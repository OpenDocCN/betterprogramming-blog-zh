<html>
<head>
<title>Create a Multi-Architecture k0s Cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建多架构k0s集群</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-multi-architecture-k0s-cluster-e265d24937b3?source=collection_archive---------9-----------------------#2020-12-30">https://betterprogramming.pub/create-a-multi-architecture-k0s-cluster-e265d24937b3?source=collection_archive---------9-----------------------#2020-12-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3e57" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">跨标准Ubuntu (amd64)和Raspberry Pi (arm64)构建k0s Kubernetes集群</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b3c672e67b9c166ff8b4a850d6102747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*715XkqWcLAiZoB8FfDp8ig.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@splashabout?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Nareeta Martin </a>在<a class="ae ky" href="https://unsplash.com/s/photos/cluster?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="04e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在之前的<a class="ae ky" href="https://medium.com/better-programming/k0s-kubernetes-in-a-single-binary-224bb43f4520" rel="noopener">文章中，</a>我们介绍了<a class="ae ky" href="https://k0sproject.io" rel="noopener ugc nofollow" target="_blank"> k0s </a>的基础知识，这是一个新的轻量级Kubernetes发行版，打包在一个Go二进制文件中。我们还使用通过<a class="ae ky" href="https://multipass.run" rel="noopener ugc nofollow" target="_blank"> Multipass </a>创建的本地虚拟机设置了一个演示集群。</p><p id="056b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇新文章中，我们将继续探索k0s，并建立一个简单的集群，其中有一个主集群和三个工作集群。工作人员将在不同的架构上运行(amd64/arm64):</p><ul class=""><li id="e170" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">master</code>:运行在<a class="ae ky" href="https://digitalocean.com" rel="noopener ugc nofollow" target="_blank">数字海洋</a>上的Ubuntu 20.04</li><li id="d4fa" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">worker1</code> : Ubuntu 20.04</li><li id="33f2" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">worker2 </code> : RPI 4运行RPI OS 64位</li><li id="b08c" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">worker3</code>:运行Alpine Linux的RPI 4</li></ul><p id="5750" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主控运行在数字海洋上，而工人运行在家庭局域网的防火墙后面。员工之间也有完整的网络连接。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="85dc" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">运行主节点</h1><p id="6203" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">主节点是运行在数字海洋基础设施上的虚拟机。是标准的Ubuntu 20.04 Linux盒子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/15f464bbb2c13ade347d5c48c1cbb69a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*az7thnxwMqbPgss5n0yTYg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用干净的网络界面在数字海洋基础设施上创建虚拟机</p></figure><p id="e2fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦虚拟机启动并运行，我们需要在其中装入一个shell，并使用以下命令安装k0s二进制文件:</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="f167" class="nw mv it mh b gy nx ny l nz oa"><strong class="mh iu">$ curl -sSLf get.k0s.sh | sudo sh<br/></strong>Downloading k0s from URL: <a class="ae ky" href="https://github.com/k0sproject/k0s/releases/download/v0.9.0/k0s-v0.9.0-arm64" rel="noopener ugc nofollow" target="_blank">https://github.com/k0sproject/k0s/releases/download/v0.9.0/k0s-v0.9.0-<strong class="mh iu">amd64</strong></a></span></pre><p id="0246" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>在上面命令的输出中，我们可以看到amd64版本已经被下载了。还有，k0s 0 . 9 . 0版本是最新的(截止到2020年12月)。</p><p id="04e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们使用默认配置将集群初始化为主节点。这个节点也可以定义为一个使用<code class="fe me mf mg mh b">--enable-worker</code>标志的工人。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="404f" class="nw mv it mh b gy nx ny l nz oa">$ k0s server</span></pre><p id="9203" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>这个命令在前台运行k0s。对于真正的生产集群，我们可以使用systemd来管理这个过程。</p><p id="50d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后从这个主机上的另一个终端，我们创建一个<code class="fe me mf mg mh b">join</code>令牌。我们需要保存这个令牌——因为我们将在接下来的步骤中使用它来添加工作节点。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="0cfb" class="nw mv it mh b gy nx ny l nz oa">$ k0s token create --role worker &gt; join.token</span></pre><p id="de4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了访问我们的新集群(它还没有任何worker节点)，我们首先需要使用在主服务器上创建的配置文件来配置我们的本地kubectl。这可以通过以下命令轻松完成:</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="bff1" class="nw mv it mh b gy nx ny l nz oa"># Get the kubeconfig file<br/>$ ssh root@$MASTER cat /var/lib/k0s/pki/admin.conf &gt; k0s.cfg</span><span id="9d62" class="nw mv it mh b gy ob ny l nz oa"># Configure kubectl<br/>$ export KUBECONFIG=$PWD/k0s.cfg</span></pre><p id="9ad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>确保将<code class="fe me mf mg mh b">localhost</code>替换为<code class="fe me mf mg mh b">k0s.cfg</code>中主节点的外部IP地址。</p><p id="09fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以访问群集并检查节点。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="7066" class="nw mv it mh b gy nx ny l nz oa"><strong class="mh iu">$ kubectl get no<br/></strong>No resources found</span></pre><p id="db43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了一个单节点集群。该节点只是一个主节点，这就是为什么上一个命令没有列出它的原因。在下一步中，我们将添加第一个worker节点。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="dcac" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">添加Ubuntu工作节点</h1><p id="4244" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">这个工人将在20.04 Ubuntu机器上运行(英特尔NUC)。</p><p id="15b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要安装k0s二进制文件，就像我们对主节点所做的那样。</p><p id="52c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们使用以下命令运行worker节点:</p><p id="8f10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>在运行这个命令之前，我们将上一步中生成的<code class="fe me mf mg mh b">join.token</code>文件复制到第一个worker节点上的<code class="fe me mf mg mh b">/tmp/join.token</code>中。使用<code class="fe me mf mg mh b">--token-file</code>选项，我们可以轻松分发令牌。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="677a" class="nw mv it mh b gy nx ny l nz oa">$ sudo k0s worker --token-file /tmp/join.token</span></pre><p id="8f0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们确保我们的第一个worker出现在节点列表中:</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="8cbc" class="nw mv it mh b gy nx ny l nz oa"><strong class="mh iu">$ kubectl get no<br/></strong>NAME      STATUS   ROLES    AGE   VERSION<br/>worker1   Ready    &lt;none&gt;   25s   v1.20.1-k0s1</span></pre><p id="aecb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以检查集群中运行的所有系统单元:</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="5add" class="nw mv it mh b gy nx ny l nz oa">$ <strong class="mh iu">kubectl get po -A</strong><br/>NAMESPACE    NAME                        READY STATUS  RESTARTS  AGE<br/>kube-system  calico-kube-controllers-... 1/1   Running 0         5m<br/>kube-system  calico-node-7nzbf           1/1   Running 0         60s<br/>kube-system  coredns-5c98d7d4d8-p96dn    1/1   Running 0         5m<br/>kube-system  konnectivity-agent-77jkp    1/1   Running 0         60s<br/>kube-system  kube-proxy-czm86            1/1   Running 0         60s<br/>kube-system  metrics-server-7d475dd-...  1/1   Running 0         5m</span></pre><p id="86cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">api-server</code>、<code class="fe me mf mg mh b">kube-controller-manager</code>和<code class="fe me mf mg mh b">kube-scheduler</code>没有在这里列出，因为它们是作为裸进程运行的(理解:它们没有在Pods中运行)。</p><p id="d6c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong> Calico是创建k0s集群时默认使用的网络插件。可以使用k0s配置文件对其进行配置，以满足特定需求。Calico是一个强大的解决方案，也是许多Kubernetes管理的网络插件。</p><p id="add1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加第一个工人真的很容易。在接下来的步骤中，我们将添加额外的运行在Raspberry Pi 4上的workers。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="ffb0" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">添加在RPI操作系统上运行的Raspberry Pi Worker</h1><p id="00e7" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们现在将添加一个运行在Raspberry Pi 4上的worker。在这一步中，我们将使用k0s的arm64版本(而amd64由主节点和第一个工作节点使用)。</p><p id="a39c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一节中，我们将看到事情变得更加复杂。这不是k0s本身造成的，而是RPI内核的默认配置造成的，我们必须重新编译。</p><h2 id="fd1d" class="nw mv it bd mw oc od dn na oe of dp ne li og oh ng lm oi oj ni lq ok ol nk om bi translated">树莓Pi操作系统的安装</h2><p id="9f38" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">首先，我们创建一个带有64位Raspberry Pi操作系统的SD卡。64位版本仍处于测试阶段，可以从这里下载<a class="ae ky" href="https://downloads.raspberrypi.org/raspios_lite_arm64/images/raspios_lite_arm64-2020-08-24/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="44ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>在本教程中，我们使用精简版，因为我们不需要桌面版。</p><p id="0957" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.raspberrypi.org/blog/raspberry-pi-imager-imaging-utility/" rel="noopener ugc nofollow" target="_blank"> Raspberry Pi Imager </a>让SD卡的制作变得非常简单，因为我们只需要:</p><ul class=""><li id="749a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">选择操作系统映像(Raspberry Pi OS Buster arm64 Lite)</li><li id="fb9e" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">选择SD卡的位置</li><li id="3ed5" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">启动副本</li><li id="edaa" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">等几分钟，放松一下，喝杯咖啡</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/6954b348e23375a6e0f55b1b0f28b85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k3ZAw86Zikxf2vcxuMV5zQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用Raspberry Pi成像仪在SD卡上刷新64位Raspberry Pi操作系统</p></figure><h2 id="449a" class="nw mv it bd mw oc od dn na oe of dp ne li og oh ng lm oi oj ni lq ok ol nk om bi translated">重建内核</h2><p id="0537" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">立即运行k0s worker会导致错误，因为内核映像中缺少一个配置选项。更具体地说，这与<a class="ae ky" href="https://www.kernel.org/doc/html/latest/scheduler/sched-bwc.html" rel="noopener ugc nofollow" target="_blank"> CFS带宽控制</a>有关，CFS带宽控制允许我们定义cgroups来限制一个进程的CPU消耗。</p><p id="961b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们必须通过提供缺失的配置选项来重建内核。这似乎是一个令人印象深刻的任务，但谷歌搜索使事情变得相对容易。</p><p id="cdc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>在64位Raspberry Pi OS 64的正式版本中，可能没有必要重新构建内核——本文将会更新以反映这些变化。</p><p id="8b56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>下面的说明直接从树莓中完成。如果想从另一台机器上构建内核(交叉编译)，还需要其他指令。</p><ul class=""><li id="bc8f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">首先，我们得到必要的工具和源代码</li></ul><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="7cc9" class="nw mv it mh b gy nx ny l nz oa">$ sudo apt install git bc bison flex libssl-dev make<br/>$ git clone --depth=1 https://github.com/raspberrypi/linux</span></pre><ul class=""><li id="2be3" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">接下来，我们使用RPI 4的配置选项</li></ul><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="93b7" class="nw mv it mh b gy nx ny l nz oa">$ cd linux<br/>$ KERNEL=kernel8<br/>$ make bcm2711_defconfig</span></pre><ul class=""><li id="80ff" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">接下来，我们需要确保下面的选项在<code class="fe me mf mg mh b">.config</code>文件中(如果它不在那里，添加它)</li></ul><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="e066" class="nw mv it mh b gy nx ny l nz oa">CONFIG_CFS_BANDWIDTH=y</span></pre><ul class=""><li id="dfd7" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们现在可以构建新的内核映像了。这一步可能需要一些时间(在我的RPI 4上大约需要30分钟)，即使<code class="fe me mf mg mh b">-j4</code>选项允许我们并行编译。</li></ul><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="68b1" class="nw mv it mh b gy nx ny l nz oa"><strong class="mh iu">ARCH=arm64</strong> make -j4 Image.gz modules dtbs</span></pre><ul class=""><li id="9055" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">接下来，我们安装/复制构建的结果</li></ul><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="1539" class="nw mv it mh b gy nx ny l nz oa">sudo make modules_install<br/>sudo cp arch/arm64/boot/dts/*.dtb /boot/<br/>sudo cp arch/arm64/boot/dts/overlays/*.dtb* /boot/overlays/<br/>sudo cp arch/arm64/boot/dts/overlays/README /boot/overlays/<br/>sudo cp arch/arm64/boot/Image /boot/$KERNEL.img</span></pre><ul class=""><li id="40b5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">最后是在<code class="fe me mf mg mh b">/boot/cmdline.txt</code>文件中添加具体的cgroup选项</li></ul><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="a89b" class="nw mv it mh b gy nx ny l nz oa">cgroup_enable=cpuset cgroup_enable=memory cgroup_memory=1 </span></pre><ul class=""><li id="06db" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">然后，我们可以重启设备</li></ul><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="5de4" class="nw mv it mh b gy nx ny l nz oa">$ sudo reboot</span></pre><p id="a699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，应该可以将此RPI作为工作节点添加到群集了。</p><h2 id="2759" class="nw mv it bd mw oc od dn na oe of dp ne li og oh ng lm oi oj ni lq ok ol nk om bi translated">作为工作节点加入</h2><p id="d34b" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">首先，我们安装k0s二进制文件，就像我们对前面的节点所做的那样。这一次，自动选择arm64版本。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="f116" class="nw mv it mh b gy nx ny l nz oa"><strong class="mh iu">$ curl -sSLf get.k0s.sh | sudo sh</strong><br/>Downloading k0s from URL: <a class="ae ky" href="https://github.com/k0sproject/k0s/releases/download/v0.9.0/k0s-v0.9.0-arm64" rel="noopener ugc nofollow" target="_blank">https://github.com/k0sproject/k0s/releases/download/v0.9.0/k0s-v0.9.0-<strong class="mh iu">arm64</strong></a></span></pre><p id="7a33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们使用之前生成的<code class="fe me mf mg mh b">join.token</code>文件将Raspberry设备添加到集群中。</p><p id="9896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>在运行这个命令之前，我们将主节点上生成的<code class="fe me mf mg mh b">join.token</code>文件复制到RPI上的<code class="fe me mf mg mh b">/tmp/join.token</code>。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="cea3" class="nw mv it mh b gy nx ny l nz oa">$ sudo k0s worker --token-file /tmp/join.token</span></pre><p id="6dc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们要确保新员工已经准备好了。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="fa25" class="nw mv it mh b gy nx ny l nz oa"><strong class="mh iu">$ kubectl get no<br/></strong>NAME      STATUS   ROLES    AGE   VERSION<br/>worker1   Ready    &lt;none&gt;   10m   v1.20.1-k0s1<br/>worker2   Ready    &lt;none&gt;   21s   v1.20.1-k0s1</span></pre><p id="0e41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步，我们将添加另一个Raspberry Pi worker——这个worker运行Alpine Linux而不是RPI OS。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f1a6" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">添加运行Alpine Linux的Raspberry PI Worker</h1><p id="14ae" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Alpine是一个著名的Linux发行版，通常用作Dockerfile文件中的基本映像。这也是一个完整的Linux发行版，可以安装在工作站和许多设备上。在下一节中，我们将在RPI上安装Alpine，并将其作为新的worker节点加入集群。</p><h2 id="c884" class="nw mv it bd mw oc od dn na oe of dp ne li og oh ng lm oi oj ni lq ok ol nk om bi translated">在RPI上安装Alpine</h2><p id="20ee" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">首先，我们需要获得Alpine Linux版本。在<a class="ae ky" href="https://alpinelinux.org/downloads/" rel="noopener ugc nofollow" target="_blank">官方Alpine Linux网站</a>的下载部分我们可以找到的版本中，有一些是专门针对树莓Pi设备的。在本文的示例中，我们使用的是aarch64版本，因为它将安装在RPI 4上(这是一个64位设备)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/928147a54c128d3c34fa4f91f262695b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3-rCYVoPrpe8000XPO3wSA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Alpine Linux可用于许多设备</p></figure><p id="ab47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>在撰写本文时，当前版本是Alpine 3.12。存档文件下载到一个名为<em class="op"> </em> <code class="fe me mf mg mh b">alpine-rpi-3.12.3-aarch64.tar</code>的文件中。</p><p id="b607" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，在一个空的micro SD卡上，我们创建一个FAT32分区，并将以前的TAR文件的内容提取到那个分区中。</p><p id="22a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以将SD卡插入RPI 4并启动它。</p><p id="85f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们运行<code class="fe me mf mg mh b">setup-alpine</code>实用程序脚本，这将有助于定义我们的Alpine发行版的主要配置:</p><ul class=""><li id="1654" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">键盘布局</li><li id="b492" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">主机名</li><li id="ab6f" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">网络接口的设置</li><li id="8d71" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">Root密码</li><li id="a22d" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">时区</li><li id="63d1" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">NTP客户端</li><li id="fd39" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">镜子</li><li id="464a" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">SSH服务器</li></ul><p id="afb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要挂载cgroups虚拟文件系统。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="7a97" class="nw mv it mh b gy nx ny l nz oa">/etc/init.d/cgroups start &amp;&amp; rc-update add cgroups boot</span></pre><p id="548d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要重新挂载<code class="fe me mf mg mh b">/media/mmcblk0p1</code>分区的读写。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="caeb" class="nw mv it mh b gy nx ny l nz oa">mount -o remount,rw /media/mmcblk0p1</span></pre><p id="edcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将允许我们在<code class="fe me mf mg mh b">/cmdline.txt</code>文件的开头添加特定的cgroup选项:</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="ad53" class="nw mv it mh b gy nx ny l nz oa">cgroup_enable=cpuset cgroup_enable=memory cgroup_memory=1</span></pre><p id="ea83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并添加一些依赖项:</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="6db1" class="nw mv it mh b gy nx ny l nz oa">apk add iptables coreutils findutils curl</span></pre><p id="e61d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是用SD卡的空闲空间创建一个新的分区。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/8824ec79b0733be5a5cab1e9a254f588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EqyxxPNPX2790EL_mytJ8Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">/dev/mmcblk0p2 ext4分区是用SD卡的可用空间创建的(本例中使用了cfdisk)</p></figure><p id="f275" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一步之后，我们的RPI将在SD卡上看到两个分区:</p><ul class=""><li id="8146" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">/dev/mmcblk0p1</code>:引导分区</li><li id="d0fd" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">/dev/mmcblk0p2</code>:我们将使用的分区为k0s提供额外的存储空间</li></ul><p id="ff59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在RAM中运行Alpine时(另一种安装方法可以通过正确的磁盘安装来完成)，我们需要提交我们的更改(通过LBU实用程序)，以便它们在重启后可用。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="3fa6" class="nw mv it mh b gy nx ny l nz oa">lbu commit -d</span></pre><p id="b7b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以重启设备:</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="136a" class="nw mv it mh b gy nx ny l nz oa">reboot</span></pre><h2 id="be7c" class="nw mv it bd mw oc od dn na oe of dp ne li og oh ng lm oi oj ni lq ok ol nk om bi translated">作为工作节点加入</h2><p id="9f4b" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">首先，我们将<code class="fe me mf mg mh b">/dev/mmcblk0p2</code>分区挂载到<code class="fe me mf mg mh b">/var/lib/k0s</code>中，这样k0s将有足够的空间来运行Pods(这与k0s的需求无关，但与我们安装Alpine的方式有关)。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="9fad" class="nw mv it mh b gy nx ny l nz oa">mkdir /var/lib/k0s<br/>mount /dev/mmcblk0p2 /var/lib/k0s</span></pre><p id="fc56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们安装k0s二进制文件，就像我们对前面的节点所做的那样。再次自动选择arm64版本。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="f558" class="nw mv it mh b gy nx ny l nz oa"><strong class="mh iu">$ curl -sSLf get.k0s.sh | sh</strong><br/>Downloading k0s from URL: Downloading k0s from URL: <a class="ae ky" href="https://github.com/k0sproject/k0s/releases/download/v0.9.0/k0s-v0.9.0-arm64" rel="noopener ugc nofollow" target="_blank">https://github.com/k0sproject/k0s/releases/download/v0.9.0/k0s-v0.9.0-<strong class="mh iu">arm64</strong></a></span></pre><p id="4e1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们使用之前生成的<code class="fe me mf mg mh b">join.token</code>文件将Raspberry设备添加到集群中。</p><p id="452f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>按照前面的步骤，在运行这个命令之前，我们需要将<code class="fe me mf mg mh b">join.token</code>文件复制到这个RPI上的<code class="fe me mf mg mh b">/tmp/join.token</code>中。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="d7cf" class="nw mv it mh b gy nx ny l nz oa">$ k0s worker --token-file /tmp/join.token</span></pre><p id="9a81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们要确保它已经准备好了。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="fefc" class="nw mv it mh b gy nx ny l nz oa"><strong class="mh iu">$ kubectl get no<br/></strong>NAME      STATUS   ROLES    AGE    VERSION<br/>worker1   Ready    &lt;none&gt;   50m    v1.20.1-k0s1<br/>worker2   Ready    &lt;none&gt;   40m    v1.20.1-k0s1<br/>worker3   Ready    &lt;none&gt;   85s    v1.20.1-k0s1</span></pre><p id="0638" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的三工作节点集群现在已经启动并准备就绪。下一步，我们将部署一个示例应用程序，并确保它工作正常。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="43ba" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">部署应用程序</h1><p id="fccd" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">首先，我们使用可用于几种架构的映像创建一个<code class="fe me mf mg mh b">DaemonSet</code>规范，并将其保存在<code class="fe me mf mg mh b">whoami.yaml</code>中。</p><p id="54cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>我们使用一个<code class="fe me mf mg mh b">DaemonSet</code>来确保在每个worker节点上部署一个Pod。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="333f" class="nw mv it mh b gy nx ny l nz oa"><strong class="mh iu">apiVersion</strong>: apps/v1<br/><strong class="mh iu">kind</strong>: DaemonSet<br/><strong class="mh iu">metadata</strong>:<br/>  <strong class="mh iu">name</strong>: whoami<br/>  <strong class="mh iu">labels</strong>:<br/>    <strong class="mh iu">app</strong>: whoami<br/><strong class="mh iu">spec</strong>:<br/>  <strong class="mh iu">selector</strong>:<br/>    <strong class="mh iu">matchLabels</strong>:<br/>      <strong class="mh iu">name</strong>: whoami<br/>  <strong class="mh iu">template</strong>:<br/>    <strong class="mh iu">metadata</strong>:<br/>      <strong class="mh iu">labels</strong>:<br/>        <strong class="mh iu">name</strong>: whoami<br/>    <strong class="mh iu">spec</strong>:<br/>      <strong class="mh iu">containers</strong>:<br/>      - <strong class="mh iu">name</strong>: whoami<br/>        <strong class="mh iu">image</strong>: <!-- -->stefanscherer/whoami</span></pre><p id="79ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们用以下命令创建这个<code class="fe me mf mg mh b">DeamonSet</code>:</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="e48a" class="nw mv it mh b gy nx ny l nz oa">$ kubectl apply -f whoami.yaml</span></pre><p id="b954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们验证每个工作人员是否正在运行一个Pod，同时检索Pod的IP地址:</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="c093" class="nw mv it mh b gy nx ny l nz oa"><strong class="mh iu">$ kubectl get po -o custom-columns=NAME:.metadata.name,NODE:.spec.nodeName,IP:.status.podIP<br/></strong>NAME           NODE      IP<br/>whoami-2hmb9   worker1   10.244.235.132<br/>whoami-69d7r   worker3   10.244.182.2<br/>whoami-8sgv5   worker2   10.244.189.67</span></pre><p id="150f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们运行一个除了等待什么也不做的测试舱。我们将验证它运行在哪个节点上(在本例中为<code class="fe me mf mg mh b">worker1</code>),并在这个新的Pod中获得一个shell。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="2643" class="nw mv it mh b gy nx ny l nz oa"># Run a new Pod based on Alpine<br/><strong class="mh iu">$ kubectl run test --image=alpine -- sleep 10000</strong></span><span id="b15d" class="nw mv it mh b gy ob ny l nz oa"># Check the host it is running on (you might get a different host)<strong class="mh iu"><br/>$ kubectl get po -o custom-columns=NAME:.metadata.name,NODE:.spec.nodeName | grep test</strong><br/>NAME   NODE<br/>test   worker1</span><span id="da6e" class="nw mv it mh b gy ob ny l nz oa"># Get a shell inside the test Pod<br/><strong class="mh iu">$ kubectl exec -ti test -- sh</strong><br/>/ #</span></pre><p id="b494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个新的单元中，我们可以确保我们可以访问每个<code class="fe me mf mg mh b">whoami</code>单元，无论它运行在哪个节点上:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/6a301839328e9265d6128f7c1f52f91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6qIAok0-ku9UnWLQogJS2A.png"/></div></div></figure><p id="99ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切正常——我们可以到达所有的<code class="fe me mf mg mh b">whoami</code>舱。这只是一个简单的例子，以确保连接工作正常。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="7106" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="8641" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在跨不同基础设施和架构的集群上运行k0s非常容易(为RPI重新编译Linux内核与k0s无关，在64位Raspberry Pi OS的正式版本中可能也没有必要)。</p><p id="a666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意一件重要的事情:我们不需要在路由器中为控制平面进程(运行在DigitalOcean VM上)和kubelet(运行在每个worker上)打开一个端口来进行通信。这一部分由连接代理管理，它在一个工作者的kubelet和API服务器之间打开一个隧道。</p><p id="d250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以从任何地方访问控制平面(当然，通过安全组)，并将数据平面隔离在防火墙之后。</p><p id="3e3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多架构集群的下一步将是添加一个运行在Windows机器(Windows Server 2019)上的额外工作节点。这将在k0s的未来版本中提供。敬请关注。</p></div></div>    
</body>
</html>