<html>
<head>
<title>Reactive Vue Routes With the Composition API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有组合API的反应性Vue路由</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/reactive-vue-routes-with-the-composition-api-18c1abd878d1?source=collection_archive---------10-----------------------#2020-04-15">https://betterprogramming.pub/reactive-vue-routes-with-the-composition-api-18c1abd878d1?source=collection_archive---------10-----------------------#2020-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2979" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">观看Vue.js路线</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b8927266d46447e233f5d01350b6491a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WEkBhChS81WTodi-GoZmUA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="95a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://vue-composition-api-rfc.netlify.com/#summary" rel="noopener ugc nofollow" target="_blank"> Vue.js组合API </a>是一组基于函数的API，允许您灵活组合组件逻辑。这对于编写可重用的逻辑和使代码组织良好非常有用。</p><p id="d191" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文将介绍如何在Vue项目中直接观察route对象。</p><p id="7eec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是GitHub中的最终代码库:<a class="ae lu" href="https://github.com/manakuro/reactive-vue-route-in-composition-api-example" rel="noopener ugc nofollow" target="_blank">manakuro/reactive-vue-route-in-composition-API-example</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="50f9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置Nuxt项目</h1><p id="2521" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">为了快速开始，我们将创建一个<a class="ae lu" href="https://nuxtjs.org/" rel="noopener ugc nofollow" target="_blank"> Nuxt </a>项目:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0d13" class="ne md it na b gy nf ng l nh ni">npx create-nuxt-app my-app</span></pre><p id="9a7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">安装后，您可以通过运行以下命令来启动dev服务器:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d211" class="ne md it na b gy nf ng l nh ni">yarn dev</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3d42" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置合成API</h1><p id="e835" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">安装合成API:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="98b4" class="ne md it na b gy nf ng l nh ni">yarn add @vue/composition-api</span></pre><p id="8461" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建一个<code class="fe nj nk nl na b">plugins/composition-api.js</code>:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="215b" class="ne md it na b gy nf ng l nh ni">import Vue from 'vue'<br/>import VueCompositionApi from '@vue/composition-api'<br/><br/>Vue.use(VueCompositionApi)</span></pre><p id="d547" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将其添加到<code class="fe nj nk nl na b">nuxt.config.js</code>中的插件:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c20c" class="ne md it na b gy nf ng l nh ni">plugins: ['~/plugins/composition-api'],</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0d16" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">添加设置功能</h1><p id="613b" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">既然我们可以在SFC中使用组合API，那么让我们来利用这个特性。</p><p id="3171" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们有一个按钮，可以像这样更改URL中的查询参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="82fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您想在设置功能中使用<code class="fe nj nk nl na b">route</code>时，您可以通过<code class="fe nj nk nl na b">ctx</code>来访问它，它包括Vue实例对象。</p><p id="8da3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看它是如何工作的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/6646082356aacee1e8a0c1d81f0a2a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*s2ydJ1D10b4jPg3R-5rO-A.gif"/></div></div></figure><p id="ab08" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我以为点击按钮后文本会变成<code class="fe nj nk nl na b">React Router query: handle my query!</code>。但它没有改变，因为路由对象只是一个普通的对象，而不是一个反应性的对象。</p><p id="aa44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了使它工作，我们需要通过传递一个引用来使路由具有反应性。</p><p id="e5c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将代码更改为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="06b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们添加了一个reactive <code class="fe nj nk nl na b">state</code>，包括route对象。<code class="fe nj nk nl na b">reactive</code>函数等于<code class="fe nj nk nl na b">Vue.observable</code>，使一个对象具有反应性。在内部，Vue在由<code class="fe nj nk nl na b">data</code>函数返回的对象上使用它。</p><p id="06c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们通过使用<code class="fe nj nk nl na b">watch</code>函数使<code class="fe nj nk nl na b">$route</code>可见，因为我们需要在<code class="fe nj nk nl na b">$router</code>改变一些东西后用一个新的对象更新<code class="fe nj nk nl na b">state.route</code>对象。</p><p id="6a80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看它是如何工作的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/ec2c9b404f66db3e945e2d7354a6fe7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3coI-mXh3XEdyrLgKdymPQ.gif"/></div></div></figure><p id="8326" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很好。效果很好。</p><p id="adc0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经完成了，我们想让路线在整个项目中更容易重用。</p><p id="a9b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我们将提取代码并创建<code class="fe nj nk nl na b">useRouter</code>作为钩子函数。</p><p id="389e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建<code class="fe nj nk nl na b">hooks/useRouter.ts</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d728" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nj nk nl na b">toRefs</code>在从组合函数中返回反应对象时非常有用，可以在不损失反应性的情况下析构返回的对象。</p><p id="2f25" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们编辑Vue文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8c4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很好！这是一个非常具有声明性的函数，使它更容易重用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a213" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="5673" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们已经介绍了如何使用复合API来观察route对象。组合API的关键思想是使代码有组织、可读和可重用。如果你发现自己在设置函数中写了一堆代码，就试着按关注点分开，创建一个<code class="fe nj nk nl na b">useXXX</code>函数来重用它。你可以在GitHub上看到<a class="ae lu" href="https://gist.github.com/yyx990803/8854f8f6a97631576c14b63c8acd8f2e" rel="noopener ugc nofollow" target="_blank">一些代码</a>的例子。</p><p id="2356" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这能对你有所帮助。</p><p id="b920" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是GitHub中的最终代码库:<a class="ae lu" href="https://github.com/manakuro/reactive-vue-route-in-composition-api-example" rel="noopener ugc nofollow" target="_blank">manakuro/reactive-vue-route-in-composition-API-example</a>。</p></div></div>    
</body>
</html>