<html>
<head>
<title>How Programming Language Interpterers Execute Your Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编程语言解释器如何执行你的代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-language-interpterers-execute-your-programs-450a6837dee4?source=collection_archive---------13-----------------------#2022-01-03">https://betterprogramming.pub/how-language-interpterers-execute-your-programs-450a6837dee4?source=collection_archive---------13-----------------------#2022-01-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="de71" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解Python、JavaScript和Java等语言是如何工作的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/55c6086ea1d5e80ca17b6bdd3c8e66da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G7d1y2Ey1bwQiA-kDmRJVA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a0a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你有没有想过你的源代码是如何被执行的？有许多方法可以做到这一点，但使用口译员是最简单的选择之一。一个<a class="ae lu" href="https://en.wikipedia.org/wiki/Interpreter_(computing)" rel="noopener ugc nofollow" target="_blank">解释器</a>是一个软件，它以源代码作为输入，直接执行程序中描述的操作，而不需要先编译成<a class="ae lu" href="https://en.wikipedia.org/wiki/Machine_code" rel="noopener ugc nofollow" target="_blank">机器码</a>。</p><p id="9c99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解释器在现代软件开发中变得非常流行，特别是得益于像Python和JavaScript这样的语言。它们允许程序员轻松地表达概念，而不需要指定数据类型并立即运行他们的程序，而不必等待源代码被编译成CPU可以理解的格式。</p><p id="b985" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，同一个程序可以在多个平台上运行，因为兼容性是由解释器自带的<a class="ae lu" href="https://en.wikipedia.org/wiki/Virtual_machine" rel="noopener ugc nofollow" target="_blank">虚拟机</a>保证的。</p><h1 id="a35f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">口译员如何在高水平上工作</h1><p id="8abf" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">有许多类型的解释器，从数学(又名计算器)，到CPU，甚至是自然语言解释器。但是，它们的工作原理基本相同。将源代码翻译成<a class="ae lu" href="https://en.wikipedia.org/wiki/Machine_code" rel="noopener ugc nofollow" target="_blank">机器指令</a>的复杂任务被分成更小更简单的步骤，以链式方式一个接一个地执行:加载源代码，对源代码进行标记，将标记解析成语法树，可选地生成字节码表示，最后执行程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9d72a96db02b6d48bf0f4932ea85c0a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9qcbp82QJnUUtK0f8jWOUg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">解释链。图片由作者提供，<a class="ae lu" href="https://pngtree.com/freepng/traffic-lights-quanmie_2210914.html?sol=downref&amp;id=bef" rel="noopener ugc nofollow" target="_blank">红绿灯</a>由artwant提供，<a class="ae lu" href="https://pngtree.com/freepng/finish-line-icon-simple-style_5254975.html?sol=downref&amp;id=bef" rel="noopener ugc nofollow" target="_blank">完成标志</a>由Ylivdesig提供，来自<a class="ae lu" href="https://pngtree.com/" rel="noopener ugc nofollow" target="_blank"> pngtree </a> <strong class="bd ms">。</strong></p></figure><p id="433f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将详细介绍每个阶段所涉及的内容。在下一篇文章中，我将展示如何用代码实现一个解释器。</p><h1 id="76f2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">加载源代码</h1><p id="88e0" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这是解释的第一步，也是最简单的一步。它包括获取用户想要运行的源代码。可以通过从磁盘加载一个或多个文件，或者通过在<a class="ae lu" href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop" rel="noopener ugc nofollow" target="_blank">读取-评估-打印循环</a>(也称为交互式shell)中请求用户输入来获取。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/20b2d27ae29d629fb0e38f77b4931666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*T4kwb6aG5ewTTHWApOQtkg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python REPL的例子。</p></figure><p id="c5c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个操作的输出通常是一个包含要运行的源代码的字符串，它将被传递到解释链的下一个环节。</p><h1 id="3bfe" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">将源代码符号化</h1><p id="e327" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/Lexical_analysis" rel="noopener ugc nofollow" target="_blank">记号化</a>，或词法分析，是将字符串源代码等字符序列转换成<a class="ae lu" href="https://en.wikipedia.org/wiki/Lexical_analysis#Token" rel="noopener ugc nofollow" target="_blank">记号</a>序列的过程。记号是语言中仍然有意义的最小单位，可以是单词、标点符号或运算符。</p><p id="2419" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更具体地说，下面是一个标记化代码语句的示例:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="147a" class="mz lw it mv b gy na nb l nc nd">// Source code<br/>int var = 1;</span><span id="e286" class="mz lw it mv b gy ne nb l nc nd">// Tokens separated by '|'<br/>int | var | = | 1 | ;</span></pre><p id="0099" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">令牌可以有各种属性，但它们的基本定义是:</p><ul class=""><li id="e4ee" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">一个<strong class="la iu">类型</strong>，或者这个令牌代表什么。标记类型是由语言实现定义的，但一般来说，它们围绕着数字、字符串、标识符、运算符和关键字。</li></ul><p id="ba2b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">令牌的类型稍后用于解释其值。类型可以比作自然语言中的<a class="ae lu" href="https://en.wikipedia.org/wiki/Part_of_speech" rel="noopener ugc nofollow" target="_blank">词类</a>，比如副词、名字或者介词。</p><ul class=""><li id="906a" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">一个<strong class="la iu">值</strong>，或者说这个令牌是什么意思。值可以是任何东西，从数字到复杂的数据结构。它们可以被认为是自然语言中一个词的意思，就像“狗”这个词确定了狗的概念一样。</li><li id="d4f3" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">一个<strong class="la iu">优先级</strong>，或者何时应该评估令牌。它通常表示为一个数字，取决于令牌的类型及其在代码中的位置。</li></ul><p id="277f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">优先权可以比作你解释词义的顺序。比如你理解“快狗追可爱猫”这句话里，“快”和“可爱”这两个字分别跟“狗”和“猫”走，并没有所谓的“可爱追”，或者“快了”。</p><p id="143e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了让这一点更清楚，让我们标记一下我之前展示的代码行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/91d3fb67389170a671803117709a2047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2adGcAWAfZpSw3C3guJCww.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">令牌化代码语句表。</p></figure><p id="eacb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您所看到的，像<code class="fe nu nv nw mv b"><strong class="la iu">var</strong></code>和<code class="fe nu nv nw mv b"><strong class="la iu">1</strong></code>这样的标记的优先级为0，因为它们不会被执行。否则，操作“1”会做什么？</p><p id="f837" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在标记化阶段的最后，我们获得一个标记序列。由于解释器不能理解一个简单的字符串，源代码不得不逐渐采取一种更结构化的形式，每次都更接近计算机程序能够理解的形式，从而执行。</p><h1 id="eac4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">解析令牌</h1><p id="22e2" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这一步是将上一步生成的标记组织成一个层次结构，称为<a class="ae lu" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank">抽象语法树</a>。它是“抽象的”,因为它不代表原始语法的细节，而是源代码的高级视图。</p><p id="e23c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在解析阶段，我们将需要使用令牌的优先级及其类型，以便将它们组织成树状结构。具有最高优先级的令牌首先被求值，而正如我之前提到的，零优先级意味着令牌不会被求值。</p><p id="750c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，让我们确定具有最高优先级的令牌:<code class="fe nu nv nw mv b">int</code>。然后我们要问问自己<code class="fe nu nv nw mv b">int</code>需要什么。这就是令牌类型派上用场的时候:因为<code class="fe nu nv nw mv b">int</code>令牌是一个变量类型声明操作符，它需要一个变量来声明。标识符标记<code class="fe nu nv nw mv b">var</code>恰好就在它旁边，所以它将被作为语法树中<code class="fe nu nv nw mv b">int</code>的子元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/3d09d0ec718a1efc5043beb6abdaba04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-dQJD0rPpeAm1t4e3Zr-6A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">"<strong class="bd ms"> int </strong>"在语法树中以"<strong class="bd ms"> var </strong>"为子。</p></figure><p id="2b2b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每当考虑解析一个令牌时，为了不再考虑它，它的优先级被设置为0。所以，现在<code class="fe nu nv nw mv b">int</code>的优先级是0。接下来，具有最高优先级值的令牌是<code class="fe nu nv nw mv b">=</code>(为1)，它需要两个操作数:一个值和一个用于赋值的标识符(变量)。和以前一样，令牌<code class="fe nu nv nw mv b">=</code>从令牌列表中提取它的孩子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/8d60a36c25af25252bf7eeb399d7cd29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*OxXTGEFW7zdpEti8xJDdpg.png"/></div></figure><p id="35e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，树开始呈现类似程序逻辑结构的形状:<code class="fe nu nv nw mv b"><strong class="la iu">=</strong></code>标记将值<code class="fe nu nv nw mv b"><strong class="la iu">1</strong></code> <strong class="la iu"> </strong>赋给由<code class="fe nu nv nw mv b"><strong class="la iu">int</strong></code>声明的变量<code class="fe nu nv nw mv b"><strong class="la iu">var</strong></code>。最后一个标记<code class="fe nu nv nw mv b"><strong class="la iu">;</strong></code>可以简单地丢弃，因为它表示代码语句的结束。</p><p id="9fd7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">圆括号的使用通过提高它们所包含的标记的优先级来改变操作的顺序。</p><h1 id="ae22" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">生成字节码</h1><p id="0410" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/Bytecode" rel="noopener ugc nofollow" target="_blank">字节码</a>是一种指令集形式，旨在由解释器高效执行。它由一系列字节组成，简洁地描述了程序的行为，就像机器指令一样。</p><p id="d5ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从语法树生成字节代码表示是可选的，但是极大地提高了解释器的性能，因为它可以直接执行指令，而不必对代码执行任何耗时的语法或逻辑分析。</p><p id="66e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">字节码的另一个优点是可重用性:您可以在程序第一次运行时生成它，然后将其存储在一个文件中。当程序第二次执行时，解释器首先查找这个文件，以避免将源代码再次标记和解析成语法树。</p><p id="608d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Java和Python等流行语言使用这种方法，分别在<code class="fe nu nv nw mv b">target</code>文件夹中生成<code class="fe nu nv nw mv b">.class</code>文件，在<code class="fe nu nv nw mv b">__pycache__</code>文件夹中生成<code class="fe nu nv nw mv b">.pyc</code>文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/ebfe23cb73e191c42b22b196777aacf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s1uP8Id8zQDSu3jjIWs21g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python缓存字节码示例。</p></figure><p id="94b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个字节码指令分为两个主要部分:</p><ul class=""><li id="b322" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">Operator，或<a class="ae lu" href="https://en.wikipedia.org/wiki/Opcode" rel="noopener ugc nofollow" target="_blank"> opcode </a>，一个1字节的值，标识要执行的操作，如加法。哪个操作码对应哪个操作是由解释器的架构定义的。</li><li id="c4b7" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">操作数，一个可变大小的字节序列，表示操作符应该对什么执行操作。</li></ul><p id="1e9c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，语句<code class="fe nu nv nw mv b">int var = 1;</code>可以编码成如下所示。请注意，这是一个虚拟示例，并不对应于任何特定的字节码规范。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/a8aadcb795a99413155b3e9a26eb2dcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V-qgR0y2I5KotD3s5l9-7Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“int var = 1；”的字节码示例</p></figure><p id="0978" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中1字节操作码<code class="fe nu nv nw mv b">43</code>对应于将给定数量的字节推入到<a class="ae lu" href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">堆栈</a>中的操作，而<code class="fe nu nv nw mv b">04 00 00 … </code>是一个8字节数，它指定了要推入的字节数量；记住4个字节是<code class="fe nu nv nw mv b">int</code>数据类型的大小。</p><p id="fc7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，操作码<code class="fe nu nv nw mv b">02</code>负责将位于指定堆栈地址的字节(<code class="fe nu nv nw mv b">00 00 00 …</code>，对应于新推入的字节)设置为给定值(<code class="fe nu nv nw mv b">01 00 00 00</code>)。</p><h1 id="5093" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">执行程序</h1><p id="e0cf" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">作为最后一步，生成的程序表示被馈送到虚拟机，这是一个负责模拟物理计算机系统功能的软件，如<a class="ae lu" href="https://en.wikipedia.org/wiki/Java_virtual_machine" rel="noopener ugc nofollow" target="_blank"> JVM </a>。</p><p id="f063" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">语法树和字节码都可以执行，但是它们的处理方式不同。</p><h1 id="b499" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">执行字节代码</h1><p id="ae5d" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这个过程相当简单:您必须将一个函数映射到每个操作码。基于该操作，VM还加载一定数量的表示操作数的字节。然后，它执行该操作并将结果(如果有的话)存储在虚拟<a class="ae lu" href="https://en.wikipedia.org/wiki/Processor_register" rel="noopener ugc nofollow" target="_blank">寄存器</a>中，用于在<a class="ae lu" href="https://en.wikipedia.org/wiki/Instruction_cycle" rel="noopener ugc nofollow" target="_blank">获取-解码-执行周期</a>中使用的下一条指令。</p><p id="516b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这通常是首选的方法，因为它比解释语法树更有效。然而，它要求你要么从头构建一个新的VM，要么学习现有的字节码规范，例如，<a class="ae lu" href="https://en.wikipedia.org/wiki/Kotlin_(programming_language)" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>运行在JVM上，尽管它是为Java设计的。</p><h1 id="742d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">执行语法树</h1><p id="ff4f" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这个过程包括递归地执行由语法树表示的操作，从叶节点开始，逐步沿分支向上，直到根节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/868b081ce3f6036f0083e19e75fcf612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fkT3jzjoU5cscJ0qyY-wjQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">语法树执行工作流。</p></figure><p id="49f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对代码中的每一条语句重复这个过程。您可能已经注意到，除了执行字节码之外，还涉及到更多的步骤，因此这种方法要慢得多。另一方面，它通常更容易用代码实现，并且不需要太多关于CPU如何工作的知识。</p><h1 id="5523" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="2e64" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这是对解释器在运行源代码时所经历的步骤的高级解释。在下一篇文章中，我将介绍如何从头开始编写一个解释器。</p><p id="68b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢这本书。如果你有任何问题或补充，请在评论中分享。感谢阅读！</p><p id="ab24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你对这个领域感兴趣，我建议你看看这个关于如何编写数学解释器的指南:</p><div class="oc od gp gr oe of"><a rel="noopener  ugc nofollow" target="_blank" href="/programming-a-calculator-to-solve-complex-numerical-expressions-75d228f37ebf"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">编写计算器程序来解决复杂的数字表达式</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">计算器与编译器和解释器有许多共同之处。通过代码示例和算法探索细节…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">better编程. pub</p></div></div><div class="oo l"><div class="op l oq or os oo ot ks of"/></div></div></a></div></div></div>    
</body>
</html>