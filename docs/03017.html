<html>
<head>
<title>Equality and Comparison in Java: Pitfalls and Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的相等性和比较:陷阱和最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/equality-and-comparison-in-java-pitfalls-and-best-practices-96b713e7009?source=collection_archive---------7-----------------------#2020-01-15">https://betterprogramming.pub/equality-and-comparison-in-java-pitfalls-and-best-practices-96b713e7009?source=collection_archive---------7-----------------------#2020-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="edee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">仅仅因为它“平等”，并不意味着它是平等的。如何正确地比较对象和原语</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5971c813502fc1d6ba5ff4987b1cfd18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Es7wZJ9zWFZ3Yv6fjyJs8Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@jhaland?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">约根·哈兰</a>在<a class="ae ky" href="https://unsplash.com/s/photos/twins?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8bff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java有不同的比较对象和原语的方法，每种方法都有自己的语义。使用“错误的”会导致意想不到的结果，并可能引入微妙的、难以捕捉的错误。</p><p id="670a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们了解Java中的陷阱<em class="lv"> </em>和相等与比较的最佳实践之前，我们需要理解不同类型及其行为。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ad3b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">原语与对象</h1><p id="6c0d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Java类型系统是双重的，由八个<a class="ae ky" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" rel="noopener ugc nofollow" target="_blank">原始数据类型</a> ( <code class="fe na nb nc nd b">boolean</code>、<code class="fe na nb nc nd b">byte</code>、<code class="fe na nb nc nd b">char</code>、<code class="fe na nb nc nd b">short</code>、<code class="fe na nb nc nd b">int</code>、<code class="fe na nb nc nd b">long</code>、<code class="fe na nb nc nd b">float</code>、<code class="fe na nb nc nd b">double</code>)和对象引用类型组成。</p><h2 id="bfd4" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">基元</h2><p id="af24" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Java中的原语不能是未初始化的或者<code class="fe na nb nc nd b">null</code>，它们总是有一个默认值。它代表<code class="fe na nb nc nd b">0</code>，适用于特定的数据类型:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="b868" class="ne me it nd b gy nu nv l nw nx"> Primitive | Default Value <br/>-----------|--------------- <br/> boolean   | false<br/> byte      | 0<br/> char      | '\u0000'<br/> short     | 0<br/> int       | 0<br/> long      | 0l<br/> float     | 0.0f<br/> double    | 0.0d</span></pre><h2 id="efb2" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">原始包装类</h2><p id="9ae6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">每个原始数据类型在<code class="fe na nb nc nd b">java.lang</code>中都有一个对应的包装类，将其值封装在一个Java对象中:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="5843" class="ne me it nd b gy nu nv l nw nx"> Primitive | Wrapper | Superclass<br/>-----------|---------|------------<br/> boolean   | Boolean | Object<br/> byte      | Byte    | Number<br/> char      | Char    | Object<br/> short     | Short   | Number<br/> int       | Int     | Number<br/> long      | Long    | Number<br/> float     | Float   | Number<br/> double    | Double  | Number</span></pre><p id="a75d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成为对象允许它们在更广泛的场景中使用:</p><ul class=""><li id="e20e" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">通用类型(如<code class="fe na nb nc nd b">List&lt;Integer&gt;</code>)。</li><li id="a6ca" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">按引用传递而不是按值传递。</li><li id="b3ae" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">能力为空。</li><li id="60f0" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">等等。</li></ul><p id="ce99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们也必须处理所有的不利因素。像<code class="fe na nb nc nd b">NullPointerException</code>，更大的内存占用和性能影响。</p><h2 id="985f" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">自动装箱和拆箱</h2><p id="7629" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在我们了解平等和比较之前，我们需要了解的最后一件事是<a class="ae ky" href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html" rel="noopener ugc nofollow" target="_blank">拳击</a>。</p><p id="f3d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管原语和对象引用具有不同的语义，但由于Java编译器，它们可以互换使用。</p><p id="3185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">自动装箱</em>是原语类型在其对应包装类中的自动转换，<em class="lv">拆箱</em>是另一个方向。这使得我们可以不加区别地使用这两种类型:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="72cc" class="ne me it nd b gy nu nv l nw nx">List&lt;Integer&gt; values = new ArrayList&lt;&gt;();</span><span id="ef02" class="ne me it nd b gy om nv l nw nx">for (int i = 0; i &lt; 50; i++&gt;) {<br/>    values.add(i);<br/>}</span></pre><p id="3cb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe na nb nc nd b">List</code>使用包装器类型<code class="fe na nb nc nd b">Integer</code>，但是我们的代码会编译，即使我们添加了一个<code class="fe na nb nc nd b">int</code>。多亏了编译器通过自动装箱<code class="fe na nb nc nd b">i</code>来改变我们的代码，这才成为可能:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="0858" class="ne me it nd b gy nu nv l nw nx">List&lt;Integer&gt; values = new ArrayList&lt;&gt;();</span><span id="cd84" class="ne me it nd b gy om nv l nw nx">for (int i = 0; i &lt; 50; i++&gt;) {<br/>    values.add(Integer.valueOf(i));<br/>}</span></pre><p id="6d4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反之亦然:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="0b92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管我们使用了像<code class="fe na nb nc nd b">%</code>和<code class="fe na nb nc nd b">+</code>这样的操作符，但这些操作符对于对象类型<code class="fe na nb nc nd b">Integer</code>来说是不可用的，代码编译得很好。因为编译器<em class="lv">拆箱</em>包装器类型。实际编译的代码看起来更像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8ba8" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">平等</h1><p id="dba4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果我们看看其他编程语言，对于如何比较值，最符合逻辑的结论可能是<code class="fe na nb nc nd b">==</code>操作符和它的对手<code class="fe na nb nc nd b">!=</code>。</p><p id="539f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，我们可以用它们来检查相等性，它们相互比较值，但是它可能不是你期望的值。</p><h2 id="169f" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">基元</h2><p id="e828" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">原语是<a class="ae ky" href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10" rel="noopener ugc nofollow" target="_blank"> <em class="lv">文字</em> </a>，内存中的固定值，可以用<code class="fe na nb nc nd b">==</code>测试是否相等。</p><p id="4f6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除非他们不能。</p><p id="3e16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与其他原始数据类型相比，浮点数据类型<code class="fe na nb nc nd b">float</code>和<code class="fe na nb nc nd b">double</code>由于其在内存中的<a class="ae ky" href="https://en.wikipedia.org/wiki/IEEE_754" rel="noopener ugc nofollow" target="_blank">存储方法，无法可靠地检查其是否与<code class="fe na nb nc nd b">==</code>相等。它们不是精确的值:</a></p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="79be" class="ne me it nd b gy nu nv l nw nx">float value = 1.0f;<br/>value += 0.1f;      <em class="lv">// 1.1f</em><br/>value += 0.1f;      <em class="lv">// 1.2f</em><br/>value += 0.1f;      <em class="lv">// 1.3000001f</em></span><span id="6a50" class="ne me it nd b gy om nv l nw nx">boolean isEqual = (value == 1.3f) <em class="lv">// false</em></span></pre><p id="eee0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有两个选择来处理这件事。要么使用<code class="fe na nb nc nd b">java.util.BigDecimal</code>，也就是<em class="lv">确切的说是</em>。或者通过使用基于阈值的比较:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="ac1f" class="ne me it nd b gy nu nv l nw nx">float value = 1.0f;<br/>value += 0.1f;      <em class="lv">// 1.1f</em><br/>value += 0.1f;      <em class="lv">// 1.2f</em><br/>value += 0.1f;      <em class="lv">// 1.3000001f</em></span><span id="15ec" class="ne me it nd b gy om nv l nw nx">float THRESHOLD = 0.00001f;<br/>boolean isEqual = Math.abs(value - 1.3f) &lt; THRESHOLD); <em class="lv">// true</em></span></pre><h2 id="143a" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">数组</h2><p id="7329" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">另一个陷阱是基本数组，因为数组不是基本类型，它们是对象。</p><h2 id="ada8" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">目标</h2><p id="6bff" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果用<code class="fe na nb nc nd b">==</code>比较对象，它也会比较对象的值。这里唯一的问题是对象的值实际上是它的引用，因此得名<em class="lv">对象引用类型</em>。</p><p id="5020" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着只有当两个值指向内存中的同一个对象时，它们才相等。</p><p id="2ba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，变量在某些情况下可能相等，但在其他情况下不相等:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="9c06" class="ne me it nd b gy nu nv l nw nx">String a = "a";<br/>String b = "b";<br/>String ab = "ab";</span><span id="9331" class="ne me it nd b gy om nv l nw nx">boolean result1 = (a == "a");      <em class="lv">// true</em><br/>boolean result2 = (ab == "ab");    <em class="lv">// true</em><br/>boolean result3 = (a + b == "ab"); <em class="lv">// false</em></span></pre><p id="c404" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译器和JVM可能会优化字符串常量，所以<code class="fe na nb nc nd b">result2</code>就是<code class="fe na nb nc nd b">true</code>。而<code class="fe na nb nc nd b">result3</code>是<code class="fe na nb nc nd b">false</code>，因为<code class="fe na nb nc nd b">a + b</code>在内存中创建了一个新的对象。所有这些都依赖于实现，并且在不同的JVM之间有所不同。</p><p id="98e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个“不太明显”的缺陷可能发生在原始包装类型上:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="7977" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么？这个也让我大吃一惊。</p><p id="9b46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#valueOf(int)" rel="noopener ugc nofollow" target="_blank">java.util.Integer</a></code>和<code class="fe na nb nc nd b"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html#valueOf(long)" rel="noopener ugc nofollow" target="_blank">java.util.Long</a> </code>的<code class="fe na nb nc nd b">valueOf(...)</code>方法实际上缓存了特定范围(-128到127)的值，使得<code class="fe na nb nc nd b">a</code>和<code class="fe na nb nc nd b">b</code>成为同一个对象，而<code class="fe na nb nc nd b">c</code>和<code class="fe na nb nc nd b">d</code>不是。而且感谢拆箱，<code class="fe na nb nc nd b">equalAgain</code>就是<code class="fe na nb nc nd b">true</code>。</p><h2 id="aaed" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">Object.equals(Object other)和Object hashCode()</h2><p id="ebad" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe na nb nc nd b">java.lang.Object</code>类为其所有子类提供了一个<code class="fe na nb nc nd b">equals</code>方法，实现非常简单:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="639f" class="ne me it nd b gy nu nv l nw nx">public boolean equals(Object obj) {<br/>    return (this == obj);<br/>}</span></pre><p id="b160" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，我们的每一个类型都继承了对象引用的“有问题的”比较。为了能够将<code class="fe na nb nc nd b">equals</code>用于<em class="lv">实际的</em>相等，我们需要在我们的类型中覆盖它，使<a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)" rel="noopener ugc nofollow" target="_blank">具有某些属性</a>:</p><ul class=""><li id="47ed" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">反身性:一个物体应该与自身相等:<code class="fe na nb nc nd b">obj.equals(obj) == true</code>。</li><li id="745e" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">对称:如果<code class="fe na nb nc nd b">a.equals(b) == true</code>，那么<code class="fe na nb nc nd b">b.equals(a)</code>也必须是<code class="fe na nb nc nd b">true</code>。</li><li id="603a" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">传递性:如果<code class="fe na nb nc nd b">a.equals(b) == true</code>和<code class="fe na nb nc nd b">b.equals(c) == true</code>，那么<code class="fe na nb nc nd b">a.equals(c)</code>应该是<code class="fe na nb nc nd b">true</code>。</li><li id="aba8" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">一致:<code class="fe na nb nc nd b">a.equals(b)</code>对于未修改的对象应该总是有相同的值。</li><li id="4a6a" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">空处理:<code class="fe na nb nc nd b">a.equals(null)</code>应该是<code class="fe na nb nc nd b">false</code>。</li><li id="c4e4" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">散列码:相等的对象必须有相同的散列码。</li></ul><p id="5304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们提供自己的<code class="fe na nb nc nd b">equals</code>方法，我们也需要覆盖<code class="fe na nb nc nd b">hashCode</code>。</p><p id="2fdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从Java 7开始，类<code class="fe na nb nc nd b"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/util/Objects.html" rel="noopener ugc nofollow" target="_blank">java.util.Objects</a></code>为简化我们的代码提供了帮助:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="5d75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意第19行的类比较。我们可能倾向于使用<code class="fe na nb nc nd b">instanceof</code>来比较对象，但是这可能违反了<code class="fe na nb nc nd b">equals</code>和<code class="fe na nb nc nd b">hashCode</code>之间的一般约定:相等的对象必须有相同的散列码。</p><p id="a5cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们可以设计我们的对象，即使子类也等于它们的父类。但是两者相等的定义必须相同，哈希代码计算必须发生在基类中。</p><p id="917d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类<code class="fe na nb nc nd b">java.util.Date</code>及其子类<code class="fe na nb nc nd b">java.sql.Date</code>就是这样定义的。<code class="fe na nb nc nd b">sql</code>版本没有<code class="fe na nb nc nd b">equal</code>或<code class="fe na nb nc nd b">hashCode</code>方法，基类仅从时间戳构建它的哈希代码。</p><p id="128f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再比如集合类:<code class="fe na nb nc nd b">java.util.ArrayList</code>和<code class="fe na nb nc nd b">java.util.LinkedList</code>都是<code class="fe na nb nc nd b">java.util.AbstractList</code>的子类，使用它的<code class="fe na nb nc nd b">equal</code>和<code class="fe na nb nc nd b">hashCode</code>方法。集合的相等性大多数时候是由它们内容的相等性定义的，所以使用<code class="fe na nb nc nd b">instanceof</code>而不是硬类检查似乎是合适的。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="914f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">比较</h1><p id="5ed2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">仅仅测试平等是远远不够的。其他重要的操作是值的比较。</p><h2 id="986d" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">基元</h2><p id="abed" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">像在其他语言中一样，我们可以用<code class="fe na nb nc nd b">&lt;</code>、<code class="fe na nb nc nd b">&gt;</code>、<code class="fe na nb nc nd b">&lt;=</code>和<code class="fe na nb nc nd b">&gt;=</code>操作符来比较原语的值。</p><p id="8a72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">浮点数据类型的同样问题也适用于它们，所以要注意。另外，<code class="fe na nb nc nd b">boolean</code>除了与<code class="fe na nb nc nd b">==</code>和<code class="fe na nb nc nd b">!=</code>相等之外，没有可比性。</p><h2 id="4c3a" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">java.lang.Comparable <t/></h2><p id="1963" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">对象不支持这些运算符。为了比较对象类型，我们需要实现接口<code class="fe na nb nc nd b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html" rel="noopener ugc nofollow" target="_blank">java.lang.Comparable&lt;T&gt;</a></code>及其单一方法<code class="fe na nb nc nd b">int compareTo(T)</code>。</p><p id="64b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">left.compareTo(right)</code>的结果应该如下:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="ae8c" class="ne me it nd b gy nu nv l nw nx"> Result | Meaning / Order<br/>--------|---------------------------<br/>  0     | left is the same as right<br/> -1     | left &lt; right<br/>  1     | left &gt; right</span></pre><p id="21b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果代表了我们这种类型的自然顺序，而不仅仅是算术上的可比性。这样，我们可以使我们类型的集合可排序。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="61d1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">最佳实践</h1><p id="8c7d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在比较相等值或它们的自然顺序时，我们应该遵循一些简单的规则，以免得到错误的结果。</p><h2 id="5ade" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">从不与==比较对象</h2><p id="e414" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">只有当它是同一个对象时才有效。具有相同值的不同对象<em class="lv">不</em>相等。总是使用<code class="fe na nb nc nd b">boolean equals(Object other)</code>来比较是否相等。</p><h2 id="9502" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">始终执行<code class="fe na nb nc nd b">equals</code>和<code class="fe na nb nc nd b">hashCode if needed</code></h2><p id="a991" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了使类型可测试相等性，我们需要同时实现<code class="fe na nb nc nd b">equals</code> <em class="lv">和</em> <code class="fe na nb nc nd b">hashCode</code>来确保正确和一致的行为。</p><h2 id="67c5" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">浮点数据类型并不精确</h2><p id="64b1" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">永远记住，浮点数据类型并不精确，也更难比较。</p><p id="c4dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们需要处理十进制数值，并且需要绝对精度，我们应该总是使用<code class="fe na nb nc nd b">java.util.BigDecimal</code>。但是要知道它的<code class="fe na nb nc nd b">equals</code>是基于它的精度:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="f985" class="ne me it nd b gy nu nv l nw nx">BigDecimal a = new BigDecimal("2.0");<br/>BigDecimal b = new BigDecimal("2.0");<br/>BigDecimal c = new BigDecimal("2.00");</span><span id="4964" class="ne me it nd b gy om nv l nw nx">boolean equal    = a.equals(b); // true<br/>boolean notEqual = a.equals(c); // false</span></pre><p id="f7be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们需要更轻松的比较，我们可以使用<code class="fe na nb nc nd b">compareTo</code>:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="bab5" class="ne me it nd b gy nu nv l nw nx">BigDecimal a = new BigDecimal("2.0");<br/>BigDecimal b = new BigDecimal("2.0");<br/>BigDecimal c = new BigDecimal("2.00");</span><span id="9833" class="ne me it nd b gy om nv l nw nx">boolean equal = a.equals(b);    <em class="lv">// true</em><br/>int result    = a.compareTo(c); <em class="lv">// 0</em></span></pre><p id="b232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与原始操作相比,<code class="fe na nb nc nd b">BigDecimal</code> API并不漂亮，主要是因为它的不变性。但那其实是好事，正确先于美丽。</p><h2 id="a3c5" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">注意自动装箱/拆箱</h2><p id="61d4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">因为编译器在幕后完成这项工作，我们必须确保比较原语或包装对象，这要归功于<code class="fe na nb nc nd b">Integer</code> / <code class="fe na nb nc nd b">Long</code>缓存。</p><p id="9c14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了100%确定，我们可以使用包装器类型的<code class="fe na nb nc nd b">Comparable&lt;T&gt;#compareTo(T)</code>,它总是使用封装的值，而不是对象引用。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b882" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">资源</h1><ul class=""><li id="4411" class="ny nz it lb b lc mv lf mw li op lm oq lq or lu od oe of og bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" rel="noopener ugc nofollow" target="_blank">原始数据类型</a> (Oracle)</li><li id="134a" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html" rel="noopener ugc nofollow" target="_blank">自动装箱</a>(甲骨文)</li><li id="a9d4" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">IEEE浮点运算标准(维基百科)</li><li id="c092" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)" rel="noopener ugc nofollow" target="_blank"> Object.equals(对象其他)</a>(甲骨文)</li><li id="9a40" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html" rel="noopener ugc nofollow" target="_blank">可比&lt; T &gt; </a>(甲骨文)</li></ul></div></div>    
</body>
</html>