<html>
<head>
<title>Don’t Be Intimidated — Learn How to Run AWS on Your Local Machine With LocalStack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要害怕——学习如何使用LocalStack在本地机器上运行AWS</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dont-be-intimidated-learn-how-to-run-aws-on-your-local-machine-with-localstack-2f3448462254?source=collection_archive---------0-----------------------#2020-08-03">https://betterprogramming.pub/dont-be-intimidated-learn-how-to-run-aws-on-your-local-machine-with-localstack-2f3448462254?source=collection_archive---------0-----------------------#2020-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5758" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">节俭的程序员指南，利用AWS APIs而不打破你的银行账户</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4dcaafcadd1d25858a5c65f1088bc5a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DvbkR6ih0oiAonim"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">奥米德·阿明在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a9b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AWS云几乎已经成为一种规范，全球超过<a class="ae ky" href="https://techcrunch.com/2015/10/07/amazons-aws-is-now-a-7-3b-business-as-it-passes-1m-active-enterprise-customers/" rel="noopener ugc nofollow" target="_blank">100万家企业</a>在其上构建应用。在你的职业生涯中，在某个时候，你必须或将要在这个生态系统中部署一些东西:这是不可避免的，这表明AWS的覆盖范围有多远。</p><p id="2851" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试在云中构建的最大挑战之一是可供您使用的服务数量和移动部件的数量。通过UI构建应用程序很简单的日子已经一去不复返了:一些业务逻辑、一个数据库和一个域，然后就万事大吉了。现在，我们拥有承诺永久可伸缩性的服务，几乎可以满足您的任何需求。</p><p id="9882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以AWS无服务器架构为例。它承诺易于使用，但配备了N个移动部件来工作。如果你构建一个简单的lambda函数，你最终不得不使用混合服务，比如CloudWatch、S3、IAM、Kinesis、Step函数等等。</p><p id="0514" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用AWS时，使您的开发环境看起来像生产环境是很困难的，特别是当您受到组织约束的时候——这些约束通常是与安全相关的或者是与成本相关的。因为大多数服务都是黑盒，所以必须部署以进行测试是很麻烦的；当事情不顺利时，这确实让生活变得有点挑战性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8eb1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">LocalStack到底是什么？</h1><p id="a18e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://github.com/localstack/localstack" rel="noopener ugc nofollow" target="_blank"> LocalStack </a>是Atlassian的一个开源项目，它提供了一种直接从本地主机开发AWS云应用程序的简单方法。它在您的本地机器上构建了一个测试环境，该环境提供了与真实的AWS云环境几乎相同的奇偶校验功能和API，只是缺少了可伸缩性、健壮性和一大堆魔力。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/7994f682e182a794c59ff598b5ae9841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HZk7S-QczJJl8okx.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源<a class="ae ky" href="https://localstack.cloud/" rel="noopener ugc nofollow" target="_blank">https://localstack.cloud/</a></p></figure><p id="96a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是通过嘲讽/测试工具的组合来完成的，主要是<a class="ae ky" href="https://github.com/mhart/kinesalite" rel="noopener ugc nofollow" target="_blank">kine salite</a>/<a class="ae ky" href="https://github.com/mhart/dynalite" rel="noopener ugc nofollow" target="_blank">dyna lite</a>和<a class="ae ky" href="https://github.com/spulec/moto" rel="noopener ugc nofollow" target="_blank"> moto </a>。虽然LocalStack是用Python编写的，但是它是语言无关的，因为所有服务都是通过HTTP服务公开的，所以您几乎可以使用任何语言来与它交互，就像您使用AWS一样。</p><p id="f695" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初，我对LocalStack的担心是它不具备与AWS同等的功能。我意识到你当地的环境不一定是一对一的；它必须足以确保你覆盖所有的用例。</p><p id="f054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它有助于您专注于完成工作中最重要的事情，而不是解决基础架构的问题，以及与把关人员争夺AWS访问权限。我相信如果一个工具可以帮助你在降低成本的同时减少复杂的分布式系统中的错误数量，那么作为你的核心本地开发工具的一部分是非常值得投资的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d924" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">对AWS看门人又爱又恨</h1><p id="0f14" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">根据您的环境的性质，有时AWS服务可以被排他地限制，并保留给几个看门人。不要误解我——守门人是确保开发人员不会搬起石头砸自己的脚所必需的。毕竟他们有成本能见度。虽然它有时可能是好的，但当有太多限制时，这意味着一个人探索AWS产品的能力有限。</p><p id="3092" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在AWS工作的一个项目是核心堆栈，SQS是我们应用程序的唯一入口。在早期，我们求助于为不同的开发者创建SQS管道。这导致了队列的指数级增长，因为每个开发人员必须被授予x数量的队列以防止消息传递冲突。</p><p id="ee58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在杰夫·贝索斯的世界里，每个字节都有一个美元值。使用AWS进行本地开发会很快变得昂贵，特别是如果这些服务总是处于空闲状态，而这通常是大部分时间。我们可能不想承认这一点，但这些只是事实。问自己一个问题:为了在开发环境或QA环境中运行您的应用程序，您实际上需要访问EC2实例多少次？</p><p id="bf9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中一些环境不需要服务一直运行。无服务器在这方面有所帮助，但也使测试变得困难。因此，按需提供这些服务是有意义的。如果您打算在特定的日子或者特性发布的时候运行测试，那么在最需要的时候提供服务是有意义的。</p><p id="3309" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的团队的LocalStack解决了其中的一些问题，因为人们可以端到端地构建AWS本机应用程序，而不必直接集成到一个实际的AWS帐户中。</p><p id="329e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将向你展示一些我是如何做到这一点的例子。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6ecd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件</h1><ol class=""><li id="aa5b" class="na nb it lb b lc mu lf mv li nc lm nd lq ne lu nf ng nh ni bi translated">安装Docker，如果你还没有的话。</li><li id="184e" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">安装<a class="ae ky" href="https://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器</a>框架。</li><li id="8e75" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">安装<a class="ae ky" href="https://aws.amazon.com/cli/" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a>。尽管我们不打算使用真正的AWS，但这是与LocalStack交互所必需的。</li><li id="f92a" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://github.com/localstack/awscli-local" rel="noopener ugc nofollow" target="_blank"> awscli-local </a>，命令行接口周围的一个薄薄的包装器，与<a class="ae ky" href="https://github.com/localstack/localstack" rel="noopener ugc nofollow" target="_blank"> LocalStack </a>一起使用，是可选的。</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="641a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置</h1><p id="ffc0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">LocalStack有两种安装方式:直接安装，比如下面的例子，或者使用Docker。如果您正在使用direct <code class="fe no np nq nr b">pip install</code>，请确保您正在新的虚拟环境或conda环境中运行pip。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="e07c" class="nw md it nr b gy nx ny l nz oa">$ pip install localstack</span></pre><p id="5bd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要用Python启动LocalStack，可以执行下面的命令。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="6c22" class="nw md it nr b gy nx ny l nz oa">$ localstack start</span></pre><p id="0d85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将采用Docker方法，因为这可以让每个参加这个练习的人拥有相同的一致的工作环境，而不用考虑操作系统。</p><p id="e70d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文假设您对Docker有初步的了解，并且您的机器上已经安装了一个副本。如果你不知道，在继续之前最好先温习一下。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8f7b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">一切开始的地方:合成文件</h1><p id="87b1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">创建一个新的<code class="fe no np nq nr b">docker-compose.yml</code>文件，或者将以下内容添加到现有的<code class="fe no np nq nr b">compose-file</code>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">docker-compose.yml</p></figure><p id="fd43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在与您的合成文件相同的根级别中创建一个名为<code class="fe no np nq nr b">data</code>的目录。我们将使用这个<code class="fe no np nq nr b">data</code>文件夹挂载到我们的<code class="fe no np nq nr b">tmp/localstack</code>目录。目录将被栈用于持久数据，用于诸如Kinesis、DynamoDB、Elasticsearch、S3、Secrets Manager、SSM、SQS和SNS等服务。</p><p id="b014" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启用此目录可以确保在重新启动或堆栈失败的情况下，您的持久化数据不会丢失。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="4483" class="nw md it nr b gy nx ny l nz oa">./bin:/docker-entrypoint-initaws.d</span></pre><p id="8b34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在与您的<code class="fe no np nq nr b">docker-compose.yml</code>文件相同的级别创建一个bin文件夹和bash文件:<code class="fe no np nq nr b">/bin/localstack-entrypoint.sh</code> <strong class="lb iu">。</strong>因为如果你不为企业版支付一些钱，LocalStack就不能提供有意义的UI，所以<code class="fe no np nq nr b">localstack-entrypoint.sh</code> bash脚本文件将用于在我们的LocalStack中创建服务和资源，比如S3文件、数据库表等。，在本地堆栈启动时。</p><p id="a668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对编写bash脚本没有信心，您也可以直接从<code class="fe no np nq nr b">localstack-entrypoint.sh</code>中执行Python脚本，只要这些脚本放在同一个文件夹中或者直接利用<a class="ae ky" href="https://aws.amazon.com/cli/" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a>。如果您希望针对您的LocalStack环境运行特殊命令，我们将在下面的脚本中看到如何实现这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">localstack-entrypoint.sh</p></figure><p id="b4af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LocalStack要求设置凭证，但是在开发的这个阶段，框架没有使用IAM身份验证机制进行任何真正的身份验证。无论您提供哪个凭据，LocalStack都将接受它们，而不需要进行验证。始终确保遵守安全最佳实践，并且不要将真正的AWS密钥强加到版本控制中。</p><h2 id="cc42" class="nw md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated"><code class="fe no np nq nr b">LocalStack ports '4563-4599:4563-4599'</code>和<code class="fe no np nq nr b">'8080'</code></h2><p id="018e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当您的Docker容器启动时，LocalStack将打开上面的<code class="fe no np nq nr b">docker-compose.yml</code>文件中定义的端口，其中左边的数字将您主机上的端口与右边的容器端口绑定在一起。在大多数情况下，这两个数字可以相同，例如<code class="fe no np nq nr b">8080:8080</code>。如果您在右边的端口上运行了其他东西，那么您可能需要将默认值更改为<code class="fe no np nq nr b">8086:8080</code>。例如，打开你的浏览器<code class="fe no np nq nr b">http://localhost:8086</code>会路由到你的容器<code class="fe no np nq nr b">8080</code>。</p><p id="3b51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">行<code class="fe no np nq nr b">'4566-4599:4566-4599'</code>做同样的事情，但是绑定了整个范围的端口。这些端口号是LocalStack用作各种API(如S3、RDS、API网关等)的端点。</p><p id="f992" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，如果你不在网络防火墙后，上述端口可能会暴露给外界。您始终可以选择仅绑定到主机<code class="fe no np nq nr b">127.0.0.1:8080:8080</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="711e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">LocalStack环境变量</h1><p id="4d38" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">LocalStack有相当多的环境变量在启动时提供给LocalStack容器。</p><ul class=""><li id="de83" class="na nb it lb b lc ld lf lg li oo lm op lq oq lu or ng nh ni bi translated"><code class="fe no np nq nr b">SERVICES=s3</code>:您可以定义一个逗号分隔的AWS服务列表来模拟。每个服务可以启动另一个docker容器来服务这样的请求。</li><li id="5213" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu or ng nh ni bi translated"><code class="fe no np nq nr b">DATA_DIR=/tmp/localstack/data</code>:这是LocalStack内部保存数据的目录。在接下来的章节中会有更多的介绍。</li></ul><h2 id="e058" class="nw md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated"><code class="fe no np nq nr b">Volumes</code></h2><p id="4d87" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe no np nq nr b">'./data:/tmp/localstack'</code></p><p id="2923" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker容器不存储状态，唯一的方法是通过卷，它访问硬盘的一部分。<code class="fe no np nq nr b">./data</code>是相对于你的<code class="fe no np nq nr b">docker-compose.yml</code>文件。你可以自由定义任何你想要的其他路径。</p><p id="f32c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的compose配置足以让您入门。为了启动，您的LocalStack环境通过Docker compose在与您的<code class="fe no np nq nr b">docker-compose.yml</code>文件相同的位置执行下面的命令。您可以在末尾添加<code class="fe no np nq nr b">-d</code>参数，将LocalStack作为后台守护进程运行。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="9402" class="nw md it nr b gy nx ny l nz oa">$ docker-compose up</span></pre><p id="4e5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当docker-compose up运行时，请查看您的控制台。您将能够看到LocalStack已经创建了一个文件:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="e5db" class="nw md it nr b gy nx ny l nz oa">../data/data/recorded_api_calls.json</span></pre><p id="59de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面我们谈到了存储文件的LocalStack <code class="fe no np nq nr b">tmp</code>目录。这种持久性是通过自动创建<code class="fe no np nq nr b">recorded_api_calls.json</code> <strong class="lb iu"> </strong>文件<strong class="lb iu"> </strong>来实现的，该文件便于回放先前运行的AWS服务调用<strong class="lb iu">。</strong></p><p id="6fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当容器重新启动时，它将重新应用这些调用。这就是我们能够在重启之间保存数据的方式。一旦我们开始上传，我们将不会在此目录中看到新文件。相反，我们的上传将作为字节原始数据记录在这个文件中。如果您想与他人共享容器的状态，您可以将该文件包含在您的repo中——但是根据您上传的量，该文件可能会很快变得非常大。</p><p id="55b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您希望以后能够恢复您的存储桶，您可以备份该文件。当您准备好恢复时，只需删除更新的文件，用您的备份替换它，并重新启动您的容器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="16e0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在Docker外部访问您的LocalStack</h1><p id="660b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你花了一点时间在AWS上，你会意识到当你有超过一个AWS帐户的访问权或者当你有超过一个访问权和密钥时，为了安全和管理你的密钥，需要使用<a class="ae ky" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html" rel="noopener ugc nofollow" target="_blank">命名概要文件</a>。</p><p id="9f52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们定义一个名为<em class="os"> localstack </em>的新的命名概要文件，这样我们就可以对localstack环境执行AWS CLI命令，其中~引用了<code class="fe no np nq nr b">$HOME</code>目录。</p><p id="34e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> ~/。AWS/凭证</strong></p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="beb7" class="nw md it nr b gy nx ny l nz oa">[localstack]<br/>aws_access_key_id = foo<br/>aws_secret_access_key = bar</span></pre><p id="f0fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> ~/。aws/config </strong></p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="df84" class="nw md it nr b gy nx ny l nz oa">[profile localstack]<br/>region = us-east-1<br/>output = json</span></pre><p id="b34b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的LocalStack正在运行，那么您的每个AWS CLI命令现在都可以由<code class="fe no np nq nr b">endpoint-url</code>参数组成，这可以确保您的命令与我们为伪造身份验证而创建的命名配置文件一起针对您的LocalStack执行。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="aa95" class="nw md it nr b gy nx ny l nz oa">$ aws --endpoint-url=http://localhost:4572 s3 ls "s3://nyc-tlc/trip data/" --profile localstack</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f209" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将LocalStack与SQS一起使用</h1><p id="4e04" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面的例子说明了如何使用boto3 SQS连接到本地堆栈。如果您使用其他编程语言，同样的原则也适用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有本地堆栈的SQS</p></figure><p id="7ac8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Node.js等效项:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="705c" class="nw md it nr b gy nx ny l nz oa">var AWS = require(‘aws-sdk’);<br/><em class="os">// Create an SQS service object using localstack endpoint</em><br/>var config = {<br/>  endpoint: new AWS.Endpoint('http://localhost:4576'),<br/>  accessKeyId: 'foo',<br/>  secretAccessKey: 'bar',<br/>  region: 'us-east-1'<br/>}<br/>var sqs = new AWS.SQS(config);</span></pre><p id="b64a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Java，我们可以实现类似的东西:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="2745" class="nw md it nr b gy nx ny l nz oa">import software.amazon.awssdk.regions.Region;<br/>import software.amazon.awssdk.services.sqs.SqsClient;<br/>import software.amazon.awssdk.services.sqs.model.*;<br/><br/>import java.net.URI;<br/><br/>public class Sqs {<br/><br/>    private SqsClient client;<br/><br/>    public Sqs(URI endpoint) {<br/>        client = SqsClient.builder()<br/>                .region(Region.US_EAST_1)<br/>                .endpointOverride(endpoint)<br/>                .build();<br/>    }<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9ff7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将LocalStack与Dask一起使用</h1><p id="0fc3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://dask.org/" rel="noopener ugc nofollow" target="_blank"> Dask </a>是您工具箱中的必备工具，如果您打算在数据科学解决方案中进行相对中等规模到大规模的数据处理。本质上，您只需编写一次代码，Dask就会处理如何将您的工作分配给多个处理器或节点，同时管理超过内存的计算。在LocalStack上测试Dask是很简单的，只要您确切地了解需要在哪里进行更改，如下例所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有Dask配置的本地堆栈</p></figure><p id="328b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要确保显式定义了<code class="fe no np nq nr b">storage_options</code>和<code class="fe no np nq nr b">endpoint-url</code>，这样boto3就知道您的LocalStack位于哪里。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="5a64" class="nw md it nr b gy nx ny l nz oa">os.environ['LOCALSTACK_S3_ENDPOINT_URL'] = 'http://localstack:4572'</span></pre><p id="fd63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe no np nq nr b">LOCALSTACK_S3_ENDPOINT_URL</code>是如何指向LocalStack的，这是给LocalStack Docker实例的默认DNS。Dask对本地文件存储做了大量的持久化工作，因此Dask代码与docker容器在同一个网络中运行是很重要的。为了更好地说明所有部分是如何连接的，您可以参考本文末尾的GitHub链接。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="62c0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何以最简单的方式在本地堆栈中创建Lambda函数</h1><p id="6d33" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你不喜欢编写CloudFormation YAML文件，serverless是一个替代选项，它可以让你轻松部署你的lambda函数。</p><p id="5b33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在不详细介绍无服务器如何工作的情况下，下面的<code class="fe no np nq nr b">serverless.yml</code>配置文件应该让您了解部署具有HTTP功能的API网关需要什么。custom - &gt; localstack部分定义了将本地lambda函数部署到localstack所需的所有配置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无服务器. yml</p></figure><p id="3bd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">lambda函数演示了一个简单的函数，它返回带有当前时间戳的“Hello World”。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="8c51" class="nw md it nr b gy nx ny l nz oa">def endpoint(event, context):<br/>    current_time = datetime.datetime.now().time()<br/>    body = {<br/>        "message": "Hello, world",<br/>        "eventTime": str(current_time)<br/>    }<br/>    response = {<br/>        "statusCode": 200,<br/>        "body": json.dumps(body)<br/>    }<br/>    return response</span></pre><p id="058f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的<code class="fe no np nq nr b">serverless.yml</code>文件将为我们完成所有繁重的工作，比如创建lambda包，将它上传到我们的LocalStack，提供任何需要的额外资源，比如API-gateway。它不会自动为我们做的一件事是S3桶创建。因此，使用bucket creation命令更新您的<code class="fe no np nq nr b">localstack-entrypoint.sh</code> <strong class="lb iu"> </strong>或者在堆栈运行时手动执行一次是很重要的。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="df88" class="nw md it nr b gy nx ny l nz oa"><em class="os"># </em>Create lambda deploy bucket for our simple http endpoint example<em class="os"><br/></em>$ aws --endpoint-url=$LOCALSTACK_S3_URL s3api create-bucket --bucket simple-http-endpoint-local-deploy</span></pre><p id="9a69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe no np nq nr b">serverless.yml</code>文件中，我们使用<code class="fe no np nq nr b">${self:service}-${opt:stage}-deploy</code>来代替硬编码的桶名。无服务器变量允许用户动态替换<code class="fe no np nq nr b">serverless.yml</code>配置中的配置值。当为您的无服务器服务提供秘密时，或者当我们希望通过stage参数部署到多个环境(例如CI、dev、QA和生产)时，它们特别有用。</p><p id="ae48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的LocalStack在后台运行，您唯一需要做的就是执行下面的命令，该命令将调用LocalStack上的部署，因为您的stage参数指向您的本地。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="0a70" class="nw md it nr b gy nx ny l nz oa">$ serverless deploy --stage local  --profile localstack</span></pre><p id="7316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要通过LocalStack上的无服务器执行lambda函数，可以执行以下命令:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="515d" class="nw md it nr b gy nx ny l nz oa">$ serverless invoke --function currentTime --log --profile localstack --stage local</span></pre><p id="dcb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会产生下面的输出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无服务器部署预期输出</p></figure><p id="a47d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要通过API Gateway提供的浏览器调用lambda函数，我们可以执行下面的URL，其中API Gateway LocalStack执行的URL模式如下:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="f144" class="nw md it nr b gy nx ny l nz oa">http://localhost:4566/restapis/&lt;apiId&gt;/&lt;stage&gt;/_user_request_/&lt;methodPath&gt;</span></pre><p id="98d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们省略了profile参数，并将stage更改为dev profile，假设我们的默认AWS命名概要文件指向一个活动的AWS帐户，正常的活动部署序列将在该帐户上启动。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9a51" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">验证本地堆栈健康</h1><p id="108f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一旦运行了本地堆栈，就可以通过点击以下URL来访问运行状况检查端点:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="a03d" class="nw md it nr b gy nx ny l nz oa"><a class="ae ky" href="http://localhost:4566/health" rel="noopener ugc nofollow" target="_blank">http://localhost:4566/health</a></span><span id="09c4" class="nw md it nr b gy ot ny l nz oa">{<br/>  "services": {<br/>    "cloudformation": "running",<br/>    "cloudwatch": "running",<br/>    "iam": "running",<br/>    "sts": "running",<br/>    "lambda": "running",<br/>    "logs": "running",<br/>    "s3": "running",<br/>    "sqs": "running",<br/>    "events": "running",<br/>    "apigateway": "running"<br/>  }<br/>}</span></pre><p id="63bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，rest API调用的初始运行可能需要一些时间。端点将列出正在运行的服务的总数及其相应的状态。服务运行的位置取决于您在LocalStack环境变量中声明的位置。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="0d81" class="nw md it nr b gy nx ny l nz oa">SERVICES=s3,sqs,lambda,cloudformation,sts,iam,cloudwatch,apigateway,events</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4adf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用awscli-local实用程序更加本地化</h1><p id="d89c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止，我们一直使用默认的AWS CLI。如果您不想在运行CLI命令时一直指定端点URL，您可以选择使用<a class="ae ky" href="https://github.com/localstack/awscli-local" rel="noopener ugc nofollow" target="_blank"> awscli-local </a>包。这是围绕AWS CLI的一个简洁的小包装器，它确保您运行的所有东西在默认情况下都在本地堆栈上运行。</p><h2 id="4c69" class="nw md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">如何创建S3存储桶</h2><p id="87b8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可以使用以下命令创建一个名为“my-test-bucket”的S3 bucket。如果您想列出您的bucket内容，授予ACL公共读取权限是很重要的。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="f4a8" class="nw md it nr b gy nx ny l nz oa">$ awslocal s3 mb s3://my-test-bucket</span></pre><p id="400f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会在您的终端中看到“make _ bucket:my-test-bucket”<em class="os"/>。验证存储桶是否已成功创建。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="7eaf" class="nw md it nr b gy nx ny l nz oa">$ awslocal s3 ls</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6c98" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">本地堆栈陷阱</h1><ul class=""><li id="095b" class="na nb it lb b lc mu lf mv li nc lm nd lq ne lu or ng nh ni bi translated">不能很好地协同工作的LocalStack参数，将存储桶持久化到挂载点，并试图通过将lambda压缩并复制到LocalStack存储桶来部署lambda，将会抛出下面的错误。</li></ul><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="e4a5" class="nw md it nr b gy nx ny l nz oa">2020-07-22T12:12:51:DEBUG:localstack.services.cloudformation.cloudformation_listener: Error response for CloudFormation action "CreateStack" (400) POST /: b'Unknown error: Please note that Lambda mounts (bucket name "__local__") cannot be used with LAMBDA_REMOTE_DOCKER=1 Traceback (most recent call last):\n  File "/opt/code/localstack/localstack/services/awslambda/lambda_api.py", line 954, in create_function\n    result = set_function_code(func_details.code, lambda_name)\n  File "/opt/code/localstack/localstack/services/awslambda/lambda_api.py", line 721, in set_function_code\n    lambda_cwd = lambda_cwd or set_archive_code(code_passed, lambda_name)\n  File "/opt/code/localstack/localstack/services/awslambda/lambda_api.py", line 676, in set_archive_code\n    raise Exception(msg % BUCKET_MARKER_LOCAL)\nException: Please note that Lambda mounts (bucket name "__local__") cannot be used with LAMBDA_REMOTE_DOCKER=1\n'<br/>localstac</span></pre><ul class=""><li id="76d6" class="na nb it lb b lc ld lf lg li oo lm op lq oq lu or ng nh ni bi translated">如果您对LocalStack docker-compose环境设置做了一些更改，最好删除您的<code class="fe no np nq nr b">/data/data/recorded_api_calls.json</code>文件。我注意到在回放已执行的API调用时，它有时会崩溃。</li><li id="7332" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu or ng nh ni bi translated">在您的<code class="fe no np nq nr b">docker-compose.yml</code>中，指定您想要使用的确切的<a class="ae ky" href="https://hub.docker.com/r/localstack/localstack/tags" rel="noopener ugc nofollow" target="_blank"> LocalStack镜像版本</a>可能是一个好主意，而不是获取最新的版本。最新的标签使得很难跟踪哪个版本的映像正在运行，有时新的特性可能包含中断更改。</li><li id="c708" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu or ng nh ni bi translated">杰夫·贝索斯的动作很快，所以不要指望LocalStack能够跟上AWS的步伐——但它是免费的。</li><li id="ba35" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu or ng nh ni bi translated">乍一看，您可能认为LocalStack本身是免费的，但有一些高级功能可能需要您支付一些费用。但是从我到目前为止所看到的来看，基础知识应该涵盖了你的大部分用例——开发人员也要吃饭。</li></ul><p id="ad02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">image: localstack/localstack:&lt;TAG-VERSION-NUMBER&gt;</code></p><p id="c478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解更多您应该知道的问题，请参阅本地堆栈<a class="ae ky" href="https://github.com/localstack/localstack#troubleshooting" rel="noopener ugc nofollow" target="_blank">故障排除</a>提示的自述文件。意识到一些问题将会为您和您的团队节省大量调试时间。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c1a2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">LocalStack的替代方案是什么？</h1><p id="e8df" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您觉得LocalStack不能满足您的某些需求，您总是可以选择使用模拟SDK，这是常规的做法。如果您在设计类时考虑到了扩展，这种方法效果最好。</p><p id="88ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为S3存储桶的替代选择，有一个MinIO可以直接替代S3云原生对象存储服务。</p><p id="5c62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你正在为其他云服务构建，比如谷歌，你有其他选择，比如谷歌云<a class="ae ky" href="https://cloud.google.com/sdk/gcloud/reference/beta/emulators" rel="noopener ugc nofollow" target="_blank">模拟器</a>和谷歌的开源FaaS ( <a class="ae ky" href="https://cloud.google.com/functions/docs/functions-framework" rel="noopener ugc nofollow" target="_blank">功能即服务</a>)框架，用于编写可在本地机器上运行的可移植Node.js函数。如果你想要一种云原生的做事方式，混合搭配的方法可能会满足你的需求。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c5c8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="5361" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在AWS上构建应用程序时，您需要控制架构的经济模型。如果你不小心的话，很容易陷入昂贵账单的永恒陷阱。</p><p id="c815" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模仿在一定程度上是可行的，但是一旦你点击了部署按钮，它并不能真实地描述真实的现实。</p><p id="9271" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LocalStack是一个很好的起点，它为开发人员提供了一个实验和测试新代码的平台，而无需竭尽全力说服您的老板为什么他们需要每月支付数百美元来验证概念。在我看来，使用LocalStack方法是一种实用的方法，可以计算出将在AWS上运行的代码。</p><p id="3b29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以尝试的一个小项目是用您最常用的AWS服务构建一个boto3或AWS SDK包装器，并通过环境变量或属性文件启用LocalStack切换功能。可以在YAML文件中配置LocalStack端点，如下所示。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="630d" class="nw md it nr b gy nx ny l nz oa">endpoints:<em class="os"><br/>  </em>S3: <a class="ae ky" href="http://localhost:4572" rel="noopener ugc nofollow" target="_blank">http://localhost:4572</a><br/>  DynamoDB: <a class="ae ky" href="http://localhost:4569" rel="noopener ugc nofollow" target="_blank">http://localhost:4569</a><br/>  CloudFormation: <a class="ae ky" href="http://localhost:4581" rel="noopener ugc nofollow" target="_blank">http://localhost:4581</a><br/>  Elasticsearch: <a class="ae ky" href="http://localhost:4571" rel="noopener ugc nofollow" target="_blank">http://localhost:4571</a><br/>  ES: <a class="ae ky" href="http://localhost:4578" rel="noopener ugc nofollow" target="_blank">http://localhost:4578</a><br/>  SNS: <a class="ae ky" href="http://localhost:4575" rel="noopener ugc nofollow" target="_blank">http://localhost:4575</a><br/>  SQS: <a class="ae ky" href="http://localhost:4576" rel="noopener ugc nofollow" target="_blank">http://localhost:4576</a><br/>  Lambda: <a class="ae ky" href="http://localhost:4574" rel="noopener ugc nofollow" target="_blank">http://localhost:4574</a><br/>  Kinesis: <a class="ae ky" href="http://localhost:4568" rel="noopener ugc nofollow" target="_blank">http://localhost:4568</a></span></pre><p id="17b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请随意复制以下存储库，其中有更多示例供您参考:</p><p id="51d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/timothymugayi/localstack_python_examples" rel="noopener ugc nofollow" target="_blank">timothymugayi/local stack _ python _ examples</a></p><p id="3d6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用LocalStack还可以做很多事情，这超出了本文的范围。我建议您花一些时间阅读LocalStack GitHub问题部分，以便熟悉一些高级设置和配置。</p><p id="5347" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你喜欢这本书。请在下面的评论区分享你的想法。如果你觉得这篇文章会对下一个开发者有所帮助，那就继续吧。</p></div></div>    
</body>
</html>