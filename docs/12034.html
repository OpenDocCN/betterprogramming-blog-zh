<html>
<head>
<title>Preventing Memory Leaks Using XCTests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用XCTests防止内存泄漏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/preventing-memory-leaks-using-xctests-5fee5e1fa7c5?source=collection_archive---------5-----------------------#2022-05-06">https://betterprogramming.pub/preventing-memory-leaks-using-xctests-5fee5e1fa7c5?source=collection_archive---------5-----------------------#2022-05-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f0b5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">减少对iOS中手工测试的依赖</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5825831f0ca159ad0d8d8baf3c03abfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xK-ceSzDhU4qi_EV"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@williamtm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">威廉·胡克</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e8ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在开发Swift应用程序时，我们会面临一些风险。其中之一是内存泄漏。</p><p id="6b79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html" rel="noopener ugc nofollow" target="_blank">自动引用计数器</a> (ARC)从内存中释放一个对象，仅在该对象没有强引用的情况下。此外，当两个引用类型相互引用时，它们都不会从内存中释放，这会导致内存泄漏。</p><p id="0c1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了研究这个问题，我们可以使用Xcode工具或内存图调试器。这些工具允许对发生的泄漏进行深入分析。然而，我们应该回答的问题是，是否有任何方法可以首先实际防止内存泄漏？</p><p id="ace3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">答案是肯定的，通过使用单元测试。自动化测试的执行允许在将应用程序传递给QA团队或客户自己之前捕捉应用程序中的错误。让我们来看看如何实现这样的保护。</p><p id="b76b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们考虑一个简单的带有按钮的视图控制器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="2f16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在动作处理程序内部，对<code class="fe lu lv lw lx b">self</code>的强引用导致<code class="fe lu lv lw lx b">button</code>和<code class="fe lu lv lw lx b">LeakingViewController</code>之间的保持循环。如您所见，即使在这个简单的例子中，我们也可以创建内存泄漏。现在让我们编写一个测试来提醒我们一个问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="8ab6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建视图控制器后，您可以注意到一些神秘的块，称为<code class="fe lu lv lw lx b">addTeardownBlock</code>。这个程序块在退出当前测试方法后执行——类似于<code class="fe lu lv lw lx b">tearDown</code>方法。它保存对<code class="fe lu lv lw lx b">viewController</code>的弱引用，以便不创建保留周期。在我们的例子中，在完成一个测试代码后，<code class="fe lu lv lw lx b">button</code>和<code class="fe lu lv lw lx b">viewController</code>将持有彼此的引用，创建一个保留周期，这样<code class="fe lu lv lw lx b">addTeardownBlock</code>就能够访问<code class="fe lu lv lw lx b">viewController</code>的引用，这反过来通知我们内存泄漏。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ly"><img src="../Images/c448eb9cba9968618e8d9af631e4f8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oPeD0TRKoSnsiYhw4f2BLg.png"/></div></div></figure><p id="7493" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">弱化按钮的处理程序闭包中的<code class="fe lu lv lw lx b"><em class="lz">self</em></code>将消除内存泄漏，同时满足测试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ma"><img src="../Images/3a7707322343bc71912c0ff2baf87367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JXWY6tA_IEqnAo12qq-6Gw.png"/></div></div></figure><p id="781f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所看到的，一个小的疏忽会导致内存泄漏。让我们通过添加另一个<code class="fe lu lv lw lx b">presenter</code>类来扩展这个例子——已知来自MVP模式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="94cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lu lv lw lx b">LeakingViewControllerPresenter</code>符合<code class="fe lu lv lw lx b">LeakingViewControllerDelegate</code>，这就为调用<code class="fe lu lv lw lx b">startLoading()</code>方法提供了可能，而且<code class="fe lu lv lw lx b">LeakingViewController</code>也可以调用<code class="fe lu lv lw lx b">LeakingViewControllerPresenter</code>上的<code class="fe lu lv lw lx b">buttonClicked()</code>。通过不使委托属性变弱，我们引入了另一个保留周期，这已被我们的测试所证明。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mb"><img src="../Images/862ccdbce683f9e996bffc1f0e62dcb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lOD-1PsA-pBT2uZLwcxonA.png"/></div></div></figure><p id="90d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们快速修复一个<em class="lz">演示者</em>类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="56d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的测试又开始通过了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mc"><img src="../Images/9c2bc5ee00a158e97ad2159faa6bbe2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GAB5OvU3wYy4tM1PxXrZ6g.png"/></div></div></figure><p id="894d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着代码开始增长，可能会有许多其他原因导致内存泄漏。</p><p id="7d3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用自动单元测试来处理它们，可以显著提高应用程序的质量并节省时间，否则你将不得不花费在冗长的手动调试上。</p><p id="e2b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使您不确定您的代码是否会触发保留循环，使用这种方法来获得对代码的信心总是好的。</p><h2 id="e4f0" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated"><em class="mw">参考</em></h2><p id="a4f1" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated"><a class="ae kv" href="https://www.essentialdeveloper.com" rel="noopener ugc nofollow" target="_blank">https://www.essentialdeveloper.com</a></p></div></div>    
</body>
</html>