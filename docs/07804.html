<html>
<head>
<title>What’s New in Swift 5.4?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 5.4有什么新功能？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-swift-5-4-88949071d538?source=collection_archive---------2-----------------------#2021-02-22">https://betterprogramming.pub/whats-new-in-swift-5-4-88949071d538?source=collection_archive---------2-----------------------#2021-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="76dc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">多个可变参数、扩展的隐式成员语法、结果生成器等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f114326dc3aaabfa33d00e6922707d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H2dY1PcEzr3EzeXM31ouNw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="e33f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Swift 5.4带给我们很多，这也是我喜欢它的原因。在本文中，我们了解了Swift 5.4的新功能。</p><p id="6535" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="lu">注:</em> </strong> <em class="lu">您可以在GitHub上</em> <a class="ae lv" href="https://github.com/Unobliging/What-s-New-in-Swift-5.4-" rel="noopener ugc nofollow" target="_blank"> <em class="lu">下载本文的示例项目和来源</em> </a> <em class="lu">。要打开和编辑这些文件，您必须使用Xcode 12.5 beta。你可以在这里</em>  <em class="lu">下载Xcode 12.5 beta </em> <a class="ae lv" href="https://developer.apple.com/download/" rel="noopener ugc nofollow" target="_blank"> <em class="lu">。不用下载Xcode 12.5 beta，直接下载Swift 5.4</em></a><a class="ae lv" href="https://swift.org/download/" rel="noopener ugc nofollow" target="_blank"><em class="lu">这里</em> </a> <em class="lu">。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0815" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">最重要的改进😄</h1><p id="d2f7" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">任何以前创建过Xcode项目或playground文件的人都知道，当您创建一个新的playground或一个新的Xcode项目时，以下值将被写入该项目:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="1ff3" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">var</strong> str = "Hello, playground"</span></pre><p id="d839" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Swift 5.4中，该值的名称已更改如下:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="106d" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">var</strong> greeting = "Hello, playground"</span></pre><p id="68fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是的，我觉得这就是Swift 5.4有趣搞笑的地方。</p><p id="84d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以看看真正有效的改进了！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="fcff" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">多变量参数</h1><p id="84e7" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">在Swift 5.4中，我们可以在函数、方法、下标和初始化器上使用多个可变参数。在Swift 5.4之前，我们只有一个可变参数，如下所示:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="712b" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">func</strong> method(singleVariadicParameter: String) {}</span></pre><p id="bc25" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以编写多个可变参数，如下面的代码:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="08e9" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">func</strong> method(multipleVariadicParameter: String..., secondMultipleVariadicParameter: String...) {}</span></pre><p id="ff3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以调用上面写的函数，当然，如果我们愿意，也可以只写一个<code class="fe nk nl nm nb b">String</code>元素。代码如下:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c0ad" class="nf me it nb b gy ng nh l ni nj">method(multipleVariadicParameter: "Can", "Steve", "Bill", secondmultipleVariadicParameter: "Tim", "Craig")</span></pre><p id="b1ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">多个可变参数的工作方式就像数组一样。当然，在调用参数中的值时，需要事先检查那个值是否存在；否则就会出错，死机。代码如下:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="a10d" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">func</strong> chooseSecondPerson(persons: String...) -&gt; String {<br/>    <strong class="nb iu">let</strong> index = 1<br/>    <strong class="nb iu">if</strong> persons.count &gt; index {<br/>        <strong class="nb iu">return</strong> persons[index]<br/>    } <strong class="nb iu">else</strong> {<br/>        <strong class="nb iu">return</strong> "There is no second person."<br/>    }<br/>}</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f51b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结果生成器</h1><p id="9100" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">自从SwiftUI问世以来，结果构建器在Swift中是如此重要。现在，随着新的改进，它变得更加重要。</p><p id="5e9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以用一个输出一个<code class="fe nk nl nm nb b">String</code>的函数创建几十个字符串吗？如果我们使用结果生成器，答案是肯定的！</p><p id="8bc2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过用<code class="fe nk nl nm nb b">@resultBuilder</code>定义新的结构来定义新的结果构建器。您将定义的方法和属性必须是<code class="fe nk nl nm nb b">static</code>。</p><p id="6d31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回到我们将<code class="fe nk nl nm nb b">String</code>元素转换成单个<code class="fe nk nl nm nb b">String</code>元素的例子。使用下面的结果生成器，我们可以连接写在它们下面的<code class="fe nk nl nm nb b">String</code>元素。代码如下:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e2a5" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">@resultBuilder</strong><br/><strong class="nb iu">struct</strong> StringBuilder {<br/>    <strong class="nb iu">static</strong> <strong class="nb iu">func</strong> buildBlock(_ strings: String...) -&gt; String {<br/>        strings.joined(separator: "\n")<br/>    }<br/>}</span></pre><p id="fcf4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们用下面的代码来描述它:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5625" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">let</strong> stringBlock = StringBuilder.buildBlock(<br/>    "It really inspires the",<br/>    "creative individual",<br/>    "to break free and start",<br/>    "something different."<br/>)</span><span id="fca3" class="nf me it nb b gy nn nh l ni nj">print(stringBlock)</span></pre><p id="31e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当定义一个值时，我们必须直接使用<code class="fe nk nl nm nb b">buildBlock</code>方法。因此，我们必须在每个<code class="fe nk nl nm nb b">String</code>元素的末尾加一个逗号。相反，我们可以在函数中使用<code class="fe nk nl nm nb b">StringBuilder</code>来做同样的事情，而不用逗号。代码如下:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="575b" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">@StringBuilder func</strong> makeSentence() -&gt; String {<br/>    "It really inspires the"<br/>    "creative individual"<br/>    "to break free and start"<br/>    "something different."<br/>}</span><span id="4eba" class="nf me it nb b gy nn nh l ni nj">print(makeSentence())</span></pre><p id="4dc3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，我们用结果构建器所做的对您来说可能没什么意义，但是如果我们更有效地使用结果构建器，您将会更好地理解它们的威力。例如，通过我们将添加到结果构建器中的两个新方法，我们可以使用条件来使用我们的结果构建器生成<code class="fe nk nl nm nb b">String</code>元素。代码如下:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="37e7" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">@resultBuilder</strong><br/><strong class="nb iu">struct</strong> ConditionalStringBuilder {<br/>    <strong class="nb iu">static func</strong> buildBlock(_ parts: String...) -&gt; String {<br/>        parts.joined(separator: "\n")<br/>    }</span><span id="ab7a" class="nf me it nb b gy nn nh l ni nj">    <strong class="nb iu">static func</strong> buildEither(first component: String) -&gt; String {<br/>        <strong class="nb iu">return</strong> component<br/>    }</span><span id="df04" class="nf me it nb b gy nn nh l ni nj">    <strong class="nb iu">static func</strong> buildEither(second component: String) -&gt; String {<br/>        <strong class="nb iu">return</strong> component<br/>    }<br/>}</span></pre><p id="537d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如你所看到的，通过创建一个<code class="fe nk nl nm nb b">if</code>循环，我们可以根据布尔值改变<code class="fe nk nl nm nb b">String</code>元素。结果如下:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="1759" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">@ConditionalStringBuilder func</strong> makeSentence() -&gt; String {<br/>    "It really inspires the"<br/>    "creative individual"<br/>    "to break free and start"</span><span id="57b1" class="nf me it nb b gy nn nh l ni nj">    <strong class="nb iu">if</strong> Bool.random() {<br/>        "something different."<br/>    } <strong class="nb iu">else</strong> {<br/>        "thinking different."<br/>    }<br/>}</span><span id="7683" class="nf me it nb b gy nn nh l ni nj">print(makeSentence())</span></pre><p id="b47b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用结果生成器可以做很多事情。你可以通过尝试找到它们。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="07ce" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">扩展隐式成员语法</h1><p id="f260" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">当在修饰符中定义元素时，我们不再需要指定元素的主类型。因此，您可以将多个成员属性或函数链接在一起，而无需在开头添加类型，如下所示:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="46f4" class="nf me it nb b gy ng nh l ni nj">.transition(.scale.move(…))</span></pre><p id="abe1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Swift 5.4之后，为了同样的结果，我们必须在下面编写这个代码块。这是一行代码:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="a0e4" class="nf me it nb b gy ng nh l ni nj">.transition(AnyTransistion.scale.move(…))</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b801" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">函数支持相同的名称</h1><p id="40e6" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">有时候，你想用相同的名字写函数。至少我想这么做。借助Swift 5.4，我们可以做到这一点。</p><p id="bab0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果我们用相同的名称创建函数——并且这些函数有相同的参数名称——如果我们用不同的对象类型定义这些参数，我们的代码将会工作。</p><p id="870e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以试着把这些写在下面:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="98b6" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">struct</strong> iPhone {}<br/><strong class="nb iu">struct</strong> iPad {}<br/><strong class="nb iu">struct</strong> Mac {}</span><span id="be84" class="nf me it nb b gy nn nh l ni nj"><strong class="nb iu">func</strong> setUpAppleProducts() {<br/>    <strong class="nb iu">func</strong> setUp(product: iPhone) {<br/>        print("iPhone is bought")<br/>    }<br/>    <br/>    <strong class="nb iu">func</strong> setUp(product: iPad) {<br/>        print("iPad is bought")<br/>    }<br/>    <br/>    <strong class="nb iu">func</strong> setUp(product: Mac) {<br/>        print("Mac is bought")<br/>    }<br/>    <br/>    setUp(product: iPhone())<br/>    setUp(product: iPad())<br/>    setUp(product: Mac())<br/>}</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="15a3" class="nf me it bd mf no np dn mj nq nr dp mn lh ns nt mp ll nu nv mr lp nw nx mt ny bi translated">结论</h2><p id="d849" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">我希望这篇文章对你有所帮助。有新的报道称，Swift 6.0可能会发布。我也会写一篇关于这个主题的文章。</p><p id="2562" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的阅读。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4bdb" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">My Other Articles<br/></strong>- <a class="ae lv" rel="noopener ugc nofollow" target="_blank" href="/building-cross-platform-apps-with-swiftui-3fea88cdb0ae">Building Cross-Platform Apps With SwiftUI</a><br/>- <a class="ae lv" rel="noopener ugc nofollow" target="_blank" href="/how-to-create-onboarding-screens-in-your-ios-app-e41b518db31f">How to Create Onboarding Screens in Your iOS App</a><br/>- <a class="ae lv" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-firebase-in-swiftuis-new-application-lifecycle-c77a8a306d63">How To Use Firebase in SwiftUI’s New Application Lifecycle</a></span></pre><p id="af06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想见我或有关于iOS开发等问题。你可以在这里和我进行一对一的会谈<a class="ae lv" href="https://superpeer.com/canbalkya" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>