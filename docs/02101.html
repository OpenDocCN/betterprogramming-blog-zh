<html>
<head>
<title>Common JavaScript Mistakes — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常见的JavaScript错误—第2部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/common-javascript-mistakes-part-2-e84b60371489?source=collection_archive---------7-----------------------#2019-11-06">https://betterprogramming.pub/common-javascript-mistakes-part-2-e84b60371489?source=collection_archive---------7-----------------------#2019-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c98b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">未定义和空，加法和连接，等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/93aaa8a347e41f982144459e32beeb85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RL5LkAHv8qqVzq0n"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@madeyes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃里克韩</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript是一种比世界上许多其他编程语言更友好的语言。然而，在编写JavaScript代码时，由于误解或忽略我们已经知道的东西，仍然很容易犯错误。通过避免下面的一些错误，我们可以通过防止代码中的错误和错别字让我们的生活变得更容易，这些错误和错别字会让我们陷入意想不到的结果。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f5db" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">混淆未定义和空</h1><p id="ecb8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript对于非值既有<code class="fe mz na nb nc b">undefined</code>又有<code class="fe mz na nb nc b">null</code>。然而，这两者之间有相当多的不同之处。<code class="fe mz na nb nc b">undefined</code>意味着变量可能已经被声明了，但是没有给它设置任何东西。变量也可以显式设置为<code class="fe mz na nb nc b">undefined</code>。当用<code class="fe mz na nb nc b">typeof</code>操作符检查类型时，<code class="fe mz na nb nc b">undefined</code>变量的类型将会得到类型<code class="fe mz na nb nc b">'undefined'</code>。不返回任何东西的函数返回<code class="fe mz na nb nc b">undefined</code>。另一方面，<code class="fe mz na nb nc b">null</code>值必须由返回<code class="fe mz na nb nc b">null</code>的函数显式设置，或者直接设置为变量。当我们检查一个设置了<code class="fe mz na nb nc b">null</code>值的对象时，我们会发现如果一个变量有<code class="fe mz na nb nc b">null</code>值，那么它的类型就是<code class="fe mz na nb nc b">'object'</code>。</p><p id="4687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于这个原因，当我们将变量值设置为非值时，尽可能坚持使用<code class="fe mz na nb nc b">undefined</code>可能更容易。这减少了混淆，我们只需要检查变量的类型是否是<code class="fe mz na nb nc b">'undefined'</code>就可以知道它是否是<code class="fe mz na nb nc b">undefined</code>。对于<code class="fe mz na nb nc b">null</code>和<code class="fe mz na nb nc b">undefined</code>来说，这比进行两次检查要少得多。</p><p id="d574" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要编写返回<code class="fe mz na nb nc b">undefined</code>的函数，我们不需要像下面的例子那样做任何事情:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6851" class="nh md it nc b gy ni nj l nk nl">const f = () =&gt; {}</span></pre><p id="f927" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要设置一个被赋予其他值的变量给<code class="fe mz na nb nc b">undefined</code>，我们可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c9e0" class="nh md it nc b gy ni nj l nk nl">x = undefined;</span></pre><p id="b9ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要检查属性值是否为<code class="fe mz na nb nc b">undefine</code>，我们可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="fd85" class="nh md it nc b gy ni nj l nk nl">typeof obj.prop === 'undefined'</span></pre><p id="f784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5d74" class="nh md it nc b gy ni nj l nk nl">obj.prop === undefined</span></pre><p id="e24a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了检查一个变量是否是<code class="fe mz na nb nc b">undefined</code>，我们可以编写下面的代码:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a506" class="nh md it nc b gy ni nj l nk nl">typeof x === 'undefined'</span></pre><p id="5477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个没有被自动赋值的声明变量的值是<code class="fe mz na nb nc b">undefined</code>。</p><p id="85cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们必须检查<code class="fe mz na nb nc b">null</code>，那么我们可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="042d" class="nh md it nc b gy ni nj l nk nl">obj.prop === null</span></pre><p id="1869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="ea0e" class="nh md it nc b gy ni nj l nk nl">x === null</span></pre><p id="de00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于变量。我们不能使用<code class="fe mz na nb nc b">typeof</code>操作符来检查<code class="fe mz na nb nc b">null</code>，因为<code class="fe mz na nb nc b">null</code>的数据类型是<code class="fe mz na nb nc b">'object'</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/c55e07e9ef50d7ca4da6bd8419ab0129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*79d0pk1RCiMWq6dC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">米哈伊尔·瓦西里耶夫在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="53af" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">混淆加法和连接</h1><p id="bf52" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在JavaScript中，<code class="fe mz na nb nc b">+</code>操作符既用于将两个数相加，也用于将字符串连接在一起。因为JavaScript是一种动态语言，所以在应用操作之前，操作数都自动转换为相同的类型。例如，如果我们有:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6df1" class="nh md it nc b gy ni nj l nk nl">let x = 1 + 1;</span></pre><p id="c87d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们得到两个，因为它们都是数字。<code class="fe mz na nb nc b">+</code>操作像我们预期的那样用于加法。然而，如果我们有下面的表达式:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="ba41" class="nh md it nc b gy ni nj l nk nl">let x = 1 + '1';</span></pre><p id="0b1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到<code class="fe mz na nb nc b">'11'</code>，因为在应用<code class="fe mz na nb nc b">+</code>操作之前，第一个操作数被强制转换成一个字符串。<code class="fe mz na nb nc b">+</code>操作用于连接而不是加法。当我们在多个变量上使用<code class="fe mz na nb nc b">+</code>操作符时，这使得知道类型更加困难。例如，如果我们有:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="fa1c" class="nh md it nc b gy ni nj l nk nl">let x = 1;<br/>let y = 2;<br/>let z = x + y;</span></pre><p id="6710" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所料，我们得到3，因为<code class="fe mz na nb nc b">x</code>和<code class="fe mz na nb nc b">y</code>都是数字。另一方面，如果我们有:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6067" class="nh md it nc b gy ni nj l nk nl">let x = 1;<br/>let y = '2';<br/>let z = x + y;</span></pre><p id="d2dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到<code class="fe mz na nb nc b">'12'</code>，因为<code class="fe mz na nb nc b">y</code>是一个字符串，所以<code class="fe mz na nb nc b">+</code>操作符被用于连接。为了解决这个问题，我们应该在使用<code class="fe mz na nb nc b">+</code>操作符之前先将所有操作数转换成数字。例如，我们应该将上面的示例重写为以下内容:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="dc3a" class="nh md it nc b gy ni nj l nk nl">let x = 1;<br/>let y = '2';<br/>let z = Number(x) + Number(y);</span></pre><p id="3993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将得到3作为<code class="fe mz na nb nc b">z</code>的值，因为我们首先用<code class="fe mz na nb nc b">Number</code>工厂函数将它们转换成数字。<code class="fe mz na nb nc b">Number</code>函数接受任何对象，如果可以解析为数字，则返回一个数字，否则返回<code class="fe mz na nb nc b">NaN</code>。另一种方法是使用<code class="fe mz na nb nc b">new Number(...).valueOf()</code>函数，正如我们在下面的代码中所做的:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="889f" class="nh md it nc b gy ni nj l nk nl">let x = 1;<br/>let y = '2';<br/>let z = new Number(x).valueOf() + new Number(y).valueOf();</span></pre><p id="d062" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe mz na nb nc b">new Number(...)</code>是一个创建<code class="fe mz na nb nc b">object</code>类型的构造函数，我们想使用<code class="fe mz na nb nc b">valueOf</code>函数将其转换回原始类型，以确保我们得到的是一个数字类型。一种更简单的方法是这样写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="20bb" class="nh md it nc b gy ni nj l nk nl">let x = 1;<br/>let y = '2';<br/>let z = +x + +y;</span></pre><p id="3d32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单个操作数前面的<code class="fe mz na nb nc b">+</code>符号将尝试将单个操作数转换为数字，如果不能转换为数字，则转换为<code class="fe mz na nb nc b">NaN</code>。它的功能与<code class="fe mz na nb nc b">Number</code>功能相同。我们还可以将变量转换成特定类型的数字。<code class="fe mz na nb nc b">Number</code>对象有一个<code class="fe mz na nb nc b">parseInt</code>函数将字符串或对象转换成整数，还有一个<code class="fe mz na nb nc b">parseFloat</code>函数将字符串或对象转换成浮点数。<code class="fe mz na nb nc b">parseInt</code>将需要转换为数字的对象作为第一个参数。它还将基数作为可选的第二个参数，这是数学数字系统的基础。如果字符串以<code class="fe mz na nb nc b">0x</code>开头，那么基数将设置为16。如果字符串以任何其他字符开头，那么基数将被设置为10。</p><p id="3f23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在下面的例子中使用它们:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5ea3" class="nh md it nc b gy ni nj l nk nl">let x = 1;<br/>let y = '2';<br/>let z = Number.parseInt(x) + Number.parseInt(y)</span></pre><p id="cf70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们可以使用下面代码中的<code class="fe mz na nb nc b">parseFloat</code>函数:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f8c9" class="nh md it nc b gy ni nj l nk nl">let x = 1;<br/>let y = '2';<br/>let z = Number.<!-- -->parseFloat<!-- -->(x) + Number.<!-- -->parseFloat<!-- -->(y)</span></pre><p id="b6b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的两个例子中，我们都会得到3。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="973a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将Return语句分成多行</h1><p id="fa80" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript在最后关闭一个语句，所以一行代码被认为是不同的。例如，如果我们有:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9e36" class="nh md it nc b gy ni nj l nk nl">const add = (a, b) =&gt; {<br/>  return<br/>  a + b;<br/>}</span></pre><p id="5c98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在运行<code class="fe mz na nb nc b">a + b</code>之前运行了结束函数执行的<code class="fe mz na nb nc b">return</code>语句，然后运行<code class="fe mz na nb nc b">console.log(add(1, 2));</code>，那么我们将得到<code class="fe mz na nb nc b">undefined</code>。因此，<code class="fe mz na nb nc b">a + b</code>永远不会在这个功能中运行。为了解决这个问题，我们要么将所有的<code class="fe mz na nb nc b">return</code>语句放在一行中，要么用括号将我们想要返回的内容括起来。例如，我们可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="7ded" class="nh md it nc b gy ni nj l nk nl">const add = (a, b) =&gt; {<br/>  return a + b;<br/>}</span></pre><p id="417e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行<code class="fe mz na nb nc b">console.log(add(1, 2));</code>，它将记录3，因为我们实际上是在函数中返回计算结果。我们也可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="ff2f" class="nh md it nc b gy ni nj l nk nl">const add = (a, b) =&gt; {<br/>  return (<br/>    a + b<br/>  );<br/>}</span></pre><p id="bc74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于返回可能长于一行的表达式很方便。如果我们运行<code class="fe mz na nb nc b">console.log(add(1, 2));</code>，也会记录3。对于箭头函数，我们也可以写成:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="e0a8" class="nh md it nc b gy ni nj l nk nl">const add = (a, b) =&gt; a + b</span></pre><p id="b62b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于单行函数，因为<code class="fe mz na nb nc b">return</code>语句对于单行箭头函数是隐含的。我们也可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="72e4" class="nh md it nc b gy ni nj l nk nl">const add = (a, b) =&gt; (a + b)</span></pre><p id="87c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">得到同样的东西。这也适用于单行箭头函数。</p><p id="c398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，如果语句不完整，比如:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="716c" class="nh md it nc b gy ni nj l nk nl">const power = (a) =&gt; {<br/>  const<br/>    power = 10;<br/>  return a ** 10;<br/>}</span></pre><p id="76e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在函数内部，JavaScript解释器将运行第一行和第二行来获得完整的语句。所以:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="44ad" class="nh md it nc b gy ni nj l nk nl">const<br/>  power = 10;</span></pre><p id="3348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与以下内容相同:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="89b0" class="nh md it nc b gy ni nj l nk nl">const power = 10;</span></pre><p id="cd8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，对于像<code class="fe mz na nb nc b">return</code>语句这样的完整语句，JavaScript解释器会将它们视为单独的行。所以:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d6df" class="nh md it nc b gy ni nj l nk nl">return <br/>  a ** 10;</span></pre><p id="39a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不等同于:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a1b6" class="nh md it nc b gy ni nj l nk nl">return a ** 10;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="c984" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使JavaScript是一种友好的语言，在编写JavaScript代码时仍然很容易出错。当我们不熟悉JavaScript时，很容易混淆<code class="fe mz na nb nc b">undefined</code>和<code class="fe mz na nb nc b">null</code>。由于JavaScript的动态类型特性，像<code class="fe mz na nb nc b">+</code>这样可以做多件事的操作符很容易被转换成我们不期望的类型，并产生错误的结果。此外，如果语句可以独立完成，那么如果我们希望两行在一起，它们就不应该写在自己的行中。</p></div></div>    
</body>
</html>