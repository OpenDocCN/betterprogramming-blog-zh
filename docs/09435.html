<html>
<head>
<title>6 JavaScript Best Practices To Master Functional Programming Style</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握函数式编程风格的6个JavaScript最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-javascript-best-practices-to-master-functional-programming-style-60141e0daa16?source=collection_archive---------1-----------------------#2021-08-25">https://betterprogramming.pub/6-javascript-best-practices-to-master-functional-programming-style-60141e0daa16?source=collection_archive---------1-----------------------#2021-08-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="490b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以现代方式使用JavaScript函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e4f735e766e95fe6375038de2b09d5c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5DyrEXp04xKTO_Y1"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sebastiancoffee?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">塞巴斯蒂安·威利斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="586d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你在这里是为了事实和最佳实践。所以，没有浪费时间的介绍。我们走吧！</p><blockquote class="lv lw lx"><p id="b6a9" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">免责声明:请记住，列出的每一项练习都是JavaScript函数式编程的进一步发展。如果你只应用了一个或几个，你的代码就不能完全发挥作用。每一步都可能违反FP设计理念，但提供了更好的功能设计。</p></blockquote><h1 id="3e48" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak"> 1。</strong>注入——神奇的分类库存</h1><p id="d23b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将从传递函数作为由<code class="fe mz na nb nc b">Array.prototype.sort()</code>方法提供的参数的例子开始。</p><p id="f043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您有一个表示<code class="fe mz na nb nc b">inventory</code> <em class="ly">、</em>的字符串数组，并且您想按字母顺序对其进行排序。您的第一个假设可能是使用如下代码结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="026d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您可能已经观察到的，我们没有向<code class="fe mz na nb nc b">sort()</code>方法传递任何参数。但是结果被很好的分类了。</p><p id="d3ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为，默认情况下，该方法根据字符串的ASCII内部表示形式对字符串进行排序。</p><p id="2513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把它和数字一起使用，你就把这个美丽的小数组的整个故事搞砸了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d8e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您必须注入自己的排序算法来实现这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用一个排序函数作为参数——以一种非常FP的方式——也有助于按照给定的属性对对象进行排序。然后我们可以使用一个比较函数。例如，您可以按年龄对人进行排序，大致如下:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="f401" class="nj md it nc b gy nk nl l nm nn">dementedPeope.sort((a,b) =&gt; a.age — b.age))</span></pre><p id="022a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:谈论字符串和排序——无论何时处理外语字符串，例如西班牙语，都应该使用<code class="fe mz na nb nc b">localCompare()</code>方法，并提供注入以获得正确的顺序。那是因为他们的字母表中有不同的字母。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="baf7" class="mc md it bd me mf nv mh mi mj nw ml mm jz nx ka mo kc ny kd mq kf nz kg ms mt bi translated"><strong class="ak"> 2。</strong>回访、承诺和分手</h1><p id="ccb0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可能已经多次使用了即将出现的例子，但是您是否已经增强了这种用法，或者只是停留在良好的旧模式上？</p><p id="7492" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我说的是作为一级对象传递的函数，它们与回调和承诺有关。</p><p id="aba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Node.js中，读取文件是异步完成的，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c43a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然<code class="fe mz na nb nc b">readFile()</code>函数想要回调。这一次，我选择了一个匿名函数来完成这项工作。</p><p id="bfb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更进一步意味着你将使用<code class="fe mz na nb nc b">promise</code>或<code class="fe mz na nb nc b">async/await</code>。</p><p id="43f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很公平！</p><p id="9c9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果您要使用<code class="fe mz na nb nc b">fetch()</code>功能，您可以按以下方式操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="8c7f" class="nj md it bd me oa ob dn mi oc od dp mm li oe of mo lm og oh mq lq oi oj ms ok bi translated"><strong class="ak">延续传球方式</strong></h2><p id="ee69" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止我给你演示的可以认为是CPS——延续传球式。</p><p id="5d7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为无论何时调用一个函数，都会传递另一个函数，该函数将在输入/输出操作完成时执行。</p><p id="83a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑一下:如果禁止使用return语句，您将如何编码？</p><p id="a114" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，这似乎是一种不可能的情况，除非允许您向被调用的函数传递回调。当该过程准备返回给调用者时，它将调用传递的回调，而不是实际返回。</p><p id="df4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些术语中，回调提供被调用的函数来继续这个过程，因此也是名称的延续。</p><p id="48ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是递归的基石。</p><p id="2bc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，我们不局限于单一的延续。与承诺一样，您可以随时提供两个或更多的备选回电。不过，这也为另一个问题打开了大门:</p><p id="2bfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你如何处理异常？</p><p id="ae1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">抛出一个错误，您就会再次遇到返回问题。</p><p id="1ca8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">摆脱这种情况的方法是每当抛出异常时提供一个替代回调。另一个真正的函数式编程的解决方案叫做单子。</p><p id="82ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑这个例子来看看这个理论的实际应用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d75b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，没有<code class="fe mz na nb nc b">return</code>声明。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="df5b" class="mc md it bd me mf nv mh mi mj nw ml mm jz nx ka mo kc ny kd mq kf nz kg ms mt bi translated">3.Polyfills — <strong class="ak">使用Ajax的超级干净代码</strong></h1><p id="2f58" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">聚合填充是一段代码，它提供了您希望浏览器本身提供的技术。定义聚合填充时，动态指定函数可提高效率。</p><p id="66dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个关于Ajax的例子，当调用是不同的方式时。您的任务是编写代码来区分和处理新旧浏览器之间的差异。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="121d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码没有做错什么。它完美地工作。</p><p id="2754" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，我不得不说，这意味着每次都要回忆起这个功能，即使什么都没有改变。</p><p id="5977" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一定有更有效的方法来做得更好。</p><p id="7987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果应用一级函数的概念呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cb84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并将其与即时调用函数表达式(IIFE)相结合。使用这种方式，您可以只检查一次条件<strong class="lb iu"> </strong>并分配正确的函数以备将来使用。</p><p id="331e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码结合了两个重要的概念。</p><ol class=""><li id="c3b0" class="ol om it lb b lc ld lf lg li on lm oo lq op lu oq or os ot bi translated">您可以动态地分配一个函数:当这段代码运行时，根据当前的浏览器，全局变量<code class="fe mz na nb nc b">window.getAjax</code>将获得三个可能值中的一个。当您稍后在代码中调用<code class="fe mz na nb nc b">getAjax()</code>时，正确的函数将会执行，无需进一步的浏览器检测测试。</li><li id="adfc" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated">按照定义<code class="fe mz na nb nc b">initializeGetAjax()</code>函数的方式，它会在运行后自动清理。所以它所有的局部变量在函数运行后都不存在了。</li></ol><p id="22f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能认为Ajax示例已经过时了。但是考虑一下使用现代的<code class="fe mz na nb nc b">fetch()</code>方式调用服务的事实。你还会发现，并不是所有的现代<a class="ae ky" href="https://caniuse.com/?search=fetch" rel="noopener ugc nofollow" target="_blank">浏览器都支持所有提供的方法</a>。</p><p id="804b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你要用一个多孔填充物来修复它，<a class="ae ky" href="https://github.com/github/fetch" rel="noopener ugc nofollow" target="_blank">就像这个</a>。如果你检查代码，你会看到一些非常熟悉的策略。当然，看完这篇文章。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="ee9e" class="mc md it bd me mf nv mh mi mj nw ml mm jz nx ka mo kc ny kd mq kf nz kg ms mt bi translated"><strong class="ak"> 4。</strong>添加缺失的功能</h1><p id="6975" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">运行中定义函数的想法也允许我们编写polyfill<em class="ly"/>来提供其他缺失的函数。举一个不太好但很常见的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用更新、更清晰的方式和利用<code class="fe mz na nb nc b">include</code>方法，我们会过得更好:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e93e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，等等！如果我或我的团队也必须支持不能使用<code class="fe mz na nb nc b">include()</code>的旧浏览器，会发生什么？</p><p id="7bd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我抓住你了！我们可以这样定义运行中的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1ff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个程序实际上检查了<code class="fe mz na nb nc b">String</code>的<code class="fe mz na nb nc b">prototype</code>是否定义了<code class="fe mz na nb nc b">include</code>方法。</p><p id="9c6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有，我们为<code class="fe mz na nb nc b">prototype</code>创建一个新的属性，并为它分配一个函数。</p><p id="1e01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终创造出我们自己的自制<code class="fe mz na nb nc b">include()</code>方法。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="f210" class="mc md it bd me mf nv mh mi mj nw ml mm jz nx ka mo kc ny kd mq kf nz kg ms mt bi translated"><strong class="ak"> 5。不仅仅是你的脚趾</strong></h1><p id="2224" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Stubbing与polyfills有一些非常相似的方面。</p><p id="030a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它始于拥有一个根据环境支持做不同事情的功能。</p><p id="0735" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存根的一般概念来自源代码测试领域，用于将一个函数替换为另一个函数，该函数只做兼职工作，而不是非存根函数会做的实际全职工作。</p><p id="f202" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，考虑使用记录器函数的常见情况。在产品的开发阶段有一个日志不仅仅是至关重要的。然而，当部署时，它应该给出一个控制台打印输出。</p><blockquote class="lv lw lx"><p id="ed54" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">提示:当然，日志文件总是一个好主意。</p></blockquote><p id="ed99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仔细思考一下，您可能会立即想到下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d748" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个程序做了比它需要的更多的工作，因为它每次都检查应用程序是否在<code class="fe mz na nb nc b">DEVELOPMENT</code>中。</p><p id="f7a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等！让我们简化一下。</p><p id="01c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">删除日志功能，这样如果不在<code class="fe mz na nb nc b">DEVELOPMENT</code>模式下，它实际上不会做任何事情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f805" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript允许调用参数多于实参的函数，并且当你不在<code class="fe mz na nb nc b">DEVELOPMENT</code>时<code class="fe mz na nb nc b">log()</code>不会发生任何事情，你可以使用<code class="fe mz na nb nc b">() =&gt; {}</code>并且它会工作。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="438b" class="mc md it bd me mf nv mh mi mj nw ml mm jz nx ka mo kc ny kd mq kf nz kg ms mt bi translated"><strong class="ak"> 6。即时调用和初始化</strong></h1><p id="33a3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">广为人知的用法，在库和框架中也被采用，引入了模块化——甚至在旧版本的JavaScript中。我说的是即时调用函数表达式(IIFE)。我已经在前面的章节中讨论过了。</p><p id="4a9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们假设你正在定义一个函数并马上调用它，这样它就可以在现场执行了。</p><p id="50e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">典型的写法是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><blockquote class="lv lw lx"><p id="a6f1" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">另一种风格是<code class="fe mz na nb nc b">(function(){//...}())</code>——函数括号的不同位置不会产生任何影响。选择你的风格并坚持下去。</p></blockquote><p id="006e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以使用相同的样式，但是向函数传递一些参数，这些参数将用作其参数的初始值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="425d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以从函数中返回一些内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e89d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题总是为什么？因为简单地内联编写代码也能为我们完成这项工作。答案是:</p><p id="e48f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">范围范围范围。</p><p id="3d78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于JavaScript的函数作用域，如果在生命中定义任何变量或函数，这些定义将是内部的，从而阻止代码的其他部分访问它。</p><p id="3a67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你为一个施法者编写了一些复杂的初始化程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0c3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，上面的代码会出什么问题呢？</p><p id="cbe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题取决于这样一个事实，即我们可能——偶然——拥有与三个被创造的函数中的任何一个同名的函数。</p><p id="7772" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript的提升特性确保后一个函数被调用，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4d9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你用了生命，问题就不会发生了。</p><p id="49a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，这三个内部函数对于代码的其余部分甚至是不可见的。这也有助于保持全局名称空间的整洁:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="29b6" class="mc md it bd me mf nv mh mi mj nw ml mm jz nx ka mo kc ny kd mq kf nz kg ms mt bi translated">结论</h1><p id="3744" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本文演示了函数定义的几种方法。这几种JS技术恰好在概念上是完全FP的。</p><blockquote class="lv lw lx"><p id="4dd9" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">免责声明:请记住，列出的每一项练习都是JavaScript函数式编程的进一步发展。如果你只应用了一个或几个，你的代码就不能完全发挥作用。每一步都可能违反FP设计理念，但提供了更好的功能设计。</p></blockquote><p id="ac0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="a7c0" class="mc md it bd me mf nv mh mi mj nw ml mm jz nx ka mo kc ny kd mq kf nz kg ms mt bi translated">资源</h1><ul class=""><li id="dcd5" class="ol om it lb b lc mu lf mv li oz lm pa lq pb lu pc or os ot bi translated"><a class="ae ky" href="https://levelup.gitconnected.com/understanding-functional-programming-in-javascript-a-complete-guide-e85ed13b42c8" rel="noopener ugc nofollow" target="_blank">理解Javascript中的函数式编程——完全指南</a></li><li id="fe3e" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu pc or os ot bi translated"><a class="ae ky" href="https://www.freecodecamp.org/news/functional-programming-principles-in-javascript-1b8fc6c3563f/" rel="noopener ugc nofollow" target="_blank">Javascript中的函数式编程原则</a></li><li id="31a0" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu pc or os ot bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=sCAR8ZPM6ew" rel="noopener ugc nofollow" target="_blank">使用JavaScript的函数式编程</a></li><li id="326c" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu pc or os ot bi translated"><a class="ae ky" href="https://amzn.to/3ziF8cL" rel="noopener ugc nofollow" target="_blank">掌握JavaScript函数式编程</a></li></ul></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h2 id="8a8a" class="nj md it bd me oa ob dn mi oc od dp mm li oe of mo lm og oh mq lq oi oj ms ok bi translated">想联系作者？</h2><p id="e27d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://arnoldcodeacademy.ck.page/26-web-dev-cheat-sheets" rel="noopener ugc nofollow" target="_blank"> <em class="ly">获取26份备忘单，只研究你真正需要的东西，以获得你的第一份网络开发工作！</em> </a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/227a060a3bfa55f41fa795d5990e6032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Nqyiu4c6K-mCxE9e.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://arnoldcodeacademy.ck.page/26-web-dev-cheat-sheets" rel="noopener ugc nofollow" target="_blank"> Arnold Code Academy 26 Web开发人员备忘单</a></p></figure></div></div>    
</body>
</html>