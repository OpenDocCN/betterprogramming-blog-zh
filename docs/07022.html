<html>
<head>
<title>Write Your First Smart Contract Using Remix IDE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Remix IDE编写您的第一个智能合同</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/developing-a-smart-contract-by-using-remix-ide-81ff6f44ba2f?source=collection_archive---------1-----------------------#2020-11-30">https://betterprogramming.pub/developing-a-smart-contract-by-using-remix-ide-81ff6f44ba2f?source=collection_archive---------1-----------------------#2020-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5c1e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们学习如何在以太坊上写智能合约</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/3d474120f27e1d8f06380efa1d6b5d08.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*3jj5tQildSIyhl-RO6RLlA.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><a class="ae kr" href="https://remix-project.org/" rel="noopener ugc nofollow" target="_blank"> Remix </a> logo</p></figure><p id="c49a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在这个故事中，我们将研究如何通过使用<a class="ae kr" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix IDE </a>来开发一个具有可靠性的智能合约，Remix IDE 是专门用于实现以太坊网络合约的工具之一。</p><p id="fe13" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们将为基本银行业务开发一个智能合约，并尽可能确保它包含Solidity提供的所有功能和能力。此外，我们将了解如何在任何帐户和我们开发的合同之间发送ETH(从帐户到合同或从合同到帐户)，以及如何限制可以使用智能合同相关功能的人员。</p><p id="37d1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在开始编写契约代码之前，坚实的知识对于理解我们将在下面实现的所有内容是必不可少的。作为本文的一部分，我不会提到以太坊和坚固性的基础，但在下面链接的文章中，你可以找到关于什么是以太坊和坚固性的详细信息，以太坊建立的原则和思想，以及组成坚固性的元素。</p><div class="lo lp gp gr lq lr"><a href="https://medium.com/better-programming/overview-of-ethereum-solidity-d7a0ea5fbf00" rel="noopener follow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd ir gy z fp lw fr fs lx fu fw ip bi translated">以太坊和固体概述</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">一本关于以太坊区块链、Solidity编程语言和智能合约的有用入门书</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">medium.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf kl lr"/></div></div></a></div></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="7cce" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">入门指南</h1><p id="1a0f" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">假设我们现在熟悉以太坊和Solidity，我们可以开始开发一个智能合约，它包括Solidity提供的所有功能和能力，或者至少尽可能多。有几种方法可以开发智能合同。在这些方法中，我们将使用Remix IDE，这是一个强大的开源工具，它提供了从浏览器开发智能合同的能力。</p><p id="d7d4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">首先，让我们从浏览器打开Remix IDE，创建一个扩展名为<code class="fe nk nl nm nn b">.sol</code>的新文件。我们将在这里使用它作为我们的可靠性代码。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="521f" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">声明合同</h1><p id="f5ef" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">我们应该在我们想要使用的可靠版本旁边声明一个契约。</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="530a" class="ns mo iq nn b gy nt nu l nv nw">pragma solidity ^0.6.6;</span><span id="e4eb" class="ns mo iq nn b gy nx nu l nv nw">contract BankContract { }</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="59a7" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">定义状态变量、数据类型和数据结构</h1><p id="11df" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">我们创建一个客户机对象来保存客户机的信息，它将通过使用<code class="fe nk nl nm nn b">struct</code>元素来加入契约。它在合同中保留客户的ID、地址和余额。然后我们创建一个<code class="fe nk nl nm nn b">client_account</code>类型的数组来保存我们所有客户的信息。</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="74d8" class="ns mo iq nn b gy nt nu l nv nw">pragma solidity ^0.6.6;</span><span id="f43b" class="ns mo iq nn b gy nx nu l nv nw">contract BankContract {<br/>    <strong class="nn ir">struct client_account{<br/>        int client_id;<br/>        address client_address;<br/>        uint client_balance_in_ether;<br/>    }</strong></span><span id="13e7" class="ns mo iq nn b gy nx nu l nv nw"><strong class="nn ir">    client_account[] clients;</strong><br/>}</span></pre><p id="d75f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">每当客户加入契约时，我们都应该给他们分配一个ID，所以我们定义了一个<code class="fe nk nl nm nn b">int</code>计数器，并在契约的构造函数中将它设置为<code class="fe nk nl nm nn b">0</code>。</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="c640" class="ns mo iq nn b gy nt nu l nv nw">pragma solidity ^0.6.6;</span><span id="20a8" class="ns mo iq nn b gy nx nu l nv nw">contract BankContract {<br/>    struct client_account{<br/>        int client_id;<br/>        address client_address;<br/>        uint client_balance_in_ether;<br/>    }</span><span id="29fe" class="ns mo iq nn b gy nx nu l nv nw">    client_account[] clients;</span><span id="15ec" class="ns mo iq nn b gy nx nu l nv nw">    <strong class="nn ir">int clientCounter;<br/>    constructor() public{<br/>        clientCounter = 0;<br/>    }</strong><br/>}</span></pre><p id="2feb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">此外，我们需要为经理定义一个<code class="fe nk nl nm nn b">address</code>变量和一个<code class="fe nk nl nm nn b">mapping</code>变量来保存每个客户的最后利息日期。因为我们希望限制再次向任何帐户发送利息所需的时间，所以它将用于检查是否已经过了足够的时间。</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="d22b" class="ns mo iq nn b gy nt nu l nv nw">pragma solidity ^0.6.6;</span><span id="1668" class="ns mo iq nn b gy nx nu l nv nw">contract BankContract {<br/>    struct client_account{<br/>        int client_id;<br/>        address client_address;<br/>        uint client_balance_in_ether;<br/>    }</span><span id="0a87" class="ns mo iq nn b gy nx nu l nv nw">    client_account[] clients;</span><span id="07ee" class="ns mo iq nn b gy nx nu l nv nw">    int clientCounter;</span><span id="f2f4" class="ns mo iq nn b gy nx nu l nv nw">    <strong class="nn ir">address payable manager;<br/>    mapping(address =&gt; uint) public interestDate;</strong></span><span id="4692" class="ns mo iq nn b gy nx nu l nv nw">    constructor() public{<br/>        clientCounter = 0;<br/>    }<br/>}</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="b70b" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">实现修饰符</h1><p id="e9e0" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">在智能协定中，您可能需要限制可以调用相关方法的人员，或者您可能希望只允许在特定情况下执行该方法。在这种情况下，<code class="fe nk nl nm nn b">modifier</code>会检查您已经实现的条件，并决定是否应该执行相关的方法。</p><p id="1b3a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在实现我们需要组织智能契约的所有方法之前，我们必须实现两个修饰符。这两种方法都将检查调用相关方法的人以及使用了哪个修饰符。其中一个确定发送者是否是管理者，另一个确定发送者是否是客户。</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="a279" class="ns mo iq nn b gy nt nu l nv nw">pragma solidity ^0.6.6;</span><span id="8c00" class="ns mo iq nn b gy nx nu l nv nw">contract BankContract {<br/>    struct client_account{<br/>        int client_id;<br/>        address client_address;<br/>        uint client_balance_in_ether;<br/>    }</span><span id="4064" class="ns mo iq nn b gy nx nu l nv nw">    client_account[] clients;<br/>    <br/>    int clientCounter;<br/>    address payable manager;<br/>    mapping(address =&gt; uint) public interestDate;</span><span id="b105" class="ns mo iq nn b gy nx nu l nv nw">    constructor() public{<br/>        clientCounter = 0;<br/>    }</span><span id="2a69" class="ns mo iq nn b gy nx nu l nv nw">    <strong class="nn ir">modifier onlyManager() {<br/>        require(msg.sender == manager, "Only manager can call!");<br/>        _;<br/>    }<br/>    <br/>    modifier onlyClients() {<br/>        bool isClient = false;<br/>        for(uint i=0;i&lt;clients.length;i++){<br/>            if(clients[i].client_address == msg.sender){<br/>                isClient = true;<br/>                break;<br/>            }<br/>        }<br/>        require(isclient, "Only clients can call!");<br/>        _;<br/>    }</strong><br/>}</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="34a6" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">实现回退功能</h1><p id="39fc" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated"><code class="fe nk nl nm nn b">fallback</code>函数对于使契约从任何地址接收以太网是必不可少的。<code class="fe nk nl nm nn b">receive</code>关键字是Solidity 0.6.x中新增的，它被用作<code class="fe nk nl nm nn b">fallback</code>函数来接收以太。</p><p id="1584" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">因为我们将从客户那里收到以太作为押金，所以我们需要实现<code class="fe nk nl nm nn b">fallback</code>函数。</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="1b22" class="ns mo iq nn b gy nt nu l nv nw">pragma solidity ^0.6.6;</span><span id="3e23" class="ns mo iq nn b gy nx nu l nv nw">contract BankContract {<br/>    struct client_account{<br/>        int client_id;<br/>        address client_address;<br/>        uint client_balance_in_ether;<br/>    }</span><span id="3c1c" class="ns mo iq nn b gy nx nu l nv nw">    client_account[] clients;<br/>    <br/>    int clientCounter;<br/>    address payable manager;<br/>    mapping(address =&gt; uint) public interestDate;</span><span id="d911" class="ns mo iq nn b gy nx nu l nv nw">    constructor() public{<br/>        clientCounter = 0;<br/>    }</span><span id="8dde" class="ns mo iq nn b gy nx nu l nv nw"><strong class="nn ir">    </strong>modifier onlyManager() {<br/>        require(msg.sender == manager, "Only manager can call!");<br/>        _;<br/>    }<br/>    <br/>    modifier onlyClients() {<br/>        bool isClient = false;<br/>        for(uint i=0;i&lt;clients.length;i++){<br/>            if(clients[i].client_address == msg.sender){<br/>                isClient = true;<br/>                break;<br/>            }<br/>        }<br/>        require(isclient, "Only clients can call!");<br/>        _;<br/>    }</span><span id="baa3" class="ns mo iq nn b gy nx nu l nv nw">    <strong class="nn ir">receive() external payable { }</strong><br/>}</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="f1bd" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">开发方法</h1><p id="e9b4" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">在声明契约、定义变量、实现修饰符和回退函数之后，我们将开始开发我们将使用的方法。</p><p id="eee7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在本合同中，我们将开发以下方法:</p><ul class=""><li id="f419" class="ny nz iq ku b kv kw ky kz lb oa lf ob lj oc ln od oe of og bi translated"><code class="fe nk nl nm nn b">setManager</code>方法将用于将管理器地址设置为我们已经定义的变量。<code class="fe nk nl nm nn b">managerAddress</code>作为一个参数使用，并转换为payable以提供发送以太网。</li></ul><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="439a" class="ns mo iq nn b gy nt nu l nv nw">function setManager(address managerAddress) public returns(string memory){<br/>     manager = payable(managerAddress);<br/>     return "";<br/>}</span></pre><ul class=""><li id="eb26" class="ny nz iq ku b kv kw ky kz lb oa lf ob lj oc ln od oe of og bi translated">将使用<code class="fe nk nl nm nn b">joinAsClient</code>方法来确保客户加入合同。每当客户加入联系人时，他们的利息日期将被设置，并且客户信息将被添加到<code class="fe nk nl nm nn b">client</code>数组中。</li></ul><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="55ab" class="ns mo iq nn b gy nt nu l nv nw">function joinAsClient() public payable returns(string memory){<br/>     interestDate[msg.sender] = now;<br/>     clients.push(client_account(clientCounter++, msg.sender, address(msg.sender).balance));<br/>     return "";<br/>}</span></pre><ul class=""><li id="391b" class="ny nz iq ku b kv kw ky kz lb oa lf ob lj oc ln od oe of og bi translated">将使用<code class="fe nk nl nm nn b">deposit</code>方法将ETH从客户帐户发送到合同。我们希望这个方法只能被加入契约的客户调用，所以这个限制使用了<code class="fe nk nl nm nn b">onlyClient</code>修饰符。</li></ul><p id="0a8b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">注意:</strong><code class="fe nk nl nm nn b">transfer</code>方法属于契约，专用于在地址间发送指定数量的ETH。<code class="fe nk nl nm nn b">payable</code>关键字使得接收ETH转账成为可能，因此<code class="fe nk nl nm nn b">msg.value</code>中指示的ETH金额将被转账到合同地址。</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="8a7c" class="ns mo iq nn b gy nt nu l nv nw">function deposit() public payable onlyClients{<br/>     payable(address(this)).transfer(msg.value);<br/>}</span></pre><ul class=""><li id="f8a9" class="ny nz iq ku b kv kw ky kz lb oa lf ob lj oc ln od oe of og bi translated"><code class="fe nk nl nm nn b">withdraw</code>方法将用于将ETH从合同发送到客户账户。它将<code class="fe nk nl nm nn b">amount</code>参数中指示的ETH单位从合同发送到发送交易的客户端。我们希望这个方法只能被加入契约的客户调用，所以这个限制使用了<code class="fe nk nl nm nn b">onlyClient</code>修饰符。</li></ul><p id="f71a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">注意:</strong>发送者的地址保存在<code class="fe nk nl nm nn b">msg.sender</code>变量中。</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="cfc8" class="ns mo iq nn b gy nt nu l nv nw">function withdraw(uint amount) public payable onlyClients{<br/>     msg.sender.transfer(amount * 1 ether);<br/>}</span></pre><ul class=""><li id="04d5" class="ny nz iq ku b kv kw ky kz lb oa lf ob lj oc ln od oe of og bi translated">将使用<code class="fe nk nl nm nn b">sendInterest</code>方法将ETH作为合同的利息发送给所有客户。我们希望这个方法只能被管理器调用，所以这个限制使用了<code class="fe nk nl nm nn b">onlyManager</code>修饰符。这里，将为所有客户端检查相关客户端获取利息的最后日期，如果特定时间段已经过去，将发送利息。最后，如果发送了新的利息，则相关客户的新利息日期将被重置到<code class="fe nk nl nm nn b">interestDate</code>数组中。</li></ul><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="be5a" class="ns mo iq nn b gy nt nu l nv nw">function sendInterest() public payable onlyManager{<br/>     for(uint i=0;i&lt;clients.length;i++){<br/>          address initialAddress = clients[i].client_address;<br/>          uint lastInterestDate = interestDate[initialAddress];<br/>          if(now &lt; lastInterestDate + 10 seconds){<br/>               revert("It's just been less than 10 seconds!");<br/>          }<br/>          payable(initialAddress).transfer(1 ether);<br/>          interestDate[initialAddress] = now;<br/>     }<br/>}</span></pre><ul class=""><li id="645c" class="ny nz iq ku b kv kw ky kz lb oa lf ob lj oc ln od oe of og bi translated"><code class="fe nk nl nm nn b">getContractBalance</code>方法将用于获取我们部署的契约的余额。</li></ul><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="36d2" class="ns mo iq nn b gy nt nu l nv nw">function getContractBalance() public view returns(uint){<br/>     return address(this).balance;<br/>}</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="ca65" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">智能合约的最终状态</h1><p id="929c" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">在所有这些改进之后，下面是我们的银行应用程序的最终状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="299d" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">编译智能合同</h1><p id="4fe0" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">在完成智能合约的开发之后，我们将把它编译到Remix IDE上。如下图所示，我们有了<code class="fe nk nl nm nn b">BankContract.sol</code>文件，还有两个我们将使用的部分:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/64c58fc191a1ed4ca5bf27c5fcf9465a.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*si6GEhELHAp4oi5zZt85zg.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">混音IDE</p></figure><ul class=""><li id="0c36" class="ny nz iq ku b kv kw ky kz lb oa lf ob lj oc ln od oe of og bi translated">用<code class="fe nk nl nm nn b">I</code>表示的部分是Solidity编译器，我们在这个部分中使用它来测试我们的智能契约。</li><li id="e5f0" class="ny nz iq ku b kv ok ky ol lb om lf on lj oo ln od oe of og bi translated">用<code class="fe nk nl nm nn b">II</code>表示的部分是Deploy &amp; Run Transactions，我们将在编译它之后在下面的部分使用它。</li></ul><p id="efd8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们应该编译我们从上图中用<code class="fe nk nl nm nn b">I</code>表示的部分开发的智能契约。下图显示了当我们转到Solidity编译器部分时所面临的情况。我们根据之前指定的版本选择编译器版本，然后单击该部分底部的按钮。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><div class="gh gi op"><img src="../Images/561102afeb4a932e72714f68171ef326.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*Ig1tosxBwyDzDOnI5KKbBA.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">可靠性编译器部分</p></figure><p id="dd73" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">一旦我们没有任何问题地编译了智能合约，我们就可以继续部署智能合约和运行事务了。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="4629" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">部署智能合同</h1><p id="d649" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">我们应该部署我们从上图中用<code class="fe nk nl nm nn b">II</code>表示的部分开发的智能契约。下图显示了当我们转到部署&amp;运行事务<em class="ou"> </em>部分时所面临的情况。</p><p id="75cb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Remix IDE提供了将智能合约部署到各种环境中的各种机会。在这里，我们可以使用我们选择的配置在任何我们想要的环境中部署智能合约。此外，我们可以使用这里设置的参数运行任何调用智能契约方法的事务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/dc09c449fa8e9bf145d30f9eb9f8381c.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*FpxDVXJafMJ5FFNj3Tlj_g.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><em class="ow">部署&amp;运行事务部分</em></p></figure><p id="c73c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在本文中，我们将在JavaScript VM环境中部署我们的契约，因此我们将在以下环境中选择它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/1f2f48e9d5ceb139b27a5c51a31db304.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*JprcM_azjz12RAsL0iKS4g.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">环境列表</p></figure><p id="35f5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在accounts组合框中，我们将能够在部署和测试智能合约期间使用许多帐户。在Remix IDE提供的这些帐户中，我们将选择第一个帐户来部署联系人。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/eeaa252335a50640b300f8c99068a4cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*_SUzBlR6wQoPTUQdKNdo8A.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">帐目</p></figure><p id="51ff" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">设置好环境和帐户后，我们就可以部署它了，所以我们单击deploy按钮。在terminal部分，事务结果如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><div class="gh gi oz"><img src="../Images/3876af37f06d7a43e1e70f68e998b782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ydGnFhlkX-XKWxJVFpqyVQ.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">交易结果</p></figure><p id="6e76" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">注:</strong>合同地址是从我们客户账户发送的ETH将被保存的地址。</p><p id="fa46" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">根据上述交易结果，智能合约已成功部署到所选账户。部署智能合约操作会给部署它的发送方带来成本。<code class="fe nk nl nm nn b">transaction cost</code>代表我们部署契约所需的成本——<code class="fe nk nl nm nn b">transaction cost</code>中的金额来自账户——如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/9bd1448d05a508d266102371f98dcdd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*hJtiv3I-TvodamVeCl5Ppw.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">帐目</p></figure><p id="e34b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">另一方面，可以在左侧的已部署合同子部分中看到已部署的智能合同。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/daf2c24715bcdb93fb986fdc550bd229.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*uVWsg9eFH6vz9bsaPNJzWQ.png"/></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="97fd" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">运行交易</h1><p id="8caa" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">现在，我们准备调用复合智能合约开发的函数。当我们在Deployed Contract小节中展开相关的契约时，所开发的方法就会出现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/ad4871b3486d2f75c7dabe56b370192b.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*9GkL_7km0JLniclJlrTneQ.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">这些方法</p></figure><h2 id="f74f" class="ns mo iq bd mp pc pd dn mt pe pf dp mx lb pg ph mz lf pi pj nb lj pk pl nd pm bi translated">setManager方法</h2><p id="6d99" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">我们开始通过调用这些方法来模拟一个小的过程。首先，我们应该设置一个经理。因此，我们键入一个从帐户组合中选择的地址，然后单击黄色的<code class="fe nk nl nm nn b">setManager</code>按钮。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/2397a30a59fa3ae5498a586f3b875ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*p_DALOshyD8SHlRck4ieEw.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">setManager方法</p></figure><p id="d567" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">终端中会出现以下输出。解码后的输出显示了从该方法返回的消息，这是一个空字符串消息——正如我们所预期的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><div class="gh gi po"><img src="../Images/d567c85dc35ecccd938a14346e4d9b15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R4gab8NCuQp5ZKSrEEfgsg.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">setManager方法的结果</p></figure><h2 id="c378" class="ns mo iq bd mp pc pd dn mt pe pf dp mx lb pg ph mz lf pi pj nb lj pk pl nd pm bi translated">joinAsClient方法</h2><p id="cff9" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">我们将继续作为从account组合中确定的三个客户端的客户端加入，并为每个客户端调用<code class="fe nk nl nm nn b">joinAsClient</code>方法。</p><p id="ba63" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">此时——这与上一次不同——我们应该在选择相关帐户时调用该方法，因为我们从这里获取了<code class="fe nk nl nm nn b">msg.sender</code>值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/1f7e3d0e40846710b34de4a7dc486a7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*_T4qVtl0trgJ4b3ROLyOOA.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">客户的账户</p></figure><p id="203e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这三个账户被选作客户端，我们分别点击了红色的<code class="fe nk nl nm nn b">joinAsClient</code> <em class="ou"> </em>按钮。完成这些操作后，终端会显示以下信息，这意味着这三个帐户在合同中被设置为客户。此外，还从客户账户中扣除了运行该方法的特定费用。</p><div class="kg kh ki kj gt ab cb"><figure class="pq kk pr ps pt pu pv paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><img src="../Images/85937cb1685cc05ead9c162871669164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*WqkkaQtzTRQcHCBlhke7yw.png"/></div></figure><figure class="pq kk pw ps pt pu pv paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><img src="../Images/06a855b3f31732633811f59481b439dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*vVyJBDLCQD8qNsbFgJP1TQ.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk px di py pz translated">joinAsClient方法的结果</p></figure></div><h2 id="d4cb" class="ns mo iq bd mp pc pd dn mt pe pf dp mx lb pg ph mz lf pi pj nb lj pk pl nd pm bi translated">存款方法</h2><p id="c39b" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">现在，我们将通过存款方式从客户账户中向合同发送10 ETH。在存款方法中，我们从发送方获取在<code class="fe nk nl nm nn b">msg.value</code>中声明的金额，该金额在<code class="fe nk nl nm nn b">msg.sender</code>变量中表示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/b63fa40706c8bf6a4b91002f73f36903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*Qmsc-wx5bQSru5kjVD0eMg.png"/></div></figure><p id="c2bb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">因此，我们设置10 ETH，并通过为每个客户端帐户单击红色的存款按钮来调用存款方法，就像我们之前对<code class="fe nk nl nm nn b">joinAsClient</code>方法所做的那样。完成这些操作后，终端显示以下信息，这意味着这三个帐户从他们的帐户向合同地址发送了10 ETH。此外，帐户余额的最终状态如下所示:</p><div class="kg kh ki kj gt ab cb"><figure class="pq kk qb ps pt pu pv paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><img src="../Images/b275a7e9f7c9e6b9d190802173887adf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*WEyrZNmALJR8cj8VGNJADg.png"/></div></figure><figure class="pq kk qc ps pt pu pv paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><img src="../Images/b74b5fd91e53a7edd684b01f63bb664c.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*MHVz8fg9qevtqr3RFDqeyw.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk qd di qe pz translated">存款方法的结果</p></figure></div><h2 id="9d51" class="ns mo iq bd mp pc pd dn mt pe pf dp mx lb pg ph mz lf pi pj nb lj pk pl nd pm bi translated">getContractBalance方法</h2><p id="cf3c" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">现在，我们调用<code class="fe nk nl nm nn b">getContractBalance</code>方法来检查从客户端发送的第30个ETH是否存在于合同帐户中。因此，我们单击蓝色的getContractBalance按钮，它返回一个对应于30 ETH in Wei的金额。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/c37a07d3429cd71e3151a04fa606960a.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*LW17iRYQEPWX2pyVRMGyhg.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">getContractBalance方法</p></figure><p id="6999" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">与我们目前应用的方法不同，这个方法只是返回一个值，而不改变任何状态变量。因此，它是免费执行的，终端中的警告似乎有点不同。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><div class="gh gi qg"><img src="../Images/a7d20072997a1033e725f32bea9bd204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k7gfU8ZyFtoDn0Y9av6Rjw.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">getContractBalance方法的结果</p></figure><h2 id="cf95" class="ns mo iq bd mp pc pd dn mt pe pf dp mx lb pg ph mz lf pi pj nb lj pk pl nd pm bi translated">sendInterest方法</h2><p id="1165" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">在检查合同不再为空之后，我们可以通过调用<code class="fe nk nl nm nn b">sendInterest</code>方法向客户发送利息。我们选择之前设置为经理帐户的帐户，然后单击红色的sendInterest按钮。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><div class="gh gi qh"><img src="../Images/fda8135780ab6c910253b781db3bb29c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dEyxRUmHXXCwzrcQSulgnA.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><em class="ow">send interest</em>方法的结果</p></figure><p id="acd5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在终端中调用方法后，会出现上图中的消息。此消息意味着第一次成功发送到每个客户的帐户。我们可以看到，在此操作之后，每个客户端的余额从89增加到90。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qi"><img src="../Images/0e8fc79a0c84517ca4dd92e9ea2a5fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*y7RyymS6ztHrgVV0LEu2zw.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">客户的账户</p></figure><p id="3221" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们实现了一个限制，检查自调用<code class="fe nk nl nm nn b">sendInterest</code>方法以来是否已经过了10秒。为了检查这个控件，我们在10秒钟内再次调用相同的方法。交易按预期进行，终端出现了<code class="fe nk nl nm nn b">"It’s just been less than 10 seconds!"</code>消息，如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><div class="gh gi qj"><img src="../Images/22a034271ed5c2e136ad47ceabbf887d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1chlMGnniCTLyXbujIWdvQ.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><em class="ow">“才过了不到10秒！”消息</em></p></figure><h2 id="21cd" class="ns mo iq bd mp pc pd dn mt pe pf dp mx lb pg ph mz lf pi pj nb lj pk pl nd pm bi translated">该提取方法</h2><p id="61d5" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">现在，我们调用我们开发的最后一个方法，从合同中提取一笔金额到客户的账户。在取款方法中，我们将在<code class="fe nk nl nm nn b">msg.value</code>中声明的金额从账户转移到在<code class="fe nk nl nm nn b">msg.sender</code>变量中表示的发送方。</p><p id="53e9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在这一点上，有一个问题被意识到了，那就是没有作为客户加入契约的人也可以调用这个方法。我们使用<code class="fe nk nl nm nn b">onlyClient</code>修改器来避免这个问题。</p><p id="9d5a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当我们选择一个属于任何未加入合同的客户的账户，然后通过红色的取款按钮调用取款方法时，会显示<code class="fe nk nl nm nn b">"Only clients can call this!"</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><div class="gh gi qk"><img src="../Images/99ab2811db220011c51bf02b57f91642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SgFGhmUEgm25zp3CXT6klQ.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><em class="ow">“只有客户才能调用这个！”消息</em></p></figure><p id="4af7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果我们选择任何加入合同的人并点击红色的撤回按钮，我们预计发送者的金额将从90增加到99 ETH。</p><div class="kg kh ki kj gt ab cb"><figure class="pq kk ql ps pt pu pv paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><img src="../Images/2b999d9b22a7347d826f9910f64fa06f.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*MuXAu8I5_hnzbYZUId82GA.png"/></div></figure><figure class="pq kk qm ps pt pu pv paragraph-image"><img src="../Images/37cf7f3b67d4111d24d2277425d18f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*mjg5qQsXicunrOSjiRex1Q.png"/><p class="kn ko gj gh gi kp kq bd b be z dk qn di qo pz translated">该提取方法</p></figure></div><p id="7c06" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在调用该方法后，我们看到ETH的数量如我们预期的那样增加了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qp"><img src="../Images/9a011c69e66ebe07b00939a6421c91be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*XoVD0LpZfv8R2sa9iLUADQ.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">发送方的余额</p></figure><p id="2db6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但如你所见，最后一笔金额少了31，830魏，这相当于执行交易应从汇款人账户中提取的交易成本。如果我们在终端中查看交易细节，我们可以看到与交易成本完全相同的金额。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><div class="gh gi qq"><img src="../Images/e7038b9514555a533fd044ca37276b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hPBCbTZ2h6kqsBK1Y5eQMQ.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><em class="ow">撤回</em>方法的结果</p></figure><p id="a9d8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在这些操作之后，合同地址中应该只剩下18个ETH，因为合同中总共发送了12个ETH(3个ETH作为利息，9个ETH作为提款)。</p><p id="5447" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果我们调用<code class="fe nk nl nm nn b">getContractBalance</code> <em class="ou"> </em>方法，我们会看到下面的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qr"><img src="../Images/4274bb434b6e884b5bc941181985c761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*CsCf0tVckQcWe1r7N3xR-A.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">getContractBalance方法</p></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="cd2c" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">结论</h1><p id="c92e" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">仅此而已！在本文中，我们开发了一个智能契约，它允许尽可能多地实现复合稳固性的所有元素。然后我们在Remix IDE上编译并部署了它。最后，我们通过模拟一个流程的方法测试了它提供的所有功能。</p></div></div>    
</body>
</html>