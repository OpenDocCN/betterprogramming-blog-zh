<html>
<head>
<title>The Prototype Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的原型模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-prototype-pattern-in-javascript-bfe9ff433e6c?source=collection_archive---------5-----------------------#2019-11-17">https://betterprogramming.pub/the-prototype-pattern-in-javascript-bfe9ff433e6c?source=collection_archive---------5-----------------------#2019-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="27b7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">与面向对象的类相比，使用它可以获得性能提升</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ec81eb0b19aa7d87d3b202bd94590fb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z5TAea-hXoFfXZTZcVrvaw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">多梅尼科·洛亚在Unsplash </em>上拍摄的照片</p></figure><p id="6d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript中可以实现多种设计模式，在本文中，我们将讨论<em class="lv">原型设计模式，</em>一种基于对象的创造性设计模式。</p><p id="786b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要对JavaScript中的三种设计模式进行回顾，这里有一个概述:</p><ul class=""><li id="f58f" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">创造性设计模式:这些模式为你创建对象，而不是直接实例化对象。这种方法的好处是，在决定需要创建哪些对象时，它给了您的程序更多的灵活性。</li><li id="fa5e" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">行为设计模式:</strong>这些模式专注于对象之间的交流。</li><li id="70d6" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">结构设计模式:</strong>这些模式专注于类和对象的组合。它们可用于通过继承来组合接口，并定义组合多个对象的方式，以实现新的功能。</li></ul><p id="f842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，原型模式到底是什么，它有什么作用？</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="333a" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">原型模式</h1><p id="ef52" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">该模式的主要焦点是帮助创建对象，这些对象可以用作由构造函数创建的任何<em class="lv"> </em>对象的蓝图。它通过所谓的<a class="ae no" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" rel="noopener ugc nofollow" target="_blank"> <em class="lv">原型继承</em> </a>来做到这一点。</p><p id="d467" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于JavaScript具有对原型继承的原生支持，因此使用起来自然很容易，甚至不需要学习语法本身之外的任何新概念。</p><p id="a946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当对象通过构造函数创建并包含<code class="fe np nq nr ns b">name</code>属性时，用同一构造函数创建的其他对象也将具有相同的属性，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="4a9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这听起来像典型的类对象，但实际上，它完全避免使用类。原型设计模式只是创建现有功能对象的副本，而不是定义全新的对象。</p><p id="ecfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与面向对象的类相比，在JavaScript中使用该模式的最大好处是性能提升。这意味着当您在对象内部定义函数时，它们将通过引用来创建。换句话说，所有子对象将指向同一个方法，而不是创建它们自己的单独副本！</p><p id="12c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是这种模式的一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1dd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的代码示例中，我们通过使用<code class="fe np nq nr ns b">Warrior.prototype.&lt;method&gt; = function() {...}</code>来定义战士的攻击方法。你可以看到我们已经用关键字<code class="fe np nq nr ns b">new</code>实例化了一些战士，所以现在我们看两个实例。两个实例都根据调用者传入的<code class="fe np nq nr ns b">name</code>参数来设置它们的<code class="fe np nq nr ns b">name</code>属性。</p><p id="3868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在原型中定义方法<code class="fe np nq nr ns b">bash</code>和<code class="fe np nq nr ns b">omniSlash</code>时，正如所展示的，我们看到的两个独立的实例实际上引用了相同的<code class="fe np nq nr ns b">bash</code>和<code class="fe np nq nr ns b">omniSlash</code>函数！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b48f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们这样定义它们，那么它们就不一样了。本质上，JavaScript为每个实例创建了(假定)相同方法的另一个副本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e300" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以如果我们不像上一个例子那样使用原型模式，那么当我们实例化许多实例时会有多疯狂？我们已经克隆了一些方法，它们从本质上做着同样的事情，甚至不需要被复制，除非它们依赖于实例内部的状态。</p><p id="df8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">扩展原型的另一种变体是如下所示的语法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="52d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这相当于:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="a671" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="89d0" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>