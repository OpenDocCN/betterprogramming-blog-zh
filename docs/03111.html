<html>
<head>
<title>The Flyweight Pattern in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中的轻量级模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-flyweight-pattern-in-go-a0712764195a?source=collection_archive---------9-----------------------#2020-01-21">https://betterprogramming.pub/the-flyweight-pattern-in-go-a0712764195a?source=collection_archive---------9-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a350" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过与其他对象共享数据来最小化内存使用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/88e71c113b32f0a04277ceb39a91ec05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*me9SMwKwJ18bden7Rks0SQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">罗伯特·克里斯在<a class="ae ky" href="https://unsplash.com/s/photos/fly?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="f34c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Flyweight_pattern" rel="noopener ugc nofollow" target="_blank">定义</a>:</p><blockquote class="lv lw lx"><p id="f3a1" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">Flyweight是一种软件设计模式。flyweight是通过与其他类似对象共享尽可能多的数据来最小化内存使用的对象；当简单的重复表示会使用不可接受的内存量时，这是一种大量使用对象的方法。—维基百科</p></blockquote><p id="b427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面，我将在<a class="ae ky" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>中用两个例子演示flyweight模式。首先，我将优化依赖于相同底层数据的两个基于内存的缓存，然后我将优化另一个包含重复数据的缓存。</p><p id="d3f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧。所有的例子都是用Golang写的，完整的例子在附录中提供。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="ec30" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">序文</h1><p id="3b3d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">对于这两个示例，请考虑以下类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">玩家定义。</p></figure><p id="c119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">游戏平台上的玩家。这有点做作，但对我们的目的来说相当简单。示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一号玩家。</p></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="a469" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">第一个例子:一个缓存，三种查找方法</h1><p id="10b0" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">假设我们希望将应用程序中的每一个<code class="fe ni nj nk nl b">Player</code>都缓存在内存中以便快速访问，我们需要能够通过<code class="fe ni nj nk nl b">ID</code>、<code class="fe ni nj nk nl b">Handle</code>和国家<code class="fe ni nj nk nl b">Code</code>来查找它们。第一个(简单的)实现可能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">包含相同玩家的三个数据结构。</p></figure><p id="f29b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过循环遍历各个表行，用数据库中的数据填充它们，对于每一行，用每行中的字段填充一个<code class="fe ni nj nk nl b">Player</code>实例，并将其添加到每个地图中。</p><p id="f917" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用映射进行查找是因为它们<em class="ly">高效</em>:当您已经有了键时，您不需要每次都遍历整个数据结构——一个<em class="ly"> O(n) </em>操作——而是可以在常量时间内进行直接查找，<em class="ly"> O(1) </em>。</p><p id="b0cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当有数千或数百万玩家时，这是一个重要的优化。</p><p id="99fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们快速看一下上面每一项的查找函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">重构前查找函数。</p></figure><p id="6cb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相当简单。</p><p id="38a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是有一个问题:<em class="ly">每个玩家存在三次</em>，占用了三倍于必要的内存。</p><p id="e393" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到我们的缓存声明，并通过指定一个地图作为“事实的基础”，或者“参考点”来解决这个问题。</p><p id="6b0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用播放器<code class="fe ni nj nk nl b">ID</code>的声明看起来很合适，原因有二:因为<code class="fe ni nj nk nl b">ID</code>作为<em class="ly">主键，</em>以及因为<code class="fe ni nj nk nl b">uint32</code>比播放器的<code class="fe ni nj nk nl b">Handle</code>占用的空间少得多，T3是一个任意长度的字符串。让我们重构为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">重构的数据结构。</p></figure><p id="b8ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，<code class="fe ni nj nk nl b">playerCountryMap</code>和<code class="fe ni nj nk nl b">playerHandleMap</code>都作为到<code class="fe ni nj nk nl b">playerIDMap</code>的<em class="ly">参考。显然，我们需要稍微重构一下我们的查找函数:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">重构的查找函数。</p></figure><p id="42f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，第一个函数<code class="fe ni nj nk nl b">FindPlayerByID</code>没有改变。第二个函数<code class="fe ni nj nk nl b">FindPlayerByHandle</code>现在将检索播放器<code class="fe ni nj nk nl b">ID</code>而不是<code class="fe ni nj nk nl b">Player</code>，并继续调用<code class="fe ni nj nk nl b">FindPlayerByID</code>来完成查找。</p><p id="e6a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于两次查找，复杂度现在是<em class="ly"> O(2) </em>而不是<em class="ly"> O(1) </em>，这仍然是常数时间，因此这两种方法之间的性能差异可以忽略不计。</p><p id="073f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三个函数更有趣一点。我们创建一个用第一次查找得到的<code class="fe ni nj nk nl b">ID</code>片的大小初始化的片，然后循环遍历<code class="fe ni nj nk nl b">ID</code>，同时单独查找它们并将<code class="fe ni nj nk nl b">Player</code>添加到该片。</p><p id="a4ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不需要检查<code class="fe ni nj nk nl b">ID</code>的存在，因为<em class="ly">我们</em>在控制缓存；我们知道它的存在。由于循环，复杂度是<em class="ly"> O(n+1) </em>，或者仅仅是<em class="ly"> O(n) </em>。</p><p id="b51d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这比直接查找更糟糕，因此这里有两种策略:</p><ol class=""><li id="e5cd" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">继续这种实现方式，虽然速度稍慢，但可以节省内存，或者:</li><li id="8e35" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">坚持原来的实现，它需要更多的内存，但是查找速度更快。</li></ol><p id="fbd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以——也应该——根据具体情况混合搭配这两种策略；始终选择适合情况的策略。</p><p id="8f9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为这个例子的最后一点，你也可以使用指针来引用而不是使用<code class="fe ni nj nk nl b">uint32</code> s。概念是相同的，你可以坚持总是使用引用原始结构的指针，而不是进行多次相互依赖的查找。</p><p id="bd9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是请记住，拥有一个包含成千上万个指针的缓存也会相应地增加GC必须管理的指针数量，这会对GC暂停时间产生负面影响。</p><p id="9dc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您不需要更改数据时，最好使用值。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="025b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">第二个示例:数据复制</h1><p id="e898" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">让我们假设一个场景，我们仍然在缓存<code class="fe ni nj nk nl b">Player</code> s，但对于应用程序的这个特定部分，我们可以绝对肯定地说，他们都玩了完全相同的游戏。</p><p id="d083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许是因为视频游戏发行商之一CrashyGames，Inc .要求提供一份本地可管理的列表，列出该平台上所有玩过他们所有游戏的玩家——也许是为了向他们道歉，说明他们的游戏质量有问题？</p><p id="9352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以立即看到，通过不为每个<code class="fe ni nj nk nl b">Player</code>存储字段<code class="fe ni nj nk nl b">Games</code>，我们可以节省大量内存。因为我们仍然需要该字段作为数据类型的一部分，所以我们将单独存储它，然后在请求时将它添加到一个ad-hoc <code class="fe ni nj nk nl b">Player</code>中。</p><p id="e9a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要第二种数据类型，我们称之为<code class="fe ni nj nk nl b">cachedPlayer</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">cachedPlayer的定义。</p></figure><p id="7a3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能注意到了，名字以小写的“c”开头；我们不会导出这种类型，而只是在缓存范围内内部使用。</p><p id="eeb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的缓存，我们的游戏列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">缓存和游戏列表。</p></figure><p id="9b9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这次我们就直接用<code class="fe ni nj nk nl b">ID</code>来查，用<code class="fe ni nj nk nl b">uint32</code>来表示。但CrashyGames拥有数百万玩家，这种优化是值得的。</p><p id="ae9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，让我们深入一些代码。这不需要太多工作。首先，我们将在<code class="fe ni nj nk nl b">cachedPlayer</code>上声明一个方便的方法，将它转换成常规的<code class="fe ni nj nk nl b">Player</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">cacedPlayer的转换器方法。</p></figure><p id="369c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以实现缓存查找了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">FindPlayerByID的实现。</p></figure><p id="2d00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我保持了方法<code class="fe ni nj nk nl b">cachedPlayer.convertWith</code>的纯洁性，将额外的字段作为参数，而<code class="fe ni nj nk nl b">FindPlayerByID</code>是变量<code class="fe ni nj nk nl b">games</code>的闭包，它只是存储在包级变量中，但是您可以按照自己喜欢的方式实现它。</p><p id="2771" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧！现在我们将所有内容存储一次。如果有许多重复的名字，你甚至可以把它带到下一个层次，把<code class="fe ni nj nk nl b">Player</code>名字保存在一个单独的数据结构中。</p><p id="daa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是要注意执行名称比较的开销，以及用名称增加数据结构的开销。只有在确实可以节省开支的时候，才这样做。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="bad1" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="9e65" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">轻量级模式是你的朋友，但是和大多数事情一样，需要找到一个平衡点；优化太多，你会引入不必要的复杂性——优化太少，你的应用会变得笨拙而缓慢。</p><p id="6124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在决定使用flyweight模式之前，考虑数据结构的大小，以及对代码可读性和应用程序可维护性的影响。记住唐纳德·克努特的一句老话:</p><blockquote class="oa"><p id="dd73" class="ob oc it bd od oe of og oh oi oj lu dk translated">"过早优化是万恶之源."</p></blockquote><p id="a699" class="pw-post-body-paragraph kz la it lb b lc ok ju le lf ol jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">现在去优化你的代码吧！</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="b314" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">附录</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用flyweight模式后的示例一。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用flyweight模式后的示例二。</p></figure></div></div>    
</body>
</html>