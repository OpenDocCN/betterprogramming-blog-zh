<html>
<head>
<title>How To Refresh Cell’s Content When Using UIHostingConfiguration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用UIHostingConfiguration时如何刷新单元格的内容</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-refresh-cells-content-when-using-uihostingconfiguration-9a34c00e6479?source=collection_archive---------15-----------------------#2022-09-14">https://betterprogramming.pub/how-to-refresh-cells-content-when-using-uihostingconfiguration-9a34c00e6479?source=collection_archive---------15-----------------------#2022-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1961" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">告别手动刷新单元格</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fb1c335e77384fd9a9b3d3a5ef216c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z3oSYOUe1KuyU4bQPBlWYw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b9e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用表视图或集合视图时，确保数据模型始终与屏幕上显示的内容保持同步是非常重要的。当使用表格视图或集合视图构建UI时，总是需要手动确保一切同步。</p><p id="6b7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着iOS 16中<code class="fe lu lv lw lx b">UIHostingConfiguration</code>的引入，我们终于可以利用只存在于SwiftUI中的双向绑定的力量了。通过双向绑定，iOS将为我们处理同步数据模型和视图内容的繁重工作。这意味着我们不再需要调用<code class="fe lu lv lw lx b">reloadItems(at:)</code>来刷新单元格，或者调用<code class="fe lu lv lw lx b">reconfigureItems(at:)</code>来更新数据源快照。</p><p id="4130" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是UIKit上一些非常令人兴奋的改进，你一定不想错过，所以让我们开始吧！</p><h1 id="983b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">示例应用程序</h1><p id="6bfd" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">为了展示双向绑定的伟大之处，让我们创建一个简单的待办事项列表应用程序，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/40d108955516545ce7addeea318fb9ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*6HOTBG1kRKIzah48ysSg8Q.gif"/></div></figure><p id="ce77" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在进入主题之前，让我们定义一个模型对象，我们可以用它来表示一个待办事项列表条目。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="92b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除此之外，我已经整理了一个使用<code class="fe lu lv lw lx b">UIHostingConfiguration</code>的简单列表，您可以将它作为本文的开始项目。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c9f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您在理解上面的代码时有困难，我强烈建议您首先阅读我之前的文章<a class="ae my" href="https://swiftsenpai.com/development/swiftui-custom-cell/" rel="noopener ugc nofollow" target="_blank">“如何使用SwiftUI </a>创建自定义UICollectionViewListCell”</p><h1 id="7ab4" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">双向绑定</h1><p id="88ca" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">双向绑定是SwiftUI中一个相当常见但极其有用的特性。在SwiftUI中，通常在模型对象和视图之间建立双向绑定。术语“双向”表示模型对象的任何变化都会自动触发视图的更新。对视图的任何更改都将触发对模型对象的更新。</p><p id="0093" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们的待办事项应用程序使用的是<code class="fe lu lv lw lx b">UIhostingConfiguration</code>，我们可以忘记重新加载单元格的传统方式，利用这个令人敬畏的SwiftUI功能来更新我们单元格的内容。</p><p id="9d7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它是这样工作的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/37fa00b3fec12dcefc8dc190ac4ed8bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z2ZaZbfzzgzbKsYg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">双向装订</p></figure><h1 id="3302" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">使用双向绑定刷新单元格</h1><p id="c466" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">如上图所示，我们想要在<code class="fe lu lv lw lx b">TodoItem</code>和<code class="fe lu lv lw lx b">TodoListCell</code>之间建立一个双向绑定。让我们首先关注将<code class="fe lu lv lw lx b">TodoItem</code>绑定到<code class="fe lu lv lw lx b">TodoListCell</code>上。</p><h2 id="8e0b" class="na lz it bd ma nb nc dn me nd ne dp mi lh nf ng mk ll nh ni mm lp nj nk mo nl bi translated">绑定1:要查看的模型对象</h2><p id="5f38" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">我们需要做的第一件事是使<code class="fe lu lv lw lx b">TodoItem</code>符合<code class="fe lu lv lw lx b">ObservableObject</code>。之后，将<code class="fe lu lv lw lx b">@Published</code>属性包装器添加到<code class="fe lu lv lw lx b">completed</code>属性中。当<code class="fe lu lv lw lx b">completed</code>发生变化时，这个属性包装器触发SwiftUI更新我们的单元格。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="65d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，转到<code class="fe lu lv lw lx b">TodoListCell</code>，将<code class="fe lu lv lw lx b">item</code>属性标记为<code class="fe lu lv lw lx b">@ObservedObject</code>。现在，让我们根据<code class="fe lu lv lw lx b">item</code>的<code class="fe lu lv lw lx b">completed</code>状态，给<code class="fe lu lv lw lx b">Text</code>视图添加一些样式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0ffc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">至此，我们已经成功地将<code class="fe lu lv lw lx b">TodoItem</code>绑定到了<code class="fe lu lv lw lx b">TodoListCell</code>。要查看实际的绑定，让我们通过将所有<code class="fe lu lv lw lx b">TodoItem</code>的<code class="fe lu lv lw lx b">completed</code>状态更改为<code class="fe lu lv lw lx b">true</code>来实现“完成全部”功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="070e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果您运行示例代码并点击“全部完成”按钮，所有单元格的标题都会变成灰色，并带有删除线。</p><p id="fdb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我们不需要手动逐个刷新每个单元格。每次<code class="fe lu lv lw lx b">item</code>(观察对象)发生变化时，SwiftUI会自动刷新相应的单元格。这就是捆绑的力量！</p><h2 id="3519" class="na lz it bd ma nb nc dn me nd ne dp mi lh nf ng mk ll nh ni mm lp nj nk mo nl bi translated">绑定2:视图到模型对象</h2><p id="ed5e" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">难题的另一部分是创建从<code class="fe lu lv lw lx b">TodoListCell</code>的UI元素到<code class="fe lu lv lw lx b">TodoItem</code>的绑定。为了实现这一点，我们可以使用SwiftUI中的<code class="fe lu lv lw lx b">Toggle</code>视图，它具有内置的绑定功能，我们需要做的就是使用<code class="fe lu lv lw lx b">$</code>前缀来建立绑定。</p><p id="f687" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为顶上的樱桃，我还添加了<code class="fe lu lv lw lx b">animation()</code>到绑定中，这样每当<code class="fe lu lv lw lx b">completed</code>状态改变时，我们可以得到一个平滑的删除线和变色动画。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="dd3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了所有这些，我们成功地在<code class="fe lu lv lw lx b">TodoListCell</code>和<code class="fe lu lv lw lx b">TodoItem</code>之间创建了一个双向绑定。因此，每当我们点击<code class="fe lu lv lw lx b">Toggle</code>视图时，就会更新<code class="fe lu lv lw lx b">TodoItem</code>的<code class="fe lu lv lw lx b">completed</code>状态，从而触发相应<code class="fe lu lv lw lx b">TodoListCell</code>的刷新。</p><p id="3712" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想试试示例代码吗？请在这里随意获取<a class="ae my" href="https://github.com/LeeKahSeng/SwiftSenpai-UICollectionView-SwiftUI" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="b90c" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">好的和坏的</h1><p id="fb07" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">既然您已经看到了双向绑定的运行，您应该会注意到一切都是自动发生的。只要我们正确地设置了绑定，我们的模型对象和单元内容将总是同步的。</p><p id="cdd4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最重要的是，多亏了<code class="fe lu lv lw lx b">UIHostingConfiguration</code>，我们现在可以轻松地利用SwiftUI的能力，并在UIKit环境中使用它。正如你之前看到的，在UIKit中实现起来有些麻烦的动画和效果(比如删除线)已经变得极其容易实现了。</p><p id="7b84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">话虽如此，但有一点需要注意。在这种情况下，模型对象必须是引用类型，否则它将无法符合<code class="fe lu lv lw lx b">ObservableObject</code>协议。这在大多数情况下应该没什么大不了的，但我相信还是值得一提的。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="aff5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你喜欢读这篇文章吗？如果你这样做了，我相信你也会喜欢我以前的文章，“在iOS 16 中使用UIHostingConfiguration时，<a class="ae my" href="https://swiftsenpai.com/development/uihostingconfiguration-cell-interactions/" rel="noopener ugc nofollow" target="_blank">处理单元交互”</a></p><p id="d53c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。👨🏻‍💻</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="0117" class="na lz it lx b gy nx ny l nz oa"><strong class="lx iu">Want to Connect?</strong></span><span id="55af" class="na lz it lx b gy ob ny l nz oa">Feel free to follow me on <a class="ae my" href="https://twitter.com/Lee_Kah_Seng" rel="noopener ugc nofollow" target="_blank">Twitter</a> so you won’t miss out on any of my upcoming iOS development-related articles.</span></pre></div></div>    
</body>
</html>