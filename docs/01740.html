<html>
<head>
<title>Why you should use MobX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该使用MobX</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-you-should-use-mobx-5d3e1914eb0f?source=collection_archive---------10-----------------------#2019-10-09">https://betterprogramming.pub/why-you-should-use-mobx-5d3e1914eb0f?source=collection_archive---------10-----------------------#2019-10-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="55b2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">react状态管理解决方案的比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6aaeec381d66d02cf00592ba09f20012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8mwxxlfbjJWPv3-y.png"/></div></div></figure><p id="4611" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些年来，我使用过各种状态管理库(使用或不使用react ),但在过去几年中，MobX是我的首选解决方案——从简单的玩具应用程序到由多个团队构建的复杂应用程序，我甚至在非react (Vue.js)的框架中使用它。</p><p id="f909" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么我经常使用它？我将通过列举MobX的优势，并将每个优势与我认为的替代解决方案的缺点进行比较，来尝试回答这个问题(因为这更适合react用户，所以我将它与redux和使用上下文的状态管理进行比较)</p><p id="6dfa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文假设您熟悉MobX及其工作原理，如果您不熟悉，您应该阅读<a class="ae lq" href="https://mobx.js.org/README.html#introduction" rel="noopener ugc nofollow" target="_blank"> MobX文档</a>。</p><h2 id="2acf" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">目录</h2><ul class=""><li id="918d" class="mk ml it kw b kx mm la mn ld mo lh mp ll mq lp mr ms mt mu bi translated"><a class="ae lq" href="#f25a" rel="noopener ugc nofollow">优点</a><br/>–<a class="ae lq" href="#91bb" rel="noopener ugc nofollow">MobX具有最少的样板文件</a><br/>–<a class="ae lq" href="#324e" rel="noopener ugc nofollow">MobX总是呈现最少的必需组件</a><br/>–<a class="ae lq" href="#2957" rel="noopener ugc nofollow">MobX不需要您更改代码</a><br/>–<a class="ae lq" href="#2957" rel="noopener ugc nofollow">MobX很容易组合</a><br/>–<a class="ae lq" href="#a5c0" rel="noopener ugc nofollow">逻辑不应该是视图层的一部分</a><br/>–<a class="ae lq" href="#7a3d" rel="noopener ugc nofollow">MobX不限于全局状态【T23</a></li><li id="8783" class="mk ml it kw b kx mv la mw ld mx lh my ll mz lp mr ms mt mu bi translated"><a class="ae lq" href="#6750" rel="noopener ugc nofollow">缺点</a><br/>–<a class="ae lq" href="#2944" rel="noopener ugc nofollow">MobX不具备不变性</a><br/>–<a class="ae lq" href="#0ad3" rel="noopener ugc nofollow">MobX更难跟踪和调试</a></li></ul></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="17c9" class="nh ls it bd lt ni nj nk lw nl nm nn lz jz no ka mc kc np kd mf kf nq kg mi nr bi translated">MobX的优势</h1><h2 id="f25a" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">MobX有最少的样板文件</h2><p id="be6c" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">Redux因其样板文件而臭名昭著。redux中有一个简单的api调用方法，每个应用程序都有这样或那样的形式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a135" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要做一些非常简单的事情，需要很多代码，而且这还是在我们添加最小的库以使redux在重要的应用程序中可用之前，比如<em class="nx">redux-thunk</em>/<em class="nx">redux-saga</em>、<em class="nx"> reselect </em>(用于模块化)和<em class="nx"> normalizr </em>(用于规范化)。</p><p id="d2a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，做同样事情的MobX商店应该这样写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0e16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于那些想知道这与之前的<em class="nx"> redux </em>示例功能完全相同的人来说。除了更加简洁之外，它也更加清晰和直接，没有额外的功能会向你袭来。</p><p id="d6df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与<em class="nx"> redux </em>的例子不同，它会自动记忆，并且不需要<em class="nx"> thunk </em>或<em class="nx"> saga </em>在真正的应用程序中工作。(虽然它没有正常化，但需要做更多的工作)</p><p id="b532" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有各种各样的尝试来减少样板文件——从redux本身，如<em class="nx"> actionCreatorCreator </em>(我一听到这个名字就害怕)到成熟的传统库，如<em class="nx"> ducks </em>。不幸的是，他们要么没有实现他们的主张，要么没有得到太多的欢迎。</p><p id="b860" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大量样板代码并不局限于创建<em class="nx">redux</em>reducer的逻辑层部分。它还被添加到消费者部分——反应组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="ea42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React中状态管理的另一个选项是使用上下文api。</p><p id="5d9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们用上下文和钩子做一个相同的api例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="fc64" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这与<em class="nx"> MobX </em>的例子没有太大区别——我们只添加了<code class="fe ny nz oa ob b">createContext</code>和<code class="fe ny nz oa ob b">Context.Provider</code>。然而，我们需要使用<code class="fe ny nz oa ob b">Context.Provider</code>和<code class="fe ny nz oa ob b">useContext</code>每次我们想要的状态，需要单独使用。</p><p id="665d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您的应用程序增长得越多，状态在树中的位置越靠前，这种情况就越常见，直到您的顶级组件看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="1ca5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你遵循Kent C. Dodds关于如何构建状态的指导方针，你可能会说这不应该发生，因为状态只应该尽可能地接近用法，而不是所有的都应该留在顶部。</p><p id="3c1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不幸的是，我发现许多常见的用例需要将状态提升到应用程序的顶部——任何需要在应用程序的两个部分(如主窗口和侧栏，或导航栏)显示的内容，例如:通知/消息，验证(和我的用户信息)，显示订阅源/群组是否有更多项目要显示，在线用户的数量等等。</p><p id="55fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于您经常将状态和动作与MobX捆绑在一起，因此它也吸取了道具钻取问题的教训——将单个道具向下发送几个级别比发送多个级别要容易得多，这使得您的较低级别组件更简单。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="91bb" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">MobX总是呈现最少的必需组件</h2><p id="6cee" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">开箱即用，而且不费吹灰之力，MobX将只重新渲染组件，当您更新商店的特定部分时，这些组件的渲染树实际上会发生变化。这意味着MobX永远不会渲染一个组件，除非它所依赖的道具改变了；它永远不会呈现实际发生变化的组件的父组件或它的兄弟组件。</p><p id="dde9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要使用redux获得类似的功能，您需要使用困难且非常手动的记忆化过程。<br/>让我们以前面提到的资源api为例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="cc83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们天真地使用redux，那么每次存储中的任何<em class="nx">资源</em>发生变化时，所有<em class="nx"> ResourceView </em>组件都会重新呈现。</p><p id="e383" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了让它变得更有性能，我们需要使用记忆化。<br/>让我们更改代码以使用<em class="nx">重新选择</em>库:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="e6cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这更像是样板文件，但除此之外，很难使用它——您需要手动考虑哪些状态排列需要重新呈现您的组件，并把它们都考虑进去。</p><p id="bb3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你的组件稍微复杂一点，那么维护和扩展也将成为一场噩梦(通常对于顶级组件如页面或导航来说就是如此)</p><p id="022c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用上下文进行状态管理也会遇到类似的问题，如果您只想在实际资源发生变化时呈现<code class="fe ny nz oa ob b">ResourceView</code>，那么您必须为每个resourceId创建一个<code class="fe ny nz oa ob b">Context</code>(或者以某种方式重新构建您的应用程序)。</p><p id="2834" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">即使你做了所有这些，仍然有只有MobX能处理的边缘情况。<br/>考虑这样一种情况，你想计算自从你的fetch在一个资源属性中被调用以来的秒数，这个资源属性在某个东西被加载时被更新，并且当它完成时显示请求花费了多长时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="1dc8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在每秒钟<code class="fe ny nz oa ob b">ResourceView</code>都会重新渲染，尽管我们只显示了<code class="fe ny nz oa ob b">&lt;Loader/&gt;</code>组件，实际上没有任何变化。<br/>重新选择和上下文根本无法确定，只要<em class="nx"> loading </em>属性为真，就没有使用资源的其他属性。</p><p id="96b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，默认情况下，Mobx不会重新渲染<em class="nx"> ResourceView </em>，直到加载属性被更改——因为MobX只根据上次渲染中使用的属性进行渲染。</p><p id="9746" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong>MobX的这个特性依赖于引用最底层的可观察组件，并且对于每个组件使用observer(两者都是在React中使用MobX的自然方式)。<br/>如果你在你的应用程序顶部引用一个可观察的值，并将该值作为道具发送到整个渲染树，那么每一次修改都会渲染所有内容。(所以不要那么做)</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="324e" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">MobX不需要你修改代码</h2><p id="6e52" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">使用MobX看起来就像普通的javascript，它不需要您更改代码或架构来支持它(不像Redux，在较小程度上也不像Context)。</p><p id="fd03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，这是一个不可见的抽象，在许多情况下，如果你去掉所有的MobX代码——<em class="nx">@ observable</em>，<em class="nx"> @computed </em>，<em class="nx"> @action </em>和<em class="nx">observer</em>decorator，你的代码将完全一样地工作(尽管会有一些性能问题)。</p><p id="04fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就其核心而言，MobX根本不是一个状态管理解决方案，它是一种提高性能的元编程方法——因此，它完全不受如何构建代码的影响。<br/>国家管理部分是你用它构建的。</p><p id="d224" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有些人会认为这是一个缺点，但是我喜欢我的框架和库尽可能的非个人化，这样我就可以用我认为最好的方式来构建我的代码。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="2957" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">MobX很容易组装</h2><p id="f486" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">redux最大的问题之一，至少对我来说，是因为它的全局性质，很难编写它(composeReducers肯定不是我所指的那种编写)。</p><p id="d4b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">redux在可组合性方面有问题的主要原因是redux中存储内的路径很重要。按照使用<em class="nx"> redux </em>的标准方式，你不能对<code class="fe ny nz oa ob b">authentication/user/current</code>和<code class="fe ny nz oa ob b">groups/user/manager</code>下的减速器模块使用相同的组件，即使商店本身完全相同。</p><p id="7484" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你使用<code class="fe ny nz oa ob b">connect</code>函数，你需要为同一个组件使用不同的hoc，或者创建一个接受商店路径作为属性的组件。</p><p id="2485" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是为什么规范化在Redux中如此重要——如果你总是把所有相同的对象放在相同的位置，你就不会有这个问题。<br/>但这意味着每个需要显示共享对象的reducer都需要访问共享资源池——例如，加载用户的存储的每个api调用都需要访问共享用户存储。</p><p id="1ee3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这破坏了模块自包含的能力，但对大多数应用程序来说还不算太坏，问题真正出在开始使用第三方组件的时候。</p><p id="e9ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于第三方组件和模块无法预测你的商店将会是什么样子，所以如果没有一些可怕的诡计，他们就无法从你的商店中获益。这就是为什么redux没有很多流行的用户模块/库(比如简单的REST消费者),但是有很多中间件的原因之一。</p><p id="fb01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">redux让可组合的实用程序库变得困难的一个很好的例子是redux-forms——无论何时你创建或使用redux-form 的实例，你必须给它在存储中的路径(并且它必须在reducer中是顶层)</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="a5c0" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">逻辑不应该是视图层的一部分</h2><p id="3541" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">在单页应用程序扩散之前，我就开始做web UI，就像现在一样，有许多相互竞争的想法和框架。但是他们都同意的一件事是，你的视图层永远不应该包含逻辑(无论你把那个层中的对象称为控制器、Dao还是fat模型)。</p><p id="f3a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也许我很守旧，但是我仍然不能忍受在视图层内部看到逻辑——在React中，这意味着在组件内部。</p><p id="d039" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有充分理由说明为什么不应该将逻辑放在视图层中:</p><ul class=""><li id="1b13" class="mk ml it kw b kx ky la lb ld oc lh od ll oe lp mr ms mt mu bi translated"><strong class="kw iu">这使得重构</strong>变得更加困难——如果你的组件知道你的商店的结构(这就是redux中的<em class="nx"> connect </em>所发生的),那么任何改变结构的重构都需要你改变视图层。它还将应用程序的逻辑与视图的结构联系起来——如果同一个模型有不同类型的视图，这将是一个问题。</li><li id="55a4" class="mk ml it kw b kx mv la mw ld mx lh my ll mz lp mr ms mt mu bi translated"><strong class="kw iu">如果视图负责应用程序的流程，那么维护和推理应用程序的流程就更加困难</strong> —如果你的组件调用api，那么要知道一个动作是否会导致API调用，你必须遵循生命周期和你的渲染树的渲染。当您的逻辑从视图中分离出来时，操作的结果更加确定，并且与您正在查看的页面或当前显示的组件无关</li><li id="a05d" class="mk ml it kw b kx mv la mw ld mx lh my ll mz lp mr ms mt mu bi translated"><strong class="kw iu">它使得测试更慢更复杂</strong> —如果你的视图负责调用API和执行业务逻辑，这意味着你需要启动视图(在这种情况下是React的渲染)来测试应用的流程。如果您的逻辑没有连接到视图，那么测试它通常就像测试一个普通的javascript函数一样简单。</li><li id="4f60" class="mk ml it kw b kx mv la mw ld mx lh my ll mz lp mr ms mt mu bi translated"><strong class="kw iu">横切关注点更难使用</strong>——像日志记录、缓存和错误处理这样的事情，当它们被分割在多个组件之间时，就更难做了。</li></ul><p id="3740" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您使用<em class="nx"> react-mobx </em>的inject从store inside组件中提取状态，这些问题也是相关的。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="7a3d" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">MobX不局限于全局状态</h2><p id="e1bf" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">不是所有的东西都应该在逻辑层。对于一个组件来说是本地的或者不在远处的组件之间共享的东西不应该保存在组件的状态中。<br/>表单是组件本地的一个例子(除非它在会话之间持续存在)。</p><p id="28e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当在组件内部使用MobX时，可以获得与使用MobX获得全局状态相同的好处，即性能和没有样板文件。</p><p id="f2b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们以一个使用钩子的简单表单为例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="6750" class="nh ls it bd lt ni nj nk lw nl nm nn lz jz no ka mc kc np kd mf kf nq kg mi nr bi translated">缺点</h1><h2 id="2944" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">MobX不能很好地处理不可变性</h2><p id="a671" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">MobX广泛依赖于突变来判断什么需要重新计算，因此在不变性方面表现不佳。并不是说不可变性不起作用，只是如果你经常使用不可变性，你会失去MobX提供的性能优势，并且使用它不会有什么好处。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="0ad3" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">MobX更难跟踪和调试</h2><p id="a0c8" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">由于MobX使用“magic ”(也称为元编程)来跟踪正在使用和订阅的可观察对象，因此它对正常的调试和编程工具隐藏了许多实现。</p><p id="9483" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您想知道是什么导致了重新计算/重新呈现，以及如果您更改了什么，什么会重新呈现时，调试就成了一个问题。这是redux最强大的特性——所有的样板文件都是为了让应用程序流易于理解和维护。<br/>对于非常大的应用程序以及多个开发人员在同一个应用程序上工作，MobX会变得难以维护，需要制定严格的约定来保持状态和应用程序流的可管理性。</p><p id="be3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Redux倒回时间和跟踪状态变化的能力也是维护和调试代码的一个非常强大的工具，这是MobX无法真正做到的(如果您使用actions和strict mode，您将得到它的近似值，这很好，但还不够接近)。</p><p id="060a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">MobX状态树试图解决一些棘手的问题，但代价是固执己见，失去了吸引人们使用MobX的灵活性。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="71cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nx">最初发表于</em><a class="ae lq" href="https://www.alonbd.com/blog/2019-10-09-why-you-should-use-mobx" rel="noopener ugc nofollow" target="_blank">T5【https://www.alonbd.com】</a><em class="nx">。</em></p></div></div>    
</body>
</html>