<html>
<head>
<title>Dockerize a React App and an Express API With MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用MongoDB实现一个React应用和一个Express API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dockerizing-react-app-and-express-api-with-mongodb-f3a06bebf570?source=collection_archive---------3-----------------------#2020-02-26">https://betterprogramming.pub/dockerizing-react-app-and-express-api-with-mongodb-f3a06bebf570?source=collection_archive---------3-----------------------#2020-02-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1f5d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于如何使用容器将React应用、Express API和MongoDB迁移到Docker的简单指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6c9a2075a2088d721a4b15f9105eac2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eAVVl4etCTr78TezjDX9og.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://pxhere.com/en/photographer/767067" rel="noopener ugc nofollow" target="_blank">穆罕默德·哈桑</a>在<a class="ae kv" href="https://pxhere.com/en/photo/1449859" rel="noopener ugc nofollow" target="_blank"> PxHere </a>上拍摄</p></figure><p id="1988" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简单起见，我假设您有一个工作的前端和后端，以及连接的数据库。</p><p id="614d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最好的想法是将API和客户端回购放在一个文件夹中。您可以使用一个远程repo来存储它们，或者使用两个独立的远程repo，然后使用Git子模块将它们与父远程组合在一起。我就是这么做的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/e950156d4e0ccdf9a68844f8ff7dc1f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*3HzqpqAUxcrdow4MX7bcLg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">父回购文件夹树</p></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="8f04" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">React应用</h1><p id="a748" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我为我的项目使用了Create React App (CRA)和TypeScript。这是一个简单的博客，有几个观点。</p><p id="1b4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先要做的是在客户机根文件夹中创建一个Dockerfile。为此，只需键入:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="38e0" class="nc mb iq my b gy nd ne l nf ng">$ touch Dockerfile</span></pre><p id="0e0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开文件，让我们填写它。我在我的CRA上使用TypeScript，所以首先我必须构建我的应用程序。然后，我把我得到的东西作为静态文件存放起来。为了实现这一点，我们将采用<a class="ae kv" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">两阶段Docker构建</a>。</p><p id="1fda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一阶段是使用Node构建应用程序。我用的是<strong class="ky ir"> </strong>阿尔卑斯版本——因为它最轻，所以我们的容器会很小。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="0500" class="nc mb iq my b gy nd ne l nf ng">FROM node:12-alpine as builder</span><span id="b01d" class="nc mb iq my b gy nh ne l nf ng">WORKDIR /app<br/>COPY package.json /app/package.json<br/>RUN npm install --only=prod<br/>COPY . /app<br/>RUN npm run build</span></pre><p id="c23b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">docker文件的开头看起来就是这样。我们使用<code class="fe ni nj nk my b">node:12-alpine as builder</code>，然后建立一个工作目录到<code class="fe ni nj nk my b">/app</code>。这将在我们的容器中创建一个新文件夹。我们将我们的<strong class="ky ir"> </strong> <code class="fe ni nj nk my b">package.json</code>复制到容器中的一个新文件夹中，并安装所有的包。接下来，我们从<code class="fe ni nj nk my b">/services/client</code>文件夹中复制所有内容并粘贴到我们的容器中。这一步的最后一点是构建一切。</p><p id="6d50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们必须托管新创建的构建。为了做到这一点，我们将使用NGINX——再次在Alpine版本中减少大小。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="6e48" class="nc mb iq my b gy nd ne l nf ng">FROM nginx:1.16.0-alpine<br/>COPY --from=builder /app/build /usr/share/nginx/html<br/>EXPOSE 80<br/>CMD ["nginx", "-g", "daemon off;"]</span></pre><p id="67ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们复制上一步的构建并粘贴到<code class="fe ni nj nk my b">nginx</code>文件夹中。然后暴露端口<code class="fe ni nj nk my b">80</code>——这将是我们的容器监听连接的端口。最后一行是启动NGINX。</p><p id="4fd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">客户端部分到此为止。整个docker文件应该如下所示:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="4fc2" class="nc mb iq my b gy nd ne l nf ng">FROM node:12-alpine as build</span><span id="e421" class="nc mb iq my b gy nh ne l nf ng">WORKDIR /app<br/>COPY package.json /app/package.json<br/>RUN npm install --only=prod<br/>COPY . /app<br/>RUN npm run build</span><span id="05dc" class="nc mb iq my b gy nh ne l nf ng">FROM nginx:1.16.0-alpine<br/>COPY --from=build /app/build /usr/share/nginx/html<br/>EXPOSE 80<br/>CMD ["nginx", "-g", "daemon off;"]</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="390c" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">快速API</h1><p id="e486" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">API也非常简单——使用RESTful路由来创建帖子、处理授权等。让我们从在API根文件夹中创建一个Dockerfiler开始，方法与上一部分相同。</p><p id="71e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我用了ES6的特性，所以我必须把所有东西都编译成Vanilla JS来运行它，我用了Babel。你可以猜到，这将是一个两阶段的建设了。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="51fc" class="nc mb iq my b gy nd ne l nf ng">FROM node:12-alpine as builder</span><span id="f06e" class="nc mb iq my b gy nh ne l nf ng">WORKDIR /app<br/>COPY package.json /app/package.json<br/>RUN apk --no-cache add --virtual builds-deps build-base python<br/>RUN npm install<br/>COPY . /app<br/>RUN npm run build</span></pre><p id="2410" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它与客户的Dockerfile非常相似，所以我不会再解释它了。不过，有一点不同。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="c925" class="nc mb iq my b gy nd ne l nf ng">RUN apk --no-cache add --virtual builds-deps build-base python</span></pre><p id="38ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在将密码保存到数据库之前，我用bcrypt对密码进行了哈希处理。这是一个非常受欢迎的软件包，但它在使用阿尔卑斯山图像时存在一些问题。您可能会发现类似以下的错误:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="2602" class="nc mb iq my b gy nd ne l nf ng">node-pre-gyp WARN Pre-built binaries not found for bcrypt@3.0.8 and node@12.16.1 (node-v72 ABI, musl) (falling back to source compile with node-gyp)</span><span id="695e" class="nc mb iq my b gy nh ne l nf ng">npm ERR! Failed at the bcrypt@3.0.8 install script.</span></pre><p id="a0c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个众所周知的问题，<a class="ae kv" href="https://github.com/kelektiv/node.bcrypt.js/wiki/Installation-Instructions#docker" rel="noopener ugc nofollow" target="_blank">解决方案</a>是在安装npm包之前安装额外的包和Python。</p><p id="4e75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与客户端类似，下一步是获取构建API并使用Node运行它。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="a591" class="nc mb iq my b gy nd ne l nf ng">FROM node:12-alpine<br/>WORKDIR /app<br/>COPY --from=builder /app/dist /app<br/>COPY package.json /app/package.json<br/>RUN apk --no-cache add --virtual builds-deps build-base python<br/>RUN npm install --only=prod</span><span id="c6b1" class="nc mb iq my b gy nh ne l nf ng">EXPOSE 8080 <br/>USER node<br/>CMD ["node", "index.js"]</span></pre><p id="c044" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个例外是只安装生产包。我们不再需要巴别塔——因为一切都在第一步中完成了。然后我们公开端口<code class="fe ni nj nk my b">8080</code>来监听请求并启动节点。</p><p id="3cec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">整个docker文件应该如下所示:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="d077" class="nc mb iq my b gy nd ne l nf ng">FROM node:12-alpine as builder</span><span id="2f8a" class="nc mb iq my b gy nh ne l nf ng">WORKDIR /app<br/>COPY package.json /app/package.json<br/>RUN apk --no-cache add --virtual builds-deps build-base python<br/>RUN npm install<br/>COPY . /app<br/>RUN npm run build</span><span id="6295" class="nc mb iq my b gy nh ne l nf ng">FROM node:12-alpine<br/>WORKDIR /app<br/>COPY --from=builder /app/dist /app<br/>COPY package.json /app/package.json<br/>RUN apk --no-cache add --virtual builds-deps build-base python<br/>RUN npm install --only=prod</span><span id="26d6" class="nc mb iq my b gy nh ne l nf ng">EXPOSE 8080 <br/>USER node<br/>CMD ["node", "index.js"]</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="c8be" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">Docker撰写</h1><p id="7749" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">最后一步是将API和客户机容器与MongoDB容器结合起来。为此，我们使用一个放在父回购根目录中的<code class="fe ni nj nk my b">docker-compose</code>文件——因为它必须访问客户端和API的docker文件。</p><p id="4b99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建<code class="fe ni nj nk my b">docker-compose</code>文件:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="a82c" class="nc mb iq my b gy nd ne l nf ng">$ touch docker-compose.yml</span></pre><p id="c55d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该得到如下所示的文件结构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/e950156d4e0ccdf9a68844f8ff7dc1f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*3HzqpqAUxcrdow4MX7bcLg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">父回购文件夹树</p></figure><p id="df0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用下面的代码填充<code class="fe ni nj nk my b">docker-compose</code>文件，稍后我会解释。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="59b3" class="nc mb iq my b gy nd ne l nf ng">version: "3"</span><span id="c114" class="nc mb iq my b gy nh ne l nf ng">services:<br/>  api:<br/>    build: ./services/api<br/>    ports:<br/>      - "8080:8080"<br/>    depends_on:<br/>      - db<br/>    container_name: blog-api</span><span id="ff63" class="nc mb iq my b gy nh ne l nf ng">  client:<br/>    build: ./services/client<br/>    ports:<br/>      - "80:80"<br/>    container_name: blog-client</span><span id="2e41" class="nc mb iq my b gy nh ne l nf ng">  db:<br/>    image: mongo<br/>    ports:<br/>      - "27017:27017"<br/>    container_name: blog-db</span></pre><p id="fcc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">真的就这么简单。我们有三个服务:客户端、API和MongoDB。MongoDB没有Docker file——Docker会从它的hub下载图像，然后用它们创建一个容器。这意味着我们的数据库是易腐的，但对于开始它是足够的。</p><p id="f089" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在API和客户机中，我们有一个build键，它分别指向两个服务的Dockerfile位置(根文件夹)。other文件中的端口容器被分配到我们的<code class="fe ni nj nk my b">docker-compose</code>网络端口，这样容器就可以相互通信。API服务也有<code class="fe ni nj nk my b">depends_on</code>键。这告诉Docker等待启动它，直到数据库容器完全运行。因此，我们将避免来自API容器的连接错误。</p><p id="b348" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">MongoDB还有一点:在我们后端的代码库中，我们必须更新MongoDB连接字符串。通常，我们指的是<code class="fe ni nj nk my b">localhost</code>:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="c00f" class="nc mb iq my b gy nd ne l nf ng">mongodb://localhost:27017/blog</span></pre><p id="15b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是使用<code class="fe ni nj nk my b">docker-compose</code>，它必须指向一个容器名:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="644b" class="nc mb iq my b gy nd ne l nf ng">mongodb://blog-db:27017/blog</span></pre><p id="3b86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一步是在父repo根目录(<code class="fe ni nj nk my b"> docker-compose.yml</code>所在的位置)中使用以下命令运行所有内容:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="b1dc" class="nc mb iq my b gy nd ne l nf ng">$ docker-compose up</span></pre><p id="edaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅此而已。我想更多的是阅读而不是编码。谢谢你坚持到最后！</p></div></div>    
</body>
</html>