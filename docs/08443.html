<html>
<head>
<title>50 Swift Interview Questions and Answers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">50个Swift面试问题和答案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/50-swift-interview-questions-and-answers-for-2021-8911c2768a51?source=collection_archive---------1-----------------------#2021-04-30">https://betterprogramming.pub/50-swift-interview-questions-and-answers-for-2021-8911c2768a51?source=collection_archive---------1-----------------------#2021-04-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0c69" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过了解这些基本问题的答案，赢得iOS开发人员的面试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/560cd6055fb025d91daaa490f06839e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rwarWBgat_Wc8DQ6n51rmQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">原图:<a class="ae ky" href="https://unsplash.com/@charlesdeluvio" rel="noopener ugc nofollow" target="_blank">查尔斯·德鲁维奥</a></p></figure><p id="6ab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里列出了50个Swift面试问题和答案。这些问题集中在Swift编程和iOS应用程序开发。在你有机会在面试官面前展示你的技能之前，你需要知道这些问题的答案。</p><p id="9fd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些问题没有特定的顺序，让我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4f89" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.<em class="mu">什么导致了错误？你能如何修理它？</em></h1><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="d82b" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">let</strong> n1: Int = 1<br/><strong class="mw iu">let</strong> n2: Float = 2.0<br/><strong class="mw iu">let</strong> n3: Double = 3.34</span><span id="9561" class="na md it mw b gy nf nc l nd ne"><strong class="mw iu">var</strong> result = n1 + n2 + n3</span></pre><h2 id="cc36" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="ead2" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">在Swift中，两种数据类型之间的隐式类型转换是不可能的。</p><p id="851c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，您试图将三个元素加在一起，每个元素代表一种不同的数据类型。</p><p id="6edc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要解决这个问题，您需要将每个值转换为相同的数据类型。例如:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="abad" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">var</strong> result = Double(n1) + Double(n2) + n3</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9b65" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.<em class="mu">L</em><code class="fe nw nx ny mw b"><em class="mu">en</em></code><em class="mu">的值是多少？为什么？</em></h1><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="555a" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">var</strong> arr1 = [1, 2, 3]<br/><strong class="mw iu">var</strong> arr2 = arr1</span><span id="1cc3" class="na md it mw b gy nf nc l nd ne">arr2.append(4)</span><span id="6a92" class="na md it mw b gy nf nc l nd ne"><strong class="mw iu">var</strong> len = arr1.count</span></pre><h2 id="53e4" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="c1d9" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated"><code class="fe nw nx ny mw b">len</code>的值为3，即<code class="fe nw nx ny mw b">arr1</code>中的元素个数为3。这是因为将<code class="fe nw nx ny mw b">arr1</code>分配给<code class="fe nw nx ny mw b">arr2</code>实际上意味着将<code class="fe nw nx ny mw b">arr1</code>的副本分配给<code class="fe nw nx ny mw b">arr2</code>，因此<code class="fe nw nx ny mw b">arr1</code>不受影响。</p><p id="50f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Swift中，所有的基本数据类型(布尔值、整数等。)，枚举和结构本质上都是<em class="nz">值类型</em>。</p><p id="37dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数组也是值类型。当在Swift中移动值类型时，您实际上是在使用它的副本。例如，当将一个<em class="nz">值类型</em>作为参数传递给一个函数时，会创建一个它的副本，因此无论该函数做什么都不会反映在原始值中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="05af" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.有什么问题，你如何解决？</h1><p id="182c" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">考虑这段试图从iOS设备的本地存储中检索主题颜色的代码:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="7fa8" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">var</strong> color = UserDefaults.standard.string(forKey: "themeColor")!<br/>print(color)</span></pre><p id="9674" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能发现错误并改正它吗？</p><h2 id="3459" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="7e62" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">第一行从<em class="nz">用户默认值</em>中检索主题颜色。然而，这个方法返回一个可选的(因为<code class="fe nw nx ny mw b">themeColor</code>可能没有被定义)。如果没有找到密钥，返回一个<code class="fe nw nx ny mw b">nil</code>，上面的代码崩溃:</p><p id="f942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nw nx ny mw b">fatal error: unexpectedly found nil while unwrapping an Optional value</code></p><p id="f6c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这发生在第一行使用<code class="fe nw nx ny mw b">!</code>到<em class="nz">强制展开</em>可选的，现在是一个<code class="fe nw nx ny mw b">nil</code>。<em class="nz">只有当您100%确定该值不是</em> <code class="fe nw nx ny mw b"><em class="nz">nil</em></code>时，才应使用强制解包。</p><p id="5609" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要解决这个问题，您可以使用<em class="nz">可选绑定</em>来检查是否找到了键的值:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="351d" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">if</strong> <strong class="mw iu">let</strong> color = defaults.stringForKey("themeColor") {<br/>    print(color)<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8880" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.<em class="mu">你能看到哪些潜在的改进？</em></h1><p id="fe52" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">您正在查看一个拉取请求，遇到了这种方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="e6a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能向代码的作者提出什么改进建议？</p><h2 id="822c" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="a2bf" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">尽管这段代码可能有效，但有两件事需要考虑。</p><ul class=""><li id="6c26" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated">使用硬编码的字符串如(例如<code class="fe nw nx ny mw b">"West"</code>)不是一个好主意。如果有人拼错了怎么办？为了解决这个问题，应该放弃硬编码的字符串，而应该创建一个枚举。</li><li id="0df1" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">还有，用一个<em class="nz"> switch </em>语句<em class="nz"> </em>代替冗长的if-else语句怎么样？</li></ul><p id="feeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些改进，代码变得类型更安全，可读性更好:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e88c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.<em class="mu">Swift中有哪些枚举？</em></h1><h2 id="0721" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="5416" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">枚举是一组相关的值。</p><p id="7144" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">枚举使得编写类型安全的代码成为可能。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="0bc8" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">enum</strong> Direction {<br/>    <strong class="mw iu">case</strong> North<br/>    <strong class="mw iu">case</strong> East<br/>    <strong class="mw iu">case</strong> South<br/>    <strong class="mw iu">case</strong> West<br/>}</span></pre><p id="1c04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在您的代码中，例如，您可以调用<code class="fe nw nx ny mw b">Direction.North</code>，而不是使用神秘的字符串<code class="fe nw nx ny mw b">"North"</code>(这很容易被拼错并导致令人讨厌的错误)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bb9a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.<em class="mu">Swift中的可选项目是什么？你怎么能创造一个呢？</em></h1><h2 id="b15c" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="1b7e" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">一个<em class="nz">可选的</em>是可以存储一个值或者一个<code class="fe nw nx ny mw b">nil</code>的类型。您可以通过在任何类型后添加问号<code class="fe nw nx ny mw b">?</code>来创建可选:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="64db" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">var</strong> number: Int? = 10</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1cd6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.<em class="mu">Swift中的</em> <strong class="ak"> typealias </strong> <em class="mu">是什么？你如何创造一个？</em></h1><h2 id="ec28" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="d708" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated"><code class="fe nw nx ny mw b"><a class="ae ky" href="https://www.codingem.com/typealias-in-swift/" rel="noopener ugc nofollow" target="_blank">Typealias</a></code>顾名思义，是现有数据类型的别名。</p><p id="6024" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以像这样创建一个:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="24bb" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">typealias</strong> Weight = Float</span></pre><p id="6050" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可以用<code class="fe nw nx ny mw b">Weight</code>代替<code class="fe nw nx ny mw b">Float</code>:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="addc" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">let</strong> mass1: Weight = 150.0<br/><strong class="mw iu">let</strong> mass2: Weight = 220.0</span><span id="8a28" class="na md it mw b gy nf nc l nd ne"><strong class="mw iu">let</strong> total: Weight = mass1 + mass2</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c4fc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">8.<em class="mu">说出使用Swift的一些优势</em></h1><h2 id="ef44" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="1441" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">仅举几个例子:</p><ul class=""><li id="3219" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated">Swift是一种类型安全语言</li><li id="58d2" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">它有闭合支持</li><li id="27c9" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">它有可选的类型支持</li><li id="0eef" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">它有内置的错误处理功能</li><li id="5e64" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">它支持模式匹配</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7812" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">9.<em class="mu">Swift中有5种控制转移语句——说出它们的名称并解释使用它们的原因。</em></h1><h2 id="0710" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="0842" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">五种控制转移语句是:</p><ul class=""><li id="0941" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated"><code class="fe nw nx ny mw b">Break</code></li><li id="4c8a" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated"><code class="fe nw nx ny mw b">Continue</code></li><li id="de34" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated"><code class="fe nw nx ny mw b">Fallthrough</code></li><li id="4ec1" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated"><code class="fe nw nx ny mw b">Throw</code></li><li id="aecc" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated"><code class="fe nw nx ny mw b">Return</code></li></ul><p id="6fae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">控制转移语句更改代码运行的顺序。</p><p id="3170" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，当认为不必继续循环时，可以使用控制转移语句<code class="fe nw nx ny mw b"><strong class="lb iu">break</strong></code> <strong class="lb iu"> </strong>来结束For循环的执行:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="d2ab" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">for</strong> choice <strong class="mw iu">in</strong> choices:<br/>    <strong class="mw iu">if</strong> isCorrect(choice):<br/>        print("Correct choice found!")<br/>        <strong class="mw iu">break</strong></span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b0f4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">10.建议对这段代码进行一个小的重构</h1><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="67ee" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">if</strong> age &lt; 18 {<br/>    driveCar()<br/>} <strong class="mw iu">else</strong> {<br/>    doNotDrive()<br/>}</span></pre><p id="4852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个表达式很简洁，运行良好——但是你能建议一个小的重构改进来使它更好吗？</p><h2 id="7eb1" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="c129" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">您可以使用<a class="ae ky" href="https://www.codingem.com/swift-one-liner-if-else-statements/" rel="noopener ugc nofollow" target="_blank">三元条件操作符</a>将该表达式转换成一行代码，在这种情况下，这不会影响可读性，但会提高可读性。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="8b0a" class="na md it mw b gy nb nc l nd ne">age &lt; 18 ? driveCar() : doNotDrive()</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="771c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">11.提高代码可读性</h1><p id="d618" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">在我们公司，我们有20名开发人员和20种独特的编码风格。我们如何实施一些常见的编码风格/最佳实践？</p><h2 id="9bc3" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="cab2" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">开始使用棉绒，例如<a class="ae ky" href="https://medium.com/codex/swift-automatic-code-styling-tool-in-2021-971531595651" rel="noopener"> Swiftlint </a>。linter是一个易于安装的工具，它可以检查和修复您的错误，并代表您执行最佳实践和惯例。</p><p id="834a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用linter的默认指南，但是您也可以配置linter来匹配您公司的偏好。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bb01" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">12.<em class="mu">Swift中的完成处理程序是什么？</em></h1><h2 id="7ce7" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="d1ed" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/codex/swift-closures-made-simple-cb81dd15b543#:~:text=completion handlers—closures in action" rel="noopener">完成处理程序</a>是正在运行的闭包。</p><p id="2865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您执行一个耗时的任务，比如一个网络请求，并且您想在请求完成后立即做一些事情。但是你肯定<em class="nz">不想</em>因为多次检查流程是否正在进行而浪费资源。</p><p id="c64a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是使用完成处理程序的地方。完成处理程序是一个闭包，一旦耗时的流程完成，它就会“把你叫回来”。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="77de" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">13.<em class="mu">如果没有物理的Ios设备，如何测试一个Ios应用？</em></h1><h2 id="e5dd" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="5fd8" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">如果你没有iOS设备，你可以使用苹果的iOS设备模拟器在Mac上测试你的应用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4c6f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">14.<em class="mu">init()在Swift中是做什么的？</em></h1><h2 id="b5ee" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="3f4a" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated"><code class="fe nw nx ny mw b">init()</code>方法用于初始化一个实例。</p><p id="f6d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">初始化意味着准备一个(类、结构或枚举的)实例以供使用。</p><p id="53a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在初始化过程中，为实例的每个属性设置初始值。在实例可以使用之前，您还可以执行一些其他准备工作。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1f86" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">15.<em class="mu">解释Swift </em>中 <code class="fe nw nx ny mw b"><em class="mu">Let</em></code> <em class="mu">与</em> <code class="fe nw nx ny mw b"><em class="mu">Var</em></code> <em class="mu">的区别</em></h1><h2 id="8c60" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="bc1b" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">在Swift中，您可以使用<code class="fe nw nx ny mw b">let</code>创建一个常量(一个不能更改的值)，使用<code class="fe nw nx ny mw b">var</code>创建一个变量(一个以后可以修改的值)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b6ee" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">16.<em class="mu">什么是</em> <code class="fe nw nx ny mw b"><em class="mu">PLIST</em></code> <em class="mu">？</em></h1><h2 id="1e8f" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="0728" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">PLIST或属性列表是用于在项目文件系统中存储数据的键值对的字典。比如<code class="fe nw nx ny mw b">info.plist</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="de78" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">17.<em class="mu">Swift中有哪些协议？举个例子</em></h1><h2 id="c7e9" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="dcbe" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/codex/swift-how-protocols-work-5d0d43a961e7" rel="noopener">协议</a>是一个代码契约。它充当属性、方法等的蓝图。它描述了符合的类型<em class="nz">必须如何表现。</em></p><p id="fc87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您不能创建协议的实例。相反，你可以让一个类<em class="nz">符合</em>一个协议。</p><p id="572b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是描述动物的示例协议:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0ea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建符合<code class="fe nw nx ny mw b">Animal</code>协议的<code class="fe nw nx ny mw b">Cat</code>和<code class="fe nw nx ny mw b">Dog</code>类。因此，要求它们都实现<code class="fe nw nx ny mw b">Animal</code>协议中描述的行为，即变量<code class="fe nw nx ny mw b">name</code>、<code class="fe nw nx ny mw b">color</code>和<code class="fe nw nx ny mw b">makeSound()</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0242" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">18.<em class="mu">什么是双问号运算符？</em></h1><h2 id="324f" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="ae01" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">双问号运算符<code class="fe nw nx ny mw b">??</code>被称为零合并运算符。如果不是<code class="fe nw nx ny mw b">nil</code>，则<em class="nz"> </em>返回左侧的值。如果左边是<code class="fe nw nx ny mw b">nil</code>，那么它返回右边的值。</p><p id="9f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nz">零合并</em>可用作检查可选值是否为<code class="fe nw nx ny mw b">nil</code>的简写。例如，您可以替换为:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="1e38" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">var</strong> name: String?</span><span id="7715" class="na md it mw b gy nf nc l nd ne"><strong class="mw iu">if</strong> name != <strong class="mw iu">nil</strong> {<br/>    print(name)<br/>} <strong class="mw iu">else</strong> {<br/>    print("N/A")<br/>}</span></pre><p id="60a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="ada1" class="na md it mw b gy nb nc l nd ne">print(name ?? "N/A")</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e328" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">19.<em class="mu">什么是守卫声明？举个例子</em></h1><h2 id="462f" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="9093" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">guard语句用于将程序控制转移到范围之外。Guard语句类似于if语句，但它仅在某些条件不满足时运行。</p><p id="6834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，用于退出函数的guard语句:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="f29b" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">func</strong> myFun() {<br/>    <strong class="mw iu">guard</strong> <strong class="mw iu">false</strong> <strong class="mw iu">else</strong> {<br/>         print("This block is run")<br/>         <strong class="mw iu">return</strong><br/>    }<br/>    print("This is never run")<br/>}</span><span id="e009" class="na md it mw b gy nf nc l nd ne">myFun()</span></pre><p id="eaf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="17dd" class="na md it mw b gy nb nc l nd ne">This block is run</span></pre><h1 id="54fe" class="mc md it bd me mf oq mh mi mj or ml mm jz os ka mo kc ot kd mq kf ou kg ms mt bi translated">20.<em class="mu">Swift中有哪三种主要的托收类型？</em></h1><h2 id="9c8e" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><ul class=""><li id="3c69" class="oc od it lb b lc nr lf ns li ov lm ow lq ox lu oh oi oj ok bi translated">数组:数组是值的有序集合。</li><li id="bcd5" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">集合:集合是值的无序集合。</li><li id="e827" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">字典:字典是键值对的无序集合。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="84a8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">21.<em class="mu">Swift中的Defer是什么？</em></h1><h2 id="1093" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="0adc" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">您可以使用<a class="ae ky" href="https://medium.com/codex/swift-cheat-sheet-statement-keywords-cf6520f3de12#:~:text=use defer to execute code right before exiting the scope where you are using the keyword. for example:" rel="noopener"> defer </a>方法在退出作用域之前执行代码。例如，让我们在函数执行完成之前打印一些内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="fbb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">延迟通常在打开和关闭某个范围内的上下文时使用，例如在访问文件时。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="da61" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">22.没有第三个辅助变量可以交换两个变量吗？</h1><h2 id="453a" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="8a1b" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">是的，这是可能的。使用<a class="ae ky" href="https://www.codingem.com/swift-destructuring-tuples/" rel="noopener ugc nofollow" target="_blank">元组析构</a>，可以这样解决问题:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="bcdc" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">var</strong> a = 1<br/><strong class="mw iu">var</strong> b = 2</span><span id="bbb0" class="na md it mw b gy nf nc l nd ne">(a, b) = (b, a)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5e0c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><em class="mu"> 23。结构和类有什么区别？</em></h1><h2 id="19de" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><ul class=""><li id="f3e4" class="oc od it lb b lc nr lf ns li ov lm ow lq ox lu oh oi oj ok bi translated">结构是值类型，而类是引用类型。</li><li id="28b0" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">结构不支持继承，类支持。</li><li id="3dcb" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">在类中，我们可以用<code class="fe nw nx ny mw b">let</code>关键字创建一个实例，并尝试改变它的属性，而在结构中没有可变性。</li><li id="3c0b" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">结构不支持类型转换，但类支持。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eaa0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">24.什么是可选链接？</h1><h2 id="df7f" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="e7b6" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">可选链接意味着您可以安全地调用可能是<code class="fe nw nx ny mw b">nil</code>的东西的属性。</p><p id="1785" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可选链接的工作方式，顾名思义，就是用问号运算符<code class="fe nw nx ny mw b">?</code>链接一个或多个可选值，如下所示:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="04a3" class="na md it mw b gy nb nc l nd ne">something?.someValue?.someMethod()</span></pre><p id="1df5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在上述链中的任何一点遇到了<code class="fe nw nx ny mw b">nil</code>，应用程序不会崩溃——相反，会返回一个<code class="fe nw nx ny mw b">nil</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c16c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">25.<em class="mu">什么是可选绑定？</em></h1><h2 id="fea3" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="33d7" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">可选绑定检查可选的是否包含值。如果可选的有一个值，可选绑定使该值暂时可用:</p><p id="c11b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个例子，下面的代码检查名字是否是<code class="fe nw nx ny mw b">nil</code>。如果不是，则创建一个临时常数<code class="fe nw nx ny mw b">realName</code>并为其赋值<code class="fe nw nx ny mw b">name</code>。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="169d" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">var</strong> name: String? = "Charles"</span><span id="f057" class="na md it mw b gy nf nc l nd ne"><strong class="mw iu">if</strong> <strong class="mw iu">let</strong> realName = name {<br/>    print (realName)<br/>}</span></pre><p id="d103" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="00db" class="na md it mw b gy nb nc l nd ne">Charles</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6c38" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">26.<em class="mu">解释MVC架构</em></h1><h2 id="0319" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="be36" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">MVC(模型-视图-控制器)，是一个开发iOS应用的软件架构。这是iOS应用程序开发的基本概念之一。</p><p id="c623" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多个iOS框架使用MVC。</p><p id="041e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MVC的思想是将数据从一个地方传递到另一个地方。这意味着中的任何对象都属于以下三个类别之一:</p><ul class=""><li id="69e1" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated"><strong class="lb iu">模型:</strong>模型代表app的数据。它存储信息，如商店中的产品。模型管理应用程序的状态。</li><li id="6b3e" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">视图:视图负责显示用户界面并与之交互。例如，一个视图为应用程序的用户呈现一个产品表。</li><li id="8474" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">控制器:控制器是将模型和视图粘合在一起的东西。它负责控制两者之间的逻辑。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9e1f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">27.<em class="mu">Swift中的输入输出参数是什么？</em></h1><h2 id="c5d0" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="f03f" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">一个<a class="ae ky" href="https://www.codingem.com/2021/04/07/swift-what-is-inout/" rel="noopener ugc nofollow" target="_blank"> inout </a>参数允许你改变函数内部参数的值。</p><p id="087c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使参数进出，在参数类型前使用<code class="fe nw nx ny mw b">inout</code>关键字。</p><p id="927a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要传递一个变量作为输入输出，在它的名字前面使用<code class="fe nw nx ny mw b">&amp;</code>。</p><p id="43c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2431" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">28.<em class="mu">什么是元组？如何创建一个，如何从中读取值？</em></h1><h2 id="c143" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="e16b" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">元组是可用于将多个值捆绑在一起的值，例如，作为一对。</p><p id="b86b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">元组的值不需要属于同一类型。</p><p id="52a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过在括号内用逗号分隔值来创建元组。</p><p id="c6c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="51ee" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">var</strong> coordinates3D = (1.0, 2.0, 5.0)</span></pre><p id="4b67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要访问元组中的值，请使用点符号和索引:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="a525" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">let</strong> xPos = coordinates3D.0</span></pre><p id="c836" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以创建元组，以便每个值都有一个名称:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="a498" class="na md it mw b gy nb nc l nd ne">var coordinates3D = (x: 1.0, y: 2.0, z: 5.0)</span></pre><p id="2a36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，您可以通过名称访问元组的特定值:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="b781" class="na md it mw b gy nb nc l nd ne">let xPos = coordinates3D.x</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="34a3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">29.<em class="mu">什么是Swift报文？</em></h1><h2 id="6533" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="8d51" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">Swift Messages是一个库，用于将消息显示为iOS设备屏幕顶部或底部的状态栏。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1584" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">30.<em class="mu">可以给函数参数一个默认值吗？怎么会？</em></h1><h2 id="0ad6" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="4849" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">可以给参数一个默认值:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="8db3" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">func</strong> eat(food: String = "spaghetti") {<br/>    print("Yum! I ate some good \(food).")<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0a9e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">31.什么是仿制药？举一个使用泛型的例子</h1><h2 id="9916" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="374a" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">泛型允许您编写灵活且可重用的代码，可以处理任何数据类型。</p><p id="51d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您正在编写一个3D向量结构，但是您希望能够使用整数、浮点数和双精度数来创建向量。您肯定不希望为每种数据类型分别编写相同的代码。</p><p id="c853" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是你可以使用泛型的地方。</p><p id="abf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可以为参数创建一个通用类型(代表任何类型),使用字母如<code class="fe nw nx ny mw b">T</code>,如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5a38" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">32.英镑财产被称为什么？什么是Getters和Setters？</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="6440" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="9351" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated"><code class="fe nw nx ny mw b">pounds</code>属性也被称为<a class="ae ky" href="https://medium.com/codex/getters-and-setters-in-swift-79a46e9401a0" rel="noopener"> <em class="nz">一个计算属性</em> </a> <em class="nz">。</em></p><p id="e450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Swift中，计算的属性<em class="nz">不存储在对象</em>中。计算属性意味着只有当试图访问它时，它的值才“按需”计算。您可以使用<code class="fe nw nx ny mw b">get</code>和(可选)<code class="fe nw nx ny mw b">set</code>方法创建计算属性。</p><ul class=""><li id="ca36" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated">当调用<code class="fe nw nx ny mw b">weight.pounds</code>时，<code class="fe nw nx ny mw b">get</code>方法执行“按需”<em class="nz">计算</em>。</li><li id="68c1" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated"><code class="fe nw nx ny mw b">set</code>方法在<code class="fe nw nx ny mw b">pounds</code>更新时更新<code class="fe nw nx ny mw b">kilograms</code>。(注意<code class="fe nw nx ny mw b">set</code>方法是可选的，你不需要这样的方法来创建一个计算属性。)</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0b54" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">33.==和===运算符有什么区别？</h1><h2 id="1416" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><ul class=""><li id="4a12" class="oc od it lb b lc nr lf ns li ov lm ow lq ox lu oh oi oj ok bi translated"><code class="fe nw nx ny mw b">==</code>是相等运算符。</li><li id="fb04" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated"><code class="fe nw nx ny mw b">===</code>是恒等运算符。</li></ul><p id="09df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相等运算符<code class="fe nw nx ny mw b">==</code>用于检查两个<code class="fe nw nx ny mw b">Equatable</code>类型是否相等:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="c4a4" class="na md it mw b gy nb nc l nd ne">"Hello" == "Hello"<br/>10.0 == 5.0 + 5.0</span></pre><p id="561e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恒等运算符<code class="fe nw nx ny mw b">===</code>可用于检查两个类是否相同，即它们是否指向同一个内存地址。让我们看一个例子:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="5f6d" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">class</strong> Fruit {<br/>    <strong class="mw iu">var</strong> name = "Banana"<br/>}</span><span id="4753" class="na md it mw b gy nf nc l nd ne"><strong class="mw iu">let</strong> fruit1 = Fruit()<br/><strong class="mw iu">let</strong> fruit2 = fruit1 // fruit2 now points to same address as fruit1</span><span id="0ce0" class="na md it mw b gy nf nc l nd ne">fruit1 === fruit2 // true</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fc6c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">34.<em class="mu">什么是扩展？</em></h1><h2 id="15aa" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="dded" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">在Swift中，您可以使用扩展向现有类型添加功能。</p><p id="ddb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Swift中，您可以使用<code class="fe nw nx ny mw b"><strong class="lb iu">extension</strong></code>关键字创建扩展:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="8617" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">extension</strong> SomeExistingType {<br/>    // add new functionality to SomeExistingType here<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="155a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">35.<em class="mu">什么是嵌套函数？</em></h1><h2 id="bd98" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="af96" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">嵌套函数是函数内部函数的组合:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="e6f9" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">func</strong> outer() {<br/>    <strong class="mw iu">func</strong> inner() {<br/>       // Do something here<br/>    }<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b0a9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">36.<em class="mu">如何在Swift中创建基类？</em></h1><h2 id="b931" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="9996" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">您可以通过定义没有超类的类来创建基类。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ba25" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">37.<em class="mu">什么是强制解包？你应该什么时候使用它？</em></h1><h2 id="af6f" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="ee01" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">强制展开<strong class="lb iu"> </strong>尝试<strong class="lb iu"> </strong>将可选转换为值，不管它是否包含值。</p><p id="27af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">强制解包是不安全的，因为如果可选选项是<code class="fe nw nx ny mw b">nil</code>，你试图解开它，它会触发一个错误，使应用程序崩溃。因此，应该避免使用它，除非你100%确定这个选项不是<code class="fe nw nx ny mw b">nil</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="88c2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">38.列举使用高阶函数的一些好处。</h1><h2 id="a0de" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><ul class=""><li id="82d0" class="oc od it lb b lc nr lf ns li ov lm ow lq ox lu oh oi oj ok bi translated">它们提供了灵活性。</li><li id="5004" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">它们在不能使用常规函数的异步调用中很有用。</li><li id="6176" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">他们有时会提高代码的质量，使代码更短、更简洁。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6db3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">39.<em class="mu">F</em><code class="fe nw nx ny mw b"><strong class="ak">ileprivate</strong></code><em class="mu">和P </em> <code class="fe nw nx ny mw b"><strong class="ak">rivate</strong></code> <em class="mu">有什么区别？</em></h1><h2 id="5b04" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><ul class=""><li id="71d0" class="oc od it lb b lc nr lf ns li ov lm ow lq ox lu oh oi oj ok bi translated">可以在同一个Swift文件中的任何地方读取<code class="fe nw nx ny mw b">fileprivate</code>属性，但不能在文件之外读取。</li><li id="3bab" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">一个<code class="fe nw nx ny mw b">private</code>属性只能在声明它的类型中读取(以及在同一文件中该类型的扩展中)。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0822" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">40.<em class="mu">您如何解释Swift的功能？</em></h1><h2 id="0b9b" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="194e" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">函数使得定义可重用的代码块成为可能。函数可以执行属于程序一部分的任务。</p><p id="24b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，函数接受一些它们可以使用的值。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="105f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">41.<em class="mu">N</em><code class="fe nw nx ny mw b"><strong class="ak">il</strong></code><em class="mu">和N </em> <code class="fe nw nx ny mw b">one</code> <em class="mu">有什么区别？</em></h1><h2 id="06e8" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="8805" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">两者没有区别:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="989e" class="na md it mw b gy nb nc l nd ne">nil == .none // returns true</span></pre><p id="86b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的区别是使用<code class="fe nw nx ny mw b">nil</code>比使用<code class="fe nw nx ny mw b">none</code>更常见。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="675b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">42.<em class="mu">Swift中的字典是什么？</em></h1><h2 id="51b0" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="ad35" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">字典是Swift中的基本集合类型。它可以用来存储键值对。</p><p id="3426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过知道一个键，可以很容易地访问一个值:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="dc9f" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">let</strong> dict = ["a": 1, "b": 2]</span><span id="8348" class="na md it mw b gy nf nc l nd ne"><strong class="mw iu">let</strong> valueOfA = dict["a"]</span></pre><h1 id="c9c6" class="mc md it bd me mf oq mh mi mj or ml mm jz os ka mo kc ot kd mq kf ou kg ms mt bi translated">43.<em class="mu">M</em><code class="fe nw nx ny mw b"><strong class="ak"><em class="mu">utating</em></strong></code><em class="mu">关键字是做什么的？</em></h1><h2 id="8097" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="5a28" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">您可以使用<code class="fe nw nx ny mw b">mutating</code>关键字通过标记特定的方法<code class="fe nw nx ny mw b">mutating</code>来允许改变方法中结构的属性。</p><p id="ed93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="61ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，这对于<a class="ae ky" href="https://medium.com/codex/structs-vs-classes-in-swift-c37ef7e7d960#:~:text=a%20value%20type%20is%20a%20type%20whose%20value%20is%20copied%20when%20it%E2%80%99s%20assigned%20to%20a%20variable%20or%20constant%2C%20or%20when%20it%E2%80%99s%20passed%20to%20a%20function." rel="noopener">值类型</a>(结构和枚举)是不可能的，但是对于<a class="ae ky" href="https://medium.com/codex/structs-vs-classes-in-swift-c37ef7e7d960#:~:text=in%20swift%2C%20classes%20are%20reference%20types%20by%20their%20nature.%20when%20we%20create%20an%20instance%20of%20a%20class%20and%20assign%20it%20to%20a%20variable%2C%20the%20instance%20is%20not%20copied%20to%20the%20new%20variable.%20a%20reference%20to%20it%20is%20used%20instead." rel="noopener">引用类型</a>(类)是可能的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="18c6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">44.你能解决这个代码中的问题吗？</h1><p id="198d" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">下面的代码抛出了一个编译器错误。怎么了？你能如何修理它？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="1070" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="2b5b" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">一个<code class="fe nw nx ny mw b"><a class="ae ky" href="https://www.codingem.com/the-guard-keyword-in-swift/" rel="noopener ugc nofollow" target="_blank">guard</a></code>语句的<code class="fe nw nx ny mw b">else</code>块需要一个退出路径。</p><p id="1f52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可以使用<code class="fe nw nx ny mw b">return</code>为其提供一个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="51b2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">45.<em class="mu">什么是反初始化器？你怎么能创造一个呢？</em></h1><h2 id="d3cb" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="1a7f" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">在释放类实例之前运行反初始化程序。</p><p id="cdb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe nw nx ny mw b">deinit</code>关键字创建一个反初始化器。</p><p id="0602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有当您需要在释放类实例之前做一些整理工作时，此方法才是有用的。大多数情况下，让Swift代表您自动处理就足够了。</p><p id="b891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个反初始化器的例子，当<code class="fe nw nx ny mw b">Example</code>的一个实例被释放时，它将<code class="fe nw nx ny mw b">number</code>设置回0。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="733c" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">var</strong> number = 15</span><span id="eccc" class="na md it mw b gy nf nc l nd ne"><strong class="mw iu">class</strong> Example {<br/>    <strong class="mw iu">init</strong>() {<br/>       number *= 10<br/>    }<br/>    <br/>    <strong class="mw iu">deinit</strong> {<br/>        number = 0<br/>    }<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="776a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">46.函数和方法有什么区别？</h1><h2 id="e4d9" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="2c39" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">函数和方法之间有一点小小的区别。两者都是可重用的代码块，然而，方法属于类、结构或枚举，而函数不属于。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b3ee" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">47.你怎么能禁止一个类被继承呢？</h1><h2 id="c3fb" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="2546" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">通过使用<code class="fe nw nx ny mw b">final</code>关键字使该类成为最终类。例如:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="e65f" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">final</strong> <strong class="mw iu">class</strong> Animal {<br/>    let name = "I'm a furry animal"<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b2a7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">48.<em class="mu">什么是懒惰变量？什么时候应该使用？</em></h1><h2 id="5f0d" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="6ad7" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">惰性变量的初始值是在第一次调用它时计算的。惰性变量可以通过在需要之前不做不必要的工作来优化代码。</p><p id="949b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="00cc" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">lazy</strong> <strong class="mw iu">var</strong> tallest: Person? = {<br/>    <strong class="mw iu">return</strong> people.max(by: { $0.height &lt; $1.height })<br/>}()</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8e70" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">49.<em class="mu">Swift中的自动关闭是什么？您应该如何以及何时使用它？</em></h1><h2 id="3fe8" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="6e63" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">一个自动闭包将一个函数参数包装到一个闭包里。当调用autoclosure时，它返回包装在里面的表达式的值。</p><p id="7da3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，在使用带有闭包参数的函数时，使用autoclosures在语法上很方便。这是因为autoclosure允许您省略花括号<code class="fe nw nx ny mw b">{}</code>。这可以使代码更具可读性。</p><p id="5d9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，请记住<a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html" rel="noopener ugc nofollow" target="_blank">苹果对使用自动关闭</a>的说法:</p><blockquote class="oy oz pa"><p id="24cf" class="kz la nz lb b lc ld ju le lf lg jx lh pb lj lk ll pc ln lo lp pd lr ls lt lu im bi translated">调用采用自动闭包的函数很常见，但实现这种函数并不常见。</p></blockquote><p id="fe1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个简化代码的自动关闭的例子。第一个代码片段使用常规闭包，第二个代码片段使用autoclosure。看看第二个例子中的<code class="fe nw nx ny mw b">I_will</code>函数调用是如何变得更具可读性的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9ce9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">50.这段代码中缺少了什么？</h1><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="e401" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">enum</strong> Example {<br/>  <strong class="mw iu">case</strong> something(Int, Example)<br/>}</span></pre><h2 id="6c93" class="na md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">回答:</h2><p id="8fca" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">可以在Swift中创建类似上面的递归枚举。下面是一个抽象的例子——然而，使用递归枚举是默认禁用的，你需要使用<code class="fe nw nx ny mw b">indirect</code>关键字来启用它:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="f360" class="na md it mw b gy nb nc l nd ne"><strong class="mw iu">enum</strong> Example {<br/>  indirect <strong class="mw iu">case</strong> something(Int, Example)<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1faa" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">51.奖金——在结束中[软弱的自己]做了什么</h1><p id="aa4b" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">在一个类中，闭包与<strong class="lb iu"> self </strong>创建了一个强引用循环。</p><p id="c537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">强大的引用周期会导致内存泄漏，从而导致应用程序出现意外行为。</p><p id="6120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，被删除的视图控制器可以继续在后台执行，因为ARC不能释放它。</p><p id="ac97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止这种情况，您需要使对<strong class="lb iu">自身</strong>的引用变弱。这是通过在闭包中使用<strong class="lb iu">【弱自我】</strong>来实现的。</p><p id="9834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阅读更多关于<a class="ae ky" href="https://www.codingem.com/weak-self-in-swift/" rel="noopener ugc nofollow" target="_blank">这个话题</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f4c2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="8c68" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">感谢阅读。我希望这些对你有用，并能帮助你找到理想的工作！</p><p id="935f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我很想加入你的LinkedIn网络。随意连接<a class="ae ky" href="https://www.linkedin.com/in/artturi-jalli-29619413a" rel="noopener ugc nofollow" target="_blank"> Artturi Jalli </a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8e76" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><div class="pe pf gp gr pg ph"><a href="https://swift.org/documentation/" rel="noopener  ugc nofollow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">Swift.org</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">您可以将此页面上的资源用作Swift语言的文档。苹果公司拥有额外的资源…</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">swift.org</p></div></div></div></a></div><div class="pe pf gp gr pg ph"><a href="https://developer.apple.com/documentation/" rel="noopener  ugc nofollow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">Apple开发者文档</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">编辑描述</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">developer.apple.com</p></div></div></div></a></div></div></div>    
</body>
</html>