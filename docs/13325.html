<html>
<head>
<title>Blazingly fast REST API in Go with Gin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">《与杜松子酒同行》中惊人的快速休息API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modern-rest-api-with-go-and-postgresql-39b0e966534a?source=collection_archive---------4-----------------------#2022-08-17">https://betterprogramming.pub/modern-rest-api-with-go-and-postgresql-39b0e966534a?source=collection_archive---------4-----------------------#2022-08-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fa46" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Go第2部分构建现代REST API</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dae2a7e2a240a9fd21359f81d38feca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hlL8qyjq2rNmAQEe"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Bjarne Vijfvinkel 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="1e04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文是一系列文章中的第二篇，涵盖了逐步实现现代REST API微服务的所有方面:</p><ol class=""><li id="2e00" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-c765d571b9e7" rel="noopener">用sqlc定义SQL优先数据模型</a></li><li id="b88f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">用Gin实现REST API</strong></li><li id="55cf" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-1d48767a813" rel="noopener">用Viper配置</a></li><li id="6a11" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-e0070aa1b383" rel="noopener">在容器中构建和运行</a></li><li id="857a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-7c916ce2816a" rel="noopener">集装箱测试</a></li></ol><p id="0265" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该系列的所有代码都可以在https://github.com/bquenin/modern-go-rest-api-tutorial<a class="ae kv" href="https://github.com/bquenin/modern-go-rest-api-tutorial" rel="noopener ugc nofollow" target="_blank">获得</a></p><h1 id="0e90" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">数据模型与API模型</h1><p id="462f" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">至于数据模型，我们必须设计我们的REST API模型。存储在数据库中的数据模型和通过网络发送的REST API模型相似但不相同。例如，您的用户数据模型中可能有一个密码字段，您不想通过网络发送它。</p><p id="08be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，虽然相似，但数据和API模型并不相同，在某些情况下，差异很大。我们可以将与数据模型相同的基本原理应用于API模型:</p><ul class=""><li id="746d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nd ly lz ma bi translated"><strong class="ky ir"> API优先</strong>:有竞争的标准，但是<a class="ae kv" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank"> OpenAPI </a>(又名Swagger)是事实上的标准。OpenAPI允许你描述REST API的所有方面:资源路径、输入、输出等等。您可以用自己喜欢的语言从API描述中生成客户机和服务器存根。例如，您可以使用<a class="ae kv" href="https://github.com/deepmap/oapi-codegen" rel="noopener ugc nofollow" target="_blank"> oapi-codegen </a>在Go中创建存根。</li><li id="a76f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nd ly lz ma bi translated"><strong class="ky ir">代码优先</strong>:另一方面，您可以直接在代码中定义API端点、输入和输出，让您完全控制您的资源处理程序。在Go中，有几个著名的库允许快速REST API开发，比如<a class="ae kv" href="https://gin-gonic.com/" rel="noopener ugc nofollow" target="_blank"> gin </a>、<a class="ae kv" href="https://echo.labstack.com/" rel="noopener ugc nofollow" target="_blank"> echo </a>，或者<a class="ae kv" href="https://go-chi.io/" rel="noopener ugc nofollow" target="_blank"> chi </a>。</li></ul><p id="8daf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两种方法各有利弊，并且已经有大量关于何时使用它们的文献。同样，没有正确或错误的答案，因为它取决于许多因素。本教程将遵循使用<a class="ae kv" href="https://gin-gonic.com/" rel="noopener ugc nofollow" target="_blank"> gin </a>库的代码优先方法。</p><h1 id="9a4c" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">实现作者服务</h1><p id="1f4d" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">如前所述，我们正在为sqlc教程中提供的示例模型构建一个REST API。我们希望实现以下方法:</p><ul class=""><li id="77c9" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nd ly lz ma bi translated">在帖子上创建作者/作者</li><li id="cf6a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nd ly lz ma bi translated">在GET /authors/:id上按id获取作者</li><li id="a0f1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nd ly lz ma bi translated">PUT上的完整更新作者/authors/:id</li><li id="c093" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nd ly lz ma bi translated">修补程序/authors/:id上的部分更新作者</li><li id="641e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nd ly lz ma bi translated">在删除/authors/:id时删除作者</li><li id="afca" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nd ly lz ma bi translated">在GET /authors上列出作者</li></ul><p id="2bf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要定义我们的作者服务。我们将在以下位置添加<em class="ne"> authors.go </em>文件:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="9b45" class="nk mh iq ng b gy nl nm l nn no">└── api<br/>    └── authors<br/>        └── authors.go</span></pre><p id="445e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，在Go中，有一个惯例是将所有API服务放在<strong class="ky ir"> api </strong>文件夹下。如果我们要实现多个服务，我们可以将它们添加到各自的文件夹下，如下所示:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="c0ec" class="nk mh iq ng b gy nl nm l nn no">└── api<br/>    ├── authors<br/>    │   └── authors.go<br/>    ├── books<br/>    │   └── books.go<br/>    └── publishers<br/>        └── publishers.go</span></pre><p id="8220" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我们的作者服务的基本实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者服务的基本实现</p></figure><p id="fe70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在服务结构中唯一需要的字段是由sqlc生成的代码提供的<strong class="ky ir">查询</strong>对象。它允许运行我们之前定义的SQL查询。</p><h1 id="21f6" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">注册处理程序</h1><p id="f88b" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们现在要为每个API方法定义一个处理程序。处理程序负责管理对特定HTTP动词和路径的任何调用。由于我们正在使用<a class="ae kv" href="https://gin-gonic.com/" rel="noopener ugc nofollow" target="_blank"> gin </a>，我们将像这样向路由器注册我们的处理程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将<strong class="ak"> RegisterHandlers </strong>方法添加到作者服务</p></figure><h1 id="7f18" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">实现处理程序</h1><p id="3b55" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">处理程序的实现分为3个步骤:</p><ul class=""><li id="5d74" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nd ly lz ma bi translated"><strong class="ky ir">解析请求:</strong>验证并清理所有输入参数，</li><li id="a891" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nd ly lz ma bi translated"><strong class="ky ir">执行请求</strong>:执行我们用sqlc定义的SQL查询，</li><li id="143f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nd ly lz ma bi translated"><strong class="ky ir">构建响应</strong>:编辑任何敏感数据，并返回请求的信息以及适当的HTTP状态代码。</li></ul><h2 id="b7ec" class="nk mh iq bd mi nr ns dn mm nt nu dp mq lf nv nw ms lj nx ny mu ln nz oa mw ob bi translated">创建作者处理程序</h2><p id="8c3e" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">按照上面的结构，我们得到下面的<strong class="ky ir">创建作者</strong>处理程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建作者处理程序</p></figure><p id="821a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用<code class="fe oc od oe ng b">apiAuthor</code>结构来解析和验证我们的输入。Gin依靠Go struct标签来表达给定字段的验证约束。在我们的例子中，我们指定两个字段都是必需的，name字段的最大长度是32。</p><p id="6730" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以表达许多验证约束:最大长度、最小长度、电子邮件、UUID，甚至比特币地址！确保查看验证器库的<a class="ae kv" href="https://github.com/go-playground/validator#baked-in-validations" rel="noopener ugc nofollow" target="_blank">文档，以了解所有提供的验证器。</a></p><p id="e444" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果违反了任何约束，<code class="fe oc od oe ng b">ShouldBindJSON</code>方法会返回一个错误，我们会将该错误传播给调用者。</p><p id="06cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦输入被验证，我们通过从sqlc调用由<code class="fe oc od oe ng b">queries</code>对象提供的<code class="fe oc od oe ng b">CreateAuthor</code>函数来创建作者。</p><p id="fe76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将作者返回给调用者。我们使用以下方法将数据库作者转换为API作者:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将数据库对象转换为API对象</p></figure><p id="fc27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，数据库和API对象之间没有区别。然而，这通常是在需要时进行修订的地方。</p><h2 id="3aff" class="nk mh iq bd mi nr ns dn mm nt nu dp mq lf nv nw ms lj nx ny mu ln nz oa mw ob bi translated">获取作者处理程序</h2><p id="02ea" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">按照上面的结构，我们得到下面的<code class="fe oc od oe ng b">Get Author</code>处理程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="35a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个API调用，<code class="fe oc od oe ng b">id</code>参数是一个路径参数。然而，我们可以遵循相同的模式，定义一个<code class="fe oc od oe ng b">pathParameters</code>结构来表达我们的验证约束，并像验证任何其他参数一样验证它。</p><p id="124f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦输入被验证，我们就从数据库返回用户。</p><h2 id="c949" class="nk mh iq bd mi nr ns dn mm nt nu dp mq lf nv nw ms lj nx ny mu ln nz oa mw ob bi translated">删除作者处理程序</h2><p id="8c27" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">按照上面的结构，我们得到下面的<code class="fe oc od oe ng b">Delete Author</code>处理程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="41bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，唯一的参数是<strong class="ky ir"> id </strong>路径参数，所以我们使用相同的验证机制。</p><p id="ddc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们删除相应的作者，并返回一个带有OK状态代码的空响应。</p><h2 id="e14c" class="nk mh iq bd mi nr ns dn mm nt nu dp mq lf nv nw ms lj nx ny mu ln nz oa mw ob bi translated">列表作者处理程序</h2><p id="a61c" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">按照上面的结构，我们得到下面的<strong class="ky ir">列表作者</strong>处理程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="4d9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个API调用没有参数，所以我们执行SQL查询并将结果返回给调用者。请注意，这个实现很简单。现实世界的实现将提供搜索查询、过滤、排序、分页等。</p><h1 id="0b0f" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">更新作者</h1><p id="e8af" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">您可以对REST API资源执行两种类型的更新:</p><ul class=""><li id="ffab" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nd ly lz ma bi translated"><strong class="ky ir">完全更新</strong>:调用者必须提供他们想要替换的对象的所有字段。任何缺少的字段都将被视为更新的空值，并将清空数据库中的相应字段。</li><li id="85eb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nd ly lz ma bi translated"><strong class="ky ir">部分更新</strong>:调用者只提供需要更新的字段。</li></ul><p id="00b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据您的使用情况，如果您想更新几个字段，完全更新可能有些过头，而且会浪费大量资源。这就是为什么部分更新通常是首选的原因。</p><p id="9992" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几种方法可以实现部分更新。最常见的有:</p><ul class=""><li id="d371" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nd ly lz ma bi translated"><strong class="ky ir"> JSON合并补丁</strong>:如<a class="ae kv" href="https://www.rfc-editor.org/rfc/rfc7396.html" rel="noopener ugc nofollow" target="_blank"> RFC 7396 </a>中所定义的，定义了只有请求中提供的字段才应该被验证和更新；任何缺失的字段都应保持不变。</li><li id="2a20" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nd ly lz ma bi translated"><strong class="ky ir"> JSON补丁</strong>:如<a class="ae kv" href="https://www.rfc-editor.org/rfc/rfc6902" rel="noopener ugc nofollow" target="_blank"> RFC 6902 </a>中定义的，定义了一个补丁格式，调用者在其中定义要执行的更新。</li></ul><p id="b879" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我们将遵循<strong class="ky ir"> JSON合并补丁</strong>，因为它实现起来稍微容易一些，但两者都在行业中广泛使用。</p><h2 id="3575" class="nk mh iq bd mi nr ns dn mm nt nu dp mq lf nv nw ms lj nx ny mu ln nz oa mw ob bi translated">完全更新作者处理程序</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="479c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整更新需要更新作者的ID和完整内容。然后，我们必须相应地验证两个参数(路径和主体)。</p><p id="34d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦通过验证，我们就在数据库中更新作者，并将更新后的作者作为响应返回。</p><h2 id="d1c5" class="nk mh iq bd mi nr ns dn mm nt nu dp mq lf nv nw ms lj nx ny mu ln nz oa mw ob bi translated">部分更新作者处理程序</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5a7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，部分更新有点复杂，因为我们需要接受缺失的字段。为了适应这些，我们定义了一个<code class="fe oc od oe ng b">apiAuthorPartialUpdate</code>结构，其中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><ol class=""><li id="6ded" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">字段可以为空:使用指针，这样我们可以检查字段是否已经被提供，</li><li id="8eac" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">验证约束从“必需”更改为“忽略”。它告诉底层验证器只在字段存在时才验证字段，如果字段丢失，则不引发任何错误。</li></ol><p id="9653" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦验证成功，我们必须为SQL查询构建部分更新参数。如前所述，sqlc希望查询是完全结构化的，因此我们必须指出哪一列要更新或不更新:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c979" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们更新作者并将更新后的作者返回给调用者。</p><h1 id="b98e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">把所有的放在一起</h1><p id="8678" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">现在我们已经实现了我们的处理程序，我们可以相应地更新main函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><ol class=""><li id="b97c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">如前一篇文章所述，实例化我们的数据库连接，</li><li id="f410" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">用数据库查询对象实例化我们的作者服务，</li><li id="b90e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">实例化路由器并注册我们的处理程序，</li><li id="08d5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">启动服务器！</li></ol><h1 id="e2b9" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">下一步是什么？</h1><p id="b327" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">既然我们已经完成了REST API处理程序的实现，我们将看一看如何配置API服务器。</p></div></div>    
</body>
</html>