<html>
<head>
<title>Mastering the Android Touch System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握Android触摸系统</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mastering-the-android-touch-system-41234cf3c3b3?source=collection_archive---------2-----------------------#2019-11-26">https://betterprogramming.pub/mastering-the-android-touch-system-41234cf3c3b3?source=collection_archive---------2-----------------------#2019-11-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fcee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们探索一下触摸框架</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/255a6cbbe2174eacc5458650adaa1348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lXqs5t1BqMXgpVm9T_67uA.jpeg"/></div></div></figure><p id="57d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">处理触摸事件是开发用户交互的重要部分。我们已经知道了标准事件的基本处理:点击、长时间点击、按键等等。</p><p id="001f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我们将看到Android如何将触摸事件从父母发送到孩子。我们开始吧</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="6ef7" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">运动事件</h1><p id="c978" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">从触摸屏到我们的应用程序的每个事件都被包装成一个运动事件。运动事件是用于报告运动事件的对象。它们为我们提供了与每个事件相关的所有信息:动作是什么以及与事件相关的元数据，如触摸位置、该点在屏幕上的手指数量以及事件时间。</p><p id="c827" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运动事件根据动作代码和一组轴值来描述运动。动作代码指定发生的状态变化，例如指针向下或向上。轴值描述了位置和其他运动属性。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="666f" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">两颗北极指极星</h1><p id="310a" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">多点触摸屏为每个手指发出一个移动轨迹。产生移动轨迹的单个手指或其他物体(鼠标、笔、轨迹球)被称为指针。运动事件包含关于当前活动的所有指针的信息，即使它们中的一些自从上次事件被传送以来没有移动过。</p><p id="11d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们用手指触摸屏幕上的特定点时，产生的信息包括X、Y坐标，以及其他信息，如索引、id等。由于Android支持多点触摸，指针用于识别在同一时间点引起移动轨迹的所有对象。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="1bb0" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">行动</h1><p id="90da" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">动作类型和它们的名字暗示了它们做什么。可用的操作有</p><p id="ef29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> ACTION_DOWN: </strong>这是物体或手指进入<strong class="kw iu">接触</strong>屏幕的第一个点。当你把手指放在屏幕上<strong class="kw iu"> ACTION_DOWN </strong>，<strong class="kw iu"> </strong>被触发。</p><p id="eaf1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> ACTION_UP: </strong>这是物体或手指释放与屏幕接触的点。当您在屏幕上取下手指<strong class="kw iu"> ACTION_UP </strong>时，<strong class="kw iu"> </strong>被触发。</p><p id="0aea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> ACTION_MOVE: </strong>这是指针在屏幕上被<strong class="kw iu">拖动</strong>时调用的事件。这可以定义为循环<strong class="kw iu">动作_下降</strong>和<strong class="kw iu">动作_上升之间发生的变化。</strong></p><p id="6d8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> ACTION_POINTER_DOWN: </strong>这与<strong class="kw iu"> ACTION_DOWN </strong>类似，但<strong class="kw iu"> </strong>在支持多点触摸的情况下，当辅助或附加对象接触屏幕时调用。</p><p id="6f8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> ACTION_POINTER_UP: </strong>这与<strong class="kw iu"> ACTION_UP </strong>类似，但在支持多点触摸的情况下，当辅助或附加对象释放与屏幕的接触时，会调用<strong class="kw iu"> </strong>。</p><p id="ed34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> ACTION_CANCEL: </strong>当最初一个视图正在处理被转移到另一个视图的触摸时，该事件被触发。当前手势已被中止。你不会再得到任何分数了。</p><p id="5254" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">手势被定义为以<strong class="kw iu"> ACTION_DOWN </strong>开始，以<strong class="kw iu"> ACTION_UP结束。</strong>这个循环在交互过程中重复几次。每个指针都有一个唯一的id，该id在指针第一次下降时被分配(由<strong class="kw iu"> ACTION_DOWN </strong>或<strong class="kw iu"> ACTION_UP </strong>指示)。指针id保持有效，直到指针最终上升(由<strong class="kw iu"> ACTION_UP </strong>或<strong class="kw iu"> ACTION_POINTER_UP </strong>指示)或手势被取消(由<strong class="kw iu"> ACTION_CANCEL </strong>指示)。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="f9dd" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">了解系统</h1><p id="0475" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">这是我们完整的窗口，包含三个部分:状态栏、导航栏和内容视图。内容视图是一个<code class="fe mu mv mw mx b">FrameLayout</code>，它包含你正在展开的其他布局。<code class="fe mu mv mw mx b">setContentView</code>是告诉内容视图容器上应该填充什么的方法。里面的布局包含了我们添加的所有视图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/aa4ba4490dc9c6b687d37041d6c2b938.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*MMs_PpxPmMGOfWhr4tNJ0Q.png"/></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="d94d" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">Android如何处理触摸</h1><p id="2431" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">输入事件首先传递给窗口，然后传递给前台活动。在我们的应用程序中，最上面的前台活动在任何其他组件之前接收触摸事件。如果我们想要消费这个事件，并且不允许在视图层次结构中有任何进一步的活动，我们覆盖活动中的<code class="fe mu mv mw mx b">dipatchTouchEvent()</code>并返回true。活动的<code class="fe mu mv mw mx b">dispatchTouchEvent()</code>是接收触摸事件的第一个方法。</p><p id="2141" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果活动对处理触摸事件不感兴趣，那么它就会向下流动，从活动的根布局或<code class="fe mu mv mw mx b">ViewGroup</code>到底部视图。该循环继续流动，直到它找到某个对处理触摸事件感兴趣的组件。如果任何视图或视图组消耗了触摸事件，则循环停止。如果事件没有找到任何要使用的视图，并且如果循环到达了底部视图，则循环开始往回走，从层次结构底部的视图开始到顶部的活动。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/6154a6eb139367d628a795543ce09546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*xFRgeLd4jHpHDefDAHpj4w.png"/></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="86a9" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">onInterceptTouchEvent()</h1><p id="a321" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated"><code class="fe mu mv mw mx b">ViewGroup </code>有一个额外的方法<code class="fe mu mv mw mx b">onInterceptTouchEvent()</code>，它持续监控所有通过<code class="fe mu mv mw mx b">ViewGroup</code>流向其子视图的触摸事件。这是因为在任何给定的时间点，如果ViewGroup想要通过停止事件流来获得当前手势的所有权，子视图正在消耗的内容将开始自己消耗。换句话说，一个包含布局可以选择在视图接收到事件之前从一个被接触的视图中窃取事件。</p><p id="1e1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里最好的例子是一个包含要交互的孩子的<code class="fe mu mv mw mx b">ScrollView</code>。在这种情况下，父<code class="fe mu mv mw mx b">ViewGroup</code>不断地监控触摸事件流。如果有一个孩子正在处理的触摸事件，并且手势已经改变为拖动，那么使用<code class="fe mu mv mw mx b">onInterceptTouchEvent()</code>方法的父节点将停止孩子上的触摸事件并自行消耗。子视图可以调用父视图上的<code class="fe mu mv mw mx b">requestDisallowIntercept()</code>来在当前手势的持续时间内阻止<code class="fe mu mv mw mx b">onInterceptTouchEvent()</code>。一旦手势结束或者如果新的手势开始，这些标志被框架重置，因为框架给予父母优先权来控制孩子之上的触摸事件。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="6446" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">触摸调度</h1><p id="6fd2" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated"><strong class="kw iu">步骤1: </strong>包含内容视图的当前活动被调用<code class="fe mu mv mw mx b">Activity.dispatchTouchEvent()</code>。</p><p id="f149" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">步骤2: </strong>如果活动选择不“消费”事件(并开始传播)，则事件被传递到<code class="fe mu mv mw mx b">ViewGroup</code> <code class="fe mu mv mw mx b">dispatchTouchEvent</code>。</p><p id="42af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">步骤3: </strong> <code class="fe mu mv mw mx b">ViewGroup</code> <code class="fe mu mv mw mx b">dispatchTouchEvent</code>将首先触发<code class="fe mu mv mw mx b">ViewGroup</code> <code class="fe mu mv mw mx b">onInterceptTouchEvent</code>，如果该方法选择不拦截触摸事件，则通过触发<code class="fe mu mv mw mx b">dispatchTouchEvent</code>将其发送给孩子。</p><p id="d1e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总而言之，从活动开始，<code class="fe mu mv mw mx b">dispatchTouchEvent</code>在过程中的每个级别都被调用。调度程序负责确定接下来要调用哪些方法。在触发视图层次结构中下一个子节点上的<code class="fe mu mv mw mx b">dispatchTouchEvent</code>之前，调度程序触发<code class="fe mu mv mw mx b">ViewGroup</code>。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="bcd3" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">例子</h1><p id="ede1" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">让我们详细看看如果层次结构中没有视图使用触摸事件会发生什么。<code class="fe mu mv mw mx b">dispatchTouchEvent()</code> <strong class="kw iu"> </strong>从活动开始，一直到视图，如下图所示，没有任何东西消耗触摸事件，反向链从视图开始，调用视图的<code class="fe mu mv mw mx b"><strong class="kw iu">onTouchEvent()</strong></code>及其父视图，然后调用活动。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/5e94904fffe8ff3a5c661de4539486fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pAMFjiyfZ-BrBTb-on4X4A.png"/></div></div></figure><p id="6201" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">dispatchTouchEvent()</code> <strong class="kw iu"> <em class="nb"> </em> </strong> <em class="nb">是活动中的第一个方法，</em> <code class="fe mu mv mw mx b">onTouchEvent()</code> <em class="nb">是活动中最后一个接收触摸事件的方法。</em></p><p id="daed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个链条就像<code class="fe mu mv mw mx b">dispatchTouchEvent()</code>向下流动和<code class="fe mu mv mw mx b">onTouchEvent()</code>事件流回一样。因此，如果您想在活动中使用触摸事件，请使用<code class="fe mu mv mw mx b">dispatchTouchEvent()</code> <strong class="kw iu"> </strong>而不是<code class="fe mu mv mw mx b">onTouchEvent()</code>，因为在层次结构中，任何子视图都有可能使用它。如果任何视图被消耗，将无法返回。</p><p id="88b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在任何时候，如果任何组件对使用事件感兴趣，传播就在那里停止。它不会进一步传播，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/3606e8917edb713aaa33ce886bf47295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BFSEK_t2Dl2Q1RAwc2slMg.png"/></div></div></figure><p id="ffe1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在按钮在<code class="fe mu mv mw mx b">ScrollView</code>内的情况下，按钮在被点击时接收触摸事件，但是如果手势变为拖动，则<code class="fe mu mv mw mx b">onInterceptTouchEvent</code>被调用并且<code class="fe mu mv mw mx b">ScrollView</code>开始处理触摸，并且按钮接收<code class="fe mu mv mw mx b">ACTION_CANCEL</code>事件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/e371847b8c441080149a627069591f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4O7rzRKtozD-71bpbX3sYw.png"/></div></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="745d" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">自定义触摸处理</h1><p id="95b9" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">作为开发人员，在某些时候，我们可能需要在布局中移动视图。让我们看看如何做到这一点。</p><p id="8724" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，创建一个带有视图的XML，然后在活动中展开它。这是基本的设置，现在让我们开始运动部分。</p><pre class="kj kk kl km gt ne mx nf ng aw nh bi"><span id="b5a4" class="ni ly it mx b gy nj nk l nl nm">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:app="http://schemas.android.com/apk/res-auto"<br/>    xmlns:tools="http://schemas.android.com/tools"<br/>    android:id="@+id/_root"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    tools:context=".MainActivity"&gt;<br/><br/>    &lt;TextView<br/>        android:id="@+id/_textView"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:text="Hello World!"<br/>        android:textSize="30sp"<br/>        app:layout_constraintBottom_toBottomOf="parent"<br/>        app:layout_constraintLeft_toLeftOf="parent"<br/>        app:layout_constraintRight_toRightOf="parent"<br/>        app:layout_constraintTop_toTopOf="parent" /&gt;<br/><br/>&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span></pre><p id="0216" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们需要为我们打算在屏幕上移动的视图注册一个触摸监听器。接下来，我们覆盖<code class="fe mu mv mw mx b">onTouch()</code>方法，它有两个属性:视图和<code class="fe mu mv mw mx b">MotionEvent</code>。然后逻辑开始，因为我们必须移动文本视图:我们需要获得触摸事件的X和Y坐标，然后将它们设置到视图中。通过这样做，视图在屏幕上移动，但不是像我们预期的那样——在ACTION_DOWN中需要计算delta部分。可以通过从视图X坐标中减去运动事件X坐标来获得δX坐标。下面是一个简单的等式:</p><pre class="kj kk kl km gt ne mx nf ng aw nh bi"><span id="4886" class="ni ly it mx b gy nj nk l nl nm">var _xDelta = _textView.x — event.rawX</span><span id="3a38" class="ni ly it mx b gy nn nk l nl nm">package com.example.myapplication<br/><br/>import androidx.appcompat.app.AppCompatActivity<br/>import android.os.Bundle<br/>import android.view.MotionEvent<br/>import android.view.View<br/>import kotlinx.android.synthetic.main.activity_main.*<br/><br/>class MainActivity : AppCompatActivity(),View.OnTouchListener {<br/><br/>    private var _xDelta: Float = 0.0f<br/>    private var _yDelta: Float = 0.0f<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_main)<br/>        _textView.setOnTouchListener(this)<br/><br/>    }<br/><br/>    override fun onTouch(p0: View?, event: MotionEvent): Boolean {<br/><br/>        when (event.action) {<br/><br/>            MotionEvent.ACTION_DOWN -&gt; {<br/><br/>                _xDelta = _textView.x - event.rawX<br/>                _yDelta = _textView.y - event.rawY<br/>            }<br/>            MotionEvent.ACTION_MOVE -&gt;<br/><br/>                _textView.animate()<br/>                    .x(event.rawX + _xDelta)<br/>                    .y(event.rawY + _yDelta)<br/>                    .setDuration(0)<br/>                    .start()<br/>            else -&gt; return false<br/>        }<br/>        return true<br/>    }<br/><br/>}</span></pre><p id="ecc3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> </strong>增量X分量应在ACTION_DOWN上计算，并应从ACTION_MOVE中的事件X坐标中扣除。输出将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/b0f989b24c11385602c815fdb8075fca.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/1*xXyzBFGE1DhaMPGgAd1f2w.gif"/></div><p class="np nq gj gh gi nr ns bd b be z dk translated">输出</p></figure><p id="a190" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">目前就这些。我们对Android触摸系统如何工作，如何拦截子触摸事件，如何阻止父触摸事件，以及如何移动屏幕上的视图有了一个概念。有关多点触摸事件和其他触摸相关内容链接的更多信息，请点击以下链接。</p><h2 id="945d" class="ni ly it bd lz nt nu dn md nv nw dp mh ld nx ny mj lh nz oa ml ll ob oc mn od bi translated">参考</h2><p id="1205" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated"><a class="ae oe" href="https://www.youtube.com/watch?v=EZAoJU-nUyI" rel="noopener ugc nofollow" target="_blank">戴夫·史密斯掌握安卓触摸系统</a></p><p id="ab65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae oe" href="https://developer.android.com/training/gestures/viewgroup" rel="noopener ugc nofollow" target="_blank">管理视图组中的触摸事件</a></p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="19c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>