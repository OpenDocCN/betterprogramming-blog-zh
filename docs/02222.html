<html>
<head>
<title>How To Create a Web App for Coding Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建用于编码测试的Web应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-web-app-for-coding-tests-750ef97bf1e3?source=collection_archive---------6-----------------------#2019-11-14">https://betterprogramming.pub/how-to-create-a-web-app-for-coding-tests-750ef97bf1e3?source=collection_archive---------6-----------------------#2019-11-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="112a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何用Node.js构建你自己的编码测试平台</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/92767cd308602c768d824c4b7284f392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OCDKFF1ScjIKM3PyPF_PmA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">黑客排名测试中候选人解决方案的示例结果。资料来源:hackerrank.com</p></figure><p id="463c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如今，越来越多的公司在招聘软件开发人员时使用编码测试。像<a class="ae lu" href="https://www.hackerrank.com" rel="noopener ugc nofollow" target="_blank"> HackerRank </a>、<a class="ae lu" href="https://www.codility.com/" rel="noopener ugc nofollow" target="_blank">codi ty</a>等网站。帮助公司管理这些测试，并根据他们的代码在一些测试案例中的表现给候选人打分。</p><p id="f732" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将描述如何构建一个简单的web应用程序来管理编码测试。web应用程序将向用户提出一个问题，允许用户提交他们的解决方案，在一些预定义的测试用例上运行解决方案，并向用户显示结果。</p><p id="8c10" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用Express.js作为web后端，而Python将是提交解决方案的语言。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6b1f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">搭建舞台</h1><p id="9a53" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们将从创建用户界面开始，它将由一个问题区域和一个编码区域组成。</p><p id="e99d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我们将首先为每个区域创建两个div元素。然后，我们将设计它们的样式:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="18ef" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">&lt;div class="question"&gt;</strong><br/>  &lt;h2&gt;&lt;strong&gt;QUESTION&lt;/strong&gt;&lt;/h2&gt;<br/>  &lt;span id="questionText"&gt;&lt;/span&gt;<br/>&lt;/div&gt;</span><span id="1302" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">&lt;div class="code-area"&gt;</strong><br/>  &lt;textarea rows="20" autofocus&gt;def solution(arr):&lt;/textarea&gt;<br/>&lt;/div&gt;</span></pre><p id="53ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们设计两个div的样式:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="25ad" class="ne md it na b gy nf ng l nh ni">.question, .code-area {<br/>  padding: 25px;<br/>  <strong class="na iu">display: table-cell;</strong><br/>  width: 50%;<br/>}</span><span id="246a" class="ne md it na b gy nj ng l nh ni">.question {<br/>  text-align: left;<br/>  position: absolute;<br/>  top: 0vh;<br/>}</span><span id="4709" class="ne md it na b gy nj ng l nh ni">.code-area {<br/>  border-left: 2px solid navy;<br/>}</span></pre><p id="2b85" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的CSS中，我们制作了两个div的表格单元格(这样它们可以并排)。我们需要一张桌子来容纳它们。我们将为此创建一个包含div:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bf74" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">&lt;div class="container"&gt;</strong><br/>  &lt;div class="question"&gt;<br/>    ...<br/>  &lt;/div&gt;<br/>  &lt;div class="code-area"&gt;<br/>    ...<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="00f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们会设计它的样式:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f3ba" class="ne md it na b gy nf ng l nh ni">.container {<br/>  <strong class="na iu">display: table;</strong><br/>  height: 95vh;<br/>  width: 95vw;<br/>}</span></pre><p id="d2aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还将为<code class="fe nk nl nm na b">body</code>元素添加一些样式来改变背景颜色和字体:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ba6b" class="ne md it na b gy nf ng l nh ni">body {<br/>  background-color: aliceblue;<br/>  text-align: center;<br/>  font-size: 16pt;<br/>  font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;<br/>}</span></pre><p id="5a20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之前，我们创建了一个默认文本为<code class="fe nk nl nm na b">def solution(arr):</code>的<code class="fe nk nl nm na b">textarea</code>元素。让我们给这个<code class="fe nk nl nm na b">textarea</code>一个类和ID:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="12f4" class="ne md it na b gy nf ng l nh ni">&lt;textarea rows="20" <strong class="na iu">class="input" id="code"</strong> autofocus&gt;def solution(arr):&lt;/textarea&gt;</span></pre><p id="3a37" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们也为运行测试创建一个<code class="fe nk nl nm na b">button</code>元素，为结果创建一个<code class="fe nk nl nm na b">span</code>元素:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="73f0" class="ne md it na b gy nf ng l nh ni">...<br/>&lt;textarea rows="20" class="input" id="code" autofocus&gt;def solution(arr):&lt;/textarea&gt;<br/>&lt;br/&gt;&lt;br/&gt;<br/><strong class="na iu">&lt;button&gt;RUN TESTS&lt;/button&gt;</strong><br/>&lt;br/&gt;&lt;br/&gt;<br/><strong class="na iu">&lt;span id="results"&gt;&lt;/span&gt;</strong><br/>...</span></pre><p id="703b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们给元素添加一些样式:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d523" class="ne md it na b gy nf ng l nh ni">.input, #results {<br/>  height: 60%;<br/>}</span><span id="a991" class="ne md it na b gy nj ng l nh ni">.input {<br/>  border: 1px solid gray;<br/>  width: 90%;<br/>  font-family: monospace;<br/>  font-size: 12pt;<br/>  padding: 10px;<br/>}</span><span id="59de" class="ne md it na b gy nj ng l nh ni">button {<br/>  width: 150px;<br/>  height: 50px;<br/>  cursor: pointer;<br/>  background-color: lightgreen;<br/>  color: white;<br/>  font-weight: bolder;<br/>}</span></pre><p id="fc34" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就结束了我们在用户界面设计上的工作。网页现在看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/3f12dbc92734ec105ad10c5223e2141d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PzCXJGLfH9iHxWxg1jo_wg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用户界面</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8997" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">准备后端</h1><p id="db6c" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在web应用程序的另一端，我们将从导入所需的库开始:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2810" class="ne md it na b gy nf ng l nh ni">const bodyParser = require(<strong class="na iu">'body-parser'</strong>);<br/>const cors = require(<strong class="na iu">'cors'</strong>);<br/>const execSync = require(<strong class="na iu">'child_process'</strong>).execSync;<br/>const express = require(<strong class="na iu">'express'</strong>);<br/>const fs = require(<strong class="na iu">'fs'</strong>);<br/>const path = require(<strong class="na iu">'path'</strong>);</span></pre><p id="622e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要:</p><ul class=""><li id="e754" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated"><code class="fe nk nl nm na b">body-parser</code>帮助我们处理帖子请求</li><li id="3fe8" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe nk nl nm na b">cors</code>对于跨来源请求</li><li id="18ac" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe nk nl nm na b">child_process</code>、<code class="fe nk nl nm na b">fs</code>和<code class="fe nk nl nm na b">path</code>用于执行用户的代码解决方案</li><li id="f317" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe nk nl nm na b">express</code>，很明显。</li></ul><p id="17a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们将创建一个Express应用程序，并将其设置为使用我们需要的依赖项:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e552" class="ne md it na b gy nf ng l nh ni">const app = express();<br/>app.use(cors());<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span></pre><p id="1450" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们将设置端点，并让应用程序监听端口5000:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="24d4" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">function testCode(req, res)</strong> {<br/>  return res.send("Success");<br/>}</span><span id="9fb7" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">app.get('/', (req, res)</strong> =&gt; {<br/>  res.send("Hello world");<br/>});</span><span id="063c" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">app.post('/test/', testCode);</strong></span><span id="4874" class="ne md it na b gy nj ng l nh ni">app.listen(5000, () =&gt;<br/>  console.log(`Listening on port 5000.`),<br/>);</span></pre><p id="0bdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们上面有两个端点:</p><ul class=""><li id="b9ac" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated"><code class="fe nk nl nm na b">/</code>:用于服务前端页面和</li><li id="7688" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe nk nl nm na b">/test/</code>:用于测试用户的代码。</li></ul><p id="543d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当被访问时,<code class="fe nk nl nm na b">/test/</code>端点调用函数<code class="fe nk nl nm na b">testCode</code>。该函数将用户代码写入Python文件，然后运行另一个Python脚本来测试代码:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7f28" class="ne md it na b gy nf ng l nh ni">...</span><span id="9687" class="ne md it na b gy nj ng l nh ni">const CODE_FOLDER = "code";</span><span id="cb04" class="ne md it na b gy nj ng l nh ni">function testCode(req, res) {<br/>  let code = <strong class="na iu">req.body["code"]</strong>;<br/>  try {<br/>    <strong class="na iu">fs.writeFileSync(path.join(__dirname, CODE_FOLDER, "input_code.py"), code);</strong><br/>    <strong class="na iu">const proc = execSync("python3 " + path.join(CODE_FOLDER, "tests.py"));</strong><br/>    const results = proc.toString();<br/>    <br/>    return res.send(results);<br/>  } catch (error) {<br/>    console.log("An error occurred");<br/>    console.log(error);<br/>    return res.send("An error occurred.");<br/>  }<br/>}</span></pre><p id="450e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，用户输入的代码——将作为名为<code class="fe nk nl nm na b">code</code>的请求参数从前端发送——将被保存到名为<code class="fe nk nl nm na b">input_code.py</code>的文件中，然后Python脚本<code class="fe nk nl nm na b">tests.py</code>将使用节点的<code class="fe nk nl nm na b">execSync</code>函数执行(该函数执行控制台命令，等待其输出，然后返回)。然后，脚本的输出将被发送到前端。</p><p id="7189" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是<code class="fe nk nl nm na b">tests.py</code>脚本包含的内容:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d091" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">from input_code import solution</strong></span><span id="934f" class="ne md it na b gy nj ng l nh ni">def <strong class="na iu">get_test_cases()</strong>:<br/>  pass</span><span id="fd46" class="ne md it na b gy nj ng l nh ni">def <strong class="na iu">get_expected_outputs()</strong>:<br/>  pass</span><span id="8732" class="ne md it na b gy nj ng l nh ni">def <strong class="na iu">test_code()</strong>:<br/>  pass</span><span id="e341" class="ne md it na b gy nj ng l nh ni">if __name__ == '__main__':<br/>  test_code()</span></pre><p id="9c00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它包含三个功能:</p><ul class=""><li id="b0e0" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated"><code class="fe nk nl nm na b">get_test_cases()</code>:获取运行用户代码的测试用例</li><li id="61e4" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe nk nl nm na b">get_expected_outputs()</code>:获取每个测试用例的预期输出</li><li id="e33f" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe nk nl nm na b">test_code()</code>:根据测试用例测试用户的解决方案</li></ul><p id="3cb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们填充这些函数:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1cb8" class="ne md it na b gy nf ng l nh ni">def get_test_cases():<br/>  return {<br/>    <strong class="na iu">"SMALL_INPUT"</strong>: [1, 2, 3],<br/>    <strong class="na iu">"LARGE_INPUT"</strong>: [1, 2, 3] * 1000 + [4],<br/>  }</span><span id="89ce" class="ne md it na b gy nj ng l nh ni">def get_expected_outputs():<br/>  return {<br/>    <strong class="na iu">"SMALL_INPUT"</strong>: 3,<br/>    <strong class="na iu">"LARGE_INPUT"</strong>: 4,<br/>  }</span></pre><p id="b625" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前两个函数为我们提供了一些样本测试用例的输入和输出。他们也标记测试用例<code class="fe nk nl nm na b">“SMALL_INPUT”</code>和<code class="fe nk nl nm na b">“LARGE_INPUT”</code>用于识别。</p><p id="7762" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们在第三个函数中使用它们来测试用户代码:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8ccc" class="ne md it na b gy nf ng l nh ni">def test_code():<br/>  test_cases = get_test_cases()<br/>  expected = get_expected_outputs()<br/>  test_cases_count = len(test_cases)<br/>  passed_test_cases = 0<br/>  failed_test_cases = []<br/>  <br/>  for label in test_cases.keys():<br/>    code_result = <strong class="na iu">solution(test_cases[label])</strong><br/>    if code_result == expected[label]:<br/>      passed_test_cases += 1<br/>    else:<br/>      failed_test_cases.append(label)<br/>  <br/>  print("Passed", passed_test_cases, "out of", test_cases_count, "test cases.")<br/>  <br/>  if len(failed_test_cases) &gt; 0:<br/>    print("Test cases not passed:", ", ".join(failed_test_cases))</span></pre><p id="fff4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用上面的代码，我们遍历每个测试用例，在测试用例输入上调用用户的解决方案，并将用户的结果与预期的结果进行比较。</p><p id="ee89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果结果相同，我们将通过的测试用例数加1；否则，我们将失败测试用例的标签添加到一个数组中。</p><p id="6e7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们打印通过的测试用例的数量，如果有失败的，我们打印它们的标签。注意，用户代码必须包含一个名为<code class="fe nk nl nm na b">solution()</code>的函数，它将通过一个数组传递给每个测试用例，并且必须返回一个数字。</p><p id="f5ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，后端就完成了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f755" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">连接两端</h1><p id="ca73" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们的下一个任务是连接前端和后端。</p><p id="3802" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我们将创建一个JavaScript函数，每当用户单击<code class="fe nk nl nm na b">RUN TESTS</code>按钮时都会调用该函数。这个函数会将用户的代码发送到后端，并显示用户的结果。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f22d" class="ne md it na b gy nf ng l nh ni">&lt;script&gt;<br/>  function runTests() {<br/>    document.getElementById("results").innerHTML = "Running...";<br/>    <strong class="na iu">const code = document.getElementById("code").value;</strong><br/>    let xhr = new XMLHttpRequest();<br/>  <br/>    xhr.onreadystatechange = () =&gt; {<br/>      if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {<br/>        <strong class="na iu">document.getElementById("results").innerHTML = xhr.responseText;</strong><br/>      }<br/>    }</span><span id="d0c3" class="ne md it na b gy nj ng l nh ni">    <strong class="na iu">xhr.open("POST", "http://localhost:5000/test/");</strong><br/>    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");<br/>    <strong class="na iu">xhr.send("code=" + code);</strong><br/>  }<br/>&lt;/script&gt;</span></pre><p id="d6a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该函数首先从ID为<code class="fe nk nl nm na b">code</code>的<code class="fe nk nl nm na b">textarea</code>获取用户代码，然后使用<a class="ae lu" href="https://en.wikipedia.org/wiki/Ajax_(programming)" rel="noopener ugc nofollow" target="_blank"> AJAX </a>向后端的<code class="fe nk nl nm na b">/test/</code>端点发送请求。然后，当它收到响应时，它将结果设置在ID为<code class="fe nk nl nm na b">results</code>的<code class="fe nk nl nm na b">span</code>中。</p><p id="e44c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们将这个事件处理程序添加到<code class="fe nk nl nm na b">RUN TESTS</code>按钮:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7e85" class="ne md it na b gy nf ng l nh ni">&lt;button <strong class="na iu">onclick="runTests()"</strong>&gt;RUN TESTS&lt;/button&gt;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="137a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">测试应用程序</h1><p id="8328" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">为了测试web应用程序，让我们向问题区域添加一个简单的问题:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e558" class="ne md it na b gy nf ng l nh ni">&lt;div class="question"&gt;<br/>  &lt;h2&gt;&lt;strong&gt;QUESTION&lt;/strong&gt;&lt;/h2&gt;<br/>  Find the maximum number in an array of integers.<br/>  &lt;br/&gt; For example, in the array [1, -3, 5], the maximum number is 5.<br/>&lt;/div&gt;</span></pre><p id="c66e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个问题只是要求用户找出数组中最大的数字。这里有一个解决问题的方法:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7e94" class="ne md it na b gy nf ng l nh ni">def solution(arr):<br/>  maximum = arr[0]</span><span id="ac21" class="ne md it na b gy nj ng l nh ni">  return maximum</span></pre><p id="a421" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解决方案返回数组中的第一个元素(这显然是错误的)。点击<code class="fe nk nl nm na b">RUN TESTS</code>按钮，我们会看到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/6cd8cad7df2a0aaa17d4bca83d8d3c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6AmC5MNM1cQpdV6iCm1bcw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用错误的解决方案进行测试</p></figure><p id="2686" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">测试结果告诉我们这个解决方案是错误的，因为它没有通过任何测试。它还说明了测试用例的名称未能帮助用户适当地调整他们的代码。</p><p id="1c09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们用下面的代码试一试:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5a9c" class="ne md it na b gy nf ng l nh ni">def solution(arr):<br/>  maximum = 0<br/>  <br/>  for elem in arr:<br/>    if elem &gt; maximum:<br/>      maximum = elem</span><span id="f26d" class="ne md it na b gy nj ng l nh ni">  return maximum</span></pre><p id="eefc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该解决方案遍历数组，通过将每个元素与先前已知的最大元素进行比较来检查哪个项目最大。这更可能是一个正确的解决方案，但让我们测试一下以确认:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/fd069142be4e2ff3d94a28998f8e4ec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sT9XSX_HBLjYTzimNtYTSA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用正确的解决方案进行测试</p></figure><p id="f7a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码通过了两个测试案例！我们的编码测试web应用程序像预期的那样工作。</p><p id="997b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">谢谢你跟了这么远。您可以在<a class="ae lu" href="https://github.com/eshiofune/100-days-of-code/tree/master/js/CodeTest" rel="noopener ugc nofollow" target="_blank"> my GitHub repository </a>中找到web应用程序的完整代码。</p></div></div>    
</body>
</html>