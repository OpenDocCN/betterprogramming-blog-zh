<html>
<head>
<title>Velocity Limit With Rust — Performance Matters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生锈时的速度限制—性能至关重要</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/velocity-limit-with-rust-performance-matters-9345763ec2d6?source=collection_archive---------6-----------------------#2022-05-01">https://betterprogramming.pub/velocity-limit-with-rust-performance-matters-9345763ec2d6?source=collection_archive---------6-----------------------#2022-05-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3520" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这个周末让我们用Rust重建速度极限</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ece824edea98a29dd73c7c374bab334b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pu7coD-3MHYSA2J3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ghuffmanphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔治·霍夫曼</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="91bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上次，我分享了一些关于卓越运营的想法和经验<a class="ae ky" href="https://medium.com/geekculture/five-tips-to-start-your-i-t-operational-excellence-journey-9b238d21652b" rel="noopener">。让我们本周回到一些用例编码上来。</a></p><p id="01ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">三年前的2019年，<a class="ae ky" href="https://levelup.gitconnected.com/build-a-finance-velocity-limits-real-time-data-process-pipeline-in-go-with-gcp-stacks-558081f6ba8c" rel="noopener ugc nofollow" target="_blank">我用Golang建立了一个管道</a>来处理带有一些具有速度限制能力的事务数据的文件。</p><p id="996d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本周我们将用铁锈制作它。首先，让我们回忆一下“<strong class="lb iu">速度极限。</strong></p><p id="6890" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在金融领域，账户通常有所谓的<strong class="lb iu">“速度限制”、</strong>来接受或拒绝交易，以便将资金存入客户账户。</p><h2 id="0b65" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">功能需求</h2><ol class=""><li id="3756" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">每个传入的数据都是一个简单的JSON有效负载，如下所示:</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文件示例—按作者</p></figure><p id="7dae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.每个客户都有三个限制:</p><ul class=""><li id="5063" class="mo mp it lb b lc ld lf lg li nb lm nc lq nd lu ne mw mx my bi translated">每天最多可以加载$ 100(例如$500.00)</li><li id="82b8" class="mo mp it lb b lc nf lf ng li nh lm ni lq nj lu ne mw mx my bi translated">每周最多可加载$ 1000元(例如$20000.00)</li><li id="5acf" class="mo mp it lb b lc nf lf ng li nh lm ni lq nj lu ne mw mx my bi translated">无论数量多少，每天都可以执行最大装载次数。(例如，5)</li></ul><p id="158d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个用户试图在一天内加载1000美元两次，第二次会被拒绝，一个用户试图在一天内加载500美元四次也会被拒绝。</p><p id="28d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.如果对于一个特定的用户id，一个事务ID被观察了不止一次，我们将只计算列表中第一个出现的ID。</p><p id="1e20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.对于每笔交易，我们将返回一个JSON响应，指示交易是否根据用户的活动被接受，其结构如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文件输出—按作者</p></figure><p id="1cb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们将更多地关注代码和逻辑演练，我们可能不会涉及一些实现细节，如错误处理、日志记录、警报等。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="9d3d" class="nr lw it bd lx ns nt nu ma nv nw nx md jz ny ka mg kc nz kd mj kf oa kg mm ob bi translated">让我们编码</h1><p id="2247" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">编码就像讲故事一样。今天的主角是<code class="fe of og oh oi b">Transaction</code>。基于文件结构，让我们定义一下<code class="fe of og oh oi b">Transaction</code>的样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">事务结构—按作者</p></figure><p id="2a9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你从功能需求中看到的，在这个过程中需要保持跟踪记录。所以我们需要一些散列表来满足需求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">跟踪和输出结构—按作者</p></figure><p id="a06e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要确保我们的代码库可以基于当前需求或未来需求进行扩展，处理这一点的最佳方式是让事务维护其逻辑，并且它可以通过其orchestrator进行调用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/3054f29f8da9e5f94b6e7ebfadbdbb51.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*ZHpxOYuzjyr3z9d_20zUVw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">事务UML项目—按作者</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">事务操作实现—按作者</p></figure><p id="61be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">这里的重要提示</strong>:如果你仔细阅读代码，在运行期间跟踪速度和有效限制的关键是使用hashmap，特别是当我们跟踪每周交易时，我们只需要获得一年中周数的唯一字符串，并将其作为唯一的引用键。</p><p id="f548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们已经实现了<code class="fe of og oh oi b">Transaction</code>。让我们从定义一个工人开始。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/c0062510e6b10b179a03ab065fa94594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*npMdGuT0eZr69esOZHEVIw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生锈速度限制工人-作者</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工人实现—按作者</p></figure><p id="0d50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把它组装起来，然后运行它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生锈速度极限主要—作者</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">货物运行-发布-按作者</p></figure><p id="4c5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是等一下。如果你记得我们三年前的Golang实现(链接更早)，执行时间是~ 5毫秒。</p><p id="e24e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们进行一些性能比较。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无缓冲长凳运行——作者</p></figure><p id="c15f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发生了什么事？在范围运行中，Go几乎比Rust实现快50 %。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="200c" class="nr lw it bd lx ns nt nu ma nv nw nx md jz ny ka mg kc nz kd mj kf oa kg mm ob bi translated">性能调整</h1><p id="716f" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">首先，不要误解我，我喜欢Golang，我已经用Golang编码很长时间了，我喜欢Golang的简单性和其他伟大的特性。但是，我们不应该在Golang和Rust之间看到如此巨大的性能差距。</p><p id="0443" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们一定漏掉了什么。但是，你可能觉得还是快。为什么你还固执于那些~3毫秒。</p><p id="d3ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">性能至关重要，尤其是在云环境中，从规模、基础架构成本以及我们的客户期望来看，毫秒数非常重要。</p><p id="3c7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了找出问题所在，在运行我们的仪器之前，让我们后退一步，重新思考该应用程序的主要活动，以及哪些步骤可能会影响性能，看看我们是否可以缩小一些关注方向。</p><p id="822c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在worker实现中，您可以看到有三个主要任务，</p><ol class=""><li id="d4df" class="mo mp it lb b lc ld lf lg li nb lm nc lq nd lu mv mw mx my bi translated">读取文件。</li><li id="54a5" class="mo mp it lb b lc nf lf ng li nh lm ni lq nj lu mv mw mx my bi translated">用事务实现处理文件。</li><li id="feec" class="mo mp it lb b lc nf lf ng li nh lm ni lq nj lu mv mw mx my bi translated">写文件。</li></ol><p id="f8bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">读取和写入都大量涉及系统调用，并且系统调用是昂贵的。</p><p id="e296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Golang和Rust是很棒的低级语言；但是，它们处理I/O读写的方式不同。Golang的<code class="fe of og oh oi b">io.writer</code>接口默认是缓冲的。另一方面，Rust在没有缓冲的文件上读写。</p><p id="729b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，我们试试看。</p><ol class=""><li id="b7de" class="mo mp it lb b lc ld lf lg li nb lm nc lq nd lu mv mw mx my bi translated">在<code class="fe of og oh oi b">load_transaction</code>功能中，我们使用的是<code class="fe of og oh oi b">BufReader::new(file)</code> <em class="ol">。</em>哪个应该好。</li><li id="b72d" class="mo mp it lb b lc nf lf ng li nh lm ni lq nj lu mv mw mx my bi translated">在<code class="fe of og oh oi b">file_writer</code>里。让我们添加这一行代码。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">bufwriter —按作者</p></figure><p id="427a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次基准测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">缓冲长凳—作者，</p></figure><p id="76f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到结果是有希望的。Rust回到游戏的速度比Golang快3毫秒。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="d84a" class="nr lw it bd lx ns nt nu ma nv nw nx md jz ny ka mg kc nz kd mj kf oa kg mm ob bi translated">最后的话</h1><p id="8821" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">我们了解到:</p><ol class=""><li id="bc08" class="mo mp it lb b lc ld lf lg li nb lm nc lq nd lu mv mw mx my bi translated">如何在Rust中实现“速度极限”用例？</li><li id="f1bf" class="mo mp it lb b lc nf lf ng li nh lm ni lq nj lu mv mw mx my bi translated">我们还会查看性能比较，以及当我们需要深入研究性能挑战时应该如何思考。</li><li id="ceba" class="mo mp it lb b lc nf lf ng li nh lm ni lq nj lu mv mw mx my bi translated">同样，性能基准测试是必不可少的，尤其是因为我们处于云的原生世界中。</li><li id="4264" class="mo mp it lb b lc nf lf ng li nh lm ni lq nj lu mv mw mx my bi translated">以适当的心态追踪绩效并不顽固。:)</li></ol><p id="c0b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>