<html>
<head>
<title>Rollup vs. Parcel vs. webpack: Which Is the Best Bundler?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rollup vs. Parcel vs. webpack:哪个是最好的捆扎机？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-battle-of-bundlers-6333a4e3eda9?source=collection_archive---------0-----------------------#2019-11-25">https://betterprogramming.pub/the-battle-of-bundlers-6333a4e3eda9?source=collection_archive---------0-----------------------#2019-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6d21" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">邦德勒之战</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a7c2d78b20efc36ef152e1b0bdc50332.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i5qsV34DtRQkikbMqzWQ4g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卷装vs .包裹vs .网袋:谁是捆扎机的最佳选择？</p></figure><p id="998b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最近，我向npm发布了一个库，我想用我将要打包的代码的bundler进行试验。虽然<a class="ae lu" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>一直是我的标准选择，但我决定让它与另外两个流行的捆扎机— <a class="ae lu" href="https://rollupjs.org/guide/en/" rel="noopener ugc nofollow" target="_blank"> Rollup </a>和<a class="ae lu" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank"> Parcel </a>竞争。</p><p id="52ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于那些来自非JavaScript背景的人来说，bundler是一个工具，它递归地跟踪来自应用程序入口点的所有导入，并将它们打包成一个文件。打包程序还可以通过删除不必要的空白、新行、注释和块分隔符来缩小文件，而不会影响它们的功能。</p><p id="227d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们通过一个简单的代码片段来理解这一点:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="057c" class="ma mb it lw b gy mc md l me mf">var test = [];<br/>for (var i = 0; i &lt; 100; i++) {<br/>  test[i] = i;<br/>}</span></pre><p id="a60a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们刚刚创建了一个名为test的数组，并将它的成员初始化到100。该代码的简化版本看起来有点像这样:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="887b" class="ma mb it lw b gy mc md l me mf">for(var a=[i=0];++i&lt;20;a[i]=i);</span></pre><p id="16f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更少的字符和行数。你可能会说代码不可读，但是谁在乎呢？一旦你的代码准备好了，你就把它打包，精简的代码很容易被浏览器获取和解释。</p><p id="0f81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在你一定很容易猜到捆绑器的重要性，对吗？</p><p id="b5c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设您的代码没有作为多个文件的包捆绑和托管在服务器上。为了导入这些文件以运行代码，浏览器必须向服务器发送一个单独的HTTP请求。这种传输的效率与被请求文件的数量和大小成正比。对于像脸书这样的大型应用程序，这可能会导致灾难性的性能和UX。</p><p id="e342" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，随着bundler的加入，应用程序的性能大大提高，因为现在浏览器只需请求一个文件就可以向用户显示您的应用程序。此外，获取一个几千字节重的缩小文件比实际文件更快，实际文件可能会达到几兆字节，从而缩短了应用程序的加载时间。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="7f0a" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">既然我们可以自己动手，为什么还要安装捆扎机？</h1><p id="012c" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">当然可以，但是当处理大型代码库时，手动缩小应用程序不是一个可扩展的解决方案。让捆绑者为你做它！</p><p id="fe13" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据使用情况，从众多可用的捆绑器中做出正确的选择可能会改变您的应用程序的命运。回到我在开始时谈到的实验:我想与你分享我的发现，关于webpack、Rollup和package如何满足开发人员的一些重要需求。</p><h2 id="a340" class="ma mb it bd mo nj nk dn ms nl nm dp mw lh nn no my ll np nq na lp nr ns nc nt bi translated"><strong class="ak">捆扎机的配置</strong></h2><p id="c909" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated"><strong class="la iu">package在这里胜出</strong>，因为它根本不需要配置文件。只需安装package并运行package build，它将为您做开箱即用的一切。</p><p id="6feb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">webpack和Rollup都需要一个配置文件<strong class="la iu"> </strong>来指定条目、输出、加载器、插件、转换等。然而，有一点小小的不同:</p><ul class=""><li id="6e16" class="nu nv it la b lb lc le lf lh nw ll nx lp ny lt nz oa ob oc bi translated">Rollup具有用于导入/导出的节点聚合填充，但webpack没有。</li><li id="bfc8" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">Rollup支持config中的相对路径，但webpack不支持——这就是为什么您使用<code class="fe oi oj ok lw b">path.resolve</code>或<code class="fe oi oj ok lw b">path.join</code>。</li></ul><p id="4891" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">webpack配置可能会变得复杂，但是它提供了对第三方导入、图像、CSS预处理程序等等的广泛支持。</p><p id="33e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我很难使用Rollup来捆绑我的应用程序，该应用程序使用了<a class="ae lu" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>，这是一个非常常用的HTTP请求库——不仅仅是axios，其他第三方集成也是如此。在取得胜利之前，我不得不做了大量的研究，并尝试安装了许多插件——代价是放弃了一些导入。</p><h2 id="4c4f" class="ma mb it bd mo nj nk dn ms nl nm dp mw lh nn no my ll np nq na lp nr ns nc nt bi translated"><strong class="ak">死码消除</strong></h2><p id="c99d" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">死代码消除，或者通常所说的<em class="ol">树抖动</em>，对于实现最佳的包大小和应用性能非常重要。</p><p id="2813" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，包裹成了赢家。Parcel支持ES6和CommonJS模块的树摇动。这是革命性的，因为npm上的库中大多数代码仍然使用<a class="ae lu" href="https://www.npmjs.com/search?q=commonjs" rel="noopener ugc nofollow" target="_blank"> CommonJS </a>。</p><p id="7f8e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大部分工作包在树抖动时完成，也是通过使用大量工作进程的多核处理并行完成的，并且也缓存在文件系统上。这意味着构建仍然很快，重建也快得惊人。</p><p id="7892" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在比赛中，罗博获得第二名。开箱即用，它静态地分析您正在导入的代码，并将排除任何实际上没有使用的代码。这可以让你避免在配置中写入更多的行，增加额外的依赖和增加应用程序的大小。</p><p id="f154" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">webpack需要一些手动操作来实现树抖动:</p><ul class=""><li id="98ea" class="nu nv it la b lb lc le lf lh nw ll nx lp ny lt nz oa ob oc bi translated">使用ES6语法(即<code class="fe oi oj ok lw b">import</code>和<code class="fe oi oj ok lw b">export</code>)。</li><li id="1494" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">在您的<code class="fe oi oj ok lw b">package.json</code>中设置<code class="fe oi oj ok lw b">SideEffects</code>标志。</li><li id="bcfa" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">包括一个支持死代码移除的minifier(例如:<code class="fe oi oj ok lw b">UglifyJSPlugin</code>)。</li></ul><p id="d70f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Rollup和webpack更关注ES6的树抖动，因为它更容易进行静态分析，但为了真正产生重大影响，我们还需要分析CommonJS依赖关系，为此它们都需要导入插件。</p><p id="9c8c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，鉴于JavaScript是动态的这一事实，该语言中的几乎每一个结构都可能在运行时以无法预测的方式被改变。</p><p id="ef84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际上，这意味着作为一个引用导入的实体(如类)不能被静态分析来删除不使用的成员(静态和实例)。因此，与其过度依赖捆绑器来帮你做这件事，不如在你编码之前可视化你的组件，然后分析它们以获得最佳结果。</p><h2 id="dbd5" class="ma mb it bd mo nj nk dn ms nl nm dp mw lh nn no my ll np nq na lp nr ns nc nt bi translated"><strong class="ak">代码拆分</strong></h2><p id="8758" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">随着应用的增长，你的捆绑包大小也会增长，尤其是第三方导入。你的应用程序的加载时间与其包的大小成正比。</p><p id="1fa4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码分割帮助浏览器<em class="ol">延迟加载</em>应用程序运行所需的东西，显著提高性能和UX。</p><p id="c150" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> webpack在这方面胜出</strong>，工作量最小，加载时间更快。它提供了三种方法来启用webpack中可用的代码拆分:</p><ul class=""><li id="5f32" class="nu nv it la b lb lc le lf lh nw ll nx lp ny lt nz oa ob oc bi translated"><strong class="la iu">定义入口点</strong> —使用<code class="fe oi oj ok lw b"><a class="ae lu" href="https://webpack.js.org/configuration/entry-context" rel="noopener ugc nofollow" target="_blank">entry</a></code>配置手动分割代码。</li><li id="c399" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated"><strong class="la iu">使用</strong> <code class="fe oi oj ok lw b"><a class="ae lu" href="https://webpack.js.org/plugins/commons-chunk-plugin" rel="noopener ugc nofollow" target="_blank">CommonsChunkPlugin</a></code>对数据块进行重复数据删除和拆分。</li><li id="640b" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated"><strong class="la iu">动态</strong> i <strong class="la iu">导入</strong> —在模块内使用内联函数调用。</li></ul><p id="97bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在通过Rollup进行代码拆分的过程中，您的代码拆分块本身是标准的es模块，它们使用浏览器的内置模块加载器，没有任何额外的开销，同时仍然可以获得Rollup的树摇动特性的全部好处。对于还不支持ES模块的浏览器，你也可以使用<code class="fe oi oj ok lw b">SystemJS</code>或者任何AMD loader。它是完全自动化的，结果是零代码重复。</p><p id="62c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">宗地支持零配置代码分割。在这里，代码拆分是通过使用动态<code class="fe oi oj ok lw b">import()</code> <a class="ae lu" href="https://github.com/tc39/proposal-dynamic-import" rel="noopener ugc nofollow" target="_blank">函数语法建议</a>来控制的，它的工作方式类似于普通的<code class="fe oi oj ok lw b">import</code>语句或<code class="fe oi oj ok lw b">require</code>函数，但返回的是<code class="fe oi oj ok lw b">Promise</code>。这意味着模块是异步加载的。</p><p id="5969" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于代码分割来说，Rollup和package比webpack更受欢迎，但是它们都是最近才引入这个特性的，并且也报告了一些问题。所以坚持使用老的网络包是安全的。</p><p id="5e83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我注意到的一个引人注目的事实是，对于启用了代码拆分的相同代码，使用webpack的构建时间最少，其次是Rollup，最后是package。</p><h2 id="f95d" class="ma mb it bd mo nj nk dn ms nl nm dp mw lh nn no my ll np nq na lp nr ns nc nt bi translated">实时重装</h2><p id="4231" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">在开发过程中，如果你的应用程序用你写的新代码更新，而不是手动刷新来查看变化，那就太好了。具有实时重新加载功能的捆扎机可以为您刷新。</p><p id="3eeb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了调试和开发所必需的其他实用程序之外，Bundlers还以开发服务器的形式为您提供了一个运行时环境。</p><p id="ce3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Parcel已经非常周到地内置了一个开发服务器，它会在您更改文件时自动重建您的应用程序。但是当使用HTTP日志、钩子和中间件时，会有一些相关的问题。</p><p id="9b7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在使用Rollup时，我们需要安装并配置<code class="fe oi oj ok lw b">rollup-plugin-serve</code>，它将为我们提供live reload功能。然而，它需要另一个插件<code class="fe oi oj ok lw b">rollup-plugin-livereload</code>才能工作。这意味着它不是一个独立的插件，需要额外的依赖才能运行。</p><p id="8e96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了webpack，你只需要添加一个名为<code class="fe oi oj ok lw b">webpack-dev-server</code>的插件，它提供了一个简单的开发服务器，默认情况下开启了实时重载功能。什么更好？在开发服务器启动并运行之后，您可以使用钩子做一些事情，添加中间件，还可以指定我们运行开发服务器时要服务的文件。<strong class="la iu">web pack的这种可定制性胜过了Rollup和package。</strong></p><h2 id="391a" class="ma mb it bd mo nj nk dn ms nl nm dp mw lh nn no my ll np nq na lp nr ns nc nt bi translated"><strong class="ak">热模块更换</strong></h2><p id="f36c" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">热模块替换(HMR)通过在运行时自动更新浏览器中的模块而无需刷新整个页面，从而改善了开发体验。当您对代码进行小的更改时，可以保留应用程序状态。</p><p id="b7d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能会问HMR和实弹有什么不同。</p><p id="d7fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当一个文件改变时，实时重新加载会重新加载整个应用程序。例如，如果你进入应用导航的第五层并保存了更改，实时重新加载会重新启动应用并将其加载回着陆/初始路线。</p><p id="e452" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，热重装仅刷新被改变的文件，同时仍然保持应用的状态。例如，如果你在应用导航的第五层保存了一个CSS修改，状态不会改变:你仍然在同一个页面上，但是新的样式是可见的。</p><p id="35b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">webpack有自己的网络服务器，称为<code class="fe oi oj ok lw b">webpack-dev-server</code>，通过它支持HMR。它可以在开发中作为一个实时重载的替代品。</p><p id="2289" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然package已经内置了对热模块替换的支持，但Rollup上个月发布了一个插件<code class="fe oi oj ok lw b">rollup-plugin-hotreload</code>来支持热重装。</p><p id="948a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于这一功能在roll up and package这样的捆绑器中相当新，<strong class="la iu">我仍然选择webpack作为安全的赌注</strong>，因为我不想在开发过程中遇到可避免的问题。</p><h2 id="0003" class="ma mb it bd mo nj nk dn ms nl nm dp mw lh nn no my ll np nq na lp nr ns nc nt bi translated">模块变压器</h2><p id="14ac" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">捆绑器通常只知道如何读取JS文件。变形金刚本质上是教师，他们教捆绑者如何处理JS以外的文件，并将它们添加到应用程序的依赖图和捆绑包中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/0e7d16f0029e1e49da1eb8aa829362cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*fQYPJhmQuHA93GWcChKBTw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于转换css模块的加载程序</p></figure><p id="f941" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，在上面的图片中，您可以看到一个webpack配置，在第13行到第15行之间有一个关于如何读取CSS的指令。它基本上是说，“嘿webpack，每当你遇到一个被解析为<code class="fe oi oj ok lw b">.css</code>的文件，使用上面导入的<code class="fe oi oj ok lw b">css-loader</code>来读取它并将其导出为一个字符串。”类似地，一个HTML加载器会告诉webpack如何读取它在你的应用中遇到的<code class="fe oi oj ok lw b">.html</code>文件，并将它们作为字符串导出到你的包中。</p><p id="fe39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Parcel非常巧妙地处理了转换过程。</strong>与Rollup和webpack不同，它们需要您指定要转换、安装和配置的文件类型，以及转换它们的插件，Parcel为许多常见的转换和transpilers提供了内置支持。</p><p id="7ded" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当package找到<code class="fe oi oj ok lw b">.babelrc</code>、<code class="fe oi oj ok lw b">.postcssrc</code>、<code class="fe oi oj ok lw b">.posthtml</code>等配置文件时，它会自动运行相应的转换器。在模块中。除了在<code class="fe oi oj ok lw b">.babelrc</code>中指定的任何转换，Parcel总是在所有模块上使用<a class="ae lu" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>将现代JavaScript编译成浏览器支持的形式。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="babd" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">简单地</h1><p id="a46b" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">以下是我实验发现的关键:</p><p id="c177" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">构建一个基本的应用程序，并希望它快速启动和运行？使用包裹。</p><p id="fdea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用最少的第三方导入构建一个库？使用汇总。</p><p id="a721" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">构建一个包含大量第三方集成的复杂应用？需要良好的代码分割、静态资产的使用和CommonJs依赖吗？使用webpack。</p><p id="222b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就个人而言，我将继续在我的项目中使用webpack。有人可能会说，在许多情况下，Parcel提供了内置配置，这可能会简化开发，但很难忽视webpack提供的广泛支持和可定制性。</p><p id="d9cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">归根结底，这是每个开发人员需要根据自己的需求做出的个人决定。这有点像开自动档汽车和手动档汽车的区别。有时你需要额外的控制，有时你不需要。</p></div></div>    
</body>
</html>