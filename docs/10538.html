<html>
<head>
<title>I Wrote a Node.js Framework to Create Cloud-native Microservices for Kubernetes in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我用TypeScript编写了一个Node.js框架来为Kubernetes创建云原生微服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/i-wrote-a-node-js-framework-to-create-cloud-native-microservices-for-kubernetes-in-typescript-a2b31b16f152?source=collection_archive---------10-----------------------#2022-01-13">https://betterprogramming.pub/i-wrote-a-node-js-framework-to-create-cloud-native-microservices-for-kubernetes-in-typescript-a2b31b16f152?source=collection_archive---------10-----------------------#2022-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="74ea" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">采用Node.js和TypeScript的安全第一云原生微服务</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8c8ea13a366187b428b45257516edcfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vD3i8KvyRqo_JVEq7RtjAg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@killerfvith" rel="noopener ugc nofollow" target="_blank">亚历克斯·王</a>在<a class="ae kv" href="http://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="63cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">📕看看我的新书</strong> <a class="ae kv" href="https://www.amazon.com/Clean-Code-Principles-Patterns-Practitioners-ebook/dp/B0BSDJKYQJ/ref=sr_1_1?crid=8M0CMV4CP6UQ&amp;keywords=clean+code+principles&amp;qid=1674980636&amp;sprefix=clean+code+principle%2Caps%2C175&amp;sr=8-1" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">干净代码原则和模式:软件从业者手册</strong> </a>！</p><h1 id="7234" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">介绍</h1><p id="77d6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我将向您介绍一种使用Node.js和TypeScript构建微服务和API的全新方式。</p><p id="0129" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们都知道像REST、GraphQL和gRPC这样的技术，但现在游戏中有了一个新玩家，一个叫做<a class="ae kv" href="https://github.com/backk-node/backk" rel="noopener ugc nofollow" target="_blank"> <em class="mp"> Backk </em> </a> <em class="mp">的框架。</em></p><p id="1e61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">名称<em class="mp"> Backk </em>来源于Kubernetes 的<em class="mp">后端。这个新框架不需要您学习任何额外的技术，但是您可以简单地利用您现有的JavaScript(和TypeScript)知识。</em></p><p id="ba62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Backk框架中，您使用标准的JavaScript类和函数来定义您的微服务API端点。但是您需要使用TypeScript来为您的API端点参数和响应提供类型。如果您还没有太多的TypeScript经验，也不要担心。了解TypeScript的基础知识足以帮助你走得更远。</p><h1 id="2884" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">概念和架构</h1><p id="0bc9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Backk微服务是运行在<a class="ae kv" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>集群中的云原生微服务。微服务可以在一个或多个名称空间中运行。</p><p id="9e44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个微服务由一个或多个服务(JavaScript类)组成，服务本身由一个或多个服务函数(类方法)组成。</p><p id="203e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些服务及其功能构成了您的微服务的API。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/5c1e59684c16d3ffbd036071f4894351.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*kDTRzBPDn1mIz_RqaEAy-A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">巴克建筑</p></figure><p id="47df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果你的微服务有一个服务<code class="fe mr ms mt mu b">emailNotificationService</code>和一个函数<code class="fe mr ms mt mu b">sendEmail</code>，那么这个服务函数可以通过HTTP URL路径<code class="fe mr ms mt mu b">emailNotificationService.sendEmail</code>访问。</p><p id="e00e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的微服务被命名为<code class="fe mr ms mt mu b">notification-service</code>并安装在默认的Kubernetes名称空间中，您可以通过HTTP访问Kubernetes集群外部的服务功能，如下所示:<code class="fe mr ms mt mu b">https://&lt;kube-cluster-edge-fqdn&gt;/notification-service.default/emailNotificationService.sendEmail</code></p><p id="7330" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务函数可以有零个或一个JavaScript类类型的参数。服务函数返回值，可以是<code class="fe mr ms mt mu b">null</code>，一个可以转换成JSON或者error的JavaScript值。</p><p id="b6f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同步的，微服务可以通过HTTP访问。默认情况下，微服务中的每个服务功能都可以通过HTTP POST方法访问。但是可以配置使用HTTP GET方法访问的服务函数。</p><p id="bc05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">异步地，可以通过Kafka和/或Redis访问微服务。在Kafka的情况下，微服务从以微服务命名的主题中读取消息，消息键告诉服务函数执行，消息值是服务函数的参数。</p><p id="5e52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Redis的情况下，微服务使用以微服务命名的列表(作为队列),并从列表中弹出服务函数调用。</p><h1 id="aead" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">创建微服务</h1><p id="3f18" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们用一个简短的例子来展示如何创建一个Backk微服务并通过HTTP访问它。</p><p id="b5c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例微服务由一个服务<code class="fe mr ms mt mu b">SalesItemService</code>组成，该服务用于创建销售项目并获取所创建的销售项目。它使用MySQL数据库实现持久性。</p><p id="3d80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是服务<code class="fe mr ms mt mu b">SalesItemService</code>的界面，由两个服务功能:<code class="fe mr ms mt mu b">createSalesItem</code>和<code class="fe mr ms mt mu b">getSalesItems</code>组成:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">SalesItemService接口</p></figure><p id="c141" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是<code class="fe mr ms mt mu b">SalesItem</code>实体类，包含两个<em class="mp">读写</em>字段<code class="fe mr ms mt mu b">name</code>和<code class="fe mr ms mt mu b">price.</code>实体类必须用<code class="fe mr ms mt mu b">Entity()</code>标注，类的名称将是存储实体的数据库表的名称。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">SalesItem实体类</p></figure><p id="bf25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是<code class="fe mr ms mt mu b">SalesItemService</code>接口的实现类<code class="fe mr ms mt mu b">SalesItemServiceImpl</code>。<code class="fe mr ms mt mu b">createSalesItem</code>服务功能将在数据存储(在本例中为MySQL数据库)中保存销售项目实体。<code class="fe mr ms mt mu b">getSalesItems</code>服务功能从数据存储中提取所有销售项目。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">SalesItemService接口的实现类</p></figure><p id="af2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后是实际的微服务实现类<code class="fe mr ms mt mu b">MicroserviceImpl</code>。在微服务实现类中，您实例化您的服务(在我们的例子中只有一个服务<code class="fe mr ms mt mu b">salesItemService)</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">微服务实现类</p></figure><p id="c35e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以创建一个带有HTTP POST请求的销售项目:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="8c85" class="nb lt iq mu b gy nc nd l ne nf"><em class="mp">POST /salesItemService.createSalesItem<br/>Content-Type: application/json<br/><br/>{<br/>  "name": "Sales item 1",<br/>  "price": 49.95<br/>}</em></span></pre><p id="9d01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们得到一个响应，其中包含分配了<code class="fe mr ms mt mu b">_id</code>的已创建销售项目:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="cebe" class="nb lt iq mu b gy nc nd l ne nf"><em class="mp">HTTP/1.1 200 OK<br/>Content-Type: application/json<br/><br/>{<br/>  "metadata": {}<br/>  "data": {<br/>    "_id": "1",<br/>    "name": "Sales item 1",<br/>    "price": 49.95<br/>  }<br/>}</em></span></pre><p id="6f77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建另一个销售项目:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="9052" class="nb lt iq mu b gy nc nd l ne nf"><em class="mp">POST /salesItemService.createSalesItem<br/>Content-Type: application/json<br/><br/>{<br/>  "name": "Sales item 2",<br/>  "price": 89.95<br/>}</em></span></pre><p id="1414" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们可以通过HTTP POST请求获得创建的实体:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="3ad2" class="nb lt iq mu b gy nc nd l ne nf"><em class="mp">POST /salesItemService.getSalesItems</em></span></pre><p id="6781" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">答案会是:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="778d" class="nb lt iq mu b gy nc nd l ne nf"><em class="mp">HTTP/1.1 200 OK<br/>Content-Type: application/json<br/><br/>{<br/>  metadata: {}<br/>  data: [<br/>    {<br/>      "_id": "1",<br/>      "name": "Sales item 1",<br/>      "price": 49.95<br/>    },<br/>    {<br/>      "_id": "2",<br/>      "name": "Sales item 2",<br/>      "price": 89.95<br/>    }<br/>  ]<br/>}</em></span></pre><h1 id="9349" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Backk功能</h1><ul class=""><li id="a254" class="ng nh iq ky b kz mk lc ml lf ni lj nj ln nk lr nl nm nn no bi translated">基于HTTP/1.1或HTTP2的同步微服务</li><li id="3152" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">带<a class="ae kv" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇卡夫卡</a>和/或<a class="ae kv" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>的异步微服务</li><li id="8425" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">使用您现有的Javascript知识，不需要学习任何额外的技术，如REST、GraphQL或gRPC</li><li id="c1bc" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">可用于资源和RPC风格的微服务</li><li id="6a78" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">不在乎你的微服务是微服务还是更像是小型服务、大型服务或整体服务</li><li id="dd78" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">在HTTP/1.1和HTTP/2中使用服务器发送事件(SSE)的订阅端点</li><li id="1155" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">支持不同的数据库:<a class="ae kv" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>，<a class="ae kv" href="https://www.mysql.com/" rel="noopener ugc nofollow" target="_blank"> MySQL </a>，<a class="ae kv" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>，<a class="ae kv" href="https://mariadb.org/" rel="noopener ugc nofollow" target="_blank"> MariaDB </a>，<a class="ae kv" href="https://vitess.io/" rel="noopener ugc nofollow" target="_blank"> Vitess </a>(兼容MySQL)，<a class="ae kv" href="https://www.yugabyte.com/" rel="noopener ugc nofollow" target="_blank"> YugabyteDB </a>(兼容PostgreSQL)和<a class="ae kv" href="https://www.cockroachlabs.com/" rel="noopener ugc nofollow" target="_blank">cockrochdb</a>(兼容PostgreSQL)</li><li id="a148" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">ORM(对象关系映射器),具有一套全面的数据存储操作和实体字段验证</li><li id="2dea" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">用于提高安全性的强制实体字段验证</li><li id="e22f" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">极大地简化了数据传输对象(dto)的定义，或者完全消除了对dto的需求</li><li id="6b43" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">自动数据库模式生成</li><li id="d1f2" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">使用Redis的可配置响应缓存</li><li id="1781" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">自动微服务文档生成(<a class="ae kv" href="https://typedoc.org/" rel="noopener ugc nofollow" target="_blank"> TypeDoc </a>格式)</li><li id="3f93" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">自动微服务<a class="ae kv" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank"> OpenAPI 3 </a>元数据/规范生成</li><li id="41a5" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">可以调用元数据的自动API端点来为动态客户端检索微服务元数据</li><li id="99e0" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">为<a class="ae kv" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank">邮递员</a>和<a class="ae kv" href="https://www.npmjs.com/package/newman" rel="noopener ugc nofollow" target="_blank">纽曼</a>自动生成微服务集成测试</li><li id="717a" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">为Kubernetes集群内部和web前端客户端自动生成客户端代码</li><li id="cd0e" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">使用<a class="ae kv" href="https://opentelemetry.io/" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry </a> API的分布式跟踪(Jaeger)</li><li id="e59b" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">日志文件格式符合OpenTelemetry规范</li><li id="c309" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">使用OpenTelemetry API (Prometheus)收集指标</li><li id="b9d7" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">微服务启动时执行一次的启动功能</li><li id="83be" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">预定功能:Cronjobs和按客户机请求预定</li><li id="0af9" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">内置Kubernetes活跃度、就绪性和启动探针支持</li><li id="9da4" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">现成的Docker文件(构建无发行版和非根Docker映像)</li><li id="9b82" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">现成的Docker编写yaml文件，用于在CI管道中设置集成测试环境</li><li id="2019" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">用于Kubernetes部署的现成头盔模板</li><li id="446c" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">默认情况下提供一个Kubernetes pod容器安全上下文，该上下文将放弃所有Linux功能，使用只读文件系统，以非root用户身份运行，并禁用权限提升</li><li id="9785" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">现成的持续集成和持续安全CI/CS管道(目前只有Github工作流)具有强大的安全功能:OWASP ZAP API扫描、sonar cloud/sonar cube的静态代码分析、FOSSA的法律和合规性分析、Anchore的Docker图像漏洞扫描、Docker图像标签包含阿沙摘要的Helm图表</li><li id="bc44" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">OAuth 2.0授权支持</li><li id="2bbd" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">验证码验证支持</li><li id="d88e" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">使用<a class="ae kv" href="https://argon2.online/" rel="noopener ugc nofollow" target="_blank"> Argon2 </a>算法的自动密码散列</li><li id="d860" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">使用AES-256-CBC自动加密/解密个人身份信息(PII)</li><li id="4f02" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">创建统一微服务的推荐源代码目录结构</li><li id="da30" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">从构建和测试到Docker/Minikube/Helm管理的一整套NPM脚本</li><li id="9a55" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">轻松访问其他远程Backk微服务</li><li id="95a6" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">在一个请求中顺序或并行执行多个服务功能，并且可选地在一个事务中执行</li><li id="d26d" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">Git的提交挂钩</li><li id="3a11" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">最终用户身份验证和授权由单独的第三方服务完成。Backk微服务从不自行处理最终用户凭据，这最大限度地降低了泄露凭据的风险。</li><li id="4f33" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">强制服务和服务功能访问控制。每个服务函数必须用至少一个授权装饰器进行注释，比如<code class="fe mr ms mt mu b">@AllowForEveryUser</code></li><li id="f7bd" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">强制实体属性访问控制:每个实体属性必须有一个访问控制装饰器，比如<code class="fe mr ms mt mu b">@Private</code>或<code class="fe mr ms mt mu b">@ReadWrite</code></li><li id="c26b" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">强制设置请求内容最大长度</li><li id="ed51" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">强制数值范围限制</li><li id="0546" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">流式JSON解析以防止可能的Node.js事件循环阻塞</li><li id="503a" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">强制字符串最大长度限制</li><li id="5fca" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">强制分页</li><li id="9606" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">可能只允许当前，下一页或上一页抓取</li><li id="d96d" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">使用<a class="ae kv" href="https://github.com/uhop/node-re2/" rel="noopener ugc nofollow" target="_blank"> Google RE2 </a>进行验证时更安全的正则表达式处理</li><li id="9e9d" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">支持外部服务中的审计日志记录</li><li id="ec30" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">在生产环境中自动检查数据库密码和加密密钥的长度和强度</li><li id="ef01" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">安全日志将自动从日志条目中过滤出潜在的秘密和PII</li><li id="7af2" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">防止系统内部信息泄漏(生产环境API响应中没有堆栈跟踪)</li><li id="166d" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">通过广泛的ORM功能实现强大的SQL注入预防</li></ul><h1 id="0f1f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资源</h1><ul class=""><li id="77c7" class="ng nh iq ky b kz mk lc ml lf ni lj nj ln nk lr nl nm nn no bi translated"><a class="ae kv" href="https://github.com/backk-node" rel="noopener ugc nofollow" target="_blank">back Github页面</a></li><li id="ef86" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><a class="ae kv" href="https://github.com/backk-node/backk-example-microservice" rel="noopener ugc nofollow" target="_blank">back示例微服务</a></li><li id="6c02" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><a class="ae kv" href="https://github.com/backk-node/backk-starter" rel="noopener ugc nofollow" target="_blank"> Backk starter项目</a>(用于创建自己的Backk微服务)</li><li id="87a1" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><a class="ae kv" href="https://github.com/backk-node/backk/blob/main/docs/USAGE_DOCUMENTATION.MD" rel="noopener ugc nofollow" target="_blank">back使用文档</a></li><li id="7d72" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><a class="ae kv" href="https://github.com/backk-node/backk/blob/main/docs/API_DOCUMENTATION.MD" rel="noopener ugc nofollow" target="_blank"> Backk API文档</a></li></ul></div></div>    
</body>
</html>