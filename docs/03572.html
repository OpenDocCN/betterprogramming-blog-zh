<html>
<head>
<title>iOS Dependency Injection With Cleanse: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有清理的iOS依赖注入:第2部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ios-dependency-injection-with-cleanse-part-2-f6b49bee2ada?source=collection_archive---------11-----------------------#2020-02-18">https://betterprogramming.pub/ios-dependency-injection-with-cleanse-part-2-f6b49bee2ada?source=collection_archive---------11-----------------------#2020-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8377" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">注入网络服务并绑定数据集合</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1037a81183e455659399568efab06d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rXYzXUXz9FbU6HM1n6dK3A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片来自<a class="ae kv" href="https://github.com/square/Cleanse" rel="noopener ugc nofollow" target="_blank">https://github.com/square/Cleanse</a>。</p></figure><p id="bb32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">又见面了。</p><p id="e7dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们关于<a class="ae kv" href="https://github.com/square/Cleanse" rel="noopener ugc nofollow" target="_blank">清理</a>的依赖注入教程的第二部分(先阅读<a class="ae kv" href="https://medium.com/better-programming/ios-dependency-injection-with-cleanse-1ef495e390a2" rel="noopener">第1部分</a>)。你可以在GitHub 上找到这个教程<a class="ae kv" href="https://github.com/g20ready/CleansePlayground" rel="noopener ugc nofollow" target="_blank">的代码。</a></p><p id="3c2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们将在这一部分学习的内容:</p><ul class=""><li id="297b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">网络服务的注入</li><li id="2226" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用<strong class="ky ir"> </strong>多绑定<strong class="ky ir"> </strong>提供数据集合</li><li id="933e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用辅助注入来传递参数以及图形对象(例如，主-详细信息流中的选定项目)</li></ul><p id="d8ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后但同样重要的是，我将表达我对您是否应该使用Cleanse作为您项目的DI框架的想法。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="4e42" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">网络服务</h1><p id="1a38" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">在我们开始之前，将以下依赖项添加到您的Podfile并点击<code class="fe nk nl nm nn b">pod install</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Podfile。</p></figure><p id="4c5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个例子，我们将使用<a class="ae kv" href="https://github.com/HackerNews/API" rel="noopener ugc nofollow" target="_blank"> HackerNews API </a>，并获取和显示头条新闻。当用户选择一个，我们将显示一个详细的页面，并在一个<code class="fe nk nl nm nn b">WKWebView</code>渲染故事。首先定义我们的模型结构。根据API和一些研究，它应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">HNStory.swift。</p></figure><p id="5434" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，是时候定义我们的服务了，应该如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">TopStoriesService.swift</p></figure><p id="e42d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止还不错，但是一些实际的代码呢？让我们编写我们的第一个类，这将是我们的<code class="fe nk nl nm nn b">HttpClient</code>，它实现了我们刚刚定义的服务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">HttpClient.swift</p></figure><p id="a9c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的HTTP客户端看起来很简单，对吗？它的实例化只有两个依赖项:我们API的基本URL和一个<code class="fe nk nl nm nn b">SessionManager</code>，这是Alamofire对<code class="fe nk nl nm nn b">URLSession</code>的方便包装。我们添加一个助手函数，给定一个<code class="fe nk nl nm nn b">URLRequestConvertible</code>，返回给定类型的可观察值。对象的这个接口可以转换成一个<code class="fe nk nl nm nn b">URLRequest</code>。<code class="fe nk nl nm nn b">URLRequest</code>当然是可兑换的，但是我们仍然缺少我们服务的实现。现在我们来补充一下。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="699c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不会在这里详细介绍RxSwift，但我们所做的只是从Top Stories API中获取前十个对象。现在，我们希望我们的服务实现能够出现在我们的图表中。因此，我们需要定义我们的<code class="fe nk nl nm nn b">HttpClient</code>模块。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">HttpClientModule.swift。</p></figure><p id="4708" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们到了吗？不完全是。如果你看我们的<code class="fe nk nl nm nn b">HttpClient</code>，它需要一个<code class="fe nk nl nm nn b">TaggedProvider</code>和一个<code class="fe nk nl nm nn b">SessionManager</code>。而这些都还没有提供。我们将首先提供URL模块。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">BaseApiURLModule.swift</p></figure><p id="4408" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们提供了一个新的标签，<code class="fe nk nl nm nn b">BaseApiURL</code>。它的元素typealias是一个URL，这意味着当我们调用get时，这个<code class="fe nk nl nm nn b">TaggedProvider</code>将返回一个URL。接下来，我们定义将我们的基本URL注入到我们的图中的模块。这段代码可能包含关于您是去开发领域还是生产领域的逻辑。</p><p id="e0c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看来我们还缺少我们<code class="fe nk nl nm nn b">HttpClient</code>需要的<code class="fe nk nl nm nn b">SessionManager</code> <strong class="ky ir"> </strong>。创建另一个文件并添加以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">CoreNetworkModule.swift。</p></figure><p id="ff47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码做了很多工作，但是第19到21行是<code class="fe nk nl nm nn b">SessionManager</code>被实例化并提供给我们的图表的地方。这是我们的图的一个单例，从我们的活页夹的范围中定义。<code class="fe nk nl nm nn b">SingletonBinder</code>是<code class="fe nk nl nm nn b">Binder&lt;Singleton&gt;</code>的类型别名。其中一个<code class="fe nk nl nm nn b">SessionManagers</code>构造函数需要一个<code class="fe nk nl nm nn b">URLSessionConfiguration</code>、一个<code class="fe nk nl nm nn b">SessionDelegate</code>和一个<code class="fe nk nl nm nn b">ServerTrustPolicyManager?</code>。我们从第7行到第17行提供了所有这些依赖关系。现在修改<code class="fe nk nl nm nn b">HttpClientModule</code>如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5153" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一个要连接的点和我们的<code class="fe nk nl nm nn b">TopStoriesService</code>的实现<code class="fe nk nl nm nn b">HttpClient</code>，将在我们的图形中可用，以供其他对象使用。打开你的<code class="fe nk nl nm nn b">MainComponent</code> <strong class="ky ir"> </strong>，在<code class="fe nk nl nm nn b">configure</code>功能里面添加<code class="fe nk nl nm nn b">binder.include(module: HttpClient.Module) </code>。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="d741" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">视图模型和视图控制器</h1><p id="a8cc" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">现在我们已经设置了网络层，是时候使用它了。添加一个名为<code class="fe nk nl nm nn b">TopStoriesViewModel</code>的新文件。它应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">TopStoriesViewModel.swift。</p></figure><p id="604e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，我知道由于RxSwift部分，这可能看起来有点复杂，但忽略它。您只需要知道它获取数据并通过输出传递给我们的<code class="fe nk nl nm nn b">ViewController</code>。重要的是我们的<code class="fe nk nl nm nn b">ViewModel</code>是用我们之前定义的<code class="fe nk nl nm nn b">TopStoriesService</code>实例化的。接下来，我们要添加我们的<code class="fe nk nl nm nn b">ViewController</code>。用一个<code class="fe nk nl nm nn b">xib</code>文件创建一个新的<code class="fe nk nl nm nn b">ViewController</code>(最好命名为<code class="fe nk nl nm nn b">TopStoriesViewController</code>)并添加以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">TopStoriesViewController.swift。</p></figure><p id="3e75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是<code class="fe nk nl nm nn b">viewDidLoad</code>中定义的两个设置功能的扩展。<strong class="ky ir"> </strong>虽然这无关紧要，但下面几行将填充我们的列表。这是你与<a class="ae kv" href="https://github.com/ReactiveX/RxSwift" rel="noopener ugc nofollow" target="_blank"> RxSwift </a>和<a class="ae kv" href="https://github.com/ReactiveX/RxSwift/tree/master/RxCocoa" rel="noopener ugc nofollow" target="_blank"> RxCocoa </a>合作的好处之一。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">TopStoriesViewController.swift。</p></figure><p id="cc0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该单元格是一个带有三个标签的自定义单元格。你爱怎么处理就怎么处理。该单元的代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a883" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将定义一个模块，该模块将在每次请求时向我们的图中注入这个<code class="fe nk nl nm nn b">ViewController</code>的一个实例。这一次，我们将使用<code class="fe nk nl nm nn b">UnscopedBinder</code>，它是<code class="fe nk nl nm nn b">Binder&lt;Unscoped&gt;</code>的typealias，主要是因为拥有单一视图控制器没有意义。该模块将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7ad8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等等，什么？我们告诉我们的绑定器，它应该将我们的<code class="fe nk nl nm nn b">TopStoriesViewController</code>绑定到它的超类类型和<code class="fe nk nl nm nn b">intoCollection()</code>？</p><p id="e4df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第11行和第12行<strong class="ky ir"> </strong>实际上做的是，它们告诉Cleanse将从工厂返回的<code class="fe nk nl nm nn b">ViewController</code>放入一个<code class="fe nk nl nm nn b">UIViewController</code>对象数组中，并提供该数组。第14行简单地将TopStoriesViewController包装在一个<code class="fe nk nl nm nn b">UINavigationController</code>中并返回它。我们将使用注入的数组作为我们的<code class="fe nk nl nm nn b">TabBarController</code>的<code class="fe nk nl nm nn b">viewControllers</code>属性。</p><p id="c7f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们即将看到黑客新闻API的头条新闻。我们现在需要做的就是添加我们的<code class="fe nk nl nm nn b">MainTabBarViewController</code>，它应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c36e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在是最后一次，打开您的<code class="fe nk nl nm nn b">MainComponent</code>文件并替换其内容，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="bbd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">点击运行，你会看到一个列表中的热门故事。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="bf1a" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">辅助注射</h1><p id="285a" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">还有最后一件事我们没有谈到。假设我们希望用户选择一个<code class="fe nk nl nm nn b">UITableViewCell</code>并导航到一个<code class="fe nk nl nm nn b">StoryViewController</code>，在这里我们将所选故事对象的<code class="fe nk nl nm nn b">url</code>属性加载到一个<code class="fe nk nl nm nn b">WKWebView</code>中。事实是，我们不能将故事注入到我们的图表中，因为它是用户生成的事件。这就是辅助注射的用武之地。从<code class="fe nk nl nm nn b">ViewModel</code>开始，创建一个新文件并添加以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1d46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，跳过Rx部分，专注于构造函数。这很简单——它所需要的只是一个<code class="fe nk nl nm nn b">HNStory</code>对象。现在创建您的<code class="fe nk nl nm nn b">StoryViewController</code>(这里不需要nib文件)并添加以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="58a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而我们<code class="fe nk nl nm nn b">StoryViewController</code>的模块看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="07f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们定义一个<code class="fe nk nl nm nn b">AssistedFactory</code> <strong class="ky ir"> </strong>，种子为<code class="fe nk nl nm nn b">HNStory</code>，用户选择的故事。这个<code class="fe nk nl nm nn b">AssistedFactory</code> <strong class="ky ir"> </strong>会为我们构建一个<code class="fe nk nl nm nn b">StoryViewController</code>的元素。怎么会？<strong class="ky ir"> </strong>这个问题的答案是我们模块的<code class="fe nk nl nm nn b">configure</code>函数。这里我们告诉binder应该绑定了一个<code class="fe nk nl nm nn b">StoryViewController</code>的工厂。<strong class="ky ir"> </strong>下一行<code class="fe nk nl nm nn b">.with(AssistedFactory.self)</code>是一个方向，告诉Cleanse在图中注入一个类型为<code class="fe nk nl nm nn b">AssistedFactory</code>的工厂。给定种子(<code class="fe nk nl nm nn b">HNStory</code>，这个工厂将为我们提供<code class="fe nk nl nm nn b">StoryViewController</code>实例。</p><p id="517e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe nk nl nm nn b">TopStoriesViewController</code>并添加以下几行:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b0a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还应该在<code class="fe nk nl nm nn b">setupViewModel</code>函数中添加点击处理:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c7b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第10行，我们调用<code class="fe nk nl nm nn b">storyFactory.build</code>将我们选择的故事的一个参数传递给工厂，它返回一个<code class="fe nk nl nm nn b">StoryViewController</code>的实例。完全像是过度杀戮。其实不是。通过利用辅助工厂特性，我们还可以在图中使用get dependencies。假设我们想从<code class="fe nk nl nm nn b">StoryViewModel</code>访问我们的服务。然后我们要做的就是在构造函数中定义它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">StoryViewModel.swift。</p></figure><p id="107b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并更新模块来传递参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">storyviewcontrollermodule . swift。</p></figure><p id="da45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅此而已。我们现在传递用户选择的故事项，并从我们的图表中获取服务。</p><p id="bf5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想我们已经完成了第二部分。接下来，我将和大家分享我对DI的看法。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="2186" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">结论</h1><p id="a13f" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">正如你在本教程中看到的，清理是相当复杂的。它肯定有一个学习曲线，但是如果你熟悉其他的DI框架(例如dagger) <strong class="ky ir">，</strong>，那么你会发现集成它更容易。</p><p id="e834" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你在一个组织的不同部门与多个团队一起工作一个大项目，那么你必须有一个标准的方法来注入你的依赖关系。否则，事情最终会变糟——即使你雇佣了最有才华的工程师。为了准确，你做的每件事都必须有一个记录的方法。拥有一个框架来处理依赖性管理是一个需要处理的问题。</p><h2 id="cc83" class="nq mo iq bd mp nr ns dn mt nt nu dp mx lf nv nw mz lj nx ny nb ln nz oa nd ob bi translated"><strong class="ak">优点</strong></h2><p id="331d" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">就特征而言，清洗是完整的。</p><p id="2a13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它处理图形构造的方式是安全的，这意味着如果您的设置出错，您会在早期崩溃。</p><p id="0028" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它的文档很好<strong class="ky ir"> </strong>(我只是通过阅读和查看示例代码来集成它)，并且它正在被积极地维护。</p><h2 id="d241" class="nq mo iq bd mp nr ns dn mt nt nu dp mx lf nv nw mz lj nx ny nb ln nz oa nd ob bi translated">骗局</h2><p id="e3cc" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">初级开发人员需要努力理解框架的核心概念。</p><p id="6866" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重构一个庞大的代码库需要花费大量的时间，但是可以逐步完成。</p><p id="967a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目标-C支持是实验性的。</p><p id="036b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">堆栈溢出只有三个关于清理的问题。</p><p id="2cdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果你和2-3个开发人员一起做一个相对较小的项目，虽然集成起来会更容易，但是你必须仔细考虑是否值得在你的开发中增加这种开销。</p><p id="6931" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对Cleanse或DI有任何问题或想法，请在下面的评论区自由表达。</p><p id="64c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您花时间阅读本文。</p></div></div>    
</body>
</html>