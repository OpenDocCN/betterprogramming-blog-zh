<html>
<head>
<title>`await`ing on a Better Future</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">等待一个更好的未来</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/await-ing-a-better-future-fb58167b3b3d?source=collection_archive---------11-----------------------#2022-11-29">https://betterprogramming.pub/await-ing-a-better-future-fb58167b3b3d?source=collection_archive---------11-----------------------#2022-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="daef" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">代码抽象的例子</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/47dbbc98997b36f7ff1432297f792c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Hgcazs0wNIEfN4G-"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@drmakete?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> drmakete实验室</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b128" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管我最初对JavaScript中的关键字<code class="fe ls lt lu lv b">await</code>的引入感到满意，但我已经开始认为编程语言可以完全抽象这个概念，而不需要任何特殊的语法。从短期来看，我们应该更喜欢自己的代码抽象来帮助我们忘记异步。</p><p id="999d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提醒一下，异步允许程序员“差不多同时”做很多事情，也就是说，在执行过程中停下来做别的事情。如果一个程序有许多IO阻塞的操作(例如，调用远程服务、访问磁盘、等待用户输入等等)，这就变得特别重要。</p><p id="0383" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">async/await语法是主流编程语言中相对较新的内容。它允许编写不会线性执行的线性代码。</p><p id="9871" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">典型用法如下所示:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="338d" class="ma mb iq lv b be mc md l me mf">// Execution will possibly go elsewhere here<br/>const nBoxes = await getNumberOfBoxes();<br/>// Here too.<br/>const nBunnies = await getNumberOfBunnies();<br/>const message = nBoxes - nBunnies &gt; 0<br/> ? 'we have enough boxes'<br/> : 'we don\'t have enough boxes';<br/>console.log(message);</span></pre><p id="5af3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个异步调用是按顺序进行的，但是由于它们没有副作用(它们是只读的)，它们可以同时发生，这样会快得多:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="cc75" class="ma mb iq lv b be mc md l me mf">const [nBoxes, nBunnies] = await Promise.all([<br/> getNumberOfBoxes(),<br/> getNumberOfBunnies()<br/>]);<br/>const message = nBoxes - nBunnies &gt; 0<br/> ? 'we have enough boxes'<br/> : 'we don\'t have enough boxes';<br/>console.log(message);</span></pre><p id="e1c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种低效是常见的，并且经常在代码审查中被发现。</p><p id="1b9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个问题是命令式编码是线性完成的:代码行按照编写的顺序一行一行地执行。有时候，就像这个例子，我们不关心先运行哪一行。然而，我们必须做出选择，这就引入了任意的变化——噪声。</p><p id="3154" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们能做得更好吗？我们能减少噪音并确保代码以最佳方式运行吗？</p><p id="a429" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们看一下程序的图形表示，那么这个图中节点之间的依赖关系暗示了什么可以并行完成(直观地说，同一“层”中的任何东西)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/a2536d01f0d8f3d3e9c7c7fcff1d9a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rqt30gbU_bjllkG9"/></div></div></figure><p id="3a19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种表示中，非语义的自由度被拿走了；我们不能再对代码应用“行置换”变换。</p><p id="1462" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是有时候管理<code class="fe ls lt lu lv b">await</code>是语义上的。以这个案例为例:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="7c07" class="ma mb iq lv b be mc md l me mf">await createUser(data)<br/>const users = await getUsers()<br/>return users</span></pre><p id="63dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不等同于以下内容:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="6741" class="ma mb iq lv b be mc md l me mf">const [_, users] = await Promise.all([createUser(data), getUsers()])<br/>return users</span></pre><p id="be0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">异步调用有副作用，这意味着<code class="fe ls lt lu lv b">await</code>的顺序很重要，即使依赖关系没有明确暗示出来。</p><p id="d6cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是大多数时候，让程序同时管理<code class="fe ls lt lu lv b">await</code>和执行顺序会带来麻烦，或者至少，有些需要更多的努力。只是抽象层次不对。我们将添加这些语句以使代码“正常工作”</p><p id="6cab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在某种意义上，异步类似于指针操作。我们过去常常手动管理内存使用。现在，我们大多数人，大部分时间，都不再需要了。它被巧妙的语法抽象化了。</p><p id="d3f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们更希望让异步为我们管理，而不是由我们来管理。为此，我们可以使用更好的抽象来执行:异步感知的组合器(参见下面的实现)。使用它们，上面的例子可以写成这样:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="0271" class="ma mb iq lv b be mc md l me mf">pipe(<br/> juxt(getNumberOfBoxes, getNumberOfBunnies),<br/> subtraction,<br/> greater(0)),<br/> result =&gt; console.log(<br/>   result<br/>     ? ’we have enough boxes’<br/>     : ’we don\’t have enough boxes’<br/> ),<br/>)</span></pre><p id="f527" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">pipe</code>基本上意味着函数组合(以相反的顺序),<code class="fe ls lt lu lv b">juxt</code>意味着并行组合，所以我们输入一个值，得到一个结果数组。</p><p id="4707" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种写作方式有三个优点:</p><ol class=""><li id="8258" class="mh mi iq ky b kz la lc ld lf mj lj mk ln ml lr mm mn mo mp bi translated">它最佳地等待着。实际上，我们自己从来没有明确地给<code class="fe ls lt lu lv b">f()</code>或<code class="fe ls lt lu lv b">await</code>打过电话。<code class="fe ls lt lu lv b">juxt</code>和<code class="fe ls lt lu lv b">pipe</code>对此做出明智的决定，这样就少了一件需要担心的事情。</li><li id="03f5" class="mh mi iq ky b kz mq lc mr lf ms lj mt ln mu lr mm mn mo mp bi translated">它被去噪是因为正确书写它的方法更少了。顺序更加依赖于驱动，更加语义化——我们不能切换任何行。</li><li id="050d" class="mh mi iq ky b kz mq lc mr lf ms lj mt ln mu lr mm mn mo mp bi translated">在将<code class="fe ls lt lu lv b">getNumberOfBunnies</code>更改为同步不需要代码更改的意义上，它与成分的重复/关联更少。</li></ol><p id="486c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果IO是有影响的，并且我们希望确保事情按顺序发生，该怎么办？我们应该明确地渴望做到这一点，因此一些composer将需要按顺序发生的动作链接起来，而不是四处浮动:未来的编辑器可能会无意中改变它们的顺序并导致错误。抽象是这样工作的:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="681f" class="ma mb iq lv b be mc md l me mf">return doInSequence(<br/> () =&gt; createUser(data),<br/>  getUsers<br/>);</span></pre><p id="b31f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些抽象的共同点是，它们帮助我们在依赖空间中思考，这比执行顺序空间(有时有意义，有时是任意的)更有意义。</p><p id="9cac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这反过来减少了噪声，更加简洁，并且总是最佳的。</p><h1 id="26a4" class="mv mb iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated"><strong class="ak">附录</strong></h1><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="8113" class="ma mb iq lv b be mc md l me mf">const wrapPromise = (x) =&gt; Promise.resolve(x);<br/><br/>const doInSequence = (head, ...rest) =&gt; wrapPromise(head()).then((x) =&gt; (rest.length ? doInSequence(...rest) : x));<br/><br/>const map = (f) =&gt; (xs) =&gt; {<br/> const results = [];<br/> for (const x of xs) {<br/>   results.push(f(x));<br/> }<br/> return results.some(isPromise) ? Promise.all(results) : results;<br/>};<br/>const juxt =<br/> (...fs) =&gt;<br/> (...x) =&gt;<br/>   map((f) =&gt; f(...x))(fs);<br/><br/>const reduceHelper = (reducer) =&gt; (s, xs, firstIndex) =&gt;<br/> firstIndex === xs.length<br/>   ? s<br/>   : isPromise(s)<br/>   ? s.then((s) =&gt;<br/>       reduceHelper(reducer)(reducer(s, xs[firstIndex]), xs, firstIndex + 1),<br/>     )<br/>   : reduceHelper(reducer)(reducer(s, xs[firstIndex]), xs, firstIndex + 1);<br/>const reduce = (reducer, initial) =&gt; (xs) =&gt;<br/> initial<br/>   ? reduceHelper(reducer)(initial(), xs, 0)<br/>   : reduceHelper(reducer)(xs[0], xs, 1);<br/>const pipe =<br/> (...fs) =&gt;<br/> (...x) =&gt;<br/>   reduce(<br/>     (s, x) =&gt; x(s),<br/>     () =&gt; fs[0](...x),<br/>   )(fs.slice(1));</span></pre><p id="8eb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在https://github.com/uriva/gamlajs找到这些和其他的。</p></div></div>    
</body>
</html>