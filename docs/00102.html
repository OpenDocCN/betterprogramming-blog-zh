<html>
<head>
<title>A Generic HTTP Service Approach for Angular Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向角度应用的通用HTTP服务方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-generic-http-service-approach-for-angular-applications-a7bd8ff6a068?source=collection_archive---------0-----------------------#2018-02-13">https://betterprogramming.pub/a-generic-http-service-approach-for-angular-applications-a7bd8ff6a068?source=collection_archive---------0-----------------------#2018-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a85eafe835ad03e637c1fa9d06da54b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nIjfoUR90CUKibydNhq_Bw.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@jantined?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Jantine Doornbos </a>在<a class="ae kf" href="https://unsplash.com/search/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8885" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我目前正在做的项目的一部分是构建一个基于Angular 4的web应用程序，该程序从大量RESTful后端服务中提取数据并将其可视化。</p><p id="9957" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">REST的基石之一是通过HTTP请求识别和操作资源。</p><p id="230c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有一个RESTful pizza服务，它公开了一个<code class="fe le lf lg lh b">pizzas</code>端点，那么在这个端点上执行一个<code class="fe le lf lg lh b">HTTP GET</code>将会返回一个资源集合，每个资源都是一个pizza的表示。</p><p id="aeab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每一个比萨饼都可以用一个属性来唯一识别，比如一个<code class="fe le lf lg lh b">id</code>。然后这个<code class="fe le lf lg lh b">id</code>可以用来获取和操作一个特定的pizza资源。</p><p id="8e4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">向<code class="fe le lf lg lh b">pizzas/:id</code>端点发出<code class="fe le lf lg lh b">GET</code>请求将返回带有所请求的<code class="fe le lf lg lh b">id</code>的比萨饼。</p><p id="006b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用请求体中的pizza资源向<code class="fe le lf lg lh b">pizzas/:id</code>端点发出<code class="fe le lf lg lh b">PUT</code>请求，会用提供的值更新指定的资源。</p><p id="71f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">向端点发出一个<code class="fe le lf lg lh b">DELETE</code>请求会删除那个资源。</p><p id="6110" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总体情况如下:</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi li"><img src="../Images/13dce521684c80cd334e26dff517f446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H3OltmWogerLP1kLzjDtow.png"/></div></div></figure><p id="a36f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Angular应用程序中，我们将使用<code class="fe le lf lg lh b">HttpClient</code>模块来发出HTTP请求，因此如果我们在Angular应用程序中实现了一个匹配的<code class="fe le lf lg lh b">PizzaService</code>，它看起来会像这样:</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="a811" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">HttpClient</code>的泛型方法确保强类型的<code class="fe le lf lg lh b">Pizza</code>对象被返回给使用该服务的组件。</p><p id="7392" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，如果在后端的对象表示和在前端需要显示的内容之间需要稍微复杂一点的转换，我们将需要构建自己的转换机制。</p><p id="7f64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以我们的例子为例，让比萨饼有一个<code class="fe le lf lg lh b">cookedOn</code>属性，它由API作为字符串返回。我们想把它解析成一个<a class="ae kf" href="https://momentjs.com/" rel="noopener ugc nofollow" target="_blank">矩</a>对象，这样我们就可以更好地控制它在应用程序中的显示方式。</p><p id="a2ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，在向API回发披萨时，<code class="fe le lf lg lh b">cookedOn</code>字段将被忽略，不需要被回发。</p><p id="2651" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于诸如此类的转换，我使用了一种称为<code class="fe le lf lg lh b">Serializer</code>的机制，它将API返回的原始<a class="ae kf" href="https://www.json.org/" rel="noopener ugc nofollow" target="_blank"> JSON </a>转换为具有所需属性的强类型对象。</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi li"><img src="../Images/a4181be40f89a8a3c57574e07b67d05d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFqdpbO6mpL0Ufwr5km1jQ.png"/></div></div></figure><p id="37da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个<code class="fe le lf lg lh b">PizzaSerializer</code>的例子:</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="ff33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和<code class="fe le lf lg lh b">PizzaService</code>，现在已经增强为使用串行器。</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="cf83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，这里需要注意的是，如果我们有另一个返回汉堡而不是披萨的后端服务，匹配的前端服务将做与<code class="fe le lf lg lh b">PizzaService</code>相同的事情，只是现在它对<code class="fe le lf lg lh b">Burger</code>对象而不是<code class="fe le lf lg lh b">Pizza</code>对象执行相同的操作。</p><p id="488a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于模型上的可能差异，实现上的唯一差异是序列化器。</p><p id="6d42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在构建我们的Angular应用程序的过程中，我们实现了大量的服务来从后端获取和操作数据。</p><p id="b78c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们最终得到了一堆本质上做同样事情的类——从后端获取特定的资源，将它们转换成前端对它们的表示，并根据需要从后端更新、创建或删除它们。</p><p id="4859" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这最终导致了大量代码重复，需要以某种方式解决。</p><p id="b69f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解决方案是采用一种通用的方法，这种方法适用于从RESTful API获取的任何资源，只要资源符合一些基本的约束。</p><p id="ab2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们假设从API返回的所有东西都是唯一可识别的，这意味着我们收到的每个对象都有一个<code class="fe le lf lg lh b">id</code>字段。</p><p id="3c17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过创建一个<code class="fe le lf lg lh b">Resource</code>模型来对此进行形式化:</p><pre class="lj lk ll lm gt lp lh lq lr aw ls bi"><span id="59fd" class="lt lu it lh b gy lv lw l lx ly">export class Resource {<br/>  id: number<br/>}</span></pre><p id="a9fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们为从后端获取的资源创建的每个模型，比如<code class="fe le lf lg lh b">Burger</code>或<code class="fe le lf lg lh b">Pizza</code>，都可以从<code class="fe le lf lg lh b">Resource</code>继承，从而赋予它一个<code class="fe le lf lg lh b">id</code>属性。</p><pre class="lj lk ll lm gt lp lh lq lr aw ls bi"><span id="46d0" class="lt lu it lh b gy lv lw l lx ly">export class Pizza extends Resource {<br/>  //id is inherited from Resource<br/>  name: string;<br/>  cookedOn: Moment;<br/>}</span></pre><p id="dc6d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个我们需要通用化的组件是<code class="fe le lf lg lh b">Serializer</code>。我们将通过指定一个所有序列化程序都将实现的接口来做到这一点。</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="04b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们使用这个通用模型和接口(以及一些很酷的TypeScript泛型)来实现适用于任何资源的通用服务。</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="be18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">扩展这个通用服务的<code class="fe le lf lg lh b">PizzaService</code>现在不需要编写任何CRUD代码！</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="3e95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实现一个新的汉堡服务现在只需要创建一个类，并让它从上面的泛型<code class="fe le lf lg lh b">ResourceService</code>继承。</p><p id="f360" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有了它，一个从RESTful API获取和转换数据的通用实现！</p><p id="a35e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，还有一种情况我们没有考虑到。</p><p id="f5e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">REST允许资源拥有子资源，即与主资源对象相关联的子资源。</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi li"><img src="../Images/6a9d9e4dcd0bd01212c2a838dd8b752c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1oHG2xf95cKL8K6GFGYow.png"/></div></div></figure><p id="637f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了支持这样的子资源，我们需要如下扩展我们的资源模型:</p><pre class="lj lk ll lm gt lp lh lq lr aw ls bi"><span id="9e9c" class="lt lu it lh b gy lv lw l lx ly">export class Resource {<br/>  id: number;<br/>  parentId?: number;<br/>}</span></pre><p id="6516" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">添加<code class="fe le lf lg lh b">parentId</code>字段允许我们识别子资源。</p><p id="e82d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我们将需要实现另一个通用服务，一个<code class="fe le lf lg lh b">SubResourceService</code>，它需要一个额外的参数来标识父端点，并且需要在<code class="fe le lf lg lh b">parentId</code>中被传递以对资源进行操作。</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c89e" class="mg lu it bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">结论</h1><p id="dd4e" class="pw-post-body-paragraph kg kh it ki b kj nd kl km kn ne kp kq kr nf kt ku kv ng kx ky kz nh lb lc ld im bi translated">现在，我们有了RESTful API提供的任何资源或子资源上的CRUD的全功能通用实现。</p><p id="c81e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这确保了在获取、转换和分发数据方面完成所有繁重工作的代码被封装在两个类中，并且可以单独进行单元测试。</p><p id="7b96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">序列化程序公开了纯函数，这些函数也可以进行彻底的单元测试，以确保高质量的工作软件。</p></div></div>    
</body>
</html>