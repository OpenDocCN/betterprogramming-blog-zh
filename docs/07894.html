<html>
<head>
<title>Haskell Tutorial: Get Started With Functional Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Haskell教程:函数式编程入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/haskell-tutorial-get-started-with-functional-programming-6de2527b0a05?source=collection_archive---------12-----------------------#2021-03-02">https://betterprogramming.pub/haskell-tutorial-get-started-with-functional-programming-6de2527b0a05?source=collection_archive---------12-----------------------#2021-03-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="94bf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从基础到高级概念</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4b85b7dc0b6106a18139d4e224b11a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sk3WIbt-0tJiMlZkMPAAxg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="aa9b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Haskell是一种经典的函数式编程语言，在21世纪20年代有所复兴。随着对数据科学家需求的增长，公司正在寻找能够随着大数据量扩展并保持效率的工具。</p><p id="f40c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Haskell是这项工作的完美选择——拥有多年的优化和专门为这种业务数据分析构建的特性。</p><p id="88f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天，我们将通过对Haskell的实际介绍来帮助您克服函数式编程的学习曲线。</p><p id="4f53" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">下面是我们今天要讲的内容:</strong></p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="7136" class="lw lx iq ls b gy ly lz l ma mb">1. <a class="ae mc" href="#6b9b" rel="noopener ugc nofollow">What Is Functional Programming?</a><br/>2. <a class="ae mc" href="#97e5" rel="noopener ugc nofollow">What Is the Haskell Programming Language?</a><br/>3. <a class="ae mc" href="#a447" rel="noopener ugc nofollow">Basics of the Haskell Syntax</a><br/>4. <a class="ae mc" href="#b4be" rel="noopener ugc nofollow">Advanced Haskell Concepts</a><br/>5. <a class="ae mc" href="#0807" rel="noopener ugc nofollow">What to Learn Next</a></span></pre></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="6b9b" class="mk lx iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">什么是函数式编程？</h1><p id="8705" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">函数式编程是一种声明式编程范式，用于创建包含一系列简单函数而非语句的程序。</p><p id="ce9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然OOP程序擅长表现具有独特特征的物理对象，但函数式程序是纯数学的，用于复杂的数学计算或非物理问题，如人工智能设计或高级方程模型。</p><p id="7161" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">函数范式中的所有函数必须:</strong></p><ul class=""><li id="06e0" class="ng nh iq kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated"><strong class="kx ir">纯</strong>:它们不会产生副作用或改变输入数据</li><li id="eaca" class="ng nh iq kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated"><strong class="kx ir">与程序状态</strong>无关:相同输入的值总是相同的，与其他变量值无关</li></ul><p id="7197" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个函数完成一个单独的操作，可以按顺序组合完成复杂的操作。例如，我们可能有一个函数将输入数<code class="fe nu nv nw ls b">doubleInput</code>加倍，另一个函数将该数除以圆周率<code class="fe nu nv nw ls b">divPi</code>。</p><p id="3d3a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些功能中的任何一个都可以单独使用，或者它们可以串在一起，这样<code class="fe nu nv nw ls b">doubleInput</code>的输出就是<code class="fe nu nv nw ls b">divPi</code>的输入。这种特性使得函数程序的各个部分高度模块化，因为函数可以在程序中重用，可以被调用、作为参数传递或返回。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="97e5" class="mk lx iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">什么是Haskell编程语言？</h1><p id="896f" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">Haskell是一种编译的、静态类型的函数式编程语言。它创建于20世纪90年代初，是第一批开源纯函数式编程语言之一，以美国逻辑学家哈斯凯尔·布鲁克斯·加里的名字命名。Haskell加入了Lisp，成为一种基于数学的更古老但有用的函数式语言。</p><p id="74fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Haskell语言是为函数式编程而从头开始构建的，具有强制性的纯度强制和不可变的数据。它主要以其惰性计算和内存安全而闻名，避免了C或C++等语言中常见的内存管理问题。</p><p id="d1ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与Java等其他静态类型语言相比，它还提供了更健壮的数据类型选择，具有参数多态性、基于类(ad-hoc)的多态性、类型族等类型特性。</p><p id="506b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">总的来说，Haskell将函数式编程的性能和可伸缩性优势与多年的优化和独特的工具结合在一起。</p><p id="58f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，Haskell主要用于金融、生物技术或电子商务等数据丰富的业务领域的数据分析。这些行业对可伸缩性和安全性日益增长的需求使得Haskellers成为一个非常受欢迎的群体。</p><p id="8b6c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一个Python中的命令式解决方案在Haskell中如何表现为声明式函数式解决方案的示例:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="d775" class="lw lx iq ls b gy ly lz l ma mb">def compound_interest(years):<br/>  current_money = 1000<br/>  for year in range(years):<br/>    current_money = current_money * 1.05<br/>  print('After {years} years, you have {money:.2f} dollars.'.format(years=years, money=current_money))<br/>  return current_money <br/>compound_interest(10)</span><span id="97d7" class="lw lx iq ls b gy nx lz l ma mb">compoundInterest :: Int -&gt; Double<br/>compoundInterest 0 = 1000<br/>compoundInterest n = 1.05 * (compoundInterest (n - 1))<br/>main = printf "After 10 years, you have %.2f dollars." (compoundInterest 10)</span></pre><p id="3611" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与命令式程序相比，Haskell程序具有:</p><ul class=""><li id="5db4" class="ng nh iq kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated">类型和静态类型批注</li><li id="841f" class="ng nh iq kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">没有声明。该函数是用表达式逐个定义的。</li><li id="a685" class="ng nh iq kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">没有循环。我们每次都用递归调用来乘以利率。</li><li id="54ec" class="ng nh iq kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">没有可变变量。我们使用一个递归表达式从(<em class="ny"> n- </em> 1)年后的值得到<em class="ny"> n </em>年后的值。</li><li id="fbb2" class="ng nh iq kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">这个函数没有副作用。将结果打印到屏幕上发生在计算结果的函数之外。</li></ul></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="0b7f" class="mk lx iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">Haskell的显著特征</h1><h2 id="d31e" class="lw lx iq bd ml nz oa dn mp ob oc dp mt le od oe mv li of og mx lm oh oi mz oj bi translated"><strong class="ak">记忆安全</strong></h2><p id="3959" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">包括自动内存管理，以避免内存泄漏和溢出。Haskell的内存管理类似于Golang、Rust或Python。</p><h2 id="88ea" class="lw lx iq bd ml nz oa dn mp ob oc dp mt le od oe mv li of og mx lm oh oi mz oj bi translated"><strong class="ak">已编译</strong></h2><p id="a934" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">使用GHC·哈斯克尔编译器提前直接编译成机器源代码。GHC经过高度优化，可以生成高效的可执行文件来提高性能。它还有一个名为GHCi的交互式环境，允许对表达式进行交互式评估。这个特性是Haskell在高输入数据分析方面受欢迎的关键。</p><h2 id="ed57" class="lw lx iq bd ml nz oa dn mp ob oc dp mt le od oe mv li of og mx lm oh oi mz oj bi translated"><strong class="ak">静态类型化</strong></h2><p id="e370" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">有一个类似于Java的静态类型系统，它在环境中验证Haskell代码。这让您可以在开发的早期就捕捉到bug。Haskell丰富的类型选择意味着对于给定的变量，您总是有最完美的类型。</p><h2 id="2f1a" class="lw lx iq bd ml nz oa dn mp ob oc dp mt le od oe mv li of og mx lm oh oi mz oj bi translated"><strong class="ak">强制实施的功能性最佳实践</strong></h2><p id="bb99" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">实施函数式编程规则，例如纯函数和带有错误消息的不可变变量。这一特性最大限度地降低了程序的复杂性，并确保您充分利用了它的功能。</p><h2 id="29e3" class="lw lx iq bd ml nz oa dn mp ob oc dp mt le od oe mv li of og mx lm oh oi mz oj bi translated"><strong class="ak">懒评</strong></h2><p id="89ba" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">将计算推迟到需要结果时。Haskell以其优化的惰性评估能力而闻名，这使得重构和函数组合变得容易。</p><h2 id="f1fc" class="lw lx iq bd ml nz oa dn mp ob oc dp mt le od oe mv li of og mx lm oh oi mz oj bi translated"><strong class="ak">并发</strong></h2><p id="da79" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">Haskell通过绿色线程(虚拟线程)和<code class="fe nu nv nw ls b">async</code>和<code class="fe nu nv nw ls b">stm</code>库使并发变得容易，这些库为您提供了创建并发程序所需的所有工具。强制纯函数增加了简单性，避免了并发编程的许多常见问题。</p><h2 id="fc4b" class="lw lx iq bd ml nz oa dn mp ob oc dp mt le od oe mv li of og mx lm oh oi mz oj bi translated"><strong class="ak">图书馆</strong></h2><p id="fca8" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">Haskell在这一点上已经开源了几十年，这意味着有成千上万的库可用于每一个可能的应用程序。可以肯定的是，你遇到的几乎所有问题都会有一个现成的库来解决。一些流行的附加功能是Stack，它构建和处理依赖关系，以及Cabal，它添加了打包和分发功能。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="a447" class="mk lx iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">Haskell语法的基础</h1><p id="57ab" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">现在你知道了为什么Haskell今天还在使用，让我们探索一些基本的语法。Haskell的两个最核心的概念是类型和函数。</p><ul class=""><li id="c493" class="ng nh iq kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated"><strong class="kx ir">类型</strong>是行为相似的值的集合，例如数字或字符串</li><li id="1b61" class="ng nh iq kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated"><strong class="kx ir">函数</strong>可用于将一种类型的值映射到另一种类型</li></ul><h2 id="cef0" class="lw lx iq bd ml nz oa dn mp ob oc dp mt le od oe mv li of og mx lm oh oi mz oj bi translated">数字类型</h2><p id="efe7" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">数值类型保存不同范围和位数的数值，如<code class="fe nu nv nw ls b">15</code>或<code class="fe nu nv nw ls b">1.17</code>。Haskell有三种常见的数字类型:</p><ul class=""><li id="6e8c" class="ng nh iq kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated"><code class="fe nu nv nw ls b">Int</code>为64位(&gt; 20位)整数</li><li id="e353" class="ng nh iq kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated"><code class="fe nu nv nw ls b">Integer</code>可以表示任意数字的<code class="fe nu nv nw ls b">Int</code>类型列表(类似于其他语言中的<code class="fe nu nv nw ls b">BigInt</code>)</li><li id="2d13" class="ng nh iq kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated"><code class="fe nu nv nw ls b">Double</code>为64位十进制数。每个数字类型都使用标准操作符，如<code class="fe nu nv nw ls b">+</code>、<code class="fe nu nv nw ls b">-</code>和<code class="fe nu nv nw ls b">*</code>。只有<code class="fe nu nv nw ls b">Double</code>支持除法运算，所有<code class="fe nu nv nw ls b">Integer</code>除法都会作为<code class="fe nu nv nw ls b">Double</code>返回。例如:</li></ul><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="a9a7" class="lw lx iq ls b gy ly lz l ma mb">Prelude&gt; 3 / 2<br/>1.5</span></pre><p id="319e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是更多数字类型操作的例子。</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="81d0" class="lw lx iq ls b gy ly lz l ma mb">Prelude&gt; 1 + 2<br/>3<br/>Prelude&gt; 5 * (7 - 1)<br/>30</span></pre><p id="674d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Haskell使用类型推理为给定的操作分配最符合逻辑的数据类型。因此，如果显而易见，我们不必声明类型，例如<code class="fe nu nv nw ls b">Int</code>对<code class="fe nu nv nw ls b">Double</code>值。</p><p id="3947" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要显式声明数据类型，可以在每个值后添加名称，如下所示:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="7d54" class="lw lx iq ls b gy ly lz l ma mb">Prelude&gt; (1 :: Int) + (2 :: Int)<br/>3</span></pre><p id="0c96" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Haskell还包括用于常见数字运算的预定义函数，如指数、整数除法和类型转换。</p><ul class=""><li id="926a" class="ng nh iq kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated"><strong class="kx ir">幂</strong> ( <code class="fe nu nv nw ls b">^</code>):将第一个数字提升到第二个数字的幂。这将执行几个隐藏的乘法运算，并返回最终结果。</li><li id="a336" class="ng nh iq kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated"><strong class="kx ir">整数除法</strong> ( <code class="fe nu nv nw ls b">div</code>):用于完成整数的除法运算，而不需要变成双精度。所有小数都被截断。还有一个模数运算符(<code class="fe nu nv nw ls b">mod</code>)，可以让您找到余数。</li></ul><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="bef3" class="lw lx iq ls b gy ly lz l ma mb">Prelude&gt; div 7 3 <br/>2<br/>Prelude&gt; mod 7 3<br/>1</span></pre><ul class=""><li id="ba3d" class="ng nh iq kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated">类型转换:Haskell不支持跨类型操作，这意味着我们经常要转换值。Prelude包括不同常见类型的类型转换，如<code class="fe nu nv nw ls b">fromIntegral</code>或<code class="fe nu nv nw ls b">fromDouble</code>。</li></ul><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="4df8" class="lw lx iq ls b gy ly lz l ma mb">Prelude&gt; 5.2 + fromIntegral (div 7 3)<br/>7.2</span></pre><h2 id="b2e7" class="lw lx iq bd ml nz oa dn mp ob oc dp mt le od oe mv li of og mx lm oh oi mz oj bi translated">用线串</h2><p id="f184" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">字符串类型表示可以构成单词或短语的一系列字符。它们用双引号括起来，以区别于其他数据类型，比如<code class="fe nu nv nw ls b">“string string”</code>。</p><p id="1fd0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一些基本的字符串函数是:</p><ul class=""><li id="1a07" class="ng nh iq kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated"><strong class="kx ir">连接:</strong>使用<code class="fe nu nv nw ls b">++</code>操作符连接两个字符串</li></ul><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="de05" class="lw lx iq ls b gy ly lz l ma mb">Prelude Data.Char&gt; "hello, " ++ "world" <br/>"hello, world"</span></pre><ul class=""><li id="9aaf" class="ng nh iq kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated"><strong class="kx ir">反转:</strong>反转字符串中字符的顺序，使第一个字符成为最后一个</li></ul><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="8dc9" class="lw lx iq ls b gy ly lz l ma mb">Prelude Data.Char&gt; reverse "hello" <br/>"olleh" </span><span id="36f8" class="lw lx iq ls b gy nx lz l ma mb">Prelude Data.Char&gt; reverse "radar" <br/>"radar"</span></pre><h2 id="11a7" class="lw lx iq bd ml nz oa dn mp ob oc dp mt le od oe mv li of og mx lm oh oi mz oj bi translated">元组</h2><p id="c3c0" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">Tuble类型是一种数据类型，包含预设值的两个链接值。例如，<code class="fe nu nv nw ls b">(5, True)</code>是一个包含整数<code class="fe nu nv nw ls b">5</code>和布尔值<code class="fe nu nv nw ls b">True</code>的元组。它具有元组类型<code class="fe nu nv nw ls b">(Int, Bool)</code>，表示包含第一个<code class="fe nu nv nw ls b">Int</code>值和第二个<code class="fe nu nv nw ls b">Bool</code>值的值。</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="94de" class="lw lx iq ls b gy ly lz l ma mb">twoNumbers :: (Double, Double)<br/>twoNumbers = (3.14, 2.59)<br/>address :: (String, Int, String, Int)<br/>address = ("New York", 10005, "Wall St.", 1)<br/>main = do <br/>  print twoNumbers <br/>  print address</span></pre><p id="110c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">元组构造本质上是一个将两个值链接起来的函数，这样它们就被视为一个值。</p><h2 id="bf25" class="lw lx iq bd ml nz oa dn mp ob oc dp mt le od oe mv li of og mx lm oh oi mz oj bi translated">自定义功能</h2><p id="7a11" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">使用以下定义创建您自己的函数:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="e7e6" class="lw lx iq ls b gy ly lz l ma mb">function_name :: argument_type -&gt; return_type</span></pre><p id="7911" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">函数名是用来调用函数的，参数类型定义了任何输入参数允许的数据类型，返回类型定义了返回值将出现的数据类型。</p><p id="da3c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">定义后，输入一个定义函数行为的等式:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="fc5a" class="lw lx iq ls b gy ly lz l ma mb">function_name pattern = expression</span></pre><p id="a19e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">函数名呼应了更大函数的名称，模式充当占位符，将被输入参数替换，表达式概述了如何使用该模式。</p><p id="b1f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一个函数的定义和公式的例子，这个函数将打印传递的字符串两次。</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="1414" class="lw lx iq ls b gy ly lz l ma mb">sayTwice :: String -&gt; String<br/>sayTwice s = s ++ s<br/>main = print (sayTwice "hello")</span></pre><h2 id="8d54" class="lw lx iq bd ml nz oa dn mp ob oc dp mt le od oe mv li of og mx lm oh oi mz oj bi translated">列表</h2><p id="b55f" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">列表是递归定义的元素序列。像链表一样，每个元素指向下一个元素，直到最后一个元素，最后一个元素指向一个特殊的<code class="fe nu nv nw ls b">nill</code>值来标记列表的结束。</p><p id="4a43" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">列表中的所有元素必须是相同的数据类型，使用方括号定义，如<code class="fe nu nv nw ls b">[Int]</code>或<code class="fe nu nv nw ls b">[String]</code>。然后，用该类型的一系列逗号分隔的值填充列表。一旦被填充，所有值的当前顺序都是不可变的。</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="1744" class="lw lx iq ls b gy ly lz l ma mb">ints :: [Int]<br/>ints = [1, 2, 3]</span></pre><p id="1609" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">列表对于存储以后需要循环的数据很有用，因为它们很容易与递归一起使用。</p><h2 id="082d" class="lw lx iq bd ml nz oa dn mp ob oc dp mt le od oe mv li of og mx lm oh oi mz oj bi translated">自定义数据类型</h2><p id="d317" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">Haskell还允许您创建自己的数据类型，类似于我们创建函数的方式。每种数据类型都有一个名称和一组该类型可接受的期望值。</p><p id="f3e1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了更好地理解这一点，看一下标准库的<code class="fe nu nv nw ls b">Bool</code>类型定义:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="716f" class="lw lx iq ls b gy ly lz l ma mb">data Bool = False | True</span></pre><p id="9b92" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">自定义数据类型用关键字<code class="fe nu nv nw ls b">data</code>标记，并由以下项目命名为<code class="fe nu nv nw ls b">Bool</code>。<code class="fe nu nv nw ls b">=</code>标记了名称和接受值之间的界限。然后<code class="fe nu nv nw ls b">False | True</code>定义类型<code class="fe nu nv nw ls b">Bool</code>的任何值必须为真或假。</p><p id="bffa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类似地，我们可以定义一个自定义的<code class="fe nu nv nw ls b">Geometry</code>数据类型，它接受三种形状，每种形状都有不同的输入要求。</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="fa40" class="lw lx iq ls b gy ly lz l ma mb">data Geometry = Rectangle Double Double | Square Double | Circle Double</span></pre><p id="238a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的<code class="fe nu nv nw ls b">Geometry</code>数据类型允许创建三种不同的形状:矩形、正方形和圆形。</p><p id="44a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些形状是数据构造器，定义了类型为<code class="fe nu nv nw ls b">Geometry</code>的元素的可接受值。A <code class="fe nu nv nw ls b">Rectangle</code>用两个double(它的宽度和高度)来描述，a <code class="fe nu nv nw ls b">Square</code>用一个double(一边的长度)来描述，a <code class="fe nu nv nw ls b">Circle</code>用一个single double(它的半径)来描述。</p><p id="2584" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当创建一个<code class="fe nu nv nw ls b">Geometry</code>值时，您必须声明您希望将哪个构造函数<code class="fe nu nv nw ls b">Rectangle</code>、<code class="fe nu nv nw ls b">Square</code>或<code class="fe nu nv nw ls b">Circle</code>用于您的输入。例如:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="3238" class="lw lx iq ls b gy ly lz l ma mb">*Geometry&gt; s1 = Rectangle 3 5 :: Geometry <br/>*Geometry&gt; s2 = Square 4 :: Geometry<br/>*Geometry&gt; s3 = Circle 7 :: Geometry</span></pre><h2 id="74b6" class="lw lx iq bd ml nz oa dn mp ob oc dp mt le od oe mv li of og mx lm oh oi mz oj bi translated">类型类别</h2><p id="de3d" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">类型类是共享一个公共属性的类型的集合。例如，type class <code class="fe nu nv nw ls b">Show</code>是可以使用<code class="fe nu nv nw ls b">show</code>函数转换成字符串的所有类型的类(注意大小写的不同)。它的语法是:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="5443" class="lw lx iq ls b gy ly lz l ma mb">class Show a where<br/>  show :: a -&gt; String</span></pre><p id="ddca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有类型类声明都以<code class="fe nu nv nw ls b">class</code>关键字、一个名称(<code class="fe nu nv nw ls b">Show</code>)和一个类型变量(<code class="fe nu nv nw ls b">a</code>)开始。<code class="fe nu nv nw ls b">where</code>关键字设置了一个条件，调用所有类型，其中下面的语句等同于<code class="fe nu nv nw ls b">True</code>。在这种情况下，<code class="fe nu nv nw ls b">Show</code>使用接受变量并返回<code class="fe nu nv nw ls b">String</code>的<code class="fe nu nv nw ls b">show</code>函数查找所有类型。</p><p id="dbc6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">换句话说，属于<code class="fe nu nv nw ls b">Show</code>类型类的每个类型<code class="fe nu nv nw ls b">a</code>都必须支持<code class="fe nu nv nw ls b">show</code>功能。类型类的行为类似于面向对象编程语言的接口，因为它们定义了一组数据的蓝图。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="b4be" class="mk lx iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">高级Haskell概念</h1><h2 id="5328" class="lw lx iq bd ml nz oa dn mp ob oc dp mt le od oe mv li of og mx lm oh oi mz oj bi translated">高阶函数</h2><p id="8d8a" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">与其他函数式编程语言一样，Haskell将函数视为一等公民，可以从其他函数传递或返回。作用于或返回新函数的函数称为<em class="ny">高阶函数。</em></p><p id="e955" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以使用高阶函数组合您的模块化函数来完成复杂的运算。这是函数组合的重要部分，其中一个函数的输出作为下一个函数的输入。</p><p id="c764" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">函数<code class="fe nu nv nw ls b">applyTwice</code>将整数函数作为第一个参数，并对第二个参数应用两次。</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="824f" class="lw lx iq ls b gy ly lz l ma mb">applyTwice :: (Int -&gt; Int) -&gt; Int -&gt; Int<br/>applyTwice f x = f (f x)</span></pre><p id="3efe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">括号阐明了第一个<code class="fe nu nv nw ls b">Int</code>集合应该一起理解为一个<code class="fe nu nv nw ls b">Int</code>函数，而不是两个独立的<code class="fe nu nv nw ls b">Int</code>值。</p><p id="f8bf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们将创建一些示例函数，<code class="fe nu nv nw ls b">double</code>和<code class="fe nu nv nw ls b">next</code>，以传递给我们的高阶函数，<code class="fe nu nv nw ls b">applyTwice</code>。</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="86a4" class="lw lx iq ls b gy ly lz l ma mb">applyTwice :: (Int -&gt; Int) -&gt; Int -&gt; Int<br/>applyTwice f x = f (f x)<br/>double :: Int -&gt; Int<br/>double x = 2 * x<br/>next :: Int -&gt; Int <br/>next x = x + 1<br/>main = do <br/>  print (applyTwice double 2) -- quadruples<br/>  print (applyTwice next 1) --adds 2</span></pre><h2 id="f699" class="lw lx iq bd ml nz oa dn mp ob oc dp mt le od oe mv li of og mx lm oh oi mz oj bi translated">λ表达式</h2><p id="5129" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">如果我们想不止一次地使用<code class="fe nu nv nw ls b">double</code>和<code class="fe nu nv nw ls b">next</code>，我们上面的<code class="fe nu nv nw ls b">applyTwice</code>实现是有效的。但是如果这是我们唯一需要这种行为的时候呢？我们不想为一次使用创建一个完整的功能。</p><p id="354f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">相反，我们可以使用Haskell的lambda表达式来创建一个匿名函数。这些基本上是一次性函数，在使用的地方定义了表达式，但是没有保存它的名称。Lambda表达式以其他方式作为带有输入参数和返回值的函数工作。</p><p id="8a70" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，我们可以将我们的<code class="fe nu nv nw ls b">next</code>函数转换成一个lambda表达式:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="91b8" class="lw lx iq ls b gy ly lz l ma mb">\x -&gt; x + 1</span></pre><p id="c8d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Lambda表达式总是以反斜杠(<code class="fe nu nv nw ls b">\</code>)开始，然后为函数<code class="fe nu nv nw ls b">x</code>的输入列出一个占位符。然后有一个箭头函数来标记表达式的开始。该表达式在调用<code class="fe nu nv nw ls b">x</code>时使用输入参数。</p><p id="64c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里，我们的lambda表达式本质上是说，“将<code class="fe nu nv nw ls b">1</code>添加到传递给我的任何输入中。然后，返回新值。</p><p id="9157" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还可以使用lambda表达式作为高阶函数的输入。下面是我们的<code class="fe nu nv nw ls b">applyTwice</code>函数如何处理lambda表达式而不是函数:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="63db" class="lw lx iq ls b gy ly lz l ma mb">applyTwice :: (Int -&gt; Int) -&gt; Int -&gt; Int<br/>applyTwice f = f . f<br/>main = do <br/>  print (applyTwice (\x -&gt; x * 2) 8)<br/>  print (applyTwice (\x -&gt; x + 1) 7)</span></pre><p id="8591" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Lambda表达式通常用于为高阶函数提供简单的行为，您不希望将这些行为保存到函数中，或者只需要一次。您还可以通过将它们提供给抽象的高阶函数，使用它们来概述程序的一般逻辑模式。</p><h2 id="9a83" class="lw lx iq bd ml nz oa dn mp ob oc dp mt le od oe mv li of og mx lm oh oi mz oj bi translated">递归</h2><p id="6dd9" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">像Haskell这样的函数式语言不像命令式语言那样有循环或条件语句。相反，他们使用递归来创建重复的行为。这是因为递归结构是声明性的，就像函数式编程一样，因此更适合。</p><blockquote class="ok ol om"><p id="ee84" class="kv kw ny kx b ky kz jr la lb lc ju ld on lf lg lh oo lj lk ll op ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="iq">提醒:</em> </strong> <em class="iq">递归函数是反复调用自身直到达到指定程序状态的函数。</em></p></blockquote><p id="3cb2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是Haskell中递归函数的一个例子:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="73c7" class="lw lx iq ls b gy ly lz l ma mb">compoundInterest :: Int -&gt; Double<br/>compoundInterest 0 = 1000<br/>compoundInterest n = 1.05 * compoundInterest (n - 1)<br/>main = print (compoundInterest 3)</span></pre><p id="5bf3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第一个等式涵盖了输入值为<code class="fe nu nv nw ls b">0</code>时执行的基本情况，并立即产生结果<code class="fe nu nv nw ls b">1000</code>。第二个等式是递归情况，它使用输入值<code class="fe nu nv nw ls b">n - 1</code>的计算结果来计算输入值<code class="fe nu nv nw ls b">n</code>的结果。</p><p id="f280" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看看这个递归函数是如何对每个递归步骤求值的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/7849e79aa01d0ef703ffd5360e36157a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/0*9KkxsrEfKM8s7qqU.PNG"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="af37" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从循环到递归结构的转换是采用Haskell时最难做出的改变之一。复杂的递归结构会导致深度嵌套效应，这可能会使理解或调试变得混乱。</p><p id="70df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，Haskell通过要求纯函数和使用惰性求值来避免执行顺序问题，最大限度地降低了这个问题的严重性。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="0807" class="mk lx iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">接下来学什么</h1><p id="dcd1" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">祝贺您迈出了学习Haskell的第一步！虽然从命令式/通用语言(如JavaScript、Perl或PHP)迁移到Haskell是一个挑战，但是有几十年的学习资料可以帮助你。</p><p id="e557" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">接下来你要学习的一些概念是:</strong></p><ul class=""><li id="210b" class="ng nh iq kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated">单子表达式</li><li id="6669" class="ng nh iq kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">Currying</li><li id="5a35" class="ng nh iq kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">多次递归调用</li><li id="9a95" class="ng nh iq kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">输入输出集成</li></ul><p id="54d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">快乐学习！</p></div></div>    
</body>
</html>