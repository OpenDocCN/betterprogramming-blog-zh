# 在 Python 中停止使用这样的异常

> 原文：<https://betterprogramming.pub/stop-using-exceptions-like-this-in-python-2bd8ba7d8841>

## Python 中要避免的四个常见错误处理错误

![](img/7d5367769791bb35328abfd68e623718.png)

[rom son preech wit](https://unsplash.com/@woodies11?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照。

假设你正在开发一个博客应用程序。在博客应用的正常流程中，用户可以注册并创建博客文章。

当您的应用程序的正常流程意外中断时，就会发生异常(错误)。例如，当一个用户在你的博客网站上注册了一个现有的电子邮件。

异常处理意味着作为应用程序开发人员，要决定如何处理这种中断。例如，在这个场景中，我们可以简单地向用户返回一个错误消息，向我们的日志系统写入一个错误，等等。

错误处理是构建任何应用程序的基本部分，因为它使我们的代码更易于维护。

要在 Python 中引发异常，我们可以简单地执行以下操作:

```
raise ValueError("Something has gone wrong.")
```

在本文中，我打算与您分享一些 Python 错误处理技巧和一些要避免的常见坏习惯。

## TL；速度三角形定位法(dead reckoning)

*   千万不要使用裸露的`except`
*   避免捕捉或引发泛型`Exception`
*   不要只是路过`except`街区

# 1.避免裸露，除非

第一条经验法则是绝对避免使用 bare `except`，因为它不会给我们任何要检查的异常对象。

再者，使用 bare `except`还可以捕捉所有异常，包括我们一般不想要的异常，比如`SystemExit`或者`KeyboardInterrupt`。

这里有一个使用 bare `except`的例子，不推荐使用:

永远不要使用 bare，除非。

## 那么，捕捉每个异常有什么错呢？

捕捉每一个异常都可能导致我们的应用程序失败，而我们却不知道原因。对于调试来说，这是一个可怕的想法。

这里有一个例子:我们正在构建一个允许用户上传 PDF 文件的功能。假设我们在代码块周围放了一个泛型`try-catch`。

下面，我们捕捉到一个通用异常，表示无论实际问题是什么，都找不到文件:

为什么我们不应该提出或抓住一个通用`Exception.`的例子

不管实际问题是什么(例如，端点是只读的、没有权限或无效的文件类型)，任何人在上传文件时遇到问题都会返回一个错误，声称找不到文件。

现在假设文件被上传了，但是用户上传了一个图像文件。用户不断返回“文件未找到”的错误，因为他们重试和重试。最终，他们开始尖叫，“文件就在那里！这个 app 就是个垃圾！”

或者，处理这种情况的正确方法是引入特定的异常类来处理提到的所有三种情况。

# 2.停止使用引发异常

其次，我们应该避免在 Python 中使用泛型`Exception`,因为它容易隐藏 bug。

这里还有一个你应该避免使用的例子:

避免这种[错误隐藏](https://en.wikipedia.org/wiki/Error_hiding)反模式！

虽然有很多方法可以编写糟糕的代码，但这是最糟糕的反模式之一(称为错误隐藏)。

根据我的个人经验，这种模式已经成为开发人员生产力的最大消耗。

# 3.停止使用 except 异常

作为开发人员，我们倾向于在自动驾驶模式下用一个`try-except`块包装我们的函数代码。我们喜欢这样做，因为我们知道总是有可能抛出异常。

再安全也不为过，对吧？

停止使用`except Exception`！

然而，需要注意的是，开发人员倾向于用通用的`BaseException`或`Exception`类来捕捉异常。

在这种情况下，这意味着我们将抓住*一切。*一切包括我们不能或者也许不应该从中恢复的异常。

## 计划，计划，计划

相反，我们应该总是提前计划，并弄清楚什么会中断，以及预计会抛出什么异常。

例如，如果我们使用数据库调用通过电子邮件获取用户配置文件，我们应该预料到电子邮件可能不存在，并相应地处理它。

在这种情况下，我们可以引发一个自定义的`UserDoesNotExist`错误，并提示我们的用户再试一次，让我们的应用程序从异常中积极恢复。

下面是一个关于如何在 Python 中引发自定义用户定义的异常的非常基本的例子:

```
class UserDoesNotExist(Exception):
    """Raised when user does not exist"""
    pass
```

在编写我们自己的自定义用户定义异常之前，我们应该总是检查我们正在使用的库是否有符合我们用例的内置异常。

简而言之，我们应该只用语义上符合我们用例的特定`[Exception](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)`来捕捉我们感兴趣的错误。

最后，这里有一个如何正确处理异常的更好的例子:

我们可以添加更具体的异常来处理不同的异常。

## 但是，我不知道使用什么异常

可以理解的是，我们不可能总是为每一个可能的例外做好准备。

在这种情况下，一些人建议我们至少应该用`Exception`来捕捉它们，因为它不会包括像`GeneratorExist`、`SystemExit`和`KeyboardInterrupt`这样的东西，它们会终止我们的应用程序。

我认为我们应该花些时间来弄清楚有哪些例外。当捕捉一般异常成为一种习惯时，它就成了一条不归路。

这里有另一个很好的[例子](https://stackoverflow.com/a/736029/10067850)来说明为什么我们不应该捕捉泛型异常。

# 4.除了街区之外，不要进入

当设计一个应用程序时，可能会有一些特殊的例外，我们什么都不用做就可以很好地完成。

然而，开发人员可能做的最糟糕的事情是:

一个我们不应该使用的坏例子

上面的代码暗示，尽管我们没有为任何异常做好准备，但我们愿意捕捉任何异常。

传递和捕捉`Exception`(或 bare `except`)的另一个缺点是，当代码中有两个错误时，我们永远不会知道第二个错误。第一个错误将总是首先被捕获，我们将离开`try`块。

如果我们只是传递一个`except`语句，这是一个很好的迹象，表明我们没有真正为我们正在捕捉的异常做好准备。也许现在是重新思考和重构的好时机。

## 日志，不要通过

然而，如果我们不必对异常做任何事情，我们至少应该在记录异常的同时使用一个更具体的异常。

日志，不要过！

除了考虑包含一些恢复代码，我们还可以添加一个注释来通知其他开发人员关于用例的信息。

底线是，除非明确需要，否则我们应该避免传入`except`块。同样，这通常是一个不好的迹象。

最终，我们应该将异常记录到一个监控系统中，这样我们至少有一个实际出错的日志。

# 结束语

为了总结我们在本文中所经历的一切，我们应该:

*   千万不要用裸露的`except`。
*   停止提升通用`Exception`。
*   停止捕捉通用`Exception`。
*   避免通过`except`区块。

在大多数情况下，应用程序在异常点失败通常比我们的应用程序继续以奇怪的意外方式运行要好。因此，最好只捕捉我们知道并打算处理的异常。

仅此而已！编码快乐！

## [最初发表于 jerrynsh.com](https://jerrynsh.com/stop-using-exceptions-like-this-in-python/)

[](/3-useful-python-f-string-tricks-you-probably-dont-know-f908f7ed6cf5) [## 你可能不知道的 3 个有用的 Python f-string 技巧

### 关于 Python 的格式化字符串(f-string)你需要知道的事情

better 编程. pub](/3-useful-python-f-string-tricks-you-probably-dont-know-f908f7ed6cf5) [](/tuples-vs-lists-vs-sets-in-python-3dff8a7b1f02) [## Python 中的元组、列表和集合

### 你可能一直都用错了

better 编程. pub](/tuples-vs-lists-vs-sets-in-python-3dff8a7b1f02)