<html>
<head>
<title>React Gets First Class Support for Async/Await — Yay or Meh?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React获得了对Async/Await的一流支持——Yay还是Meh？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-gets-first-class-support-for-async-await-yay-or-meh-8bab1ff471b4?source=collection_archive---------0-----------------------#2022-10-24">https://betterprogramming.pub/react-gets-first-class-support-for-async-await-yay-or-meh-8bab1ff471b4?source=collection_archive---------0-----------------------#2022-10-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f01b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">React RFC草案提案对数据加载的支持</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/76020e85a719460c07a22abda3308d32.png" data-original-src="https://miro.medium.com/v2/format:webp/0*PKwSaZq78LwwvJJa.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="f576" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当团队在React <code class="fe lq lr ls lt b">16.6</code>上引入<code class="fe lq lr ls lt b">Suspense</code>时，React对Async/Await的一流支持的第一个基石就开始了。当时，还没有并发模式，其功能也很有限。挂起的组件会呈现出来，只是隐藏在DOM上。它被称为<code class="fe lq lr ls lt b">Legacy Suspense</code>。</p><p id="1821" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Suspense</code>将成为所有其他API依赖的重要机制。</p><p id="47e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当并发模式登陆后，<code class="fe lq lr ls lt b">Suspense</code> API得到了增强:</p><ul class=""><li id="c9f4" class="lu lv it kw b kx ky la lb ld lw lh lx ll ly lp lz ma mb mc bi translated">React组件的执行被“暂停”。在<code class="fe lq lr ls lt b">ComponentThatSuspends</code>解决之前<code class="fe lq lr ls lt b">Element</code>不会安装。</li><li id="ed0b" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">效果/生命周期被正确触发。</li></ul><p id="d99b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到目前为止，延迟加载组件是唯一受<code class="fe lq lr ls lt b">Suspense</code>支持的用例。React团队已经花了很长时间来弄清楚如何将数据加载与<code class="fe lq lr ls lt b">Suspense</code>融合在一起。在这份公布的RFC草案中，我们终于可以看到他们计划如何构建它。</p><h1 id="b1b2" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">数据提取暂停</h1><p id="bcf1" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">React团队采用的方法非常传统，但有所改变。</p><p id="3fc3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">他们选择以两种方式实现这一特性:</p><ul class=""><li id="04d5" class="lu lv it kw b kx ky la lb ld lw lh lx ll ly lp lz ma mb mc bi translated">React客户端:通过引入一个<code class="fe lq lr ls lt b">use</code>钩子</li><li id="6d29" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">React服务器组件:支持本机<code class="fe lq lr ls lt b">async/await</code> Es7语法。</li></ul><h2 id="1019" class="nf mj it bd mk ng nh dn mo ni nj dp ms ld nk nl mu lh nm nn mw ll no np my nq bi translated">使用挂钩</h2><p id="f3aa" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">这个钩子就像它的名字一样充满争议。他们选择了这个特别的名字，试图将其与其他名字区分开来。为什么？因为这个钩子不一样:<strong class="kw iu">它可以有条件的运行</strong>。</p><p id="2817" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">仅仅这一点就打破了我们在过去几年中学到的整个钩子概念。React团队是如何将这个想法灌输到我们的头脑中的，这是非常了不起的。丹·阿布拉莫夫甚至在一篇著名的文章中详细解释了原因。</p><p id="f7d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如何有条件地调用<code class="fe lq lr ls lt b">use</code>钩子？因为简化了，它只是抛出一个被最近的<code class="fe lq lr ls lt b">Suspense</code>父级捕获的<code class="fe lq lr ls lt b">Promise</code>。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="d690" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种方法的警告是什么？与<code class="fe lq lr ls lt b">async/await</code>不同，React组件不会从停止的地方恢复。相反，挂起的组件将被重新呈现。这是React组件幂等的副作用，多么讽刺。</p><p id="ed4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们举一个新的<code class="fe lq lr ls lt b">use</code>钩子的例子:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="nu nt l"/></div></figure><p id="75d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的代码看起来简单且容易推理。只有一个条件。<code class="fe lq lr ls lt b">&lt;Test /&gt;</code>组件会无休止地重新渲染。</p><p id="6a74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么？如前所述，通过抛出类似承诺的异常来“暂停”渲染。当承诺被解决时，整个组件将被重新呈现。这意味着将再次调用<code class="fe lq lr ls lt b">fetchData</code>方法，这将导致另一次重新渲染，依此类推。</p><p id="584f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可能的解决方法是什么？</p><ul class=""><li id="c9a3" class="lu lv it kw b kx ky la lb ld lw lh lx ll ly lp lz ma mb mc bi translated">为已解析的承诺创建缓存机制。</li><li id="c48f" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">等待并使用React团队正在开发的<code class="fe lq lr ls lt b">cache</code> API。人体工程学将会像<code class="fe lq lr ls lt b">use(cache(fetchData))</code>一样增加组合的复杂性。</li></ul><p id="7b38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">T4的API还没有看到草案。该功能最有可能在<code class="fe lq lr ls lt b">use</code>功能发布后登陆。</p><h2 id="beb9" class="nf mj it bd mk ng nh dn mo ni nj dp ms ld nk nl mu lh nm nn mw ll no np my nq bi translated">服务器组件上的异步/等待</h2><p id="e2b5" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">在服务器组件中实现数据获取的方式略有不同。React团队声称，这可能会产生积极的影响，因为它迫使开发人员更加小心。他们为什么这么说？因为服务器组件有一些必须牢记的限制。</p><p id="1a7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">服务器组件将能够使用标准的<code class="fe lq lr ls lt b">async/await</code>语法。这里，他们没有违反服务器组件不能访问钩子的规则。他们已经用<code class="fe lq lr ls lt b">useId</code>钩弯过一次了。</p><p id="dc8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个例子:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="nu nt l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">摘自RFC提案的React代码示例</p></figure><p id="6399" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以上似乎更自然，也更容易推理。为什么React客户端不使用该解决方案？有一些陷阱需要解决。简而言之，它与<code class="fe lq lr ls lt b">async</code>方法如何工作有关，而且它们将在每次执行时返回一个新的承诺。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="nu nt l"/></div></figure><p id="facb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这可能会导致任意属性挂起用户界面。更多详情<a class="ae nr" href="https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md#reading-the-result-of-a-promise-during-an-unrelated-update" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><h1 id="3ba6" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">怎么可能有戏？</h1><p id="e476" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">React有三个释放通道:</p><ul class=""><li id="602d" class="lu lv it kw b kx ky la lb ld lw lh lx ll ly lp lz ma mb mc bi translated"><code class="fe lq lr ls lt b"><strong class="kw iu">latest</strong></code>:针对稳定的反应释放。这是所有production React应用程序使用的通道。</li><li id="5b8e" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated"><code class="fe lq lr ls lt b"><strong class="kw iu">Next</strong></code>:你可以把这个当做发布候选通道。第三方项目大多使用。</li><li id="f57d" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated"><code class="fe lq lr ls lt b"><strong class="kw iu">Experimental</strong></code>:稳定版本中没有的API和特性。这是为了试用新版本，因为它们已经发布。你可以把它看作是一个早期的预览。</li></ul><p id="2551" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">N <em class="nv">注:只有</em> <code class="fe lq lr ls lt b"><em class="nv">latest</em></code> <em class="nv">通道使用语义版本化。</em> <code class="fe lq lr ls lt b"><em class="nv">next</em></code> <em class="nv">和</em> <code class="fe lq lr ls lt b"><em class="nv">experimental</em></code> <em class="nv">根据其内容的散列和提交日期进行标记。</em></p><p id="c636" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我们可以继续安装最新的<code class="fe lq lr ls lt b">experimental</code>版本来快速预览一下<code class="fe lq lr ls lt b">use</code>钩子。请注意，独家发布的<code class="fe lq lr ls lt b">experimental</code>改动可能与最终的React有所不同。因此，期待突破性的变化，它不应该在面向用户的应用程序中使用。</p><p id="ee99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">安装非常简单:</p><pre class="ki kj kk kl gt nw lt nx ny aw nz bi"><span id="20c4" class="nf mj it lt b gy oa ob l oc od">yarn upgrade react@<strong class="lt iu">experimental</strong> react-dom@<strong class="lt iu">experimental</strong></span></pre><p id="d14e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完成后，您可以通过使用以下命令开始使用新的草案API</p><pre class="ki kj kk kl gt nw lt nx ny aw nz bi"><span id="4f50" class="nf mj it lt b gy oa ob l oc od">import {<strong class="lt iu">experimental_use as use</strong>} from 'react';</span></pre><h1 id="2239" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">我的两分钱</h1><p id="7012" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">我知道React团队正朝着设计接口的方向努力，这样我们就可以摆脱加载旋转器的困境。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1b3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是通过将数据获取与所有现有的<code class="fe lq lr ls lt b">Suspense</code>API(如<code class="fe lq lr ls lt b">useTransition</code> / <code class="fe lq lr ls lt b">useDeferred</code>)相结合来实现的……用户将真正受益于不会到处持续显示无关加载状态的界面。他们的浏览器也将受益于不执行组件代码，这些代码会在片刻之后被丢弃。</p><p id="c7f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最令人担忧的是React的学习曲线变得更加陡峭。开发人员越来越难以理解和记住每个钩子是如何工作的。更糟糕的是，他们不仅在规则中增加了更多的例外，还根据执行环境改变了语法。理解React代码变得非常具有挑战性。</p><p id="7118" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">令人惊讶的是，这一切都隐藏在这个简化的界面后面，我们有一种错觉，认为我们在构建纯粹的功能。</p><p id="a38a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个谜题之所以有效，是因为我们遵守了一些很久以前就开始变得毫无意义的规则。我们如何到达这里？一切都是逐渐发生的。它让我想起了青蛙和沸水的故事。我们现在必须意识到实现细节，而不是消耗声明性API。当谈到勾手时，我们的大脑必须做大量的体操。</p><p id="e996" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么解决办法是什么呢？对我来说，React编译器似乎是唯一的解决方案。让我们以他们基于性能的优化API为例。<code class="fe lq lr ls lt b">useCallback</code> / <code class="fe lq lr ls lt b">useMemo</code>挂钩应该有助于提高性能。然而，仍然不确定我们希望在哪里使用它们，以及它们何时会增加一些开销。</p><p id="792a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你能想象没有备忘录API的React吗？构建<code class="fe lq lr ls lt b">React Forget</code>编译器是为了将开发者从记忆API中抽象出来。在<code class="fe lq lr ls lt b">React Conf 2021</code>预演过。它仍处于初始阶段，但有望很快着陆。在我看来，这是朝着正确方向迈出的一大步。</p><p id="79f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有希望的是，React团队发布并开始扩展编译器的想法。看起来客户端<code class="fe lq lr ls lt b">async/await</code>的特性和更多的特性可以通过编译器实现。一种想法是编译<code class="fe lq lr ls lt b">async/await</code>，将组件数据加载到类似生成器的运行时中。这将通过保持一些良好的开发人员工效学来解决问题。</p><p id="e198" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与此同时，继续积累生态系统的逻辑和细微差别变得更加困难。这确实挫败了他们的座右铭，让曾经简单的UI库变得令人头疼。</p><p id="1a86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nv">RFC建议书原文可以在</em> <a class="ae nr" href="https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md#why-cant-client-components-be-async-functions" rel="noopener ugc nofollow" target="_blank"> <em class="nv">这里找到</em> </a></p></div></div>    
</body>
</html>