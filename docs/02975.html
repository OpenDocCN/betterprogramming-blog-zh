<html>
<head>
<title>9 Ways to Work With Objects in JavaScript in 2020</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2020年JavaScript中使用对象的9种方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/9-ways-to-work-with-objects-in-javascript-in-2020-d772c29db429?source=collection_archive---------4-----------------------#2020-01-13">https://betterprogramming.pub/9-ways-to-work-with-objects-in-javascript-in-2020-d772c29db429?source=collection_archive---------4-----------------------#2020-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d2df" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">物体永远不会死亡</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/646b88f16b12da39689535d20ed8e819.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wntxTbdvwUUAs0YES5T48w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">照片由</em> <a class="ae kz" href="https://unsplash.com/@_ferh97" rel="noopener ugc nofollow" target="_blank"> <em class="ky">费尔南多·埃尔南德斯</em> </a> <em class="ky">上</em> <a class="ae kz" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> <em class="ky">下</em> </a></p></figure><p id="544f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">像许多其他语言一样，JavaScript有很多技巧来完成简单和困难的任务。让我们看看2020年使用JavaScript对象的九种方式。</p><p id="12da" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">注意:这是一个列表，我认为这是一个很好的处理对象的简短列表。有些是有趣的，有些是众所周知的，有些只是为了提供信息。</p><p id="dc99" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">无论如何，如果你喜欢用JavaScript编码，那么你可能会同意我的观点，使用对象比使用其他类型有趣得多。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6cee" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">1.如何真正创建一个空对象</h1><p id="b68b" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">你知道你可以用JavaScript创建对象吗？你当然有！</p><p id="daf1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你还知道你可以创建空的对象吗？</p><p id="2354" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里有一个例子:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="1c06" class="nf me it nb b gy ng nh l ni nj">const myEmptyObject = {}</span></pre><p id="8fa8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这是在创建普通的空对象时所能达到的最好效果。然而，在内部，它并不是真正的空，因为你本质上做的是类似于<code class="fe nk nl nm nb b">Object.create(Object.prototype)</code>的事情。这将为您创建一个对象，它可以访问位于原型链顶端的<code class="fe nk nl nm nb b">Object.prototype</code>中的属性。</p><p id="8863" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这意味着你将能够使用像<code class="fe nk nl nm nb b">myEmptyObject.toString()</code>这样的方法。</p><p id="1ea4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">要真正创建一个空对象，你只需要在使用它的时候传入<code class="fe nk nl nm nb b">null</code>:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5139" class="nf me it nb b gy ng nh l ni nj">const myTrulyEmptyObject = Object.create(null)</span></pre><p id="39b4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当您使用上面的方法创建对象时，在您自己添加属性之前，属性实际上是不存在的。</p><p id="6920" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">99.99%的情况下，我不会推荐这样做，因为没有理由不从基本原型开始。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f10e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">2.合并对象变体#1 ( <code class="fe nk nl nm nb b">Object.assign</code>)</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ee43" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当您使用<code class="fe nk nl nm nb b">Object.assign</code>方法时，您需要一个<code class="fe nk nl nm nb b">target</code>对象作为合并附加对象和/或属性的对象。</p><p id="0866" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">目标对象是<code class="fe nk nl nm nb b">Object.assign</code>的第一个参数。从第二个参数开始，其后的任何参数都将被合并到目标对象中。</p><p id="b46f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下面是Mozilla对该方法的官方定义:</p><blockquote class="np nq nr"><p id="f189" class="la lb ns lc b ld le ju lf lg lh jx li nt lk ll lm nu lo lp lq nv ls lt lu lv im bi translated">Object.assign()方法将所有可枚举的自身属性从一个或多个源对象复制到目标对象。它返回目标对象。</p></blockquote></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b378" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">3.合并对象变体#2(扩展语法)</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="fbe9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当您以这种方式合并对象时，您是在对象文字上使用spread运算符。</p><p id="8d46" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这种语法被纳入了ECMAScript 2018官方规范，因此对一些人来说，它可能仍然是一种新的补充。</p><p id="208c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">以这种方式合并多个对象非常简单，许多人推荐这种方式，因为您的代码仍然可以保持整洁和可读性，因为您所要做的就是键入三个点。仅此而已。</p><p id="6068" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">请记住，合并对象的规则仍然保持不变，所以您可以使用最奇怪的方式将对象合并在一起，就像这样:</p><h2 id="444f" class="nf me it bd mf nw nx dn mj ny nz dp mn lj oa ob mp ln oc od mr lr oe of mt og bi translated">扩展生命函数</h2><p id="bc2a" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">JavaScript中的函数在很多方面都很强大。你几乎可以用它们做任何事情。这是由于JavaScript中函数的本质——它们本质上是一等公民，所以你可以把它们扔到任何地方，随心所欲地进行破坏。</p><p id="5034" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">例如，由于JavaScript中的函数仍然是对象，所以您仍然可以将函数视为对象，这意味着您可以随意使用它们，并用它们做一些令人惊奇的事情。</p><p id="da2c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您甚至可以用奇怪的方式将它们合并到对象文字中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8adc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因为IIFEs是自调用的，所以我们立即返回一个将被合并到<code class="fe nk nl nm nb b">icons</code>对象中的对象。结果将是相同的对象，但是合并了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9cc7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">4.2020年检查现有房产</h1><p id="4d5a" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">一个绝对会在社区中掀起风暴的特性是<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank">可选链接</a>。这个新的操作符采用了<code class="fe nk nl nm nb b">.?</code>的形式，允许读取一个位于连接对象链深处的属性值，而不必明确验证链中的每个引用都是有效的。</p><p id="c1a5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这意味着如果你有任何深度嵌套的对象结构，如下所示:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="b4e5" class="nf me it nb b gy ng nh l ni nj">const food = {<br/>  fruits: {<br/>    apple: {<br/>      dates: {<br/>        expired: '2019-08-14',<br/>      },<br/>    },<br/>  },<br/>}</span></pre><p id="9e4e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">…您不再需要编写重复的代码，例如:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e407" class="nf me it nb b gy ng nh l ni nj">function getAppleExpirationDate(obj) {<br/>  if (food.fruits &amp;&amp; food.fruits.apple &amp;&amp; food.fruits.apple.dates) {<br/>    return food.fruits.apple.dates.expired<br/>  }<br/>}</span></pre><p id="b6d0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">使用可选的链接会变得容易得多:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="1ed3" class="nf me it nb b gy ng nh l ni nj">function getAppleExpirationDate(obj) {<br/>  return food?.fruits?.apple?.dates?.expired<br/>}</span></pre><p id="d0b5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在你的代码中到处使用它感觉更干净。</p><p id="f14a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">像这样的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d19a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">…可以很容易地变成这样，同时保持其可读性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="bd30" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这只会让你比以往更欣赏<a class="ae kz" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank">更漂亮的</a>。</p><p id="b7f3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">注意:</strong>在撰写本文时，并不是所有的现代浏览器都支持这个特性。但是你现在可以使用<a class="ae kz" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>并开始你想要的可选链接，因为它被编译回旧浏览器可以阅读的语法。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0471" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">5.通过覆盖<code class="fe nk nl nm nb b">.toString()</code>调用对象</h1><p id="c141" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">当对象被指定为对象文字的键时，它们被字符串化。这带来了一些很好的用例。</p><p id="0e83" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们看看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f059" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您运行这个代码片段，您将看到代码工作，结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/464ba2e196b27f09f2f87a7b90ea22c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/0*_QSjnAAok8r84M68.jpg"/></div></figure><p id="caf2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您仔细观察我们添加命令的方式，您会发现它应该会抛出如下错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/cb0db2b5577f1e3a43662ab339c79f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xZkfxO1ITw9agRUp.jpg"/></div></div></figure><p id="fdab" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">之所以没有，是因为当我们定义<code class="fe nk nl nm nb b">Command</code>构造函数时，我们也覆盖了<code class="fe nk nl nm nb b">toString</code>原型方法，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/69b3dfea4a4c9f629166f5a634a72fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NusxMU9zn7QJ0xl8.jpg"/></div></div></figure><p id="ba7d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当非主类型值被指定为对象的属性时，JavaScript试图在将它们作为键附加之前对它们进行字符串化，方法是返回到原型上的<code class="fe nk nl nm nb b">.toString</code>方法。</p><p id="f40b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><a class="ae kz" href="https://redux-toolkit.js.org/" rel="noopener ugc nofollow" target="_blank"> @reduxjs/toolkit </a>就用了这一招，允许将动作直接作为键传递。例如，它们可以直接用作键，从而映射分配给动作的<code class="fe nk nl nm nb b">.type</code>值的reducer函数。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f145" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">6.解构</h1><p id="6fd6" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">在该语言的众多重要新增功能中，有一项是对象析构:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="dcd7" class="nf me it nb b gy ng nh l ni nj">const obj = {<br/>  foods: {<br/>    apples: ['orange', 'pineapple'],<br/>  },<br/>}</span><span id="663d" class="nf me it nb b gy ok nh l ni nj">const { foods } = obj</span><span id="d7fd" class="nf me it nb b gy ok nh l ni nj">console.log(foods) <em class="ns">// apples: ["orange", "pineapple"]</em></span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="dec8" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">7.重命名析构属性</h1><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="133b" class="nf me it nb b gy ng nh l ni nj">const obj = {<br/>  foods: {<br/>    apples: ['orange', 'pineapple'],<br/>  },<br/>}</span><span id="50d7" class="nf me it nb b gy ok nh l ni nj">const { foods: myFoods } = obj</span><span id="eac7" class="nf me it nb b gy ok nh l ni nj">console.log(myFoods) <em class="ns">// apples: ["orange", "pineapple"]</em></span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3f4a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">8.迭代对象的键(<code class="fe nk nl nm nb b">for in</code>)</h1><p id="011d" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">迭代对象的键的一个简单方法是使用<code class="fe nk nl nm nb b">for in</code>语法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4e46" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">9.迭代对象的键变体#2 ( <code class="fe nk nl nm nb b">Object.keys</code>)</h1><p id="608f" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">您可以使用的另一种方法是使用<code class="fe nk nl nm nb b">Object.keys</code>方法:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="70f4" class="nf me it nb b gy ng nh l ni nj">const obj = {<br/>  foods: {<br/>    apples: ['orange', 'pineapple'],<br/>  },<br/>  water: {<br/>    f: '',<br/>  },<br/>  tolupa: function() {<br/>    return this.name<br/>  },<br/>}</span><span id="2196" class="nf me it nb b gy ok nh l ni nj">const { foods } = obj</span><span id="55c2" class="nf me it nb b gy ok nh l ni nj">const keys = Object.keys(obj)<br/>console.log(keys)</span></pre><p id="423d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里的区别是，你将在你将要工作的数组中接收密钥。</p><p id="6f07" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果你想做额外的事情，比如链接操作和转换成更结构化的值，这也更方便——这是更有用的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d867" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="31d3" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">这就是这篇文章的结尾。我希望你发现这是有价值的。以后多多关照！</p></div></div>    
</body>
</html>