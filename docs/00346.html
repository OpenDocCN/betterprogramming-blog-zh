<html>
<head>
<title>SPA Functional Reactive Programming Using Mithril and Most Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Mithril和Most核心的SPA功能反应式编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/spa-functional-reactive-programming-60fe13639f33?source=collection_archive---------0-----------------------#2019-04-28">https://betterprogramming.pub/spa-functional-reactive-programming-60fe13639f33?source=collection_archive---------0-----------------------#2019-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0ddc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">单页应用程序(SPA)的近期历史见证了反应式编程(RA)作为主导开发范例的兴起(T2)。基于事件流的概念，反应范式是一种声明性的方式来管理应用程序状态的变化(相对于传统的<a class="ae ko" href="https://en.wikipedia.org/wiki/Imperative_programming" rel="noopener ugc nofollow" target="_blank">命令式编程</a>)。流(也称为可观察的)是一种反应式数据结构，类似于电子表格应用程序中的单元格。当您更改一个值时(生成一个表示值更改的事件)，该事件会在所有相关“单元”上传播，并在必要时更新相关值。我们可以有多种口味的流:<a class="ae ko" href="http://vindum.io/blog/behaviors-and-streams-why-both/" rel="noopener ugc nofollow" target="_blank">连续/离散</a>、<a class="ae ko" href="https://staltz.com/why-we-actually-built-xstream.html" rel="noopener ugc nofollow" target="_blank">热/冷</a>、<a class="ae ko" href="https://mostcore.readthedocs.io/en/latest/concepts.html#event-propagation" rel="noopener ugc nofollow" target="_blank">同步/异步</a>等。</p><blockquote class="kp kq kr"><p id="6d15" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">反应式编程就像一个电子表格:当某个东西发生变化时，所有依赖于它的东西都会自动变化，以此类推。</p></blockquote><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi kw"><img src="../Images/5585028b4a9350945056c3d84fa8e0c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VOhhuruYSNQSiiuD"/></div></div><p class="li lj gj gh gi lk ll bd b be z dk translated"><a class="ae ko" href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" rel="noopener ugc nofollow" target="_blank">(差不多)<em class="lm">一切都可以是流</em> </a>！照片由<a class="ae ko" href="https://unsplash.com/@matthewhenry?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马太·亨利</a>在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="f399" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">函数式编程的优势</h2><p id="767d" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">软件开发中另一个正在进行的革命是对<a class="ae ko" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a> (FP)相对于<a class="ae ko" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank">面向对象编程</a> (OOP)的优势的认识。几十年来，OOP被视为编程和开发软件的最佳方式，而FP则被降级为学术的、不切实际的选择。</p><p id="9381" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，不可变状态、<a class="ae ko" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank">幂等性、纯度</a>、副作用隔离和函数可组合性的明显优势，以及成功的FP语言(Haskell、OCaml、JavaScript FP扩展等)的兴起，将渗透到工业软件开发中。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ml"><img src="../Images/4292cb5617b1dc6307cdf460c235d583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qmda_BlDRvoXDGj6"/></div></div><p class="li lj gj gh gi lk ll bd b be z dk translated">纯洁很难，但你不会后悔。由<a class="ae ko" href="https://unsplash.com/@isaacmsmith?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾萨克·史密斯</a>在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="6b96" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">FP + RP = FRP幸福</h2><p id="d1f7" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">将RP和FP混合在一起，我们得到了f<a class="ae ko" href="https://en.wikipedia.org/wiki/Functional_reactive_programming" rel="noopener ugc nofollow" target="_blank">functional reactive programming</a>(FRP)，这是开始我们未来的、革命性的web项目(或者至少是它的一部分)的一个很好的组合。</p><p id="9443" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">FRP结合了类似电子表格的状态管理的有效性和FP的所有优点:不变性、纯度、可组合性等。</p><h2 id="da2a" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">Cycle.js</h2><p id="120a" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">在寻找FRP JavaScript框架的圣杯的过程中，今天，我们的目的地显然是<a class="ae ko" href="https://cycle.js.org" rel="noopener ugc nofollow" target="_blank"> Cycle.js </a>。我不会太深入这个框架，但是Cycle无疑是关于FRP的最佳选择之一，也是最面向FP的选择之一。顾名思义，该框架是关于从用户生成的DOM事件(或其他机器生成的事件)到业务逻辑(反应性数据结构)再到新的DOM表示(和其他副作用)的单向数据流，然后从下一个事件重新开始。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/a31f768e0c6b8e7c0e3cb5e3e87678c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*l8u39OeHsVsP00p5enO-tg.png"/></div><p class="li lj gj gh gi lk ll bd b be z dk translated">Cycle.js数据流(来源:<a class="ae ko" href="https://cycle.js.org" rel="noopener ugc nofollow" target="_blank">https://cycle.js.org</a>)</p></figure><p id="2b9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一种透明干净的方式来表现人机交互。<br/>但是对于这种单一的循环，这可能不是管理深度嵌套组件的最简单方法，尤其是当组件与传统代码(jQuery插件、第三方前端SDK等)交互时。嗯，这不是不可能的——你可以编写“<a class="ae ko" href="https://cycle.js.org/drivers.html#drivers" rel="noopener ugc nofollow" target="_blank">驱动</a>”来包装第三方代码，并将源/接收器从父组件向下传递到子组件，但这并不那么容易。</p><h2 id="1180" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">一个周期来统治他们！还是没有？</h2><p id="ebea" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">如果每个组件都有自己的周期呢？这肯定是一个更复杂的架构。但它可能有助于扩展您的SPA，减少组件耦合，并简化第三方库集成，而不会失去我们代码的功能优势。你可以把每个组件看作一个独立的人机交互循环。每个组件实例都有一个状态，状态通过FP定义生成一个DOM表示，人们与DOM交互，生成的事件改变状态，循环重新开始。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi mn"><img src="../Images/2ce5ec1b036793907834a90ab386bd84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UweuDEBwcSlg1nHWmx7I9g.jpeg"/></div></div><p class="li lj gj gh gi lk ll bd b be z dk translated">FPR研究员。原创照片由<a class="ae ko" href="https://www.flickr.com/photos/27299321@N05" rel="noopener ugc nofollow" target="_blank"> Aoshi_88 </a></p></figure><h2 id="5560" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">涡轮</h2><p id="7789" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">深潜Gitlab/Github，我发现了<a class="ae ko" href="https://github.com/funkia/turbine" rel="noopener ugc nofollow" target="_blank">涡轮</a>，一个基于固体FP理论的框架，探索每个组件架构的循环。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi mo"><img src="../Images/8019c0e6c82c07e53a693d0acc17c27c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NneIMYIIhhGnXTTamhW-iw.png"/></div></div><p class="li lj gj gh gi lk ll bd b be z dk translated">涡轮部件数据周期(来源https://github.com/funkia/turbine<a class="ae ko" href="https://github.com/funkia/turbine" rel="noopener ugc nofollow" target="_blank"/>)</p></figure><p id="6f26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是Turbine维护父组件的循环规则，将状态流传递给子组件。明确的说，这是一个很好的做法；这样，从高级组件到嵌套组件，数据方向是线性的。但是这强加了组件/子组件绑定。</p><h2 id="01be" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">去耦子组件</h2><p id="b6b6" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">我们试着更务实一点。DOM是一个肮脏、不纯和奢华的地方，许多技术和方法汇聚于此(jQuery插件、Google Maps SDK、脸书SDK、CSS和所有其他构建web体验的东西)。我们的提议是提供一种方式来表达组件级别的副作用(保持它们被很好地发出信号),并使视图生成功能成为一个<a class="ae ko" href="https://cycle.js.org/model-view-intent.html#model-view-intent-what-mvc-is-really-about-why-css-selectors" rel="noopener ugc nofollow" target="_blank">主动元素</a>,而不是像Cycle或Turbine那样的被动元素。此外，组件可以向高层模型流发送事件信号，打破了单一数据方向的规则。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/0ae007779227f96f9913fc22d1988f0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*oYAfKjxjRGxcAmhIk5LDYQ.png"/></div><p class="li lj gj gh gi lk ll bd b be z dk translated">提议的架构。组件(嵌套与否，不重要)扩展高层模型流网络，从相关DOM接收事件。作为副作用，它们可以在高级模型上产生事件。这就像是MVVM建筑的玻璃钢演变。</p></figure><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi mq"><img src="../Images/119bf4888c2f89117b2c729b631e140e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_DMvajfGcKQoIOWpLysa1Q.png"/></div></div><p class="li lj gj gh gi lk ll bd b be z dk translated">传统MVVM建筑(来源:维基百科)</p></figure><p id="db65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过这种更改的规范，可以保持对事件作出反应的逻辑，并生成新的纯本地状态，但使每个组件都能够对自己的事件作出反应。更重要的是，这对父组件是完全透明的。父组件不需要知道子组件如何与肮脏的DOM世界或高级模型流交互。</p><p id="6811" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">嵌套组件的隔离和解耦使得将反应流网络细分为两层变得很自然。它们是与许多组件(外部数据同步、高级业务逻辑等)相关的逻辑的<em class="ks">高级模型层</em>。)，以及<em class="ks">视图-模型层，</em>负责对组件视图事件做出反应并更新组件状态。视图模型可以从高层模型层接收事件，并将事件发送回模型。</p><p id="7b5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果在这个分布式架构中，副作用被隔离在DOM和其他驱动程序中，那么副作用可以由reactive streams网络在组件级别直接管理。重要的是指出副作用发生的地方，不要把纯的和不纯的混在一起。正如我们将看到的，函数式反应式编程库提供了一种隔离副作用的适当方法。</p><h2 id="7d66" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">TODOMVC:示例应用程序</h2><p id="b0f1" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">现在让我们用通常的TodoMVC例子来尝试一下这个架构。本文探讨的思想可以用许多现有的SPA框架和功能流库来实现。在这种情况下，我选择了<a class="ae ko" href="https://mithril.js.org/index.html" rel="noopener ugc nofollow" target="_blank"> Mithril </a>，这是一个最小且快速的vdom框架，它以几kb的代码提供了一个标准且高效的路由解决方案，我还选择了<a class="ae ko" href="https://mostcore.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Most Core </a>，这是一个高性能的一元反应事件流库，我认为它是“最”实用的一个。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/6b2aa665bdca84da88b151eb44a3eae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*2Nryx9H3bqHCwEBfdfcFEA.png"/></div><p class="li lj gj gh gi lk ll bd b be z dk translated"><a class="ae ko" href="https://mithril.js.org/index.html" rel="noopener ugc nofollow" target="_blank">秘银2 </a> + <a class="ae ko" href="https://mostcore.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">最核心</a>:我们喜爱的libs</p></figure><blockquote class="kp kq kr"><p id="411f" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">该项目是一个ES6模块app，可以由Google Chrome运行，无需transpilation(外部依赖除外)。<br/> <a class="ae ko" href="https://github.com/FbN/todomvc-mm" rel="noopener ugc nofollow" target="_blank">储存在这里</a> <br/> <a class="ae ko" href="https://eloquent-wiles-a36b02.netlify.com/#!/" rel="noopener ugc nofollow" target="_blank">现场演示在这里</a></p></blockquote><p id="d59a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">文件被细分以显示层:</p><ul class=""><li id="63a2" class="mr ms it js b jt ju jx jy kb mt kf mu kj mv kn mw mx my mz bi translated">模型(/app/js/model)</li><li id="e825" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated">视图-模型(/app/js/vm)</li><li id="634c" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated">视图(/app/js/view)</li></ul><h2 id="d08f" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">约定</h2><p id="45c3" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">在提议的解决方案中，我们使用大多数适配器作为脏DOM世界和纯VM之间的粘合剂。</p><blockquote class="kp kq kr"><p id="057e" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">适配器是一对纠缠在一起的事件流和一个函数(我们称之为触发器),用来在流中引发(引起)事件。</p></blockquote><p id="9bb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了清楚地表达流/触发器的纠缠，我们使用后缀“$”表示流，使用后缀“_$”表示触发器。所以函数<strong class="js iu"> _$ &lt;名&gt; </strong>被触发纠缠到流函数<strong class="js iu"> $ &lt;名&gt; </strong>。<br/>基于这个约定，我们创建了一个助手函数来批量生成触发器/流，以及一个从我们的VM和视图生成标准Mithril组件的函数(参见js/mm.js)。</p><h2 id="f8f8" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">成分</h2><blockquote class="kp kq kr"><p id="d7c9" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">组件是一种封装部分视图的机制，使代码更容易组织和/或重用。</p></blockquote><p id="81c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Mithril中，组件可以用三种不同的语法形式来表达:POJO、Class和<a class="ae ko" href="https://mithril.js.org/components.html#closure-component-state" rel="noopener ugc nofollow" target="_blank"> Function(又名closure) </a>。正如你可能猜到的，我们将使用函数一。在这种形式中，组件是一个函数，在组件实例化时被调用一次，并返回一个至少带有一个<strong class="js iu">视图</strong>属性的POJO。</p><p id="0b3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">view属性是每次呈现对象时调用的函数，返回组件vnode树(以及DOM表示)。</p><p id="36e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了视图属性之外，我们可以添加一个附加属性来挂钩<a class="ae ko" href="https://mithril.js.org/lifecycle-methods.html" rel="noopener ugc nofollow" target="_blank"> DOM对象生命周期</a>:</p><ul class=""><li id="b484" class="mr ms it js b jt ju jx jy kb mt kf mu kj mv kn mw mx my mz bi translated"><strong class="js iu"> oninit </strong>:第一次对象初始化时调用一次。</li><li id="933a" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated"><strong class="js iu"> oncreate </strong>:当DOM对象被渲染并附加到页面时。此时，我们可以改变真正的DOM对象。这是与第三方SDK或库合作的好时机。</li><li id="8dc1" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated"><strong class="js iu"> onupdate </strong>:类似oncreate，但每次更新对象的DOM时调用。</li><li id="d7b8" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated"><strong class="js iu"> onremove </strong>:在从文档中移除DOM元素之前调用。</li></ul><p id="da1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了最大限度地粘合在一起，我们创建了一个名为'<strong class="js iu"> mm </strong>'的函数(参见app/js/mm.mjs)，它被赋予一个VM和一个返回标准Mithril组件的视图。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="22cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果组件将配置生命周期事件，以启动和管理我们从虚拟机返回的大多数流。</p><p id="0e23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个组件实例都有一个不可变的状态图。状态在组件声明时被初始化，并作为VM流处理的结果被替换。</p><h2 id="9680" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">高级模型</h2><p id="53a4" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">模型是标准的ES6模块，可以导出大多数流/触发器和其他有用的方法。在我们的示例中，Todo模型提供流/触发器来管理任务列表(参见<a class="ae ko" href="https://github.com/FbN/todomvc-mm/blob/master/app/js/model/todo.mjs" rel="noopener ugc nofollow" target="_blank"> /app/js/model/todo.mjs </a>)。为了方便起见，它导出了组件使用的几个纯函数。为了弄清楚模型中的内容和视图中的内容，模型考虑了逻辑的使用。如果它是关于应用程序的核心业务逻辑或影响许多组件，它可能会出现在一个模型中。如果它是一个管理单个组件行为的逻辑，就像它的表现一样，它就进入了VM。</p><h2 id="b12b" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">查看模型</h2><p id="aeb3" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">虚拟机是我们架构的核心。每个VM都是一个纯函数，它接受一个<strong class="js iu">不可变vnode </strong>(我们使用了不可变js，但这不是强制的)输入，并返回一个大多数触发器/流的集合。vnode可用于检索视图上组件定义中声明的属性。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="65e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">VM可以导入模块流，并依赖它们来构建其内部流网络。</p><p id="dcd4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">VM可以声明产生副作用的流(<a class="ae ko" href="https://mostcore.readthedocs.io/en/latest/api.html#tap" rel="noopener ugc nofollow" target="_blank">见tap </a>)。一个常见的副作用是触发模型流上的事件。从VM返回的所有流都将在组件init(由Mithril oninit)上运行，并且它们将持续到组件被移除(在Mithril onremove触发的事件之后，资源将由Most清理)。</p><p id="0415" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">VM返回的流有三种不同的管理方式:</p><ul class=""><li id="0070" class="mr ms it js b jt ju jx jy kb mt kf mu kj mv kn mw mx my mz bi translated">状态流:重新创建组件状态，导致<a class="ae ko" href="https://mithril.js.org/redraw.html" rel="noopener ugc nofollow" target="_blank">重绘</a>；</li><li id="c198" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated">效果流:导致重绘；</li><li id="5fc1" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated">生命周期流。</li></ul><p id="e8f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果返回的流的名称等于一个状态键名称，那么该流将用于更新该状态属性(我们可以将该流称为"<strong class="js iu">状态流</strong>")。</p><p id="705c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个组件状态的重新创建(当状态流接收到一个事件时发生)都会导致额外的副作用，即请求vdom的<a class="ae ko" href="https://mithril.js.org/redraw.html" rel="noopener ugc nofollow" target="_blank"> <em class="ks"> redraw </em> </a>(调用Mithril redraw方法)。</p><p id="4c5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了状态流，我们还可以返回其他任意的流(我们称之为“<strong class="js iu">效果流</strong>”)。效果流(其名称与状态属性的名称不一致的流)对于管理必须以组件DOM开始和结束但不改变组件内部状态的副作用非常有用(例如，高级模型上事件的触发)。效果流将重绘副作用生成为状态流。</p><p id="63ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">VM可以返回的第三种类型的流是生命周期流。<strong class="js iu">生命周期流</strong>是将与Mithril生命周期事件挂钩的流。因此，如果您希望在初始化/更新/删除时发生一些事情，您可以依赖这些流。生命周期流有名字——<strong class="js iu">$ oncreate，$oninit，$onupdate，$ on delete</strong>——默认情况下不会触发Mithril重绘。</p><h2 id="a4e0" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">视角</h2><p id="2dd8" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">视图是最简单的部分。这是一个生成<a class="ae ko" href="https://medium.com/hacking-and-gonzo/reactive-vs-proactive-development-180017c47fda" rel="noopener">主动</a> vdom树的纯函数。作为输入，它接收两个映射:不可变的状态映射和可用于捕捉DOM事件的触发器集合。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="014d" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">把它们放在一起</h2><p id="4dca" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">我们的代码被有意地细分成模块，以展示如何扩展SPA。虚拟机可以用于构建不同的组件，也可以组合在一个视图中使用，该视图对不同的功能进行分组。这些视图可以很容易地被JSX替换(这里没有这样做，以绕过编译)。</p><p id="ee06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以创建一个或多个组件模块，将初始状态、VM和视图放在一起，创建和导出组件，以便在视图中使用。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="773f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">app导入路由中用作页面的高层组件(见/app/js/ <a class="ae ko" href="https://github.com/FbN/todomvc-mm/blob/master/app/js/app.mjs" rel="noopener ugc nofollow" target="_blank"> app.mjs </a>)。</p><h2 id="7d0b" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">结论</h2><p id="2221" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">我们与Mithril和Most Core合作，以分布式循环、每个组件、双向流的方式开发SPA。这种建筑与古老的MVVM原则并不遥远。它肯定没有Cycle、JS或Turbine那么优雅和纯粹，但它可能是最容易扩展和与第三方库集成的(有待演示)。</p><p id="dc84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">资源链接</strong></p><ul class=""><li id="b4e0" class="mr ms it js b jt ju jx jy kb mt kf mu kj mv kn mw mx my mz bi translated"><a class="ae ko" href="http://v" rel="noopener ugc nofollow" target="_blank"> Cycle.js </a></li><li id="6e17" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated"><a class="ae ko" href="https://github.com/funkia/turbine" rel="noopener ugc nofollow" target="_blank">涡轮</a></li><li id="080c" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated"><a class="ae ko" href="https://github.com/FbN/todomvc-mm" rel="noopener ugc nofollow" target="_blank">Github Repo—todom VC Mithril+most core</a></li><li id="a9c9" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated"><a class="ae ko" href="https://eloquent-wiles-a36b02.netlify.com/#!/" rel="noopener ugc nofollow" target="_blank">代码现场演示</a></li></ul></div></div>    
</body>
</html>