<html>
<head>
<title>React Native Meets SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native遇上SwiftUI</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-native-meets-swiftui-d1606a8e1681?source=collection_archive---------3-----------------------#2020-02-12">https://betterprogramming.pub/react-native-meets-swiftui-d1606a8e1681?source=collection_archive---------3-----------------------#2020-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/eca1d4f5168eb46a7abbe2b4b3f6518c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WGHWviOG48L6VENjYLYXEA@2x.png"/></div></div></figure><div class=""/><div class=""><h2 id="0a46" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">编写一个代理，允许您在React本机应用程序中使用SwiftUI</h2></div><p id="4255" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">2015年，<a class="ae lp" href="https://facebook.github.io/react-native/" rel="noopener ugc nofollow" target="_blank"> React Native </a>为跨平台移动世界带来了声明式组件方法。没过多久，这种面向组件的哲学就扩展到了类似的库中。现在，随着<a class="ae lp" href="https://developer.apple.com/tutorials/swiftui" rel="noopener ugc nofollow" target="_blank"> SwiftUI </a>和<a class="ae lp" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank"> Jetpack Compose </a>，这终于到达了本地平台。</p><p id="ff09" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">SwiftUI 是一个UI框架，它将声明性组件方法引入苹果平台家族，包括iOS、macOS和watchOS。</p><p id="0028" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">它可以与它的前身UIKit互换工作，这意味着开发者可以将新框架无缝集成到他们现有的应用程序中。然而，混合搭配的UIKit和SwiftUI需要中间件来连接它们。</p><p id="1e93" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">今天，我们将编写一个代理，允许开发人员在其React本机应用程序中使用SwiftUI。</p><p id="d9d1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">请记住，SwiftUI <em class="lq">仅在iOS 13.0及以上版本</em>上运行(在撰写本文时，iOS 13.0的平台覆盖率为<a class="ae lp" href="https://david-smith.org/iosversionstats/" rel="noopener ugc nofollow" target="_blank">94%</a>)。如果你的应用必须支持以前的iOS版本，你就不能使用SwiftUI。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f98d" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">1.初始设置</h1><p id="fdf9" class="pw-post-body-paragraph kt ku je kv b kw mq kf ky kz mr ki lb lc ms le lf lg mt li lj lk mu lm ln lo im bi translated">让我们从创建一个带有本地UI组件的React本地应用程序开始(现在，一个简单的<code class="fe mv mw mx my b">UIView</code>就可以了)。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mz"><img src="../Images/f2a4902424072954e7b8092ae36c7bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x-JzDqVMnv3T4zNZb3kXug.png"/></div></div></figure><p id="fab1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果您不熟悉桥接本机组件以进行本机反应，我强烈建议您在继续之前阅读文档中的相应文章。GitHub 上也有初始设置的代码<a class="ae lp" href="https://github.com/Kureev/ReactNativeWithSwiftUITutorial/releases/tag/initial-setup" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="2d95" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">2.勾搭斯威夫特</h1><p id="2c62" class="pw-post-body-paragraph kt ku je kv b kw mq kf ky kz mr ki lb lc ms le lf lg mt li lj lk mu lm ln lo im bi translated">当我们有一个完成初始设置的应用程序时，我们可以创建一个Swift类(<code class="fe mv mw mx my b">SwiftUIButtonProxy</code>)，作为SwiftUI视图和<code class="fe mv mw mx my b">RCTViewManager</code>之间的代理。</p><p id="80dd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在Objective-C项目中创建第一个Swift类后，Xcode会询问您是否希望它创建<a class="ae lp" href="https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_objective-c_into_swift" rel="noopener ugc nofollow" target="_blank">一个桥接头</a>。需要向Swift公开一个任意的Objective-C代码，我们以后会用到，所以一定要说:“是”。</p><p id="ebf3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">新视图应该类似于以下内容:</p><pre class="na nb nc nd gt ne my nf ng aw nh bi"><span id="c32a" class="ni lz je my b gy nj nk l nl nm">// SwiftUIButtonProxy.swift</span><span id="ec53" class="ni lz je my b gy nn nk l nl nm"><strong class="my jf">@objc class</strong> SwiftUIButtonProxy : <strong class="my jf">UIView</strong> {}</span></pre><p id="e657" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，让我们修改我们的<code class="fe mv mw mx my b">RCTViewManager</code>来渲染它:</p><pre class="na nb nc nd gt ne my nf ng aw nh bi"><span id="1103" class="ni lz je my b gy nj nk l nl nm">// SwiftUIButtonManager.m</span><span id="0715" class="ni lz je my b gy nn nk l nl nm">-(<strong class="my jf">UIView *</strong>)view {<br/>  <strong class="my jf">return</strong> [[SwiftUIButtonProxy <strong class="my jf">alloc</strong>] <strong class="my jf">init</strong>];<br/>}</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mz"><img src="../Images/67f3e83e98598d2f6821345eadfbbff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XfVaxL2FrTGa3byp1XUetg.png"/></div></div></figure><p id="9dd5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这一步，你可能会注意到Xcode开始抱怨<code class="fe mv mw mx my b">SwiftUIButtonProxy</code>的用法。</p><p id="0246" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">发生这种情况是因为Objective-C不知道任何Swift类别，除非您导入一个收集所有可访问Swift结构信息的动态项目标题:</p><pre class="na nb nc nd gt ne my nf ng aw nh bi"><span id="68e7" class="ni lz je my b gy nj nk l nl nm"><strong class="my jf">#import</strong> "&lt;ProjectName&gt;-Swift.h"</span></pre><p id="d67e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">注意<code class="fe mv mw mx my b">&lt;ProjectName&gt;</code>只是项目名称的占位符。例如，如果您的项目名为“FooBar ”,您的导入应该如下所示:</p><pre class="na nb nc nd gt ne my nf ng aw nh bi"><span id="255b" class="ni lz je my b gy nj nk l nl nm"><strong class="my jf">#import</strong> "FooBar-Swift.h"</span></pre><p id="9af0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">不要被这种进口所迷惑。你的<code class="fe mv mw mx my b">*.xcworkspace</code>或者<code class="fe mv mw mx my b">*.xcodeproj</code>里没有对应的文件，但是它是存在的。Xcode将在构建步骤中根据Swift代码库的可见性区域构建它。</p><p id="9042" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">导入完成后，错误应该会消失，应用程序应该会正常构建。如果你在这一步有任何问题，你可以在我的<a class="ae lp" href="https://github.com/Kureev/ReactNativeWithSwiftUITutorial" rel="noopener ugc nofollow" target="_blank">教程库</a>中查看<a class="ae lp" href="https://github.com/Kureev/ReactNativeWithSwiftUITutorial/releases/tag/proxy-class" rel="noopener ugc nofollow" target="_blank">“代理类”标签</a>。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="46e9" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">3.渲染SwiftUI</h1><p id="4ac9" class="pw-post-body-paragraph kt ku je kv b kw mq kf ky kz mr ki lb lc ms le lf lg mt li lj lk mu lm ln lo im bi translated">尽管渲染Swift的视图应该非常简单，但是挂接SwiftUI却不简单。由于设计限制，从UIKit运行SwiftUI的唯一方法是使用<code class="fe mv mw mx my b">UIHostingController</code>。</p><p id="548f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">直到这一点，我都没有在app中提到使用<code class="fe mv mw mx my b">UIViewController</code>或者其他任何控制器的话题。事实上，这通常会让学习React Native的人感到困惑。</p><p id="ea19" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你看，在本地开发中，<code class="fe mv mw mx my b">ViewControllers</code>在管理应用程序的视图和数据中扮演着重要的角色。在React Native中，原生组件的JavaScript部分应该接管。</p><p id="126c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然而，如果我们构建一个复杂的本地组件，或者说，桥接一个SwiftUI视图，学习如何使用它们可能会很方便。</p><p id="823b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">正如我之前提到的，SwiftUI视图层次结构可以通过使用<code class="fe mv mw mx my b">UIHostingController</code>集成到您现有的应用程序中。它充当UIKit和SwiftUI框架之间的中介，因此您可以将SwiftUI视图作为UIKit视图层次结构的一部分。</p><p id="d0f7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们创建一个新的SwiftUI视图，并将其命名为<code class="fe mv mw mx my b">SwiftUIButton</code>。</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d2a3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然后，我们调整<code class="fe mv mw mx my b">SwiftUIButtonProxy</code>类来创建一个具有新视图的<code class="fe mv mw mx my b">UIHostingController</code>。因为我们要创建一个视图控制器并公开它的视图，所以不需要从<code class="fe mv mw mx my b">UIView</code>继承代理类。</p><p id="65b4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但是，因为我们不能将没有继承<code class="fe mv mw mx my b">NSObject</code>的类暴露给Objective-C，所以我们将用<code class="fe mv mw mx my b">NSObject</code>替换<code class="fe mv mw mx my b">UIView</code>以保持其可访问性。</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0a7c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">相应的管理器类也应该反映这些变化:</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3b4b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如您所见，我们没有返回<code class="fe mv mw mx my b">SwiftUIButtonProxy</code>本身，而是用通过<code class="fe mv mw mx my b">UIHostingController</code>代理的SwiftUI视图替换了它。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nq"><img src="../Images/f7fd889749740e725181f68833c6f5c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cwGfrOkm4TDa5Lnd5TPlew.png"/></div></div></figure><p id="b310" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">恭喜你！您刚刚桥接了您的第一个SwiftUI视图。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="2763" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">4.道具呢？</h1><p id="4ec5" class="pw-post-body-paragraph kt ku je kv b kw mq kf ky kz mr ki lb lc ms le lf lg mt li lj lk mu lm ln lo im bi translated">大多数本机组件实现配置属性和回调。在教程的这一部分，我们将桥接两个简单的属性:<code class="fe mv mw mx my b">count: Int</code>和<code class="fe mv mw mx my b">onCountChange: RCTBubblingEventBlock</code>。</p><p id="a76b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这可能是本教程中最复杂的部分。数据转发绝非易事。</p><p id="bdc7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">首先，我们不能使用标准的<code class="fe mv mw mx my b">RCT_EXPORT_VIEW_PROPERTY</code>宏，因为它会生成试图访问视图实例的setters。不幸的是，SwiftUI视图不能直接暴露给Objective-C，因为Swift的<code class="fe mv mw mx my b">struct</code>没有相应的类型。</p><p id="7f64" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这就把我们带到了这样一个点，传递数据的唯一方式是通过可以访问两个运行时的自定义Swift代理:Objective-C从JavaScript接收视图属性，Swift将这些属性设置为相应的SwiftUI视图。</p><p id="f3e3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">听起来很复杂，但是不要让它吓到你！它是这样工作的:</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nq"><img src="../Images/aea91f2e8c85064cb7153bf50fdcfb3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*obuk7pIeV9MeOix4x7zlcQ.png"/></div></div></figure><p id="8781" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">本地组件的管理器通过特殊的设置器接收新的属性，这些属性是在预编译例程期间由类似<code class="fe mv mw mx my b">RCT_EXPORT_VIEW_PROPERTY</code>的宏生成的。</p><p id="3361" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">每次使用如上所述的宏时，您都会为您包装的属性生成一个自定义setter(参见<a class="ae lp" href="https://gcc.gnu.org/onlinedocs/cpp/Object-like-Macros.html#Object-like-Macros" rel="noopener ugc nofollow" target="_blank"> #define macro </a>如何工作)，因此当您从JavaScript发送一组新的属性时，React Native会检查新属性的相应setter是否存在于管理器中。</p><p id="4a93" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">TL；DR: <code class="fe mv mw mx my b">RCT_EXPORT_VIEW_PROPERTY</code> -like宏生成属性设置器，当用户向本地组件的JavaScript表示分配新属性时，会调用这些属性设置器。</p><p id="28d8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">既然我们不能使用<code class="fe mv mw mx my b">RCT_EXPORT_VIEW_PROPERTY</code>，我建议我们创建自己的宏。按照<code class="fe mv mw mx my b">RCT_EXPORT_VIEW_PROPERTY</code>的命名惯例，我称它为<code class="fe mv mw mx my b"><a class="ae lp" href="https://gist.github.com/Kureev/2151c335cf9c7a1fa45460627424bbdf" rel="noopener ugc nofollow" target="_blank">RCT_EXPORT_SWIFTUI_PROPERTY</a></code>和<code class="fe mv mw mx my b"><a class="ae lp" href="https://gist.github.com/Kureev/2151c335cf9c7a1fa45460627424bbdf" rel="noopener ugc nofollow" target="_blank">RCT_EXPORT_SWIFTUI_CALLBACK</a></code>。</p><p id="9f5d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这些宏中的每一个都利用了<code class="fe mv mw mx my b">RCT_CUSTOM_VIEW_PROPERTY</code>的功能，它允许开发者创建一个定制的setter。</p><p id="e09e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果您决定使用它们，请记住它们仅在以下条件下有效:</p><ul class=""><li id="52f1" class="nr ns je kv b kw kx kz la lc nt lg nu lk nv lo nw nx ny nz bi translated">您有一个代理类，它公开了一个名为<code class="fe mv mw mx my b">storage</code>的静态<code class="fe mv mw mx my b">NSMutableDictionary</code>。</li><li id="b69e" class="nr ns je kv b kw oa kz ob lc oc lg od lk oe lo nw nx ny nz bi translated"><code class="fe mv mw mx my b">RCT_EXPORT_SWIFTUI_PROPERTY</code>只支持<code class="fe mv mw mx my b">int</code>、<code class="fe mv mw mx my b">string</code>、<code class="fe mv mw mx my b">bool</code>等基本属性。复杂类型需要正确的转换，这超出了本文的范围</li></ul><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/eca1d4f5168eb46a7abbe2b4b3f6518c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WGHWviOG48L6VENjYLYXEA@2x.png"/></div></div></figure><p id="ef9f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">正如我前面提到的，每个自定义宏都依赖于React Native的<code class="fe mv mw mx my b">RCT_CUSTOM_VIEW_PROPERTY</code>宏，该宏允许开发人员为道具创建自定义设置器。这个宏需要一个定义setter的块。</p><p id="715e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在块的范围内，除了类属性之外，React Native还公开了三个参数:</p><ul class=""><li id="c1db" class="nr ns je kv b kw kx kz la lc nt lg nu lk nv lo nw nx ny nz bi translated"><code class="fe mv mw mx my b">UIView *view</code> —道具接受者。</li><li id="12ec" class="nr ns je kv b kw oa kz ob lc oc lg od lk oe lo nw nx ny nz bi translated"><code class="fe mv mw mx my b">UIView *defaultView</code> —默认视图。</li><li id="f28e" class="nr ns je kv b kw oa kz ob lc oc lg od lk oe lo nw nx ny nz bi translated"><code class="fe mv mw mx my b">id json</code> —指向接收数据的指针。</li></ul><p id="2ebe" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们最感兴趣的是<code class="fe mv mw mx my b">json</code>和<code class="fe mv mw mx my b">view</code>。人们可能会注意到<code class="fe mv mw mx my b">view</code>的类型不同。我们得到的不是SwiftUI视图，而是一个常规的UI视图，它由<code class="fe mv mw mx my b">UIHostingController</code>公开用于桥接。不幸的是，这还不够。</p><p id="9bd2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">为了设置新的道具，我们需要获得对真实SwiftUI视图的引用。此时唯一的方法是通过<code class="fe mv mw mx my b">UIHostingController</code>，但是控制器本身也是不可及的…</p><p id="7e07" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">为了解决这个问题，我创建了一个<code class="fe mv mw mx my b">key:value</code>存储(<code class="fe mv mw mx my b">NSMutableDicrionary</code>，并将其作为静态属性分配给<code class="fe mv mw mx my b">SwiftUIButtonProxy</code>。</p><p id="3011" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，如果我在创建视图时存储了一个<code class="fe mv mw mx my b">view:proxy</code>对，我就可以在setter中访问所需的<code class="fe mv mw mx my b">proxy</code>。因为我们的代理是<code class="fe mv mw mx my b">UIHostingController</code>的容器，所以不需要努力就可以得到SwiftUI视图的正确引用。</p><p id="6414" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然而，别忘了我们是从Objective-C操作的，这使得直接操作SwiftUI视图道具变得不可能。</p><p id="fc8a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果我们在<code class="fe mv mw mx my b">SwiftUIButtonProxy</code>类中定义自定义的<code class="fe mv mw mx my b">count</code>和<code class="fe mv mw mx my b">onCountChange</code>属性，我们可以解决这个约束，这样它们就可以使用控制器的<code class="fe mv mw mx my b">rootView</code>属性来传播新值:</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1d11" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">为每个属性手动编写getters和setters有点乏味(特别是当您有几个属性时)，但这是我发现的最直接的方法。</p><p id="1c5e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">另外，请注意这里的<code class="fe mv mw mx my b">props</code>:swift ui允许组件拥有一个本地状态<code class="fe mv mw mx my b">@State</code>，公开状态<code class="fe mv mw mx my b">@ObservedObject</code> (props)，以及一个共享的公开状态<code class="fe mv mw mx my b">@EnvironmentObject</code>(上下文)。</p><p id="aa61" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这个例子中，我使用<code class="fe mv mw mx my b">@ObservedObject</code>，因为我们需要从外部设置值。在SwiftUI视图中，它看起来像这样:</p><pre class="na nb nc nd gt ne my nf ng aw nh bi"><span id="1c41" class="ni lz je my b gy nj nk l nl nm">// SwiftUIButton.swift</span><span id="d30d" class="ni lz je my b gy nn nk l nl nm"><strong class="my jf">@ObservedObject var</strong> props = ButtonProps()</span></pre><p id="3efb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，让我们向视图添加一个按钮。每当用户点击那个按钮时，我们希望用新增加的计数器值调用<code class="fe mv mw mx my b">props.onCountChange</code>。经过一些风格上的改变，<code class="fe mv mw mx my b">SwiftUIButton</code>代码看起来可能类似于这样:</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d3f1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，为了完善这个例子，我们只需要覆盖两个缺失的部分:<code class="fe mv mw mx my b">ButtonProps</code>和JavaScript部分:</p><pre class="na nb nc nd gt ne my nf ng aw nh bi"><span id="767c" class="ni lz je my b gy nj nk l nl nm"><strong class="my jf">class</strong> ButtonProps : <strong class="my jf">ObservableObject</strong> {<br/>  <a class="ae lp" href="http://twitter.com/Published" rel="noopener ugc nofollow" target="_blank">@Published</a> <strong class="my jf">var</strong> count: Int = 0<br/>  <a class="ae lp" href="http://twitter.com/Published" rel="noopener ugc nofollow" target="_blank">@Published</a> <strong class="my jf">var</strong> onCountChange: RCTDirectEventBlock = { _ in }<br/>}</span></pre><p id="2a27" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe mv mw mx my b">ButtonProps</code>是一个<code class="fe mv mw mx my b">ObservableObject</code>，它保存我们从JavaScript传递给它的值。如果你对<code class="fe mv mw mx my b">@Published</code>感到不解，没关系。该指令创建一个绑定，告知SwiftUI在其中一个已发布的属性发生更改时重新呈现。</p><p id="a033" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">JavaScript部分没有:</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="87d9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">就是这样！这是一条漫长而崎岖的道路，但你已经熬过来了。</p><p id="f466" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">通过一些小的调整，比如在SwiftUI视图中添加一个按钮，并通过回调连接相应的数据，您应该有一个从0计数到+无穷大的应用程序。</p><p id="0817" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">结果代码(带有一些原生UI调整)可以在<a class="ae lp" href="https://github.com/Kureev/ReactNativeWithSwiftUITutorial" rel="noopener ugc nofollow" target="_blank">教程库</a>中找到，在<a class="ae lp" href="https://github.com/Kureev/ReactNativeWithSwiftUITutorial/releases/tag/working-example" rel="noopener ugc nofollow" target="_blank">工作示例</a>标签下。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="3e49" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">5.后手稿</h1><p id="f8af" class="pw-post-body-paragraph kt ku je kv b kw mq kf ky kz mr ki lb lc ms le lf lg mt li lj lk mu lm ln lo im bi translated">我们刚刚将SwiftUI组件桥接到React本机应用程序中——虽然这开启了巨大的可能性，但我意识到这个主题具有挑战性。</p><p id="d861" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果你需要时间考虑，那也没关系。我花了几个不眠之夜才想出一个可持续的方法，坦率地说，我不确定这是不是最好的方法。</p><p id="8fe5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">该解决方案的整体复杂性让我希望在未来发布新的React原生架构时，这些事情会变得更容易。</p></div></div>    
</body>
</html>