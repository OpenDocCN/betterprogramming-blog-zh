<html>
<head>
<title>So, What’s the Deal With Micro-Frontends?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">那么，微前端是怎么回事？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/so-whats-the-deal-with-micro-frontends-7f799ef504dc?source=collection_archive---------3-----------------------#2022-08-04">https://betterprogramming.pub/so-whats-the-deal-with-micro-frontends-7f799ef504dc?source=collection_archive---------3-----------------------#2022-08-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cb47" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">微前端及其权衡的粗粒度视图</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/75d9d52b1a9760f00c1a0fe9c988828c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E0m-H9A6fXDPisN-d9VmWg@2x.png"/></div></div></figure><h1 id="92ec" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">介绍</h1><p id="6fa7" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">在软件工程中，您可以做出的最重要的技术决策之一是划分项目架构的方法。这个决定的后果是级联的，所以你必须得到这个权利！不幸的是，没有银弹解决方案，因为正确的决定取决于您的背景。一如既往，我们遵从软件架构的第一定律:</p><blockquote class="mj mk ml"><p id="b5bf" class="ln lo mm lp b lq mn ju ls lt mo jx lv mp mq ly lz mr ms mc md mt mu mg mh mi im bi translated">软件架构中的一切都是一种权衡。</p></blockquote><p id="91a8" class="pw-post-body-paragraph ln lo it lp b lq mn ju ls lt mo jx lv lw mq ly lz ma ms mc md me mu mg mh mi im bi translated">使用微前端是一种越来越流行的划分前端应用程序的方法。在这篇文章中，我将定义它们并描述它们的利弊。对于那些有更多时间的人，我将从探索不同的分区风格开始，探究其中的原因。然后我分享了微前端的粗粒度概述。但首先，对于那些赶时间的人来说:</p><p id="b925" class="pw-post-body-paragraph ln lo it lp b lq mn ju ls lt mo jx lv lw mq ly lz ma ms mc md me mu mg mh mi im bi translated"><strong class="lp iu">TL；受微服务的启发，DR </strong>微前端将以前单一的代码库分解成可独立部署的部分，这些部分组成了一个更大的整体。独立部署前端可以改善预期的特性，如可伸缩性、敏捷性和可维护性。这些好处反映了微服务的好处，但也有类似的缺点:操作和治理的复杂性。示例包括代码重用、标准化UI、管理微前端之间的交互以及部署配置的复杂性。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mv"><img src="../Images/4f7b2c5faff05c842774594732388d86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sCr1Jq7Zok9H-qbW.png"/></div></div></figure><p id="c852" class="pw-post-body-paragraph ln lo it lp b lq mn ju ls lt mo jx lv lw mq ly lz ma ms mc md me mu mg mh mi im bi translated">在我们继续之前，如果你喜欢这篇文章，请看我的简讯<a class="ae mw" href="https://growthmindsetcoding.substack.com/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="fc38" class="kv kw it bd kx ky ne la lb lc nf le lf jz ng ka lh kc nh kd lj kf ni kg ll lm bi translated">分割</h1><p id="a91d" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">在深入研究微前端之前，让我们首先探索其他分区方法</p><h1 id="1fa8" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">大泥球</h1><p id="f7bf" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">一种方法是泥浆分区的大球(或缺乏):</p><blockquote class="mj mk ml"><p id="20e6" class="ln lo mm lp b lq mn ju ls lt mo jx lv mp mq ly lz mr ms mc md mt mu mg mh mi im bi translated">“一个大泥球结构杂乱，蔓延，松散，胶带，意大利面条代码丛林显示出明显的无节制增长和重复的权宜之计。”—布莱恩·福特和约瑟夫·约德</p></blockquote><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/eda5d17d988725c38b42a2b683faefa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*ft4oFDfExwpLX1RE.png"/></div></figure><p id="ae73" class="pw-post-body-paragraph ln lo it lp b lq mn ju ls lt mo jx lv lw mq ly lz ma ms mc md me mu mg mh mi im bi translated">这种方法对于杂乱的尖峰和原型是非常好的，因为它有助于简单性和(初始)速度的特性。这对于长期使用来说并不理想，因为这种结构最终会降低灵活性和弹性。补充一点:一项被低估的技能是识别对你的特定环境重要的特征。偶尔，代码势利或业务压力会导致团队选择不正确的结构或技术，这些结构或技术不符合使项目成功所需的特征。</p><h1 id="7167" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">技术/领域划分</h1><p id="da3f" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">大多数应用程序都属于技术和领域分区应用程序的范围。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nk"><img src="../Images/378ee637b4a963ed741004e1cb9bb107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WIrMdLM5C-DMgk3g.png"/></div></div></figure><p id="4482" class="pw-post-body-paragraph ln lo it lp b lq mn ju ls lt mo jx lv lw mq ly lz ma ms mc md me mu mg mh mi im bi translated">技术分区的应用程序被分割成技术层:持久层与表示层分离，等等。这种简单的结构允许技术层的优化和专业化。然而，这意味着业务逻辑在各层之间模糊不清，可能会降低敏捷性和弹性。由于康威定律，具有这种划分结构的组织通常有独立的数据库、后端和前端团队。在前端环境中，技术上分区的应用程序可以是结构化的:</p><pre class="kk kl km kn gt nl nm nn no aw np bi"><span id="cb45" class="nq kw it nm b gy nr ns l nt nu">📦 application<br/> ┣ 📂 state<br/> ┃ ┣ 📜 store.js<br/> ┃ ┣ 📜 reducers.js<br/> ┃ ┗ 📜 actions.js<br/> ┣ 📂 components<br/> ┃ ┣ 📜 header.js<br/> ┃ ┣ 📜 button.js<br/> ┃ ┗ 📜 footer.js<br/> ┗ 📂 api<br/>   ┣ 📜 queries.js<br/>   ┗ 📜 mutations.js</span></pre><p id="472f" class="pw-post-body-paragraph ln lo it lp b lq mn ju ls lt mo jx lv lw mq ly lz ma ms mc md me mu mg mh mi im bi translated">域分区的应用程序被分割成多个业务域。想想<a class="ae mw" href="https://www.atlassian.com/agile/agile-at-scale/spotify" rel="noopener ugc nofollow" target="_blank"> Spotify模式</a>启发的跨职能团队，他们拥有端到端的产品。或者亚马逊的<a class="ae mw" href="https://queue.acm.org/detail.cfm?id=1142065" rel="noopener ugc nofollow" target="_blank">“你建造它。你跑吧”</a>走近。这有利于提高灵活性、可维护性和可伸缩性。在前端环境中，具有这种划分的应用程序是结构化的:</p><pre class="kk kl km kn gt nl nm nn no aw np bi"><span id="99a6" class="nq kw it nm b gy nr ns l nt nu">📦 application<br/> ┣ 📂 checkout<br/> ┃ ┣ 📜 state.js<br/> ┃ ┣ 📜 screen.js<br/> ┃ ┗ 📜 api.js<br/> ┗ 📂 catalog<br/>   ┣ 📜 state.js<br/>   ┣ 📜 screen.js<br/>   ┗ 📜 api.js</span></pre><h1 id="90f0" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">单片/分布式</h1><p id="39c7" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">您选择特定分区方法的决定会对部署的可能性产生影响。技术分区架构只能是整体式的，而域分区架构可以是整体式的，也可以是分布式的。在软件工程中，独石是有争议的，但是永远要小心教条，要有权衡的心态。例如，shopify<a class="ae mw" href="https://shopify.engineering/deconstructing-monolith-designing-software-maximizes-developer-productivity" rel="noopener ugc nofollow" target="_blank">采用了模块化的整体结构</a>，这非常适合其特定的环境。</p><p id="622e" class="pw-post-body-paragraph ln lo it lp b lq mn ju ls lt mo jx lv lw mq ly lz ma ms mc md me mu mg mh mi im bi translated">如果你偏爱花哨的术语，我们可以用“量子”这个术语:</p><blockquote class="mj mk ml"><p id="8e2a" class="ln lo mm lp b lq mn ju ls lt mo jx lv mp mq ly lz mr ms mc md mt mu mg mh mi im bi translated"><em class="it">一个</em>架构量子是一个具有高功能内聚性的可独立部署的组件</p></blockquote><p id="1971" class="pw-post-body-paragraph ln lo it lp b lq mn ju ls lt mo jx lv lw mq ly lz ma ms mc md me mu mg mh mi im bi translated">独石有一个量子(所有东西都部署在一起)，而且很大。模块化的单片也有一个量子。微服务有多个量程(许多部分可以独立部署)，而且每个量程都更小。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nv"><img src="../Images/fa826979c2ee72dc5b1230b1abc32090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fERKs_fp_Kj0_wG4.png"/></div></div></figure><p id="d3ed" class="pw-post-body-paragraph ln lo it lp b lq mn ju ls lt mo jx lv lw mq ly lz ma ms mc md me mu mg mh mi im bi translated">微服务流行的原因？他们是一个更进化的架构，因为他们有更多的小量子。然而，代价是随之而来的复杂性。部署、代码共享、可观察性和事务都是变得更加复杂的领域(尽管像<a class="ae mw" href="https://temporal.io/" rel="noopener ugc nofollow" target="_blank"> Temporal </a>这样的工具正在使生活变得更加简单)，所以这总是一种权衡。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nw"><img src="../Images/9593f619872d895b73a564238fc4a539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uB179iAGBXCmolFe.png"/></div></div></figure><p id="034e" class="pw-post-body-paragraph ln lo it lp b lq mn ju ls lt mo jx lv lw mq ly lz ma ms mc md me mu mg mh mi im bi translated">稍微偏离轨道一点，去中心化和集中化之间的权衡触及了一个更广泛的主题“高效数据处理的竞争方法”。自由市场经济以分散的方式处理信息。一致性是通过许多具有有限的本地知识的个人的平行和独立的行动而出现的。<a class="ae mw" rel="noopener ugc nofollow" target="_blank" href="/according to Yuval Noah Harari">根据Yuval Noah Harari </a>的说法，这种效率是苏联低效的中央集权经济落后于美国的原因。加密货币是对去中心化世界的又一次尝试，它从中央政府手中夺走了控制权，这自然引起了一些恐慌。</p><h1 id="2be2" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">微前端</h1><p id="513a" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">微前端是一种受微服务启发的新兴去中心化架构风格。这个想法是将单一的前端代码库分成由自治团队拥有的更小的部分。与模块化整体前端不同，这些应用程序随后被独立部署到生产环境中，在那里它们被组合成一个更大的整体。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mv"><img src="../Images/12039e021ec78d48d0b361d07b8e260e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5U0NPXhM99zMrCmd.png"/></div></div></figure><p id="1c92" class="pw-post-body-paragraph ln lo it lp b lq mn ju ls lt mo jx lv lw mq ly lz ma ms mc md me mu mg mh mi im bi translated">一个具体的例子，见上图。团队A和团队B在完全独立的域上工作，然后独立地部署，并以垂直分割或水平分割的方式组合在一起。在垂直分割中，团队拥有一个业务领域(参见<a class="ae mw" href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2009/february/best-practice-an-introduction-to-domain-driven-design" rel="noopener ugc nofollow" target="_blank">领域驱动设计</a>)，而在水平分割中，团队拥有一个页面切片。</p><p id="2708" class="pw-post-body-paragraph ln lo it lp b lq mn ju ls lt mo jx lv lw mq ly lz ma ms mc md me mu mg mh mi im bi translated">这种架构可以与各种后端架构一起使用，尽管它们特别适合微服务。如果与微服务一起使用，跨职能团队可以完全拥有业务领域。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mv"><img src="../Images/0bd86bd28c070273023f290fafe59435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ADgXf5HOLnsTs5Og.png"/></div></div></figure><h1 id="2145" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">对等</h1><ul class=""><li id="2485" class="nx ny it lp b lq lr lt lu lw nz ma oa me ob mi oc od oe of bi translated">工具:团队可以为他们特定的用例选择最好的工具，重构时不用担心会给其他团队带来错误，并且可以轻松地重写应用程序。这有助于他们向“您构建它，您运行它”的工作模式转变，并且它允许增量升级。</li><li id="42a5" class="nx ny it lp b lq og lt oh lw oi ma oj me ok mi oc od oe of bi translated">部署:团队可以“照单部署”——每个应用程序都按照自己的节奏部署。不相关的变更不需要捆绑在一起，部署风险也降低了，从而提高了灵活性。</li></ul><h1 id="6140" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">下降趋势</h1><ul class=""><li id="1006" class="nx ny it lp b lq lr lt lu lw nz ma oa me ob mi oc od oe of bi translated">治理:治理跨多个团队的代码质量标准和一致性更加困难，因为整体的可观察性降低了。在一个页面上混合一系列相互竞争的技术、工具或框架的能力也可能导致<strong class="lp iu">微前端混乱</strong>从而导致<strong class="lp iu">性能不佳和尺寸增大</strong>。</li><li id="c721" class="nx ny it lp b lq og lt oh lw oi ma oj me ok mi oc od oe of bi translated">操作性:管理微前端工具、管道、存储库和服务器需要更多的管理工作。协作和管理状态也更加复杂</li></ul><h1 id="52a2" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">结论</h1><p id="aea7" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">微前端是管理复杂前端代码库的一种极好的方式。这是自治团队使用的一种划分风格，它改善了可伸缩性和可进化性的特征。它们不具有简单性的特征，并且需要大量的治理和开发投资。如果您的微前端需要以特定的顺序部署，省点麻烦，坚持使用模块化的单片前端。</p><p id="129f" class="pw-post-body-paragraph ln lo it lp b lq mn ju ls lt mo jx lv lw mq ly lz ma ms mc md me mu mg mh mi im bi translated">如果您的业务需要的特性与微前端提供的特性一致，并且您有操作方面的专业知识，那么就值得进一步探索这种方法。向微前端迁移也不是“大爆炸”式的努力，所以你总是可以组建一个lighthouse团队来开拓一个小领域作为第一步实验。</p><p id="f300" class="pw-post-body-paragraph ln lo it lp b lq mn ju ls lt mo jx lv lw mq ly lz ma ms mc md me mu mg mh mi im bi translated">这篇文章是有意粗粒度地研究微前端的原理。如果您希望有一个更细粒度的视图，我建议查看以下资源:</p><ul class=""><li id="b64a" class="nx ny it lp b lq mn lt mo lw ol ma om me on mi oc od oe of bi translated"><a class="ae mw" href="https://nx.dev/module-federation/micro-frontend-architecture" rel="noopener ugc nofollow" target="_blank"> NX </a>:提供开箱即用微前端支持的工具</li><li id="bf50" class="nx ny it lp b lq og lt oh lw oi ma oj me ok mi oc od oe of bi translated">凯姆·杰克森神奇的<a class="ae mw" href="https://martinfowler.com/articles/micro-frontends.html" rel="noopener ugc nofollow" target="_blank">深入微前端</a></li><li id="7096" class="nx ny it lp b lq og lt oh lw oi ma oj me ok mi oc od oe of bi translated">微前端上的思想作品<a class="ae mw" href="https://www.thoughtworks.com/radar/techniques/micro-frontends" rel="noopener ugc nofollow" target="_blank">作品</a></li><li id="40ba" class="nx ny it lp b lq og lt oh lw oi ma oj me ok mi oc od oe of bi translated">Hello Fresh的<a class="ae mw" href="https://engineering.hellofresh.com/front-end-microservices-at-hellofresh-23978a611b87" rel="noopener ugc nofollow" target="_blank">微前端实现</a></li><li id="18f8" class="nx ny it lp b lq og lt oh lw oi ma oj me ok mi oc od oe of bi translated"><a class="ae mw" href="https://aws.amazon.com/blogs/architecture/micro-frontend-architectures-on-aws/" rel="noopener ugc nofollow" target="_blank"> AWS上的微前端</a></li><li id="9e40" class="nx ny it lp b lq og lt oh lw oi ma oj me ok mi oc od oe of bi translated">书:<a class="ae mw" href="https://learning.oreilly.com/library/view/building-micro-frontends/9781492082989/" rel="noopener ugc nofollow" target="_blank">搭建微前端</a></li><li id="daa3" class="nx ny it lp b lq og lt oh lw oi ma oj me ok mi oc od oe of bi translated">书:<a class="ae mw" href="https://www.manning.com/books/micro-frontends-in-action" rel="noopener ugc nofollow" target="_blank">微前端在行动</a></li></ul></div></div>    
</body>
</html>