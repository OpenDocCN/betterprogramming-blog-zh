<html>
<head>
<title>Xcode Build Time Optimization (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Xcode构建时优化(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/xcode-build-time-optimization-part-2-6952daf200b9?source=collection_archive---------6-----------------------#2020-05-01">https://betterprogramming.pub/xcode-build-time-optimization-part-2-6952daf200b9?source=collection_archive---------6-----------------------#2020-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="763f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索加速Xcode构建时间的技术</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/64377aa655c74d6592e7163018e0a395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eJG80hlWJXHk6aD-"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图恩·nguyễn·明在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="66de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">加快构建时间对于开发人员的生产力和产品的上市时间至关重要。控制你的构建时间并在需要的时候改进它是非常重要的。</p><p id="f346" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://medium.com/@mshcheglov/xcode-build-time-optimization-part-1-9adb5073994b" rel="noopener">的上一篇文章</a>中，我们学习了如何测量Xcode的构建时间，并获得一些指标进行分析。在这一篇中，我将向您展示我们如何解决Xcode构建时间瓶颈并加速它。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8b55" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">优化什么</h1><p id="bd74" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在我们开始之前，我建议获取项目的初始构建时间度量。以下是我们收到的关于<a class="ae kv" href="https://github.com/kickstarter/ios-oss" rel="noopener ugc nofollow" target="_blank"> Kickstarter iOS项目</a>的Xcode构建时间摘要:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/f65f773a29af5f86b26015015078100a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RFtdMD__uFfnDn5a"/></div></div></figure><p id="048b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用上面的构建时间度量，我们现在可以找到构建过程中最耗时的任务，并定义哪些可以改进。我将构建时优化技术分为以下几种:</p><ul class=""><li id="fc79" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">构建设置优化</li><li id="5615" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">源代码改进</li><li id="6bfa" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">项目增强</li><li id="0810" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">其他人</li></ul><p id="c341" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们深入细节！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="748f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">构建设置优化</h1><p id="93ce" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们应该做的第一件事是检查我们的项目是否针对调试配置进行了优化配置。默认情况下，创建新项目时会预先填充这些设置。但是在现有项目中检查它们是值得的，以防有人不小心更改了它们。</p><h2 id="4b8f" class="nl ma iq bd mb nm nn dn mf no np dp mj lf nq nr ml lj ns nt mn ln nu nv mp nw bi translated">仅构建活动架构(ONLY_ACTIVE_ARCH)</h2><p id="361b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果启用，Xcode只会为活动架构创建一个二进制文件。在开发阶段，我们在设备或模拟器(活动架构)上构建项目。发布版本应该包含所有支持的架构，因为一个架构通过App Store提供给所有类型的用户设备。确保将Debug设置为Yes，将Release设置为No。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/a2cecd7ebaa06435b6621b5197ecb06f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Nzc1xJYRlgcU8I_2"/></div></div></figure><h2 id="c3ee" class="nl ma iq bd mb nm nn dn mf no np dp mj lf nq nr ml lj ns nt mn ln nu nv mp nw bi translated">编译模式(SWIFT_COMPILATION_MODE)</h2><p id="2fc9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">该设置定义了如何在模块内重建Swift文件。将其设置为增量调试配置，仅重建过期的Swift源文件。使用整个模块进行发布，以重建模块中的所有Swift源文件，并应用某些代码优化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/06a36ae0f9f23b5a25ce22bdff4afaac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UAz3T9onMtW_0thm"/></div></div></figure><h2 id="7819" class="nl ma iq bd mb nm nn dn mf no np dp mj lf nq nr ml lj ns nt mn ln nu nv mp nw bi translated">优化级别(SWIFT_OPTIMIZATION_LEVEL)</h2><p id="c7ef" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">优化级别设置定义了我们希望优化构建的方式。由于优化过程中涉及到额外的工作，代码优化会导致构建时间变慢。调试版本应该配置为没有优化，因为我们需要一个快速的编译时间。对于发布版本，可以设置为优化速度。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/2fb91358c6408b4fc6e5041147340da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vHlwb_PIYh687SWz"/></div></div></figure><h2 id="c8d3" class="nl ma iq bd mb nm nn dn mf no np dp mj lf nq nr ml lj ns nt mn ln nu nv mp nw bi translated">调试信息格式(DEBUG_INFORMATION_FORMAT)</h2><p id="1ed6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe oa ob oc od b">dSYM</code>是一个包含调试信息的调试符号文件，用来表示和解释崩溃报告。您应该总是为发布版本创建一个，但是大多数时候您不会将它用于调试版本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/1e4bd03b0bff7c78443df7dcf2c67f07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jfVY7fF8GvPDrG6p"/></div></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9c7d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">源代码改进</h1><h2 id="5707" class="nl ma iq bd mb nm nn dn mf no np dp mj lf nq nr ml lj ns nt mn ln nu nv mp nw bi translated">找到编译缓慢的代码</h2><p id="2697" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">正如我们在<a class="ae kv" href="https://www.onswiftwings.com/posts/build-time-optimization-part2/www.onswiftwings.com/posts/build-time-optimization-part1" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中了解到的，编译过程中速度变慢的主要原因之一是对复杂表达式的求值。为了帮助我们找到Swift编译器遇到困难的地方，Xcode可以为任何函数或表达式生成一个警告，该函数或表达式的类型检查时间超过了指定的限制。以下是我用<a class="ae kv" href="https://github.com/RobertGummesson/BuildTimeAnalyzer-for-Xcode" rel="noopener ugc nofollow" target="_blank">构建时间分析器</a>得到的Kickstarter项目的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/f2592a911f6dd3265b0d584699c45811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KZSzY4wzfiWddu20"/></div></div></figure><p id="169b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看最大的罪犯。函数<code class="fe oa ob oc od b">configureBaseGradientView()</code>在Xcode构建日志中被提到了20次，每次执行类型检查需要10，067 ms。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/37b3433e113f8e2a59bda895d34838e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ks8uDRfQrlJnMCfT"/></div></div></figure><p id="8c93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">中缀运算符<code class="fe oa ob oc od b">|&gt;</code>调用链有一个复杂的表达式。毫不奇怪，花了一些时间来打字检查一个。作为一种改进，我们可以显式地指定类型并将它分成两部分:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/0fe63a28a88f37ed7b5cc57530e71883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_-LYDM853ksvTpxJ"/></div></div></figure><p id="9b03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这样，我们可以修复剩下的问题，并将总构建时间从92秒减少到57秒。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/c27c8f55403f180feed2c6aed8493dc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GbPakXGjEjKE3fvu"/></div></div></figure><h2 id="76e4" class="nl ma iq bd mb nm nn dn mf no np dp mj lf nq nr ml lj ns nt mn ln nu nv mp nw bi translated">减少重建工作</h2><p id="69f9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">理解Swift编译器如何工作并找到要重新编译的文件非常重要。您可能知道Swift的依赖模型是基于文件的。如果你在一个函数体中做了改变，编译器会很聪明的知道只有那个文件需要重新编译。另一方面，在文件中添加或删除一个新的函数或实体将触发所有依赖于它的文件的重新编译。</p><p id="9d03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以执行以下操作来减少编译器在重新生成时应该做的工作:</p><ul class=""><li id="0ef4" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">在单独的文件中定义实体。</li><li id="4cde" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">为你的类、结构、枚举、扩展等使用正确的访问修饰符。</li></ul><h2 id="20bd" class="nl ma iq bd mb nm nn dn mf no np dp mj lf nq nr ml lj ns nt mn ln nu nv mp nw bi translated">移除未使用的代码</h2><p id="9b05" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">随着项目的发展，可能会出现不再使用或永远无法访问的代码。它会降低项目的构建时间，因此需要找到并删除它。我在之前的一篇文章中描述了如何做到这一点。</p><h2 id="9893" class="nl ma iq bd mb nm nn dn mf no np dp mj lf nq nr ml lj ns nt mn ln nu nv mp nw bi translated">预生成依赖项</h2><p id="6544" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">每个项目都有不同的依赖项，这些依赖项可能会减慢构建过程。您可以通过使用预构建的动态框架和库来提高构建的效率。那么如果有新的版本，就应该重新构建框架。这种方法适用于不经常改变的内部和外部依赖关系。</p><h2 id="12e8" class="nl ma iq bd mb nm nn dn mf no np dp mj lf nq nr ml lj ns nt mn ln nu nv mp nw bi translated">代码与Xibs故事板</h2><p id="8c39" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">您可能会考虑从代码中实现UI，而不是使用Xib和故事板文件。在我看来，这两种方法各有利弊。将UI定义在Xib和故事板文件中会减慢干净构建的速度，并增加应用程序的大小。另一方面，它应该比由代码创建的复杂UI更容易理解。说到增量构建，您不会注意到显著的构建时间差异。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0989" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">项目增强</h1><h2 id="01e1" class="nl ma iq bd mb nm nn dn mf no np dp mj lf nq nr ml lj ns nt mn ln nu nv mp nw bi translated">改进运行脚本阶段</h2><p id="c221" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">每当您构建项目时，都会执行运行脚本阶段。您可以在“构建阶段”面板上找到阶段:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/aa318a0700bf3fc07906417789a5653b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Gm4zQgKSNI133A4g"/></div></div></figure><p id="6cda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们为此目标定义了下一个运行脚本阶段:</p><ul class=""><li id="39c0" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">Swiftlint —运行<code class="fe oa ob oc od b">swiftlint</code>来加强编码风格和约定。</li><li id="ced0" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">Fabric —运行初始化Crashlytics的脚本。</li><li id="5135" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">Carthage —将框架复制到应用程序包中，并删除未使用的架构。</li></ul><p id="d1f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行项目的所有运行脚本阶段花费了6秒钟。我们可能不应该在每次重建项目时都运行这些任务。以下是我们加快速度的方法:</p><ul class=""><li id="d42b" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">请考虑使用git提交挂钩。</li><li id="fb14" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">如果可能，跳过运行调试配置或模拟器目标的脚本。</li><li id="aa77" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">声明脚本的输入和输出，或者使用复制文件阶段。</li></ul><h2 id="580a" class="nl ma iq bd mb nm nn dn mf no np dp mj lf nq nr ml lj ns nt mn ln nu nv mp nw bi translated">采用模块化架构</h2><p id="b350" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果你正在做一个大项目，把一个完整的代码库分成几个模块是一个好主意。模块化您的代码允许Xcode只编译您修改的模块，并缓存这些输出以供将来构建。此外，从Xcode 10开始，我们可以从尽可能并行构建目标中受益。</p><p id="35a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们使用<a class="ae kv" href="https://github.com/PaulTaykalo/xcode-build-times-rendering" rel="noopener ugc nofollow" target="_blank">xcode-build-times-rendering</a>来检查模块及其构建时间:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/ab572e31a927bb8365fdf7c3ab04eeee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VV4EatP6tH65WVRh"/></div></div></figure><p id="0c28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，该项目包含三个框架目标和负责建立所有依赖关系的应用程序目标。但是我们无法从并行化中获得最大收益，因为这些目标之间存在线性依赖关系。更好的选择是定义独立的功能模块:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/0ee98f5cae4bee5a2a01383daee5f439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E_ERfS04LvA_wnd6"/></div></div></figure><p id="fa8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以这种方式模块化您的代码使得并行构建执行更加有效，并且加速了增量构建。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d03f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">其他人</h1><p id="6c42" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">使用上述方法，您可以加快大多数项目的构建时间。但是这些并不是你可以使用的所有技术。您可以考虑使用像Buck或Bazel这样的构建系统，并为构建工件提供远程缓存。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="72a6" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="acac" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">漫长的构建时间会减缓开发过程，并直接影响您的生产力。在本文中，我们探讨了如何减少编译器应该做的工作并提高构建效率。</p><p id="7617" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你如何控制项目的构建时间？你使用本文中提到的任何技术吗？让我知道你的想法，或者在下面的评论区问任何你可能有的问题。</p><p id="9a08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>