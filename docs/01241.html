<html>
<head>
<title>Introduction to Tree Shaking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">摇树入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-tree-shaking-e94e57db081e?source=collection_archive---------1-----------------------#2019-08-26">https://betterprogramming.pub/introduction-to-tree-shaking-e94e57db081e?source=collection_archive---------1-----------------------#2019-08-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a57b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过静态分析在编译时删除未使用或不可访问的代码。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/205805ea33af09fd355ca04a9a553544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X0GEyTiVAv9jenUc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@johannsiemens?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约翰·西门子</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="8798" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="a972" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">今天我们来看看最容易被误解的减小体积的方法之一，摇晃树木。树的晃动引起了很多议论，所以值得研究。</p><blockquote class="mn mo mp"><p id="3d18" class="lr ls mq lt b lu mr ju lw lx ms jx lz mt mu mc md mv mw mg mh mx my mk ml mm im bi translated"><em class="it">注意:要获得更多关于束尺寸的帮助，请查看</em> <a class="ae ky" href="https://medium.com/better-programming/reducing-js-bundle-size-58dc39c10f9c" rel="noopener"> <em class="it">测量</em> </a> <em class="it">和</em> <a class="ae ky" href="https://medium.com/better-programming/reducing-js-bundle-size-a6533c183296" rel="noopener"> <em class="it">死代码消除</em> </a> <em class="it">！</em></p></blockquote><p id="58c5" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们将研究树抖动意味着什么，它是如何工作的，它如何帮助消除死代码和模块依赖性，最后，我们应该从它那里得到什么。让我们首先回顾一下死代码消除。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="5741" class="kz la it bd lb lc ng le lf lg nh li lj jz ni ka ll kc nj kd ln kf nk kg lp lq bi translated">死代码消除概述</h1><p id="ae92" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本系列的上一篇文章中，我们深入探讨了什么是<a class="ae ky" href="https://medium.com/better-programming/reducing-js-bundle-size-a6533c183296" rel="noopener">死代码消除</a> (DCE)。尽管如此，让我们快速回顾一下DCE是什么，因为它对于理解树摇动是至关重要的，因为树摇动使用相同的技术。</p><p id="f7c7" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">DCE是删除未使用或不可访问的代码的过程。像<a class="ae ky" href="https://github.com/terser-js/terser" rel="noopener ugc nofollow" target="_blank"> Terser </a>这样的工具通常与Webpack这样的构建系统一起处理DCE。以下是DCE的一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d7c7" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">在上面的例子中，不可能返回到<code class="fe nn no np nq b">type: hat</code>。那是因为事先有else，使得代码不可访问。Terser将尝试确定这一点，并删除这些未使用的示例。</p><p id="6d99" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">类似地，<code class="fe nn no np nq b">selectAccessory</code>函数在这段代码中从未执行过，因此也可以删除。但是如果我们对文件运行Terser，您会注意到它没有被删除。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="eab1" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">为什么这个没有被移除？因为Terser不是正数，所以这个函数不会在其他地方使用，也不会进行那个调用。它只删除它能保证不会被使用的代码。如果有任何歧义，它将不会采取任何行动。</p><p id="5cb0" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们需要的是将这个文件隔离为一个模块。封装一个文件可以用几种不同的模块风格来完成，但是<a class="ae ky" href="https://nodejs.org/docs/latest/api/modules.html" rel="noopener ugc nofollow" target="_blank"> CommonJS </a> (CJS)和<a class="ae ky" href="https://exploringjs.com/es6/ch_modules.html" rel="noopener ugc nofollow" target="_blank"> ECMAScript模块</a> (ESM)无疑是最受欢迎的，ESM是前端的标准，CJS仍然普遍用于<a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>。</p><p id="597c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">不管怎样，在这一点上，你甚至不需要知道这是什么风格。通过使用<a class="ae ky" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>运行构建，我们可以看到不同之处。</p><blockquote class="mn mo mp"><p id="4392" class="lr ls mq lt b lu mr ju lw lx ms jx lz mt mu mc md mv mw mg mh mx my mk ml mm im bi translated"><em class="it">对于所有的Webpack示例，我将保持代码不变。那是因为我想给出这段代码的样子。我已经用</em> <code class="fe nn no np nq b"><em class="it">console.log(name)</em></code> <em class="it">为我们提供了狩猎的地点。</em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a605" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">Webpack做了很多优化，所以代码读起来可能有点棘手，但是请注意，现在已经没有<code class="fe nn no np nq b">type:ring</code>的实例了。它意识到这个函数从来没有在模块内部调用过，并消除了它。</p><blockquote class="mn mo mp"><p id="e871" class="lr ls mq lt b lu mr ju lw lx ms jx lz mt mu mc md mv mw mg mh mx my mk ml mm im bi translated"><em class="it">注意:接下来，我们将按照ESM风格调用这些</em>模块，<em class="it">。假设这些都是封装的部分，会让他们想起来更舒服。我们将很快讨论为什么要使用ESM。</em></p></blockquote></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="fd57" class="kz la it bd lb lc ng le lf lg nh li lj jz ni ka ll kc nj kd ln kf nk kg lp lq bi translated">那么什么是树摇动呢？</h1><p id="d403" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我发现考虑这个问题的最简单的方法是把它想象成跨模块的死代码消除。到目前为止，我们的死代码消除只对给定的模块内部有效。它将检查代码是否不可访问或被调用，并从该模块中删除它。</p><p id="210a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">但是如果我们有一个永远不会被调用的模块呢？还是只有一小部分是？那么我们可以从我们的代码库中移除它或者未使用模块中未使用的部分吗？</p><p id="ec88" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">答案是“是的”，其中一些可能已经在you⁠发生了——只是你不知道而已。让我们来看看这是如何实现的，以及这对您有何用处。我们将遵循以下步骤来实现这一目标:</p><ul class=""><li id="b789" class="nr ns it lt b lu mr lx ms ma nt me nu mi nv mm nw nx ny nz bi translated">理解为什么称之为摇树，这样我们就能从根本上理解我们的目标是什么</li><li id="6cda" class="nr ns it lt b lu oa lx ob ma oc me od mi oe mm nw nx ny nz bi translated">如何以一种允许最佳树抖动的方式编码</li><li id="0c22" class="nr ns it lt b lu oa lx ob ma oc me od mi oe mm nw nx ny nz bi translated">查看这种风格的代码示例</li><li id="0e87" class="nr ns it lt b lu oa lx ob ma oc me od mi oe mm nw nx ny nz bi translated">调查什么样的场景最有利于树摇动的应用</li></ul></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="9811" class="kz la it bd lb lc ng le lf lg nh li lj jz ni ka ll kc nj kd ln kf nk kg lp lq bi translated">为什么叫树摇？</h1><p id="236f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们停下来思考一下模块依赖是如何工作的。您告诉Webpack它应该查找的第一个文件，通常类似于<code class="fe nn no np nq b">src/index.js</code>。从那里，Webpack将打开该文件，并可能注意到您正在导入<code class="fe nn no np nq b">a.js</code>。然后它会注意到<code class="fe nn no np nq b">index</code>依赖于<code class="fe nn no np nq b">a.js</code>。在<code class="fe nn no np nq b">index</code>之后，Webpack将查看<code class="fe nn no np nq b">a.js</code>并扫描它的依赖性。</p><blockquote class="mn mo mp"><p id="b57a" class="lr ls mq lt b lu mr ju lw lx ms jx lz mt mu mc md mv mw mg mh mx my mk ml mm im bi translated"><em class="it">注意:根据模块系统的不同，会有一些异步加载，但为了简单起见，我们还是同步讨论一下。</em></p></blockquote><p id="5e2d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">为了更好地理解这一点，让我们添加一些文件到我们的小项目中，并导入一些文件。既然我们已经有了<code class="fe nn no np nq b">index.js</code>，让我们再做四个文件，分别命名为<code class="fe nn no np nq b">a.js</code>、<code class="fe nn no np nq b">b.js</code>、<code class="fe nn no np nq b">c.js</code>和<code class="fe nn no np nq b">d.js</code>。然后按照下面每个文件的步骤操作:</p><p id="6bda" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><strong class="lt iu"> a.js </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="551c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><strong class="lt iu"> b.js </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a842" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><strong class="lt iu"> c.js </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6cb5" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><strong class="lt iu">戴杰</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0da8" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><strong class="lt iu"> index.js </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0d3f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">很好，所以看上面的代码，我们可以映射出依赖关系。每个模块可以依赖于<code class="fe nn no np nq b">0...n</code>模块。让我们将这些依赖关系放在一个表中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/23bbb36d57820737330166c157d0a322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBuKpf9BebxtiSwVNNpOig.png"/></div></div></figure><p id="1d5c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">完成简单的依赖关系表后，让我们将其绘制成图表。一个圆圈代表每个模块，一条线代表一个依赖关系。箭头表示它是dependee模块。在我们的例子中，图表应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/b7e3cae91f3a3491aa497f3adf4d22fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3sIepVDcE69agACt.png"/></div></div></figure><p id="d917" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">看起来有点像树，不是吗？我们的模块集仍然很小，并且依赖关系有些连锁。在我们前进之前，看到一些更重要的项目，获得更好的视觉表现，将是很方便的。有一个很棒的工具可以做到这一点:Webpack Analyzer。它将为我们构建这些依赖图。首先，在我们项目运行的根中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="b16b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">上述命令将创建一个<code class="fe nn no np nq b">webpack-state.json</code>文件。现在，我们可以在分析器网站<a class="ae ky" href="https://webpack.github.io/analyse/#home" rel="noopener ugc nofollow" target="_blank">这里</a>上传这个。但是如果您导航到modules选项卡，您会注意到它看起来有点乏味:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/9ff40c633452fe960c1cb063f7826e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jlS-iCAqQkbiyUQo7Gi7FA.png"/></div></div></figure><p id="5b3c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">嗯，我们的Webpack将这些捆绑在一起作为一个单独的块。因此，我们只把它看作一个点。但是我们现在知道了这个过程，所以我们在一个更重要的项目上尝试一下怎么样？我准备在<a class="ae ky" href="https://github.com/BoostIO/Boostnote" rel="noopener ugc nofollow" target="_blank"> Boostnote </a>上试试，一个用<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>写的跨平台markdown编辑器。</p><p id="7d98" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">首先，我们将用以下代码克隆Boostnote:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0ba2" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">如果我们将<code class="fe nn no np nq b">webpack-stats</code>上传到Webpack分析器，我们会得到类似这样的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/19a971d94433ff640953ba5b16e3b308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EDJjYmqHjNN6yE8X5TLLVA.png"/></div></div></figure><p id="9ddc" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这是一棵树。不幸的是，<code class="fe nn no np nq b">main.js</code>实际上位于所有这些中间，将它创建为一个向外的网络是对空间的最佳利用。但是如果我们把它想象成基础，一切都会以一种更经典的树的形式向外扩展，有一组节点和叶子节点。</p><p id="8bf6" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">那么这和树摇晃有什么关系呢？好了，现在我们知道我们的模块结构本质上是由节点树组成的，如果我们不使用一些依赖，会发生什么呢？再次给出我们上面的项目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/81c7262d578ae0bc49c477d6746f9918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kLDpwbJM-ZOamQkX.png"/></div></div></figure><p id="fe51" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">如果我们不再依赖<code class="fe nn no np nq b">a -&gt; c</code>，会发生什么？我们的依赖图现在看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/cabf64ddabb3ef52dce7d45dae4c0ebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*w_shXflI9MZ4r2xh.png"/></div></div></figure><p id="d61a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">虽然<code class="fe nn no np nq b">a -&gt; c</code>之间的依赖现在已经不存在了，但是所有的模块仍然以某种方式被需要。当Webpack运行所有模块时，它会识别出每个模块都是在某个点导入的，并将它们添加到我们的捆绑块中。</p><p id="2927" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们返回我们的<code class="fe nn no np nq b">a -&gt; c</code>依赖项，但是现在移除我们的<code class="fe nn no np nq b">b -&gt; d</code>依赖项。现在会有什么不同？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/745a02e0a12dbd818baed617a5f6cc26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f2nYLrmeF2fMe2mx.png"/></div></div></figure><p id="41fb" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这就是晃动树木开始发挥作用的地方。当我们构建这些树和它们的包时，我们必须认识到一个重要的关系。</p><p id="0045" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们从<code class="fe nn no np nq b">index</code>开始(或者我们告诉Webpack的任何东西都是我们的起始模块)。图中的每一步都是一个<code class="fe nn no np nq b">dependsOn</code>关系。在上面的例子中，虽然<code class="fe nn no np nq b">d</code>确实依赖于<code class="fe nn no np nq b">c</code>，但是没有依赖于<code class="fe nn no np nq b">d</code>的模块。因此，树会晃动，我们实际的树会是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/68eb544850bea8463d73609a56510d05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fpwLhqf3m75gbLA1.png"/></div></div></figure><p id="bd1c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">发生了树抖动，我们从依赖关系中移除了一个不需要的模块。这是一个简单的例子，那么多重依赖呢？让我们添加回我们的<code class="fe nn no np nq b">b -&gt; d</code>依赖项，并移除我们的<code class="fe nn no np nq b">a -&gt; b</code>依赖项。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/56e93b959a44561120839745d9d6116d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gB3H8atzsMmO6FXV.png"/></div></div></figure><p id="bda0" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">就像上次一样，让我们浏览一下模块，看看它们的依赖项现在在哪里。除了<code class="fe nn no np nq b">b</code>之外，每个模块都有一个<code class="fe nn no np nq b">dependsOn</code>关系。因此，树会发生晃动，我们得到下面的树:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/62245defa40d0cb6e27715ed6706b647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RZr4UV7tfjTnOqmb.png"/></div></div></figure><p id="de14" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们的<code class="fe nn no np nq b">d</code>模块怎么了？好吧，既然没有模块依赖<code class="fe nn no np nq b">b</code>，就把它去掉了。一旦<code class="fe nn no np nq b">b</code>被移除，从我们的基地(<code class="fe nn no np nq b">index</code>)到<code class="fe nn no np nq b">d</code>模块就再也没有路径了。因此，正如你所看到的，当我们“摇动”这棵树时，我们从代码库中移除了未使用的模块。</p><p id="a267" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">现在这里有一个重要的免责声明:上面的例子并不完全是“树摇动”从技术意义上来说，这是树摇动，但不是我们通常所说的树摇动。相反，我一直在向您展示<a class="ae ky" href="https://en.wikipedia.org/wiki/Dependency_graph" rel="noopener ugc nofollow" target="_blank">模块依赖</a>以及您的模块捆绑器将如何从这些模块构建依赖图(和最终捆绑包)。但是我们很接近了，上面的过程是树摇动的基础。我们刚刚跳过了摇树过程中的一个步骤，以便在较高层次上更容易理解。</p><p id="e58e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">在讨论最后一步之前，我们需要了解什么是静态分析，以及ESM如何在其中发挥作用。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="a794" class="kz la it bd lb lc ng le lf lg nh li lj jz ni ka ll kc nj kd ln kf nk kg lp lq bi translated">CJS对欧洲稳定机制</h1><p id="d2aa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">JavaScript生态系统中的模块系统有相当长且详细的历史:<a class="ae ky" href="https://github.com/umdjs/umd" rel="noopener ugc nofollow" target="_blank"> UMD </a>、<a class="ae ky" href="https://requirejs.org/docs/whyamd.html" rel="noopener ugc nofollow" target="_blank"> AMD </a>、CJS、ESM等等。其中一些系统，如AMD，在前端非常突出，像<a class="ae ky" href="https://requirejs.org/docs/whyamd.html" rel="noopener ugc nofollow" target="_blank"> RequireJS </a>这样的实现非常流行。</p><p id="54e6" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">同时，随着Node越来越受欢迎，它的模块系统CommonJS也越来越受欢迎。CommonJS最初被指定严格用于NodeJS。但是正如<a class="ae ky" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM </a>在吞噬<a class="ae ky" href="https://bower.io/" rel="noopener ugc nofollow" target="_blank">鲍尔</a>之前最初是一个NodeJS包管理系统，CJS也是这样走到了前端。</p><p id="b6dd" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">曾几何时，CJS通常是构建前端应用程序和库的实际方式。像Webpack这样的模块捆绑商经常假设CJS将会是被使用的规范。但是CJS不是静态可分析的，因为它没有静态结构。那是什么意思？</p><p id="7198" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们来看一些CJS代码的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4428" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">在运行之前，我们无法确定<code class="fe nn no np nq b">y</code>将会是什么，以及它会导入什么。它有一个<a class="ae ky" href="https://exploringjs.com/es6/ch_modules.html#static-module-structure" rel="noopener ugc nofollow" target="_blank">动态结构</a>。我们导出代码的时候呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="49c1" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">同样，代码是动态构造的；因此，我们可以在运行时更改我们的导出。我们无法肯定进口或出口的是什么，使用的是什么。这些值都可以在运行时改变。</p><p id="8b49" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">然后我们来看ECMAScript模块。ESM是已经工作了一段时间的最新规范，是ECMAScript的官方提案。ESM是静态结构化的，这意味着所有的导入和导出都必须在编译时(而不是运行时)定义。</p><p id="2022" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">因此，我们可以保证导入和导出哪些模块。静态结构有几个积极的好处，但它也意味着我们可以分析代码，并确定在编译时使用哪些导出。</p><blockquote class="mn mo mp"><p id="cbb0" class="lr ls mq lt b lu mr ju lw lx ms jx lz mt mu mc md mv mw mg mh mx my mk ml mm im bi translated"><em class="it">注意:ESM有很多这里没有提到的好处，比如异步加载、更快的查找等。我们将在以后的文章中深入探讨这些问题。</em></p></blockquote></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="9d12" class="kz la it bd lb lc ng le lf lg nh li lj jz ni ka ll kc nj kd ln kf nk kg lp lq bi translated">这在代码中是什么样子的？</h1><p id="05ac" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们跳回到我们之前的例子<code class="fe nn no np nq b">a.js</code>、<code class="fe nn no np nq b">b.js</code>、<code class="fe nn no np nq b">c.js</code>和<code class="fe nn no np nq b">d.js</code>。就像我刚才说的，我们还没有完全做到摇树。我们遵循一个模块依赖链。但是，让我们把我们的例子更进一步。假设我们回到了最初的依赖关系，就像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/47e0b0031fe9ce7b47b609a134e93134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xUwHIQfa1Mw7Us6r.png"/></div></div></figure><p id="9bc0" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们来看看<code class="fe nn no np nq b">b.js</code>代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="043b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">一切都是正常的，我们的依赖图准确地表示了模块。但是，如果我们没有使用<code class="fe nn no np nq b">d</code>并且没有移除<code class="fe nn no np nq b">import</code>，会发生什么呢？像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="8ee1" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">如果这是CJS，我们仍然会有和上面一样的图表；因为我们不能保证在运行时，它会以某种方式被调用。但是我们可以确定它不是在编译时用ESM调用的，因此可以充分地对它进行树抖动。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/34e57493903157b0f3440e31b70be0f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*elZaJkbo4TsL91pt.png"/></div></div></figure><p id="59b6" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这是我们在Webpack中捆绑后的例子。注意没有<code class="fe nn no np nq b">console.log("This is d!")</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c693" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">最后，我们来看最后一个树抖动的例子:树抖动一个有多个导出的模块。由于树抖动也是死代码消除的一部分，并且我们可以静态地分析我们的代码，所以它不仅可以帮助处理模块依赖性，还可以帮助发现哪些代码可以被消除。我们将回到最初的结构，但会稍作改动:</p><p id="5e2e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><strong class="lt iu"> b.js </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="b509" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们更新我们的<code class="fe nn no np nq b">d.js</code> API来匹配:</p><p id="549a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><strong class="lt iu"> d.js </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="fa6e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">现在，我们的死代码消除不能删除导出的函数，因为它们可以在这个模块之外使用。当人们使用CJS时，我们的代码不是静态结构化的；因此，我们无法确定代码是否被使用过，尤其是在编译之前。</p><p id="e026" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">但是有了ESM，Webpack(或大多数模块捆绑器)可以检查这些代码，并确定这些函数是否被导入或使用过。如果它们没有被使用，就像上面的<code class="fe nn no np nq b">multiply</code>一样，树抖动发生，导出语法被删除。死代码消除照常接管，并注意到该函数没有被使用，并将它从代码库中删除。让我们通过运行下面的命令来看看它的运行情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="70af" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">注意上面的<code class="fe nn no np nq b">console.log('multiply')</code>并不存在。摇树为我们移除了代码。依赖图是什么样子的？嗯，它看起来像我们的原始图，只是从<code class="fe nn no np nq b">d</code>模块中删除了死代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/6bfebbefab7b6d6be156924dabe86e2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2EqUEoP82ISnPOiH.png"/></div></div></figure></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="6136" class="kz la it bd lb lc ng le lf lg nh li lj jz ni ka ll kc nj kd ln kf nk kg lp lq bi translated">作为一种优化，要小心摇晃采油树</h1><p id="6a02" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在你明白了什么是摇树，以及它对我们有什么帮助，我想开始说它对你的用法会有很大的不同。根据你正在构建的东西，你如何设置你的包以及设置树抖动的效果会有所不同。</p><p id="218b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这是因为树抖动可以方便地删除未使用的模块和代码。</p><p id="d816" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">取决于你在构建什么，这可能非常方便，或者对你几乎没有价值。摇树已经成为web开发社区的一个时髦词汇，作为一种几乎神奇的方式来减少包的大小。而且，在某些领域，这可能是不可思议的。但是我想早点设定预期，你可能不会这样。</p><h2 id="3d5d" class="oj la it bd lb ok ol dn lf om on dp lj ma oo op ll me oq or ln mi os ot lp ou bi translated">一个小小的警示故事</h2><p id="3f83" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我和我的同事决定减少应用程序的包大小。</p><p id="ed7d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们有几个计划，但摇树无疑是我们的首要任务之一。问题是，我们的代码是CJS和ESM的混合。因此，我们构建了几个代码模块来将我们的系统迁移到ESM。</p><p id="d647" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">在迁移之前，我们通过强制Babel构建到ESM中，测试了可能的包大小缩减。看来我们可以减少近20%的捆绑销售。这是巨大的。</p><p id="5681" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们完成了迁移并重新运行了分析器。我们将核心产品包减少了3%到5%。仍然有用，但远没有达到我们希望的水平。</p><p id="1d5a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">那么，为什么我们的数字相差如此之远呢？好吧，在我们早期的测试中，当我们强迫CJS进入ESM时，在两个规格之间导入工作是不同的(即默认)。当Webpack分析代码时，它确定导入位置没有任何东西，并将删除该模块，尽管我们需要它，这大大增加了树抖动效应。</p><blockquote class="mn mo mp"><p id="4e7b" class="lr ls mq lt b lu mr ju lw lx ms jx lz mt mu mc md mv mw mg mh mx my mk ml mm im bi translated"><em class="it">构建从CJS迁移的代码模块- &gt; ESM花费了相当多的时间和精力。两种规格之间存在一些意想不到的边缘情况。我期待开源我们所做的工作，并希望很快写一个博客详细介绍这个过程！</em></p></blockquote></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="1b5a" class="kz la it bd lb lc ng le lf lg nh li lj jz ni ka ll kc nj kd ln kf nk kg lp lq bi translated">摇树Web App vs .库代码</h1><p id="5316" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要了解树抖动对你有多大用处，首先要确定你的代码库中目前有多少未使用的代码？</p><p id="9d1a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">如果您正在构建一个web应用程序，树抖动仍然会派上用场，但是您从中获得的实际代码优化将是最小的。如果您的代码库中有大量未使用的代码，这种情况会有所不同，但假设您的大部分代码都以某种方式执行，您可能不会看到这种情况的显著减少。</p><p id="3afa" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">一个更有可能让你受益的途径是你使用的库。有些库，尤其是UI库，会被你树摇。举一个项目的例子，它意味着你可以摇动树，<a class="ae ky" href="https://github.com/react-dnd/react-dnd" rel="noopener ugc nofollow" target="_blank"> react-dnd </a>没有以任何方式捆绑，而是完全构建在ESM中。将项目导入你的web app后，如果你的应用是用树摇制作的，自然会树摇<code class="fe nn no np nq b">react-dnd</code>。</p><p id="516d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这也意味着，如果你正在开发一个库，以这样一种方式设置它是必要的，用户可以树摇他们不使用的元素。这就是为什么你会经常看到一些这样的库不捆绑他们的库，而只是通过Babel传递它，并允许用户自己动摇它。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="526d" class="kz la it bd lb lc ng le lf lg nh li lj jz ni ka ll kc nj kd ln kf nk kg lp lq bi translated">结束语</h1><p id="ee9b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">尽管我在上面提出了警告，但是树抖动、模块依赖和死代码消除是您的必备工具。它们是理解尝试减少JavaScript包大小的方法的基础。</p><p id="34f2" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们将采取的下一步实际上是我相信你可以帮助你的客户减少<a class="ae ky" href="https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive" rel="noopener ugc nofollow" target="_blank">交互</a>时间的核心方法，那就是代码分割。我们将很快对此进行深入研究，并总结一下<em class="mq"> Reducing JS Bundles </em>系列。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="0d32" class="kz la it bd lb lc ng le lf lg nh li lj jz ni ka ll kc nj kd ln kf nk kg lp lq bi translated">参考资料和进一步阅读</h1><div class="ov ow gp gr ox oy"><a href="https://webpack.js.org/guides/tree-shaking/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">摇树|网络包</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">webpack是一个模块捆绑器。它的主要目的是捆绑JavaScript文件以便在浏览器中使用，但它也…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">webpack.js.org</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://medium.com/better-programming/reducing-js-bundle-size-58dc39c10f9c" rel="noopener follow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">减小JS包的大小</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">第一部分:策略的度量和高级视图</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">medium.com</p></div></div><div class="ph l"><div class="pn l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://medium.com/better-programming/reducing-js-bundle-size-a6533c183296" rel="noopener follow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">减小JS包的大小</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">第二部分:精简和死码消除</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">medium.com</p></div></div><div class="ph l"><div class="po l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://github.com/terser-js/terser" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">特塞尔-js/特塞尔</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">🗜 JavaScript解析器、代码转换器、优化器和漂亮的ES6工具包</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">github.com</p></div></div><div class="ph l"><div class="pp l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://nodejs.org/docs/latest/api/modules.html" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">Node.js v12.9.0文档</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">在Node.js模块系统中，每个文件都被视为一个单独的模块。例如，考虑一个名为foo.js的文件…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">nodejs.org</p></div></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://exploringjs.com/es6/ch_modules.html" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">16.模块</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">编辑描述</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">exploringjs.com</p></div></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://nodejs.org/en/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">节点. js</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">Node.js是基于Chrome的V8 JavaScript引擎构建的JavaScript运行时。</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">nodejs.org</p></div></div><div class="ph l"><div class="pq l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://webpack.js.org/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">网络包</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">webpack是一个模块捆绑器。它的主要目的是捆绑JavaScript文件以便在浏览器中使用，但它也…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">webpack.js.org</p></div></div><div class="ph l"><div class="pr l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://medium.com/@joeclever/three-simple-ways-to-inspect-a-webpack-bundle-7f6a8fe7195d" rel="noopener follow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">检查Webpack包的三种简单方法</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">Webpack是一个模块捆绑器，这意味着它将所有的JavaScript文件捆绑到一个或多个文件中…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">medium.com</p></div></div><div class="ph l"><div class="ps l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://github.com/BoostIO/Boostnote" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">BoostIO/Boostnote</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">📣Boostnote团队将IssueHunt用于可持续的开源生态系统。面向程序员的笔记应用。应用程序…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">github.com</p></div></div><div class="ph l"><div class="pt l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://reactjs.org/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">react——用于构建用户界面的JavaScript库</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">React使得创建交互式ui变得不那么痛苦。为应用程序中的每个状态设计简单的视图，并反应…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">reactjs.org</p></div></div><div class="ph l"><div class="pu l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://en.wikipedia.org/wiki/Dependency_graph" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">依赖图</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">在数学、计算机科学和数字电子学中，依赖图是一种有向图，表示…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">en.wikipedia.org</p></div></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://github.com/umdjs/umd" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">umdjs/umd</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">适用于任何地方的JavaScript模块的UMD(通用模块定义)模式。- umdjs/umd</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">github.com</p></div></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://requirejs.org/docs/whyamd.html" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">为什么是AMD？</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">什么是JavaScript模块？他们的目的是什么？定义:如何将一段代码封装成一个有用的单元…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">requirejs.org</p></div></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://www.npmjs.com/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">npm</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">JavaScript。企业级。将您的开发放在一个屋檐下，并处理您公司的开源…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">www.npmjs.com</p></div></div><div class="ph l"><div class="pv l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://bower.io/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">凉亭</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">网站由很多东西组成——框架、库、资产和实用程序。鲍尔为…管理所有这些事情</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">bower.io</p></div></div><div class="ph l"><div class="pw l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://exploringjs.com/es6/ch_modules.html#static-module-structure" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">16.模块</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">编辑描述</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">exploringjs.com</p></div></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://medium.com/@lawliet29/tree-shaking-in-real-world-what-could-go-wrong-b398c2b2ebbb" rel="noopener follow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">真实世界中的摇树:会出什么问题？</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">TL；速度三角形定位法(dead reckoning)</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">medium.com</p></div></div><div class="ph l"><div class="px l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://developers.google.com/web/fundamentals/performance/optimizing-javascript/tree-shaking/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">通过摇晃树来减少JavaScript负载|网络基础|谷歌开发者</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">今天的web应用程序可以变得非常大，尤其是其中的JavaScript部分。截至2018年年中，HTTP Archive将…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">developers.google.com</p></div></div><div class="ph l"><div class="py l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://babeljs.io/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">下一代JavaScript的编译器</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">通过我们的入门指南了解更多关于巴别塔的信息，或者查看一些关于它背后的人和概念的视频…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">babeljs.io</p></div></div><div class="ph l"><div class="pz l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">互动时间|网络开发者工具|谷歌开发者</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">负载不是时间上的一个瞬间——它是一种没有一个指标可以完全捕捉到的体验。有多个…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">developers.google.com</p></div></div><div class="ph l"><div class="qa l pj pk pl ph pm ks oy"/></div></div></a></div><p id="8f38" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><a class="ae ky" href="https://webpack.github.io/analyse/" rel="noopener ugc nofollow" target="_blank">https://webpack.github.io/analyse/</a></p></div></div>    
</body>
</html>