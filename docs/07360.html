<html>
<head>
<title>Native Graph-Database Storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">本地图形数据库存储</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/native-graph-database-storage-7ed8ebabe6d8?source=collection_archive---------5-----------------------#2021-01-07">https://betterprogramming.pub/native-graph-database-storage-7ed8ebabe6d8?source=collection_archive---------5-----------------------#2021-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ee0a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Neo4j和图形数据库与关系数据库的比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/660d0f0f913f2179db6b1461692f69db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s1XC7gH9amWoL3qX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@trendmatcher?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">威廉·卡尔森伯格</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h1 id="1d32" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">背景</strong></h1><p id="f489" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">虽然数据库技术在过去二十年中的发展一直被NoSQL和关系的争论所主导，但在同一时期，有一股安静的力量一直在稳步发展。那是本地图形数据库。通过Neo4j [1]的推广，原生图数据库现在已经被许多行业广泛采用，并被许多现实世界的用例所利用。</p><p id="64a9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本文中，我想谈谈原生图数据库中的存储层，因为与NoSQL或关系数据库相比，它上面的在线资源少得多。你能找到的最有用的资料可能是Neo4j人写的书[2]，它掩盖了许多重要的细节。直到我读了源代码，我才终于明白了字节级的东西。</p><p id="a03a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我还应该提到，理论上，原生图数据库应该有多种形式。只要图的节点和它们的连接是存储设计中的一级原语，它就被认为是图原生的。但到目前为止，Neo4j的设计似乎是最被证明的方法。所以我将坚持把它作为原生图形数据库存储的典型例子。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="1139" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated"><strong class="ak">关系存储模型中的图形</strong></h1><p id="98ba" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，让我们看看如何在关系数据库世界中建模一个图。考虑一个非常简单的图，如图1所示。想象一下，它代表了Twitter用户的关系。节点1跟随节点2和3。节点2跟随节点3。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/f7d9870cac3a89f560d05455d9f0db06.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*Lf2pyR2V_paSi54vJHZI7A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1</p></figure><p id="98e3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在关系模型中，您会有一个包含用户配置文件的表，也可能有一个包含用户操作的表——就像他们什么时候开始互相关注一样。但是最重要的是，在图的上下文中，您需要一个关系表来存储用户之间的联系。</p><p id="663c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通常有两种方法可以做到这一点。您可以像图2 (a)那样做:将一条边(关系)的源和目的地存储为一行，并对所有的边都这样做。当您需要查找出站边缘(特定用户跟随的边缘)时，您可以使用索引来“查找”该用户出站关系的起点。</p><p id="914b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，您通常还需要查找传入的边(跟随特定用户的边)，因此您需要一个反向索引来扫描所有用户的入站关系。这两个索引在查找中都导致了<code class="fe nf ng nh ni b">O(log(n))</code>时间复杂度。</p><p id="84f9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">反向索引更糟糕，因为不能有一个稀疏索引只指向用户入站关系的起点。入站关系没有排序——假设您在表中有一行<code class="fe nf ng nh ni b">&lt;2,1&gt;</code>。因此您的反向索引必须完全指定到叶级别。</p><p id="2e7e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你可以选择像图2 (b)那样做。在这种情况下，您将存储一条边两次，并有一个额外的列来指示方向。您可以去掉反向索引，但是仍然需要正向索引——并且您将在应用程序层担心更多的数据一致性问题(对称重复边)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/6f4d376aa4337a768ff30713a90a6a25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bNuW1g1Ah41oONo0hkNOMA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2</p></figure><p id="32fa" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一般来说，拥有索引不仅会降低写入速度，还会增加数据大小。而且，归根结底，它只提供了<code class="fe nf ng nh ni b">O(log(n))</code>效率。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="106e" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated"><strong class="ak">本地图形存储模型</strong></h1><p id="ba8e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们看看原生图模型如何解决这些问题。图3总结了本地图形存储模型，它基于图1中的图形。让我带你走一遍。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/432b2c065521dbc166a1398419e28daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Y4_AtjzzC69zKxp-yTCEQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3</p></figure><p id="4804" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">图3 (a)是一个概念模型。它列出了与每个节点相关的所有边，并将它们组织成双向链表。注意，如果节点是边的源或目的地，则该边与该节点相关联。例如，边<code class="fe nf ng nh ni b">A &lt;1,2&gt;</code>与节点<code class="fe nf ng nh ni b">1</code>和节点<code class="fe nf ng nh ni b">2</code>都相关联。</p><p id="f70e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">图3 (b)是实际的节点存储。每个记录存储一个节点的第一个关系ID ( <code class="fe nf ng nh ni b">first_rid</code>)。例如，节点<code class="fe nf ng nh ni b">1</code>和<code class="fe nf ng nh ni b">2</code>的第一关系是<code class="fe nf ng nh ni b">A</code>。</p><p id="95c5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">图3 (c)是实际的关系存储。每个记录存储关系的源(<code class="fe nf ng nh ni b">src</code>)和目的(<code class="fe nf ng nh ni b">dst</code>)。此外，它还存储源节点和目的节点的上一个和下一个关系id(<code class="fe nf ng nh ni b">src_prev_rid</code>、<code class="fe nf ng nh ni b">src_next_rid</code>、<code class="fe nf ng nh ni b">dst_prev_rid</code>、<code class="fe nf ng nh ni b">dst_next_rid</code>)。这实质上为源和目的地保留了概念上的双向链表，但是只存储一次给定的边。</p><p id="0190" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">假设您想要检索节点<code class="fe nf ng nh ni b">2</code>的所有出站关系。如图3中的蓝色箭头所示。您首先进入节点存储器，看到节点<code class="fe nf ng nh ni b">2</code>的<code class="fe nf ng nh ni b">first_rid</code>是<code class="fe nf ng nh ni b">A</code>。然后你去关系库查找<code class="fe nf ng nh ni b">A</code>。<code class="fe nf ng nh ni b">A</code>不是<code class="fe nf ng nh ni b">2</code>的出库关系，因为<code class="fe nf ng nh ni b">2</code>是<code class="fe nf ng nh ni b">A</code>的<code class="fe nf ng nh ni b">dst</code>。但是没关系。您跟随<code class="fe nf ng nh ni b">A</code>中的<code class="fe nf ng nh ni b">dst_next_rid</code>(因为<code class="fe nf ng nh ni b">2</code>是关系<code class="fe nf ng nh ni b">A</code>中的目的地)。那就指向<code class="fe nf ng nh ni b">C</code>。<code class="fe nf ng nh ni b">C</code>是<code class="fe nf ng nh ni b">2</code>的出库关系(<code class="fe nf ng nh ni b">2</code>是<code class="fe nf ng nh ni b">C</code>中的来源)。你继续到<code class="fe nf ng nh ni b">src_next_rid</code>，它循环回到<code class="fe nf ng nh ni b">A</code>。那么你知道你已经穷尽了节点<code class="fe nf ng nh ni b">2</code>的所有关系。</p><p id="6c84" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在假设您想要添加一个新节点<code class="fe nf ng nh ni b">4</code>并使<code class="fe nf ng nh ni b">2</code>跟随<code class="fe nf ng nh ni b">4</code>。请参见图4了解这一变化的概况。再一次，让我们走一遍。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/35dfa7471af887600d6983881507ea12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ikrPGR1d7Zq-vcHyHGdCsw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4</p></figure><p id="bf4d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">图4 (a)展示了你想要达到的最终结果。图4 (b)显示了更新的概念模型。</p><p id="4ae7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一条新记录被添加到节点存储器中以存储节点<code class="fe nf ng nh ni b">4</code>的<code class="fe nf ng nh ni b">first_rid</code>，即<code class="fe nf ng nh ni b">D</code>[图4 (c)]。在关系存储器中，新记录<code class="fe nf ng nh ni b">D</code>被插入【图4 (d)】。其<code class="fe nf ng nh ni b">src</code>和<code class="fe nf ng nh ni b">dst</code>分别为<code class="fe nf ng nh ni b">2</code>和<code class="fe nf ng nh ni b">4</code>。</p><p id="e512" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它的<code class="fe nf ng nh ni b">dst_prev_rid</code>和<code class="fe nf ng nh ni b">dst_next_rid</code>之所以琐碎，是因为它的<code class="fe nf ng nh ni b">dst</code>节点<code class="fe nf ng nh ni b">4</code>只有一个关系，就是<code class="fe nf ng nh ni b">D</code>本身。稍微棘手的部分是更新节点<code class="fe nf ng nh ni b">2</code>的双向链表。我用红色突出显示了它们。很容易看出图4 (b)中节点<code class="fe nf ng nh ni b">2</code>的红色部分是如何反映在图4 (d)中的。</p><p id="ccc4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是原生图形存储模型的要点。我故意省略了节点/关系标签和属性的部分，只关注图形结构。但是给定节点/关系id，这些可以很容易地构建为查找存储。</p><p id="16ad" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">还有其他实际的考虑。例如，一个特定节点的所有关系都在一个双向链表中。您可以将入站安排在列表的开头，出站安排在列表的末尾，以便快速浏览有向关系。</p><p id="3253" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另一个例子是确定两个节点之间是否存在关系。您可以迭代源的出站或目标的入站。然而，这两个节点中的一个可能是丰富连接的(例如，Twitter上的名人用户)。在节点存储中记录一个密度位可能是有意义的，这样可以告诉您遍历其他节点的关系。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="afe6" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated"><strong class="ak">原生图形物理存储</strong></h1><p id="8493" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在上面的例子中，我可能给你留下了节点和关系是作为关系表存储的印象。他们不是。这是原生图形数据库存储的另一项重大创新。</p><p id="9d88" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可能已经注意到节点和关系记录有固定的大小——它们只包含固定大小的id。因此，诀窍是将同类记录连续存储在一个连续的存储blob中，例如，一个文件(或一组文件)。</p><p id="4f28" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于任何给定的ID，您可以直接在连续的blob中寻找<code class="fe nf ng nh ni b">ID * record_size</code>来读/写记录。这就是启用<code class="fe nf ng nh ni b">O(1)</code>查找的原因。可以为存储的连续二进制大对象中的每个记录槽引入一个<code class="fe nf ng nh ni b">in_use</code>位，以便在擦除记录时可以预分配和回收空间。</p><p id="2647" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我已经在GitHub [3]上写了一个Golang快速演示程序来说明整个想法。程序使用<code class="fe nf ng nh ni b">mmap</code>来获得一个blob存储，它分别反映了节点和关系文件，并将节点/关系记录读取/写入这些内存区域。</p><p id="71ce" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nf ng nh ni b">mmap</code>是一个有用的工具，因为它避免了从磁盘到操作系统和从操作系统到应用程序的双重复制。读写要快得多，也简单得多。请随意查看回购，如果发现问题，请务必提交问题。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="9596" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated"><strong class="ak">说几句Neo4j的存储布局</strong></h1><p id="bea7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Neo4j的节点记录包含<code class="fe nf ng nh ni b">in_use</code>信息、<code class="fe nf ng nh ni b">first_rid</code>、第一属性ID、第一标签ID和一些额外的位(例如，我们谈到的密度信息)。属性ID和标签ID指向节点的属性和标签。Neo4j的关系记录中包含了<code class="fe nf ng nh ni b">in_use</code>的信息；<code class="fe nf ng nh ni b">src</code>；<code class="fe nf ng nh ni b">dst</code>；分别为<code class="fe nf ng nh ni b">src</code>和<code class="fe nf ng nh ni b">dst</code>的上一个和下一个链接；第一类型ID；第一属性ID；和一些额外的位。类型ID和属性ID指向关系的类型和属性。</p><p id="ca72" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Neo4j标准格式的节点记录是15个字节。互联网上有一种常见的误解，认为节点记录使用一个字节表示<code class="fe nf ng nh ni b">in_use</code>，四个字节表示<code class="fe nf ng nh ni b">first_rid</code>和第一个属性ID，五个字节表示第一个标签ID，一个字节表示额外的。</p><p id="651d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在该布局中，关系和属性的限制都是2。这与Neo4j标准格式中关系的限制是2个⁵，属性的限制是2个⁶的事实不符[4]。</p><p id="4125" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">断开的是第一个字节没有全部用于<code class="fe nf ng nh ni b">in_use</code>。只有第一个字节的最后一位用于<code class="fe nf ng nh ni b">in_use</code>。前三位实际上用于<code class="fe nf ng nh ni b">first_rid</code>的高位，接下来的四位用于第一个属性ID的高位。数学结果是这样的:3+32=35，4+32=36。你需要阅读源代码来发现这一点[5]。</p><p id="dfde" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Neo4j标准格式的关系记录是34字节。类似的技术被用来最大化每个比特的效用。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="44b0" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated"><strong class="ak">参考文献</strong></h1><p id="4444" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">[1] <a class="ae ky" href="https://neo4j.com/" rel="noopener ugc nofollow" target="_blank"> Neo4j图形平台</a></p><p id="9f52" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">[2]伊恩·罗宾逊等人，2015，“图形数据库”，第二版</p><p id="c192" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">[3]<a class="ae ky" href="https://github.com/eileen-code4fun/NativeGraphDBStorage" rel="noopener ugc nofollow" target="_blank">NativeGraphDBStorage</a></p><p id="dd7a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">[4] <a class="ae ky" href="https://neo4j.com/docs/operations-manual/current/tools/store-info" rel="noopener ugc nofollow" target="_blank"> Neo4j文档</a></p><p id="8684" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">[5]<a class="ae ky" href="https://github.com/neo4j/neo4j/tree/4.2/community/record-storage-engine/src/main/java/org/neo4j/kernel/impl/store/format/standard" rel="noopener ugc nofollow" target="_blank">GitHub上的Neo4j</a></p></div></div>    
</body>
</html>