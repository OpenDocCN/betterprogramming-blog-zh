<html>
<head>
<title>Design Patterns: Template Method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式:模板方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/design-patterns-template-method-5400dde7bb72?source=collection_archive---------7-----------------------#2019-09-24">https://betterprogramming.pub/design-patterns-template-method-5400dde7bb72?source=collection_archive---------7-----------------------#2019-09-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ae4f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用口袋妖怪解释的复杂图案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1b73ae55c946493357f363ab2007a846.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YgSkYubXrzScIRXMpxQXLw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">大卫·格兰穆金在<a class="ae ky" href="https://unsplash.com/s/photos/pokemon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1711" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经典的设计模式有23种，在原著<a class="ae ky" href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" rel="noopener ugc nofollow" target="_blank"> <em class="lv">设计模式:可复用面向对象软件的元素</em> </a>中有描述。这些模式为软件开发中经常重复出现的特定问题提供解决方案。</p><p id="5fa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将描述模板模式，以及如何和何时应用它。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e877" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">模板方法模式:基本思想</h1><blockquote class="mv mw mx"><p id="08da" class="kz la lv lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated"><em class="it">“模板方法模式是一种行为的</em> <a class="ae ky" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank"> <em class="it">设计模式</em> </a> <em class="it">，它定义了一个</em> <a class="ae ky" href="https://en.wikipedia.org/wiki/Algorithm" rel="noopener ugc nofollow" target="_blank"> <em class="it">算法</em> </a> <em class="it">中的</em> <a class="ae ky" href="https://en.wikipedia.org/wiki/Program_skeleton" rel="noopener ugc nofollow" target="_blank"> <em class="it">程序骨架</em> </a> <em class="it">，将一些步骤推迟到</em> <a class="ae ky" href="https://en.wikipedia.org/wiki/Subclass_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <em class="it">子类</em></a><em class="it">”—Wikipedia</em></p><p id="2729" class="kz la lv lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated"><em class="it">“在一个操作中定义一个算法的框架，将一些步骤推迟到子类。模板方法允许子类在不改变算法结构的情况下重新定义算法的某些步骤。—设计模式:可重用面向对象软件的要素</em></p></blockquote><p id="65d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种模式的主要特点是算法在不同种类的类之间略有不同。当在具体的类中实现时，这些部分通常在不同的算法中重复。</p><p id="5355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码显示了一个经典的问题，在这个问题中，您必须重复算法的某些部分(复制-粘贴)，并且只做很小的更改:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/f76649a570e3a94dcb23d8b532d349b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MvE43yhd7NXDWSLz.png"/></div></div></figure><p id="8e8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用模板方法模式<strong class="lb iu"> </strong>使代码更加简洁，这允许我们避免在算法的不同实现中重复代码。这个模式的UML图如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/6318641cd3ea6e3abf8bc85f20fdc8a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:76/0*NxoWFuZt4DIt_WW5"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/547b8b2d4080712183a6936877b887d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eER_21z3HSVmsEIQ.png"/></div></div></figure><p id="cc99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意抽象类，它包含模板方法和私有方法。</p><p id="3f42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模板方法在不同的步骤中描述算法。这些步骤在抽象类中实现，而每个具体类中不同的具体步骤在所述具体类中实现。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="cc06" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">模板方法模式:何时使用</h1><ol class=""><li id="22af" class="ne nf it lb b lc ng lf nh li ni lm nj lq nk lu nl nm nn no bi translated">模板方法模式解决的问题是使用一种有不同变化的算法。您需要将算法分成不同的步骤，当在不同的实现之间通用时，在抽象类中实现。另一方面，不同的步骤将在具体的类中实现。</li><li id="79d2" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">另一个有趣的情况是，当您在不同的类之间复制粘贴代码(私有函数)时，您会发现需要这种模式。</li><li id="a896" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">最后，当你的大多数类都有相关的行为时，你可以使用这种模式。</li></ol></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9d90" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">模板方法模式:优势</h1><p id="2b12" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">模板方法模式有几个优点，总结如下:</p><ul class=""><li id="311e" class="ne nf it lb b lc ld lf lg li nx lm ny lq nz lu oa nm nn no bi translated">创建一个算法的具体实现是相当容易的，因为你通过使用一个抽象类去除了问题域的公共部分。</li><li id="7c6f" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu oa nm nn no bi translated">干净的代码，因为你避免了重复的代码。</li><li id="b7e2" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu oa nm nn no bi translated">更干净的代码，因为你把算法分成私有的方法或函数，这样更简单，更容易测试。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8cad" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">模板模式:使用JavaScript的口袋妖怪示例</h1><p id="d81f" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">我现在将向您展示如何使用JavaScript实现这种模式。请记住，JavaScript既缺少接口也缺少抽象类。因此，理解这种模式的最好方法是使用一个例子。</p><p id="77df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我想到了一个问题，其中有一个名为<code class="fe ob oc od oe b">Pokemon</code>的抽象类，它定义了一个口袋妖怪。一个口袋妖怪除了经典的<code class="fe ob oc od oe b">toString</code>方法外，还有一套属性，比如<code class="fe ob oc od oe b">name</code>、<code class="fe ob oc od oe b">power</code>、<code class="fe ob oc od oe b">attack</code>、<code class="fe ob oc od oe b">defense</code>。</p><p id="cc4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">口袋妖怪的类型有一个分类，比如<code class="fe ob oc od oe b">FightingPokemon</code>、<code class="fe ob oc od oe b">PoisonPokemon</code>、<code class="fe ob oc od oe b">GroundPokemon</code>，定义了一个具体的方法叫做<code class="fe ob oc od oe b">calculateDamage</code>，根据口袋妖怪的属性和类型计算数值。</p><p id="1908" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的UML图显示了我刚刚描述的场景。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/8e775015d66d3d84f0635797d88ed3dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nT8aIUvuQXi-ykMi.png"/></div></div></figure><p id="092c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用JavaScript实现实际情况的代码如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/4bfae154cd742803843f6df6167c252d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KqL-3mxqhGMB_YRJ.png"/></div></div></figure><p id="2a26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方法<code class="fe ob oc od oe b">calculateDamage</code>在每个具体类中重复，即有一个气味代码(复制-粘贴-复制代码)。这种方法可以分成不同的步骤，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/98ba28f51f5fb6219dff8270a1e983e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Pb6J3ISZ6nY8lhHl.png"/></div></div></figure><p id="70fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们的方法被分成了三个函数。实际上，两个是通用的，一个是特定的，取决于实现它的类(<code class="fe ob oc od oe b">calculateImpact</code>)。</p><p id="0286" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe ob oc od oe b">Template-Method</code>模式已经成功应用。在下面的UML中，您可以看到使用模板方法的版本更新。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/652f18d0e88d0567430fd5eaf06717b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f0szNQkrRNwl1P2E.png"/></div></div></figure><p id="5695" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">Pokemon</code>类如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/1298b10e05daad795a59d276a4b62310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h0F8lFW7sR_B7asc.png"/></div></div></figure><p id="936a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到这个类中没有实现方法<code class="fe ob oc od oe b">this.calculateImpact</code>。这是因为具体的实现将在具体的类中。这个口袋妖怪类就是我们问题中的抽象类。</p><p id="fb0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是实现具有<code class="fe ob oc od oe b">calculateImpact</code>方法的具体类。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/58e0a7a5c834c77ea4b85dc7d69d157d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nmwTP5HP3Rv19D2W.png"/></div></div></figure><p id="682f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们使用具体口袋妖怪的客户端/上下文代码如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/60ccd7294975202c8ccc244db4041a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OrIsiCs40rKfBJvb.png"/></div></div></figure><p id="773f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码创建了具体的Pokemon，它调用它的<code class="fe ob oc od oe b">calculateDamage</code>。它的实现对客户端/上下文是透明的，但是，代码不会重复。</p><p id="6ea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我创建了两个<a class="ae ky" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>脚本，在应用模板方法模式之前和之后运行代码。</p><p id="50aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">npm run step0</code> <br/> <code class="fe ob oc od oe b">npm run step1</code></p><p id="72ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，并想阅读类似的文章，别忘了鼓掌。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/826581e5d9d84c9ac865ff50de96d060.png" data-original-src="https://miro.medium.com/v2/resize:fit:292/1*vMyFTOWtr9c252J4X1FW6g.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">点按并拖移以不止一次鼓掌。50是极限。</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2609" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="e459" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">模板方法模式是一种可以避免项目中重复代码的模式，当一个算法既有不变部分又有变化部分时，后者取决于具体的类。</p><p id="7092" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，您已经能够观察到一个使用JavaScript语言的简单实现，它缺少接口/抽象。如果你使用的编程语言有接口/抽象，你可以遵循UML模式。</p><p id="9d2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的事情不是实现我向您展示的模式，而是能够识别这个特定模式可以解决的问题，以及何时可以或不可以实现所述模式。</p><p id="eac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一点至关重要，因为实现会因您使用的编程语言而异。</p></div></div>    
</body>
</html>