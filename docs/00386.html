<html>
<head>
<title>Algorithms: Selection Sort in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法:JavaScript中的选择排序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/selection-sort-algorithm-in-javascript-f876c3c0af73?source=collection_archive---------1-----------------------#2019-05-11">https://betterprogramming.pub/selection-sort-algorithm-in-javascript-f876c3c0af73?source=collection_archive---------1-----------------------#2019-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3762" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何为选择排序建立循环不变量，并使用测试驱动开发来实现算法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5ce83d6b85d644221248e16df8132034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PsjgbWgxyNYIQM30XIpsQA.png"/></div></div></figure><h1 id="6195" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">练习</h1><p id="4432" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">最近，我一直在温习<a class="ae mi" href="https://mitpress.mit.edu/books/introduction-algorithms-third-edition" rel="noopener ugc nofollow" target="_blank">科尔曼的《算法导论》</a>这本书，努力在工作中更好地面试工程候选人。在第2章，这是所有关于如何设计和分析算法，这本书提出了以下练习:</p><blockquote class="mj mk ml"><p id="9cba" class="lm ln mm lo b lp mn ju lr ls mo jx lu mp mq lx ly mr ms mb mc mt mu mf mg mh im bi translated">考虑对数组A中存储的n个数进行排序，首先找到A的最小元素，并与A[1]中的元素进行交换。然后求A的第二小元素，和A交换[2]。以这种方式继续a的前n-1个元素。为这个算法写伪代码，这就是所谓的<strong class="lo iu">选择排序</strong>。这个算法保持什么样的循环不变量？为什么它只需要运行前n-1个元素，而不是所有的n个元素？给出在ɵ-notation.选择排序的最好和最坏情况下的运行时间</p></blockquote><p id="b871" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated">我认为这是一个很好的问题，因为它涵盖了设计算法时的整个思维过程。我们知道它应该如何工作的基本思想(为每个索引寻找并交换最小的元素)，但是我们如何知道我们的实现是正确的呢？我们可以建立什么条件来确保每次迭代都执行正确的操作？最后，算法的效率如何？它的运行时间是多少？</p><p id="d4bd" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated">这些都是我们在选择排序中要涉及的问题。实际上，我刚刚发布了一篇非常类似的关于JavaScript插入排序的文章，您可以在这里找到:</p><div class="mv mw gp gr mx my"><a href="https://medium.com/@jimrottinger/insertion-sort-in-javascript-9c077844717a" rel="noopener follow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">JavaScript中的插入排序</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">简要介绍用JavaScript编写的插入排序，包括检查循环不变量和分析运行时。</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">medium.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm ks my"/></div></div></a></div><p id="dbe5" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated">在那篇文章中，我首先介绍了算法实现，然后介绍了正确性和运行时分析。然而，这一次，<strong class="lo iu">我将从建立循环不变量开始，然后用它来通知我的JavaScript代码实现。</strong>那样的话，我们将基本上做<a class="ae mi" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">测试驱动开发(TDD) </a>来实现算法。一旦我们完成了这些，我们将结束对我们实现的运行时分析。</p><h1 id="2c99" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">选择排序循环不变量</h1><p id="66eb" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如练习中所述，选择排序的工作方式是迭代输入，找到剩余的最小元素，并将其交换到当前索引中。相当简单！—但这里有一张我做的很好看的gif，可以帮你形象化:)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/6bb53a727850e5bb48858e5e92faaf5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/1*pykGPsjpwHGkp2zsXX4pLw.gif"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">选择排序，动画</p></figure><p id="9277" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated">那么这个算法的循环不变量是什么呢？提醒一下，<strong class="lo iu">循环不变量</strong>是算法在开始、结束和每次迭代执行时维护的一个或一组条件。在进一步阅读之前，花一两分钟时间思考一下！我们可以检查哪些属性来确保我们的算法正确运行？</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="fd61" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated">现在就一起想出来吧。基于我们对算法工作原理的描述，我们知道最小的剩余元素总是会被首先找到并排序。因此，在一次迭代之后，最小的元素将位于0索引处，在两次迭代之后，两个最小的元素将被排序，以此类推。这个属性给了我们一个很好的条件去检查。</p><blockquote class="mj mk ml"><p id="d734" class="lm ln mm lo b lp mn ju lr ls mo jx lu mp mq lx ly mr ms mb mc mt mu mf mg mh im bi translated">T <strong class="lo iu">对于选择排序的循环不变量是，新排序的数组的元素到当前索引为止，</strong> <code class="fe nz oa ob oc b"><strong class="lo iu">A[0..i]</strong></code> <strong class="lo iu">将包含我们最初输入的</strong> <code class="fe nz oa ob oc b"><strong class="lo iu">i</strong></code> <strong class="lo iu">最小元素，</strong> <code class="fe nz oa ob oc b"><strong class="lo iu">A[0..n-1]</strong></code> <strong class="lo iu">。它们也将按顺序排列。</strong></p></blockquote><p id="2251" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated">如果这个条件在我们的算法执行之前、期间和结束时都成立，那么我们可以确定它正在正确地执行。</p><p id="2533" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated">这是我们刚刚建立的循环不变量的代码。它需要正在排序的数组、原始输入数组和当前索引。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="fb2c" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated">我们将使用这个函数来帮助我们实现选择排序函数。</p><p id="ca71" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated"><strong class="lo iu">注意</strong> —我稍微作弊了一下，使用JavaScript数组上内置的排序函数来寻找原始输入中的<code class="fe nz oa ob oc b">i</code>最小值。有其他方法可以做到这一点，但我们只是将这个函数作为一个单元测试来使用。</p><h1 id="55c8" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">实现选择排序</h1><p id="9695" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在我们有了循环不变函数，我们可以采用测试驱动开发(TDD)的方法来实现算法。让我们使用上图中使用的相同输入。</p><pre class="kj kk kl km gt of oc og oh aw oi bi"><span id="ee6d" class="oj kv it oc b gy ok ol l om on">const input = [7, 5, 1, 8, 2]</span></pre><p id="e4c8" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated">然后，我们可以为选择排序创建一个框架函数，并调用我们的循环不变测试函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="3459" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated">我们只需要迭代到<code class="fe nz oa ob oc b">nums.length — 1</code>,因为，如果你考虑一下，我们不断地用数组中右边剩余的最小元素交换每个索引处的元素。当我们到达最后一个索引时，它肯定是最大的一个，所以我们不必处理它。</p><p id="f859" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated">现在，如果我们运行<code class="fe nz oa ob oc b">console.log(selectionSort(input))</code>，我们会在控制台中得到以下输出:</p><pre class="kj kk kl km gt of oc og oh aw oi bi"><span id="c672" class="oj kv it oc b gy ok ol l om on">Error! 7 not one of the 1 smallest elements<br/>Error! 7 not one of the 2 smallest elements<br/>Error! New Array is not properly sorted<br/>Error! 5 not one of the 2 smallest elements<br/>Error! 7 not one of the 3 smallest elements<br/>Error! New Array is not properly sorted<br/>Error! New Array is not properly sorted<br/>Error! New Array is not properly sorted<br/>Error! New Array is not properly sorted<br/>Error! 8 not one of the 4 smallest elements<br/>Error! New Array is not properly sorted<br/>Error! New Array is not properly sorted<br/>Error! New Array is not properly sorted<br/>[ 7, 5, 1, 8, 2 ]</span></pre><p id="bc6f" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated">这实际上是一件好事，因为这是我们TDD方法的开始！我们希望实现该算法，直到所有的错误都消失了，并且最终返回的数组是有序的。</p><p id="f94f" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated">循环的内部实际上非常简单。我们获取当前索引处的元素，<code class="fe nz oa ob oc b">i</code>，然后检查数组的剩余部分是否有比它小的元素。一旦找到了最小的元素，如果它不在当前的索引中，就用最小的元素替换它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="b544" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated">如果您将这段代码放在上面带有循环不变量检查的框架代码中，您会看到我们所有的错误都消失了，它只是输出最终结果！</p><pre class="kj kk kl km gt of oc og oh aw oi bi"><span id="0afa" class="oj kv it oc b gy ok ol l om on">[1 2 5 7 8]</span></pre><p id="bd16" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated">除去循环不变量检查，我们的最终算法是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="4ee5" class="ku kv it bd kw kx oo kz la lb op ld le jz oq ka lg kc or kd li kf os kg lk ll bi translated">选择排序的运行时分析</h1><p id="99be" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们将用选择排序算法的运行时分析来结束这篇文章。</p><p id="f61c" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated">正如我们在上一节中了解到的，选择排序算法只需要运行到<code class="fe nz oa ob oc b">n-1</code>元素。考虑到这一点，外环可以表示为从<code class="fe nz oa ob oc b">i=1</code>到<code class="fe nz oa ob oc b">n-1</code>的总和。对于我们的内部循环，我们只需迭代数组中尚未排序的部分。换句话说，如果我们已经排序了<code class="fe nz oa ob oc b">i</code>元素，那么我们只需要执行内部循环的<code class="fe nz oa ob oc b">n-i</code>次迭代。这给出了我们的求和公式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/ad0641bb464cc01c9d425e6c2ee57935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZVPHDR78u2nTZrN1HtU1Ig.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">选择排序的最佳情况和最坏情况运行时</p></figure><p id="8f76" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated">巧合的是，这与最坏情况插入排序得到的结果完全相同，并且是ɵ(n)。然而，选择排序和插入排序的一个巨大区别是，选择排序在最好和最坏的情况下都有相同的运行时间。不存在可能使内部回路短路的情况。它总是必须遍历整个数组，以检查是否有更小的元素剩余。<strong class="lo iu">这意味着，平均而言，插入排序永远是一种性能更高的算法。</strong></p><p id="1ca8" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mq lx ly lz ms mb mc md mu mf mg mh im bi translated">虽然这意味着使用选择排序是不切实际的，因为有更高性能的算法来做同样的工作，但我仍然发现在与候选人和同事讨论不同的算法方法时，这个练习是有教育意义和有帮助的。</p></div></div>    
</body>
</html>