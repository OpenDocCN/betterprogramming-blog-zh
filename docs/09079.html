<html>
<head>
<title>Unit Testing in iOS — The Pragmatic Guide on Where To Start</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS中的单元测试——从哪里开始的实用指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unit-testing-in-ios-the-pragmatic-guide-on-where-to-start-4d1718bdbfa?source=collection_archive---------12-----------------------#2021-07-13">https://betterprogramming.pub/unit-testing-in-ios-the-pragmatic-guide-on-where-to-start-4d1718bdbfa?source=collection_archive---------12-----------------------#2021-07-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7461" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">所以你决定开始对你的应用程序代码进行单元测试。如果您对如何实现它感到不确定，那么这篇文章就是为您准备的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d0dcd6cd1173fad8a8308be37848e20c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v2CJkw8_8bUri2H018XMzA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@olloweb?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">agency followeb</a>在<a class="ae ky" href="https://unsplash.com/s/photos/start-learning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="baf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将讨论在测试之旅开始时出现的真正问题。你会得到一些实用的建议，告诉你如何按照自己的步调更自信地向前迭代。</p><p id="a9c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请继续阅读，了解:</p><ul class=""><li id="4e51" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">从零开始向前迭代</li><li id="b93e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">为测试配置项目</li><li id="08e0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">何时、何地以及如何运行测试</li><li id="a49b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">是<em class="mj">测试</em>还是<em class="mj">单元测试</em>？</li><li id="592a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们必须使用TDD吗？</li><li id="1359" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">挑选要测试的内容</li><li id="1c4e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">测试不可测试的</li></ul><p id="d793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多很好的资源可以学习测试。您可以了解许多主题:</p><ul class=""><li id="4867" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">不同种类的测试(单元测试、集成测试、端到端测试、UI测试)</li><li id="15f1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何以及何时运行它们</li><li id="920f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何用XCTest编写测试</li><li id="c23e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">您可以使用的第三方框架</li><li id="cdd4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">不同的技术，如TDD</li><li id="dd4a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何从测试计划中获益</li><li id="6152" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何利用生成的测试结果</li><li id="9768" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">等等</li></ul><p id="2940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，你可能会觉得你的代码不容易测试。您可能想知道这是否是将您的项目重构为更易测试的架构的好时机。你甚至会感到必须测试所有代码的压力。</p><p id="020b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">弄清楚<em class="mj">实际上从哪里开始</em>会很困难，甚至让人不知所措。但事实是你不需要事先学会所有的知识。</p><p id="bf7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我来帮你开始吧。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="529e" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">从零开始，迭代</h1><p id="c3ef" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">自动化项目测试是一个迭代的过程。我们从没有测试开始，然后一点一点地添加一些测试——或者针对现有代码，或者与新编写的代码一起添加。随着时间的推移，测试代码的数量会增加。最终，很大一部分代码会被测试，尽管通常需要一段时间。</p><p id="4d3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我告诉你即使零测试也能给你的项目带来价值呢？</p><p id="89e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没错。当我们在没有测试的情况下运行测试套件时，我们已经验证了项目可以编译，并且应用程序在启动时不会立即崩溃(尽管它只适用于测试应用程序，而不是框架)。</p><p id="1558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在每次提交之前运行测试可以避免您意外提交一个甚至不能编译的版本。</p><p id="8272" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从那以后只会变得更好。每一个新的测试都会验证代码中的一个微小路径——不仅是为了生成结果的正确性，也是为了它不会使应用程序崩溃或挂起。</p><p id="7366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要担心测试速度太慢。任何数量(和种类)的测试都比没有好。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="40a4" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">为测试配置项目</h1><p id="897c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">因此，要开始从测试中获益，您需要做的就是准备好测试基础设施。从那里，您可以继续学习所有关于测试的知识，尝试不同类型的测试，等等。添加新的测试只是添加一个新的测试用例类或者一个新的功能。我们将在下面讨论这个问题。</p><p id="ad72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试是应用项目的一部分，但不是应用本身的一部分。测试存在于一个单独的目标中。目标指定要构建的产品，如iOS、watchOS、macOS应用程序、扩展、框架、测试套件或UI测试套件。一个项目可以有多种类型的目标。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/a809fa5c893ecf1ba34df2db05a56b7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VJVYy8d1mf3wgpl-.png"/></div></div></figure><p id="8a53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在使用由Swift Package Manager创建的框架，目标将通过<code class="fe np nq nr ns b">Package.swift</code>文件进行配置。SPM框架也可以有多个测试套件。下面，我们将重点放在配置应用程序项目上，但是如果你想了解如何创建一个包含测试的Swift包，请查看<a class="ae ky" href="https://www.avanderlee.com/swift/creating-swift-package-manager-framework/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p><h2 id="0f25" class="nt ms it bd mt nu nv dn mx nw nx dp nb li ny nz nd lm oa ob nf lq oc od nh oe bi translated">向项目中添加测试目标</h2><p id="5578" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">当您创建一个新项目时，选中“Include Tests”框，这样测试目标就会自动创建。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/5ab83a8f7130339a00101f962c451c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BCJZPjQ4iEVmeuv3.png"/></div></div></figure><p id="4fea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有一个预先存在的代码库，只需点击几下鼠标就可以添加一个测试目标。<a class="ae ky" href="https://openclassrooms.com/en/courses/4554386-enhance-an-existing-app-using-test-driven-development/5095691-create-your-first-test" rel="noopener ugc nofollow" target="_blank">这个免费的指南</a>展示了如何给一个项目添加一个新的测试目标(我和付费课程没有关系)。</p><h2 id="7cc3" class="nt ms it bd mt nu nv dn mx nw nx dp nb li ny nz nd lm oa ob nf lq oc od nh oe bi translated">管理损坏的测试目标</h2><p id="70f2" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">如果项目中已经有了一个测试目标，但是它无法编译或者许多测试都失败了，那么还有一条路可以走。如果只有几个错误，请尝试修复它们。</p><p id="ac78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修复旧的测试目标可能是一个更大的任务，您可能无法在它上面花费所需的时间。在这种情况下，我的建议是在项目中创建一个新的测试目标。</p><p id="4c3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个项目中可以有多个测试目标。在目标之间移动测试用例类(文件)很容易，并且您可以在以后将所有的测试合并到一个目标中。这不应该阻止你现在开始添加新的测试！</p><p id="8028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止新创建的测试目标被放弃和破坏，请确保测试保持最新并定期执行。阅读下一节，了解如何操作。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="41f0" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">何时、何地以及如何运行测试</h1><p id="af8a" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">测试可以在本地或远程机器上运行。远程机器通常由CI(持续集成)系统管理。机器从源代码控制系统中提取代码，执行测试，并报告结果。不是所有的CI系统都提供macOS机器，但是很多都提供:GitHub Actions，CircleCI，Bitrise，Travis CI。一些CI系统，如Jenkins，允许您连接自己的物理机器，但这是一个高级主题，我们不在这里讨论。很快，<a class="ae ky" href="https://developer.apple.com/documentation/Xcode/About-Continuous-Integration-and-Delivery-with-Xcode-Cloud" rel="noopener ugc nofollow" target="_blank"> Xcode Cloud </a>将允许从Xcode内部触发云中测试的执行。</p><p id="c56f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种方法可以运行测试套件。您可以手动或通过命令行运行测试。借助内置的<code class="fe np nq nr ns b">xcodebuild test</code>命令或全能的<a class="ae ky" href="https://docs.fastlane.tools/getting-started/ios/running-tests/" rel="noopener ugc nofollow" target="_blank">快速通道</a>，可以通过命令行执行一个测试套件。通常，您只需要在通过CI系统远程执行测试时使用命令行工具。</p><p id="6500" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj"> when </em>也有多种选择:您可以按需手动运行(基本上只要您记得这么做)，在合并一个特性分支之前，在每个pull请求时(如果您练习过的话)，甚至在每次提交之前或之后。</p><p id="3f65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您刚开始测试时，您可以使用测试操作在Xcode中手动触发测试。</p><p id="c440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于长期运行的项目，甚至对于单独的开发人员来说，最佳的设置是为每个合并创建一个拉请求，并通过CI系统自动对每个拉请求执行测试。这样，很容易回滚到上一个工作版本，并且当测试在云中运行时，您可以在其他地方工作。如果你已经在GitHub上托管了你的代码，GitHub Actions是最简单的选择。</p><p id="d7e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果学习如何配置CI系统不是您的首要任务之一(这完全没问题)，我建议在将您的更改推送到远程之前，或者至少在合并分支之前，在本地运行测试。</p><p id="c9e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">要开始使用GitHub动作，我推荐这本初学者友好的简短设置指南:</em> <a class="ae ky" href="https://dev.to/ezra_black_/creating-basic-github-actions-for-testing-xcode-40ld" rel="noopener ugc nofollow" target="_blank"> <em class="mj">创建基本的GitHub动作，以便用Xcode </em> </a> <em class="mj">进行测试。</em></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="bcce" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">是测试还是单元测试？</h1><p id="6790" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">术语<em class="mj">测试</em>描述了验证软件正确性的过程。然后我们区分自动化测试和手工测试。</p><p id="a6bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">单元测试</em>是一种自动测试，它验证代码的单个单元实现的正确性——比如类、结构或函数。如果我们只有单元测试，我们必须相信<em class="mj">单元</em>被正确地组合在一起，以制作一个功能正常的应用程序。</p><p id="7a1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">集成测试</em>验证各单元是否正常工作。<em class="mj">端到端测试</em>是更高级别的自动化测试，它从整体上验证系统，包括服务器端连接。<em class="mj"> UI测试</em>验证app的界面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/69a8750d18c2e8fbb2338adf75841722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rJiM3LzXQm8zYvqW.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这就是所谓的<em class="oh">测试金字塔</em>。来源:<a class="ae ky" href="https://www.ministryoftesting.com/dojo/lessons/the-mobile-test-pyramid" rel="noopener ugc nofollow" target="_blank">测试部</a></p></figure><p id="073b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用XCTest框架通过创建<code class="fe np nq nr ns b">XCTestCase</code>子类来编写所有这四种测试类型。编写UI测试需要我们使用一个特殊的<code class="fe np nq nr ns b">XCUIApplication</code> API来与应用程序本身进行交互，但是其余的测试类型都是以同样的方式编码的。区别是非常语义化的:根据你测试的代码的哪一部分，你称之为单元、集成或端到端测试。</p><p id="d37d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试很小，一个测试目标通常有很多单元测试。最常见的情况是，单元测试构成了测试套件的大部分。因此，词语<em class="mj">测试</em>和<em class="mj">单元测试</em>有时可以互换使用。</p><p id="3bf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">如果你想了解更多关于这些不同种类的测试，请查看</em> <a class="ae ky" href="https://developer.apple.com/documentation/xcode/testing-your-apps-in-xcode" rel="noopener ugc nofollow" target="_blank"> <em class="mj">苹果的Xcode </em> </a> <em class="mj">应用测试指南。要了解更多关于用XCTest编写断言的知识，</em> <a class="ae ky" href="https://developer.apple.com/documentation/xctest" rel="noopener ugc nofollow" target="_blank"> <em class="mj"> XCTest的文档页面</em> </a> <em class="mj">是一个很好的起点。</em></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="eaae" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">我们必须使用TDD吗？</h1><p id="2a61" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">TDD(测试驱动开发)是一种通常与单元测试相关联的方法。TDD规定我们应该在编写实现之前<em class="mj">编写测试。</em></p><p id="89f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些人认为TDD是编写测试的一种真正方法。然而，在现实中，每个人的大脑都是不同的。编码是一个非常有创造性的过程，不同的人喜欢不同的方式来达到相同的结果。大多数实践测试的开发人员实际上大部分时间并不遵循TDD。</p><p id="01fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我提供一个简单的经验法则:如果你想让你的代码被测试覆盖，就致力于让代码与测试配对的<em class="mj">结果</em>。如何达到这一点是个人喜好。如果你实践拉请求——特别是在团队中——你可以承诺将测试和代码一起包含在每个PR中。</p><p id="5337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了决定何时编写测试，尝试不同的方法，找出最适合你的方法。你可以在操场上画一个特性实现的草图，或者写/重写你的代码，想写多少次就写多少次，当你对特性感到满意的时候再写测试。或者首先根据实现的框架编写测试，并填充实际的逻辑以使测试通过。</p><p id="c524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将方法和模式视为灵感，并找到最适合您的流程、团队和项目的方法。</p><p id="d662" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">如果你想了解更多关于TDD的基础知识，我发现IBM的这篇文章</em><a class="ae ky" href="https://www.ibm.com/garage/method/practices/code/practice_test_driven_development/" rel="noopener ugc nofollow" target="_blank"><em class="mj"/></a><em class="mj">是一个很好的资源。</em></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="4572" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">挑选要测试的内容</h1><p id="8bfe" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">许多文章会告诉你应该测试代码库的哪些区域。但是你<em class="mj">必须</em>承诺对你<em class="mj">应该</em>做的所有事情进行单元测试吗？</p><p id="6829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">绝对不行。正如我们上面所讨论的，有一些测试总比没有好。您可以根据您的偏好、优先级和截止日期来限制测试工作的范围。</p><p id="7d85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是需要关注的三个方面:</p><ul class=""><li id="2e3e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">对您的应用程序至关重要的逻辑</li><li id="8cd1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">不太关键但模糊的逻辑，如果它被打破了，很难注意到</li><li id="7854" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">手动测试所有边缘案例既耗时又棘手的领域</li></ul><p id="ced3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些领域的例子包括反序列化(解析)服务器响应、日期算法、自定义排序/过滤逻辑，以及保存和读回用户的本地数据。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="6b11" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">测试不可测试的</h1><p id="7c5d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">大多数常用的模式和架构都非常适合单元测试，而重构<em class="mj">将</em>让编写测试变得更加容易。MVVM、MVP和依赖注入等模式是在考虑可测试性的情况下设计的。但是从单元测试开始，你绝对不需要做任何大的重构。</p><p id="d328" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管你认为你的代码有多不可测试，这里有一种方法<em class="mj">总是</em>有效:</p><ul class=""><li id="40bb" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">将这段代码提取到助手类中一个完全独立的助手函数中。这样，代码就变得纯净了。纯代码没有副作用，只使用传入的参数，返回结果。纯代码不使用单例或全局变量。</li><li id="be33" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在原来代码所在的地方用一行代码调用新函数。</li><li id="7c78" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">新的助手函数可以进行单元测试。</li></ul><p id="9ac8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使剩余的代码仍然没有被测试覆盖，您也可以测试提取的函数。当然，您仍然可以以导致bug的方式调用函数，但是您降低了这种可能性。</p><p id="45da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子。假设我们有一个视图控制器类，其中有一个我们想要测试的逻辑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="7675" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将这段逻辑提取到一个单独的纯函数中，并测试该函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="09a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe np nq nr ns b">self.data = MyViewControllerHelper.sortData(self.data)</code>时能有多少bug潜入？不多。同时，我们可以确定排序逻辑按预期工作。</p><p id="5b90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稍后，你可以把助手变成一个视图模型(你应该和MVVM一起去)。如果你已经对MVVM感到足够舒服了，那就马上开始吧。这是同时提高可测试性<em class="mj">和</em>你的应用架构的好方法。但是如果你还没有准备好进行大的重构，你仍然有办法开始测试你的代码。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="54fc" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">包扎</h1><p id="bb87" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">踏入未知的领域会让人不知所措。从不同的assert APIs到改进应用程序架构，再到配置CI系统，关于自动化测试有足够多的东西需要学习。</p><p id="f78a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文涵盖了设置测试基础设施、挑选要测试的内容、确定TDD是否适合您、理解不同类型的测试之间的差异，以及处理看似不可测试的代码。</p><p id="6a89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望我的建议能让你对测试你的应用程序更有信心。</p><p id="88fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望你喜欢这篇文章。</p><p id="a127" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文由作者在NC SA 4.0 的<a class="ae ky" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener ugc nofollow" target="_blank"> CC下授权。</a></p><p id="cbc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">原载于2021年7月13日</em><a class="ae ky" href="https://hybridcattt.com/blog/start-testing-pragmatic-guide/" rel="noopener ugc nofollow" target="_blank"><em class="mj"/></a><em class="mj">。</em></p></div></div>    
</body>
</html>