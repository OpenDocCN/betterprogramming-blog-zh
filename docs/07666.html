<html>
<head>
<title>5 Steps To Render D3.js With React Functional Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React函数组件呈现D3.js的5个步骤</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-steps-to-render-d3-js-with-react-functional-components-fcce6cec1411?source=collection_archive---------4-----------------------#2021-02-08">https://betterprogramming.pub/5-steps-to-render-d3-js-with-react-functional-components-fcce6cec1411?source=collection_archive---------4-----------------------#2021-02-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1532" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在React中使用D3的完整指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/686c980324b173eb584dc3da7ea7788f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FRaslVFg_cZnEJUuEndI_w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="bb6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据可视化是信息和数据的图形化表示。它利用可视化元素来呈现数据中的趋势、异常值和模式。当数据很多时，例如在时间序列中，这是一系列按时间顺序索引的数据点，这种方法特别有效。</p><p id="af8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://github.com/d3/d3" rel="noopener ugc nofollow" target="_blank"> D3.js </a>是一个使用web标准可视化数据的JavaScript库。D3代表“数据驱动文档”它将任意数据绑定到文档对象模型(DOM ),然后对文档应用数据驱动的转换。我们可以使用D3从一组数字中生成一个HTML表格。或者我们可以使用相同的数据创建一个交互式的<a class="ae lu" href="https://medium.com/better-programming/create-react-app-and-svgs-70970ac715f2" rel="noopener"> SVG(可缩放矢量图形)</a>条形图，具有平滑的过渡和交互。</p><p id="a44d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在之前的文章中，我们注意到C3允许我们在不知道D3所有复杂性的情况下快速构建图表。使用C3创建图表只需要几行代码。然而，使用D3实现相同的图表需要额外的努力，因为您必须考虑X和Y轴、每个数据点的形状、大小和位置等。</p><p id="8ad4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么我们要深入研究D3的复杂性和本质细节？</p><p id="5f89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为D3提供了丰富的特性来构建图形表示。对于图表，D3可以定制轴、形状、工具提示、文本、颜色和动画的每个细节。</p><p id="eade" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将建立上面的气泡图像作为一个例子。我们将为工作环境使用React，并创建一个<code class="fe lv lw lx ly b">svg</code>标签来托管这些由D3管理的橙色和蓝色圆圈。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1fd8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">在React中渲染D3的5个步骤</h1><p id="9789" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">React是一个声明式的、高效的、灵活的JavaScript库，用于构建用户界面。D3和React都是操纵DOM的固执己见的库。因为我们在工作环境中使用React，所以D3只在数据可视化区域操作DOM。对于那些D3管理的区域，我们放弃了React在性能和效率方面所能提供的。</p><p id="00cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在React中渲染D3需要五个步骤:</p><ol class=""><li id="7f09" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ni nj nk nl bi translated">构建不受控制的组件。</li><li id="37fc" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">创建D3代码。</li><li id="44d2" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">将D3代码放入<code class="fe lv lw lx ly b">useLayoutEffect</code>。</li><li id="03c2" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">设置事件监听器。</li><li id="3f8a" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">React和D3代码之间的平衡。</li></ol></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="be9d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">1.构建不受控制的组件</h1><p id="69a8" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">我们在本文的<a class="ae lu" href="https://medium.com/better-programming/to-be-or-not-to-be-2c372198a01c#ba5c-4b7662162c8e-reply" rel="noopener">中讨论了受控和非受控组件。受控组件管理其子组件的数据，而非受控组件让其子组件管理自己的数据。</a></p><p id="f2e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">D3-管理区域需要作为非受控组件建造。在我们的例子中，对于不受控制的<code class="fe lv lw lx ly b">svg</code>元素，<code class="fe lv lw lx ly b"><a class="ae lu" href="https://medium.com/better-programming/most-things-you-want-to-know-about-react-refs-29901ebf28c6" rel="noopener">useRef</a></code>被创建来访问SVG组件:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="4f73" class="nv mh it ly b gy nw nx l ny nz">const containerRef = useRef(null);</span></pre><p id="6695" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个<code class="fe lv lw lx ly b">containerRef</code>的<code class="fe lv lw lx ly b">current</code>被分配给React代码中的SVG元素:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="8ead" class="nv mh it ly b gy nw nx l ny nz">&lt;svg id="content" width="100%" height="350" ref={containerRef}&gt;<br/>  &lt;g transform="translate(0, 100)" /&gt;<br/>&lt;/svg&gt;</span></pre><p id="cfdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了这个反应<code class="fe lv lw lx ly b">ref</code>，SVG元素的宽度就可以用<code class="fe lv lw lx ly b">containerRef.current.clientWidth</code>得到。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a4f6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">2.创建D3代码</h1><p id="87ee" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">我们创建一个名为<code class="fe lv lw lx ly b">Circles</code>的React组件，它的<code class="fe lv lw lx ly b">props</code>是一个指定圆半径的数字数组。奇数编号的圆圈是蓝色的，偶数编号的圆圈是橙色的。</p><p id="058b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是排列这些圆圈的D3代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="e211" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">画圆需要四个步骤。</p><h2 id="a73a" class="nv mh it bd mi oc od dn mm oe of dp mq lh og oh ms ll oi oj mu lp ok ol mw om bi translated"><strong class="ak">绑定D3数据</strong>(第1行)</h2><p id="3657" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">以下函数用于绑定D3数据:</p><ul class=""><li id="ead4" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt on nj nk nl bi translated"><code class="fe lv lw lx ly b">d3.select</code>选择第一个匹配元素。</li><li id="0e11" class="nd ne it la b lb nm le nn lh no ll np lp nq lt on nj nk nl bi translated"><code class="fe lv lw lx ly b">d3.selectAll</code>选择所有匹配的元素。</li><li id="88e3" class="nd ne it la b lb nm le nn lh no ll np lp nq lt on nj nk nl bi translated"><code class="fe lv lw lx ly b">d3.data</code>将数据数组连接到选择的每个元素。</li></ul><p id="6051" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第1行选择了<code class="fe lv lw lx ly b">g</code>(组)标签，并选择了该组中的所有<code class="fe lv lw lx ly b">circle</code>标签来加入数据数组。</p><h2 id="87b8" class="nv mh it bd mi oc od dn mm oe of dp mq lh og oh ms ll oi oj mu lp ok ol mw om bi translated"><strong class="ak">输入新数据</strong>(第3-10行)</h2><p id="0f12" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">以下函数用于输入数据:</p><ul class=""><li id="9018" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt on nj nk nl bi translated"><code class="fe lv lw lx ly b">d3.enter</code>返回当连接数组长于选择时需要添加的DOM元素。</li><li id="adec" class="nd ne it la b lb nm le nn lh no ll np lp nq lt on nj nk nl bi translated"><code class="fe lv lw lx ly b">d3.append</code>通常跟在<code class="fe lv lw lx ly b">d3.enter</code>后面，实际上是向DOM添加缺失的元素。</li><li id="93d5" class="nd ne it la b lb nm le nn lh no ll np lp nq lt on nj nk nl bi translated"><code class="fe lv lw lx ly b">d3.attr</code>更新属性。</li></ul><p id="0858" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第3-10行添加了尚未绑定的新数据。新数据由半径(第6行)、圆心<em class="oo"> X </em>值(第7行)、圆心<em class="oo"> Y </em>值(第8行)、圆描边颜色(第9行)、圆填充颜色(第10行)配置。</p><h2 id="9892" class="nv mh it bd mi oc od dn mm oe of dp mq lh og oh ms ll oi oj mu lp ok ol mw om bi translated"><strong class="ak">更新现有数据</strong>(第12-17行)</h2><p id="b8f8" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">它使用<code class="fe lv lw lx ly b">d3.attr</code>函数用半径(第13行)、圆心<em class="oo"> X </em>值(第14行)、圆心<em class="oo"> Y </em>值(第15行)、圆描边颜色(第16行)和圆填充颜色(第17行)配置现有元素。</p><h2 id="124c" class="nv mh it bd mi oc od dn mm oe of dp mq lh og oh ms ll oi oj mu lp ok ol mw om bi translated"><strong class="ak">删除现有数据</strong>(第19行)</h2><p id="8f4f" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">以下函数用于删除现有数据:</p><ul class=""><li id="66e8" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt on nj nk nl bi translated"><code class="fe lv lw lx ly b">d3.exit</code>当连接的数组比选择的短时，返回需要删除的DOM元素。</li><li id="a5ae" class="nd ne it la b lb nm le nn lh no ll np lp nq lt on nj nk nl bi translated"><code class="fe lv lw lx ly b">d3.remove</code>通常跟在<code class="fe lv lw lx ly b">d3.exit</code>后面，实际上是从DOM中移除额外的元素。</li></ul><p id="7cc7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第19行删除了没有数据要绑定的DOM元素。</p><p id="fb5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二步和第三步(用同样的函数配置圆)不是多余的吗？</p><p id="61ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是的。它们被编码为允许新的和现有的元素以不同的方式显示或动画化。然而，由于它们是用相同的行为编码的，所以可以使用<code class="fe lv lw lx ly b">d3.merge</code>将它们组合起来，以处理输入的和现有的数据。</p><p id="1384" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是简化的D3代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="ee4d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过第6行上的<code class="fe lv lw lx ly b">merge</code>功能，D3代码被缩短。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1956" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">3.将D3代码放入useLayoutEffect</h1><p id="2be3" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">什么是<code class="fe lv lw lx ly b">useLayoutEffect</code>？</p><p id="ee6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b"><a class="ae lu" href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect" rel="noopener ugc nofollow" target="_blank">useLayoutEffect</a></code>有一个与<code class="fe lv lw lx ly b">useEffect</code>相同的签名，但是它在所有DOM突变后同步触发。这意味着<code class="fe lv lw lx ly b">useEffect</code>与所有DOM突变一起异步触发。</p><p id="e0c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事情是这样的:</p><ul class=""><li id="345c" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt on nj nk nl bi translated"><code class="fe lv lw lx ly b">props</code>或状态变化导致组件重新渲染。</li><li id="c7ee" class="nd ne it la b lb nm le nn lh no ll np lp nq lt on nj nk nl bi translated">React运行代码来更新DOM。</li><li id="2aff" class="nd ne it la b lb nm le nn lh no ll np lp nq lt on nj nk nl bi translated"><code class="fe lv lw lx ly b">useLayoutEffect</code>运行(阻止实际显示)。</li><li id="bb0d" class="nd ne it la b lb nm le nn lh no ll np lp nq lt on nj nk nl bi translated">显示是可视更新的。</li><li id="1ff6" class="nd ne it la b lb nm le nn lh no ll np lp nq lt on nj nk nl bi translated"><code class="fe lv lw lx ly b">useEffect</code>运行(不阻止实际显示)。</li></ul><p id="8a86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和往常一样，我们使用<a class="ae lu" href="https://medium.com/better-programming/10-fun-facts-about-create-react-app-eb7124aa3785" rel="noopener">创建React应用</a>来探索React <code class="fe lv lw lx ly b">useEffect</code>和<code class="fe lv lw lx ly b">useLayoutEffect</code>。以下是修改后的<code class="fe lv lw lx ly b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="f55f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当点击<code class="fe lv lw lx ly b">Update Data</code>按钮时，在控制台中，设置为<code class="fe lv lw lx ly b">0</code>，然后是<code class="fe lv lw lx ly b">1</code>和<code class="fe lv lw lx ly b">2</code>。显示屏显示最终值<code class="fe lv lw lx ly b">2</code>。我们可以看到<code class="fe lv lw lx ly b">useLayoutEffect</code>跑在<code class="fe lv lw lx ly b">useEffect</code>之前。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/6f7fd497b8894d72c74156e8d099ba72.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*BqCANXm5tb7RT3R3hN44lg.png"/></div></figure><p id="71bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过注释掉第11-14行并快速重复点击<code class="fe lv lw lx ly b">Update Data</code>按钮，我们可以看到<code class="fe lv lw lx ly b">0</code>和<code class="fe lv lw lx ly b">2</code>之间的切换。</p><p id="a262" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过注释掉第6-9行并快速重复点击<code class="fe lv lw lx ly b">Update Data</code>按钮，我们可以看到显示的值(<code class="fe lv lw lx ly b">1</code>)没有任何闪烁。</p><p id="9a71" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很多时候要用<code class="fe lv lw lx ly b">useEffect</code>。但是，如果代码改变了DOM，应该使用<code class="fe lv lw lx ly b">useLayoutEffect</code>来阻止显示，直到DOM完成改变。这样，我们可以避免显示器闪烁。</p><p id="d7a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然D3代码变异了DOM，就应该放入<code class="fe lv lw lx ly b">useLayoutEffect</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="b197" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第1行使用<code class="fe lv lw lx ly b">useLayoutEffect</code>包装D3代码。</p><p id="a5bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第2行确保数据是一个数组。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d4eb" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">4.设置事件监听器</h1><p id="34e1" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">正如我们提到的，对于<code class="fe lv lw lx ly b">svg</code>元素，我们将React的控制权让给D3。因此，我们可能需要处理一些额外的事情，比如调整大小。</p><p id="5899" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经根据观察区域的宽度均匀地画了圆。因为除非<code class="fe lv lw lx ly b">data</code>属性改变，否则不受控制的SVG组件不会重画，所以当调整显示大小时，这些圆不会被重新排列。需要使用事件侦听器来处理resize事件。在这种情况下，<code class="fe lv lw lx ly b">useEffect</code>是处理调整大小的好选择。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="c2e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第6行添加了<code class="fe lv lw lx ly b">resize</code>事件处理程序。</p><p id="ee79" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第7行在效果清理期间移除了<code class="fe lv lw lx ly b">resize</code>事件处理程序。</p><p id="4ffb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是可行的，但是在调整大小时显示屏会闪烁。事实上，我们不需要显示调整大小的每一步。<code class="fe lv lw lx ly b">Debounce</code>可以帮助我们延迟更改，直到调整大小稳定下来。我们可以使用<a class="ae lu" href="https://medium.com/better-programming/lodash-create-react-apps-built-in-library-for-debounce-and-throttle-with-hooks-3418087f44d8" rel="noopener"> Create React App内置的</a> <code class="fe lv lw lx ly b"><a class="ae lu" href="https://medium.com/better-programming/lodash-create-react-apps-built-in-library-for-debounce-and-throttle-with-hooks-3418087f44d8" rel="noopener">debounce</a></code>来实现这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="b3ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第5行，<code class="fe lv lw lx ly b">debounce</code>被添加到<code class="fe lv lw lx ly b">resize</code>事件处理程序中。</p><p id="62e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们有了React中D3的完整例子的所有部分。它们由三个文件组成:</p><ul class=""><li id="eaed" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt on nj nk nl bi translated">在<code class="fe lv lw lx ly b">package.json</code>的<code class="fe lv lw lx ly b"><a class="ae lu" href="https://medium.com/better-programming/package-jsons-dependencies-in-depth-a1f0637a3129" rel="noopener">dependencies</a></code>内增加的<code class="fe lv lw lx ly b">d3</code>包:</li></ul><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="f13b" class="nv mh it ly b gy nw nx l ny nz">"dependencies": {<br/>  "d3": "^6.3.1",<br/>  ...<br/>}</span></pre><ul class=""><li id="0219" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt on nj nk nl bi translated">新增的<code class="fe lv lw lx ly b">src/Circles.js</code>:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><ul class=""><li id="52c8" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt on nj nk nl bi translated">改装过的<code class="fe lv lw lx ly b">src/App.js</code>:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="f25e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的示例由两个组件组成:<code class="fe lv lw lx ly b">Update Data</code>按钮(第17行)和<code class="fe lv lw lx ly b">Circles</code>组件(第18行)。</p><p id="ada1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">单击该按钮时，圆会更新。第6-13行实现了点击处理程序。它计算要显示多少个圆以及每个圆的半径。</p><p id="a876" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是这个例子的视频剪辑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq ob l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f1a5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">5.React和D3代码之间的平衡</h1><p id="c16e" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">在前面的例子中，除了<code class="fe lv lw lx ly b">svg</code>和<code class="fe lv lw lx ly b">g</code>标记之外，数据可视化是由D3处理的，D3使用许多函数来操作SVG。</p><p id="dccd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际上，我们可以使用React直接管理SVG。下面是完成相同示例的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="a55d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那我们为什么需要D3呢？</p><p id="031b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于某些操作，D3提供了有利的方法，以非常简单的方式实现某些效果。例如，<code class="fe lv lw lx ly b">d3.scaleLinear</code>构建了一个投入与产出成线性关系的标度。在图表中定位数据会节省很多精力。</p><p id="4426" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们有两个强大的库来管理DOM。在某些情况下，他们可以实现类似的目标。React方式是React环境中固有的，而D3的方法在操纵数据可视化方面更胜一筹。我们展示了一个主要是D3的例子和另一个只有React的例子。它们可以以不同的比例混合。重要的是找到代码可管理性和效率的平衡点。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0a6a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="e846" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">D3非常适合数据可视化，React非常适合通用用户界面。它们都是操纵DOM的固执己见的库。将它们恰当地结合起来可以创造出漂亮的用户界面。</p><p id="31f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下一篇文章中，我们将在React 中构建D3图表。</p><p id="bfaa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae lu" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p></div></div>    
</body>
</html>