<html>
<head>
<title>A Quick Intro to React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应钩子的快速介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/quick-intro-to-react-hooks-6e8a44ae4aa6?source=collection_archive---------3-----------------------#2019-05-22">https://betterprogramming.pub/quick-intro-to-react-hooks-6e8a44ae4aa6?source=collection_archive---------3-----------------------#2019-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0f60" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用React挂钩向功能性React组件添加类组件特性，如状态管理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c5157a8f8c0ca31afc7c334ecb998725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eH3VFvqnt622-gAgY7pxFA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Dan Abramov介绍React Hooks API @ React Conf</p></figure><p id="5c06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">自从去年10月React Conf期间，<a class="ae lv" href="https://www.youtube.com/watch?v=dpw9EHDh2bM&amp;t=2s" rel="noopener ugc nofollow" target="_blank">脸书团队发布重大公告</a>以来，术语<em class="lu">挂钩</em>已经成为React社区的热门词汇。我们将永远反思我们在React中构建组件的方式。</p><p id="dd03" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是让我们倒回去一点。</p><p id="45a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">React背后的理论是用户界面的一部分(一个组件)将对状态变化做出“反应”。目前的表达方式是使用ES6类。</p><p id="efbb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总的来说，React使得在具有非常严格的单向数据流的大型应用程序中实施清晰的组织和层次结构变得非常容易，这导致了对状态的更好控制。简单吧？</p><p id="dd2b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是这些类组件有时意味着许多代码和实现不可重用，所以我们可能最终会有许多重复的逻辑——甚至更糟，庞大的组件很难浏览。</p><p id="76e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">才华横溢的React社区已经想出了不同的方法来解决这个问题，并使我们代码的某些部分在React组件中更具可重用性，如<a class="ae lv" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>或<a class="ae lv" href="https://reactjs.org/docs/render-props.html#___gatsby" rel="noopener ugc nofollow" target="_blank">渲染道具</a>。但是这两种模式都有它们的缺陷，特别是复杂性，因为它们意味着更多的嵌套组件——这是通向组件地狱的直接通道。</p><p id="535d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是钩子是来救我们的！或者至少，改变我们用代码创建组件的方式。它们不会是解决所有问题的灵丹妙药，但让我们仔细看看。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="16c2" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">什么是React钩子？</h1><p id="5199" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">简而言之，React挂钩是一种特殊的函数，用于向功能性React组件添加类组件特性，如状态管理。这使我们能够将逻辑封装在非常小且可重用的代码中。</p><p id="5814" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从16.8版本开始，钩子在React中正式可用。</p><p id="cb95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">值得注意的是，React团队不打算移除类组件，这不是替代，只是一种使管理状态更容易的方法。</p><p id="cb1a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些变化没有被打破，它们是完全选择加入和100%向后兼容的。</p><h2 id="779b" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">React挂钩与React类</h2><p id="8511" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">以前，我们会为非常简单的可重用UI创建一个功能组件。问题出现在触及生命周期事件或状态的需求之后，这意味着创建一个类组件。</p><p id="ba18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个简单的类组件如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/86b4f0be1848a200ed9182702657cf8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmoKnxwDo1iTrQAqmG0-cg.png"/></div></div></figure><p id="be03" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了钩子，我们可以简化为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/0d8c9bd5639356442493607763816f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4SeBwtFFRdQjWA7PxCjLtg.png"/></div></div></figure><p id="d2c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更简单，对吗？现在，将这种抽象带到一个代码库，这个代码库有几十个UI组件，这些组件之间共享代码。神奇的✨</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2a2b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">钩子的规则</h1><ul class=""><li id="2ec7" class="no np it la b lb mv le mw lh nq ll nr lp ns lt nt nu nv nw bi translated">不要在循环、条件或嵌套函数中调用钩子。</li><li id="47b2" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">永远不要从常规函数中调用钩子。</li><li id="ea1b" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">仅调用函数组件内部的挂钩或自定义挂钩。</li><li id="e18b" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">钩子应该位于组件的开头。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="fbbf" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">开箱即用的反应挂钩</h1><p id="197a" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">React为我们提供了一些基本的React钩子，其他实现的钩子基本上都是这些原语的变体:</p><ul class=""><li id="88ed" class="no np it la b lb lc le lf lh oc ll od lp oe lt nt nu nv nw bi translated"><em class="lu"> useState: </em>状态挂钩，用于在功能组件中设置状态</li><li id="2793" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><em class="lu"> useEffect </em>:副作用挂钩，用于数据获取、DOM更改(以避免对生命周期事件的需求)。</li><li id="5991" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><em class="lu"> useContext </em>:这个是要和React的<a class="ae lv" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a>一起使用；触发器使用最新的上下文值呈现。</li><li id="ac37" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><em class="lu"> useReducer </em>:替代<em class="lu"> useState </em>，用于复杂状态逻辑/Redux。</li><li id="f8ac" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><em class="lu"> useRef </em>:这个钩子就像一个类内部的实例变量，通常用来访问子DOM属性。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="a710" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">状态挂钩</h2><p id="926b" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">进入<em class="lu">使用状态。</em>该挂钩保持状态。它是在类组件中使用的<em class="lu"> this.state </em>和<em class="lu"> this.setState </em>的同义词。不同之处在于，它允许您将状态存储在一个更小的功能组件中。</p><p id="1fed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要管理这种状态，没有必要使用对象。可以使用简单类型的数据，如字符串、整型、布尔型等。</p><p id="8016" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">初始状态用一个初始参数调用，并返回一个包含两个元素的数组:当前状态值和setter函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/cde49950a2a557c26f77629adaa9aaf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ym8knK8XMpUjN_viL4htSQ.png"/></div></div></figure><p id="b197" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用状态为的简单功能组件示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/7422ac9deb49ad5d64b8ec48e46e3e4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P1xjUnp6uHHS4RTqcQVJFw.png"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="f954" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">效果挂钩</h2><p id="7ce7" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">每当我们愉快地用常规类组件编码时，我们通常依赖一些组件生命周期方法(如<em class="lu">componentdimount()</em>和<em class="lu"> componentWillUnmount() </em>)来设置一个副作用，并根据状态变化的方式使用<em class="lu"> componentDidUpdate() </em>进行一些其他更改。</p><p id="3572" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<em class="lu"> useEffect() </em>钩子，我们可以用一个简单的单一API来完成这个任务。</p><p id="0896" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该函数在组件首次渲染时运行，然后在随后的每次重新渲染/更新时运行。</p><p id="d68b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">React首先更新DOM并调用传递给<em class="lu"> useEffect() </em>的函数，而不会阻塞UI。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/623e5a9b3c04952d81ea1c7176654941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bLDmbTrTWmBVh8xJEwF5xw.png"/></div></div></figure><p id="7053" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过从第一个参数返回一个函数，可以实现与使用<em class="lu"> componentWillUnmount() </em>相同的功能:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/240b15fd7cea375959bfe3d179688775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hqXZqWODpi_v6G31IL9Qiw.png"/></div></div></figure><p id="dbfa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你也可以得到关于你想要更新的状态变量的超级细节，并且只为那些变量运行“useEffect ”(耶，性能！):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/1bb327da5a8d796811132d728fe25ddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mk0rcUbMT1jB0KbKgDYAFw.png"/></div></div></figure><p id="c2ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果第二个参数是一个空数组，这个效果将只在挂载时运行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/b08fe2d3f4767b35c29eb37edcdb9b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ay5pR76njKvGbuuVK92P6A.png"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="2d19" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">变径钩</h2><p id="c848" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">当我们在应用程序中使用复杂的状态逻辑时，我们通常可以依赖状态管理库，如<a class="ae lv" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>或<a class="ae lv" href="https://facebook.github.io/flux/" rel="noopener ugc nofollow" target="_blank"> Flux pattern </a>，这也意味着依赖reducers来触发我们视图中的动作。</p><p id="7640" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简而言之，缩减器是一个接受两个值并返回一个值的函数。例如，如果你有一个数组，你想把它们组合成一个值，最好的方法是使用一个reducer函数。</p><p id="efc7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，对于多个值，您可以像这样减少总和:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/f30d34c98f5114223a1a1c70175e1f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*galrmFYa0hF8hgJ_ab4W7g.png"/></div></div></figure><p id="2132" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将调用每个元素上的函数，传递总和并将其加到下一个元素上。</p><p id="76ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu"> useReducer </em>背后的逻辑本质上是一样的:我们传递一个Reducer函数和一个初始状态，reducer接收当前状态并返回一个新状态。</p><p id="4cb5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu"> useReducer </em>也被析构为两个自定义元素的数组，就像<em class="lu"> useState </em>一样。参数1是当前状态，参数2是调度功能:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/fa79922a109a65903ec15a0d8b1eb769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nXQYNkdC9fzR3aRF6Gth-A.png"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="d361" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">参考钩</h2><p id="1e05" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">这个钩子通常用于存储ref，并通过它的ref属性将其传递给DOM元素。与DOM交互非常有用，因为它会在每次渲染时给你相同的ref对象。</p><p id="a0e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个典型的例子是访问<em class="lu"> &lt;输入&gt; </em>元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/213e109780379ecd9d498cc2b0968714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*_8sskhSlsJk-_ziftCpP6w.png"/></div></figure><p id="f86f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu"> useRef </em>钩子给了我们一个地方来保存它的<em class="lu">中的可变值。当前</em>属性变异时不会导致重新渲染。您可以使用它来保存应用程序或组件中的任何可变值。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="14f6" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">定制挂钩</h2><p id="197d" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">这就是钩子最强大的地方:可以编写我们自己的钩子来使我们的代码变得枯燥无味！</p><p id="a9c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这主要是为了在组件之间共享状态和逻辑有一个额外的选项。</p><p id="0322" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在学习了<em class="lu"> useState </em>和<em class="lu"> useEffect </em>的基础知识之后，我们可以通过创建定制钩子来使代码更加紧凑。</p><p id="1c49" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">自定义钩子有助于避免组件之间共享的重复和冗余的有状态逻辑，因为可以导出/导入这些功能，甚至可以将它们制作成NPM包或GitHub库供社区使用。</p><p id="e5ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">自定义钩子是普通的JS函数，以前缀“use”命名，可以在其中使用钩子，并包含一个公共的有状态逻辑，可以在其他组件中重用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/de4766a2747806c5009bb50bdd8203f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sft5y71BAgqxBrKHJcmYkg.png"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="4712" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">展望未来</h2><p id="4986" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">虽然钩子对于React来说仍然是一种非常新的模式，可能需要一些时间来适应，但它们肯定是框架中最有前途的特性之一，就像React一样广受欢迎，因为它们允许我们以更轻松的方式创建组件，因此，使软件工程更容易，并为构建令人惊叹的东西留下更多的时间和空间。</p><p id="f050" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前端开发不就是这样吗？</p><p id="cffb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">React的前景是光明的。</p><p id="dc84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(个人注释:是的，我确实认为React是一个框架。)</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="a484" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">资源</h2><ul class=""><li id="f267" class="no np it la b lb mv le mw lh nq ll nr lp ns lt nt nu nv nw bi translated"><a class="ae lv" href="https://www.youtube.com/watch?v=dpw9EHDh2bM&amp;t=2s" rel="noopener ugc nofollow" target="_blank">今明两天反应，90%的清洁剂用钩子反应</a></li><li id="8d23" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><a class="ae lv" href="https://www.youtube.com/watch?v=G-aO5hzo1aw" rel="noopener ugc nofollow" target="_blank">和丹·阿布拉莫夫第一次尝试React钩子</a></li><li id="b69f" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><a class="ae lv" href="https://egghead.io/lessons/react-introduction-to-refactoring-a-react-application-to-react-hooks](https://egghead.io/lessons/react-introduction-to-refactoring-a-react-application-to-react-hooks" rel="noopener ugc nofollow" target="_blank">介绍如何将React应用重构为React挂钩</a></li><li id="b904" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><a class="ae lv" href="https://blog.bitsrc.io/10-react-custom-hooks-you-should-have-in-your-toolbox-aa27d3f5564d" rel="noopener ugc nofollow" target="_blank">酷炫定制React挂钩列表</a></li><li id="f6fb" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">React Podcast第31集，<a class="ae lv" href="https://reactpodcast.com/31" rel="noopener ugc nofollow" target="_blank"> Hooks与Ryan Florence混搭</a></li></ul></div></div>    
</body>
</html>