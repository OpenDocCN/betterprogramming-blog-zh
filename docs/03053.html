<html>
<head>
<title>Containerize Node, React, and Postgres With Docker on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在AWS上用Docker容器化节点、反应和Postgres</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/containerize-node-react-postgres-with-docker-on-aws-ca548595f01e?source=collection_archive---------2-----------------------#2020-01-17">https://betterprogramming.pub/containerize-node-react-postgres-with-docker-on-aws-ca548595f01e?source=collection_archive---------2-----------------------#2020-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f394" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">“如果你有容器问题，我为你感到难过，儿子，我有99个问题，它们都在容器中运行。"</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/08faaf82d1a1c942d17975a8b09f36b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*soSg33WGGon490ddP3R7Mg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查尔斯·伯德辛格在<a class="ae ky" href="https://unsplash.com/s/photos/container?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a4eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的Node.js应用程序为大联盟做好准备了吗？你希望有一个神奇、干净、清新的仙境，让你可以运行你的应用程序吗？</p><p id="9498" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你对集装箱化感兴趣但不知道从哪里开始吗？</p><p id="7cbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是你吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/528f0aa9abd322c12759b55158942c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:320/format:webp/0*LmajgiqJuVp_qQJW.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">你(可能)。</p></figure><p id="b7b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要再看了…</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d9be" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">集装箱化</strong></h1><p id="893d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在本文中，我们将研究如何使用Docker封装Node.js应用程序。</p><p id="c5ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的是，我们将在AWS上运行它，并使用Docker Compose编排它。我们还将添加一些额外的服务来模拟真实的生产部署。<a class="ae ky" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> Postgres </a>为数据库，一个基本的React app为前端。</p><p id="73a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我假设如果你已经到了这里，你已经对码头和集装箱化服务有了一些基本的了解，但如果你没有，没关系！在Docker 上查看这个伟大的<a class="ae ky" href="https://docs.docker.com/engine/docker-overview/" rel="noopener ugc nofollow" target="_blank">初级读本。</a></p><p id="9f44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个有趣的学术练习，旨在向您展示如何在EC2主机上为Node.js应用程序建立Docker容器。在本文结束时，您将对整个过程有更好的理解，并为您自己的现有应用程序的容器化打下基础。</p><p id="494c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些更喜欢视觉学习的人，让我们来看看这些服务的结构是什么样子的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/ccc8cf042d976fac71856ace35d13d84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*s7lpZATBpbdSKYE57do7PA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">人人都爱ASCII艺术！</p></figure><p id="47a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了了解这些服务如何交互并获得一些使用当前技术的实践经验之外，这里没有最终目标。</p><p id="94ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不做任务清单，不会有任何外部API，只是纯粹的功能。让我们开始吧。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8409" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">第一步。EC2主机</h1><p id="ec9c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">你需要一个地方来运行这些。最容易的地方是在您自己的机器上，但是您也可以在AWS中轻松地构建一个EC2实例，这就是我所做的。</p><p id="d89b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将带您在EC2实例上设置这个项目，但是需要一些先决条件:</p><ul class=""><li id="68b0" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">您拥有一个有效的亚马逊AWS账户。</li><li id="a7bd" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">您应该已经准备好了一个<a class="ae ky" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/get-set-up-for-amazon-ec2.html" rel="noopener ugc nofollow" target="_blank"> EC2实例。操作系统为Amazon Linux的t2-micro型运行良好。</a></li><li id="4d51" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">您应该拥有对实例的SSH访问权限。</li></ul><p id="44f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦连接到实例，让我们继续下一步。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8930" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">第二步。Docker安装</h1><p id="6901" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果没有安装Docker，就无法运行。<a class="ae ky" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/docker-basics.html" rel="noopener ugc nofollow" target="_blank">首先在EC2实例上安装Docker </a>和Docker-compose，使用以下命令:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="39c1" class="nu me it nq b gy nv nw l nx ny">sudo yum update -y<br/>sudo amazon-linux-extras install docker<br/>sudo service docker start</span></pre><p id="b23a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要将您的用户添加为Docker用户，这样您就不需要每次都运行<code class="fe nz oa ob nq b">sudo</code>。(如果您已经更改了用户，请更新<code class="fe nz oa ob nq b">ec2-user</code>名称:)</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="ef6c" class="nu me it nq b gy nv nw l nx ny">sudo usermod -a -G docker ec2-user</span></pre><p id="7ac1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让您的实例重新启动，一旦它备份，通过运行以下命令检查一切工作正常:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="f017" class="nu me it nq b gy nv nw l nx ny">docker info</span></pre><p id="46f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的输出应该如下所示:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="9828" class="nu me it nq b gy nv nw l nx ny"><br/>Client:<br/> Debug Mode: false<br/><br/>Server:<br/> Containers: 1<br/>  Running: 1<br/>  Paused: 0<br/>  Stopped: 0<br/> Images: 1<br/></span></pre><p id="823f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一件事，我们需要在实例上打开一些端口，这样我们就可以访问web服务并查看我们的结果。为了这个项目，我们可以开放<code class="fe nz oa ob nq b">3000</code>港给你自己的公共IP。</p><p id="0d91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">端口<code class="fe nz oa ob nq b">3000</code>是React运行其服务器的默认开发端口，并且<em class="oc">不应用于生产</em>。</p><p id="fa21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击<code class="fe nz oa ob nq b"><a class="ae ky" href="http://whatismyip.akamai.com" rel="noopener ugc nofollow" target="_blank">http://whatismyip.akamai.com</a></code>查看你当前的公共IP地址。</p><p id="940a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，访问AWS控制台，使用允许流量从您的IP到TCP端口上的实例的入站规则编辑实例安全组<code class="fe nz oa ob nq b">3000</code>(关于如何做的更多信息<a class="ae ky" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/authorizing-access-to-an-instance.html" rel="noopener ugc nofollow" target="_blank">在这里</a>)。</p><p id="2c61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们创建一些容器。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="47b5" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">第三步。布局</h1><p id="656e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">由于我们已经做了很多工作，我将向您展示基本的目录结构应该是什么样子:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="a819" class="nu me it nq b gy nv nw l nx ny">project_dir/<br/>    |<br/>    |-- react_frontend/<br/>    |       |<br/>    |       |-- (react.js app data)<br/>    |<br/>    |-- node_backend/<br/>    |       |<br/>    |       |-- (node.js app data)<br/>    |<br/>    |-- pg/<br/>    |   |<br/>    |   |-- pg_data/.. (created by postgres container)<br/>    |<br/>    |-- docker-compose.yml</span></pre><p id="98ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随意创建父目录，一个空的<code class="fe nz oa ob nq b">docker-compose.yml</code>、<code class="fe nz oa ob nq b">node_backend</code>目录和<code class="fe nz oa ob nq b">pg</code>目录，但是将<code class="fe nz oa ob nq b">react_frontend</code>目录留到稍后我们自动生成它的时候。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1e83" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">第四步。Node.js后端</h1><p id="4a16" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我想在这里提出一个警告，虽然这对于生产工具来说是一个很好的实践，但是这段代码不应该在生产中使用！使用的Docker容器是非常基本的，没有任何额外的安全性，所以要小心操作。</p><p id="5505" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文结束时，您不会得到一个生产就绪、经过实战检验的应用程序，但是您将得到一个构建自己的容器化应用程序的良好基础。</p><p id="1656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果此时您想直接在EC2实例上工作，您可以，或者您可以在本地机器上工作，稍后再上传文件。选择权在你，但你需要确保你已经做好了基本的准备:</p><ul class=""><li id="1a80" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated"><a class="ae ky" href="https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/setting-up-node-on-ec2-instance.html" rel="noopener ugc nofollow" target="_blank">在Linux上安装节点</a>。</li><li id="2843" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><a class="ae ky" href="https://nodejs.org/en/download/package-manager/#macos" rel="noopener ugc nofollow" target="_blank">在Mac上安装节点</a>。</li><li id="c12a" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><a class="ae ky" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#using-instance-addressing-common" rel="noopener ugc nofollow" target="_blank">获取您的EC2实例的公共IP</a>。</li></ul><p id="70f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您选择在本地发展，您将可以访问:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="e0b0" class="nu me it nq b gy nv nw l nx ny">http://localhost:&lt;port&gt;</span></pre><p id="4771" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在EC2实例上开发，您将访问:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="eb62" class="nu me it nq b gy nv nw l nx ny">http://&lt;ec2_public_ip&gt;:&lt;port&gt;</span></pre><p id="d82b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就我个人而言，我选择在本地开发，然后再部署，这可以说是一种规范。如果您选择在主机上进行远程开发，请确保记下关于它的重要信息，比如IP地址。</p><p id="6f24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启动并运行后，您可以运行以下命令来创建一个新项目:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="6ade" class="nu me it nq b gy nv nw l nx ny">mkdir node_backend<br/>cd node_backend<br/>npm init -y<br/>npm install cors express pg</span></pre><p id="d4c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在这个目录中创建一个名为<code class="fe nz oa ob nq b">index.js</code>的新文件，并在其中放置以下代码用于测试后端:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="b71b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生了很多事情。让我们来分解一下我们在这段代码中所做的一些事情:</p><ul class=""><li id="0b5e" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">在端口<code class="fe nz oa ob nq b">3001</code>上设置<a class="ae ky" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>服务器，当你访问<code class="fe nz oa ob nq b"><a class="ae ky" href="http://localhost:3001" rel="noopener ugc nofollow" target="_blank">http://&lt;host&gt;:3001</a></code>时，你会在你的浏览器中看到。</li><li id="fd1a" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">启用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>向其他服务发出请求。</li><li id="3924" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">使用身份验证和主机参数设置新的Postgres池。</li><li id="8896" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">为我们的应用程序设置两条路由:根路由(<code class="fe nz oa ob nq b">‘/’</code>)和返回PG查询结果的路由(<code class="fe nz oa ob nq b">‘/test_query’</code>)。</li><li id="cd45" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">最后，告诉服务器监听指定的端口并输出日志消息。</li></ul><p id="f9cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，您应该能够通过运行以下命令来测试基本功能:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="425a" class="nu me it nq b gy nv nw l nx ny">node server.js</span></pre><p id="937b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务器应该会启动，您可以在浏览器中导航到<code class="fe nz oa ob nq b"><a class="ae ky" href="http://localhost:3001" rel="noopener ugc nofollow" target="_blank">http://&lt;host&gt;:3001</a></code>来查看原始的JSON响应。</p><p id="baa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">酷！</p><p id="fa62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要的最后一个重要部分是为应用程序创建一个<code class="fe nz oa ob nq b">Dockerfile</code>，然后在我们的<code class="fe nz oa ob nq b">docker-compose.yml</code>文件中添加一个条目，告诉它在哪里构建。</p><p id="ab5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的<code class="fe nz oa ob nq b">node_backend</code>目录中创建一个新的<code class="fe nz oa ob nq b">Dockerfile</code>。用以下内容填充它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="ef49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的<code class="fe nz oa ob nq b">Dockerfile</code>指令改编自Node.js团队建议的基本配置。更多细节可在Node.js 获得<a class="ae ky" href="https://nodejs.org/de/docs/guides/nodejs-docker-webapp/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="0521" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在打开父目录中的<code class="fe nz oa ob nq b">docker-compose.yml</code>,添加以下样板文件和后端服务的条目:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2ddc" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">第五步。Postgres</h1><p id="0c34" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们将使用一个简单的Postgres数据库作为测试数据。让我们将它添加到我们的<code class="fe nz oa ob nq b">docker-compose.yml</code>文件中，放在我们刚刚在上面创建的<code class="fe nz oa ob nq b">node_backend</code>条目之后:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="0b37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！现在让我们通过运行:<code class="fe nz oa ob nq b">docker-compose up</code>来旋转我们的服务对。</p><p id="9a2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在构建容器时，您应该会看到一些输出，最终会看到标准的控制台日志记录，表明服务正在运行并接受连接。</p><p id="5894" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您实际上还不能查询任何内容，因为:</p><ul class=""><li id="7984" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">数据库连接尚未建立。</li><li id="2327" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">没有可查询的数据！</li></ul><p id="7072" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来补充一些测试数据…</p><p id="812c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到postgres容器指定了名称“Postgres”。当您需要直接连接到一个容器并在里面运行一些命令时，这就容易多了。</p><p id="b289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们连接到<code class="fe nz oa ob nq b">psql</code>并输入一些测试数据:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="8a67" class="nu me it nq b gy nv nw l nx ny">docker exec -it postgres psql -U postgres</span></pre><p id="ab68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的命令将把您连接到运行Postgres的容器的<code class="fe nz oa ob nq b">psql</code>控制台。下一组命令将让我们在数据库中植入一些数据:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="e164" class="nu me it nq b gy nv nw l nx ny">CREATE ROLE admin WITH LOGIN PASSWORD 'your_admin_password';<br/>CREATE DATABASE testdata WITH OWNER admin;<br/>\c testdata admin<br/>CREATE TABLE data (ID SERIAL PRIMARY KEY, firstname TEXT, lastname TEXT);<br/>INSERT INTO data (firstname, lastname) VALUES ('John', 'Doe');</span></pre><p id="6329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唷！太多了。我们刚刚做了什么？</p><ul class=""><li id="8414" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">连接到PG容器并运行<code class="fe nz oa ob nq b">psql</code>以获得PG控制台。</li><li id="f697" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">创建了一个新的数据库和一个新的管理员用户(使用您自己的密码)。</li><li id="d708" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">作为管理员用户切换到新数据库(<code class="fe nz oa ob nq b">\c</code>)。</li><li id="4e87" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">创建了一个名为<code class="fe nz oa ob nq b">data</code>的新表，其中有两个名为<code class="fe nz oa ob nq b">firstname</code>和<code class="fe nz oa ob nq b">lastname</code>的字段。</li><li id="565a" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">向表中添加一条新记录。</li></ul><p id="cba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要记住的一件重要事情是，您正在使用我们刚刚创建的新的<code class="fe nz oa ob nq b">admin</code>用户名和密码连接到这个数据库。如果您需要返回并调整Node.js服务器，现在是个好时机。</p><p id="bd4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，您应该能够访问<code class="fe nz oa ob nq b"><a class="ae ky" href="http://localhost" rel="noopener ugc nofollow" target="_blank">http://&lt;host&gt;:3001/test_query</a></code>并看到我们的新表格数据！</p><p id="db70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果遇到麻烦，可以从Node.js服务器中的连接参数开始。</p><p id="33f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按下<code class="fe nz oa ob nq b">&lt;ctrl-c&gt;</code>关闭你的容器，让我们进入最后一块。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b95f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">第六步。React.js前端</h1><p id="f89d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有很多关于用React创建基本应用程序的教程，所以我在这里就不赘述了。如果你有兴趣更深入地了解React，我强烈推荐<a class="of og ep" href="https://medium.com/u/b79712bf0f04?source=post_page-----ca548595f01e--------------------------------" rel="noopener" target="_blank"> Emi Katsuta </a>的<a class="ae ky" href="https://medium.com/better-programming/creating-a-simple-app-with-react-js-f6aa88998952" rel="noopener">文章</a>。</p><p id="bda0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过运行以下命令来创建一个新的React应用程序:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="9dd3" class="nu me it nq b gy nv nw l nx ny">npx create-react-app react_frontend<br/>cd react_frontend</span></pre><p id="26df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在<code class="fe nz oa ob nq b">react_frontend</code>目录中为一个新的基本React应用程序创建了框架。进入目录后，让我们通过运行以下命令来尝试一下:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="5c44" class="nu me it nq b gy nv nw l nx ny">npm start</span></pre><p id="13cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该看到应用程序启动了，在你的浏览器中你可以访问<code class="fe nz oa ob nq b"><a class="ae ky" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://&lt;host&gt;:3000</a></code>来看看结果——一个旋转的React标志！</p><p id="2099" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们稍微编辑一下应用程序，这样我们就可以连接到Node.js后端并查询一些数据。在你的<code class="fe nz oa ob nq b">react_frontend</code>目录中，打开<code class="fe nz oa ob nq b">src/App.js</code>，看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="5c34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里所做的是创建一个名为<code class="fe nz oa ob nq b">getTestQuery</code>的新函数，它将向后端发出请求，然后将查询结果返回给视图。</p><p id="bb6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当组件用<code class="fe nz oa ob nq b">componentDidMount</code>函数加载时，调用该函数。</p><p id="c49e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用一个空数组填充<code class="fe nz oa ob nq b">state</code>,一旦数据被加载，我们就可以将数据推入这个空数组。</p><p id="636c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成所有这些工作后，我们返回一个包含DB表条目列表的模板，这些条目的id映射到每个列表项的key属性中(使每个条目都是惟一的)。</p><p id="107c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们通过为前端创建另一个<code class="fe nz oa ob nq b">Dockerfile</code>来结束:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="9f06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将希望把它放在<code class="fe nz oa ob nq b">react_frontend</code>目录的根目录中，就像我们对后端所做的那样。</p><p id="e978" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到这与我们创建的上一个<code class="fe nz oa ob nq b">Dockerfile</code>非常相似。实际上，您可以从后端重用这个文件，并为每个服务添加不同的构建参数，但是为了简单和分段，我为这个项目创建了两个单独的文件。</p><p id="0892" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要忘记将这个服务条目添加到我们一直在使用的主<code class="fe nz oa ob nq b">docker-compose.yml</code>文件的末尾:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="cee5" class="nu me it nq b gy nv nw l nx ny">react_frontend:<br/>    container_name: "react_frontend"<br/>    build: ./react_frontend/<br/>    ports:<br/>      - "3000:3000"</span></pre><p id="7ac6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">厉害！现在，我们已经构建了所有三个服务，并准备好开始工作。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e31a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">第七步。把所有的放在一起</h1><p id="e3d5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">你期待已久的时刻。是时候一次启动所有服务了，希望不会发生爆炸！</p><p id="cb04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:如果您一直在EC2主机上进行开发，那么您需要做的就是使用下面的命令启动服务。</p><p id="3ce2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您一直在本地计算机上工作，还有其他步骤。您需要SCP将文件传输到EC2主机(或者提交到您的GitHub帐户，但这里不讨论)。</p><p id="2c62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="of og ep" href="https://medium.com/u/1effdbd182e3?source=post_page-----ca548595f01e--------------------------------" rel="noopener" target="_blank">西坎达尔·汗</a>对如何做到这一点有很好的示范<a class="ae ky" href="https://medium.com/@dearsikandarkhan/files-copying-between-aws-ec2-and-local-d07ed205eefa" rel="noopener">在媒体</a>上。</p><p id="e830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦一切就绪，运行以下命令使其全部联机:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="41b2" class="nu me it nq b gy nv nw l nx ny">docker-compose up --build</span></pre><p id="45d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会看到每个服务启动时的一些输出。一旦您确认每个服务都已启动并且没有错误，请尝试访问<code class="fe nz oa ob nq b"><a class="ae ky" href="http://localhost" rel="noopener ugc nofollow" target="_blank">http://&lt;host&gt;:3000</a></code>以查看React页面。您应该会看到类似这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/3f6369993e3fb0ee0bc5aeb1f6c56f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*gxlj_DVfsE4PRmf1WXRcRg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">很简单，是吧？</p></figure><p id="114e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！你已经做到了。虽然看的不多，但是底层配置你应该很自豪。</p><p id="e5e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建这些服务、启动它们并互连它们的过程体现了容器化和分段的一些最佳原则。</p><p id="a619" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我不会<em class="oc">真的</em>称这些为“微服务”，但它们是小型、轻量级和分段的。</p><p id="ab45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在本文中使用的大部分方法都可以被应用到容器化你自己的应用程序中，并解决一些由单一服务产生的问题。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5f98" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="8d9d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">哇！多好的旅程啊。我希望您喜欢构建我们的小服务包，并了解容器化过程如何为具有React前端的Node.js应用程序工作。</p></div></div>    
</body>
</html>