<html>
<head>
<title>Annotate Text From Google Sheet Using Google Apps Script and Machine Learning APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Google Apps脚本和机器学习API注释Google Sheet中的文本</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/automate-your-tasks-how-do-google-sheets-and-machine-learning-make-our-lives-easier-cc8ba3ef8e8d?source=collection_archive---------7-----------------------#2022-09-11">https://betterprogramming.pub/automate-your-tasks-how-do-google-sheets-and-machine-learning-make-our-lives-easier-cc8ba3ef8e8d?source=collection_archive---------7-----------------------#2022-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8062" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">谷歌表单和机器学习让自动化变得更加容易</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/567fe379cf8bafa0dad750cca36a29e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kvb1jtRgXq5OUNXxmv77og.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">让我们更聪明地工作，而不是更努力地工作(作者)</p></figure><p id="35ee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们将结合Google Apps脚本和机器学习API的强大功能，创建一个新的功能来注释工作表中的文本。</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="a38a" class="lw lx iq ls b gy ly lz l ma mb">Table of Contents</span><span id="e51d" class="lw lx iq ls b gy mc lz l ma mb"><a class="ae md" href="#e894" rel="noopener ugc nofollow">A Practical Use Case: HR Recruiting Process</a><br/><a class="ae md" href="#736e" rel="noopener ugc nofollow">How To Do This?</a><br/><a class="ae md" href="#d2d4" rel="noopener ugc nofollow">Let’s Do It!</a><br/><a class="ae md" href="#a54f" rel="noopener ugc nofollow">Final Code, Results and Conclusion</a></span></pre><blockquote class="me mf mg"><p id="8846" class="kv kw mh kx b ky kz jr la lb lc ju ld mi lf lg lh mj lj lk ll mk ln lo lp lq ij bi translated"><strong class="kx ir">注意</strong>:在本文中，我们使用了一个已经构建和部署的模型。</p><p id="b3bc" class="kv kw mh kx b ky kz jr la lb lc ju ld mi lf lg lh mj lj lk ll mk ln lo lp lq ij bi translated">考虑阅读<a class="ae md" href="https://medium.com/mlearning-ai/categorize-invoices-using-multimodal-transformers-leveraging-both-structured-and-unstructured-data-d291ee0295d6" rel="noopener">这篇</a>文章以了解更多关于构建模型的信息，以及<a class="ae md" href="https://medium.com/mlearning-ai/ml-ops-tools-for-nlp-f836a3fdc30a" rel="noopener">这篇</a>关于使用REST API将NLP模型部署为预测微服务的工具和最佳实践。</p></blockquote><h1 id="e894" class="ml lx iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">一个实际的用例:人力资源招聘流程</h1><p id="3872" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">你曾经使用过像Google Sheets这样的电子表格程序吗？<br/>您可能已经使用它对排列在单元格(行∩列)中的数据执行了一些计算和操作。为此，我们有一堆公式可以使用(例如，IF()、SUM()、TEXT()、SEARCH()等)。).</p><p id="6bde" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然电子表格为我们提供了广泛的有用操作，但有时我们需要执行只有外部机器学习模型才能处理的特定任务。这是一个业务用例的例子:</p><blockquote class="me mf mg"><p id="a63e" class="kv kw mh kx b ky kz jr la lb lc ju ld mi lf lg lh mj lj lk ll mk ln lo lp lq ij bi translated">如果你是一家初创公司的IT招聘人员，你收到了500份申请，你会自动收集到一张表格中，你必须仔细阅读每份申请，以决定候选人是否应该被列入测试/面试的入围名单或被拒绝。但是要对500篇超过1000个单词的文本进行分类将是一个冗长而低效的过程。</p><p id="5944" class="kv kw mh kx b ky kz jr la lb lc ju ld mi lf lg lh mj lj lk ll mk ln lo lp lq ij bi translated">为了帮助您自己，您已经决定自动拒绝任何不符合最低工作经验年限、适当学位以及不具备至少80%所需技能的申请。</p><p id="a6f9" class="kv kw mh kx b ky kz jr la lb lc ju ld mi lf lg lh mj lj lk ll mk ln lo lp lq ij bi translated">那事情就简单多了，对吧？但是如何从每份工作申请中自动提取技能、文凭和经验呢？</p></blockquote><p id="644f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简单的答案是使用机器学习模型作为服务，该服务将文本(工作申请)作为输入，并返回搜索到的实体(技能、学位等。)作为输出。</p><p id="9d02" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这只是成千上万个人和专业用例中的一个商业用例，Google Apps脚本和ML APIs将帮助您用更少的资源获得更好的结果。</p><p id="35f6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇文章中，我们将从候选人的角度来探讨人力资源流程。我们不是为招聘人员检测申请和工作要约之间的匹配，而是帮助候选人提取工作要约中所需的技能、所需的经验年数和文凭专业，以便他们可以有更强的申请能力。</p><p id="b37b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是我们期望得到的结果的演示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/bb2bc30ce154740dd0c56ba01c671e84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*E36FBPiNHjr9xd3-uqs3kw.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">演示:用户在谷歌表单中输入工作描述，然后使用我们将创建的功能(由作者创建)从中获得技能、经验和文凭</p></figure><h1 id="736e" class="ml lx iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">如何做到这一点？</h1><p id="1751" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">为了进行我们上面提到的自动实体提取，我们必须首先部署一个ML模型API，它将文本作为输入并返回它的实体。一旦有了这些，我们将使用Google Apps脚本从用户的表单中获取输入，使用这些数据调用API，并在表单中显示结果。</p><ul class=""><li id="74d4" class="ni nj iq kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated">UBIAI自动标注API:提供为自动标注和推理训练NLP模型的能力。自动标注工具减少了标注数据所需的时间和金钱，并允许自动标注实体，如时间、地点、日期、产品、人员等。，从原生文件下载文本后。</li></ul><p id="8111" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于本文，我们将使用一个由<a class="ae md" href="https://ubiai.tools/" rel="noopener ugc nofollow" target="_blank"> ubiai.tools </a>训练的模型来从工作描述中提取技能等实体。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/493946e3be0c36b3d929ea89b99bc3eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*G6jIkMb_25O-p0ed.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">自动标记工具提取技能，文凭，经验等。(来源:<a class="ae md" href="https://ubiai.tools/features/r1-auto-labeling" rel="noopener ugc nofollow" target="_blank">优必选</a>)</p></figure><h2 id="2874" class="lw lx iq bd mm ns nt dn mq nu nv dp mu le nw nx mw li ny nz my lm oa ob na oc bi translated">Google企业应用套件脚本</h2><p id="c8db" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">开发应用程序可能是一项复杂的任务。然而，如今，我们有越来越多的工具来帮助完成这项任务，因此可以更容易地执行它，正如本文中的例子。Google Apps脚本就是这种软件的一个例子。它允许我们在Google的一些服务中编写脚本，因此可以修改Google Sheets软件的行为。</p><p id="13f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从更广的范围来看，它对于创建创造性的应用程序非常有效，这些应用程序可以通过Google Drive或Chrome网络商店中的出版物进行存储并与许多人共享。Google Script是用于此目的的编程语言。它与JavaScript非常相似，尽管后者通常用于操作网页，但Google Script更适合访问数据和修改Google应用程序的行为。</p><blockquote class="me mf mg"><p id="bc7c" class="kv kw mh kx b ky kz jr la lb lc ju ld mi lf lg lh mj lj lk ll mk ln lo lp lq ij bi translated"><strong class="kx ir">注意</strong>:有两种类型的应用程序脚本:独立脚本，不链接到特定的谷歌文档，和容器绑定脚本，链接到谷歌文档并从该文档创建。在本文中，很明显我们将使用来自Google Sheets电子表格的容器绑定脚本。</p></blockquote><h1 id="d2d4" class="ml lx iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">我们开始吧！</h1><p id="6a38" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">因此，首先，我们需要创建一个<a class="ae md" href="https://docs.google.com/spreadsheets/" rel="noopener ugc nofollow" target="_blank"> Google sheet </a>，我们将把数据放在其中进行处理:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/661dbf60cfed45f45fa5cc9d575fe983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-az62WhN8rYDEkyXymQyEQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Google Sheets(按作者)</p></figure><p id="70e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们需要通过扩展&gt;应用程序脚本来访问应用程序脚本:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/a5e808d19aa4ced719cb0b0f636eb187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UEH0WRKeUwMFL7C1NioZ1w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从Google工作表创建的Google Apps脚本(由作者创建)</p></figure><p id="5da5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们已经创建了一个名为<code class="fe oe of og ls b">Code.gs</code>的文件，其中包含一个名为<code class="fe oe of og ls b">myFunction</code>的默认函数，所以我将函数的名称改为<code class="fe oe of og ls b">getUbiaiAnnotationResponse</code>，现在我们可以开始编写脚本了。是的，就这么简单😎。</p><ul class=""><li id="dfcc" class="ni nj iq kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated">脚本中要做的第一件事是从用户的工作表中获取数据。用户将调用一个函数，将对应于工作描述的单元格传递给它。因此，让我们为我们的函数添加一个参数，该参数对应于用户的工作描述输入，然后将它赋给一个变量，该变量将包含在API调用的主体中。代码如下:</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/80d2ef71ebc2aa68af1ab136f75c340b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*iIDAHl_wh-T7Beb7vT2OJA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">获取数据(按作者)</p></figure><ul class=""><li id="b9b8" class="ni nj iq kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated">接下来，让我们设置适当的<a class="ae md" href="https://ubiai.tools/" rel="noopener ugc nofollow" target="_blank"> ubiai.tools </a> API选项:</li></ul><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="bc44" class="lw lx iq ls b gy ly lz l ma mb">const apiRoot = 'https://api.ubiai.tools:8443/api_v1/annotate/';</span><span id="14ca" class="lw lx iq ls b gy mc lz l ma mb">const apiToken = '*** Secret String :) ***';</span><span id="ac4e" class="lw lx iq ls b gy mc lz l ma mb">const options = {<br/>   'method': 'post',<br/>   'contentType': 'application/x-www-form-urlencoded',<br/>   'payload': data<br/>};</span></pre><p id="d537" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们将使用POST请求在HTTP消息体的单个块中发送数据。</p><p id="f4c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们使用令牌和选项调用API，然后解析响应并检索返回的实体。它看起来是这样的:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="f8c3" class="lw lx iq ls b gy ly lz l ma mb">const response = UrlFetchApp.fetch(apiRoot + apiToken, options);</span><span id="362b" class="lw lx iq ls b gy mc lz l ma mb">const entities = JSON.parse(response)[0].entities;</span></pre><p id="549a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们在一个数据样本上运行代码，看看结果:</p><blockquote class="me mf mg"><p id="6935" class="kv kw mh kx b ky kz jr la lb lc ju ld mi lf lg lh mj lj lk ll mk ln lo lp lq ij bi translated"><strong class="kx ir">注意</strong>:你第一次运行脚本时会被询问权限。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/2a403a03d663c56d428846a124287f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0yEi1hoYtsNufvB6HJeTiA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">API响应(按作者)</p></figure><p id="1b14" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，如上面的截图所示，对数据“五年经验，计算机科学学位，python专家”运行我们的脚本，返回一个包含实体“5年”是一个<code class="fe oe of og ls b">Experience</code>、“计算机科学”是一个<code class="fe oe of og ls b">Diploma_Major</code>、“Python”是一个<code class="fe oe of og ls b">Skill</code>的实体列表。</p><p id="5428" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于我们对在自定义列中显示<code class="fe oe of og ls b">Skills</code>、<code class="fe oe of og ls b">Diploma_Major</code>和<code class="fe oe of og ls b">Experience</code>感兴趣，让我们继续定义三个函数来将请求的标签发送回用户的工作表:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="62ab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe oe of og ls b">getSkills</code>函数取用户的数据，然后调用我们定义的<code class="fe oe of og ls b">getUbiaiAnnotationResponse </code>函数调用NLP API，将想要的技能实体返回给用户(同样适用于<code class="fe oe of og ls b">getExperience</code>和<code class="fe oe of og ls b">getDiploma</code>)。</p><blockquote class="me mf mg"><p id="9922" class="kv kw mh kx b ky kz jr la lb lc ju ld mi lf lg lh mj lj lk ll mk ln lo lp lq ij bi translated">注意:由于我们可能使用相同的数据调用<code class="fe oe of og ls b"><em class="iq">getSkills</em></code>、<code class="fe oe of og ls b"><em class="iq">getExperience</em></code>和<code class="fe oe of og ls b"><em class="iq">getDiploma</em></code>，所以在代码中添加缓存机制以避免不必要的冗余API调用将是一个很好的实践。</p></blockquote><h1 id="a54f" class="ml lx iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">最终代码、结果和结论</h1><p id="2076" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated"><code class="fe oe of og ls b">getSkills</code>最终代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="e908" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe oe of og ls b">getExperience</code>最终代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="53fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe oe of og ls b">getDiploma</code>最终代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="e640" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe oe of og ls b">getUbiaiAnnotationResponse</code>最终代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/35482cd130dcd7bfc5ab7a5e39789518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WG0MOJbdFh9d3H1t7S7Sew.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最终代码:API调用(由作者编写)</p></figure><h1 id="1fd6" class="ml lx iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">谷歌表单结果</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/43be5593f2cbe6b20d9c71f5a520f06f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VFLDZ4tqTjIJL5bPyS6cYw.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">google表单上的结果(按作者)</p></figure><p id="becd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然这个用例很简单(从工作描述中提取技能、经验和专业文凭)，但它旨在演示如何在Google Sheets中使用外部API来创建处理文本的新功能。</p><p id="05ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用预先训练的NLP模型可以使工作自动化，并提高效率。当您可以利用Google Sheets和机器学习模型时，这种技术可以用于任何其他用例。</p><p id="6721" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="mh">感谢阅读！敬请关注更多内容。</em></p></div></div>    
</body>
</html>