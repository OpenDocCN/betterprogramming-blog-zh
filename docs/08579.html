<html>
<head>
<title>One Solid Way To Reload App Contents Without Long Polling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无需长时间轮询即可重新加载应用内容的可靠方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/one-solid-way-to-reload-app-contents-without-long-polling-d13e2a9b0abc?source=collection_archive---------8-----------------------#2021-05-17">https://betterprogramming.pub/one-solid-way-to-reload-app-contents-without-long-polling-d13e2a9b0abc?source=collection_archive---------8-----------------------#2021-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="caa9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">WebSockets和长轮询都不错，但是还有一个更好的选择</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a76687848185c670225cff4da000a386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vPIeSTDs9BrSWVj-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">塔德乌什·拉科塔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="4410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您是否经历过这样的情况:您的前端应用程序必须接收一些更新并相应地刷新其用户界面？一个例子是观察服务器上长时间运行的任务并实时检查日志。或者是看财经或体育新闻。它必须是客户端和服务器之间的单向通信通道。</p><p id="acfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来探索如何实现这一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c7a0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">发现</h1><p id="0a69" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在可能会出现多种想法。我们可以通过<a class="ae ky" href="https://en.wikipedia.org/wiki/WebSocket" rel="noopener ugc nofollow" target="_blank">网络插座</a>来实现。虽然这种方法听起来很合理，但看起来开销很大。WebSockets是TCP连接上的全双工协议。这对于许多用例来说是很棒的，但是在我们的场景中，我们不需要向服务器发送常规请求。我们的客户只打算接收更新，而不要求他们。</p><p id="daa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进一步考虑这个问题，长轮询也不能满足我们的需求。在长轮询中，在客户机和服务器之间建立HTTP连接。当收到客户端的请求时，服务器不会立即响应。客户端等待服务器的响应，连接保持打开。</p><p id="2281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦服务器将数据发送到客户端，连接就会关闭。这意味着如果客户端想要接收下一批更新，它必须通过发送新的请求来启动新的连接。对于一次性更新(例如，付款的状态)，它工作得很好。但是对于永久更新来说不是很有效。每次建立一个新的连接并处理错误会使双方的事情都变得复杂。</p><p id="8f68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还有其他选择吗？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3fb2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">解决办法</h1><p id="ae4c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">服务器发送事件(SSE)是一种可以帮助我们的技术。根据<a class="ae ky" href="https://en.wikipedia.org/wiki/Server-sent_events" rel="noopener ugc nofollow" target="_blank">维基百科</a>的说法，这并不新鲜，已经被大多数网络浏览器所采用。主要思想是在服务器和客户机之间建立HTTP连接。它将保持打开状态，直到任何一方将其关闭。服务器可以通过开放的连接向客户机推送多个更新。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/157b41493ca757fb48caa48033bf814e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*np3Fs8oh9vttyCZXBfOl4w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">服务器发送的事件架构</p></figure><p id="1d4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们可以看到服务器和客户端之间的通信是如何组织的。在该开放连接中，客户端不向服务器发送任何数据。它只接收从服务器推送的常规事件。</p><h2 id="2508" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">例子</h2><p id="8a1c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们构建一个发送这些事件的简单应用程序。对于不同的平台和语言，已经有许多可用的库。挑一个你觉得最舒服的。下面是Ruby on Rails的一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="32a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">UpdatesController</code>中的<code class="fe no np nq nr b">updates</code>功能是指适当的端点。我们必须指定<code class="fe no np nq nr b">text/event-stream</code>作为内容类型。这将响应区分为SSE。然后，我们定义事件名称和重试策略。最后，我们将当前时间写入流中。</p><p id="6f10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子还可以进一步扩展:如果数据库表发生了变化，或者后端发生了某个事件，我们可以发送一个事件。应用这项技术的想法非常广泛。</p><p id="4d61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们必须在客户端消费事件。我们的客户将是一个网络浏览器。然而，也有适用于iOS和Android等移动平台的解决方案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="03b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们连接到服务器的端点<code class="fe no np nq nr b">/updates</code>，并开始监听同一个<code class="fe no np nq nr b">time_update</code>事件。每次收到消息时，结果将被打印到控制台。就是这样！现在，您有了一个解决方案，可以从服务器获取常规事件，而无需提取它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d6bb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="423d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">服务器发送事件(SSE)对于某些业务案例来说是一个很好的解决方案。当要求永久地将消息推送到客户端时，那么您应该考虑利用它。</p><p id="74ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，就像软件开发世界中的任何技术一样，它不是银弹，也有自己的缺点。首先，SSE是半双工的，客户端不能向服务器发送消息。第二，对打开的连接数有限制。在网络浏览器中打开多个标签时，问题开始出现。因此，我们必须为这种情况构建一个解决方案。</p><p id="d029" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这是在您的应用程序和客户之间交换数据的又一个选择。意识到这一点，并在构建下一个解决方案时牢记在心。</p></div></div>    
</body>
</html>