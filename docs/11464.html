<html>
<head>
<title>Writing Integration Tests for Your Network Layer Using URLProtocol</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用URLProtocol为网络层编写集成测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-integration-tests-for-your-network-layer-using-urlprotocol-1de8d310193a?source=collection_archive---------13-----------------------#2022-03-22">https://betterprogramming.pub/writing-integration-tests-for-your-network-layer-using-urlprotocol-1de8d310193a?source=collection_archive---------13-----------------------#2022-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="de32" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在您的iOS应用中利用集成测试的力量</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/21b3f0204ea488fa2c81a7b717897df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L6GG3YJqbw_sW00q"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@vojtechbruzek?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Vojtech Bruzek </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="58f7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是集成测试？</h1><p id="2e02" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这是当所有模块一起工作时运行测试用例的地方。在现实世界中，没有一个模块可以独立运行。不同模块之间总是有数据流。这就是为什么即使你所有的单元测试用例都通过了，错误还是会发生。因此，除了单元测试之外，集成测试也很重要。</p><h1 id="551e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">为什么要进行集成测试？</h1><p id="0d88" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">大多数应用程序都与某种后端进行通信。具体来说，网络层负责与后端通信，来自该层的数据驱动应用程序。因此，这一层的正常运行非常重要，不仅是独立运行，而且与其他模块一起运行。</p><h1 id="4dc4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">核心思想是什么？</h1><p id="0fb7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">核心思想是完全控制从网络层向上发送的响应(<code class="fe mk ml mm mn b">data</code>)、状态码(<code class="fe mk ml mm mn b">HTTPURLResponse</code>)和错误(<code class="fe mk ml mm mn b">error</code>)。通过控制这些参数，我们可以模拟不同的场景，并检查我们的数据解析逻辑(解码响应)、业务层逻辑(<code class="fe mk ml mm mn b">View </code>模型或表示器)和所有其他模块是否按预期运行。</p><p id="fe81" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我们还可以检查网络层向我们的<code class="fe mk ml mm mn b">URLSession</code>实例发出的网络请求，并检查它们是否符合预期。</p><p id="c329" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated"><strong class="lq ir"> <em class="mt">免责声明</em> </strong> <em class="mt">:为了保持本文代码的简单，我有意避免了最佳实践。</em></p><h1 id="d07c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是URLProtocol？</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7564" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">这里我们使用一个共享的<code class="fe mk ml mm mn b">URLSession </code>实例来进行网络调用。通常，系统负责执行这个网络调用并返回结果。</p><p id="16bf" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">但是系统也给你机会自己执行请求并返回结果。使用<code class="fe mk ml mm mn b">URLProtocol</code>就是这样做的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0e2d" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">让我们开始吧:</p><ol class=""><li id="ed6d" class="mw mx iq lq b lr mo lu mp lx my mb mz mf na mj nb nc nd ne bi translated">创建一个<code class="fe mk ml mm mn b">URLProtocol </code>子类并实现上面给出的强制方法</li><li id="d4e8" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated">在AppDelegate的<code class="fe mk ml mm mn b">application (_:didFinishLaunchingWithOptions:)</code>方法中向系统注册你的<code class="fe mk ml mm mn b">URLProtocol </code>子类。</li><li id="afeb" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated">将URLProtocol子类的类型分配给<code class="fe mk ml mm mn b">URLSession</code>的<code class="fe mk ml mm mn b">protocolClasses </code>属性。不要创建子类的实例，因为这是由系统自动完成的。</li></ol><p id="1ca6" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">现在，每当<code class="fe mk ml mm mn b">URLSession </code>被请求发出网络请求时，它会首先检查<code class="fe mk ml mm mn b">protocolClasses </code>数组中的对象，并通过调用<code class="fe mk ml mm mn b">canInit(with: request) — &gt; Bool</code>询问它们是否要处理请求。通过从子类返回true，我们将有机会处理请求。</p><h1 id="f9bb" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">我们的示例应用程序结构</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="acc5" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我们有一个应用程序，用户可以看到一系列的职位[字符串]。让我们称之为用户提要。我们这里有三个模块:</p><h2 id="78d9" class="nk kx iq bd ky nl nm dn lc nn no dp lg lx np nq li mb nr ns lk mf nt nu lm nv bi translated">1.网路层</h2><p id="1582" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">它使用<code class="fe mk ml mm mn b">URLSession</code>的共享实例发出网络请求，并使用JSONDecoder对响应进行解码。</p><h2 id="d4d8" class="nk kx iq bd ky nl nm dn lc nn no dp lg lx np nq li mb nr ns lk mf nt nu lm nv bi translated">2.视图模型</h2><p id="b8e0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">它支持获取和搜索文章，使用网络层。</p><h2 id="2bc7" class="nk kx iq bd ky nl nm dn lc nn no dp lg lx np nq li mb nr ns lk mf nt nu lm nv bi translated">3.视图控制器</h2><p id="a847" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">它有一个视图模型的实例，并且符合<code class="fe mk ml mm mn b">ViewModelDelegate </code>协议。它调用视图模型的函数，并通过委托回调接收回复。</p><p id="8eca" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我们可以编写单元测试用例来单独验证每个模块的行为，但是如果当它们都开始相互交互时，它们开始意外地行为，那该怎么办呢？这就是为什么我们将编写一些集成测试来验证它们的行为。</p><p id="e2e1" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">在我们开始编写测试之前，让我们完成我们的<code class="fe mk ml mm mn b">URLSessionProxy</code>，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8005" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">不要关闭文章🤣。让我来分析一下到底发生了什么:</p><h2 id="d656" class="nk kx iq bd ky nl nm dn lc nn no dp lg lx np nq li mb nr ns lk mf nt nu lm nv bi translated"><code class="fe mk ml mm mn b">startLoading()</code></h2><p id="1a8e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在我们同意通过在<code class="fe mk ml mm mn b">func canInit(with request: URLRequest) -&gt; Bool</code>中返回true来处理一个URL请求之后，这个方法被系统调用。我们应该开始处理请求，并在完成后通知客户端。</p><h2 id="a8d4" class="nk kx iq bd ky nl nm dn lc nn no dp lg lx np nq li mb nr ns lk mf nt nu lm nv bi translated">请求处理程序</h2><p id="b270" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们将使用这个模型对象为请求设置<code class="fe mk ml mm mn b">response</code>、<code class="fe mk ml mm mn b">data</code>或<code class="fe mk ml mm mn b">error </code>。</p><h2 id="04ac" class="nk kx iq bd ky nl nm dn lc nn no dp lg lx np nq li mb nr ns lk mf nt nu lm nv bi translated">URLSessionProxy的静态属性</h2><p id="a030" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们有一些静态属性可以用来配置我们的类。它们需要是静态的，因为系统负责创建实际的实例，而我们无权访问这个实例。</p><ol class=""><li id="e6bc" class="mw mx iq lq b lr mo lu mp lx my mb mz mf na mj nb nc nd ne bi translated"><code class="fe mk ml mm mn b">contactedURLs: [URL]</code></li></ol><p id="30fa" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">这存储了系统传递的URL列表。这个数组对于检查应用程序访问的URL列表很有用。</p><p id="f09e" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">2.<code class="fe mk ml mm mn b">shouldHandleRequest: ((URLRequest) -&gt; Bool) = { _ in true }</code></p><p id="05e5" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">您可以使用这个闭包来决定是否要处理特定的请求。这是在<code class="fe mk ml mm mn b">func canInit(with request: URLRequest) -&gt; Bool</code>内部调用的。</p><p id="f26e" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">3.<code class="fe mk ml mm mn b">handleRequest: ((URLRequest) -&gt; RequestHandler)</code>？</p><p id="8031" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">这是在<code class="fe mk ml mm mn b">func startLoading()</code>内部调用的。您可以使用这个闭包来决定如何通过返回一个<code class="fe mk ml mm mn b">RequestHandler</code>的实例来响应一个<code class="fe mk ml mm mn b">URLRequest </code>。</p><p id="edde" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我们现在都准备好了！让我们开始编写测试。</p><h1 id="dfcb" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">测试1:在viewDidLoad()上触发了用户馈送API调用</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="37cb" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">期望:<code class="fe mk ml mm mn b">URLSessionProxy</code>的<code class="fe mk ml mm mn b">contactedURLs </code>数组包含用户提要API Url。</p><p id="67cf" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我们配置我们的<code class="fe mk ml mm mn b">URLSessionProxy </code>来返回<code class="fe mk ml mm mn b">RequestHandler </code>实例的一个默认实例，因为我们在这个测试中并不关注那个部分。然后，我们调用<code class="fe mk ml mm mn b">view </code>模型上的<code class="fe mk ml mm mn b">viewDidLoad()</code>来开始这个过程。</p><p id="fcde" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我们一直等到我们的期望实现，然后利用我们的<code class="fe mk ml mm mn b">contactedURL</code>在<code class="fe mk ml mm mn b">URLSessionProxy </code>上的属性来检查我们的应用程序是否如预期的那样联系了用户提要API。</p><h1 id="9447" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">测试2:用户可以在他们的Feed上看到帖子</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="ff6f" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">期望:在调用<code class="fe mk ml mm mn b">viewDidLoad()</code>时，视图模型在其委托上调用<code class="fe mk ml mm mn b">reloadPosts()</code>后包含模拟帖子。</p><p id="0b22" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我们设置了以下内容:</p><ol class=""><li id="c2ad" class="mw mx iq lq b lr mo lu mp lx my mb mz mf na mj nb nc nd ne bi translated">创建一个<code class="fe mk ml mm mn b">view</code>模型委托并实现对委托方法调用的期望，这样我们就知道是时候检查模拟帖子[String]的视图模型了</li><li id="f1c8" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated">配置<code class="fe mk ml mm mn b">URLSessionProxy </code>以返回模拟响应</li><li id="1965" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated">调用视图模型上的<code class="fe mk ml mm mn b"> viewDidLoad()</code>来启动流程</li></ol><p id="4a90" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">当期望实现时，我们检查我们的视图模型是否包含我们的模拟帖子。这个测试将使我们确信网络层和视图模型能够正常地协同工作，向用户显示帖子。</p><h1 id="9c85" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">测试3:搜索帖子对用户来说工作正常</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="6368" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">期望:使用正确的参数调用搜索API</p><p id="d04e" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我们配置我们的<code class="fe mk ml mm mn b">URLSessionProxy </code>来捕获搜索<code class="fe mk ml mm mn b">URLRequest </code>并将其保存到我们的局部变量中。</p><p id="4c3b" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">然后我们调用视图模型上的搜索方法，然后等待直到我们的<code class="fe mk ml mm mn b">URLRequest </code>被捕获。</p><p id="c227" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">然后，我们检查<code class="fe mk ml mm mn b">URLRequest </code>的不同部分，检查是否所有参数都符合预期。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="dd28" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">这只是你能用<code class="fe mk ml mm mn b">URLSessionProxy</code>做的一些皮毛。希望到现在为止，您已经对如何在您的项目中使用这种技术有了一个概念。</p><p id="0c6e" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">已完成的项目在这里<a class="ae kv" href="https://github.com/KarthikShiva97/URLSessionProxy" rel="noopener ugc nofollow" target="_blank">可用。随意探索！还有一个基于这种技术的</a><a class="ae kv" href="https://github.com/WeTransfer/Mocker" rel="noopener ugc nofollow" target="_blank">开源库</a>。</p></div></div>    
</body>
</html>