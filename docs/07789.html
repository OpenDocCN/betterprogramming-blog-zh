<html>
<head>
<title>Stop Lying to React About Missing Dependencies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要撒谎来对缺失的依赖做出反应</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stop-lying-to-react-about-missing-dependencies-10612e9aeeda?source=collection_archive---------0-----------------------#2021-02-19">https://betterprogramming.pub/stop-lying-to-react-about-missing-dependencies-10612e9aeeda?source=collection_archive---------0-----------------------#2021-02-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7010" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解useEffect如何避免lint警告和无限循环</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ac745c884526550ca8913c59f11ce44d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lePWxZCY5e8L0_Tu"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@markfb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马克·弗莱彻-布朗</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="e494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你曾经和<code class="fe lv lw lx ly b">useEffect</code>一起工作过，你可能会遇到下面的lint警告:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f875" class="md me it ly b gy mf mg l mh mi">React Hook useEffect has a missing dependency. Either include it or remove the dependency array.</span></pre><p id="16a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时这很简单，只需添加所需的依赖项，但这通常会导致一些意想不到的行为，让您摸不着头脑。更糟糕的是，你可能会陷入一个无限循环，因为你在关闭API之前拼命地试图关闭浏览器标签…</p><p id="49f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何才能恰当地处理这一警告，而不是忽视它呢？</p><p id="80f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">TL；DR:如果你只是在寻找解决方案，你可以直接跳到标题为“用依赖数组解决问题”的部分</em></p><p id="202f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着React钩子的出现，<code class="fe lv lw lx ly b">useEffect</code>已经被视为一种处理生命周期方法的方式，这些方法以前可以在组件类上访问(例如，<code class="fe lv lw lx ly b">componentDidMount</code>或<code class="fe lv lw lx ly b">componentWillUpdate</code>)。现实稍微微妙一些，需要从面向对象编程向函数式编程转变思维。</p><p id="8ff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank">根据维基百科</a>:</p><blockquote class="mk ml mm"><p id="9be4" class="kz la mj lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated">“纯函数是具有以下性质的函数:</p><p id="4fe1" class="kz la mj lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated">1.对于相同的参数，它的返回值是相同的(本地静态变量、非本地变量、可变引用参数或来自I/O设备的输入流没有变化)。</p><p id="5560" class="kz la mj lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated">2.它的求值没有副作用(没有局部静态变量、非局部变量、可变引用参数或I/O流的突变)。"</p></blockquote><p id="31e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在React的上下文中，一个纯粹的功能组件是一个接受一些道具(参数)并呈现一些内容的组件。可以肯定的是，使用相同的道具来呈现组件将总是输出相同的HTML。该组件没有任何内部状态，也不会与任何外部变量交互或修改任何外部变量。</p><p id="c9b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于表示组件来说很好，但是在现实世界中，有些情况下我们确实需要副作用(例如，从API加载一些数据或者在呈现之间保持一些状态)。这就是React钩子的用武之地。</p><p id="0fb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么<code class="fe lv lw lx ly b">useEffect</code>到底是做什么的呢？嗯，顾名思义，这是一种处理副作用的方式。它接受一个依赖关系数组，如果自上次渲染以来任何依赖关系发生了变化，它将运行您提供的函数。这意味着我们可以只在需要的时候处理从API加载数据之类的事情——而不是每次组件重新呈现的时候。</p><p id="5ec5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">注意:如果你对它如何工作感兴趣，React依赖于组件中钩子的顺序来知道如何处理渲染之间的副作用，这就是为什么你只能在顶层调用钩子。你可以在文档</em>  <em class="mj">中读到更多关于这个</em> <a class="ae ky" href="https://reactjs.org/docs/hooks-rules.html#explanation" rel="noopener ugc nofollow" target="_blank"> <em class="mj">的内容。</em></a></p><p id="5568" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这种依赖数组经常会导致问题。如果我们想在挂载时运行一次效果，可以使用一个空的依赖数组。例如，假设我们想在组件呈现时使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank">axios</a></code>获取一些数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="0d8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是您遇到lint警告的地方:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8d59" class="md me it ly b gy mf mg l mh mi">React Hook useEffect has a missing dependency: 'params'. Either include it or remove the dependency array.</span></pre><p id="e2bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个警告是什么意思？嗯，<code class="fe lv lw lx ly b">useEffect</code>中的代码依赖于<code class="fe lv lw lx ly b">params</code>变量来发出API请求。当组件重新呈现时，<code class="fe lv lw lx ly b">useEffect</code>中的<code class="fe lv lw lx ly b">params</code>的值可能会过期。因为这个效果只运行过一次，所以它在第一次渲染时只有<code class="fe lv lw lx ly b">params</code>的值。</p><p id="4f64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能想知道这是否真的是一个问题，除了会在您的控制台上显示恼人的lint警告。在这种情况下，您的代码将按预期工作，没有任何问题。然而，不包括正确的依赖项有可能引入微妙的错误，这可能是一场噩梦。</p><p id="caba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在他的文章<a class="ae ky" href="https://overreacted.io/a-complete-guide-to-useeffect/#dont-lie-to-react-about-dependencies" rel="noopener ugc nofollow" target="_blank">使用效果</a>的完整指南(非常值得一读)中，丹·阿布拉莫夫使用了一个带有间隔的计数器应用程序的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="0ef5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您只想设置运行一次的时间间隔，但是由于您的效果没有将<code class="fe lv lw lx ly b">count</code>作为其依赖数组的一部分，它将只有默认值(在本例中为<code class="fe lv lw lx ly b">0</code>)。您将看到的是一个<code class="fe lv lw lx ly b">0</code>,它在一秒钟后增加到<code class="fe lv lw lx ly b">1</code>,然后不再改变，因为我们在间隔的每个实例上都将计数设置为<code class="fe lv lw lx ly b">0 + 1</code>。</p><p id="b615" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如阿布拉莫夫所说:</p><blockquote class="ms"><p id="61ba" class="mt mu it bd mv mw mx my mz na nb lu dk translated">“不要撒谎来对依赖做出反应。”</p></blockquote><p id="2b1a" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">因此，<code class="fe lv lw lx ly b">useEffect</code>的第一个常见问题是，您只想在挂载时运行一次，但是遇到了lint警告。不过，还有另一个问题，我们可以用我们的例子来说明。</p><p id="5e1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以尝试通过将<code class="fe lv lw lx ly b">params</code>添加到<code class="fe lv lw lx ly b">useEffect</code>的依赖数组来解决lint警告:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e257" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论上，这应该行得通。<code class="fe lv lw lx ly b">params</code>不会改变，所以它应该只在坐骑上运行<code class="fe lv lw lx ly b">useEffect</code>一次。然而，如果<code class="fe lv lw lx ly b">params</code>是一个对象，你会发现<code class="fe lv lw lx ly b">useEffect</code>会在每次组件重新渲染时运行——即使<code class="fe lv lw lx ly b">params</code>是相同的。</p><p id="b5bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为JavaScript不处理对象相等性:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="7032" class="md me it ly b gy mf mg l mh mi">{ some: 'value' } === { some: 'value' } = false</span></pre><p id="1b72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe lv lw lx ly b">useEffect</code>检查是否有任何依赖关系发生变化时，<code class="fe lv lw lx ly b">params</code>将永远不会等于它以前的值，因此效果内部的代码将会运行。</p><p id="beb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能会导致我们的代码陷入一些非常糟糕的无限循环中。那么如何才能解决这两个问题呢？</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="7dd5" class="no me it bd np nq nr ns nt nu nv nw nx jz ny ka nz kc oa kd ob kf oc kg od oe bi translated">解决依赖数组的问题</h1><p id="41c9" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">和往常一样，当你遇到这样的问题时，第一件要做的事就是后退一步，看看你是否把自己逼入了困境。如果你花点时间重构你所做的事情，通常会有简单的解决方案。例如，您真的应该在组件中进行API调用，还是应该将代码解耦并将数据作为道具传递下去？</p><p id="dd82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">花一些时间离开，获得一些观点，这意味着你可以经常完全避免这样的问题。</p><p id="e85a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你已经做到了这一点，除了使用<code class="fe lv lw lx ly b">useEffect</code>别无选择，那么是时候使用<code class="fe lv lw lx ly b">useRef</code>了。</p><h2 id="0ae0" class="md me it bd np ok ol dn nt om on dp nx li oo op nz lm oq or ob lq os ot od ou bi translated">拯救的参考文献</h2><p id="134d" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">React的<code class="fe lv lw lx ly b">useRef</code>钩子给了我们一种在渲染之间存储可变值的方法。从<a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank">反应文件</a>中:</p><blockquote class="mk ml mm"><p id="0cf4" class="kz la mj lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated">"<code class="fe lv lw lx ly b">useRef</code>返回一个可变ref对象，其<code class="fe lv lw lx ly b">.current</code>属性被初始化为传递的参数(<code class="fe lv lw lx ly b">initialValue</code>)。返回的对象将在组件的整个生存期内保持不变。</p></blockquote><p id="7338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用一个引用来跟踪一些代码是否已经运行。如果没有，那么运行它。如果有，那就跳过它。在我们的示例中，这看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="dcdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">useEffect</code>中，我们检查<code class="fe lv lw lx ly b">hasFetchedData.current</code>是否是<code class="fe lv lw lx ly b">false</code>。如果是，那么我们点击API并将ref更新为<code class="fe lv lw lx ly b">true</code>。这意味着下一次组件渲染时，<code class="fe lv lw lx ly b">hasFetchedData.current</code>将会是<code class="fe lv lw lx ly b">true</code>，我们将不会进行API调用。<code class="fe lv lw lx ly b">useEffect</code>仍然会在每次渲染时运行，但是API调用只会运行一次。</p><p id="3b14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，我们有一个“门”我们应该只在满足某些条件时运行<code class="fe lv lw lx ly b">useEffect</code>中的代码。</p><h2 id="ceb1" class="md me it bd np ok ol dn nt om on dp nx li oo op nz lm oq or ob lq os ot od ou bi translated">处理非原语</h2><p id="39f8" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">如上所述，依赖数组中的非原语(即对象或数组)将导致<code class="fe lv lw lx ly b">useEffect</code>在每次渲染时运行，因为JavaScript无法确定对象是否相等。为了解决这个问题，当<code class="fe lv lw lx ly b">useEffect</code>运行时，我们需要在新旧值之间进行某种形式的深度比较。</p><p id="b0a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们需要保存一个对依赖关系先前值的引用，这样我们就可以在<code class="fe lv lw lx ly b">useEffect</code>运行时将其与新值进行比较，并检查它是否发生了变化。再次，裁判来拯救。我们可以使用<code class="fe lv lw lx ly b">useRef</code>来存储之前的值，如果值已经改变，就在<code class="fe lv lw lx ly b">useEffect</code>中更新它(我们可以使用某种深度比较函数来检查)。</p><p id="6a6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想做类似于上面例子的事情，但是我们想在每次<code class="fe lv lw lx ly b">params</code>值改变时获取数据。仅仅在依赖数组中传递<code class="fe lv lw lx ly b">params</code>将意味着<code class="fe lv lw lx ly b">useEffect</code>在每次重新渲染时运行，这不是我们想要的。相反，我们可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="d22e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">注意:在这个例子中，我们使用的是</em> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.npmjs.com/package/fast-deep-equal" rel="noopener ugc nofollow" target="_blank"><em class="mj">fast-deep-equal</em></a></code> <em class="mj">，但是任何深度比较函数都可以。</em></p><p id="c064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来分解一下:</p><ol class=""><li id="afe4" class="ov ow it lb b lc ld lf lg li ox lm oy lq oz lu pa pb pc pd bi translated">首先，我们设置一个ref来跟踪先前的<code class="fe lv lw lx ly b">params</code>值。</li><li id="d792" class="ov ow it lb b lc pe lf pf li pg lm ph lq pi lu pa pb pc pd bi translated">在<code class="fe lv lw lx ly b">useEffect</code>中，我们对<code class="fe lv lw lx ly b">prevParams.current</code>和<code class="fe lv lw lx ly b">params</code>进行了深入的比较，只有当它们不相等时才进行API调用。</li><li id="a4a1" class="ov ow it lb b lc pe lf pf li pg lm ph lq pi lu pa pb pc pd bi translated">最后，我们将我们的<code class="fe lv lw lx ly b">prevParams.current</code>引用更新为新的<code class="fe lv lw lx ly b">params</code>值。</li></ol><p id="52c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着API调用将只在<code class="fe lv lw lx ly b">params</code>改变时运行。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="8dc7" class="no me it bd np nq nr ns nt nu nv nw nx jz ny ka nz kc oa kd ob kf oc kg od oe bi translated">结论</h1><p id="2699" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">与<code class="fe lv lw lx ly b">useEffect</code>一起工作是突显出钩子对于React来说有多大的范式转变的事情之一。它真的迫使你去思考到底发生了什么，当它减慢了实现一个简单功能的过程时，这通常会令人沮丧。再次引用<a class="ae ky" href="https://overreacted.io/a-complete-guide-to-useeffect/" rel="noopener ugc nofollow" target="_blank">阿布拉莫夫的文章</a>谈到用钩子开始:</p><blockquote class="ms"><p id="0dd9" class="mt mu it bd mv mw mx my mz na nb lu dk translated">“不会有太多要学的。事实上，我们会花大部分时间去忘却。”</p></blockquote><p id="56f2" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">然而，一旦你真正开始“用钩子思考”，你就会收获好处。花时间真正理解发生了什么意味着你最终会写出更干净、更有性能的代码。</p><p id="242e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些lint规则的存在是有原因的，所以我们都应该尽最大努力遵守它们——不要再对依赖关系撒谎了。</p></div></div>    
</body>
</html>