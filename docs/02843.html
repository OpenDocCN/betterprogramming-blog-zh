<html>
<head>
<title>Let Users Know When You Have Updated Your Service Workers in Create React App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当您在Create React应用程序中更新服务人员时，请通知用户</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/let-users-know-when-you-have-updated-your-service-worker-in-create-react-app-b0c2701995b3?source=collection_archive---------0-----------------------#2020-01-04">https://betterprogramming.pub/let-users-know-when-you-have-updated-your-service-worker-in-create-react-app-b0c2701995b3?source=collection_archive---------0-----------------------#2020-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="afbb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当您推送新的服务人员时，显示一个警告组件，允许用户立即更新他们的页面</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/3b4129e5217999c7f99822ff9f89e31c.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*o-uGfk9X59ZU1mloaqxnfA.png"/></div></figure><p id="8bf7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Create React App (CRA)非常适合开发渐进式web应用程序(pwa)。它具有内置的离线/缓存优先行为。默认情况下未启用，但您可以选择加入。它使用服务人员，有很多陷阱，你可以从官方文件中读到。</p><p id="1fcd" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这篇文章将向您展示当您更新您的服务人员时，如何触发警报(或toast或任何您想要的组件)。通常，这将是当你的应用程序有一些新的更新，你想让用户马上看到它们。</p><p id="cbab" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这篇文章假设你有一个和CRA合作的新项目。如果您不知道，您可以通过以下方式轻松做到:</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="f77e" class="lp lq iq ll b gy lr ls l lt lu">npx create-react-app my-app</span></pre></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="8c98" class="mc lq iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">注册服务人员</h1><p id="c877" class="pw-post-body-paragraph kn ko iq kp b kq mt jr ks kt mu ju kv kw mv ky kz la mw lc ld le mx lg lh li ij bi translated">如果您导航到<code class="fe my mz na ll b">src/index.js</code>，您会在最后一行发现:</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="1ef5" class="lp lq iq ll b gy lr ls l lt lu">serviceWorker.unregister();</span></pre><p id="4250" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">切换到:</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="cb68" class="lp lq iq ll b gy lr ls l lt lu">serviceWorker.register();</span></pre><p id="e4ae" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">注册一个服务人员也差不多完成了。如果您将应用部署到支持HTTPS的站点，它将被缓存。</p><p id="ce38" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">请记住，CRA的服务工人实现只在生产中有效。你可以从Chrome DevTools的网络标签中勾选离线复选框，然后重新加载你的页面，以确保它能正常工作。</p><p id="87eb" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">还显示你的app！</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="cb39" class="mc lq iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">您更新的服务人员是否不可见？</h1><p id="40e6" class="pw-post-body-paragraph kn ko iq kp b kq mt jr ks kt mu ju kv kw mv ky kz la mw lc ld le mx lg lh li ij bi translated">现在是更难的部分。您在应用中添加或更改代码并进行部署，但用户看不到您的更新。正如文件所述:</p><blockquote class="nb nc nd"><p id="8014" class="kn ko ne kp b kq kr jr ks kt ku ju kv nf kx ky kz ng lb lc ld nh lf lg lh li ij bi translated">默认行为是保守地将更新后的服务工作者保持在“<a class="ae lj" href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting" rel="noopener ugc nofollow" target="_blank">等待</a>状态。这意味着用户将会看到旧的内容，直到他们关闭(重新加载是不够的)他们现有的，打开的标签。”</p></blockquote><p id="c29c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果您想让用户看到您的新更新，而不必关闭所有选项卡，该怎么办？CRA也在提供这种选择。</p><p id="9c51" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在<code class="fe my mz na ll b">src/serviceWorker.js</code>中有一个名为<code class="fe my mz na ll b">registerValidSW</code>的函数，它通过回调提供对服务工作者更新和成功事件的访问，并且还将关于这些事件的信息打印到控制台。这就是你如何知道什么时候显示应用程序被缓存以供离线使用，或者有更新的版本可用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5db0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe my mz na ll b">registerValidSW</code>函数接受两个参数——第二个参数是我们感兴趣的。<code class="fe my mz na ll b">config</code>可以是一个有<code class="fe my mz na ll b">onSuccess</code>和<code class="fe my mz na ll b">onUpdate</code>回调的对象。你现在应该想知道我们如何以及在哪里制造这样一个物体？</p><p id="0b89" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果你查看调用<code class="fe my mz na ll b">registerValidSW</code>的地方，你会发现它来自<code class="fe my mz na ll b">export function register(config)</code>。这与我们在<code class="fe my mz na ll b">src/index.js</code>的最后一行看到的功能完全相同。现在，我们回到了自己的代码中，我们可以这样做:</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="660f" class="lp lq iq ll b gy lr ls l lt lu">serviceWorker.register({<br/>  onSuccess: () =&gt; store.dispatch({ type: SW_INIT }),<br/>  onUpdate: reg =&gt; store.dispatch({ type: SW_UPDATE, payload: reg }),<br/>});</span></pre><p id="5842" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当这些函数被调用时，它们会分派一个函数，你可以对它们做任何你想做的事情，比如显示一条消息。</p><p id="70e8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有了<code class="fe my mz na ll b">onSuccess</code>，就更容易了——你可以在页面的某个地方显示警告。也许它说，“页面已保存供脱机使用。”使用<code class="fe my mz na ll b">onUpdate</code>，你想让用户知道有一个更新的版本可用，你可以添加一个按钮“点击获取最新版本”</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="845b" class="mc lq iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">当页面首次保存以供脱机使用时显示用户警告</h1><p id="7f9b" class="pw-post-body-paragraph kn ko iq kp b kq mt jr ks kt mu ju kv kw mv ky kz la mw lc ld le mx lg lh li ij bi translated">在上面的例子中，我使用Redux store来调度一个动作，并且我用以下内容设置了store:</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="cf2d" class="lp lq iq ll b gy lr ls l lt lu">const initalState = {<br/>  serviceWorkerInitialized: false,<br/>  serviceWorkerUpdated: false,<br/>  serviceWorkerRegistration: null,<br/>}</span></pre><p id="b390" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，当分派<code class="fe my mz na ll b">SW_INIT</code>类型的动作时，我们将<code class="fe my mz na ll b">serviceWorkerInitialized</code>状态更改为<code class="fe my mz na ll b">true</code>，并且可以在任何React组件中使用这个选择器。</p><p id="ab66" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我的<code class="fe my mz na ll b">src/App.js</code>(或任何其他组件)中，我们通过Redux挂钩从商店获得它:</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="3750" class="lp lq iq ll b gy lr ls l lt lu">const isServiceWorkerInitialized = useSelector(<br/>  state =&gt; state.serviceWorkerInitialized<br/>);</span></pre><p id="4f2c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们可以在<code class="fe my mz na ll b">true</code>的时候显示警告:</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="8fb5" class="lp lq iq ll b gy lr ls l lt lu">{isServiceWorkerInitialized &amp;&amp; (<br/>  &lt;Alert <em class="ne">text</em>="Page has been saved for offline use" /&gt;<br/>)}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/35cc3b0aab4bafcfb3647360be874f6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*dQ-oTIRtgnbd8PQ84cXJVA.png"/></div><p class="nl nm gj gh gi nn no bd b be z dk translated">安装服务人员时发出警报</p></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="15d2" class="mc lq iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">当新版本的服务人员可用时，向用户显示警告和按钮</h1><p id="d933" class="pw-post-body-paragraph kn ko iq kp b kq mt jr ks kt mu ju kv kw mv ky kz la mw lc ld le mx lg lh li ij bi translated">使用相同的模式，当服务人员被更新时，我们显示警报组件。</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="d2a9" class="lp lq iq ll b gy lr ls l lt lu">{isServiceWorkerUpdated &amp;&amp; (<br/>  &lt;Alert<br/>    <em class="ne">text</em>="There is a new version available."<br/>    buttonText="Update"<br/>    <em class="ne">onClick</em>={updateServiceWorker}<br/>  /&gt;<br/>)}</span></pre><p id="c07f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这一次我们添加了一个<code class="fe my mz na ll b">onClick</code>函数，当单击alert组件中的<code class="fe my mz na ll b">“Update”</code>按钮时将会触发该函数。因为我们希望用户点击一个按钮，就可以得到一个新版本的应用程序。</p><p id="db61" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">所有的魔力都在我们将要创建的<code class="fe my mz na ll b">updateServiceWorker</code>函数中。</p><p id="d9bb" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这个例子使用的是CRA v3，它在<code class="fe my mz na ll b">public/service-worker.js</code>文件中生成了一点附加内容。(如果你使用的是旧版本的CRA，我也为你创建了一个解决方案——请写信给我。)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ca16" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe my mz na ll b">skipWaiting</code>是一个强制你的新服务工作者成为主动者的功能，下次用户打开浏览器来到你的页面，不用做任何事就能看到新版本。</p><p id="4fa6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">你可以从<a class="ae lj" href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/skipWaiting" rel="noopener ugc nofollow" target="_blank"> MDN </a>阅读更多关于<code class="fe my mz na ll b">skipWaiting</code>的内容。但这只是迫使您的服务人员成为主动服务人员，您只能在下一次看到变化。我们想确保用户现在有一个新版本。这就是为什么我们必须调用它，然后自己刷新页面——但只能在新的服务人员激活之后。</p><p id="fc02" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了调用它，我们需要一个新服务工作者的实例。如果您返回到我们注册服务工作者的地方，您可以看到<code class="fe my mz na ll b">onUpdate</code>函数有一个名为<code class="fe my mz na ll b">reg</code>的参数。那是注册对象，那是我们的实例。这将被发送到Redux商店的<code class="fe my mz na ll b">serviceWorkerRegistration</code>物业，我们可以从<code class="fe my mz na ll b">serviceWorkerRegistration.waiting</code>那里得到我们的等待软件。</p><p id="06b7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这将是我们的函数，当用户按下警报中的<code class="fe my mz na ll b">“Update”</code>按钮时调用:</p><pre class="kg kh ki kj gt lk ll lm ln aw lo bi"><span id="bc9c" class="lp lq iq ll b gy lr ls l lt lu">const updateServiceWorker = () =&gt; {<br/>  const registrationWaiting = serviceWorkerRegistration.waiting;</span><span id="8078" class="lp lq iq ll b gy np ls l lt lu">  if (registrationWaiting) {<br/>    registrationWaiting.postMessage({ type: 'SKIP_WAITING' });</span><span id="15f3" class="lp lq iq ll b gy np ls l lt lu">    registrationWaiting.addEventListener('statechange', e =&gt; {<br/>      if (e.target.state === 'activated') {<br/>        window.location.reload();<br/>      }<br/>    });<br/>  }<br/>};</span></pre><p id="c195" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因为服务工作者是一个工作者，因此在另一个线程中，要向另一个线程发送任何消息，我们必须使用<code class="fe my mz na ll b">Worker.postMessage</code> ( <a class="ae lj" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage" rel="noopener ugc nofollow" target="_blank"> MDN </a>)。消息类型是<code class="fe my mz na ll b">'SKIP_WAITING'</code>，正如我们从生成的<code class="fe my mz na ll b">public/service-worker.js</code>文件中看到的。</p><p id="d6ab" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们创建一个eventListener来等待我们新的服务工作状态的改变，当它被激活时，我们自己重新加载页面。差不多就是这样。</p><p id="9304" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，用户可以看到有一个更新的版本可用，如果他们想，他们可以立即更新它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/9afa53b4dcaf8ee175de1f27a3895aee.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*4k3sIy_o9fICXdJug4wFtA.png"/></div><p class="nl nm gj gh gi nn no bd b be z dk translated">有新的服务人员时发出警报</p></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="91f3" class="mc lq iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">结论</h1><p id="6c14" class="pw-post-body-paragraph kn ko iq kp b kq mt jr ks kt mu ju kv kw mv ky kz la mw lc ld le mx lg lh li ij bi translated">我认为让用户决定他们是否想要一个新版本是很好的。他们可以选择点击<code class="fe my mz na ll b">“Update”</code>按钮获得新版本，或者忽略它。然后，当他们关闭标签并再次打开您的应用程序时，新版本的应用程序将可用。</p><p id="72bf" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">谢了。</p><p id="cb13" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这里有一个到<a class="ae lj" href="https://github.com/gglukmann/cra-sw" rel="noopener ugc nofollow" target="_blank">范例库</a>的链接。</p></div></div>    
</body>
</html>