<html>
<head>
<title>Use Strings as Array Efficiently in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中有效地使用字符串作为数组</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-strings-as-array-without-memory-leak-in-javascript-efff16992b02?source=collection_archive---------13-----------------------#2020-03-11">https://betterprogramming.pub/use-strings-as-array-without-memory-leak-in-javascript-efff16992b02?source=collection_archive---------13-----------------------#2020-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7dd9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用不寻常的方式解决日常任务</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4a500162c1e7ea9341edc8775144d590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NYPSi-A3MFURlFG3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@yer_a_wizard?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗勒</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="e0d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有没有试过从不同的角度看JavaScript中的一个字符串？你知道我们可以把它转换成一个数组，但是它实际上可以表现得像一个真正的数组。</p><p id="e518" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你好，世界！今天我想和你分享一些很酷的东西，可能会对你的工作有所帮助，或者至少在面试中展示你的知识。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7613" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">日常任务</h1><p id="13a8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们的例子很简单，但是它将帮助你改变关于这个主题的范式。</p><p id="d149" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，当你必须把一个单词中的每个字母分开，然后再把它放回去时，你可能会面临一个问题。通常，我们使用<code class="fe mz na nb nc b">split</code>将一个字符串转换成一个数组<strong class="lb iu"> </strong>，然后再用<strong class="lb iu"> </strong> <code class="fe mz na nb nc b">join</code>将它恢复到初始状态，但是使用了所需的分隔符:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a301" class="nh md it nc b gy ni nj l nk nl">const str = 'Hello';<br/>str.split('').join('-'); // 'H-e-l-l-o'</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="30f7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">字符串作为数组</h1><p id="cdf9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如David Flanagan在他的书<em class="nm"> JavaScript:权威指南</em>中所说，JavaScript中的字符串模仿数组。我们很容易证明这一点。不使用<code class="fe mz na nb nc b">charAt</code>方法，我们可以用方括号的用法得到所需的字母。是的，这看起来不像是一个令人信服的论点，但至少是这样的:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b1cd" class="nh md it nc b gy ni nj l nk nl">const str = 'Hello';<br/>str.charAt(1); // 'e'<br/>str[1];        // 'e'</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b056" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">它是如何工作的</h1><p id="06f8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先你需要提醒自己一个函数方法:<code class="fe mz na nb nc b">bind</code>。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="efef" class="nh md it nc b gy ni nj l nk nl">functionName.bind(this, args);</span></pre><p id="2f21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">bind</code>返回一个带有变异<code class="fe mz na nb nc b">this</code>的函数。我相信这是很清楚的，特别是如果你已经使用了React和类组件，并且根本没有使用箭头函数。</p><p id="05c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来的方法是<code class="fe mz na nb nc b">call</code>。它做的事情和<code class="fe mz na nb nc b">bind</code>几乎一样，但是它没有返回一个新的函数。相反，它立即用一个变异的<code class="fe mz na nb nc b">this</code>调用它。</p><p id="e3f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是一个类的静态方法。<code class="fe mz na nb nc b">Array Class</code>可以为我们提供<code class="fe mz na nb nc b">join</code>作为静态方法。这意味着我们可以避免<code class="fe mz na nb nc b">Array Class</code> <strong class="lb iu"> </strong>的任何实例来获得<strong class="lb iu"> </strong> <code class="fe mz na nb nc b">join</code> <strong class="lb iu">的功能。</strong></p><p id="b61e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，你可能会觉得解决方案近在咫尺。我们可以用变异的上下文调用静态方法<code class="fe mz na nb nc b">Array</code>，在我们的例子中，上下文将是我们的字符串。与常规的<code class="fe mz na nb nc b"> join</code>一样，我们可以传递一个分隔符<code class="fe mz na nb nc b">'-'</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="7d15" class="nh md it nc b gy ni nj l nk nl">const str = 'Hello';</span><span id="85ba" class="nh md it nc b gy nn nj l nk nl">Array.prototype.join.call(str, '-'); // 'H-e-l-l-o'</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6084" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">这是干什么用的？</h1><p id="9f18" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个问题问得好。</p><p id="a461" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，标题的“高效”部分来了。我决定挑战我的想法，即调用<code class="fe mz na nb nc b">prototype</code>不会像传统的<code class="fe mz na nb nc b">split.join</code>那样使用那么多内存。</p><p id="d343" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有三种情况:<code class="fe mz na nb nc b">split.join</code>、<code class="fe mz na nb nc b">Array.prototype.join</code>和<code class="fe mz na nb nc b">for-loop</code>(只是为了得到可靠的结果)。</p><p id="13ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始之前，请注意以下几点:</p><ul class=""><li id="ce92" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">每个案例都用长度为4，000，000的字符串进行了测试。</li><li id="57c8" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">每个箱子有10个循环。</li><li id="4b36" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">测试在苹果MacBook Air 2018上运行。</li></ul><p id="8066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一种情况是常规的<code class="fe mz na nb nc b">split.join</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/e968ba7916ef691d9846d9e3e8a3908e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*gYzi9QPuMFqMmZ3H-527pg.gif"/></div></figure><ul class=""><li id="54e4" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">平均速度:247.6675毫秒</li><li id="755e" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">平均内存使用量:244.191 Mb</li></ul><p id="b8e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个——<code class="fe mz na nb nc b">Array.prototype</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/aeac84730031240a94f29f7139595d35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*CJSC5Lbnd0J9l4b8NViQ2Q.gif"/></div></figure><ul class=""><li id="8567" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">平均速度:399.5979毫秒</li><li id="587c" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">平均内存使用量:223.265 Mb</li></ul><p id="3ebb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个——<code class="fe mz na nb nc b">for-loop</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/4a301562fa8a6e66235ca49703b32358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*cCLYWBU8LcIX9pg-0ehuTg.gif"/></div></figure><ul class=""><li id="5e51" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">平均速度:1186.4507毫秒</li><li id="bebf" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">平均内存使用量:281.996 Mb</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5423" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="e034" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们能从这些测试中得到什么？因此，从内存使用的角度来看，<code class="fe mz na nb nc b">for-loop</code>是最慢的(和往常一样)也是最复杂的。<code class="fe mz na nb nc b">split.join</code>被证明是最快的方法，但是不出所料，它比<code class="fe mz na nb nc b">Array.prototype.join</code>占用更多的内存。<strong class="lb iu"> </strong>很明显是因为最后一个不用创建数组存储在内存中。同时，<code class="fe mz na nb nc b">Array.prototype.join</code>并没有那么快，因为它仍然需要处理上下文，这也需要一些时间。</p><p id="9cf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你认为10次测试不足以做出决定，你可以用你的源代码自己测试。别忘了在下面分享你的结果。</p><p id="5877" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:本文不是关于用<code class="fe mz na nb nc b">'-'</code>拆分长字符串。我只是想强调您可以使用JavaScript的不同部分以不同寻常的方式解决日常任务的方法。</p></div></div>    
</body>
</html>