<html>
<head>
<title>How To Create a Custom useInfiniteScroll() With React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建带有React挂钩的自定义useInfiniteScroll()</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-custom-useinfinitescroll-with-react-hooks-248f4531384c?source=collection_archive---------3-----------------------#2019-12-03">https://betterprogramming.pub/how-to-create-a-custom-useinfinitescroll-with-react-hooks-248f4531384c?source=collection_archive---------3-----------------------#2019-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7009" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">无限滚动应该更容易</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c68884515f84a6e0c98b401780e54573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iTqWVkF_n5MiMEESLNOR9g.png"/></div></div></figure><p id="c458" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的一篇文章中，我解释了如何创建定制的<code class="fe lq lr ls lt b">useModal()</code> React挂钩，这些挂钩可以被挂钩到模态组件中。</p><p id="7e16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我将解释如何创建可用于无限滚动组件的<code class="fe lq lr ls lt b">useScrollInfinite()</code> React钩子。无限滚动是一种现代的分页方式，你不必跳到下一页就能看到更多的内容。</p><p id="bf55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它会自动检测您是否在页面末尾，并使用Ajax和其他异步数据获取技术加载更多内容。</p><p id="aa95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无限滚动极大地提升了现代应用程序的性能，因为在页面加载时只显示一点数据，然后在向下滚动页面时获取更多数据，这使得应用程序速度更快。</p><p id="5aa2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无限滚动通常非常适合处理文本、图像、视频、状态更新、提要和表格数据等列表。</p><p id="e373" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本教程中，我将使用一个名为<a class="ae lu" href="http://medrum.herokuapp.com" rel="noopener ugc nofollow" target="_blank"> Medrum </a>的REST API来获取随机文章。它从网上抓取文章，然后把它们分解成数据。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="359d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建一个列表(文章)组件</h1><p id="ae2b" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">首先要做的是构建一个简单的列表组件。您可以使用<a class="ae lu" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank">创建React应用</a>来设置React应用。</p><p id="2999" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本教程中，我将使用<a class="ae lu" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>作为HTTP客户端库。您可以按如下方式安装它:</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="444e" class="nd md it lt b gy ne nf l ng nh">yarn add axios</span></pre><p id="748c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要进一步了解如何在React中发送HTTP请求，请观看下面的视频:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d381" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们看看下面的简单组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nj l"/></div></figure><p id="0ed1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是我们在上面所做的:</p><ol class=""><li id="85ce" class="nl nm it kw b kx ky la lb ld nn lh no ll np lp nq nr ns nt bi translated">增加了一个<code class="fe lq lr ls lt b">useState</code>来存储和设置我们的数据。</li><li id="5c8c" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated">增加了一个<code class="fe lq lr ls lt b">useEffect</code>，只在组件挂载时加载我们的数据。</li><li id="dcd0" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated">检查数据是否准备好。</li><li id="df52" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated">然后，在物品列表中绘制地图，并将其显示在<code class="fe lq lr ls lt b">&lt;li&gt;</code>中。</li></ol><p id="aabf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/5a5608566b8a5c33ef568681fe605ebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jwRamrWruX76U7awXFKWHg.png"/></div></div></figure><p id="952c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你向下滚动，它不会加载更多的数据，因为它还不能检测到任何底部，这是我们教程的下一阶段。让我们看看怎样才能实现它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6297" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">通过探测底部加载更多数据</h1><p id="c120" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">现在，让我们看看如何通过检测何时滚动到主体或特定容器的底部来加载更多的数据。</p><p id="a370" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有很多方法可以做到这一点，这取决于您的用例以及您的DOM是什么样子的。</p><p id="5b8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，最常见的方法是检查窗口<code class="fe lq lr ls lt b">window</code>对象的内部高度加上文档<code class="fe lq lr ls lt b">window</code>对象的<code class="fe lq lr ls lt b">scrollTop</code>是否等于文档的<code class="fe lq lr ls lt b">offsetHeight</code>。</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="70e3" class="nd md it lt b gy ne nf l ng nh"><em class="oa"><br/>window.</em>addEventListener("scroll", ()=&gt;{<br/>  if(window.innerHeight + document.documentElement.scrollTop!==document.documentElement.offsetHeight){<br/>  return;<br/>}<br/>else {<br/>  console.log("scrolling down");<br/>}<br/>})</span></pre><p id="12ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用上面的代码，我们将能够知道用户何时滚动到页面底部。</p><p id="00b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，可以在我们的<code class="fe lq lr ls lt b">useEffect</code>生命周期挂钩中使用它，如下所示:</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="9576" class="nd md it lt b gy ne nf l ng nh">function isScrolling(){<br/>if(window.innerHeight + document.documentElement.scrollTop!==document.documentElement.offsetHeight){<br/>  return;<br/>}<br/>else {<br/>  console.log("scrolling down");<br/>}}</span><span id="b782" class="nd md it lt b gy ob nf l ng nh">useEffect(()=&gt;{<br/>window.addEventListener("scroll", isScrolling);<br/>return () =&gt; window.removeEventListener("scroll", isScrolling);}, [])</span></pre><p id="5775" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码中，我们注册了我们的<code class="fe lq lr ls lt b">isScrolling</code>函数来监听事件<code class="fe lq lr ls lt b">scroll</code>。所以现在，每当用户滚动时，就会调用<code class="fe lq lr ls lt b">isScrolling</code>。</p><p id="2aa8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们将在用户向下滚动时获取数据，所以我们需要知道数据何时完成获取，因此我们有如下内容:</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="bb99" class="nd md it lt b gy ne nf l ng nh">const [isFetching, setIsFetching] = useState(false);</span><span id="4717" class="nd md it lt b gy ob nf l ng nh">function isScrolling(){<br/>if(window.innerHeight + document.documentElement.scrollTop!==document.documentElement.offsetHeight){<br/>  return;<br/>}<br/>else {<br/>  setIsFetching(true)<br/>}}</span><span id="a299" class="nd md it lt b gy ob nf l ng nh">useEffect(() =&gt; {<br/>    if (isFetching){<br/>       console.log("Fetch data")<br/>    }<br/>  }, [isFetching]);</span></pre><p id="a87d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们需要从我前面提到的文章API中获取数据，我们将使用<code class="fe lq lr ls lt b">axios</code>:</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="b6ff" class="nd md it lt b gy ne nf l ng nh">const [page, setPage] = useState(1);</span><span id="4a71" class="nd md it lt b gy ob nf l ng nh">const fetchData = () =&gt;{<br/>let url = "https://medrum.herokuapp.com/articles";<br/>axios.get(url).then(res =&gt; {<br/>setData(res.data);<br/>});<br/>}</span><span id="5407" class="nd md it lt b gy ob nf l ng nh">const moreData = () =&gt; {<br/>let url = `https://medrum.herokuapp.com/feeds/?source=5718e53e7a84fb1901e05971&amp;page=${page}&amp;sort=popular`;<br/>axios.get(url).then(res =&gt; {<br/>setData([...data, ...res.data]);<br/>setPage(page+1)<br/>setIsFetching(false)<br/>});<br/>}</span></pre><p id="b5f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在上面做了什么:</p><ol class=""><li id="eaf2" class="nl nm it kw b kx ky la lb ld nn lh no ll np lp nq nr ns nt bi translated">我们添加了一个名为<code class="fe lq lr ls lt b">page</code>的<code class="fe lq lr ls lt b">useState</code>——它将递增并用作文章API的分页。</li><li id="8c42" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated">我们创建了两个函数:<code class="fe lq lr ls lt b">loadData</code> <strong class="kw iu"> </strong>和<code class="fe lq lr ls lt b">moreData</code>。</li><li id="8db8" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated"><code class="fe lq lr ls lt b">loadData</code>第一次加载页面时加载数据，被触发一次。</li><li id="d817" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated"><code class="fe lq lr ls lt b">moreData</code>获取更多数据，当用户向下滚动到底部时被触发。</li><li id="15e8" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated">在<code class="fe lq lr ls lt b">moreData</code>中，我们增加页面状态值，并将<code class="fe lq lr ls lt b">isFetching</code>设置为<code class="fe lq lr ls lt b">false</code>，以表示数据已经完成加载。</li></ol><p id="963b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，将所有这些放在一起，我们可以编写如下的<code class="fe lq lr ls lt b">List</code>组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nj l"/></div></figure><p id="feaf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们添加了两个<code class="fe lq lr ls lt b">useEffect</code>——第一个在浏览器加载时加载我们的数据，并将我们的<code class="fe lq lr ls lt b">isScrolling</code>回调绑定到事件监听器，而第二个监听<code class="fe lq lr ls lt b">isFetching</code> <code class="fe lq lr ls lt b">useState</code>，然后在<code class="fe lq lr ls lt b">true</code>时获取更多数据。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2cd3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建自定义React挂钩</h1><p id="74f5" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">我们已经看到了当用户向下滚动到页面底部时，如何加载更多的数据，并且一切似乎都运行良好。</p><p id="434c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我们只在我们的文章组件中实现了它，而不是一个可以被另一个组件重用的自定义React挂钩。</p><p id="4224" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看如何在自定义的React挂钩中实现这一点。</p><p id="6a8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在你的<code class="fe lq lr ls lt b">src</code>目录下创建一个新的<code class="fe lq lr ls lt b">useInfinite.js</code>文件，让我们添加一个自定义的React钩子函数，如下所示:</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="ce91" class="nd md it lt b gy ne nf l ng nh">const useInfiniteScroll = callback =&gt; {<br/>  const [isFetching, setIsFetching] = useState(false);<br/>  useEffect(() =&gt; {<br/>     <em class="oa">if</em> (!isFetching) <em class="oa">return</em>;<br/>     callback();<br/>  }, [isFetching]);<br/>  <em class="oa">return</em> [isFetching, setIsFetching];<br/>};<br/>export default useInfiniteScroll;</span></pre><p id="c69a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的<code class="fe lq lr ls lt b">useInfiniteScroll</code>定制钩子中，我们:</p><ol class=""><li id="1352" class="nl nm it kw b kx ky la lb ld nn lh no ll np lp nq nr ns nt bi translated">增加了一个参数<code class="fe lq lr ls lt b">callback</code>,当用户向下滚动时就会被触发。</li><li id="6665" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated">增加<code class="fe lq lr ls lt b">isFetching</code> <code class="fe lq lr ls lt b">useState</code>表示数据加载与否。</li><li id="4c02" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated">添加了一个<code class="fe lq lr ls lt b">useEffect</code>生命周期，当<code class="fe lq lr ls lt b">isFetching</code>状态改变并且值等于<code class="fe lq lr ls lt b">true</code>时调用我们的回调。</li><li id="7910" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated">然后，我们导出<code class="fe lq lr ls lt b">isFetching</code>和<code class="fe lq lr ls lt b">setIsFetching</code>，这样它就可以在功能组件中被访问。</li></ol><p id="2e94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来的事情是将我们的<code class="fe lq lr ls lt b">isScrolling</code>函数注册到<code class="fe lq lr ls lt b">scroll </code>事件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nj l"/></div></figure><p id="ceb5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在上面做了什么:</p><ol class=""><li id="cbf2" class="nl nm it kw b kx ky la lb ld nn lh no ll np lp nq nr ns nt bi translated">添加了一个新的<code class="fe lq lr ls lt b">useEffect</code>生命周期——它将<code class="fe lq lr ls lt b">isScrolling</code>函数绑定到滚动事件。</li><li id="242c" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated">我们添加了我们的<code class="fe lq lr ls lt b">isScrolling</code>函数。</li></ol><p id="3901" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就这样，我们定制的React挂钩就做好了。让我们看看如何用我们的文章组件实现它。转到文章组件，按如下方式重构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nj l"/></div></figure><p id="6b2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面，我们做了一些修改:</p><ol class=""><li id="17cd" class="nl nm it kw b kx ky la lb ld nn lh no ll np lp nq nr ns nt bi translated">我们导入了新创建的<code class="fe lq lr ls lt b">useInfinite</code>钩子。</li><li id="5f6f" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated">我们初始化了<code class="fe lq lr ls lt b">useInfiniteScroll</code>定制钩子，并传递给它一个当用户向下滚动时触发的函数。</li><li id="007e" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated">我们现在只有一个<code class="fe lq lr ls lt b">useEffect</code>生命周期，加载一次数据。</li><li id="3d08" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated">我们从函数表达式到函数声明重构了我们的<code class="fe lq lr ls lt b">moreData</code>函数。</li></ol><p id="6a86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">仅此而已。最后，我们现在可以对任何组件使用自定义的React钩子，以便在用户向下滚动时加载数据。</p><p id="f271" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在GitHub repo中找到完整的代码:</p><div class="oc od gp gr oe of"><a href="https://github.com/CITGuru/react-useinfinitescroll" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">cit guru/react-use infinite scroll</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">这个项目是用Create React App引导的。在项目目录中，您可以运行:在…中运行应用程序</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ks of"/></div></div></a></div><p id="e22e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要看现场演示，你可以在这里查看:<a class="ae lu" href="https://react-useinfinitescroll.now.sh/" rel="noopener ugc nofollow" target="_blank">https://react-useinfinitescroll.now.sh/</a></p></div></div>    
</body>
</html>