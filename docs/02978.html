<html>
<head>
<title>TypeScript Advanced Types: Type Guards</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript高级类型:类型保护</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typescript-advanced-types-type-guards-1018572a5d2f?source=collection_archive---------7-----------------------#2020-01-13">https://betterprogramming.pub/typescript-advanced-types-type-guards-1018572a5d2f?source=collection_archive---------7-----------------------#2020-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ad01" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">检查对象数据类型的各种方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3f89afee6498831700b57ad74f529b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_VKO7ClmsPr3GrEE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">琳达·芬金在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b222" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript具有许多高级类型功能，这使得编写动态类型代码变得容易。它还有助于采用现有的JavaScript代码，因为它允许我们在使用TypeScript的类型检查功能的同时保留JavaScript的动态功能。</p><p id="5378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript中有多种高级类型，如交集类型、联合类型、类型保护、可空类型和类型别名等等。在这篇文章中，我们将看看类型警卫。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bdb0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">防护类型</h1><p id="b028" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了检查一个对象是否属于某种类型，我们可以创建自己的类型守卫来检查我们期望出现的成员以及值的数据类型。为此，我们可以使用一些特定于TypeScript的操作符以及JavaScript操作符。</p><p id="4a80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查类型的一种方法是使用<code class="fe mz na nb nc b">as</code>操作符显式转换一个具有类型的对象。这是访问未在构成联合类型的所有类型中指定的属性所必需的。</p><p id="5777" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么TypeScript编译器不会让我们访问<code class="fe mz na nb nc b">person</code>对象的<code class="fe mz na nb nc b">name</code>属性，因为它只在<code class="fe mz na nb nc b">Person</code>类型中可用，而在<code class="fe mz na nb nc b">Employee</code>类型中不可用。因此，我们将得到以下错误:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="eaf4" class="nj md it nc b gy nk nl l nm nn">Property 'name' does not exist on type 'Person | Employee'.</span><span id="638c" class="nj md it nc b gy no nl l nm nn">Property 'name' does not exist on type 'Employee'.(2339)</span></pre><p id="d447" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们必须使用TypeScript中可用的类型断言操作符将类型转换为<code class="fe mz na nb nc b">Person</code>对象，这样我们就可以访问<code class="fe mz na nb nc b">name</code>属性，我们知道该属性存在于<code class="fe mz na nb nc b">person</code>对象中。</p><p id="2e54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们使用了<code class="fe mz na nb nc b">as</code>操作符，正如我们在下面的代码中所做的那样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mz na nb nc b">as</code>操作符，我们显式地告诉TypeScript编译器<code class="fe mz na nb nc b">person</code>属于<code class="fe mz na nb nc b">Person</code>类，这样我们就可以访问<code class="fe mz na nb nc b">Person</code>接口中的<code class="fe mz na nb nc b">name</code>属性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8b26" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">类型谓词</h1><p id="73c8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了检查对象的结构，我们可以使用类型谓词。类型谓词是一段代码，我们在其中检查给定的属性名是否有与之关联的值。</p><p id="bd6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以编写一个新函数<code class="fe mz na nb nc b">isPerson</code>来检查一个对象是否具有<code class="fe mz na nb nc b">Person</code>类型的属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="bea7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，<code class="fe mz na nb nc b">isPerson</code>返回一个<code class="fe mz na nb nc b">person is Person</code>类型，这是我们的类型谓词。</p><p id="6a94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们像在上面的代码中那样使用该函数，那么如果一个联合类型由两个类型组成，TypeScript编译器将自动缩小该类型的范围。</p><p id="32f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mz na nb nc b">if (isPerson(person)){ ... }</code>块中，我们可以访问<code class="fe mz na nb nc b">Person</code>接口的任何成员。</p><p id="2b61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果有两个以上的类型组成union类型，这就不起作用了。例如，如果我们有以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2dda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，TypeScript编译器将拒绝编译代码，我们将得到以下错误消息:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="e3b1" class="nj md it nc b gy nk nl l nm nn">Property 'employeeCode' does not exist on type 'Animal | Employee'.</span><span id="bb6a" class="nj md it nc b gy no nl l nm nn">Property 'employeeCode' does not exist on type 'Animal'.(2339)</span></pre><p id="c3d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为它不知道<code class="fe mz na nb nc b">else</code>子句的类型，因为它可以是<code class="fe mz na nb nc b">Animal</code>或<code class="fe mz na nb nc b">Employee</code>。为了解决这个问题，我们可以添加另一个<code class="fe mz na nb nc b">if</code>块来检查<code class="fe mz na nb nc b">Employee</code>类型，就像我们在下面的代码中做的那样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/e7aad765b48291cc2bcf003787fedda6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SLYw7Fu91Pl0xCTR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@desmondlau?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">摄影师</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4f04" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">In运算符</h1><p id="5bc3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">另一种检查结构以确定数据类型的方法是使用<code class="fe mz na nb nc b">in</code>操作符。这就像JavaScript <code class="fe mz na nb nc b">in</code>操作符，我们可以用它来检查一个属性是否存在于一个对象中。</p><p id="ca46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，要检查一个对象是否是一个<code class="fe mz na nb nc b">Person</code>对象，我们可以编写以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mz na nb nc b">getIdentifier</code>函数中，我们像在普通JavaScript代码中一样使用了<code class="fe mz na nb nc b">in</code>操作符。如果我们检查某个成员的名称，该名称对于某个类型来说是唯一的，那么TypeScript编译器将会推断出<code class="fe mz na nb nc b">if</code>块中<code class="fe mz na nb nc b">person</code>对象的类型，正如我们上面所做的那样。</p><p id="d419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然<code class="fe mz na nb nc b">name</code>是一个只存在于<code class="fe mz na nb nc b">Person</code>接口中的属性，那么TypeScript编译器足够聪明，知道里面的任何东西都是一个<code class="fe mz na nb nc b">Person</code>对象。</p><p id="d269" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，因为<code class="fe mz na nb nc b">employeeCode</code>只是<code class="fe mz na nb nc b">Employee</code>接口的成员，那么它知道里面的<code class="fe mz na nb nc b">person</code>对象是<code class="fe mz na nb nc b">Employee</code>类型的。</p><p id="0ad3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果两种类型都被消除了，那么TypeScript编译器知道它是<code class="fe mz na nb nc b">Animal</code>，因为其他两种类型都被<code class="fe mz na nb nc b">if</code>语句消除了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b7f5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">防护类型</h1><p id="7f10" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了确定具有由基本类型组成的联合类型的对象的类型，我们可以使用<code class="fe mz na nb nc b">typeof</code>操作符。</p><p id="f16c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有一个联合类型为<code class="fe mz na nb nc b">number | string | boolean</code>的变量，那么我们可以编写以下代码来确定它是数字、字符串还是布尔值。例如，如果我们写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d471" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以像在第一个<code class="fe mz na nb nc b">if</code>块中一样调用number方法，因为我们使用了<code class="fe mz na nb nc b">isNumber</code>函数来帮助TypeScript编译器确定<code class="fe mz na nb nc b">x</code>是否是一个数字。</p><p id="8ffd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，这也适用于第二个<code class="fe mz na nb nc b">if</code>块中的<code class="fe mz na nb nc b">isString</code>函数的字符串检查。</p><p id="8182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个变量既不是数字也不是字符串，那么它被确定为布尔值，因为我们有一个数字、字符串和布尔值类型的并集。</p><p id="5c28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">typeof</code>型防护罩可以用以下方式编写:</p><ul class=""><li id="ce0b" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe mz na nb nc b">typeof v === "typename"</code></li><li id="12c6" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe mz na nb nc b">typeof v !== "typename"</code></li></ul><p id="1a15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<code class="fe mz na nb nc b">“typename”</code>可以是<code class="fe mz na nb nc b">"number"</code>、<code class="fe mz na nb nc b">"string"</code>、<code class="fe mz na nb nc b">"boolean"</code>或<code class="fe mz na nb nc b">"symbol"</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bcc8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">防护类型的实例</h1><p id="5315" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">instanceof</code>类型保护可用于确定实例类型的类型。</p><p id="cf47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于确定一个对象属于哪个子类型很有用，给定父类型派生的子类型。例如，我们可以在下面的代码中使用<code class="fe mz na nb nc b">instanceof</code>类型的保护:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3e99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们有一个返回<code class="fe mz na nb nc b">Cat</code>或<code class="fe mz na nb nc b">Dog</code>对象的<code class="fe mz na nb nc b">getRandomAnimal</code>函数，所以它的返回类型是<code class="fe mz na nb nc b">Cat | Dog</code>。<code class="fe mz na nb nc b">Cat</code>和<code class="fe mz na nb nc b">Dog</code>都实现了<code class="fe mz na nb nc b">Animal</code>接口。</p><p id="0f42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">instanceof</code>类型守护通过对象的构造函数来确定对象的类型，由于<code class="fe mz na nb nc b">Cat</code>和<code class="fe mz na nb nc b">Dog</code>构造函数的签名不同，所以可以通过比较构造函数的签名来确定类型。</p><p id="5b2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果两个类有相同的签名，<code class="fe mz na nb nc b">instanceof</code>类型保护也将有助于确定正确的类型。在<code class="fe mz na nb nc b">if (animal instanceof Cat) { ... }</code>块中，我们可以访问<code class="fe mz na nb nc b">Cat</code>实例的<code class="fe mz na nb nc b">age</code>成员。</p><p id="0040" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，在<code class="fe mz na nb nc b"> if (animal instanceof Dog) {...}</code>块中，我们可以访问<code class="fe mz na nb nc b">Dog</code>实例独有的成员。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c73d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="6881" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通过各种类型保护和类型谓词，TypeScript编译器可以使用条件语句缩小类型范围。</p><p id="852e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型谓词由关键字<code class="fe mz na nb nc b">is</code>表示，就像<code class="fe mz na nb nc b">pet is Cat</code>一样，其中<code class="fe mz na nb nc b">pet</code>是变量而<code class="fe mz na nb nc b">Cat</code>是类型。我们还可以使用<code class="fe mz na nb nc b">typeof</code>类型保护来检查原始类型，使用<code class="fe mz na nb nc b">instanceof</code>类型保护来检查实例类型。</p><p id="06b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们让<code class="fe mz na nb nc b">in</code>操作符检查一个属性是否存在于一个对象中，这反过来通过属性的存在来确定对象的类型。</p></div></div>    
</body>
</html>