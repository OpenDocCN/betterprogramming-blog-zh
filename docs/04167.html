<html>
<head>
<title>The Usefulness of Python’s Permutations and Combinations Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python的排列和组合函数的有用性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-usefulness-of-pythons-permutations-and-combinations-functions-316245534a16?source=collection_archive---------3-----------------------#2020-03-27">https://betterprogramming.pub/the-usefulness-of-pythons-permutations-and-combinations-functions-316245534a16?source=collection_archive---------3-----------------------#2020-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d4fc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如果你使用了大量的嵌套循环，这是值得一读的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/22757020974ed14c87de16d7d7181cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4cfvUucnVWgKlgIRI3kLtQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Patrick Fore 在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="509e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近写了很多Python。作为一个相对较新的语言，它的多功能性和“生活质量”特性继续给我留下深刻印象。对于最近它在开发者中获得如此多的欢迎，我并不感到惊讶。</p><p id="0ec9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近发现的两个这样的特性是Python的<a class="ae kv" href="https://docs.python.org/library/itertools.html" rel="noopener ugc nofollow" target="_blank"> itertools </a>模块的<code class="fe ls lt lu lv b">permutations</code>和<code class="fe ls lt lu lv b">combinations</code>函数。该模块基本上是一组方便的函数，用来产生迭代器以满足各种需求。</p><p id="aa3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我只打算把重点放在<code class="fe ls lt lu lv b">permutations</code>和<code class="fe ls lt lu lv b">combinations</code>上，因为我发现它们最有用也最容易理解。如果你发现自己做了很多循环——尤其是嵌套循环——它们值得一试。这些函数在数据科学、神经网络、竞争编程和日常编码中有广泛的应用。基本上，无论在哪里使用循环，这些函数都可以让您的生活变得更加轻松。让我们开始吧！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="e158" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">排列</h1><p id="4576" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">像所有好名字一样，这个名字描述了函数的功能。它产生给定项目列表的所有排列(排列方式)，如数字或字符。让我们来看看<a class="ae kv" href="https://docs.python.org/library/itertools.html#itertools.permutations" rel="noopener ugc nofollow" target="_blank">的定义</a>:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="2f7d" class="ne me iq lv b gy nf ng l nh ni">def permutations(iterable, r=None):<br/># permutations('ABCD', 2) --&gt; AB AC AD BA BC BD CA CB CD DA DB DC<br/># permutations(range(3)) --&gt; 012 021 102 120 201 210</span></pre><p id="d6f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个项目在排列中只使用一次，顺序很重要。给定[0，1]，它的排列是[0，1]和[1，0]。让我们看一个代码示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2a8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到，我们得到了数字1、2和3的所有可能的排列，代码很少。</p><p id="5ef1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:如果需要的话，可以通过调用<code class="fe ls lt lu lv b">list(your_tuple)</code>很容易地将元组转换成列表。</p><p id="765e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可选的<code class="fe ls lt lu lv b">r</code>参数可用于指定排列的长度(否则，它使用给定的项目数)。使用与上面相同的例子，但是将<code class="fe ls lt lu lv b">r</code>设置为2:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6764" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们得到了数字1、2和3所有可能的2长度排列。您也可以对字符串使用这个函数(以及我们将讨论的其他函数):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="00a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这有许多有用的应用(例如，生成点之间的路由或操作顺序)。如果我们处理A，然后B，然后C，结果会是什么？那A呢，然后C，然后B呢？</p><p id="3abf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们看看下一个函数。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="8798" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">组合</h1><p id="6319" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">这个函数产生了组合一组给定项目的所有方法。<a class="ae kv" href="https://docs.python.org/library/itertools.html#itertools.combinations" rel="noopener ugc nofollow" target="_blank">定义</a>:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="7c40" class="ne me iq lv b gy nf ng l nh ni">def combinations(iterable, r):<br/># combinations('ABCD', 2) --&gt; AB AC AD BC BD CD<br/># combinations(range(4), 3) --&gt; 012 013 023 123</span></pre><p id="802e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这与<code class="fe ls lt lu lv b">permutations</code>类似，但每个项目只能使用一次(即它与顺序无关)。给定[0，1]，唯一的组合将是[0，1]，因为[1，0]是0和1的组合的置换。<code class="fe ls lt lu lv b">r</code>参数在这里也是强制的(否则，项目列表的组合就是列表本身)。</p><p id="ae67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你很难区分这两者，可以这样想:“面包和奶酪”和“奶酪和面包”是[面包，奶酪]的排列。然而，这两种食物只有一种组合——面包和奶酪(排名不分先后)。</p><p id="3614" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">演示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6df7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你想处理某样东西的所有组合，而顺序并不重要时，这是很棒的。例如，在图论中，这是一种快速计算无向图中给定顶点之间的边(或缺少边)的方法。对于有向图，你可以使用<code class="fe ls lt lu lv b">permutations</code>(如上)。</p><p id="4c85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数还有一个变体值得一试。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="9379" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">奖励:可替换的组合</h1><p id="d8cb" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">尽管它的名字很长(现在我们的ide都有自动完成功能)，<code class="fe ls lt lu lv b">combinations_with_replacement</code>可能特别有用。首先，它的<a class="ae kv" href="https://docs.python.org/library/itertools.html#itertools.combinations_with_replacement" rel="noopener ugc nofollow" target="_blank">定义</a>:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="2536" class="ne me iq lv b gy nf ng l nh ni">def combinations_with_replacement(iterable, r):<br/># combinations_with_replacement('ABC', 2) --&gt; AA AB AC BB BC CC</span></pre><p id="d734" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<code class="fe ls lt lu lv b">combinations</code>基本相同，但项目可以重复。看看它是如何工作的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3372" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来看看我们可以用这个函数做的一些很酷的事情:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1bc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就对了:一行程序可以让您轻松地迭代3D网格中的每个x、y和z坐标——可以根据需要适应其他场景。没有嵌套循环。</p><p id="116d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:你也可以用<a class="ae kv" href="https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="noopener ugc nofollow" target="_blank">列表理解</a>来做这件事，但是我发现这种方法可读性较差。</p><p id="4314" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这对于处理矩阵、网格系统和笛卡尔平面非常有用。这也是一个简单的嵌套循环替换。神经网络怎么样？生成一些初始权重或测试数据，以投入到您的网络中。可能性是无限的！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="b050" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">itertools模块的其余部分</h1><p id="b2c7" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">从<a class="ae kv" href="https://docs.python.org/library/itertools.html" rel="noopener ugc nofollow" target="_blank">文档</a>中:</p><blockquote class="nl nm nn"><p id="9294" class="kw kx no ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">这个模块实现了许多迭代器构建块，灵感来自APL、Haskell和SML的构造。每一个都被改写成适合Python的形式。</p><p id="56ba" class="kw kx no ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">该模块标准化了一组快速、内存高效的核心工具，这些工具可以单独使用，也可以组合使用。它们一起形成了一个“迭代器代数”,使得用纯Python简洁高效地构造专用工具成为可能。"</p></blockquote><p id="9a99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那里有很多魔法可以探索。如果您发现自己想要以某种模式迭代数据，请考虑这个模块，看看是否有这样的函数。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="11d5" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">概述</h1><p id="7e3c" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">扔掉那些嵌套循环！让Python为您做这些工作，并根据您的需要进行迭代，所有这些都用一个可读的一行程序完成。通过使用这些函数，很容易从一个集合中获取每个排列或组合(有或没有重复的术语)。你的代码会因此变得更干净。</p><p id="faf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">迭代愉快！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="d7de" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">参考</h1><ul class=""><li id="eebc" class="ns nt iq ky b kz mv lc mw lf nu lj nv ln nw lr nx ny nz oa bi translated">排列:<a class="ae kv" href="https://docs.python.org/library/itertools.html#itertools.permutations" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/library/ITER tools . html # ITER tools . permutations</a></li><li id="0b25" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated">组合:<a class="ae kv" href="https://docs.python.org/library/itertools.html#itertools.combinations" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/library/ITER tools . html # ITER tools . combinations</a></li><li id="95d7" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated">带替换的组合:<a class="ae kv" href="https://docs.python.org/library/itertools.html#itertools.combinations_with_replacement" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/library/ITER tools . html # ITER tools . combinations _ with _ replacement</a></li><li id="9f07" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated">itertools模块:<br/><a class="ae kv" href="https://docs.python.org/library/itertools.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/library/itertools.html</a></li></ul></div></div>    
</body>
</html>