<html>
<head>
<title>Every Python Programmer Should Know LRU_cache From the Standard Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个Python程序员都应该知道标准库中的LRU缓存</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/every-python-programmer-should-know-lru-cache-from-the-standard-library-8e6c20c6bc49?source=collection_archive---------2-----------------------#2020-02-24">https://betterprogramming.pub/every-python-programmer-should-know-lru-cache-from-the-standard-library-8e6c20c6bc49?source=collection_archive---------2-----------------------#2020-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1577" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过使用简单的缓存功能，只需一行代码就可以加快函数的速度</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/333623a7edef8a6a244cea715f4626b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3SULZdUvC9pOBMzrArZfNQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1853340" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/Pexels-2286921/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1853340" rel="noopener ugc nofollow" target="_blank">像素</a>的图像</p></figure><p id="e16f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不久前，我构建了一个每天运行的ETL管道，从外部服务提取数据来丰富我的输入数据，然后将结果加载到数据库中。</p><p id="7502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着输入数据的增长，我的ETL过程变得越来越慢，因为等待外部服务的响应非常耗时。经过一番调查，我意识到与总记录数(~500k)相比，我没有那么多不同的输入值(~500)。</p><p id="05c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，换句话说，我用相同的参数调用外部服务大约每条记录1000次。</p><p id="a567" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样的情况是使用缓存的主要用例。缓存函数意味着每当我们第一次计算函数的返回值时，我们将输入和结果放入一个字典中。</p><p id="2d6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个后续的函数调用，我们首先通过查看缓存来检查结果是否已经被计算过。如果我们在那里找到它，完美，不需要计算！如果没有，我们计算结果并将输入和结果存储在缓存中，以便下一个函数调用可以查找它。</p><p id="b164" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python标准库附带了许多鲜为人知但功能强大的包。对于我们手头的例子，我们将使用来自<a class="ae ky" href="https://docs.python.org/3/library/functools.html" rel="noopener ugc nofollow" target="_blank"> functools </a>的<code class="fe lv lw lx ly b">lru_cache</code>。(LRU代表最近最少使用，确切地说，缓存将通过首先丢弃最近最少/最早的条目来保留最近的输入/结果对)</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ff7d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">从Fun(c)工具导入lru_cache</h1><p id="8d52" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">括号中的<code class="fe lv lw lx ly b">c</code>有点像爸爸开的玩笑，因为这样一来<code class="fe lv lw lx ly b">functools</code>就变成了<code class="fe lv lw lx ly b">fun tools</code>，使用缓存肯定很有趣！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/025d6dc695d62a585c4adcde37adf759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EHcR3gEJx0Q3RLefJPTb5A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/FBosler/7f5597b6e308762048d252f53ef8e4fe" rel="noopener ugc nofollow" target="_blank">链接</a></p></figure><p id="858f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里没有多少魔法。我们导入<code class="fe lv lw lx ly b">lru_cache</code>并修饰一个函数，用它生成<a class="ae ky" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">斐波那契数列</a>。</p><p id="d0e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修饰一个函数意味着我们用缓存函数包装它，无论何时我们随后调用<code class="fe lv lw lx ly b">fib_cache</code>函数，我们都在调用缓存的函数。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e22f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">比赛开始了</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/3a2dfcf4b9d1e996b2fea906455c3ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-tDQcp5EF4ZXBZrhf1iguw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/FBosler/7f5597b6e308762048d252f53ef8e4fe" rel="noopener ugc nofollow" target="_blank">链接</a></p></figure><p id="a7b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们运行了一个实验，我们计算了从0到40的所有斐波纳契数在缓存和未缓存版本的函数中的计算时间，并将结果放入各自的列表中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c6bf" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">获胜者是</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/275ac66462da53bc11e8d109e65b5efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r3w6_Fxnbs8xHiiUK_YrOA.png"/></div></div></figure><p id="af35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于较低的斐波那契数，这没有太大的区别，但是一旦我们达到大约30个样本，缓存函数的效率增益就开始增加。</p><p id="23ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我没有耐心让非缓存版本运行超过40个样本，因为它需要的时间呈指数增长，而对于缓存版本，它只是线性增长。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/7a4b5984a3320473b73c2f29501957d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4BqOp7CptEzslSFdY_44mQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/FBosler/7f5597b6e308762048d252f53ef8e4fe" rel="noopener ugc nofollow" target="_blank">链接</a></p></figure><p id="dffb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有它！您离Python中的缓存只有一步之遥。这并不可怕。</p><p id="9eee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于如何加速你的代码，看看这篇关于如何并行化你的代码的文章。</p><div class="nh ni gp gr nj nk"><a href="https://medium.com/better-programming/every-python-programmer-should-know-the-not-so-secret-threadpool-642ec47f2000" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">每个Python程序员都应该知道并不秘密的线程池</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">使用多线程技术，只需几行代码就可以将I/O代码的速度提高几个数量级</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">medium.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ks nk"/></div></div></a></div></div></div>    
</body>
</html>