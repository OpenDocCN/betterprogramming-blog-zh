<html>
<head>
<title>Reference Architecture for GitLab Runners in AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS中GitLab运行程序的参考架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/reference-architecture-for-gitlab-runners-in-aws-829c45f857ed?source=collection_archive---------14-----------------------#2020-04-22">https://betterprogramming.pub/reference-architecture-for-gitlab-runners-in-aws-829c45f857ed?source=collection_archive---------14-----------------------#2020-04-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a1f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">建立一个经济高效的自动化GitLab Runner设置</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4aba6447b7f08bf825b22f15dbc9be2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KdYQhgCJiktxUUiB8KdIEg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@hishahadat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">沙哈达特·拉赫曼</a>在<a class="ae ky" href="https://unsplash.com/s/photos/software?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="2ccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我希望分享一个在自动缩放环境中运行AWS中的<a class="ae ky" href="https://about.gitlab.com/" rel="noopener ugc nofollow" target="_blank">git lab</a>runner的参考架构。下面的内容假设您对<a class="ae ky" href="https://www.terraform.io" rel="noopener ugc nofollow" target="_blank"> Terraform </a>、<a class="ae ky" href="https://www.packer.io" rel="noopener ugc nofollow" target="_blank"> Packer </a>、AWS EC2和GitLab CI有所了解，但是如果您不知道其中的一些内容，那么这个想法应该还是很容易理解和实现的。</p><p id="1ce1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到本文结束时，您将能够构建一个经济高效的自动化Gitlab Runner设置，它可以根据需求进行伸缩，还可以在预定义的时间间隔关闭整个堆栈以节省成本。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c00c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置Amazon机器映像</h1><p id="14e8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这种情况下，最小的可部署单元是Amazon机器映像(AMI)，AWS中的EC2机器需要启动它。</p><p id="6331" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了从小处着手，可以使用<code class="fe mz na nb nc b">cloud-init</code>脚本来安装GiLlab Runner，设置Runner配置，并在机器启动时安装管道作业所需的附加用户域组件。然而，随着依赖性的增加，最初的预热时间可能会受到影响，并导致跑步者在机器准备就绪后的一段时间内不可用。</p><p id="ab7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了节省时间，我们可以用Packer这样的外部工具来自动化AMI配置部分。Packer进一步支持各种构建器——帮助配置管理的供应器。对于这个用例，我们可以简单地使用<code class="fe mz na nb nc b">shell</code> provisioner/builder。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/998f9f278d32dd2aa71911cc0884e6c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QX73fiZmSucZ5ahm1mpJ9w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带封隔器的定制AMI</p></figure><p id="2845" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Packer需要一个JSON模板来定义创建定制AMI映像的整个周期。在这种情况下，我们可以使用类似于:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">packer-build . JSP</p></figure><pre class="kj kk kl km gt ng nc nh ni aw nj bi"><span id="327e" class="nk md it nc b gy nl nm l nn no">$ packer build packer-build.json</span></pre><p id="0ca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的命令，然后引导一个临时EC2实例，用一个配置脚本(在本例中是<code class="fe mz na nb nc b">./provision.sh</code>)对其进行配置，接着将EBS卷保存为一个新的AMI，并销毁临时资源(如EC2实例、安全组、SSH密钥等)。).为了避免连接问题，不要试图在公共子网中启动这个临时EC2实例，这一点很重要。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="af2c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">安装和配置GitLab转轮</h1><p id="64ee" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了在这些EC2机器上成功运行GitLab运行程序和后续的管道作业，我们需要一些基本的二进制依赖、环境设置、配置等。</p><p id="8d28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了保持事情的可重复性，我们可以在一个shell脚本中定义所有的步骤，然后由<code class="fe mz na nb nc b">Packer</code>用来准备我们的定制GitLab Runner AMI，<code class="fe mz na nb nc b">provision.sh</code>。它将获得下面的命令列表来安装、配置和准备运行程序——以及它们将注册的存储库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7e9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上脚本中值得讨论的部分是<code class="fe mz na nb nc b">SystemD</code>单元文件中的触发器<code class="fe mz na nb nc b">ExecStart</code>、<code class="fe mz na nb nc b">ExecStartPost</code>、<code class="fe mz na nb nc b">ExecStop</code>。</p><p id="ce67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些作为机器事件的钩子，我们用它来启动、注册和取消注册GitLab组/项目的运行者。这很重要，因为稍后我们将添加在下班时间关闭整个运行器集群的功能(通过使用自动缩放组中的调度)，并且实例需要从GitLab中删除运行器绑定(否则，它们将留下陈旧的关联)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/29372930cf45c192ecd1d71278ecaa3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4yjPPb7BFpAJdWwpj1xtgg.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="245e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">具有Terraform的计算基础架构</h1><p id="0f09" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">既然定制的AMI已经准备好从管道中启动和执行GitLab作业，那么是时候用启动配置和使用Terraform的自动缩放组来包装我们到目前为止创建的对象了。</p><p id="a717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们可以将启动配置定义为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">启动Packer创建的GitLab AMI的配置</p></figure><p id="bd0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图中的<code class="fe mz na nb nc b">image_id</code>是指Packer生成的AMI。</p><p id="88c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以定义基于启动配置的自动扩展组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">地形结构</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b0d3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">成本优化</h1><p id="3f38" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你可能不需要跑步者一直在跑。为了节省一些钱，可以在预定义的时间关闭集群。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自动缩放计划的地形配置</p></figure><p id="4f4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，跑步者将在工作日晚上7:30停止跑步(并在周末继续下降)，然后在周一早上6:30再次开始跑步</p><p id="5011" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，体系结构/工作流的完整概述如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/fa7a109341f1a4bd1c30ed16e1fee34e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s3GVbzMQNvXCWSdzZle7pw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">完成工作流程</p></figure><p id="8d01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这能为您提供一个思路和参考架构，以进一步扩展您的特定用例/需求。</p><p id="ef96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进一步的改进可以基于由CPU使用等负载需求驱动的自动伸缩功能。</p><p id="1121" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文到此为止。下次见，<em class="nr"> tschüss！</em></p></div></div>    
</body>
</html>