<html>
<head>
<title>Type-Safe TypeScript With Type Narrowing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有类型收缩的类型安全类型脚本</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/type-safe-typescript-with-type-narrowing-649450d708df?source=collection_archive---------5-----------------------#2022-11-08">https://betterprogramming.pub/type-safe-typescript-with-type-narrowing-649450d708df?source=collection_archive---------5-----------------------#2022-11-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d16f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">提高项目类型安全性的常用模式指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e1febcfce7a2d31ec1edb4cd09c6ffd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HcOK1EjSHdbzsqjmCwZmiQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://pixabay.com/illustrations/cubes-choice-one-yellow-light-2492010/" rel="noopener ugc nofollow" target="_blank">https://pix abay . com/illustrations/cubes-choice-one-yellow-light-2492010/</a></p></figure><p id="0fe7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文展示了最大化TypeScript的类型安全代码潜力的常见模式。这些技术属于同一类，我们称之为类型收缩。</p><p id="5db5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">源代码可在<a class="ae kv" href="https://github.com/rainerhahnekamp/type-safe-typescript-with-type-narrowing" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。本文的视频版本可从以下网址获得:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="bd1e" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">介绍</h1><p id="608c" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">每当我们处理多种类型的变量时，比如一个<code class="fe mr ms mt mu b">unknown</code>或一个联合类型，我们可以应用类型缩小来将其“缩小”到一个特定的类型。我们与TypeScript编译器一起工作，因为它理解我们代码的上下文，并保证这种缩小以完全类型安全的方式发生。</p><p id="0222" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有一个参数类型为<code class="fe mr ms mt mu b">Date | undefined</code>的函数。每次函数执行时，变量的类型可以是<code class="fe mr ms mt mu b">Date</code>或<code class="fe mr ms mt mu b">undefined</code>，但不能同时是两种类型。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="02a0" class="mz lv iq mu b gy na nb l nc nd">function print(value: Date | undefined): void {}</span></pre><p id="084d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们应用一个<code class="fe mr ms mt mu b">if</code>条件，检查那个变量是否不是<code class="fe mr ms mt mu b">undefined</code>，TypeScript理解它的意思，只把条件中的值当作一个<code class="fe mr ms mt mu b">string</code>。这是类型收缩。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="76e6" class="mz lv iq mu b gy na nb l nc nd">function print(input: Date | undefined): void {<br/>  if (input !== undefined) {<br/>    input.getTime(); // 👍 value is only Date<br/>  }</span><span id="2206" class="mz lv iq mu b gy ne nb l nc nd">  input.getTime(); // 💣 fails, value can be Date or undefined<br/>}</span></pre><p id="ee2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有一种非常类似的技术，叫做类型断言。乍一看，这似乎是更容易的选择。然而，就类型安全而言，它并不安全。我们手动设置类型，因此覆盖了编译器。</p><p id="9672" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果编译器可以和我们说话，它会说类似这样的话:“好吧，你知道你在那里做什么，但是如果出了问题，不要怪我。”</p><p id="365f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们应该避免类型断言，而总是支持类型收缩。(一般来说，试图比编译器聪明从来都不是一个好主意。)</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="93b7" class="mz lv iq mu b gy na nb l nc nd">function print(input: Date | undefined): void {<br/>  (input as Date).getTime(); // type assertion - don't!<br/>}</span></pre><p id="da31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个简短的介绍之后，让我们设计一个主要类型收缩技术的例子。</p><p id="eccc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将是我们的“工作台”:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="b9de" class="mz lv iq mu b gy na nb l nc nd">declare function diffInYears(input: Date): number;<br/>declare function parse(input: string): Date;</span><span id="f6cc" class="mz lv iq mu b gy ne nb l nc nd">function calcAge(input: Date | null | undefined): number {<br/>  return diffInYears(input); // will not work<br/>}</span></pre><p id="c367" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">calcAge</code>，应该返回，顾名思义，<code class="fe mr ms mt mu b">age</code>。</p><p id="56d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我们使用两个实用函数<code class="fe mr ms mt mu b">diffInYears</code>和<code class="fe mr ms mt mu b">parse</code>。为了简单起见，这个片段没有显示它们的实现。</p><p id="1ec9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">calcAge</code>中<code class="fe mr ms mt mu b">input</code>的类型有三种。因此，return语句将无法编译。</p><h1 id="f69f" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">平等缩小</h1><p id="f96e" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">一个明显的开始是检查<code class="fe mr ms mt mu b">input</code>是否没有值<code class="fe mr ms mt mu b">null</code>和<code class="fe mr ms mt mu b">undefined</code>。如果是这样，那就只能是一个<code class="fe mr ms mt mu b">Date</code>。</p><p id="8eee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们添加这个条件，TypeScript理解它并将<code class="fe mr ms mt mu b">if</code>块中的<code class="fe mr ms mt mu b">input</code>视为<code class="fe mr ms mt mu b">Date</code>，我们可以安全地调用<code class="fe mr ms mt mu b">diffInYears</code>。</p><p id="c305" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种对TypeScript的“隐式理解”已经是我们的第一个类型保护，它被称为“等式收缩”</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="7490" class="mz lv iq mu b gy na nb l nc nd">function calcAge(input: Date | null | undefined): number {<br/>  if (input !== null &amp;&amp; input !== undefined) {<br/>    return diffInYears(input);<br/>  }<br/>}</span></pre><p id="6c09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意<code class="fe mr ms mt mu b">if</code>条件不是对<code class="fe mr ms mt mu b">undefined</code>或<code class="fe mr ms mt mu b">null</code>类型的直接检查。它违背了价值观。同样，我们也不能针对<code class="fe mr ms mt mu b">Date</code> : <code class="fe mr ms mt mu b">value === Date</code>编写类型检查。<code class="fe mr ms mt mu b">Date</code>是<code class="fe mr ms mt mu b">input</code>的类型而不是它的值。</p><p id="1ed3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么为什么我们可以用<code class="fe mr ms mt mu b">undefined</code>和<code class="fe mr ms mt mu b">null</code>呢？答案很明显。类型<code class="fe mr ms mt mu b">undefined</code>只有一个值，即“未定义”而<code class="fe mr ms mt mu b">null</code>也是如此。类型<code class="fe mr ms mt mu b">null</code>只能有一个值，即“null”</p><p id="5d5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们的条件实际上排除了<code class="fe mr ms mt mu b">undefined</code>或<code class="fe mr ms mt mu b">null</code>的所有可能值。出于明显的原因，我们不想排除类型<code class="fe mr ms mt mu b">Date</code>:)的所有可能值</p><h1 id="a73c" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">类型of</h1><p id="4221" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">让我们试试另一种类型的后卫。JavaScript提供了<code class="fe mr ms mt mu b">typeof</code>，我们可以把它放在任何变量的前面。顾名思义，它将返回变量类型的名称作为<code class="fe mr ms mt mu b">string</code> …嗯，不完全是。否则，我们早就读到这篇文章的结尾了:)。</p><p id="5c18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在JavaScript中，我们有7个原语类型，剩下的只是类型<code class="fe mr ms mt mu b">object</code>。基本类型有<code class="fe mr ms mt mu b">boolean</code>、<code class="fe mr ms mt mu b">string</code>、<code class="fe mr ms mt mu b">number</code>、<code class="fe mr ms mt mu b">undefined</code>、<code class="fe mr ms mt mu b">null</code>、<code class="fe mr ms mt mu b">bigint</code>和<code class="fe mr ms mt mu b">symbol</code>。</p><p id="85d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">typeof</code>返回除了<code class="fe mr ms mt mu b">null</code>之外的每个原始类型的名称。对于<code class="fe mr ms mt mu b">null</code>，它返回‘对象’所以我们可以假设对于<code class="fe mr ms mt mu b">null</code>和任何非原始类型，我们会得到‘object’但是还有第二个例外。如果变量实际上是一个<code class="fe mr ms mt mu b">function</code>或者如果你传递了一个<code class="fe mr ms mt mu b">class</code>的名字，<code class="fe mr ms mt mu b">typeof</code>也返回‘函数’。严格来说，函数不是实型；它是一个可调用的对象。</p><p id="41a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这些知识，下面的代码会起作用吗？</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="a3df" class="mz lv iq mu b gy na nb l nc nd">function calcAge(input: Date | null | undefined): number {<br/>  if (typeof input === "object") {<br/>    return diffInYears(input);<br/>  }<br/>}</span></pre><p id="88f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不会。因为<code class="fe mr ms mt mu b">typeof</code>也为<code class="fe mr ms mt mu b">null</code>返回“object ”,所以编译会失败。所以，我们对<code class="fe mr ms mt mu b">typeof</code>型守卫没有任何用处，但是让我们记住它。我们以后可能需要它。</p><h1 id="803b" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">真实性变窄</h1><p id="9b1f" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">JavaScript发明了两个新的英语术语。虚伪和真实。如果我们将一个假值放入一个条件中，它将为真值返回<code class="fe mr ms mt mu b">false</code>和<code class="fe mr ms mt mu b">true</code>。JavaScript中有一个详尽的falsy值列表。分别是<code class="fe mr ms mt mu b">false</code>、<code class="fe mr ms mt mu b">0</code>、<code class="fe mr ms mt mu b">0n</code>、<code class="fe mr ms mt mu b">''</code>、<code class="fe mr ms mt mu b">null</code>、<code class="fe mr ms mt mu b">NaN</code>和<code class="fe mr ms mt mu b">undefined</code>。</p><p id="6fa5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以利用这一点。如果我们只将<code class="fe mr ms mt mu b">input</code>放入<code class="fe mr ms mt mu b">if</code>条件中，如果值不是<code class="fe mr ms mt mu b">undefined</code>或<code class="fe mr ms mt mu b">null</code>，它将是<code class="fe mr ms mt mu b">true</code>。在我们的例子中，这与等式运算符非常相似，只是更短一些。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="4ea8" class="mz lv iq mu b gy na nb l nc nd">function calcAge(input: Date | null | undefined): number {<br/>  if (input) {<br/>    return diffInYears(input);<br/>  }<br/>}</span></pre><p id="58ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们漏了一点点。如果该值是一个空字符串，它也将是false，我们将不会在<code class="fe mr ms mt mu b">if</code>-条件中结束。但是只要我们知道，这对我们的用例来说是可以的。</p><p id="9cbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们使我们的例子更有趣。我们添加了第四种可能的类型，即<code class="fe mr ms mt mu b">string</code>。现在是<code class="fe mr ms mt mu b">typeof</code>进入游戏的时间。</p><p id="dfbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们通过truthiness narrowing消除了值为<code class="fe mr ms mt mu b">null</code>或<code class="fe mr ms mt mu b">undefined</code>的可能性，并返回值0(我们将在后面进行改进)。</p><p id="114c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么就只有在<code class="fe mr ms mt mu b">Date</code>和<code class="fe mr ms mt mu b">string</code>之间了。而在这里，我们可以用<code class="fe mr ms mt mu b">typeof</code>来检查<code class="fe mr ms mt mu b">input</code>是否是<code class="fe mr ms mt mu b">string</code>。如果没有，那只能是<code class="fe mr ms mt mu b">Date</code>。完美！</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="2b6f" class="mz lv iq mu b gy na nb l nc nd">function calcAge(input: Date | null | undefined | string): number {<br/>  if (!input) {<br/>    return 0;<br/>  } else if (typeof input === "string") {<br/>    return diffInYears(parse(input));<br/>  } else {<br/>    return diffInYears(input);<br/>  }<br/>}</span></pre><h1 id="0fba" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated"><code class="fe mr ms mt mu b">instanceof</code></h1><p id="4395" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">当我们处理类时，也有可能进行类型收缩。为此，让我们添加一个类<code class="fe mr ms mt mu b">Person</code>，它有一个类型为<code class="fe mr ms mt mu b">Date</code>的属性<code class="fe mr ms mt mu b">birthday</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf lt l"/></div></figure><p id="dc8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，<code class="fe mr ms mt mu b">else</code>子句中的最后一个返回将失败，因为<code class="fe mr ms mt mu b">input</code>可以是类型<code class="fe mr ms mt mu b">Date</code>或<code class="fe mr ms mt mu b">Person</code>。好消息是两者实际上都是类实例，我们可以使用<code class="fe mr ms mt mu b">instanceof</code>。</p><p id="e6a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果值是特定类的实例，则<code class="fe mr ms mt mu b">instanceof</code>返回<code class="fe mr ms mt mu b">true</code>。因此，如果我们为类<code class="fe mr ms mt mu b">Date</code>添加一个带有检查的条件，我们再次处于类型安全的一侧:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf lt l"/></div></figure><p id="afc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要知道<code class="fe mr ms mt mu b">instanceof</code>为整个类继承链返回<code class="fe mr ms mt mu b">true</code>。因此，如果<code class="fe mr ms mt mu b">Person</code>从<code class="fe mr ms mt mu b">Entity</code>类扩展而来，<code class="fe mr ms mt mu b">instanceof Entity</code>也将返回true。</p><h1 id="54b3" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">歧视工会</h1><p id="f4f9" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">我们经常使用类，但是我们经常处理对象文字或者——用TypeScript行话来说——接口或类型。</p><p id="c7cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看这个稍加修改的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf lt l"/></div></figure><p id="1124" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哎哟，又是一个编译错误。我们不能在这里也使用<code class="fe mr ms mt mu b">instanceof</code>吗？编号<code class="fe mr ms mt mu b">Person</code>和<code class="fe mr ms mt mu b">Car</code>都只是一个<code class="fe mr ms mt mu b">type</code>，是一个仅存在于TypeScript中的元素。当它被转换成JavaScript时，<code class="fe mr ms mt mu b">Person</code>和<code class="fe mr ms mt mu b">Car</code>的定义就不再存在了。另一方面，类也确实存在于JavaScript中。这就是为什么<code class="fe mr ms mt mu b">instanceof</code>为他们工作。</p><p id="3c00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，那我们能做什么？</p><p id="f0a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们处于一种幸运的地位。<code class="fe mr ms mt mu b">Person</code>和<code class="fe mr ms mt mu b">Car</code>共享同一个属性<code class="fe mr ms mt mu b">category</code>，并且各自有不同的值。通过验证<code class="fe mr ms mt mu b">category</code>是否有值“car”，TypeScript足够聪明地理解它只能是类型<code class="fe mr ms mt mu b">Car</code>。对于<code class="fe mr ms mt mu b">Person</code>,该值显然是“人”。这种类型的防护装置的名称是“歧视性联合”让我们再次修正我们的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf lt l"/></div></figure><p id="f01a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不需要为鉴别器<code class="fe mr ms mt mu b">category</code>调用属性。我们可以选择任何我们想要的名字。</p><h1 id="a62f" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated"><code class="fe mr ms mt mu b">"in"</code>型防护罩</h1><p id="5e43" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">考虑这样一种情况，我们没有那么幸运地拥有一个可以用作鉴别器值的属性:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf lt l"/></div></figure><p id="9289" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们可以使用<code class="fe mr ms mt mu b">in</code>型防护罩。用<code class="fe mr ms mt mu b">in</code>我们可以请求一个对象是否有某种属性。所以如果它在<code class="fe mr ms mt mu b">Person</code>和<code class="fe mr ms mt mu b">Car</code>之间，并且属性<code class="fe mr ms mt mu b">birthday</code>存在。类型只能是<code class="fe mr ms mt mu b">Person</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf lt l"/></div></figure><h1 id="e0dc" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">类型谓词</h1><p id="3bb1" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">我们的下一个类型后卫不是真正意义上的类型后卫。这是某种妥协。</p><p id="38a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们用类型<code class="fe mr ms mt mu b">PersonJson</code>替换类型<code class="fe mr ms mt mu b">Car</code>。它也有一个属性<code class="fe mr ms mt mu b">birthday</code>，但是它的类型是<code class="fe mr ms mt mu b">string</code>。</p><p id="db1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过<code class="fe mr ms mt mu b">typeof value.birthday === 'string'</code>逃脱。这是<code class="fe mr ms mt mu b">typeof</code>和区别联管节型护罩的组合:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf lt l"/></div></figure><p id="5b01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码编译好了，一切看起来都没问题，但并不完美。如果我们将<code class="fe mr ms mt mu b">input</code>赋给最后一个<code class="fe mr ms mt mu b">else if</code>语句中的一个新变量，我们会看到TypeScript将类型标识为<code class="fe mr ms mt mu b">Person | PersonJson</code>，而不是<code class="fe mr ms mt mu b">PersonJson</code>。</p><p id="53f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们达到TypeScript极限的时间点。幸运的是，这并不意味着游戏结束。</p><p id="4fe5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当TypeScript用尽选项时，它允许我们提出一个包含特定类型验证代码的函数。</p><p id="28ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">某种程度上，这是一种妥协。只要我们返回<code class="fe mr ms mt mu b">true</code>或<code class="fe mr ms mt mu b">false</code>，我们就可以在那个函数中写任何我们想写的东西。TypeScript会信任我们。</p><p id="3104" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个特殊的函数被称为“类型谓词”,对于<code class="fe mr ms mt mu b">Person</code>,它看起来是这样的:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="66fc" class="mz lv iq mu b gy na nb l nc nd">function isPerson(value: Person | PersonJson): value is Person {<br/>  return value.birthday instanceof Date;<br/>}</span></pre><p id="48c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意我们通常使用返回类型的特殊符号。</p><p id="9562" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用谓词作为任何其他函数，并将其放入最后一个<code class="fe mr ms mt mu b">else if</code>条件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf lt l"/></div></figure><h1 id="61e1" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">针对U型收缩<code class="fe mr ms mt mu b">nknown</code></h1><p id="2a70" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">有了类型谓词，我们甚至可以处理<code class="fe mr ms mt mu b">unknown</code>类型的变量。所要做的就是用类型谓词应用一个<code class="fe mr ms mt mu b">if</code>条件，瞧，问题就解决了。</p><p id="a3b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但我们必须小心，不应该欺骗自己。类型收缩和我们的验证逻辑一样好。</p><p id="cfad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们有一个类型为<code class="fe mr ms mt mu b">unknown</code>的值，并且我们想要验证它是否具有<code class="fe mr ms mt mu b">Person</code>的“形状”，我们必须想出一个比我们之前使用的代码更好的代码。对于“形状”，我们指的是任何具有属性<code class="fe mr ms mt mu b">birthday: Date</code>的对象文字或实例。</p><h2 id="13c2" class="mz lv iq bd lw ng nh dn ma ni nj dp me lf nk nl mg lj nm nn mi ln no np mk nq bi translated">9.1.手动验证</h2><p id="5ebb" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">类型安全的类型谓词如下所示:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="a1ff" class="mz lv iq mu b gy na nb l nc nd">function isPerson(value: unknown): value is Person {<br/>  return (<br/>    typeof value === "object" &amp;&amp;<br/>    value !== null &amp;&amp;<br/>    "birthday" in value &amp;&amp;<br/>    (value as { birthday: unknown }).birthday instanceof Date<br/>  );<br/>}</span></pre><p id="2026" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多么庞大的代码量啊！不幸的是，如果我们想要完全类型安全，这是必要的。</p><p id="e829" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数显示了TypeScript功能的另一个限制。尽管我们检查了<code class="fe mr ms mt mu b">birthday</code>是<code class="fe mr ms mt mu b">value</code>的一个属性，我们仍然必须在最后一个条件中应用类型断言来检查<code class="fe mr ms mt mu b">birthday</code>是否属于类型<code class="fe mr ms mt mu b">Date</code>。</p><p id="45af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以预计随着时间的推移，TypeScript的局限性会变得越来越小，但目前，它就是这样。</p><h2 id="9eef" class="mz lv iq bd lw ng nh dn ma ni nj dp me lf nk nl mg lj nm nn mi ln no np mk nq bi translated">9.2.自动验证:zod</h2><p id="a9ae" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">我们继续使用针对<code class="fe mr ms mt mu b">unknown</code>类型的类型收缩。根据应用程序的类型，我们可能经常不得不处理<code class="fe mr ms mt mu b">unknown</code>类型。显然，我们不想一直自己编写这些庞大的类型谓词。它耗费了相当多的宝贵时间。</p><p id="d208" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，不一定非要那样。有一些特殊的库可以自动进行验证。</p><p id="946d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中最受欢迎的是“佐德”其他类似的库是“快速检查”或“是”</p><p id="49d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于每一种类型，我们必须首先提出一个模式。这意味着我们以编程方式定义类型并将其存储到一个变量中。所以模式信息在运行时也是存在的。</p><p id="c8bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在类型谓词中使用生成的模式来验证值是否属于该类型。</p><p id="e164" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了zod，我们的<code class="fe mr ms mt mu b">isPerson</code>看起来会像这样:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="325a" class="mz lv iq mu b gy na nb l nc nd">const personSchema = z.object({<br/>  birthday: z.date(),<br/>});</span><span id="8214" class="mz lv iq mu b gy ne nb l nc nd">type Person = z.infer&lt;typeof personSchema&gt;;</span><span id="a652" class="mz lv iq mu b gy ne nb l nc nd">function isPerson(value: unknown): value is Person {<br/>  return personSchema.safeParse(value).success;<br/>}</span></pre><p id="bd7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们定义模式并将其存储在<code class="fe mr ms mt mu b">personSchema</code>下。有了现有的模式，我们可以让zod为我们自动生成类型。这与<code class="fe mr ms mt mu b">z.infer</code>一起工作。这简化了事情，并确保我们在更改<code class="fe mr ms mt mu b">Person</code>类型时不会重复工作。</p><p id="6692" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们使用方法<code class="fe mr ms mt mu b">safeParse</code>，如果值不属于类型<code class="fe mr ms mt mu b">Person</code>，它不会抛出错误。它通过<code class="fe mr ms mt mu b">success</code>属性返回结果。</p><p id="cffe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这比一直手动编写验证代码要好得多。</p><h1 id="f0f4" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">断言函数</h1><p id="0eaa" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">断言函数是最后一个特性，它不是类型保护，但是非常方便。</p><p id="55e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当类型为<code class="fe mr ms mt mu b">unknown</code>、<code class="fe mr ms mt mu b">null</code>或空字符串时，我们返回第一个条件中的数字<code class="fe mr ms mt mu b">0</code>。</p><p id="df51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">返回数字<code class="fe mr ms mt mu b">0</code>是一种方法。另一种方法是抛出一个错误。</p><p id="ab7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们抛出一个错误，TypeScript的类型收缩将把<code class="fe mr ms mt mu b">undefined</code>或<code class="fe mr ms mt mu b">null</code>从函数的其余代码中排除。</p><p id="5eed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">断言函数就是这样一个特殊的函数。如果我们调用它，它将——类似于类型guard——缩小参数范围，但它不返回布尔值。它向我们保证，如果值不是特定的类型，它会抛出一个错误。</p><p id="036a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">处理不应该是<code class="fe mr ms mt mu b">undefined</code>或<code class="fe mr ms mt mu b">null</code>的类型是如此常见，以至于TypeScript甚至提供了一个特殊的类型实用程序。它被命名为<code class="fe mr ms mt mu b">NonNullable&lt;T&gt;</code>。该类型实用程序意味着，无论<code class="fe mr ms mt mu b">T</code>是什么类型，它都不是<code class="fe mr ms mt mu b">undefined</code>或<code class="fe mr ms mt mu b">null</code>。让我们看看<code class="fe mr ms mt mu b">NonNullable&lt;T&gt;</code>和断言函数是如何工作的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf lt l"/></div></figure><p id="c1f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">必须允许最后一个问题:当我们抛出一个错误时，为什么不首先从参数的联合类型中删除它们？比如<code class="fe mr ms mt mu b">function calcAge(value: Date | string | Person | PersonJson): number {}</code>？</p><p id="384f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为打电话的人可能会强迫我们加入。例如，在Angular中，禁用时，表单的输入值为<code class="fe mr ms mt mu b">undefined</code>。因此，我们当然可以说，我们的程序逻辑不允许使用<code class="fe mr ms mt mu b">undefined</code>，因为我们没有提供禁用功能。然而，我们的表单库的类型有它，这就是为什么它在参数的类型中。</p><h1 id="129e" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">摘要</h1><p id="ebea" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">本文展示了处理联合类型的各种技术，以及如何将它们缩小到一种特定的类型。TypeScript可以验证这些模式，这意味着我们并不是要比编译器更聪明，而是要生成尽可能类型安全的代码。</p><p id="a135" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相对于类型断言，我们应该总是倾向于类型收缩。这意味着更多的努力，但我们不必牺牲类型安全。</p><p id="e148" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类型安全是我们使用TypeScript而不是JavaScript的主要原因。我们希望获得尽可能多的类型安全。从这个角度来看，正确使用类型收缩是应用程序开发人员最重要的类型脚本技能。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="d592" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ny">原载于</em>【www.rainerhahnekamp.com】<em class="ny"/></p></div></div>    
</body>
</html>