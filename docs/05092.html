<html>
<head>
<title>Indie Mac App DevOps With GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有GitHub操作的独立Mac应用程序DevOps</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/indie-mac-app-devops-with-github-actions-b16764a3ebe7?source=collection_archive---------6-----------------------#2020-06-08">https://betterprogramming.pub/indie-mac-app-devops-with-github-actions-b16764a3ebe7?source=collection_archive---------6-----------------------#2020-06-08</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="ff42" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">自动化测试、签名、公证和分发</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/ba038ccad386d83680070027a0a23fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a2SNKWkH5vfQyQMY"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@ray30?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雷锐</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="58c9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你在考虑为<a class="ae kz" href="https://www.apple.com/macos/" rel="noopener ugc nofollow" target="_blank"> macOS </a>写一个应用吗？你想使用<a class="ae kz" href="https://brew.sh" rel="noopener ugc nofollow" target="_blank">自制软件</a>在<a class="ae kz" href="https://developer.apple.com/app-store/mac/" rel="noopener ugc nofollow" target="_blank"> Mac应用商店</a>之外发布它吗？在这篇文章中，我描述了如何使用<a class="ae kz" href="https://github.com" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和<a class="ae kz" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>为一个用苹果<a class="ae kz" href="https://developer.apple.com/developer-id/" rel="noopener ugc nofollow" target="_blank">开发者ID </a>签名的Mac应用程序设置持续集成、交付和部署。最棒的是，如果app是开源的，我描述的一切都是完全免费使用的！(如果你的应用程序不是开源的，而是托管在GitHub上的一个私人存储库中，你仍然可以免费这样做，但要受到<a class="ae kz" href="https://help.github.com/en/github/setting-up-and-managing-billing-and-payments-on-github/about-billing-for-github-actions" rel="noopener ugc nofollow" target="_blank">限制</a>。)</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="d550" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">这有什么难的？</h1><p id="7e31" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">过去，你可以编译你的代码，把它打包在一个文档或安装程序中，放在一个网站上供下载，然后期望人们下载它——现在不是了。由于恶意软件的传播，苹果公司在操作系统中增加了限制，以防止不受信任的代码运行。这些限制使建造和包装变得复杂。此外，使用过自制软件的用户希望能够从命令行安装并保持最新的软件。这种预期也使分配变得复杂。</p><p id="a9fd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">自2012年以来，Mac操作系统已经包括了<a class="ae kz" href="https://support.apple.com/en-us/HT202491" rel="noopener ugc nofollow" target="_blank">看门人</a>，这一功能要求应用程序已经用苹果提供的加密证书签名才能运行。最新版本的macOS甚至开始要求在Mac App Store之外发布的应用程序必须经过苹果公司的<a class="ae kz" href="https://developer.apple.com/developer-id/" rel="noopener ugc nofollow" target="_blank">公证</a>才能运行，这是一个<a class="ae kz" href="https://developer.apple.com/documentation/xcode/notarizing_macos_software_before_distribution" rel="noopener ugc nofollow" target="_blank">过程</a>，要求你在发布之前将应用程序上传到苹果公司，然后等待回复。</p><p id="9e35" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用Mac App Store进行分发有很多原因——对于大多数应用程序来说，这可能是正确的地方。但如果你想使用Mac App Store中不允许的API，或者你不想处理审查过程，那么选择退出并找到不同的发布渠道是有意义的。我会告诉你怎么做。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="562c" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">我们理想的DevOps工作流程</h1><p id="7b51" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">我们理想的DevOps工作流是在每次提交时自动测试我们的代码，并在每个发布标签上自动构建和发布以供分发。在我们推动变更和用户访问变更之间不应该有手动的步骤。</p><p id="1ec9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这种情况下，当我们说“发布以供分发”时，我们的意思是可以使用自制软件安装新版本的应用程序。为了实现这一点，我们将在GitHub上托管我们自己的<a class="ae kz" href="https://docs.brew.sh/Taps" rel="noopener ugc nofollow" target="_blank">自制tap </a>，并在GitHub上托管我们构建的应用作为<a class="ae kz" href="https://developer.github.com/v3/repos/releases/#upload-a-release-asset" rel="noopener ugc nofollow" target="_blank">发布资产</a>。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="f443" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">六个手动步骤</h1><p id="574b" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在软件部署的环境中，趋向于“手动的、重复的、可自动化的、战术性的、缺乏持久价值的、线性扩展的”工作被称为<a class="ae kz" href="https://landing.google.com/sre/sre-book/chapters/eliminating-toil/" rel="noopener ugc nofollow" target="_blank">辛劳</a>。在提交更改、标记并将其推送到GitHub之后，我们必须执行六个手动步骤来发布我们的应用程序以供分发<em class="na">,这些步骤都很辛苦:</em></p><ul class=""><li id="34a5" class="nb nc iu lc b ld le lg lh lj nd ln ne lr nf lv ng nh ni nj bi translated">构建用于发布的应用程序。</li><li id="61d8" class="nb nc iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">使用Apple开发者ID证书对应用程序进行签名。</li><li id="9fb3" class="nb nc iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">将签名的应用程序打包到磁盘映像中。</li><li id="f06d" class="nb nc iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">公证磁盘映像。</li><li id="482d" class="nb nc iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">将经过公证的磁盘映像作为发布资产上传到GitHub。</li><li id="b65d" class="nb nc iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">用新的应用程序版本和SHA256值更新Homebrew tap。</li></ul></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="1c94" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">告别辛劳</h1><p id="7510" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">我们用辛劳做什么？我们将它自动化！最终的结果将是，每当我们向GitHub推送标签时，应用程序将自动构建、签名、打包、公证，并作为GitHub发布资产上传，我们的家酿tap将自动更新以指向新版本。整个过程只需几分钟。</p><p id="d521" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">自动化是持续集成(CI)和持续部署(CD)的混合，使用<a class="ae kz" href="https://help.github.com/en/actions/configuring-and-managing-workflows" rel="noopener ugc nofollow" target="_blank"> GitHub Actions工作流</a>实现。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="2b35" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">连续累计</h1><p id="4f70" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">我们创建的自动化的第一部分是持续集成:在每次提交后构建和测试我们的应用程序。为此，我们在macOS主机上的GitHub Actions环境中运行<code class="fe np nq nr ns b">xcodebuild test</code>。</p><p id="5e37" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="na">注意</em> </strong> <em class="na">:即使你的应用不包含测试，你仍然可以在每次提交时构建你的应用，并从持续集成中获得价值。在这种情况下，使用</em> <code class="fe np nq nr ns b"><em class="na">build</em></code> <em class="na">动作代替</em> <code class="fe np nq nr ns b"><em class="na">test</em></code> <em class="na">动作与</em> <code class="fe np nq nr ns b"><em class="na">xcodebuild</em></code> <em class="na">在工作流程的最后一步。</em></p><p id="ae6f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过将以下GitHub Actions工作流放入我们在<code class="fe np nq nr ns b">.github/workflows/master_test.yml</code>的项目工作区，我们实现了持续集成:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="e5e0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">每当我们将新的提交推送到<code class="fe np nq nr ns b">master</code>分支时，这个工作流就会运行。它包括在macOS主机上运行的单个作业。这项工作包括三个步骤。</p><p id="3437" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，触发工作流的提交的引用将是签出的引用。</p><p id="ff57" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，确定项目的默认方案，并将其设置为环境变量。(在这一点上，这种方法可能看起来有些多余——毕竟，我们可以对项目的默认方案名称进行硬编码——但是我现在引入这种模式是因为我们将在下一个工作流中再次使用它，并且它允许这个工作流在其他项目中无需修改就可以重用。)</p><p id="e128" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，使用<code class="fe np nq nr ns b">xcodebuild test</code>构建并测试项目，输出通过<code class="fe np nq nr ns b"><a class="ae kz" href="https://github.com/xcpretty/xcpretty" rel="noopener ugc nofollow" target="_blank">xcpretty</a></code>传输，这是一个方便的开源工具，预装在GitHub Actions runners上。我们用值“<code class="fe np nq nr ns b">—</code>”(这个值在Xcode中被称为“本地运行签名”)覆盖了<code class="fe np nq nr ns b">CODE_SIGN_IDENTITY</code>构建设置，以启用特定代码签名。这允许我们在一台机器上构建和测试应用程序，而不需要为这个工作流配置任何代码签名秘密。</p><p id="bee2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于这个持续集成工作流来说，一些事情必须是真实的。上述工作流文件必须提交到项目工作区的<code class="fe np nq nr ns b">master</code>分支，并推送到GitHub。项目本身必须配置有包含构建和测试阶段的共享方案，并且该方案必须位于方案列表的第一位。最后，测试必须能够在通过<code class="fe np nq nr ns b">xcodebuild test</code>调用时运行——在第一次部署工作流之前，通过从命令行本地运行测试来验证这一点。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="3c08" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">持续部署</h1><p id="40b3" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">我们创建的自动化的第二部分是持续部署:在每个发布标签之后发布我们的应用程序。我们使用的惯例是，任何以字母“<code class="fe np nq nr ns b">v</code>”开头的标签都是发布标签，例如<code class="fe np nq nr ns b">v1.2.0</code>。</p><p id="9336" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们在macOS主机上的GitHub Actions环境中运行<code class="fe np nq nr ns b">xcodebuild install</code>来构建和签署项目，然后我们将我们的应用程序打包成一个磁盘映像，公证它，将其作为发布资产上传，最后用最新的版本信息更新我们的家酿tap。</p><p id="d7d3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过将以下GitHub Actions工作流放入我们在<code class="fe np nq nr ns b">.github/workflows/master_deploy.yml</code>的项目工作区，我们实现了持续部署:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="26d3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个工作流比前一个工作流多了很多，但是两个工作流的开始是相似的。每当我们向存储库推送以字母“<code class="fe np nq nr ns b">v</code>”开头的新标签时，这个工作流就会运行。它包括在macOS主机上运行的单个作业。这项工作包括十一个步骤。</p><p id="cf12" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">和以前一样，第一步检查项目。这一次，触发工作流的标签是检出的标签。</p><p id="c17c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，项目的默认方案被确定，并被设置为一个环境变量，如前所述。</p><p id="2994" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，使用<code class="fe np nq nr ns b">xcodebuild -showBuildSettings</code>从项目中读取额外的构建设置，并设置为环境变量供后续步骤使用。这避免了在工作流中硬编码项目细节的需要，并且使得在其他项目中重用工作流更加容易。</p><p id="3a4c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下一步是在action runner主机上设置一个macOS钥匙串，其中包含我们应用程序的签名凭证，因为Xcode希望在默认钥匙串中找到签名身份。该步骤使用<code class="fe np nq nr ns b">SIGNING_CERTIFICATE_P12_DATA</code>和<code class="fe np nq nr ns b">SIGNING_CERTIFICATE_PASSWORD</code>秘密以及<code class="fe np nq nr ns b">security</code>工具来导入签名证书。(有关如何设置密码的信息，请参见下文。)这是这个过程中最复杂、记录最少的一步。这个 StackOverflow问题的答案提供了一些背景。</p><p id="7721" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们测试应用程序。我们从来不想发布一个没有通过测试的应用程序版本，所以我们在继续之前要确保测试通过。如果您的项目不包含测试，请省略此步骤。</p><p id="7f7e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一旦应用程序已经过测试，下一步是重新构建它以便安装，然后将应用程序安装到一个发布根目录(<code class="fe np nq nr ns b">DSTROOT</code>)。</p><p id="6ee9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">成功完成安装步骤后，使用<code class="fe np nq nr ns b">hdiutil</code>将应用程序打包成磁盘映像。</p><p id="d758" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">工作流程的下一步是使用<code class="fe np nq nr ns b"><a class="ae kz" href="https://www.npmjs.com/package/notarize-cli" rel="noopener ugc nofollow" target="_blank">notarize-cli</a></code>工具公证磁盘映像。这是我写的一个工具，用来在持续部署的背景下简化Mac应用的公证。它包装了Xcode提供的两个工具— <code class="fe np nq nr ns b">altool</code>和<code class="fe np nq nr ns b">stapler</code>。它用那些工具把磁盘镜像上传到苹果，等待成功，然后把公证钉到磁盘镜像上。这一步使用<code class="fe np nq nr ns b">NOTARIZE_USERNAME</code>和<code class="fe np nq nr ns b">NOTARIZE_PASSWORD</code>秘密向Apple认证。(有关如何设置密码的信息，请参见下文。)</p><p id="4f9c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该应用程序已准备好进行部署。下一步是将经过公证的磁盘映像作为发布资产交付给GitHub。我们使用来自<a class="ae kz" href="https://github.com/marketplace" rel="noopener ugc nofollow" target="_blank"> GitHub市场</a>的<code class="fe np nq nr ns b"><a class="ae kz" href="https://github.com/softprops/action-gh-release" rel="noopener ugc nofollow" target="_blank">softprops/action-gh-release</a></code>动作来为我们执行这个动作。这一步使用的是GitHub Actions自动为我们设置的<code class="fe np nq nr ns b"><a class="ae kz" href="https://help.github.com/en/actions/configuring-and-managing-workflows/authenticating-with-the-github_token#about-the-github_token-secret" rel="noopener ugc nofollow" target="_blank">GITHUB_TOKEN</a></code>秘密。这个令牌的作用范围是允许我们只对运行的工作流所在的存储库进行修改。</p><p id="a1ca" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">至此，app已经交付。在GitHub上闲逛的人可以找到发布的应用并下载它，但是谁有时间做这个呢？为了完成部署，我们仍然需要更新自制水龙头。受欢迎的应用程序可以存放在<a class="ae kz" href="https://github.com/Homebrew/homebrew-cask/tree/master/Casks" rel="noopener ugc nofollow" target="_blank">家酿木桶</a>储存库中，但是如果你的应用程序还没有受众，它就不会被官方tap接受——你需要存放自己的应用程序。幸运的是，托管自己的水龙头很容易，家酿支持从第三方水龙头无缝安装。(有关如何设置龙头和桶以用于此工作流程的信息，请参见下文。)</p><p id="a205" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">工作流程中的下一步是检查水龙头。这一步使用了<code class="fe np nq nr ns b">CASK_REPO</code>和<code class="fe np nq nr ns b">CASK_REPO_TOKEN</code>的秘密。(有关如何设置密码的信息，请参见下文。)屏蔽回收令牌保存在已签出的工作区中，并用于在下一步中将更改推回tap存储库。</p><p id="acdc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后一步是用应用程序的新版本号和发布资产的哈希值更新木桶。版本号由触发工作流的发布标签确定，哈希从经过公证的磁盘映像计算得出。提交作者被设置为触发工作流的用户，更改被提交并推回tap存储库。</p><p id="c6ca" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要让这个工作流工作，有几件事必须是真的。上述工作流文件必须提交到项目工作区的<code class="fe np nq nr ns b">master</code>分支，并推送到GitHub。项目本身必须用包含构建和测试阶段的默认共享方案进行配置。项目必须配置代码签名身份的名称，以便在构建发布时使用，并且该名称必须与存储在GitHub secret中的签名凭证相匹配。最后，在家酿tap存储库中必须已经存在一个木桶，以便进行最后一步的更新。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="1957" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">项目配置</h1><p id="dc06" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">配置Xcode项目的方式似乎有无限多种。我希望这些工作流程能与您的工作流程相配合。我已经验证了这些工作流可以与新创建的配置了UI测试的macOS应用程序项目一起工作，除了默认的<code class="fe np nq nr ns b">testLaunchPerformance</code>测试在从命令行运行时失败——删除该测试，您就可以开始工作了。</p><p id="21e4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">若要为项目配置开发者ID签名，请先在Xcode的“帐户”偏好设置中添加您的Apple ID帐户。添加帐户后，从团队表中选择您的团队，然后单击“管理证书…”按钮。找一个“开发者ID应用”证书。如果您没有看到，请通过单击“+”按钮并从菜单中选择“开发者ID应用程序”来创建一个。</p><p id="c60c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="na">注</em> </strong> <em class="na">:如果你用Xcode创建了证书，那么它也应该自动导入到你的本地钥匙串中。如果出于某种原因，您需要手动下载您的开发者ID证书和私钥，并将其导入到您的钥匙串中，您可以从</em> <a class="ae kz" href="https://developer.apple.com/account/resources/certificates/list" rel="noopener ugc nofollow" target="_blank"> <em class="na">本页</em> </a> <em class="na">执行此操作。双击下载的"。cer”文件来使用“钥匙串访问”应用程序导入它。</em></p><p id="935b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，对Xcode项目中应用程序目标的“签名和功能”设置进行以下更改:</p><ul class=""><li id="27a4" class="nb nc iu lc b ld le lg lh lj nd ln ne lr nf lv ng nh ni nj bi translated">停用“自动管理签名”</li><li id="4b06" class="nb nc iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">将“团队”设定为与您的Apple ID相关联的团队。</li><li id="cd70" class="nb nc iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">将“预置描述文件”设置为“无”]。</li><li id="aa63" class="nb nc iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">将“签名证书”设置为“开发者ID应用”</li></ul><p id="7919" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在应该可以使用Xcode用你的开发者ID证书给你的应用签名了。通过从“产品”菜单中选择“归档”来构建要发布的应用程序，验证所有配置是否正确。然后从“窗口”菜单中选择“管理器”,并在档案表中找到新创建的档案。点击“分发应用”，然后选择“开发者ID”并点击“下一步”选择“导出”并点击“下一步”保留“分发证书”和配置文件设置的默认值，然后单击“下一步”如果出现提示，请输入您的凭据，最后单击“导出”保存签名的应用程序。</p><p id="8954" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">那是许多乏味的点击和等待——难怪我们决定自动化这一点！</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="d166" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">秘密配置</h1><p id="2ccd" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">我们已经创建了一个GitHub Actions工作流来执行持续集成和持续交付，并且我们的项目配置了开发人员ID代码签名。接下来要做的是设置我们的工作流成功运行所需的秘密。</p><p id="f684" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要向GitHub存储库添加密码，请导航到存储库的“设置”选项卡。然后从侧边栏选择“秘密”。点按“新密码”，然后输入密码的名称和值。最后，点击“添加密码”</p><p id="662c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe np nq nr ns b"><strong class="lc iv">SIGNING_CERTIFICATE_PASSWORD</strong></code></p><p id="8ba8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个密码应该设置为一个密码，用于加密您在生成下面的<code class="fe np nq nr ns b">SIGNING_CERTIFICATE_P12_DATA</code>密码时创建的p12文件。</p><p id="0352" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是我最喜欢的使用命令行生成随机密码的一行程序:</p><pre class="kk kl km kn gu nv ns nw nx aw ny bi"><span id="acaf" class="nz me iu ns b gz oa ob l oc od">&lt; /dev/urandom LC_CTYPE=C tr -dc a-zA-Z0-9 | head -c 32; echo</span></pre><p id="010c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe np nq nr ns b"><strong class="lc iv">SIGNING_CERTIFICATE_P12_DATA</strong></code></p><p id="fc75" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此机密应该设置为包含签名证书和私钥的p12文件的base64编码内容。</p><p id="def3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要设置这个秘密，我们首先需要从keychain导出签名证书和私钥。为此，请打开“钥匙串访问”应用程序，确定您的默认“登录”钥匙串已选定，然后选择“我的证书”类别。从列表中选择您的开发者ID证书，并从“文件”菜单中选择“导出项目…”。将文件格式设置为“个人信息交换(. p12)”，然后单击“保存”当提示输入加密密码时，输入<code class="fe np nq nr ns b">SIGNING_CERTIFICATE_PASSWORD</code>密码的值。然后在“钥匙串访问”提示时输入您的本地帐户凭据。</p><p id="05c5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，打开终端窗口并在磁盘上找到p12文件。运行以下命令对文件进行base64编码，并将其复制到剪贴板:</p><pre class="kk kl km kn gu nv ns nw nx aw ny bi"><span id="e563" class="nz me iu ns b gz oa ob l oc od">cat Certificates.p12 | base64 | pbcopy</span></pre><p id="2ada" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">粘贴复制的文本作为秘密的值。</p><p id="7d9e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe np nq nr ns b"><strong class="lc iv">NOTARIZE_USERNAME</strong></code>:这个秘密应该设置到你开发者账户的Apple ID。</p><p id="a336" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe np nq nr ns b"><strong class="lc iv">NOTARIZE_PASSWORD</strong></code>:此密码应设置为您的Apple ID帐户的应用程序专用密码。按照这些说明<a class="ae kz" href="https://support.apple.com/en-us/HT204397" rel="noopener ugc nofollow" target="_blank">创建特定于应用程序的密码。</a></p><p id="e4c7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe np nq nr ns b"><strong class="lc iv">CASK_REPO</strong></code>:这个秘密应该设置为GitHub存储库的全限定名称，该存储库托管这个应用程序的容器，例如<code class="fe np nq nr ns b">bacongravy/homebrew-tap</code>。</p><p id="1f18" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe np nq nr ns b"><strong class="lc iv">CASK_REPO_TOKEN</strong></code>:这个秘密应该被设置为GitHub个人访问令牌(PAT ),其作用域是对由<code class="fe np nq nr ns b">CASK_REPO</code>指定的存储库进行写访问。要生成PAT，请在GitHub上导航到您的用户“设置”，从边栏中选择“开发者设置”，然后从边栏中选择“个人访问令牌”，然后单击“生成新令牌”为令牌命名，选择“repo”范围，然后单击“Generate token”复制显示的令牌，并将其作为密码添加到您的存储库中。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="3ed1" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">抽头配置</h1><p id="cd87" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">家酿tap只是一个遵循特定惯例的GitHub库。阅读<a class="ae kz" href="https://docs.brew.sh/How-to-Create-and-Maintain-a-Tap" rel="noopener ugc nofollow" target="_blank">文档</a>了解更多信息。</p><p id="a7cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我建议将你的tap库命名为<code class="fe np nq nr ns b">homebrew-tap</code>。这将允许您使用如下命令安装应用程序:</p><pre class="kk kl km kn gu nv ns nw nx aw ny bi"><span id="ebd9" class="nz me iu ns b gz oa ob l oc od"> brew install &lt;username&gt;/tap/&lt;app-name&gt;</span></pre><p id="13ad" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您的全限定存储库名称应该是<code class="fe np nq nr ns b">&lt;username&gt;/homebrew-tap</code>，这是您应该将<code class="fe np nq nr ns b">CASK_REPO</code> secret设置为的值。</p><p id="c200" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们假设你的项目资源库命名为“chuck-wagon”，你的Xcode项目文件命名为“chuck-wagon.xcodeproj”，默认方案命名为“Chuck Wagon”，方案产生一个名为“Chuck Wagon.app”的产品。在这种情况下，工作流将发布一个名为“Chuck_Wagon.dmg”的磁盘映像，而木桶文件将被命名为“chuck-wagon.rb”。</p><p id="9815" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您需要在tap存储库中创建屏蔽文件。阅读文档了解更多信息。</p><p id="a0bb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是“卡车”的酒桶可能的样子:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="7a91" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要使这适用于您的应用程序，您需要将“<username>”、“chuck-wagon”、“Chuck Wagon”、“Chuck Wagon.app”和“Chuck_Wagon.dmg”替换为适合您的GitHub用户名和应用程序的值。</username></p><p id="9dd8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在您在路径<code class="fe np nq nr ns b">/Casks/$PROJECT_NAME</code>的<code class="fe np nq nr ns b">CASK_REPO</code>存储库中创建一个文件之后，<code class="fe np nq nr ns b">master_deploy</code>工作流将能够更新版本和sha256值。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="293d" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="0b65" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">这并不容易，但我们做到了。恭喜你！</p><p id="5040" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我已经建立了一个<a class="ae kz" href="https://github.com/bacongravy/mac-app-devops-demo" rel="noopener ugc nofollow" target="_blank">演示库</a>，这样你就可以看到一个活生生的例子。你可以在这里查看<code class="fe np nq nr ns b"><a class="ae kz" href="https://github.com/bacongravy/mac-app-devops-demo/blob/master/.github/workflows/master_deploy.yml" rel="noopener ugc nofollow" target="_blank">master_deploy</a></code>工作流程<a class="ae kz" href="https://github.com/bacongravy/mac-app-devops-demo/runs/728981487?check_suite_focus=true" rel="noopener ugc nofollow" target="_blank">的运行日志。可以在</a><a class="ae kz" href="https://github.com/bacongravy/homebrew-tap/blob/master/Casks/mac-app-devops-demo.rb" rel="noopener ugc nofollow" target="_blank">这里</a>找到由该工作流构建的演示应用的木桶。</p><p id="88f3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望这篇文章能启发你将生活中的辛劳自动化。编码快乐！</p></div></div>    
</body>
</html>