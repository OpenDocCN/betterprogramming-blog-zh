<html>
<head>
<title>Creating a REST API in Node.js With Express, TypeScript, MongoDB and Docker — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Express、TypeScript、MongoDB和Docker在Node.js中创建REST API第3部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pokeapi-rest-in-nodejs-with-express-typescript-mongodb-and-docker-part-3-1b173fc2a482?source=collection_archive---------3-----------------------#2019-07-04">https://betterprogramming.pub/pokeapi-rest-in-nodejs-with-express-typescript-mongodb-and-docker-part-3-1b173fc2a482?source=collection_archive---------3-----------------------#2019-07-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0d40" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建PokeAPI路由和查询数据库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2412e6bececa735d1588750633e9d62a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N0MSEI9BpIi7uXaWOj3CLQ.png"/></div></div></figure><p id="6af9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一系列文章的第三部分，将向您展示如何使用Express、TypeScript、Docker和MongoDB在Node.js中创建REST API。以下是本系列的其余部分:</p><p id="9251" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如需进一步阅读，请查看以下链接:</p><ul class=""><li id="3269" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><a class="ae lz" href="https://medium.com/@nyablk97/pokeapi-rest-in-nodejs-with-express-typescript-mongodb-and-docker-part-1-8428b0cd05d" rel="noopener">用Express、TypeScript、MongoDB和Docker在NodeJS中创建REST API第1部分</a></li><li id="09a4" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><a class="ae lz" href="https://medium.com/@nyablk97/pokeapi-rest-in-nodejs-with-express-typescript-mongodb-and-docker-part-2-38b48af52860" rel="noopener">用Express、TypeScript、MongoDB和Docker在NodeJS中创建REST API第二部分</a></li></ul><p id="2447" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在这里找到完整的代码。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="c9c4" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">介绍</h1><p id="2b7f" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">在前一篇文章中，我们用docker-compose部署了一个<a class="ae lz" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>的实例，并将我们的应用程序连接到它。我们还创建了我们的<a class="ae lz" href="https://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank">mongose</a>模式和数据模型。</p><p id="c526" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们将实现创建基本CRUD所必需的其余路径，以及它们各自的数据库查询功能。这些函数将利用我们之前创建的模型来查询我们的MongoDB数据库。</p><p id="18e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:Mongoose提供了基于回调或承诺的API。对于这个项目，我们将使用基于承诺的API，原因很简单，我更喜欢承诺而不是回调，因为我发现它们不那么冗长，因此更干净。你可以在这里阅读更多关于猫鼬承诺<a class="ae lz" href="https://mongoosejs.com/docs/promises.html" rel="noopener ugc nofollow" target="_blank">的内容。</a></p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="60a6" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">编码开始</h1><h2 id="e976" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">试映</h2><p id="9cf0" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">和往常一样，我们将在这篇文章的结尾先预览一下我们的目录:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/80e3239e1ef3cb0c8a4252e93b8edbfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*57HdxcMq1YMslRTrmBrIqQ.png"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">PokeAPI第3部分目录树</p></figure><p id="2a34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能会注意到，从目录角度来看，自上一篇文章以来没有任何变化。然而，在内容方面，有相当多的变化。</p><p id="567d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">提醒一下，为了运行我们的项目，我们目前使用以下命令:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="ff1a" class="nj mn it ob b gy of og l oh oi">npm run start</span></pre><p id="1af2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要启动我们的dockerized MongoDB实例，请使用以下命令:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="c27e" class="nj mn it ob b gy of og l oh oi">docker-compose up</span></pre><p id="91de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">说完了，我们开始吧。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="9abe" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">口袋妖怪服务:查询数据库</h1><p id="af14" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">现在是时候创建我们的数据库查询函数了。要做到这一点，如前所述，我们将利用我们的口袋妖怪模型。</p><p id="7270" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们的目标是实现四个基本的CRUD操作，所以我们要实现的第一个函数是读取<code class="fe oj ok ol ob b">db</code>的内容。所以，让我们打开<code class="fe oj ok ol ob b">pokemon.service.ts</code>文件，并添加一个<code class="fe oj ok ol ob b">findAll</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">PokemonService第4版——创建新的findAll方法</p></figure><p id="8671" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，我们新的<code class="fe oj ok ol ob b">findAll</code>方法使用Pokemon模型与MongoDB交互，并找到DB中的所有Pokemon。由于mongose的助手函数在<a class="ae lz" href="https://mongoosejs.com/docs/queries.html" rel="noopener ugc nofollow" target="_blank">mongose文档中有广泛的记载，</a>我认为没有必要在这里对它们进行分解。</p><p id="c02a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我将评论一下<code class="fe oj ok ol ob b">exec</code>函数。正如我前面提到的，我们将使用Mongoose的基于承诺的API，我们将通过使用返回承诺的<code class="fe oj ok ol ob b">exec</code>函数来实现。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="3056" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">实现获取路由</h1><p id="f746" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">我们现在在<code class="fe oj ok ol ob b">PokemonService</code>中有了<code class="fe oj ok ol ob b">findAll</code>函数。为了能够与这个函数交互，我们必须在控制器中创建另一个GET路由:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">口袋妖怪控制器版本6-创建一个新的获取路线</p></figure><p id="faf8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码非常简单，我们已经创建了一个新的GET route和一个新的private <code class="fe oj ok ol ob b">findAll</code>方法，它主要是调用服务的<code class="fe oj ok ol ob b">findAll</code>方法并发送响应。当然，我们通过将代码包装在try/catch块中来处理可能出现的任何错误。</p><p id="a653" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意第27行的<code class="fe oj ok ol ob b">res.status(500)</code>？因为默认情况下，Express将Response status属性设置为200，所以每当出现错误时，我们都需要指定一个错误状态代码，否则我们将面临获得一个通知我们有错误的响应的危险，但这个响应看起来很好，状态为200 OK！我们当然不希望这种情况发生，因此，如果发现任何错误，我们将发送一个状态代码500，它代表<em class="oo">内部服务器错误</em>，表明出现了问题。</p><p id="9a10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="oo">注意:我意识到发送一个通用的500状态代码给ever error并不是一个好的做法。在本系列的下一部分，我们将实现一个更好的错误处理机制，包括自定义错误、集中式错误处理和正确的状态代码。</em></p><h2 id="e914" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">测试路线</h2><p id="811a" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">既然我们已经确定了新路线，是时候测试它了！</p><p id="f7e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="oo">提示:从这里开始，我推荐使用</em> <a class="ae lz" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> <em class="oo">邮递员</em> </a> <em class="oo">来测试我们的路线。</em></p><p id="e2db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，访问这条新路由的端点是<code class="fe oj ok ol ob b">/all</code>。考虑到我们所有的口袋妖怪端点都以<code class="fe oj ok ol ob b">/pokemon</code>开头，完整的路径应该是<code class="fe oj ok ol ob b">/pokemon/all</code>。</p><p id="180a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果一切顺利，您应该从Postman获得如下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/25191fce5ea17c96c85a27339e212d5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6T0GrRTQkZpDWJzvMhM2A.png"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">邮递员:得到所有口袋妖怪</p></figure><p id="2319" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们没有将任何数据引入到我们的数据库中，所以我们接收到一个空数组。我们现在已经成功地完成了我们的第一个数据库查询！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="20a7" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">添加新的口袋妖怪</h1><p id="5f33" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">让我们实现一个函数来添加一个新的口袋妖怪到我们的数据库。让我们回到<code class="fe oj ok ol ob b">PokemonService</code>并创建一个<code class="fe oj ok ol ob b">add</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">口袋妖怪服务版本5-创建一个新的添加方法</p></figure><p id="17e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简单地解释一下，我们从请求主体创建一个Mongoose文档(<code class="fe oj ok ol ob b">newPokemon</code>)，并将其保存到db中。</p><p id="37f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="oo">注意:mongose文档是mongose模型的实例。</em></p><p id="ca9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们创建与新功能交互的路线。在我们的控制器中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">口袋妖怪控制器版本7-增加了一个新的发布路线</p></figure><p id="2466" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">考虑到GET和POST路由具有完全相同的端点，我们可以如上所示将它们链接起来。这样，我们就不必两次声明同一个路由，每个动词声明一次。</p><p id="76e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，这一次，我们的新路由是通过POST请求访问的。让我们前往邮差，并添加一个新的口袋妖怪到数据库:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/55be9c2257045e406cfea2e831eaeb30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TqdwItA_W7GbFqYer4AeAg.png"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">邮递员:添加一个新的口袋妖怪</p></figure><p id="ced5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果一切顺利，你应该会收到你刚刚添加的口袋妖怪作为输出。为了再次检查我们的小火龙是否被正确添加，我们可以利用之前的GET路径来获得所有的口袋妖怪:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/3a16848d2d37ecb3e4cacea431626050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VLWtUUWZXMPfyrv_jAMV0g.png"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">邮递员:得到所有口袋妖怪</p></figure><p id="bb0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">恭喜，我们的数据库中现在有了一个小火龙。</p><p id="a9b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不要担心<code class="fe oj ok ol ob b">_id</code>和<code class="fe oj ok ol ob b">__v</code>字段。它们是由Mongoose自动生成的，我们后面会讲到。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="cbc6" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">删除口袋妖怪</h1><p id="32e9" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">现在是时候实现一个删除口袋妖怪的函数了，所以让我们打开<code class="fe oj ok ol ob b">PokemonService</code>，并创建一个<code class="fe oj ok ol ob b">delete</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">口袋妖怪服务版本6-增加了一个新的删除方法</p></figure><p id="0f23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Mongoose有一个非常有用的<code class="fe oj ok ol ob b">findByIdAndDelete</code>助手函数，它允许我们通过它的<code class="fe oj ok ol ob b">_id</code>字段删除一个文档(在我们的例子中是一个Pokemon)。</p><p id="2362" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该功能是<code class="fe oj ok ol ob b">findOneAndDelete({_id: pokemonId})</code> <em class="oo">的简写。</em></p><p id="2660" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="oo">注意:如果您需要通过</em> <code class="fe oj ok ol ob b"><em class="oo">_id</em></code> <em class="oo">以外的任何字段删除单据，您可以使用前面提到的</em> <code class="fe oj ok ol ob b"><em class="oo">findOneAndDelete</em></code> <em class="oo">功能。更多关于它的信息</em> <a class="ae lz" href="https://mongoosejs.com/docs/api.html#model_Model.findOneAndDelete" rel="noopener ugc nofollow" target="_blank"> <em class="oo">这里</em> </a> <em class="oo">。</em></p><h2 id="ca43" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">保护条款</h2><p id="c243" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">如果你已经熟悉了保护条款，可以跳过这一部分。如果你不是，请和我呆在一起，我们将讨论这个非常有用的技术。</p><p id="c392" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简而言之，保护子句是一种检查，在出现错误或满足条件的情况下，通过返回语句或异常退出函数。它们允许我们在代码中避免不必要的复杂性。这是我们的保护条款:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">保护条款</p></figure><p id="aa44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过颠倒逻辑，并检查口袋妖怪是否已被删除，我们可以避免一个<code class="fe oj ok ol ob b">else</code>声明。如果条件满足，我们通过抛出一个错误来退出函数。如果口袋妖怪已经删除成功，则返回删除的口袋妖怪结果。简单而优雅。</p><h2 id="02c6" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">定义删除路线</h2><p id="9e2b" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">现在我们已经创建了我们的<code class="fe oj ok ol ob b">delete</code>函数，是时候创建我们的路线了。因此，在我们的控制器中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">口袋妖怪控制器版本7-增加了一个新的删除方法</p></figure><p id="6be9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们刚刚创建的删除路由中，我们表示将在URL中接收一个请求参数，这个参数我们已经命名为<code class="fe oj ok ol ob b">id</code>。然后我们在第46行获得这个参数，通过<code class="fe oj ok ol ob b">req.params</code>访问它，并把它传递给我们的服务。</p><p id="7eb7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">访问我们路线的路径如下所示:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="0ec8" class="nj mn it ob b gy of og l oh oi">localhost:9001/pokemon/<strong class="ob iu">123pokemonId</strong></span></pre><p id="3180" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中<code class="fe oj ok ol ob b">123pokemonId</code>是<code class="fe oj ok ol ob b">id</code>参数。</p><p id="a83a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们再次打开Postman，并通过删除我们之前添加到db中的口袋妖怪(或您选择的任何口袋妖怪)来测试我们的新路线:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/5627e82e73c48cc93620b146463e9a45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ap4SiHnT3QW6GMVZy_xrwQ.png"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">邮递员:删除一个口袋妖怪</p></figure><p id="689e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如你所见，我们收到了刚刚删除的口袋妖怪。如果在数据库中没有找到我们指定ID的Pokemon，我们将收到一条<code class="fe oj ok ol ob b">Pokemon with id '' not found</code>消息。让我们再次尝试删除同一个口袋妖怪，看看我们是否确实收到了这样的消息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/2633481950e5e62b07e04aadf064d426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-bMdf5b1EUExCy6I1xKmUw.png"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">邮递员:试图删除一个不存在的口袋妖怪</p></figure><p id="5df9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好，我们现在确信我们的错误处理工作正常。</p><p id="2fb6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过从数据库中获取所有口袋妖怪来仔细检查我们的小火龙是否已被正确删除:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/5161a0dc8aa64554dea6e7fe33d35fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYwda4kpkNdorbWxDEDUrQ.png"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">邮递员:得到所有口袋妖怪</p></figure><p id="35a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">空数组=无口袋妖怪=小火龙已成功删除。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="b94a" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">更新口袋妖怪</h1><p id="f041" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">在我们的口袋妖怪服务中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">口袋妖怪服务版本7-添加更新方法</p></figure><p id="6030" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能会注意到，我们的新<code class="fe oj ok ol ob b">update</code>方法与我们的<code class="fe oj ok ol ob b">delete</code>方法非常相似。我们存储Mongoose查询的结果，然后使用一个guard子句在没有找到Pokemon的情况下抛出一个错误。如果口袋妖怪更新成功，我们返回它。</p><p id="8c76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的控制器中，让我们创建最终路线:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">口袋妖怪控制器版本9-增加了一个新的上传路线</p></figure><p id="8033" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，我们再次链接了我们的PUT和DELETE路由，因为它们共享同一个端点。</p><p id="0814" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们去邮差那里，测试一下我们的最终路线。不要忘记添加一个新的口袋妖怪，否则你将没有任何数据更新！我选择添加另一个小火龙，现在我将更新它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/949345610e1253b1a299010bddbfed36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rb4aUrdjZpuozH9cnaX8Cw.png"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">邮递员:更新一个口袋妖怪</p></figure><p id="ec9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们获得所有的口袋妖怪来检查我们的小火龙:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/28a00289502106159ca25e2091bbb580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I630zCbTzIUK1bnTwsCeeQ.png"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">邮递员:得到所有口袋妖怪</p></figure><p id="038f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">恭喜你！我们的小火龙已经发展成为一个Charmeleon，我们已经成功地实现了所有基本的CRUD函数和它们各自的路由。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="de06" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">处理_id和__v</h1><p id="8612" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">最后但同样重要的是，我们将处理<code class="fe oj ok ol ob b">_id</code>和<code class="fe oj ok ol ob b">__v</code>字段。这是由Mongoose自动生成的两个字段。让我们来看看它们各自代表了什么，以及我们可以对它们做些什么:</p><ul class=""><li id="8c08" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">版本密钥:<code class="fe oj ok ol ob b">__v</code>是Mongoose自动添加到每个文档中的版本密钥。每当我们执行对数组进行修改的操作时，都会更新这个版本键，该操作可能会改变数组中任何元素的位置。因此，这是一个重要的领域，除非我们知道我们在做什么，否则我们不应该禁用它。如果我们不喜欢这个名字，我们可以通过在模式中添加一行简单的代码来改变它:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">自定义版本密钥</p></figure><p id="42fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们想要禁用它，我再一次提醒你，你应该只在你知道你在做什么的情况下才这样做，我们可以将<code class="fe oj ok ol ob b">versionKey</code>属性设置为false，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">禁用版本密钥</p></figure><p id="b5db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="oo">注意:亚伦·赫克曼有一篇很棒的文章，深入探讨了</em> <code class="fe oj ok ol ob b"><em class="oo">versionKey</em></code> <em class="oo">。这里的</em>  <em class="oo">你可以读一下</em> <a class="ae lz" href="http://aaronheckmann.blogspot.com/2012/06/mongoose-v3-part-1-versioning.html" rel="noopener ugc nofollow" target="_blank"> <em class="oo">。</em></a></p><ul class=""><li id="ab07" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">Mongoose ID:默认情况下，mongose向我们的模式添加了一个<code class="fe oj ok ol ob b">_id</code>属性。然后，每当我们从一个模式创建一个模型时，Mongoose自动创建一个ObjectId类型的新的<code class="fe oj ok ol ob b">_id</code>。由于<code class="fe oj ok ol ob b">_id</code>是Mongoose使用的唯一标识符，所以我们无法摆脱它。我们可以做的是，每当我们向客户发送我们的模型时，将其重命名为<code class="fe oj ok ol ob b">id</code>，因为老实说，<code class="fe oj ok ol ob b">_id</code>看起来不太好。要重命名它，我们所要做的就是将下面的代码添加到我们的<code class="fe oj ok ol ob b">app.ts</code>文件中的<code class="fe oj ok ol ob b">setMongoConfig</code>方法中:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">将_id重命名为id</p></figure><p id="e41e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们回到Postman，检查一下<code class="fe oj ok ol ob b">_id</code>确实已经被重命名为<code class="fe oj ok ol ob b">id</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/9001292bed35a9bb29fa1e9ca5d5f12e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fmFONk1qQozU4RbfjOquMQ.png"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">邮递员:得到所有口袋妖怪</p></figure><p id="1d19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">瞧啊！我们不再有丑陋的<code class="fe oj ok ol ob b">_id</code>领域。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="6ba5" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结论</h1><p id="8a30" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">在这篇文章中，我们学习了如何通过Mongoose模型和文档来查询MongoDB。我们还实现了访问CRUD函数的路径。</p><p id="d26a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想看这篇文章的完整代码，你可以在PokeAPI项目的这个分支<a class="ae lz" href="https://github.com/puntotech/pokeAPI/tree/03-routes" rel="noopener ugc nofollow" target="_blank">中看到。</a></p><p id="7034" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">非常感谢你的阅读，我希望你能喜欢这篇文章并觉得有用。请随意与您的朋友和/或同事分享，如果您有任何意见，请随时联系我！</p></div></div>    
</body>
</html>