<html>
<head>
<title>The Technical Interview Guide to Array Transformations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数组转换的技术面试指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-technical-interview-guide-to-array-transformations-91e23839d19c?source=collection_archive---------7-----------------------#2020-10-29">https://betterprogramming.pub/the-technical-interview-guide-to-array-transformations-91e23839d19c?source=collection_archive---------7-----------------------#2020-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="be6b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用于面试准备和日常编码的数组转换的JavaScript指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/65e94b4d059a688f8ff93a6c1dc723b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GzRlU0gr0c53A-OM9MixMA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="87dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">数组</a>是一个类似列表的对象，它有执行遍历和变异操作的方法。我们已经在另一篇文章中回顾了数组API。今天我们来看看一些常见的数组变换面试问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5397" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">旋转一维数组</h1><p id="6344" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">给定一个数组，我们可以将每个元素旋转k步。如果到达数组的末尾，元素将旋转到数组的开头。以<code class="fe mz na nb nc b">[1, 2, 3, 4, 5 , 6, 7]</code>为例。将数组旋转一步将导致<code class="fe mz na nb nc b">[7, 1, 2, 3, 4, 5 , 6]</code>。将阵列旋转两步将导致<code class="fe mz na nb nc b">[6, 7, 1, 2, 3, 4, 5 ]</code>。将数组旋转九步将得到<code class="fe mz na nb nc b">[6, 7, 1, 2, 3, 4, 5 ]</code>。这相当于将阵列旋转两步(<code class="fe mz na nb nc b">9 % 7</code>)。当k为负时，它旋转到前面，即旋转阵列<code class="fe mz na nb nc b">-4</code>步将导致<code class="fe mz na nb nc b">[5 , 6, 7, 1, 2, 3, 4]</code>。这相当于将阵列旋转3 ( <code class="fe mz na nb nc b">7 - 4</code>)步。</p><p id="4456" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是将数组中的每个元素旋转k步的算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8183" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以上算法是基于直觉。它有一些边界需要处理。</p><p id="d7bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有另一种方法来完成它。下面是一个长度为7的数字数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/4a31d339cf72e9cf7ec93e51f2e9b64c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GHvWO-CCP-wXi_5zFg-9tA.png"/></div></div></figure><p id="1007" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">反转后的数组如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/b8f397825b7718c1f1a7eac1712a1c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DRwfDI06RslK2fiT_83IrA.png"/></div></div></figure><p id="5c40" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设k已经被减少到<code class="fe mz na nb nc b">[0, nums.length -1]</code>的范围内，旋转数组k步中的元素将最后k个元素移动到前面。相当于把反转后的数组从0反转到<code class="fe mz na nb nc b">k — 1</code>，从k反转到<code class="fe mz na nb nc b">nums.length -1</code>。</p><p id="384f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果k = 3，反转<code class="fe mz na nb nc b">[7, 6, 5]</code>和<code class="fe mz na nb nc b">[4, 3, 2, 1]</code>与旋转<code class="fe mz na nb nc b">[1, 2, 3, 4, 5 , 6, 7]</code>三步的效果相同:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/dc375a2ce5c54e8bd23c812e52619613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7pmYLRIvH_Z-9Ju6yCbsNA.png"/></div></div></figure><p id="f5f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是通过反转三个数组来旋转数组中每个元素的算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cd8c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那不是更整洁吗？</p><p id="e47e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是对两种算法的验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="44eb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">转置二维数组</h1><p id="9a3e" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">给定一个2D数组，我们可以通过沿主对角线翻转元素来转置该数组，即，将点<code class="fe mz na nb nc b">[i][j]</code>转置到点<code class="fe mz na nb nc b">[j][i]</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/551907d2e2e6f9a0ad743e0e9f53bf2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p6zvCSRECef0mUWrEyrH0Q.png"/></div></div></figure><p id="13ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是转置2D数组的算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7924" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d44e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">旋转二维数组</h1><p id="cc4e" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">给定一个2D数组，我们可以将它顺时针旋转90 <strong class="la iu"> </strong>。</p><p id="92d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果给我们一个左下方的数组，顺时针旋转90度<strong class="la iu"> </strong>就成了右下方的数组。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/8244224368a330465dbad3e05aaac52a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IxIHeeWwfnophrLLxJPwiQ.png"/></div></div></figure><p id="1379" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们执行原地旋转，假设数组是一个n×n数组。下图显示了四个角的数组索引:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/61c0bdcf78e23b2f553d36a5ade49317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V7I4N57uEHC8eZQpd-EWxg.png"/></div></div></figure><p id="2b2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要旋转[i][j]处的元素及其相关元素:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/939e3fccd7f83c2b35787296af09b857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IKsnzXs2Fj5Bc8skQZ58Zg.png"/></div></div></figure><p id="db14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是旋转2D数组中每四对元素(上、右、下、左)的算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="13f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">旋转1D阵列有一条捷径。旋转2D阵列有捷径吗？是的，确实如此。</p><p id="d1d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们绘制主对角线，并通过沿主对角线翻转元素来转置数组。这将生成右下方的数组。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/96cd4bf05502c83fe11c437c2351e1ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FF-4J_ISmMAZqHWUq_KPVQ.png"/></div></div></figure><p id="2a9f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">观察转置的数组。原来的行变成了列。它几乎是目标数组，只是需要反转行(沿中间的Y轴翻转)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/0c01854fb97625947124cfc53e8ac4f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B0BGZakvPRagoZuBRqE4ug.png"/></div></div></figure><p id="140b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是通过沿主对角线转置并反转所有行来旋转2D数组的算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9410" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是对两种算法的验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0e51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果面试题要求我们将一个2D阵列逆时针旋转90°<strong class="la iu"/>，我们该如何处理这个问题？</p><p id="c263" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">步骤1:沿着主对角线转置数组。这将生成右下方的数组。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/96cd4bf05502c83fe11c437c2351e1ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FF-4J_ISmMAZqHWUq_KPVQ.png"/></div></div></figure><p id="eab7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">步骤2:反转列(沿着中间的X轴翻转)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/83eb5241a15f3c038ca6f90a360b1880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jStNVwyPMisxk_zmMKUfVw.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a29c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">以螺旋顺序遍历</h1><p id="09ce" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">2D数组的螺旋顺序是从左上角开始，以顺时针方向遍历所有元素，直到到达数组的中间。</p><p id="5161" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个3x3阵列的螺旋顺序示例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/bef64b98ab231a8c3df5208009db99de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OqjVA2qtNxMv0Jn5Y6J2pA.png"/></div></div></figure><p id="d70f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是以螺旋顺序遍历2D数组的算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="57a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dd93" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">搜索二维数组</h1><p id="d224" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">升序2D数组是一个数字数组，其元素值从左到右、从上到下递增。我们被要求编写一个算法来搜索排序数组中的目标值。</p><p id="5cca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，下图中有三个2D升序数组(A、B和C)。尝试搜索目标值，6。a和B返回真，C返回假。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/87b0e4a78184b5998fd7d1995c433bd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zrvo6iQAnDdjX0ndZupWUw.png"/></div></div></figure><p id="2cf7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以将其视为从左上角到右下角的1D阵列。那么这个问题就变成了一个二分搜索法问题。</p><p id="cd3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是在升序2D数组中搜索目标值的算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="217d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面是一个二分搜索法，在一个超级指数和2D指数之间有一些指数转换。</p><p id="bdcb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还可以检查每行的目标是否是该行的一部分(小于或等于该行的最后一个元素)。算法是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4d3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是对两种算法的验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="180d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">优化稀疏矩阵乘法</h1><p id="4411" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/Matrix_multiplication" rel="noopener ugc nofollow" target="_blank">矩阵乘法</a>是从两个矩阵产生一个矩阵的运算。第一个矩阵中的列数必须等于第二个矩阵中的行数。结果矩阵具有第一矩阵的行数和第二矩阵的列数。下面是一个2×3矩阵乘以3×2矩阵得到2×2矩阵的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/1033ee668f76208e5ca57f8f7934c218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zthwoJOoc7pBC2IoWNMDUQ.png"/></div></div></figure><p id="8f16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">稀疏矩阵是大部分元素为零的矩阵。对于有多少元素需要为零才能被认为是稀疏的，没有严格的定义。通常非零元素的数量大约是行数或列数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/0e0ed9b03b476bf9d16693fae8c7348c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KLsJW_BgoupQtcfuZvXpsw.png"/></div></div></figure><p id="6df6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了得到结果<code class="fe mz na nb nc b">C = A x B</code>，每个元素可以计算如下:</p><ul class=""><li id="8fcc" class="nn no it la b lb lc le lf lh np ll nq lp nr lt ns nt nu nv bi translated"><code class="fe mz na nb nc b">C[i][j] = A[i][k] * B[k][j]</code>对于每k。</li></ul><p id="8d69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果是稀疏矩阵，如果<code class="fe mz na nb nc b">A[i][k]</code>为0或者<code class="fe mz na nb nc b">B[k][j]</code>为0，可以节省大量计算。</p><p id="6e50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是执行稀疏矩阵乘法的算法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2c86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以修改上述算法，以便从生成非零数据数组。这样可以节省检查中的元素是否为零的时间。如果B有很多列，这可能会提高性能。</p><p id="409a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是通过从一个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="25a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4583" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">优化矩阵链乘法</h1><p id="4baf" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">矩阵乘法是结合律。对于三个矩阵A、B和C，<code class="fe mz na nb nc b">(A x B) x C = A x (B x C)</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/a135372c603b3a19d017f4f9d0d23d3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fs9c8KIAiQ4zSjJCz1ZnVw.png"/></div></div></figure><p id="7235" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，乘法计数是不同的:</p><ul class=""><li id="f1c5" class="nn no it la b lb lc le lf lh np ll nq lp nr lt ns nt nu nv bi translated"><code class="fe mz na nb nc b">(A x B) x C</code>的乘法计数是10。</li><li id="17da" class="nn no it la b lb nx le ny lh nz ll oa lp ob lt ns nt nu nv bi translated"><code class="fe mz na nb nc b">A x (B x C)</code>的乘法计数是14。</li></ul><p id="b410" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当链很长时，优化乘法阶数对于提高性能至关重要。</p><p id="02c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们写一个算法来找出最小乘法计数。这里给我们一个矩阵索引的数组，<code class="fe mz na nb nc b">nums</code>，它代表了一个矩阵链，维数分别为<code class="fe mz na nb nc b">nums[0] x nums[1]</code>、<code class="fe mz na nb nc b">nums[1] x nums[2]</code>、...，<code class="fe mz na nb nc b">nums[nums.length — 2] x nums[nums.length — 1]</code>。这里通常采用<a class="ae lu" href="https://medium.com/better-programming/the-technical-interview-guide-to-dynamic-programming-3ce755d99849" rel="noopener">动态规划</a>。<code class="fe mz na nb nc b">dp[i][j]</code>代表从<code class="fe mz na nb nc b">matrix[i]</code>到<code class="fe mz na nb nc b">matrix[j]</code>的最小乘法计数。</p><ul class=""><li id="7230" class="nn no it la b lb lc le lf lh np ll nq lp nr lt ns nt nu nv bi translated"><code class="fe mz na nb nc b">dp[i][j] = Math.max(dp[i][k] + dp[k + 1][j] + nums[i — 1] x nums[k] x nums[j])</code>，对于每一个<code class="fe mz na nb nc b">i ≤ k &lt; j</code>。</li></ul><p id="25c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是找出给定矩阵链索引的最小乘法计数的算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f1ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1112" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="0462" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">数组变换问题有很多种。熟能生巧。享受编码。</p><p id="6706" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae lu" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p></div></div>    
</body>
</html>