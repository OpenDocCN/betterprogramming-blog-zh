<html>
<head>
<title>Why RSpec Tests Fail (and How To Fix Them)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RSpec测试失败的原因(以及如何修复它们)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-rspec-tests-fail-and-how-to-fix-them-402f1c7dce16?source=collection_archive---------7-----------------------#2019-10-07">https://betterprogramming.pub/why-rspec-tests-fail-and-how-to-fix-them-402f1c7dce16?source=collection_archive---------7-----------------------#2019-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6e06" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">知道如何排除测试故障是一项基本的软件技能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/787a77e5e5dadf01b7bbfcbe652d024b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ywoj4blnnZzAOTzkMlRL8Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">美国宇航局第一次发射，1950年🚀</p></figure><p id="0ae0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">美国宇航局最早发射火箭的尝试是在40年代末和50年代初由无人火箭组成的<a class="ae kv" href="https://en.wikipedia.org/wiki/RTV-G-4_Bumper" rel="noopener ugc nofollow" target="_blank">保险杠</a>计划的一部分。接下来的十年见证了许多次火箭发射——一些成功了，而另一些爆炸了。</p><p id="a129" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在1961年，苏联成功地用第一枚载人火箭将宇航员尤里·加加里送上太空，使他成为历史上第一个遨游太空的人。</p><p id="b227" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与之形成对比的是万虎，一个被称为“第一宇航员”的中国传奇人物。在他的上升过程中，他坐在一把连着几十个火箭的椅子上。这个故事的大多数版本都是杜撰的，胡没能活着再次尝试太空飞行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/3d1c6a54deb19d6891e0867a8a91e9df.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/0*xLkxBlQs7smyYT9W.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">万虎，<a class="ae kv" href="https://en.wikipedia.org/wiki/Wan_Hu" rel="noopener ugc nofollow" target="_blank">百科</a></p></figure><p id="9f04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">万虎的故事是一个警示:在拿重要资源(比如我们的生命)冒险之前，我们应该首先在一个受限的环境中测试我们的想法。</p><p id="bf04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在在航空、汽车、制药、银行和教育领域都能看到软件的身影。这使得软件质量比以往更加重要，软件测试是提高质量的重要部分。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="f99e" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">为什么要测试软件</h1><p id="e521" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">单元测试是针对错误和错误的前线防御。没有自动化测试，生产部署更像是祈祷好运。最终，最终用户成为你的测试对象。</p><p id="d485" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自动化测试在软件开发生命周期(SDLC)的早期捕获错误，导致<a class="ae kv" href="https://abstracta.us/blog/test-automation/true-roi-test-automation/" rel="noopener ugc nofollow" target="_blank">可测量的成本节约</a>和软件质量的整体提高。</p><p id="8cd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，即使当需求非常清晰，并且利益相关者一致时，工程师在将他们对需求的理解转化为可执行代码时也会犯错误。</p><p id="c3e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">错误可以有多种形式，包括逻辑、算术和连接性错误，以及过时的依赖、对数据的假设、糟糕的文档或缺乏适当的版本控制的结果。错误通常也是不可预见的副作用的结果。</p><p id="6890" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单元测试迫使我们批判性地思考，并验证我们的代码表现出某些行为。通过这种方式，测试起到了与编辑器相同的作用，可以防止可能导致语法或类型错误的细微打字错误。</p><p id="2fd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于像Ruby这样的解释型语言来说，这尤其有用，因为许多异常都是运行时错误，而不是编译时错误。</p><p id="d162" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当单元测试在多个类似生产的系统之间被组合并针对真实数据运行时，它们就成为集成测试。这就是像<a class="ae kv" href="https://rspec.info/" rel="noopener ugc nofollow" target="_blank"> RSpec </a>这样的行为驱动开发(BDD)框架异常强大和令人沮丧的地方。</p><p id="1002" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<a class="ae kv" href="https://rubyonrails.org/" rel="noopener ugc nofollow" target="_blank"> Rails </a>非常相似，RSpec结合像<a class="ae kv" href="https://github.com/thoughtbot/factory_bot" rel="noopener ugc nofollow" target="_blank"> factory_bot </a>、<a class="ae kv" href="https://github.com/DatabaseCleaner" rel="noopener ugc nofollow" target="_blank"> DatabaseCleaner </a>、<a class="ae kv" href="https://github.com/teamcapybara/capybara" rel="noopener ugc nofollow" target="_blank"> Capybara </a>、<a class="ae kv" href="https://github.com/travisjeffery/timecop" rel="noopener ugc nofollow" target="_blank"> Timecop </a>和<a class="ae kv" href="https://github.com/vcr/vcr" rel="noopener ugc nofollow" target="_blank"> VCR </a>这样的库，提供了看起来很像<a class="ae kv" href="https://magic-ruby.com/" rel="noopener ugc nofollow" target="_blank"> Ruby Magic </a>的功能。但是一旦您熟悉了这些工具，就有可能对每个系统进行协调和独立的测试。</p><p id="8a8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在花时间编写(和重写)了许多RSpec测试之后，我想指出我在编写和调试测试时遇到的微妙和不那么微妙的问题。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="c5ba" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><em class="mx">RSpec测试如何失败</em></h1><p id="5405" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">测试持续失败<em class="my">或间歇失败<em class="my"/>。</em></p><p id="830f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试中的可重复性很重要，因为如果没有可重复性，开发人员会质疑测试的价值，最终会质疑测试本身(想想吧，有狼来了综合症的男孩)。</p><p id="517d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">持续失败的测试更容易被发现，通常是精神疲劳的结果。</p><p id="489f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">间歇性失败的测试称为<em class="my">片状测试</em> <strong class="ky ir"> </strong>，更难分析。它们通常是由不确定的行为、不可用的外部服务、非事务性更改、关于数据的假设、副作用以及与日期和时间相关的边缘情况引起的。</p><p id="3e72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是RSpec测试失败的原因以及如何修复它们。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="0d67" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">健忘</h1><p id="506b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">磕碰太多或无意磕碰。</p><blockquote class="mz"><p id="79c6" class="na nb iq bd nc nd ne nf ng nh ni lr dk translated">存根为测试过程中的呼叫提供固定的答案，通常对测试程序之外的任何事情都不作出响应。——马丁·福勒，<a class="ae kv" href="https://martinfowler.com/articles/mocksArentStubs.html" rel="noopener ugc nofollow" target="_blank">模仿不是树桩</a></p></blockquote><p id="6636" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">RSpec没有明确要求使用测试间谍来产生<a class="ae kv" href="https://relishapp.com/rspec/rspec-mocks/docs/basics/expecting-messages" rel="noopener ugc nofollow" target="_blank">消息预期</a>。相反，它提供了<code class="fe no np nq nr b"><a class="ae kv" href="http://rspec.info/documentation/2.14/rspec-mocks/RSpec/Mocks/Matchers/Receive.html" rel="noopener ugc nofollow" target="_blank">receive</a></code> <a class="ae kv" href="http://rspec.info/documentation/2.14/rspec-mocks/RSpec/Mocks/Matchers/Receive.html" rel="noopener ugc nofollow" target="_blank">匹配器</a>，可以在任何对象上使用它来预测分支行为。</p><p id="0d7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这种方法提供了更简洁、更方便的语法，但也很容易忘记默认情况下<code class="fe no np nq nr b">receive</code>匹配器存根目标方法。</p><p id="684b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">房地产101告诉我们，房价只会上涨。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c41a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可能想在RSpec中测试这个假设:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c042" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">令我们惊讶的是，当我们运行这个测试时，它失败了，并出现以下错误:</p><pre class="kg kh ki kj gt nu nr nv nw aw nx bi"><span id="5130" class="ny mb iq nr b gy nz oa l ob oc">Failure/Error: expect(house.price).to be &gt; 649000<br/>       expected: &gt; 649000<br/>       got:        649000</span></pre><p id="174d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实证明，<code class="fe no np nq nr b">receive</code>匹配器会存根化目标方法，除非我们使用<code class="fe no np nq nr b">and_call_original</code>来取消存根化。这个没有署名的<code class="fe no np nq nr b">appreciate_a_lot</code>，结果是房价不变。</p><p id="8252" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一种策略是将分支测试与结果测试分开。这保持了测试用例的简洁，避免了不经意间的方法错误。</p><p id="af92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一种更通用的方法是尽可能少地使用存根，以避免测试和生产代码路径之间的差异。最重要的是，与上面的例子不同，<a class="ae kv" href="https://thoughtbot.com/blog/don-t-stub-the-system-under-test" rel="noopener ugc nofollow" target="_blank">不要stub测试中的系统</a>。</p><p id="c588" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TL/DR:记住，存根是<code class="fe no np nq nr b">receive</code>匹配器的默认行为；使用<code class="fe no np nq nr b">and_call_original</code>取消存根，但保留消息预期。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="6f94" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">内存和数据库中的差异</h1><p id="afe9" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">有许多方法可以找到和更新活动记录模型，但是默认情况下，活动记录将使用一个名为<code class="fe no np nq nr b">id</code>的整数列作为表的主键。</p><p id="d4ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终，随着Rails 4.2的出现，出现了GlobalID，一个应用范围内的统一资源标识符(URI)。因此，Rails特性包括主动作业支持，直接传递模型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="fd53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使得将模型作为参数传递给乔布斯变得更加容易。然而，它也掩盖了幕后发生的事情，这可能会在测试过程中造成混乱。</p><p id="40d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">活动作业在内部使用<code class="fe no np nq nr b">GlobalID::Locator.locate</code>来反序列化模型<code class="fe no np nq nr b">GlobalID</code>。然后，它使用主键执行数据库查询。</p><p id="3178" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，编写这样一个测试是很诱人的，因为表面上看起来我们是在直接传递<code class="fe no np nq nr b">user</code>对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="e080" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个测试失败，出现如下错误:</p><pre class="kg kh ki kj gt nu nr nv nw aw nx bi"><span id="2671" class="ny mb iq nr b gy nz oa l ob oc">Failure/Error: expect(user).to receive(:perform_send_welcome_email!)<br/>     <br/>   (#&lt;User:#..&gt;).perform_send_welcome_email!(*(any args))<br/>           expected: 1 time with any arguments<br/>           received: 0 times with any arguments</span></pre><p id="8962" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个测试也失败了，但出现了不同的错误:</p><pre class="kg kh ki kj gt nu nr nv nw aw nx bi"><span id="695b" class="ny mb iq nr b gy nz oa l ob oc">Failure/Error: expect(user.welcome_email_sent?).to eq(true)<br/>     <br/>       expected: true<br/>            got: false<br/>     <br/>       (compared using ==)</span></pre><p id="f222" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个测试都失败了，因为被测试的主题，一个特定的<code class="fe no np nq nr b">User</code>，在数据库中是相同的，但在内存中不是。数据库更改不会自动传播到内存中的模型。</p><p id="b86f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个测试可以使用像<code class="fe no np nq nr b"><a class="ae kv" href="https://relishapp.com/rspec/rspec-mocks/docs/working-with-legacy-code/any-instance" rel="noopener ugc nofollow" target="_blank">expect_any_instance_of(User)</a></code>这样的匹配器，而第二个测试可以用<code class="fe no np nq nr b"><a class="ae kv" href="https://apidock.com/rails/ActiveRecord/Persistence/reload" rel="noopener ugc nofollow" target="_blank">#reload</a></code>轻松完成，它将活动记录与数据库重新同步。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c5ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TL/DR:了解内存和数据库中的差异；根据需要使用<code class="fe no np nq nr b">#reload</code>将记录与数据库重新同步。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="48b7" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">非决定论</h1><p id="160f" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">有时通过，有时失败。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/f8504b1a787d7c6de71d396197271dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CitcuXgLIpXQdotyJP2GIw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://hsm.utimaco.com/solutions/applications/random-number-generator/" rel="noopener ugc nofollow" target="_blank">随机数发生器</a></p></figure><h2 id="c229" class="ny mb iq bd mc oe of dn mg og oh dp mk lf oi oj mm lj ok ol mo ln om on mq oo bi translated">随机性</h2><p id="7ebe" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><a class="ae kv" href="https://engineering.mit.edu/engage/ask-an-engineer/can-a-computer-generate-a-truly-random-number/" rel="noopener ugc nofollow" target="_blank">计算机能生成真正的随机数吗？</a>不尽然，至少在没有特殊硬件的情况下不会。相反，计算机通过从诸如光标移动、按键、硬盘访问等熵池中提取数据来模拟随机性。</p><p id="5934" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些“随机”源然后被组合在一个位置(如<code class="fe no np nq nr b"><a class="ae kv" href="https://en.wikipedia.org/wiki//dev/random" rel="noopener ugc nofollow" target="_blank">/dev/random</a></code>)用于需要伪随机行为的应用。</p><p id="8527" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不管行为是真随机还是伪随机，测试随机性都是相当困难的。不出所料，它也是不确定行为的一个明显来源。考虑一个<code class="fe no np nq nr b">Dice</code>类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8c95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用<code class="fe no np nq nr b">roll</code>应该会返回一个1到6之间的随机数，就像真的骰子一样。</p><p id="1029" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们编写测试来验证这种行为。也许我们还包括一个测试来验证骰子没有以某种方式加权(或者也许这个代码是用于赌博服务的，我们想要不准确的结果)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="53f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在本地进行测试，他们通过了。他们在CI再次通过。几天后，我们注意到第二次测试出现了间歇性故障。最简单的解决办法是完全避免随机性。当这不可能时，我们可以提供一个“种子”给<code class="fe no np nq nr b"><a class="ae kv" href="https://ruby-doc.org/core-2.4.0/Random.html" rel="noopener ugc nofollow" target="_blank">Random</a></code>类。</p><p id="6e2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:这与我们通过手动设置<code class="fe no np nq nr b"><a class="ae kv" href="https://relishapp.com/rspec/rspec-core/docs/command-line/order" rel="noopener ugc nofollow" target="_blank">--seed</a></code>选项来调试随机排序的RSpec测试时使用的过程相同。</p><p id="5fca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">伪随机数发生器(PRNGs)只是将一个输入映射到一个看似随机但确定的序列的函数。使用一个固定的种子为我们提供了一个固定的序列，从而提供了确定性的结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8ed1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，<code class="fe no np nq nr b">total</code>总会让出<code class="fe no np nq nr b">191</code>，并且测试会一直通过！尽管我们也引入了测试和生产条件之间的不一致。幸运的是，这种情况并不常见。</p><h2 id="f8f7" class="ny mb iq bd mc oe of dn mg og oh dp mk lf oi oj mm lj ok ol mo ln om on mq oo bi translated"><strong class="ak">唯一约束</strong></h2><p id="d3f4" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">随机性更有可能表现为在具有唯一约束的模型工厂中随机生成的数据之间的<em class="my">冲突。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="cc48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<code class="fe no np nq nr b">ObjectId</code>或类似UUIDs发生冲突的几率非常低，但与描述重复的概率是1:1000。当需要随机生成的属性时，最简单的解决方案是从更大的随机库中选择。</p><p id="3df8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:<a class="ae kv" href="https://github.com/faker-ruby/faker" rel="noopener ugc nofollow" target="_blank"> Faker </a>是另一个很棒的工具，可以在测试工厂中用来创建独特的结构化数据，而没有冲突的风险。</p><p id="14fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TL/DR:避免测试随机性。如果不能，指定一个种子和/或使用<em class="my">更多</em>随机<em class="my">随机</em>像<code class="fe no np nq nr b"><a class="ae kv" href="https://ruby-doc.org/stdlib-2.5.1/libdoc/securerandom/rdoc/SecureRandom.html" rel="noopener ugc nofollow" target="_blank">SecureRandom</a></code>一样。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="fe34" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">跨测试的状态保存</strong></h1><p id="fb45" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">阿恩·哈特茨的文章很好地总结了这一点:<a class="ae kv" href="https://makandracards.com/makandra/11507-using-before-all-in-rspec-will-cause-you-lots-of-trouble-unless-you-know-what-you-are-doing" rel="noopener ugc nofollow" target="_blank">在RSpec中使用</a> <code class="fe no np nq nr b"><a class="ae kv" href="https://makandracards.com/makandra/11507-using-before-all-in-rspec-will-cause-you-lots-of-trouble-unless-you-know-what-you-are-doing" rel="noopener ugc nofollow" target="_blank">before(:all)</a></code> <a class="ae kv" href="https://makandracards.com/makandra/11507-using-before-all-in-rspec-will-cause-you-lots-of-trouble-unless-you-know-what-you-are-doing" rel="noopener ugc nofollow" target="_blank">会给你带来很多麻烦，除非你知道自己在做什么</a>。</p><p id="4360" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe no np nq nr b">before(:all)</code>在事务块之外创建数据，跨测试持久化更改。</p><p id="cf29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最佳实践(Rspec支持使用<code class="fe no np nq nr b">--order rand</code>选项)是以随机的顺序运行测试，以揭示测试之间隐含的依赖关系。在随机排序的测试之间持续的数据自然会导致不一致。</p><p id="8650" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个关于<em class="my">而不是</em>如何使用<code class="fe no np nq nr b">before(:all)</code>的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8e7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果按照定义的顺序运行测试，第二个测试将会失败:</p><pre class="kg kh ki kj gt nu nr nv nw aw nx bi"><span id="268b" class="ny mb iq nr b gy nz oa l ob oc">Failure/Error: raise AlreadyVotedError<br/><br/># ./voter.rb:26:in `vote'</span></pre><p id="ec14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么RSpec提供惰性求值的<code class="fe no np nq nr b">let</code>和急切求值的<code class="fe no np nq nr b">let! </code>助手方法。<a class="ae kv" href="https://stackoverflow.com/questions/5359558/when-to-use-rspec-let" rel="noopener ugc nofollow" target="_blank">何时使用RSpec </a> <code class="fe no np nq nr b"><a class="ae kv" href="https://stackoverflow.com/questions/5359558/when-to-use-rspec-let" rel="noopener ugc nofollow" target="_blank">let</a></code>提供了更多的细节，但简言之:</p><p id="6f03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总是选择<code class="fe no np nq nr b">let</code>而不是实例变量。</p><p id="1896" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TL/DR:一直用<code class="fe no np nq nr b">let</code>，不要用<code class="fe no np nq nr b">before(:all)</code>。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="5f39" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">网络通话</strong></h1><p id="fec8" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">大多数应用程序依赖第三方服务，如支付处理的<a class="ae kv" href="https://stripe.com/" rel="noopener ugc nofollow" target="_blank"> Stripe </a>或<a class="ae kv" href="https://squareup.com/us/en" rel="noopener ugc nofollow" target="_blank"> Square </a>，日志记录的<a class="ae kv" href="https://www.splunk.com/" rel="noopener ugc nofollow" target="_blank"> Splunk </a>，监控的<a class="ae kv" href="https://newrelic.com/" rel="noopener ugc nofollow" target="_blank"> New Relic </a>。</p><p id="94f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着应用程序会产生大量的网络请求。虽然我们可以相信这些服务提供商的工程师已经彻底测试了他们的客户端库，但是在我们的应用程序中测试这些库的使用也是很重要的。</p><p id="8311" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，并不是所有的客户端库都支持集成测试环境。即使他们这样做了，网络问题也可能导致像这样的测试暂时失败。在编写契约测试时，最好不要超出远程边界进行测试。</p><pre class="kg kh ki kj gt nu nr nv nw aw nx bi"><span id="c1de" class="ny mb iq nr b gy nz oa l ob oc"># --- Caused by: ---<br/># Net::HTTPServerException:<br/>#   503 "Service Unavailable"</span></pre><p id="0e3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是像VCR 这样的工具有用的地方！</p><p id="3d46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">VCR允许开发人员“记录和重放”HTTP交互，包括由第三方工具生成的交互。这使得测试快速、确定、准确，并且不依赖于网络可用性或外部服务。</p><p id="03d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试被包装在一个<code class="fe no np nq nr b">use_cassette</code>块中，以便在第一次执行时，创建一个YAML文件来保存响应。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="58e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于更深入的信息，RubyGuides有一个关于使用和配置VCR 的很好的教程<a class="ae kv" href="https://www.rubyguides.com/2018/12/ruby-vcr-gem/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="8dbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TL/DR:在测试中使用预先录制的HTTP响应来提高整体速度、可靠性和准确性。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="b7e2" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">时间</h1><p id="58e3" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">不是冻结时间。</p><p id="2d73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个月有28-31天，一年有365天，有2027天尼克松是总统。实际上，一个儒略年大约有365.25天(更准确地说是<a class="ae kv" href="https://pumas.jpl.nasa.gov/files/04_21_97_1.pdf" rel="noopener ugc nofollow" target="_blank"> 365.2422天</a>)。</p><p id="173f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，每四年可以被称为闰年，我们只需要多加一天。二月总是得到那一天，因为它是最短的一个月。</p><p id="0df6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些国家如美国(和地区)跨越11个时区，而其他国家如中国只观察一个时区(UTC+8)。然后，出于一些疯狂的原因，一些国家每年两次增加或减少时钟，试图使工作时间与阳光相协调。</p><p id="0ed2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试工作可靠，在01:00-23:00之间。</p><p id="1f3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不用说，时间是非常复杂的，跨边界测试时间是非常困难的。我听说过这种被称为<em class="my">灰姑娘测试</em>的测试，因为它们会在午夜变成南瓜。</p><p id="5662" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让这些测试更加可靠，最好成为一名时间领主…或者至少在RSpec中学会如何冻结和旅行时间。</p><p id="52b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个有许多<code class="fe no np nq nr b">Events</code>的<code class="fe no np nq nr b">Venue</code>模型的例子。如果我们想要一个即将到来的音乐会的列表，我们可以将开始时间与当天进行比较。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0de0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在测试过程中，我们要确保这个范围返回今天发生的或将来会发生的音乐会。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0092" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个测试看起来没问题。它甚至可以从单一来源获得开始时间，以保证一致的增量。如果这个测试在一天的界限内运行，例如在午夜之前(11:59:59pm)，就会出现问题。</p><p id="0c38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果在concert创建期间花费了足够的时间，<code class="fe no np nq nr b">upcoming_concerts</code>可能会在第二天被调用，导致第一个期望失败。</p><p id="2fd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用<code class="fe no np nq nr b">Timecop</code>解决这个问题最简单的方法是冻结时间<code class="fe no np nq nr b">before :each</code>并返回<code class="fe no np nq nr b">after :each</code>。这样，在测试期间，时间在之间流逝<em class="my">,而不是<em class="my">。</em></em></p><p id="356d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TL/DR:使用<a class="ae kv" href="https://github.com/travisjeffery/timecop" rel="noopener ugc nofollow" target="_blank"> Timecop </a>在RSpec中冻结和可预测地移动时间；防御性地测试时间界限和边缘案例。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="c067" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">副作用</h1><h2 id="a523" class="ny mb iq bd mc oe of dn mg og oh dp mk lf oi oj mm lj ok ol mo ln om on mq oo bi translated"><strong class="ak">活动记录回调</strong></h2><p id="c640" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">活动记录提供了方便的生命周期<a class="ae kv" href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks.html" rel="noopener ugc nofollow" target="_blank">回调</a>在状态改变前后，易于“设置和忘记”。彻底的测试应该包括这些回调，但是有时有必要回避它们。</p><p id="c419" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是<code class="fe no np nq nr b"><a class="ae kv" href="https://apidock.com/rails/ActiveSupport/Callbacks/Callback/ClassMethods/skip_callback" rel="noopener ugc nofollow" target="_blank">skip_callback</a></code>的用武之地。它既可以用于规范工厂，也可以用于单独的测试。考虑一款<code class="fe no np nq nr b">User</code>车型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="7b18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然stub <code class="fe no np nq nr b">send_welcome_email</code>是可能的，但是在现实世界的应用程序中，这个方法可能被深埋在堆栈跟踪中，结果只是许多回调中的一个。</p><p id="af66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，也许回调应该在一个任务之前异步运行，但是所有的任务都是为了一个特定的测试而内联运行的。无论是哪种情况，都可以指示活动记录跳过特定模型的回调。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1662" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可能需要一个<code class="fe no np nq nr b">User</code>模型才能将<code class="fe no np nq nr b">Address</code>视为住宅。</p><p id="b160" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在<code class="fe no np nq nr b">perform_enqueued_jobs</code>块中创建<code class="fe no np nq nr b">User</code>并将其与<code class="fe no np nq nr b">Address</code>相关联会触发创建后回调，并最终触发<code class="fe no np nq nr b">SendWelcomeEmail</code>作业。</p><p id="2d55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也就是说，应该避免跳过回调，以支持更显式的工厂、记录的网络调用和特定于环境的配置。</p><p id="0650" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，在“测试”环境中，发送电子邮件可以在ActionMailer 中全局处理<a class="ae kv" href="https://stackoverflow.com/questions/19983221/actionmailer-testing-with-rspec" rel="noopener ugc nofollow" target="_blank">。如果您选择<code class="fe no np nq nr b">skip_callback</code>，记得调用<code class="fe no np nq nr b"><a class="ae kv" href="https://api.rubyonrails.org/classes/ActiveSupport/Callbacks/ClassMethods.html#method-i-set_callback" rel="noopener ugc nofollow" target="_blank">set_callback</a></code>来恢复其他测试的回调。</a></p><p id="92cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TL/DR: <code class="fe no np nq nr b"><a class="ae kv" href="https://apidock.com/rails/ActiveSupport/Callbacks/Callback/ClassMethods/skip_callback" rel="noopener ugc nofollow" target="_blank">skip_callback</a></code>可避免主动记录回调，但慎用。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="81b7" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">活动作业队列适配器</strong></h1><p id="c738" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">活动记录回调的一个常见用例是将活动作业排队。在底层，活动作业被配置为使用特定的<a class="ae kv" href="https://api.rubyonrails.org/classes/ActiveJob/QueueAdapters.html" rel="noopener ugc nofollow" target="_blank"> QueueAdapter </a>。这个适配器决定了队列的顺序(如FIFO、LIFO等)。</p><p id="f5c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">RSpec的一个常见适配器是<a class="ae kv" href="https://api.rubyonrails.org/classes/ActiveJob/QueueAdapters/TestAdapter.html" rel="noopener ugc nofollow" target="_blank"> TestAdapter </a>，它可用于验证特定作业是否成功入队。</p><p id="7e07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，TestAdapter在默认情况下并不实际执行这项工作！</p><p id="4d4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据您测试的内容，还有其他的适配器，比如InlineAdapter 中的<a class="ae kv" href="https://api.rubyonrails.org/classes/ActiveJob/QueueAdapters/InlineAdapter.html" rel="noopener ugc nofollow" target="_blank">，它们通过像<code class="fe no np nq nr b">perform_now</code>一样处理<code class="fe no np nq nr b">perform_later</code>调用来立即执行作业。</a></p><p id="0ab7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，TestAdapter有一个方法<code class="fe no np nq nr b">perform_enqueued_jobs</code>，顾名思义，它实际上同步执行排队的作业。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="279c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与回调一样，无论是否实际执行工作，测试都是有价值的。RSpec提供了有用的活动工作匹配器，如<code class="fe no np nq nr b"><a class="ae kv" href="https://relishapp.com/rspec/rspec-rails/docs/matchers/have-enqueued-job-matcher" rel="noopener ugc nofollow" target="_blank">have_enqueued_job</a></code>匹配器。</p><p id="438d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些助手方法允许分离关注点，使得在一个规范中测试作业的逻辑，而在另一个规范中测试触发作业的逻辑成为可能。</p><p id="62cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TL/DR:使用<code class="fe no np nq nr b">TestAdapter</code>来跟踪和执行排队的活动作业。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="194e" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">太具体了</h1><p id="e891" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">排序不一致的数据。</p><p id="2c66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像<em class="my">散列</em>和<em class="my">数组</em>这样的集合用于存储相关数据，并且都是按照插入顺序枚举的。</p><p id="df3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在测试过程中，这导致了隐式特定于顺序的比较，通常是在创建和比较活动记录模型集合时。例如，一个<code class="fe no np nq nr b">Cat</code>可以有多个<code class="fe no np nq nr b">toys</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="904c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后编写一个简单的测试来确认一个<code class="fe no np nq nr b">Cat</code>实际上可以有许多玩具。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="a3af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/thoughtbot/factory_bot" rel="noopener ugc nofollow" target="_blank"> factory_bot </a>的<code class="fe no np nq nr b">create_list</code>助手创造了三个与我们的猫Lovie相关的玩具。</p><p id="63ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的问题是，虽然<code class="fe no np nq nr b">create_list</code>将返回creation一贯订购的三个独特的玩具，但协会将根据订购范围返回。如果没有提供订单，则默认为按ID排序。</p><p id="188a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于顺序id，这不会造成问题，因为按创建或顺序排序应该是相同的。然而，<code class="fe no np nq nr b">ObjectID</code>的前四个数字代表自Unix纪元以来的秒数。</p><p id="89ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不使用<code class="fe no np nq nr b">eq</code>来比较两个数组，我们可以使用冗余命名的<code class="fe no np nq nr b">match_array</code>匹配器，它与顺序无关。</p><p id="b8ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TL/DR:在与排序无关的情况下比较集合时，使用<code class="fe no np nq nr b">hash_including</code>、<code class="fe no np nq nr b">include</code>和<code class="fe no np nq nr b">match_array</code>。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="509b" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">负面测试预期</strong></h1><p id="122b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">阴性测试是一个特例。与正面测试不同，非常容易编写过度具体的测试，最终什么也测试不到。考虑一个方法中的代码路径，它不会引发自定义错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5381" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对<code class="fe no np nq nr b">price_per_sq_ft</code>的测试可能看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2405" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个测试期望出现错误，而第二个测试期望出现错误<em class="my">而不是</em>。第二个测试的问题是微妙的，但幸运的是这是一个很常见的事件，RSpec实际上默认警告开发人员。</p><p id="a65a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">警告</strong>:</p><p id="c083" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe no np nq nr b">expect { }.not_to raise_error(SpecificErrorClass)</code>会有误报的风险，因为任何其他错误都会导致期望通过，包括Ruby提出的错误(例如<code class="fe no np nq nr b">NoMethodError</code>、<code class="fe no np nq nr b">NameError</code>和<code class="fe no np nq nr b">ArgumentError</code>)，这意味着您想要测试的代码甚至可能无法到达。</p><p id="5f7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而是考虑使用<code class="fe no np nq nr b">expect { }.not_to raise_error` or `expect { }.to raise_error(DifferentSpecificErrorClass)</code>。</p><p id="73b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">RSpec警告清楚地解释了该测试的问题。</p><p id="8211" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，第二个测试实际上引发了<code class="fe no np nq nr b">TypeError: nil can’t be coerced into Fixnum</code>，因为我们没有定义<code class="fe no np nq nr b">@sq_ft</code>！这就是过于具体的负面测试的问题，他们可能会错过像这样的真正问题。</p><p id="2933" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TL/DR:偏爱阳性测试胜过阴性测试；更广泛地编写负面测试，尤其是在错误处理方面。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ef8a" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">资源</h1><p id="2216" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">有很多关于使用Ruby、Rails、active record、RSpec、factory_bot和自动化测试的优秀文章。</p><p id="6cb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是我发现的几个特别有用的例子。</p><ul class=""><li id="2f76" class="op oq iq ky b kz la lc ld lf or lj os ln ot lr ou ov ow ox bi translated"><a class="ae kv" href="https://www.betterspecs.org/" rel="noopener ugc nofollow" target="_blank">更好的规格</a>。</li><li id="caf1" class="op oq iq ky b kz oy lc oz lf pa lj pb ln pc lr ou ov ow ox bi translated"><a class="ae kv" href="https://rspec.rubystyle.guide/" rel="noopener ugc nofollow" target="_blank"> RSpec风格指南</a>。</li><li id="98a6" class="op oq iq ky b kz oy lc oz lf pa lj pb ln pc lr ou ov ow ox bi translated">有时会失败的测试。</li><li id="237c" class="op oq iq ky b kz oy lc oz lf pa lj pb ln pc lr ou ov ow ox bi translated"><a class="ae kv" href="https://thoughtbot.com/blog/its-about-time-zones" rel="noopener ugc nofollow" target="_blank">关于时间(时区)</a>。</li><li id="67d5" class="op oq iq ky b kz oy lc oz lf pa lj pb ln pc lr ou ov ow ox bi translated"><a class="ae kv" href="https://softwareengineering.stackexchange.com/questions/147134/how-should-i-test-randomness" rel="noopener ugc nofollow" target="_blank">我应该如何测试随机性？</a></li><li id="56f2" class="op oq iq ky b kz oy lc oz lf pa lj pb ln pc lr ou ov ow ox bi translated"><a class="ae kv" href="https://hackernoon.com/flaky-tests-a-war-that-never-ends-9aa32fdef359" rel="noopener ugc nofollow" target="_blank">古怪的测试——永无止境的战争</a>。</li><li id="af11" class="op oq iq ky b kz oy lc oz lf pa lj pb ln pc lr ou ov ow ox bi translated"><a class="ae kv" href="https://spin.atomicobject.com/2012/08/09/rspec-thank-you-for-running-my-tests-in-random-order/" rel="noopener ugc nofollow" target="_blank"> RSpec:感谢您以随机顺序运行我的测试</a></li><li id="2c9b" class="op oq iq ky b kz oy lc oz lf pa lj pb ln pc lr ou ov ow ox bi translated"><a class="ae kv" href="https://medium.com/better-programming/how-to-set-up-rails-with-rspec-capybara-and-database-cleaner-aacb000070ef" rel="noopener">如何用RSpec、Capybara、Database_cleaner设置Rails】。</a></li><li id="740a" class="op oq iq ky b kz oy lc oz lf pa lj pb ln pc lr ou ov ow ox bi translated"><a class="ae kv" href="https://medium.com/@fistsOfReason/testing-is-good-pyramids-are-bad-ice-cream-cones-are-the-worst-ad94b9b2f05f" rel="noopener">检测良好。金字塔不好。冰淇淋甜筒最难吃</a>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/3eefb7a647f8ce9c1fcc6be8b32d721b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*Hhhtpg8HTH18MYWdzfuqRQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">单元测试的基础知识</p></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="bcd8" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">最后的想法</h1><blockquote class="mz"><p id="5200" class="na nb iq bd nc nd ne nf ng nh ni lr dk translated">在满足时间表的甜蜜被遗忘后，质量差的痛苦仍然存在。</p></blockquote><p id="51f3" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">测试失败可能会令人沮丧，尤其是当不清楚失败的原因时。然而，不要忘记测试背后的总体目标:验证行为，并提醒工程师潜在变化背后的意外后果。</p><p id="2bd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管失败的测试令人沮丧，但是没有测试会导致不可预测和不可靠的部署。随着软件系统规模和复杂性的增长，直接投入生产的风险也在增长。另一种方法是按下代码，然后交叉手指。</p><p id="285e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，如果在回顾了这些例子之后，你的测试仍然失败，那么总有可能是因为<strong class="ky ir"> </strong>有一个bug！</p><p id="f58d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">毕竟，这就是测试的目的:在SDLC的早期识别bug。在测试期间捕获bug比在生产中捕获bug更好(也更便宜)。</p><p id="b537" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快乐的虫子挤压！</p></div></div>    
</body>
</html>