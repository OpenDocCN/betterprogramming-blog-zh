<html>
<head>
<title>Localization Changes in Java 9</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 9中的本地化变化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/localization-changes-in-java-9-c05ffde8cc2f?source=collection_archive---------10-----------------------#2020-07-20">https://betterprogramming.pub/localization-changes-in-java-9-c05ffde8cc2f?source=collection_archive---------10-----------------------#2020-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4d6f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">当日期和时间打破了我们的项目</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/83bbc592e580174244bcd0b3b3a1930f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BTaDt6rB0Q8LeE3bOCdqGA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@agent_illustrateur?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯汀·罗伊</a>在<a class="ae ky" href="https://unsplash.com/s/photos/world-map?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="4aea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe lv lw lx ly b">java.util.Locale</code>来格式化日期、数字、货币等等。但是在某些情况下，这些格式化的字符串随着<a class="ae ky" href="https://www.oracle.com/java/technologies/javase/v9-issues-relnotes.html#JDK-8008577" rel="noopener ugc nofollow" target="_blank"> JDK 9 </a>发生了变化，导致了大量微妙的(有时不那么微妙的)错误。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6bad" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">TABLE OF CONTENTS</strong></span><span id="e61d" class="md me it ly b gy mj mg l mh mi"><a class="ae ky" href="#b698" rel="noopener ugc nofollow">What Are Locales?</a><br/><a class="ae ky" href="#ea74" rel="noopener ugc nofollow">Where Do Locales Come From?<br/></a><a class="ae ky" href="#67e8" rel="noopener ugc nofollow">What Changed With JDK 9?</a><br/><a class="ae ky" href="#490a" rel="noopener ugc nofollow">How to Deal With the Changes<br/></a><a class="ae ky" href="#1847" rel="noopener ugc nofollow">Conclusion</a></span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="b698" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">什么是区域设置？</h1><p id="5f38" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">为了更好地理解一个问题，我们必须首先知道我们在处理什么。</p><blockquote class="nn"><p id="2d02" class="no np it bd nq nr ns nt nu nv nw lu dk translated"><em class="nx">“区域设置是一组参数，用于定义用户的语言、地区以及用户希望在其用户界面中看到的任何特殊变量首选项”——</em><a class="ae ky" href="https://en.wikipedia.org/wiki/Locale_(computer_software)" rel="noopener ugc nofollow" target="_blank"><em class="nx">维基百科</em> </a></p></blockquote><p id="21e3" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">区域设置的核心用途是格式化多种不同的数据以供输出:</p><ul class=""><li id="fd42" class="od oe it lb b lc ld lf lg li of lm og lq oh lu oi oj ok ol bi translated">数字</li><li id="271b" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">日期、时间、工作日、纪元等。</li><li id="66e0" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">货币</li><li id="4d88" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">字符串排序</li><li id="b4f4" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">等等。</li></ul><p id="3860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">区域设置由属性层次结构定义:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="0b24" class="md me it ly b gy mf mg l mh mi">&lt;language&gt;[_&lt;COUNTRY&gt;[_&lt;variant&gt;]]</span><span id="a8f0" class="md me it ly b gy mj mg l mh mi">language:  ISO 639 (mandatory)<br/>COUNTRY:   ISO 639 (optional)<br/>variant:   any string (optional)</span></pre><p id="9eae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这三个参数足以定义大多数可能的组合。通常一种语言就足够了，但有时我们需要更具体一些。变体用于进一步指定语言环境:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="c459" class="md me it ly b gy mf mg l mh mi">Locale.<strong class="ly iu">GERMAN</strong>        =&gt; de<br/>Locale.<strong class="ly iu">GERMANY</strong>       =&gt; de_DE</span><span id="6dee" class="md me it ly b gy mj mg l mh mi">Locale.<strong class="ly iu">ENGLISH</strong>       =&gt; en<br/>Locale.<strong class="ly iu">UK</strong>            =&gt; en_GB<br/>Locale.<strong class="ly iu">CANADA</strong>        =&gt; en_CA</span><span id="1bba" class="md me it ly b gy mj mg l mh mi">Locale.<strong class="ly iu">FRENCH</strong>        =&gt; fr<br/>Locale.<strong class="ly iu">CANADA_FRENCH</strong> =&gt; fr_CA</span></pre><p id="4188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不限于预定义的设置，还支持自定义语言环境:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="ea74" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">语言环境来自哪里？</h1><p id="da5c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">一个公认的语言环境来源是“Unicode公共语言环境数据库”(<a class="ae ky" href="http://cldr.unicode.org/" rel="noopener ugc nofollow" target="_blank"> CLDR </a>)。它是世界上最大和最广泛的可用区域数据库，被操作系统、谷歌浏览器、MediaWiki等使用。</p><p id="98ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是就像任何标准一样，它不是语言环境的唯一来源。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/2ce240e4d5f4bf4aa4a0812e2d827654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*9nMBMt-OugnruBr_M-WuEQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">XKCD:标准—<a class="ae ky" href="https://xkcd.com/927/" rel="noopener ugc nofollow" target="_blank">https://xkcd.com/927/</a></p></figure><h2 id="76b7" class="md me it bd ms ou ov dn mw ow ox dp na li oy oz nc lm pa pb ne lq pc pd ng pe bi translated">JDK默认区域设置提供程序</h2><p id="843c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Java从<code class="fe lv lw lx ly b"><a class="ae ky" href="https://hg.openjdk.java.net/jdk9/jdk9/jdk/file/tip/src/java.base/share/classes/sun/util/locale/provider/LocaleProviderAdapter.java" rel="noopener ugc nofollow" target="_blank">LocaleProviderAdapter</a></code>中检索语言环境。在JDK 8之前，默认的提供者是JRE，它有自己的区域设置定义列表。</p><p id="dcc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JRE不是JDK唯一的供应商:</p><ul class=""><li id="333e" class="od oe it lb b lc ld lf lg li of lm og lq oh lu oi oj ok ol bi translated">JRE (Java自己的列表)</li><li id="be91" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">CLDR (Unicode公共语言数据库)</li><li id="3abc" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">SPI(服务提供商接口)</li><li id="ccca" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">主机(由操作系统提供)</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="67e8" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">JDK 9号有什么变化？</h1><p id="801e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><a class="ae ky" href="https://openjdk.java.net/jeps/252" rel="noopener ugc nofollow" target="_blank"> JEP 252 </a>从JDK 9开始，将默认提供者从JRE改为CLDR。这种变化导致微小的差异，最终可能导致大问题。</p><p id="528b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是我们升级到JDK 11号时遇到的问题。</p><h2 id="dbf5" class="md me it bd ms ou ov dn mw ow ox dp na li oy oz nc lm pa pb ne lq pc pd ng pe bi translated">不同的日期格式</h2><p id="c24c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">对我们来说，第一个突破是用Google的<a class="ae ky" href="https://github.com/google/gson" rel="noopener ugc nofollow" target="_blank"> GSON </a>来(反)序列化JSON数据。我们为<a class="ae ky" href="https://mailchimp.com/" rel="noopener ugc nofollow" target="_blank"> Mailchimp </a>用户使用定制的同步服务，保存相关数据。在JDK 11中，我们不再能够读取以前持久存储的数据。</p><p id="3111" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在构建了一些测试场景之后，我们发现了日期格式中的一个细微差别:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f367" class="md me it ly b gy mf mg l mh mi">Before: Jul 15, 2020 2:20:32 AM<br/>After:  Jul 15, 2020, 2:20:32 AM</span></pre><p id="50a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意到年份后面的逗号了吗？这是从哪里突然冒出来的？</p><p id="47af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，<a class="ae ky" href="http://cldr.unicode.org/" rel="noopener ugc nofollow" target="_blank"> CLDR </a>定义的一些格式与以前的JDK略有不同。</p><h2 id="178c" class="md me it bd ms ou ov dn mw ow ox dp na li oy oz nc lm pa pb ne lq pc pd ng pe bi translated">一周什么时候开始？</h2><p id="939f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">另一个问题来自一周的第一天。</p><p id="7160" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在大多数系统中使用的是Apache Tapestry，为了最大的兼容性，我们使用了“纯语言”的语言环境。这意味着我们使用的是<code class="fe lv lw lx ly b">Locale.GERMAN</code> (de)而不是<code class="fe lv lw lx ly b">Locale.GERMANY</code> (de_DE)。</p><p id="222c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之前没有任何问题；所有内容都按照预期的样子进行了格式化。正如所料，一周的第一天是星期一。</p><p id="bf25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们从JDK时间8点转换到11点后，我们的约会对象从周日开始。通过相关代码的调试发现，语言环境仍然是<code class="fe lv lw lx ly b">Locale.GERMAN</code>。但是一周的开始日期被返回为星期日。</p><p id="bbb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发生了什么事？</p><p id="18ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CLDR和JRE provider之间的一个微妙区别是不同种类的格式如何与一个地区的特殊性相关联。JRE提供了周一作为<code class="fe lv lw lx ly b">Locale.GERMAN</code>一周的开始日，尽管它不应该是！</p><p id="b679" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CLDR没有一周的开始日，这仅仅是因为日历不应该被视为语言相关的。相反，一个地区(或者用Java术语来说，一个“国家”)负责定义日历，包括一周的开始日。因此，我们的“纯语言”德语地区突然回落到默认的国家/地区001: Sunday。</p><h2 id="89ba" class="md me it bd ms ou ov dn mw ow ox dp na li oy oz nc lm pa pb ne lq pc pd ng pe bi translated">货币格式</h2><p id="40e3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们有一个简单的货币格式单元测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="c455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它以前运行良好，但现在失败了，因为货币格式发生了重大变化:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4ee1" class="md me it ly b gy mf mg l mh mi">¤ = Unicode Currency Symbol Placeholder</span><span id="bf6f" class="md me it ly b gy mj mg l mh mi"> JDK 8      | JDK 9+<br/>------------|----------------- <br/> ¤ 1.234,99 | 1.234,99\u00a0¤</span></pre><p id="a5f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像本周初一样，问题出在“纯语言”地区。但这一次，情况正好相反。</p><p id="5990" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CLDR <a class="ae ky" href="https://unicode-org.github.io/cldr-staging/charts/37/by_type/numbers.number_formatting_patterns.html" rel="noopener ugc nofollow" target="_blank">确实为基于<code class="fe lv lw lx ly b">de</code>的语言提供了默认的格式</a>，有更具体的模式，例如<code class="fe lv lw lx ly b">de_AT</code>。另一方面，JDK没有针对<code class="fe lv lw lx ly b">de</code>的模式，所以它退回到默认模式。</p><p id="966e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更糟糕的是，一个“不间断空格”现在被用来分隔值和符号。</p><p id="da45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在JDK 8号上使用<code class="fe lv lw lx ly b">Locale.GERMANY</code>而不是<code class="fe lv lw lx ly b">Locale.GERMAN</code>，我们会得到和JDK 11号几乎一样的结果。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="490a" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">如何应对这些变化</h1><p id="e6cb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">既然我们在格式代码中发现了多个重大变化，我们应该如何处理它们呢？</p><h2 id="5fcf" class="md me it bd ms ou ov dn mw ow ox dp na li oy oz nc lm pa pb ne lq pc pd ng pe bi translated">更新我们的依赖性</h2><p id="c046" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">修复我们的GSON问题就像更新依赖关系一样简单。这个问题在<a class="ae ky" href="https://unicode-org.github.io/cldr-staging/charts/37/by_type/numbers.number_formatting_patterns.html" rel="noopener ugc nofollow" target="_blank"> 2.8.3 </a>中得到修复，我们使用的是2.8.2。在Maven依赖地狱中过了一段时间后，(反)序列化再次完美地工作了。</p><h2 id="f41e" class="md me it bd ms ou ov dn mw ow ox dp na li oy oz nc lm pa pb ne lq pc pd ng pe bi translated">适应变化</h2><p id="1e9c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果可能的话，我们应该尽可能多地接受代码中的变化——CLDR的语言环境定义比以前更加准确和深思熟虑。</p><p id="0166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用许多不同系统使用的定义明确的标准，我们可以确保更好的互操作性，并且更面向未来。如果有必要，我们仍然可以将不可修复的代码包装在我们自己的兼容性包装器中，或者自己提供不同的日期格式。</p><h2 id="28e0" class="md me it bd ms ou ov dn mw ow ox dp na li oy oz nc lm pa pb ne lq pc pd ng pe bi translated">兼容模式</h2><p id="2a21" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在软件开发的世界里，技术上正确有时是不可能的。想想遗留代码、不可替代的依赖、我们必须与之交互的封闭系统等等。为什么我们不能仅仅适应特定的变化，原因有很多。</p><p id="27cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们不能适应它们，JDK会支持我们:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="3a1e" class="md me it ly b gy mf mg l mh mi">java -D<em class="pf">java.locale.providers=&lt;order of providers&gt;</em></span><span id="9a84" class="md me it ly b gy mj mg l mh mi">Available providers:<br/>- CLDR (default)<br/>- HOST (OS provided)<br/>- SPI (Service Provider Interface)<br/>- COMPAT (formerly JRE)<br/>- JRE (alternative to JRE, but disfavored over COMPAT)</span></pre><p id="9709" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过指定区域设置提供者的查找顺序，我们可以获得与以前相同的结果，而无需更改一行代码。这可能是最快的修复方法，但是依赖兼容模式很可能会成为一个问题。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="1847" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="0288" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">查看<a class="ae ky" href="https://bugs.openjdk.java.net/browse/JDK-8008577" rel="noopener ugc nofollow" target="_blank"> JDK-8008577 </a>、<a class="ae ky" href="https://bugs.openjdk.java.net/browse/JDK-8145136" rel="noopener ugc nofollow" target="_blank"> JDK-8145136 </a>及其相关子报告中的错误，似乎切换默认提供商的风险和影响并没有得到应有的重视。</p><p id="edba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其实，那其实挺好理解的。根据您使用的语言环境，您甚至可能不会受到任何问题的影响。</p><p id="5343" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，我们应该尽可能地适应变化，否则从长远来看，任何修复都会变成技术债务。JDK 9是一个大规模的发布，有许多突破性的变化，所以它不太可能在一个更大的项目中一切都开箱即用。修正基于区域设置的格式应该明确地列在我们的任务清单上。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="95e9" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">资源</h1><ul class=""><li id="380f" class="od oe it lb b lc ni lf nj li pg lm ph lq pi lu oi oj ok ol bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Locale_(computer_software)" rel="noopener ugc nofollow" target="_blank">语言环境(电脑软件)</a>(维基百科)</li><li id="745b" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><a class="ae ky" href="https://www.oracle.com/java/technologies/javase/v9-issues-relnotes.html#JDK-8008577" rel="noopener ugc nofollow" target="_blank"> JDK 9发布说明</a>(甲骨文)</li><li id="6201" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><a class="ae ky" href="https://openjdk.java.net/jeps/252" rel="noopener ugc nofollow" target="_blank"> JEP 252:默认使用CLDR地区数据</a> (OpenJDK)</li><li id="1f6a" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/9/intl/internationalization-enhancements-jdk-9.htm#JSINT-GUID-AF5AECA7-07C1-4E7D-BC10-BC7E73DC6C7F" rel="noopener ugc nofollow" target="_blank">JDK 9中的国际化增强功能</a>(甲骨文)</li><li id="f9c1" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><a class="ae ky" href="http://cldr.unicode.org/" rel="noopener ugc nofollow" target="_blank"> Unicode公共区域数据库</a></li><li id="c6f6" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/ISO_639" rel="noopener ugc nofollow" target="_blank"> ISO 639 </a>(维基百科)</li><li id="af75" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/ISO_15924" rel="noopener ugc nofollow" target="_blank"> ISO 15924 </a>(维基)</li><li id="10b5" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><a class="ae ky" href="https://www.iso.org/iso-3166-country-codes.html" rel="noopener ugc nofollow" target="_blank"> ISO 3166 </a>(维基)</li><li id="8fc6" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">UN M.49 (维基百科)</li></ul></div></div>    
</body>
</html>