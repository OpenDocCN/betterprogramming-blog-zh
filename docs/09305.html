<html>
<head>
<title>Should You Be Deleting Your Own Code?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该删除你自己的代码吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/should-you-be-deleting-your-own-code-ba77700cf4b8?source=collection_archive---------10-----------------------#2021-08-09">https://betterprogramming.pub/should-you-be-deleting-your-own-code-ba77700cf4b8?source=collection_archive---------10-----------------------#2021-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="100a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">爱上你的代码是你作为开发人员所能做的最糟糕的事情</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/51caaf49ce5c260d12c372f50dfb0a0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8KKpkktPT7oDufMtuyRimw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@lesanches?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">莱昂纳多·桑切斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/love?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的原始照片，由作者编辑</p></figure><p id="479c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">爱上我们自己的代码可能是任何软件开发人员最大的原罪之一。我们对它做得越多，我们就越把它当成自己的孩子看待。</p><p id="84c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创造了它，所以它一定是完美的。然而，有很多时候，我们提出的解决方案在几个小时内就变得毫无用处，仅仅是因为我们意识到有一种更简单的方法。然而，我们重构解决方案了吗？不，我们没有，因为我们<em class="lv">热爱我们的代码</em>。</p><p id="8148" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遗憾的是，这并不好。在这篇文章中，我将解释为什么，相反，你应该遵循斯蒂芬·金的写作建议，学会杀死你的宠儿:</p><blockquote class="lw"><p id="1d96" class="lx ly it bd lz ma mb mc md me mf lu dk translated">"杀了你的宝贝，杀了你的宝贝，即使这会伤了你这个自私的小流氓的心，也要杀了你的宝贝。"</p></blockquote><p id="9e26" class="pw-post-body-paragraph kz la it lb b lc mg ju le lf mh jx lh li mi lk ll lm mj lo lp lq mk ls lt lu im bi translated">这句引用自《恐怖大师》的话可以也应该应用到我们每天的软件实践中。我们需要学会删除我们的解决方案，就像一个作者应该学会删除不必要的人物或没有任何趣味的情节。</p><p id="cc95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们来看看需要记住这条规则的四种情况:</p><h1 id="efa5" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">过于复杂的一行程序</h1><p id="8403" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">当他们在一段不是他们写的代码中发现一个神秘的一行程序时，谁会不喜欢呢？我说的对吗？</p><p id="2a2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">花10分钟阅读一行代码，在头脑中分析它，弄清楚它做了什么，结果只能继续阅读剩下的代码:无价之宝。</p><p id="dc48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码应该由计算机来解析，由人类来阅读。</p><p id="81ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果只关注那句话的前半部分，是写不出代码的。我的意思是你可以，但更确切地说，你不应该——因为你永远不会孤单。即使你是一个人在做自己的项目，也还是需要想想十分钟后的你，或者五个月后的你。你最终会忘记这句话的作用以及你为什么要这样写，所以你必须花很多时间去弄清楚你为什么要这样写。</p><p id="a3c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你试图记住这一点，因为你正在排除一个错误，猜猜10分钟后会发生什么，无法理解你自己的代码:你将重写它。您将尝试根据周围的逻辑来猜测该行做了什么，然后用更容易理解的代码重写它。见鬼，如果其他人试图通过查看您的代码来修复该错误，也会发生这种情况。你的俏皮话在五分钟没有意义后就会消失。</p><p id="4af6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果您(或其他人)可能会在以后摆脱它，为什么还要花费时间和精力来编写这个一行程序呢？请在评论中回答我这个问题。</p><p id="6ae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为，虽然不是所有的一行程序都是邪恶的，但大多数都应该避免。甚至像三元运算符这样基本的东西，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b654" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行代码易于阅读，如果您能确保它不会受到额外的逻辑或代码重构的影响，那么我会让您保留它。否则，你将继续向表达式的第一部分添加条件，当你需要在<code class="fe nk nl nm nn b">:</code>之前或之后增加一个额外的步骤时，你将不得不把它变成一个完整的<code class="fe nk nl nm nn b">if</code>语句。那为什么不从一开始就让你省事，拥有一个<code class="fe nk nl nm nn b">if</code>？</p><p id="ed35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我是说，如果你改写这个，你真的会下地狱吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="2de8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你这样写，没有人会觉得你很可笑。如果他们这样做了，你可以解释这个版本的<code class="fe nk nl nm nn b">if</code>可以成长和扩展，而其他版本不能。</p><p id="8371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，当您编写一行程序时，要确保两件事:</p><ol class=""><li id="334a" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">别人很容易理解。这不仅意味着代码易于阅读，还意味着它有适当的注释来解释其逻辑。</li><li id="0ebc" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">两个月后，你不必因为一个新的业务规则或者一个新特性的加入而重构它。相反，要确保这个一行程序有一个很好的理由，并且会持续很长时间。</li></ol><p id="86c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不能保证这两点，也许你根本不需要一个命令行程序。</p><h1 id="72e1" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">打破范式</h1><p id="c156" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我在我参与的项目中见过这种情况，这真的很痛苦。在选择逻辑范式时，我们都有自己的偏好。</p><p id="f1f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以面向对象，我们可以功能化，或者我们可以选择任何其他选项，这取决于我们使用的技术和我们正在解决的问题。但是我们需要选择一个并让整个团队都遵循它。</p><p id="cc3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么？因为这将确保几件事:</p><ul class=""><li id="0cd2" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu oc nu nv nw bi translated">所有开发人员都可以遵循相同的编码标准。</li><li id="c27e" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated">更容易在不同模块之间重用代码。</li><li id="fad1" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated">阅读代码的不同部分需要相同的思维框架，这就减少了理解整个代码库所需的认知负荷。</li></ul><p id="5046" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的问题是一些语言允许混合使用不同的范例。例如，Python和JavaScript都允许函数式编程的元素与OOP的元素共存。为什么这是一个问题？因为如果你喜欢FP，但被迫从事OOP项目，你仍然可以在你的代码中使用FP，并让它与项目的其他部分交互。当然，现在唯一的问题是，你团队中任何不精通FP的人，将不得不付出双倍的努力来赶上FP，然后阅读你的代码来理解你刚刚犯了什么错误。</p><p id="4a9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上帝保佑，让别人而不是你来修改你的代码或者调试它来寻找问题。很有可能他们最终会将整个事情重写回OOP。</p><p id="7f62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样的话也可以反过来说:在FP项目中强制OOP。你就是不做。</p><p id="d4c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你的团队已经决定了一个范例，那么这个决定本身就构成了你所有的队友用来解决项目问题的心智模型。当你改变范式的时候，你就打破了那个思维模式，你会强迫他们采用一个新的模式。请注意，这不是不可能的，但是这比采用项目的标准要昂贵得多(从认知角度来说)。</p><p id="647f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你绝对可以喜欢和偏爱你选择的任何编程范式，但是请为了对一切神圣和亲爱的事物的热爱:遵循你的项目的标准，包括选择的范式。</p><p id="0cb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅仅因为你使用的语言允许你混合搭配，并不意味着你应该这样做。</p><h1 id="fa2c" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">假设您的代码是自文档化的，因为这对您来说是显而易见的</h1><p id="c5d4" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">您确切地知道您的代码在做什么，因此它不需要任何进一步的文档。</p><p id="37e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不对。</p><p id="a996" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我永远不会厌倦说这句话:你不是一个人在工作。即使你认为你知道，也有可能几年后有人会偶然发现你的作品并试图阅读它。</p><p id="4843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有人甚至可能是你，在未来的几年里，完全忘记了你为什么要写那段代码。</p><p id="9085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有所谓的“显而易见的商业逻辑”。注意我是如何说“业务逻辑”而不是“代码”的因为有明显的代码。我的意思是，你不需要在这一行加上注释来理解它的作用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是你确实需要一个关于这个的评论，不是吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c05a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的意思是，代码并不复杂，但可能有几行代码注释，如下所示:</p><pre class="kj kk kl km gt od nn oe of aw og bi"><span id="8359" class="oh mm it nn b gy oi oj l ok ol">/**<br/> Saves the user to the database.<br/> It receives a "User" object, it generates a random alphanumeric ID and then it tries to save it into the users table.<br/> If sucessfull, it'll return the new generated user ID.<br/> If it fails, it'll return "false" instead.<br/>*/</span></pre><p id="b09f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事情就清楚多了，不是吗？之前，您必须阅读我的代码，对其进行逆向工程，并对其周围的业务逻辑进行假设。然而，现在你有我自己的话来解释它的行为。</p><p id="27a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解代码很大程度上与上下文有关。你不提供，读者就要补了。他们会根据假设来做，而对于每一个假设，总有出错的空间。他们犯的错误越多，错误就越大，直到他们完全误解了你的代码。</p><p id="48de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些都可以避免，只要把你对代码的热爱放在一边，写几行注释解释你刚刚写了什么和为什么写。</p><h1 id="6ee2" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">强迫你的团队使用你自己的库</h1><p id="e1a9" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我很抱歉过去做了太多次。</p><p id="bc13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为开发人员，我们倾向于将功能抽象化。当我们看到一个重复的模式时，我们会想:<em class="lv">这可以变成一个模块/库。</em></p><p id="4e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是看待代码的一种很好的方式，不要误会我的意思，但是问题是当我们将这种倾向发挥到极致，认为我们可以为我们需要的任何东西创建自己的库。</p><p id="046c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多最常见的编程语言周围都有巨大的社区，共享他们自己的工作和时间来创建一个庞大的库和模块生态系统，供其他人使用，并节省他们项目的大量时间和精力。他们免费做这个。</p><p id="77e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果您确信这些库是潜在的安全风险，并且唯一的解决方法是拥有一个零依赖环境，那么您将最终创建所有的实用程序库、框架和任何其他您自己可能需要的可重用代码。</p><p id="c698" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是<a class="ae ky" href="https://medium.com/varietate/here-is-how-you-can-destroy-your-software-developer-career-with-this-one-trait-present-in-everyone-fd38bcb54bc9" rel="noopener">开发人员最好的自我表现</a>:你认为你能比整个开发人员社区做得更好。听着，我明白，你有几十年(如果不是更多的话)的经验，而且你参与过所有类型的项目。这太棒了，但是，你不可能有足够的时间来开发这么多的库而不忽略一些事情:</p><ul class=""><li id="0531" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu oc nu nv nw bi translated">首先，你自己的项目。你工作的二级库越多，你实际推进项目的时间就越少。</li><li id="cf81" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated">质量。这些额外库的质量将会受到影响，因为如果你花时间正确地编码、测试和发布它，你将永远无法回到你自己的项目中。</li><li id="6799" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated">稳定。类似于质量，你不能让你的库代码经历这么多用例，以至于你能在你的代码中找出所有的问题。然而，随着时间的推移，其他人开发的库已经有如此多的用户报告了错误，以至于他们现在可以确保比你高得多的稳定性级别。</li></ul><p id="dff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是技巧的问题；只是时间问题。</p><p id="d1f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要误解我的意思，担心使用外部库会给项目带来安全风险是完全有道理的。事实上，<a class="ae ky" href="https://blog.logrocket.com/the-latest-npm-breach-or-is-it-a427617a4185/" rel="noopener ugc nofollow" target="_blank">过去也有过这种情况</a>，但这并不是像一个疯子一样开始重新发明轮子的理由。相反，试着理解你不能自己做所有的事情，试着采用一些最佳实践:</p><ul class=""><li id="4d4c" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu oc nu nv nw bi translated">选择当前正在使用的库。一个积极维护的存储库意味着它背后有一个团队，如果你需要的话，他们可以给你支持。</li><li id="c859" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated">选择其他人都在使用的库。许多用户已经在非常不同的环境中测试和审查了流行的库。这是一个很好的迹象。</li><li id="18f8" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated">使用您选择的库的固定版本。外部依赖项并不遵循您的发布时间表，它们有自己的发布时间表，如果您不锁定您的依赖项的版本，您可能最终会在您甚至不知道的情况下安装一个对您的项目的新发布有重大更改(或安全问题)的新版本。相反，始终使用相同的版本，如果您需要更新它，请确保在将更新推向生产之前，在您的系统上测试它的工作情况。</li></ul><p id="07dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这三个简单的步骤可以帮助你摆脱对外部依赖的恐惧，并且可以帮助你节省大量的时间，不必自己重新实现所有的东西。</p></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><p id="5dd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自负是开发者的一个大问题。它可以有多种形式，包括对我们自己代码的爱。如果我们不能控制住爱，它可能会成为一个问题。</p><p id="39c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，要学会理解，有时候，你的代码需要重构甚至删除。不管你有多喜欢，都是为了项目好。</p></div></div>    
</body>
</html>