<html>
<head>
<title>Dart Futures: Chaining and Concurrency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dart未来:链接和并发</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dart-futures-chaining-and-concurrency-86dc5a89dd2b?source=collection_archive---------4-----------------------#2022-12-08">https://betterprogramming.pub/dart-futures-chaining-and-concurrency-86dc5a89dd2b?source=collection_archive---------4-----------------------#2022-12-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a69f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">链接期货并处理同步期货看涨期权</em></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl kl"><img src="../Images/678bf4f0c0a590ad15e6eccfe9f70355.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Qs3jUnFDxGbOz-qRpC_u-A.jpeg"/></div><p class="ko kp gj gh gi kq kr bd b be z dk translated">按作者分类的标题图像</p></figure><h1 id="d4cd" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">前言</h1><p id="37c5" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">在我之前的文章中，我解释了Dart中关于期货的基本概念。我已经讨论了它们是如何被设计来帮助我们在单线程环境中通过事件循环处理异步任务的。</p><p id="1d6b" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">我还讨论了我们可以使用的一些构造函数和方法，以及它们的具体用法，这使我们能够优雅地处理异步任务，比如API调用。</p><p id="f5fc" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">在本文中，我将讨论一些围绕<code class="fe mm mn mo mp b">Future</code>类的高级概念。讨论将主要围绕以下主题:</p><ul class=""><li id="acbf" class="mq mr iq lm b ln mh lq mi lt ms lx mt mb mu mf mv mw mx my bi translated">将未来链接在一起，实现异步任务执行的多米诺骨牌效应。</li><li id="a034" class="mq mr iq lm b ln mz lq na lt nb lx nc mb nd mf mv mw mx my bi translated">并发执行多个<code class="fe mm mn mo mp b">Future</code>任务并处理它们的结果。</li></ul><h1 id="7ab2" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">在开始之前</h1><p id="8bfd" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">对于那些直接阅读本文的人来说，他们的兴趣仅仅在于了解链和并发性，而不是在第一篇文章中浏览所有的基础知识，在我们开始之前，让我们回顾一下。</p><p id="d66e" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">Future提供了使我们访问事件循环和管理异步作业变得简单所需的API。它允许我们做许多事情。</p><p id="7b18" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">未来是这样运作的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/a7193ac47a6de5e5a729f86a254c81f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYizDYslLmt7R_ufZi-BIw.jpeg"/></div></div><p class="ko kp gj gh gi kq kr bd b be z dk translated">图1:未来处理异步任务的过程</p></figure><p id="aef7" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">在本文中，我们将建立与上一篇文章相同的实验基础。</p><p id="3cae" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">假设我们开发了一个应用程序，可以让我们更容易地在街对面的当地咖啡店里看到最新的咖啡。</p><p id="fe59" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">我们的热咖啡数据将来自这里:<code class="fe mm mn mo mp b"><a class="ae mg" href="https://api.sampleapis.com/coffee/hot" rel="noopener ugc nofollow" target="_blank">https://api.sampleapis.com/coffee/hot</a></code></p><p id="b71e" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">这个API返回给我们一个热咖啡的数组，单个对象看起来像这样:</p><pre class="kg kh ki kj gt nj mp nk bn nl nm bi"><span id="c928" class="nn kt iq mp b be no np l nq nr">{<br/>  "title":"Black",<br/>  "description":"Black coffee is as simple as it gets with ground coffee beans steeped in hot water, served warm.",<br/>  "ingredients":[<br/>     "Coffee"<br/>  ],<br/>  "image":"https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/A_small_cup_of_coffee.JPG/640px-A_small_cup_of_coffee.JPG",<br/>  "id":1<br/>}</span></pre><p id="5314" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">我们可以执行的从这个API获取数据的最简单形式的<code class="fe mm mn mo mp b">Future</code>如下所示:</p><pre class="kg kh ki kj gt nj mp nk bn nl nm bi"><span id="8b5d" class="nn kt iq mp b be no np l nq nr">void main() {<br/>  Future&lt;http.Response&gt; coffeeData =<br/>      http.get(Uri.parse('https://api.sampleapis.com/coffee/hot'));<br/>}</span></pre><p id="541a" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">现在我们已经为我们的思考过程建立了基础，让我们开始吧。</p><h1 id="6b74" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">连锁期货</h1><h2 id="ad9a" class="ns kt iq bd ku nt nu dn ky nv nw dp lc lt nx ny le lx nz oa lg mb ob oc li od bi translated">问题陈述</h2><p id="46ab" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">最近，我们的后端开发人员请求了一个咖啡列表，这是一个经过授权的请求。</p><p id="56d5" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">授权请求要求请求头包含用户成功登录时获得的授权令牌。这意味着用户在查看咖啡列表之前必须登录到应用程序。</p><p id="c724" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">我们如何在发出成功的登录请求后请求coffee list端点？</p><h2 id="a4b0" class="ns kt iq bd ku nt nu dn ky nv nw dp lc lt nx ny le lx nz oa lg mb ob oc li od bi translated">解决办法</h2><p id="dc4e" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">这就是使用<code class="fe mm mn mo mp b">then()</code>将两个或更多期货链接在一起的能力派上用场的地方。我们可以确保在继续进行获取咖啡列表的调用之前，从登录调用中收到一个肯定的结果，除此之外，我们可以很容易地从前面的调用中获得值。</p><p id="feac" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">让我们创造一些方法，让我们的生活更轻松。</p><p id="cd61" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">下面是获取coffees数据的方法:</p><pre class="kg kh ki kj gt nj mp nk bn nl nm bi"><span id="3d00" class="nn kt iq mp b be no np l nq nr">Future&lt;http.Response&gt; fetchCoffeeData({required String coffeeTemp}) async {<br/>  const baseURL = 'https://api.sampleapis.com/';<br/>  final coffeeResponse =<br/>      await http.get(Uri.parse(baseURL + '/coffee/' + coffeeTemp));<br/><br/>  if (coffeeResponse.statusCode == 200) {<br/>    return coffeeResponse;<br/>  } else {<br/>    throw Exception('Failed to fetch coffees');<br/>  }<br/>}<br/></span></pre><p id="7292" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">登录方法如下:</p><pre class="kg kh ki kj gt nj mp nk bn nl nm bi"><span id="168c" class="nn kt iq mp b be no np l nq nr">Future&lt;http.Response&gt; loginUser({<br/>  required String username,<br/>  required String password,<br/>}) async {<br/>  const baseURL = 'https://api.sampleapis.com/';<br/>  Map&lt;String, String&gt; requestBody = {<br/>    'username': username,<br/>    'password': password<br/>  };<br/><br/>  final loginResponse =<br/>      await http.post(Uri.parse(baseURL + '/login/'), body: requestBody);<br/><br/>  if (loginResponse.statusCode == 200) {<br/>    return loginResponse;<br/>  } else {<br/>    throw Exception('Failed to log you in.');<br/>  }<br/>}</span></pre><p id="09c6" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">通过查看下面的代码，您可以这样问自己:</p><h2 id="cf0e" class="ns kt iq bd ku nt nu dn ky nv nw dp lc lt nx ny le lx nz oa lg mb ob oc li od bi translated">去连锁？</h2><pre class="kg kh ki kj gt nj mp nk bn nl nm bi"><span id="14a1" class="nn kt iq mp b be no np l nq nr">List&lt;Coffee&gt; result = await loginUser(<br/>        username: 'darsshan@sample.com', password: 'Mithrandir@123')<br/>    .then((value) =&gt; <br/>        LoginResponse.fromJson(jsonDecode(loginResponse.body)))<br/>    .then((value) =&gt;<br/>        fetchCoffeeData(coffeeTemp: 'hot', authToken: value.authToken))<br/>    .then((value) =&gt; getCoffeeList(coffeeListResponse));</span></pre><h2 id="0b59" class="ns kt iq bd ku nt nu dn ky nv nw dp lc lt nx ny le lx nz oa lg mb ob oc li od bi translated">还是不要锁链？</h2><pre class="kg kh ki kj gt nj mp nk bn nl nm bi"><span id="6dd9" class="nn kt iq mp b be no np l nq nr">http.Response loginResponse = await loginUser(<br/>  username: 'darsshan@sample.com',<br/>  password: 'Mithrandir@123',<br/>);<br/><br/>final userData = LoginResponse.fromJson(jsonDecode(loginResponse.body));<br/><br/>http.Response coffeeListResponse = await fetchCoffeeData(<br/>  coffeeTemp: 'hot',<br/>  authToken: userData.authToken,<br/>);<br/><br/>List&lt;Coffee&gt; coffeeList = getCoffeeList(coffeeListResponse);</span></pre><p id="7d3d" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">从上面的代码实现中可以看出，当我们选择将期货链接在一起时，它给我们带来了一些生动的好处:</p><ul class=""><li id="ebbf" class="mq mr iq lm b ln mh lq mi lt ms lx mt mb mu mf mv mw mx my bi translated">获得相同结果的代码行更少</li><li id="b839" class="mq mr iq lm b ln mz lq na lt nb lx nc mb nd mf mv mw mx my bi translated">更容易阅读代码以了解发生了什么，因为它是按相关事件的顺序排列的</li><li id="08ca" class="mq mr iq lm b ln mz lq na lt nb lx nc mb nd mf mv mw mx my bi translated">清晰概述依赖关系，因为如果没有从前面的代码接收到正确的信息，后续的代码将无法执行<code class="fe mm mn mo mp b">Future</code></li></ul><p id="e6f5" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">当将多个<code class="fe mm mn mo mp b">Future</code>链接在一起时，需要注意的是前面的<code class="fe mm mn mo mp b">Future</code>失败将导致所有后续的<code class="fe mm mn mo mp b">Future</code>调用失败。</p><pre class="kg kh ki kj gt nj mp nk bn nl nm bi"><span id="1a6f" class="nn kt iq mp b be no np l nq nr">loginUser(username: 'darsshan@sample.com', password: 'Mithrandir@123')<br/>    // Future 1: Success<br/>    .then((value) =&gt; LoginResponse.fromJson(jsonDecode(loginResponse.body)))<br/>    // Future 2: Let's make this fail.<br/>    .then((value) =&gt; fetchCoffeeData(<br/>        coffeeTemp: 'hot', authToken: 'expired token'))<br/>    // Future 3: This will not be executed as the one before it failed.<br/>    .then((value) =&gt; getCoffeeList(coffeeListResponse))<br/>    // Future 4: This will not be executed as the one before it failed.<br/>    .then((value) =&gt;<br/>        fetchCoffeeData(coffeeTemp: 'iced', authToken: value.authToken))<br/>    // Future 5: This will not be executed as the one before it failed.<br/>    .then((value) =&gt; getCoffeeList(coffeeListResponse))<br/>    // This error traces back to Future 2.<br/>    .catchError((error) =&gt; error);</span></pre><h1 id="0864" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">未来的并发性</h1><h2 id="a18b" class="ns kt iq bd ku nt nu dn ky nv nw dp lc lt nx ny le lx nz oa lg mb ob oc li od bi translated">问题陈述</h2><p id="9e20" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">我们的产品管理团队提出了一项新要求。他们想提升咖啡应用的用户体验。他们想在我们的应用程序中创建一个“给我惊喜”部分，随机建议用户喝一杯咖啡。</p><p id="2116" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">咖啡列表必须至少包含一种温度的咖啡，要么是热咖啡，要么是冰咖啡。如果其中一个咖啡温度不可用，应该预先警告用户。</p><p id="c5e0" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">我们可以同时启动两个API调用并监控它的结果吗？</p><p id="3561" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">如果其中一个失败了，我们能知道哪一个失败了吗？</p><h2 id="582f" class="ns kt iq bd ku nt nu dn ky nv nw dp lc lt nx ny le lx nz oa lg mb ob oc li od bi translated">解决办法</h2><p id="e58c" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">这就是<code class="fe mm mn mo mp b">Future</code>中并发性可以帮助我们的地方。<code class="fe mm mn mo mp b">Future</code>中的<code class="fe mm mn mo mp b">Future.wait()</code>方法接受一个<code class="fe mm mn mo mp b">Future</code>列表，等待它们完成，并给我们每一个的结果。</p><p id="71d5" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">让我们试着用<code class="fe mm mn mo mp b">Future.wait()</code>来解决上面的问题。</p><pre class="kg kh ki kj gt nj mp nk bn nl nm bi"><span id="228c" class="nn kt iq mp b be no np l nq nr">Future&lt;List&lt;Coffee&gt;&gt; hotCoffee =<br/>    await fetchCoffeeData(coffeeTemp: 'hot', authToken: userData.authToken)<br/>        .then((value) =&gt; getCoffeeList(coffeeListResponse));<br/><br/>Future&lt;List&lt;Coffee&gt;&gt; icedCoffee =<br/>    await fetchCoffeeData(coffeeTemp: 'iced', authToken: userData.authToken)<br/>        .then((value) =&gt; getCoffeeList(coffeeListResponse));<br/><br/>List&lt;List&lt;Coffee&gt;&gt; coffeeLists =<br/>    await Future.wait([hotCoffee, icedCoffee]).catchError(<br/>  (error) =&gt; error,<br/>);<br/><br/>List&lt;Coffee&gt; mergedCoffees = [...coffeeLists[0], ...coffeeLists[1]];</span></pre><p id="7e1b" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">从上面的实现中可以看出，我们将两个<code class="fe mm mn mo mp b">Future</code>、<code class="fe mm mn mo mp b">hotCoffee</code>和<code class="fe mm mn mo mp b">icedCoffee</code>放入<code class="fe mm mn mo mp b">Future.wait()</code>。我们将在一个数组中得到结果。</p><p id="5fa9" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">数组中的结果被索引，对应于我们提供给<code class="fe mm mn mo mp b">Future.wait()</code>的<code class="fe mm mn mo mp b">Future</code>列表。这就是为什么我非常确定热咖啡的列表将在索引<code class="fe mm mn mo mp b">0</code>处，而冰咖啡将在索引<code class="fe mm mn mo mp b">1</code>处。</p><p id="827e" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">但这是如果成功的话。万一失败了呢？</p><h2 id="dbeb" class="ns kt iq bd ku nt nu dn ky nv nw dp lc lt nx ny le lx nz oa lg mb ob oc li od bi translated">在一个期货列表中，我们能知道哪个期货失败了吗？</h2><p id="fefc" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">由于<code class="fe mm mn mo mp b">Future.wait()</code>本身返回另一个可以自己解决的<code class="fe mm mn mo mp b">Future</code>，我们可以给它附加一个<code class="fe mm mn mo mp b">catchError()</code>回调。这次回调将让我们知道哪个期货失败了，但有一个警告。</p><p id="03a0" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated"><code class="fe mm mn mo mp b">Future.wait()</code>只会给我们抛出<code class="fe mm mn mo mp b">Future</code>的错误，在一份期货清单中第一个失败。</p><h2 id="51db" class="ns kt iq bd ku nt nu dn ky nv nw dp lc lt nx ny le lx nz oa lg mb ob oc li od bi translated">故障场景解释:</h2><p id="f6ea" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">如果我们有<code class="fe mm mn mo mp b">Future A</code>、<code class="fe mm mn mo mp b">Future B</code>和<code class="fe mm mn mo mp b">Future C</code>，假设它们是这样的:<code class="fe mm mn mo mp b">Future.wait(Future A, Future B, Future C)</code>。现在让我们假设<code class="fe mm mn mo mp b">Future B</code>和<code class="fe mm mn mo mp b">Future C</code>已经失效，而<code class="fe mm mn mo mp b">Future B</code>先失效。</p><p id="9e78" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">在这种情况下，<code class="fe mm mn mo mp b">Future.wait()</code>只会通过<code class="fe mm mn mo mp b">Future B</code>向我们抛出异常，并且会丢弃从<code class="fe mm mn mo mp b">Future C</code>抛出的错误。</p><h1 id="4d7b" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">结论</h1><p id="a499" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">通过上面的讨论和解释，我们现在可以很好地理解以下概念:</p><ul class=""><li id="bc34" class="mq mr iq lm b ln mh lq mi lt ms lx mt mb mu mf mv mw mx my bi translated">我们如何连锁期货</li><li id="bd7c" class="mq mr iq lm b ln mz lq na lt nb lx nc mb nd mf mv mw mx my bi translated">为什么我们需要考虑在某些情况下链接未来</li><li id="e53e" class="mq mr iq lm b ln mz lq na lt nb lx nc mb nd mf mv mw mx my bi translated">我们如何追踪连锁期货的例外</li><li id="fe08" class="mq mr iq lm b ln mz lq na lt nb lx nc mb nd mf mv mw mx my bi translated">连锁期货的警告是什么</li><li id="10aa" class="mq mr iq lm b ln mz lq na lt nb lx nc mb nd mf mv mw mx my bi translated">我们如何使用<code class="fe mm mn mo mp b">Future.wait()</code>同时触发多个期货</li><li id="590b" class="mq mr iq lm b ln mz lq na lt nb lx nc mb nd mf mv mw mx my bi translated">我们如何通过<code class="fe mm mn mo mp b">Future.wait()</code>获得多个期货的数据</li><li id="9f18" class="mq mr iq lm b ln mz lq na lt nb lx nc mb nd mf mv mw mx my bi translated">我们如何在<code class="fe mm mn mo mp b">Future.wait()</code>中追踪异常</li><li id="1701" class="mq mr iq lm b ln mz lq na lt nb lx nc mb nd mf mv mw mx my bi translated">当我们使用<code class="fe mm mn mo mp b">Future.wait()</code>时，异常处理的注意事项是什么</li></ul><p id="6e48" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>