<html>
<head>
<title>Adopting New API Versions With Hexagonal Architecture in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kotlin中采用六角形架构的新API版本</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/adopt-new-api-versions-with-hexagonal-architecture-353e3d8fd64c?source=collection_archive---------11-----------------------#2022-03-16">https://betterprogramming.pub/adopt-new-api-versions-with-hexagonal-architecture-353e3d8fd64c?source=collection_archive---------11-----------------------#2022-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4a17" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">保持最新状态，不破坏任何东西</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/62ad04a6d20a0cfe7691c24df7b8ec4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0rQpWVYbmkf49ykbHCBanQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图像由<a class="ae kv" href="https://unsplash.com/@steve_j" rel="noopener ugc nofollow" target="_blank">斯蒂夫·约翰森</a>在<a class="ae kv" href="https://unsplash.com/photos/WkJPu3rEeJE" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7f33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你已经习惯于长期使用旧的API时，采用新的API版本可能会很麻烦；尤其是如果你从来没有为它设计过。在本指南中，我将向您展示一种采用全新迭代的方法，对代码的改动最小。</p><h1 id="562a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们现有的应用程序</h1><p id="7846" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">假设我们是一家兽医诊所，我们有一个应用程序，它从我们的API获取一些数据，将其格式化为HTML，然后打印到控制台。你可以从这个大纲中推断出我们如何构建一个功能完整的网络或移动应用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="db1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们设计这个应用程序时，我们对它的外观有一个非常具体的想法，所以我们围绕这些要求设计了我们的模型和API。它非常适合我们，我们对此非常满意。</p><h1 id="bb9b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">新要求</h1><p id="05df" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">但是现在我们有了新的要求:我们必须展示猫最喜欢的食物。后端团队已经支持这一点，但它只在他们的新API版本中可用。让我们看看他们发给我们的新方案:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7421" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原来他们对新模式做了很多改动，有几个问题:</p><ul class=""><li id="154a" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">我们不想支持<code class="fe na nb nc nd b">breed</code>的新值，他们用<code class="fe na nb nc nd b">CamelCase</code>而不是我们想要的<code class="fe na nb nc nd b">snake_case</code>。</li><li id="321c" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">colours</code>是一组枚举，而不是我们想要的<code class="fe na nb nc nd b">grey</code>和<code class="fe na nb nc nd b">brown</code>布尔</li><li id="3e6c" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">id</code>和<code class="fe na nb nc nd b">ownerId</code>是UUIDs，而不是我们想要的整数</li><li id="f8fd" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">appointments</code>从猫模式中缺失；它们只能从完全不同的API操作中获得</li></ul><p id="ceda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下我们的应用程序是巨大的:如果我们采用这个新模式作为我们的模型，变化将是巨大的，并且需要大量的回归测试。当我们想要的只是增加一个新的属性时，我们无法证明所付出的努力是值得的。</p><h1 id="30a8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">通过六边形让生活更美好</h1><p id="a3c9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果我们采用<a class="ae kv" href="https://netflixtechblog.com/ready-for-changes-with-hexagonal-architecture-b315ec967749" rel="noopener ugc nofollow" target="_blank">六边形架构</a>的一些原则(特别是端口和适配器)，我们可以将我们的应用程序与这些问题隔离开来。我们可以采用新的API版本，添加新的特性，并对现有代码做很少的修改。所有这些都可以通过一个适配器来实现，该适配器可以将新模式转换成我们熟悉的模型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/e73f48ae5d361147e045c86cde1998e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*o6fbdriILJXulIJ5C3otkg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">您可以设计许多不同的适配器来适应单个端口</p></figure><h2 id="1afb" class="nk lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">港口</h2><p id="43a7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在软件术语中，端口是定义我们想要完成的契约的接口。</p><pre class="kg kh ki kj gt nw nd nx ny aw nz bi"><span id="cff8" class="nk lt iq nd b gy oa ob l oc od">fun interface Horn {<br/>  fun honk()<br/>}</span></pre><h2 id="727d" class="nk lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">适配器</h2><p id="c77c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">适配器是端口接口的实现。可以有几个版本，可以根据需要换入换出，甚至可以动态地换入换出，或者用函数式编程分层。</p><pre class="kg kh ki kj gt nw nd nx ny aw nz bi"><span id="00cd" class="nk lt iq nd b gy oa ob l oc od">class CarHorn: Horn {<br/>  override fun honk() {<br/>    println("Beep")<br/>  }<br/>}</span><span id="4e27" class="nk lt iq nd b gy oe ob l oc od">class TruckHorn: Horn {<br/>  override fun honk() {<br/>    println("BURRRRRRRRRP")<br/>  }<br/>}</span></pre><h2 id="5fdd" class="nk lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">定义我们的港口</h2><p id="ea1f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">那么，我们如何使用端口和适配器来帮助我们呢？如果我们的目标是使用和以前一样的<code class="fe na nb nc nd b">Cat</code>模型，那么端口真正需要做的就是通过它的id获得一个<code class="fe na nb nc nd b">Cat</code>。但是首先我们需要调和旧整数<code class="fe na nb nc nd b">id</code>和新整数<code class="fe na nb nc nd b">UUID</code>之间的差异。谢天谢地，这两个可以很容易地表示为一个<code class="fe na nb nc nd b">String</code>，所以我们的端口将使用它。我们可以通过更新我们的<code class="fe na nb nc nd b">Cat</code>模型来使用字符串<code class="fe na nb nc nd b">id</code>来进行一个小小的妥协。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="16d2" class="nk lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">实现v1适配器</h2><p id="3de5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，让我们拿出一个v1适配器来实现我们的端口。这非常简单，因为它所做的只是将任务委托给<code class="fe na nb nc nd b">ClientV1</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="43c3" class="nk lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated"><strong class="ak">实现v2适配器</strong></h2><p id="64df" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">接下来，我们需要为<code class="fe na nb nc nd b">ClientV2</code>创建一个适配器。这个有点复杂，因为它需要进行两次API调用，并将结果合并到原始的<code class="fe na nb nc nd b">Cat</code>模型中。我们还将借此机会从<code class="fe na nb nc nd b">CatDtoV2</code>中获取新的<code class="fe na nb nc nd b">favouriteFood</code>字段。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="bf95" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用新端口</h1><p id="28f3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了实际使用这个新的<code class="fe na nb nc nd b">CatsDao</code>端口，我们必须更新我们的<code class="fe na nb nc nd b">CatUi</code>来使用它而不是<code class="fe na nb nc nd b">ClientV1</code>。然后我们必须更新我们的<code class="fe na nb nc nd b">main</code>方法来注入一个适配器。然后，我们可以安全地渲染来自任一API的猫，以及最喜爱的食物(如果存在的话)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="0e72" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">安全迁移到V2</h1><p id="6c26" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">因此，现在我们已经成功地采用了一个全新的用户界面，用户流失最小。但是我们为什么要维护V1适配器呢？</p><h2 id="12b3" class="nk lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">原因一:安全</h2><p id="d25e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">仍然支持旧的API并使用特性标志来缓慢推出更新或在出现问题时快速回滚通常是有价值的。</p><h2 id="eaf6" class="nk lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">原因2:遗留数据</h2><p id="5fd0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果<code class="fe na nb nc nd b">v2</code> API不能访问所有的旧数据，那么我们需要一种方法来返回到<code class="fe na nb nc nd b">v1</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="724e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这些问题，我们现在有2个新的适配器。<code class="fe na nb nc nd b">toggled</code>适配器使用一个特征标志来决定我们是委托给<code class="fe na nb nc nd b">v1</code>还是<code class="fe na nb nc nd b">backCompat</code>适配器，而<code class="fe na nb nc nd b">backCompat</code>将试图从<code class="fe na nb nc nd b">v2</code>获取<code class="fe na nb nc nd b">Cat</code>，如果没有找到，返回到<code class="fe na nb nc nd b">v1</code>。</p><h1 id="bf0b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">额外收获:安全地迭代内部模型</h1><p id="8f5a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们最初的应用程序有一个问题，到目前为止的改进并没有改变这一点。在成功发布对<code class="fe na nb nc nd b">favouriteFood</code>的支持后，我们现在想要支持<code class="fe na nb nc nd b">v2</code>模式中所有可用的新颜色。<code class="fe na nb nc nd b">Cat</code>模型不支持这一点，但是更新它会使我们的<code class="fe na nb nc nd b">ClientV1</code>变得复杂。</p><p id="666c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在以前，这将是一个巨大的问题。但是现在我们有了将我们的内部模型与新的API版本隔离的工具，我们可以更进一步，通过让<code class="fe na nb nc nd b">ClientV1</code>返回一个新的<code class="fe na nb nc nd b">CatDtoV1</code>，并更新适配器以从<code class="fe na nb nc nd b">CatDtoV1</code>转换为<code class="fe na nb nc nd b">Cat</code>，将它与(现在的)遗留<code class="fe na nb nc nd b">v1</code>模式隔离。一旦这样做了，支持这个新特性就安全多了，同时仍然支持两个API版本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="33bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要忘记对<code class="fe na nb nc nd b">v2</code>适配器进行相应的更新。</p><h1 id="97d5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">包扎</h1><p id="9917" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有了这个指南，您应该能够采用新的API版本，而对现有代码的改动最小。它所需要的只是用一个端口取代您对客户机的直接依赖，这个端口由一个适配器实现，该适配器可以从新的模型转换成您喜欢的模型。请让我在评论中知道这是否有助于你解决一个繁重的迁移。祝你好运！</p><p id="2a3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的源代码，请参见下面的回购:</p><div class="of og gp gr oh oi"><a href="https://github.com/oharaandrew314/hexagonal-api-clients" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">GitHub-oharaandrew 314/hexagon-API-clients</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow kp oi"/></div></div></a></div></div></div>    
</body>
</html>