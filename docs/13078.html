<html>
<head>
<title>How to Create a GraphQL Gateway With REST APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用REST APIs创建GraphQL网关</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-graphql-gateway-with-rest-apis-and-not-dying-in-the-intent-e4eee697c51b?source=collection_archive---------6-----------------------#2022-07-26">https://betterprogramming.pub/how-to-create-a-graphql-gateway-with-rest-apis-and-not-dying-in-the-intent-e4eee697c51b?source=collection_archive---------6-----------------------#2022-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7c05" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索不同的选择和挑战</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3e93de3c391f4ac13593731ff051d04a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xzWiKWaCji96k29m"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@ibidsy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克莱顿</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1af7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有多少次，在使用基于REST的分布式架构时，我们最终会遇到API复杂性问题的项目，因为随着项目的增长:</p><ul class=""><li id="7328" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">越来越多的服务直接依赖/相互耦合</li><li id="9eef" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">服务之间的数据聚合(例如前端消费)成为一个巨大的负担，减慢了项目的速度</li><li id="4314" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">服务的数量增加了，如果它们之间没有通信契约，这可能是一个可维护性问题</li></ul><p id="6148" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前端，复杂性大致反映了上述问题:</p><ul class=""><li id="3387" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">与许多不同的REST APIs通信可能很麻烦</li><li id="1aa8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">尤其是当API之间存在数据依赖关系时，检索单个视图的所有相关数据可能会涉及多次REST API调用，从而降低开发和应用程序的速度</li></ul><p id="05af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用一个<strong class="ky ir"> GraphQL网关</strong>，这些复杂性中的许多都可以被简化。它统一和标准化了REST微服务之间的通信，并为前端带来了定义良好的自动生成数据类型、查询和变异的独特访问接口。</p><p id="1b46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，GraphQL网关在属于不同服务的越来越多的实体之间创建数据关系，而没有创建深度耦合或不可阻挡的REST调用网的危险。</p><h1 id="b34d" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">什么是GraphQL？</strong></h1><blockquote class="my mz na"><p id="bf48" class="kw kx nb ky b kz la jr lb lc ld ju le nc lg lh li nd lk ll lm ne lo lp lq lr ij bi translated">GraphQL是一种API查询语言，也是一种用现有数据完成这些查询的运行时语言。GraphQL为API中的数据提供了完整且易于理解的描述，使客户能够准确地要求他们需要的东西，使API更容易随时间发展，并支持强大的开发工具。</p><p id="d6b7" class="kw kx nb ky b kz la jr lb lc ld ju le nc lg lh li nd lk ll lm ne lo lp lq lr ij bi translated">关于<a class="ae kv" href="https://graphql.org/faq/" rel="noopener ugc nofollow" target="_blank"> GraphQL文档</a>的更多信息。</p></blockquote><p id="b316" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们以这个<a class="ae kv" href="https://github.com/segpacto/graphql-gateway-microservices-sample" rel="noopener ugc nofollow" target="_blank">仓库</a>为例。它包含了两个微服务的实现— <a class="ae kv" href="https://github.com/segpacto/graphql-gateway-microservices-sample/tree/master/customer" rel="noopener ugc nofollow" target="_blank">客户</a>和<a class="ae kv" href="https://github.com/segpacto/graphql-gateway-microservices-sample/tree/master/invoice" rel="noopener ugc nofollow" target="_blank">发票</a>。两者都公开了使用OpenAPI/Swagger记录的REST API。</p><p id="b37f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们想在前端显示发票支付金额和客户名称。我们将如何实现这一点？</p><h1 id="49c1" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">选项1 </strong></h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/fb4b824faa8fead4b869efe602264c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*5pXB51K16RLfeGyXqRs5Gw.png"/></div></figure><p id="e548" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以将业务逻辑转移到客户端(浏览器、电话等)，因此它会创建两个REST调用，一个调用客户API，另一个调用发票API，在这种情况下，调用会随着新微服务的数量不断增加。</p><p id="176e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种方法中，前端需要知道多个API，当微服务的数量不断增加时，这很难维护。</p><p id="1b0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，当新的微服务整合到架构中时，我们的前端需要添加新的URL和端点(如果有多个的话),并处理不同类型的HTTP请求及其配置。</p><p id="b9f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，网页显示了实体customer和invoice之间的关系(每个客户一个发票列表)。要在手机应用程序上访问相同的数据聚合，需要在那里再次实现，因为实体的关系不能被重用。</p><p id="7d53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了前面提到的，控制REST APIs响应负载的属性并不是现成的。这可能意味着，每次我们请求客户或发票数据时，无论我们是否需要，它都是带有所有属性的实体。这可能会由于网络延迟和通过互联网传输大数据块而导致性能问题。</p><h1 id="ab90" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">选项2 </strong></h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/d64dba2c0d9984ce6ded13292229fdeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WjlyKU9TVPxRaTAsmBfDFA.png"/></div></div></figure><p id="2042" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种方法是创建一个<a class="ae kv" href="https://microservices.io/patterns/data/api-composition.html" rel="noopener ugc nofollow" target="_blank"> API Composer服务</a>，它应该公开端点，允许我们通过在前端只做一次调用来检索实体及其聚合。一个客户的所有相关发票。</p><p id="de1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该服务无疑比前一个选项执行得更好，因为减少了调用的数量，但是关系仍然是不可重用的，我们可以在特定的get端点上从API Composer服务获得关系customer和invoices，但是不能在另一个使用POST并返回相同的Customer实体的端点上做同样的事情，而不手动实现数据的聚合，因此需要找到另一个解决方案。</p><p id="8b9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">API Composer服务上的每个端点都返回实体之间的关系(例如:客户-发票、客户-预订、发票-预订)，但是一旦需要新的关系，如客户-发票-预订，响应有效负载就会变得巨大，因为REST调用不会在没有实现它的情况下从响应中排除属性，并且以前的关系不能在端点之间重用，需要重新实现，从而导致无法管理的增长。</p><h1 id="b385" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak"> GraphQL网关作为解决方案</strong></h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/4f04f7e5b56c24bd89c6f2c56d68bdf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*1ndcu7j7ouWoBO0GB5Anyg.png"/></div></figure><p id="95c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过在我们的架构上引入<a class="ae kv" href="https://github.com/segpacto/graphql-gateway-microservices-sample/tree/master/graphql-gateway" rel="noopener ugc nofollow" target="_blank"> GraphQL Gateway </a>服务，无论后端有多少服务，前端都有一个访问数据的入口点。</p><p id="9d0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据关系/聚合可以由不同的客户端(web应用程序、电话应用程序)重用，因为它们是在实体之间建立的。一旦我们声明Customer实体与Invoice实体有关系，所有使用这些实体的操作(查询、变异)都可以使用它。</p><p id="f6ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查询和变异的GraphQL类型和解析器是自动生成的，这意味着服务根据OpenAPI文档创建自己的GraphQL类型，并且知道在哪里可以找到数据以及使用哪些HTTP方法(POST、GET等)。</p><p id="b836" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前端只请求和接收实体所需的属性，这减少了后端和前端之间通过互联网传输的数据量。前面的优势也有助于通过只做一次请求来获得客户和相关发票。</p><p id="3a21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">向我们的后端添加新服务不需要在前端做任何改变来访问新的数据类型、查询和变化。</p><h1 id="9d05" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">graph QL网关实际上是做什么的？</strong></h1><p id="4617" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">GraphQL Gateway在内部使用包<a class="ae kv" href="https://www.npmjs.com/package/gql-gateway" rel="noopener ugc nofollow" target="_blank"> gql-gateway </a>，它负责连接到每一个微服务，读取、解释、自动将所有OpenApi/Swagger文档转换为GraphQL类型，并自动生成所有查询和变异的解析器。</p><p id="f43e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该服务创建一个具有所有特性的<a class="ae kv" href="https://www.apollographql.com/docs/apollo-server/" rel="noopener ugc nofollow" target="_blank"> Apollo服务器</a>，负责验证输入数据，并只解析客户端请求的属性。</p><p id="7dc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，当前端请求实体Customer和Invoice时，服务会准确地知道连接到哪个服务来检索数据。</p><p id="36f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该服务是完全无状态的，这允许我们根据请求和使用的数量来扩展它。</p><h1 id="bf36" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">实施这种方法有多难？</strong></h1><p id="48ce" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">创建带有所有自动生成的GraphQL类型、查询和变异的<a class="ae kv" href="https://github.com/segpacto/graphql-gateway-microservices-sample/tree/master/graphql-gateway" rel="noopener ugc nofollow" target="_blank">网关</a>应该只需要几行代码。</p><p id="d679" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从头开始…</p><p id="12ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有两个微服务在端口<code class="fe nn no np nq b">3000</code>和<code class="fe nn no np nq b">3001</code>上公开OpenApi/Swagger文档，这两个端口描述了检索<a class="ae kv" href="https://github.com/segpacto/graphql-gateway-microservices-sample/blob/master/customer/swagger.json" rel="noopener ugc nofollow" target="_blank">客户</a>和<a class="ae kv" href="https://github.com/segpacto/graphql-gateway-microservices-sample/blob/master/invoice/swagger.json" rel="noopener ugc nofollow" target="_blank">发票</a>的端点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">简单graphQl网关</p></figure><p id="ed98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">常量<code class="fe nn no np nq b">endpointsList</code>包含所有微服务OpenApi/Swagger文档的列表。这个配置被传递给<a class="ae kv" href="https://www.npmjs.com/package/gql-gateway" rel="noopener ugc nofollow" target="_blank"> gql-package </a>，它负责创建监听端口5000的Apollo服务器。</p><p id="35eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过导航到<a class="ae kv" href="http://localhost:5000" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000 </a>来访问<a class="ae kv" href="https://www.apollographql.com/docs/apollo-server/v2/testing/graphql-playground/" rel="noopener ugc nofollow" target="_blank"> apollo playground </a>，它给出了所有自动生成的类型、查询和可用变异的概念。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/1721a5dec1dfd916141a4c73eabfdb70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28dYILb9msgSMT5s8FIb3w.png"/></div></div></figure><p id="1038" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们创建一些<code class="fe nn no np nq b">Entity</code>关系:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">具有实体关系的GraphQl网关</p></figure><p id="5e98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些可能看起来像复杂的代码，但实际上是创建<a class="ae kv" href="https://www.graphql-tools.com/docs/schema-delegation" rel="noopener ugc nofollow" target="_blank"> GraphQL模式委托</a>的标准方式，这意味着实体内特定属性的解析将被委托给特定的查询或变异。</p><p id="f165" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，为了表明客户将有一个相关发票的列表，我们只需通过添加发票类型的数组来扩展<code class="fe nn no np nq b">localSchema</code>常量上的客户类型。然后，在解析器上，我们指示客户的invoices属性将通过委托给属于<code class="fe nn no np nq b">invoiceApi</code>的查询<code class="fe nn no np nq b">getInvoicesByCustomerId</code>来解析。</p><blockquote class="my mz na"><p id="dd18" class="kw kx nb ky b kz la jr lb lc ld ju le nc lg lh li nd lk ll lm ne lo lp lq lr ij bi translated">要更深入地了解<strong class="ky ir"> gql-package </strong>，请查看<a class="ae kv" href="https://github.com/segpacto/gql-gateway" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">自述文件</strong> </a>或<a class="ae kv" href="https://github.com/segpacto/gql-gateway/blob/master/examples/advanced.js" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">高级示例</strong> </a>。</p></blockquote><p id="bda9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从现在开始，每次客户被包括在任何GraphQL查询或变体的响应中，我们也可以访问发票，反之亦然。委托和模式拼接是一种以可伸缩的方式解决和创建数据关系的优雅方式。</p><p id="7a59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，GraphQL网关本身并不是所有问题的解决方案，这只是在提高开发速度方面的一个简化表示。</p><p id="5c4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了成功地应用上述解决方案，实现应该伴随着良好的开发实践、作为我们的服务和互联网之间的媒介的API网关、负载平衡器、设计良好的缓存策略以及良好的CI/CD策略，这里仅举几个例子。没有解决大型基础设施技术问题的灵丹妙药，但实验仍然是学习如何解决的最佳方式。</p><p id="5afa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要深入了解相关主题，您可以查看:</p><ul class=""><li id="ac41" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://microservices.io/patterns/data/api-composition.html" rel="noopener ugc nofollow" target="_blank"> API组合模式</a></li><li id="a361" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://dzone.com/articles/microservices-integration-aggregators" rel="noopener ugc nofollow" target="_blank">聚合器vs API组合模式</a></li><li id="1ce6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://itnext.io/auto-generated-graphql-gateways-bring-your-rest-apis-together-for-great-and-for-better-9d74470820cc" rel="noopener ugc nofollow" target="_blank"> GraphQL网关审查</a></li><li id="a6f0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://www.apollographql.com/docs/federation/gateway/" rel="noopener ugc nofollow" target="_blank">阿波罗网关</a></li><li id="ccb2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://www.apollographql.com/docs/federation/" rel="noopener ugc nofollow" target="_blank">阿波罗联邦</a></li><li id="a4c2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://www.apollographql.com/docs/apollo-server/v2/api/graphql-tools/#delegatetoschema" rel="noopener ugc nofollow" target="_blank"> GraphQL模式委托</a></li><li id="371b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://www.apollographql.com/docs/federation/migrating-from-stitching/" rel="noopener ugc nofollow" target="_blank"> GraphQL模式拼接</a></li><li id="87f9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank"> OpenAPI/Swagger </a></li></ul></div></div>    
</body>
</html>