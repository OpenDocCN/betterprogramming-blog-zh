<html>
<head>
<title>Feign Reactive — My Preferred Solution for REST API Consumption</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">假装被动——我对REST API消费的首选解决方案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/feign-reactive-my-preferred-solution-for-rest-api-consumption-5d79a283b24f?source=collection_archive---------1-----------------------#2022-10-24">https://betterprogramming.pub/feign-reactive-my-preferred-solution-for-rest-api-consumption-5d79a283b24f?source=collection_archive---------1-----------------------#2022-10-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="04bf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何为第三方API集成实现Feign Reactive的分步指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f811d553c0a21f48095a072b3d29192c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-o4jWSIYKQmjD2g8YNTiiw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="5f38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">几个月前，我写了一篇名为<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/implementing-reactive-circuit-breaker-using-resilience4j-4fe81d28e100?sk=cbb3276325c258162425d6bc89a2e2ba">使用Resilience4j </a>实现反应式断路器的文章，其中Spring WebFlux的WebClient由于其非阻塞特性而被选为我消费REST API的首选解决方案。今天，我将介绍<a class="ae lu" href="https://github.com/PlaytikaOSS/feign-reactive" rel="noopener ugc nofollow" target="_blank"> Feign Reactive </a>，并推荐它作为我对REST API消费的首选解决方案。为了找出原因，让我们深入研究一下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/438a8cb70dfe6ed683283525f5553d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLqrNaZNVPNRrnEmTrEKjg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图表</p></figure><h1 id="f1cf" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">什么是假装反应？</h1><p id="8171" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">Spring WebClient是一个进行HTTP请求的非阻塞反应式客户端。OpenFeign 是一个流行的框架，它帮助我们轻松地创建带有注释的声明性REST客户端。在微服务架构中调用外部服务时，它提供了更好的抽象。</p><p id="ecfa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://github.com/PlaytikaOSS/feign-reactive" rel="noopener ugc nofollow" target="_blank"> Feign Reactive </a>是Feign在Spring WebClient上的实现。它给我们带来了两全其美:在Spring WebClient的快速、异步、无阻塞的HTTP客户端上编写客户端API的Feign的简洁语法。</p><p id="32d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了使用Feign Reactive演示REST API消费，我们将构建一个Spring Boot应用程序客户服务客户端来消费由另一个Spring Boot应用程序客户服务提供的REST API，后者对客户执行CRUD操作。</p><p id="137a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在客户-服务-客户端中实现假装反应的详细步骤概述如下:</p><h1 id="e5cf" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">步骤1:在pom.xml中添加依赖项</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="2a60" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">第二步:客户客户申报</h1><p id="de9a" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">在下面的<code class="fe mv mw mx my b">CustomerServiceClient</code>中捕捉到了Feign的声明性，它是一个对客户服务API作出反应的客户端。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7e27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面第1行的注释<code class="fe mv mw mx my b">@ReactiveFeignClient</code>，连同下面主Spring Boot类<code class="fe mv mw mx my b">CustomerServiceClientApplication</code>中第2行的注释<code class="fe mv mw mx my b">@EnableReactiveFeignClients</code>，使这个接口成为一个假想的反应客户端。这两种注释都使我们的客户服务-客户服务中的假动作活跃起来。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="33b1" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">步骤3: application.yml</h1><p id="d442" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">Feign的声明性也反映在我们的<code class="fe mv mw mx my b">application.yml</code>中，在这里我们为客户服务API集成定义了一组配置细节(下面是示例配置):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="f5d0" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">第四步:假装被动配置</h1><p id="2132" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">结合上面<code class="fe mv mw mx my b">application.yml</code>中的定义，我们可以在<code class="fe mv mw mx my b">CustomerClientConfig</code>类中配置一些API与客户服务集成的横切关注点。详见下文。我们正在配置以下区域:</p><ol class=""><li id="a296" class="mz na it la b lb lc le lf lh nb ll nc lp nd lt ne nf ng nh bi translated">记录(下面的第26–29行，以及上面<code class="fe mv mw mx my b">application.yml</code>中的第17–19行)</li><li id="91cb" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">重试策略(下面的第31–34行)</li><li id="8783" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">错误处理(下面的第36–41行)</li><li id="e962" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">超时(下面的第49–57行)</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6b66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！又快又简单。感谢佯作反应的声明性质！</p><h1 id="792f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">使用WireMock进行测试</h1><p id="5d84" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">WireMock是一个用于存根和模仿web服务的库。它构造了一个HTTP服务器，我们可以像连接实际的web服务一样连接它。当WireMock服务器运行时，我们可以设置期望值，调用服务，并验证其行为。</p><p id="fd3a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了将第三方集成测试的WireMock引入客户-服务-客户端，让我们遵循下面的实现细节:</p><h1 id="4bda" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">步骤1:添加POM依赖项</h1><p id="4421" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">除了<code class="fe mv mw mx my b">spring-boot-starter-test</code>，我们还需要POM文件中的以下依赖项。注意，我们使用了<code class="fe mv mw mx my b">wiremock-jre8</code>，这是为了允许WireMock的JUnit 5测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="954e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，我们还在pom中添加了<code class="fe mv mw mx my b">maven-failsafe-plugin</code>。这个插件分离了单元测试和集成测试的执行。Maven首先执行我们的单元测试。将应用程序打包成一个<code class="fe mv mw mx my b">.jar</code>文件后，Maven将执行我们的集成测试。为了确保<code class="fe mv mw mx my b">maven-failsafe-plugin</code>将我们的测试识别为集成测试，我们需要将关键字<code class="fe mv mw mx my b">IT</code>(代表集成测试)添加到我们的测试类中，比如<code class="fe mv mw mx my b">CustomerServiceClientIT</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="570f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">步骤2:ApplicationContextInitializer</h1><p id="fddd" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">对于在Spring或Spring Boot框架上开发的应用程序来说，将WireMock服务器生命周期绑定到Spring <code class="fe mv mw mx my b">TestContext</code>是很自然的。每次<code class="fe mv mw mx my b">ApplicationContext</code>启动时，Spring执行每个配置的<code class="fe mv mw mx my b">ApplicationContextInitializer</code>。</p><p id="1a3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以开发一个实现<code class="fe mv mw mx my b">ApplicationContextInitializer</code>的类，其中我们可以启动WireMock服务器，将服务器注册为Spring上下文中的bean，并覆盖API的基本URL的配置值；参见下面的示例类<code class="fe mv mw mx my b">WireMockInitializer</code>。我们用WireMock服务器的本地主机基本URL(第21行)覆盖基本URL <code class="fe mv mw mx my b">customer-service.urls.base-url</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="56b8" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">步骤3:实现集成测试</h1><p id="ef0a" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">现在让我们用WireMock编写集成测试。见下图<code class="fe mv mw mx my b">CustomerServiceClientIT</code>类。几个要点:</p><ul class=""><li id="3ded" class="mz na it la b lb lc le lf lh nb ll nc lp nd lt nn nf ng nh bi translated"><code class="fe mv mw mx my b">@SpringBootTest</code></li></ul><p id="f5f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用<code class="fe mv mw mx my b">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</code>注释我们的集成测试。我们用一个<code class="fe mv mw mx my b">RANDOM_PORT</code>来指定<code class="fe mv mw mx my b">webEnvironment</code>。这是为了避免端口冲突，如果同一个WireMock服务器需要为多个重复使用应用程序上下文的IT测试所共享。</p><ul class=""><li id="a774" class="mz na it la b lb lc le lf lh nb ll nc lp nd lt nn nf ng nh bi translated"><code class="fe mv mw mx my b">@ContextConfiguration</code></li></ul><p id="4365" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们通过使用<code class="fe mv mw mx my b">@ContextConfiguration(initializers = {WireMockInitializer.class})</code>激活我们的WireMock初始化器。我们为匹配的基本URL创建了这个初始化器。</p><ul class=""><li id="2dac" class="mz na it la b lb lc le lf lh nb ll nc lp nd lt nn nf ng nh bi translated">将<code class="fe mv mw mx my b">WireMockServer</code>注入其中</li></ul><p id="78e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第10行将<code class="fe mv mw mx my b">WireMockServer </code>注入到我们的测试中，就像其他任何Spring beans一样。这是因为我们的初始化器类已经将我们的<code class="fe mv mw mx my b">WireMockServer </code>加载到了<code class="fe mv mw mx my b">TestContext</code>中。</p><ul class=""><li id="334b" class="mz na it la b lb lc le lf lh nb ll nc lp nd lt nn nf ng nh bi translated">存根API响应</li></ul><p id="d360" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个测试用例都以<code class="fe mv mw mx my b">wireMockServer.stubFor</code>开始(比如第37–42行)，它存根了我们的API响应。这就是“模拟”发生的地方。确保通过实时API调用捕获真实响应，并将其用于存根响应。断言需要匹配存根数据。当使用<code class="fe mv mw mx my b">stubFor</code>阻止来自WireMock的虚假HTTP响应时，我们必须匹配我们的应用程序将调用的HTTP方法和路径。wither方法(例如，<code class="fe mv mw mx my b">withHeader()</code>)为我们提供了一种灵活的方式来构造存根HTTP响应。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="04ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际的测试验证发生在与客户端API调用相同的块中，比如第49–57行，其中<code class="fe mv mw mx my b">WebTestClient</code>触发了对我们的<code class="fe mv mw mx my b">WireMockServer</code>的调用。<code class="fe mv mw mx my b">WebTestClient</code>的流畅API允许我们定义HTTP请求和我们的期望。</p><p id="b2fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">测试日志显示基本URL确实从实际的第三方基本URL(在<code class="fe mv mw mx my b">application.yml</code>中定义)更改为<code class="fe mv mw mx my b">WireMockServer</code>的<code class="fe mv mw mx my b">localhost</code> URL，所以我们的调用确实命中了<code class="fe mv mw mx my b">WireMockServer</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/c065ca44daac01cec8c7509cf1750d12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_-cXBM7uft2M00QW0W6ZiA.png"/></div></div></figure><ul class=""><li id="e9d5" class="mz na it la b lb lc le lf lh nb ll nc lp nd lt nn nf ng nh bi translated">重置<code class="fe mv mw mx my b">WireMockServer</code></li></ul><p id="a9ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">记得在测试之间重置我们的存根设置。第30–33行，<code class="fe mv mw mx my b">resetAll()</code>将<code class="fe mv mw mx my b">WireMockServer</code>重置为默认设置，并删除所有HTTP存根。这为我们的每个测试提供了一个清晰的设置。</p><p id="33fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意</strong>:我最初用Spring Boot 3.0.0-M5开发了一个客户服务客户端。然而，我遇到了与servlet APIs相关的错误，主要是因为WireMock依赖于Jetty 9而不是Jetty 11。WireMock还没有兼容Jakarta EE 9的版本，这是Spring Boot 3的基线。关于这个话题有一个<a class="ae lu" href="https://github.com/wiremock/wiremock/issues/1760" rel="noopener ugc nofollow" target="_blank">未解决的问题</a>。</p><p id="84bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出于这个原因，我修改了这个应用程序，使用Spring Boot 2.7.5，这是我写这篇文章时最新的2.x版本。这是升级到Spring Boot 3的挑战之一的一个例子，由于第三方库还没有提供Jakarta EE 9兼容版本。</p><h1 id="cea8" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">摘要</h1><p id="209f" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">我们在这个故事中探讨了假装反应。结合两个世界的精华，在Spring WebClient的快速、异步和非阻塞HTTP客户端上编写客户端API的简明语法Feign Reactive为任何REST API消费提供了一个完美的解决方案。我们深入探讨了如何在REST API客户端应用程序中实现Feign Reactive。</p><p id="0f54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还探索了如何用WireMock测试Feign Reactive实现。我希望这个故事对您有所帮助，并且我鼓励您在下一个REST API客户端项目中尝试一下Feign Reactive。</p><p id="c50b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个故事的源代码可以在我的<a class="ae lu" href="https://github.com/wenqiglantz/customer-service-client-feign-reactive" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。</p><p id="be65" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编码快乐！</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="4414" class="lw lx it bd ly lz nw mb mc md nx mf mg jz ny ka mi kc nz kd mk kf oa kg mm mn bi translated">参考</h1><p id="8fa8" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated"><a class="ae lu" href="https://github.com/PlaytikaOSS/feign-reactive" rel="noopener ugc nofollow" target="_blank">https://github.com/PlaytikaOSS/feign-reactive</a></p><p id="7de5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://wiremock.org/" rel="noopener ugc nofollow" target="_blank">灵活的API模拟| WireMock </a></p><p id="0447" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://rieckpil.de/spring-boot-integration-tests-with-wiremock-and-junit-5/" rel="noopener ugc nofollow" target="_blank">使用WireMock和JUnit 5进行Spring Boot集成测试— rieckpil </a></p></div></div>    
</body>
</html>