<html>
<head>
<title>Is Pandas for Web Scraping Not Enough? Try Beautiful Soup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫用于网页抓取还不够吗？尝尝美味的汤</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-pandas-for-web-scraping-not-enough-try-beautiful-soup-98d0362d5bb1?source=collection_archive---------4-----------------------#2021-09-27">https://betterprogramming.pub/how-to-use-pandas-for-web-scraping-not-enough-try-beautiful-soup-98d0362d5bb1?source=collection_archive---------4-----------------------#2021-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="30c6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从熊猫到美味的汤——高级网页抓取变得简单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1767c653901815a892cd4780dec65af0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c5_FVIbUnybThkom"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sagarkulkarni?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">萨加尔·库尔卡尼</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5d84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经进入互联网时代几十年了，在此期间，互联网积累了大量的数据。无论你的专业是什么，你都会在互联网的某个地方找到有用的数据。如果你正在考虑从事数据科学职业，你不应该担心没有玩具数据集可以玩，只要从互联网上抓取一些数据就可以了。</p><p id="92b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等，我忘了网站上显示的许多数据都不是数据科学友好的格式。相反，它们是作为适用的HTML元素呈现的。因此，获取这些数据的一个必要步骤是将HTML格式转换成表格格式。在本教程中，我们将学习如何使用网络抓取技术从网站获取类似表格的数据。</p><p id="39a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">免责声明:可能有关于网页抓取的法律规定。这篇文章并不打算作为一个网页抓取的认可。在这里，我们将专注于一个技术细节，并使用维基百科作为数据源，这是在<a class="ae ky" href="https://en.wikipedia.org/wiki/Wikipedia:Copyrights" rel="noopener ugc nofollow" target="_blank">自由文档许可</a>下。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a5ad" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">是的，熊猫是可能的</h1><p id="7a15" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">毫无疑问，许多数据科学家使用Python作为他们数据科学项目的工作语言。如果你在Python阵营中，你可能也使用Pandas，它是最通用的数据处理和操作库之一。信不信由你，你可以用熊猫来完成原始的网页抓取工作——就像一行代码那么简单。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b8d3" class="ne md it na b gy nf ng l nh ni">dfs = pd.read_html("the_url_to_the_website")</span></pre><p id="8d1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与创建单个<code class="fe nj nk nl na b">DataFrame</code>的其他<code class="fe nj nk nl na b">read_</code>函数不同，<code class="fe nj nk nl na b">read_html</code>函数返回一个<code class="fe nj nk nl na b">DataFrame</code>列表，每个列表对应于网页中的一个表。让我们用一个例子(<a class="ae ky" href="https://en.wikipedia.org/wiki/List_of_countries_by_population_(United_Nations)" rel="noopener ugc nofollow" target="_blank">网页链接</a>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">熊猫读HTML</p></figure><p id="1d76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上图，熊猫看了这个网页，得到了两个<code class="fe nj nk nl na b">DataFrame</code>物体。当然，当您有两个表格时，您很容易就能判断出哪个是哪个——您可以简单地查看两个表格，然后选择您想要使用的表格。我</p><p id="ce27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，这是我们需要按国家研究人口的第一个表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过read_html创建了数据帧</p></figure><p id="e53a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，在原始网页上，原始群体使用逗号来分隔每三个数字，Pandas删除了这些逗号，并正确地将它们转换为整数——这是一种数据科学家友好的数据类型。它再次强调了Pandas作为一个有用的数据处理库的多功能性。</p><p id="8d9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，网页上有多个表格。虽然我们可以仔细检查每个数据帧，看看哪一个是我们需要的数据，但定位它可能很繁琐。这不是Python或熊猫的工作方式，因为它应该是简洁的，让我们的生活变得简单。毫不奇怪，<code class="fe nj nk nl na b">read_html</code>有一个您想要使用的参数— <code class="fe nj nk nl na b">match</code>，您可以为它指定表应该包含的文本(字符串或正则表达式)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表中文本的规格</p></figure><p id="a7c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，我们指定表应该包含<code class="fe nj nk nl na b">“UN statistical”</code>，这样就只创建了一个<code class="fe nj nk nl na b">DataFrame</code>。</p><p id="a678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，当在HTML文档中找不到表格时，<code class="fe nj nk nl na b">read_html</code>会抛出<code class="fe nj nk nl na b">Value_Error</code>。换句话说，这个函数只能抓取网页上的表格，如果你想获取其他数据，这就构成了一个限制。因此，我们应该考虑替代方案——更高级的web抓取的<a class="ae ky" href="https://pypi.org/project/beautifulsoup4/" rel="noopener ugc nofollow" target="_blank"> Beautiful Soup </a>库。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f4dd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">美丽的汤</h1><p id="3ddf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Beautiful Soup是一个强大的库，专门处理HTML或XML文档。您可以使用这个库来搜索和修改解析树，您可以将解析树想象成使用一系列分层标签的有组织的结构。您可以使用<code class="fe nj nk nl na b">pip</code>或<code class="fe nj nk nl na b">conda</code>安装这个库。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e5ee" class="ne md it na b gy nf ng l nh ni"># using pip<br/>pip install beautifulsoup4</span><span id="f79d" class="ne md it na b gy no ng l nh ni"># using conda<br/>conda install beautifulsoup4</span></pre><p id="6c9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便提一下，当你对熊猫使用<code class="fe nj nk nl na b">read_html</code>时，你可能会注意到你会被要求安装漂亮的汤和其他支持包(例如<code class="fe nj nk nl na b">lxml</code>或<code class="fe nj nk nl na b">html5lib</code>)。您想要安装的另一个库是<code class="fe nj nk nl na b">requests</code>，它对于发出web请求以获取web页面的原始源代码特别方便。</p><h2 id="2a7d" class="ne md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">第一步。获取HTML文档</h2><p id="b4f9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们开始抓取web页面之前，让我们首先获取HTML文档以进行离线处理。下面的代码向您展示了第一步。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">获取HTML文档</p></figure><p id="4173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们使用<code class="fe nj nk nl na b">requests</code>来运行获取web页面的GET请求，并且我们可以通过访问响应的<code class="fe nj nk nl na b">text</code>属性来获取文档。这份文件已经准备好了。</p><h2 id="5b1b" class="ne md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">第二步。检查所需的元件</h2><p id="8ade" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对源页面有一个很好的理解是提取你需要的信息的基本步骤。事实上，你可能知道，你可以在你的网络浏览器中查看网页的源代码，比如Chrome或者Firefox。在我们的情况下，您可以通过链接查看:view-source:<a class="ae ky" href="https://en.wikipedia.org/wiki/List_of_countries_by_population_(United_Nations)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/List _ of _ countries _ by _ population _(United Nations)</a>，如下图快速浏览。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/e6024791f861bf9b6de67966bbd81861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b3vo02sQN91YYM4DUMiSTQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">网页源代码的屏幕截图</p></figure><p id="c58d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了在web浏览器中查看代码之外，Beautiful Soup还提供了一种以可读方式查看源代码的编程方式，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由美汤整理的网页源代码</p></figure><p id="692a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看静态源代码可能没有帮助，因为文本太多了！相反，使用Chrome或Firefox的开发工具检查这些元素是个好主意。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/921890cce28511ee943bf5b745dfb7fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZEokWOjRoSB9tsB_r6Yzw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">检查HTML元素</p></figure><p id="5102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您只需将鼠标放在您感兴趣的元素上，检查器就会突出显示该元素的信息。例如，我们知道标题有一个标签h1，它的id是<code class="fe nj nk nl na b">firstHeading</code>，它的类是<code class="fe nj nk nl na b">firstHeading</code>。</p><p id="2efc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查的想法是为您需要的元素收集可识别的信息，如<code class="fe nj nk nl na b">tag</code>、<code class="fe nj nk nl na b">id</code>和<code class="fe nj nk nl na b">class</code>。</p><h2 id="5163" class="ne md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">第三步。提取数据</h2><p id="ecd7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一旦有了商品的可识别信息，就该从网页中提取数据了。有几种方法可以做到这一点，选择哪种方法完全取决于您的需求。让我们一个一个来看。</p><p id="a434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对特定的元素<strong class="lb iu"> </strong>感兴趣，并且知道它的id，这可能是最简单的场景:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7273" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; heading = soup.find(id="firstHeading")<br/>heading<br/>&gt;&gt;&gt; &lt;h1 class="firstHeading" id="firstHeading"&gt;List of countries by population (United Nations)&lt;/h1&gt;<br/>&gt;&gt;&gt; type(heading)<br/>&lt;class 'bs4.element.Tag'&gt;<br/>&gt;&gt;&gt; heading.text<br/>'List of countries by population (United Nations)'</span></pre><p id="92c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们通过指定元素的<code class="fe nj nk nl na b">id</code>来使用<code class="fe nj nk nl na b">find</code>方法，并获得元素，该元素被Beautiful Soup解析为一个<code class="fe nj nk nl na b">Tag</code>对象。对于这个对象，我们可以通过访问它的<code class="fe nj nk nl na b">text</code>属性来检索标题。</p><p id="2351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，您只需获得网页的第一个标题。如果您有多个网页，您可以按顺序处理它们以检索第一个标题。</p><p id="8750" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，您可以通过指定标记名来使用<code class="fe nj nk nl na b">find</code>方法。但是，它将返回匹配标签的第一个元素。因为我们知道只有h1元素，所以我们可以通过调用:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="abfc" class="ne md it na b gy nf ng l nh ni">soup.find("h1")</span></pre><p id="dcaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对一组元素感兴趣，您应该考虑<code class="fe nj nk nl na b">find_all</code>方法。例如，让我们检索所有h2标题，以了解web文档的组织。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">找到一组元素</p></figure><p id="b7dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我向您展示了使用<code class="fe nj nk nl na b">find_all</code>方法将检索带有标签h2的所有元素。对于这些元素，我们可以得到所有的字幕，因为<code class="fe nj nk nl na b">headings</code>是一个迭代器。</p><p id="658d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不知道要查找什么元素，但是您有兴趣找出包含某个字符串的元素，该怎么办？在这种情况下，您可以简单地让Beautiful Soup为您完成繁重的工作—它可以搜索特定的字符串，如下所示。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="83b0" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; soup.find(text="United Nations").parent<br/>&lt;a href="/wiki/United_Nations" title="United Nations"&gt;United Nations&lt;/a&gt;</span></pre><p id="d3aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用文本<code class="fe nj nk nl na b">“United Nations”</code>的规范，<code class="fe nj nk nl na b">find</code>方法定位元素。通常，元素本身并不是您想要的，在大多数情况下，您可以通过访问<code class="fe nj nk nl na b">parent</code>属性来检查元素的父元素。当然，如果您想用这个字符串找出更多的元素，您可以简单地使用<code class="fe nj nk nl na b">find_all</code>方法。</p><p id="a684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们已经向您展示了如何在Pandas中使用read_html来刮擦一张表，但是这是一个可行的任务，您可以自己用漂亮的汤来完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用美味的汤解析桌子</p></figure><p id="9117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段向您展示了解析表的一种可能的解决方案。有几点值得注意:</p><ul class=""><li id="c9c6" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated">表格元素有<code class="fe nj nk nl na b">“table”</code>标签。我们可以用<code class="fe nj nk nl na b">find</code>的方法来定位。</li><li id="09f8" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">在HTML文档中，每个表格行都有一个标签<code class="fe nj nk nl na b">“tr”</code>。在每一行中，使用标签<code class="fe nj nk nl na b">“td”</code>将数据显示为列。因此，我们迭代行，对于每一行，我们迭代列。</li><li id="fc81" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">所有数据都保存为字符串。所以，如果你想进行你的项目，进一步清理桌子是很重要的。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7d11" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="348d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们首先回顾了如何通过一个熊猫函数调用——<code class="fe nj nk nl na b">read_html</code>函数轻松地抓取表格。与其他Pandas <code class="fe nj nk nl na b">read_*</code>方法不同，<code class="fe nj nk nl na b">read_html</code>调用创建了一个<code class="fe nj nk nl na b">DataFrame</code>列表。请注意，只有当网页上有表格元素时，该函数才起作用。</p><p id="6e3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有更高级的web抓取需求，您可能想要尝试Beautiful Soup library，它专门处理HTML和XML文档。通过创建解析树，Beautiful Soup可以很容易地通过id、类、标签甚至属性来定位所需的元素，尽管最后一种方法不在本文讨论范围内。</p><p id="33a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，Beautiful Soup提供的所有功能几乎都可以满足您处理网页以提取所需数据的需要。正如您可能已经发现的那样，web抓取听起来可能非常技术性，但是对于像获取一些数据这样的基本用例来说，它并没有那么难，对吗？</p></div></div>    
</body>
</html>