<html>
<head>
<title>Execution Context, Lexical Environment, and Closures in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的执行上下文、词汇环境和闭包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/execution-context-lexical-environment-and-closures-in-javascript-b57c979341a5?source=collection_archive---------0-----------------------#2019-12-10">https://betterprogramming.pub/execution-context-lexical-environment-and-closures-in-javascript-b57c979341a5?source=collection_archive---------0-----------------------#2019-12-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8f69" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你应该知道的高级JavaScript概念</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4cd7dfb6d344c1494e05de9a901e1f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nsyTe-M1-pnBDeLq"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lepetitpatte?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">哈维尔·塞拉</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3e07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我想谈谈三个高级JavaScript概念:执行上下文、词法环境和闭包。</p><p id="7eeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将是一篇长文。如果您想跳到摘要，请滚动到页面底部。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8bcd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是执行上下文？</h1><p id="8ba0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">那么，什么是执行上下文呢？每当你写一些代码时，你的代码都在一个空间中——这个空间被称为“执行上下文”。假设您编写了一个简单的计算器:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="78d8" class="ne md it na b gy nf ng l nh ni">function cal(type, a, b) {<br/>  if (type === 'add') {<br/>    return a + b;<br/>  } else if (type === 'subtract') {<br/>    return a - b; <br/>  } else if (type === 'multiply') {<br/>    return a * b; <br/>  } else {<br/>    return a / b; <br/>  }<br/>}<br/><br/>var four = 4;<br/>var seven = 7;<br/>cal('add', 4, 7);</span></pre><p id="631e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，每当调用一个函数时，都会在当前运行的执行上下文上创建一个新的执行上下文。新创建的一个存储在执行上下文的堆栈中。</p><p id="f9d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们调用<code class="fe nj nk nl na b">cal()</code>，新的上下文将被创建，并被推送到上下文堆栈中。但是，默认情况下，堆栈中已经存在一个上下文—全局执行上下文。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/c82ef2e5f0828c94237fb170b0b6c23c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y8oX0ddZ8vXcOnRIM2yjzw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">执行上下文的基本概念</p></figure><p id="3f16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先调用并运行函数<code class="fe nj nk nl na b">cal</code>,这样就创建了新的执行上下文。然后，它被存储在上下文堆栈中。然后，当前执行上下文的控制被转移到新创建的上下文，在这种情况下，是从全局上下文转移的。</p><p id="4669" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当您调用一个函数时，就会创建一个执行上下文。使用JavaScript开发时，您可能会看到以下错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/1f730c84c64dd4646ee71c3a6b4f8a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8B-c5fttUyKRuoRzLtKfCQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">调用堆栈错误</p></figure><p id="691e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数<code class="fe nj nk nl na b">a</code>不断递归调用自己。每次<code class="fe nj nk nl na b">a</code>调用自己时，一个关于<code class="fe nj nk nl na b">a</code>的新的执行上下文将被创建并存储在堆栈中。因为内存堆栈的存储空间不是无限的，所以它会溢出。</p><p id="a2ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你知道了什么是执行上下文，但是还有更多要学习。我们稍后会进一步讨论这个问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1ecb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">词汇环境</h1><p id="1c2b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当你运行一个函数或者声明一个变量或者函数的时候会发生什么？我几乎没有解释过，每个函数调用都会创建一个执行上下文，默认情况下，堆栈中有一个全局执行上下文。执行上下文分为三个不同的区域。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/de649a927b59a34055a00ecf75753e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tq3-6dXcBbDH2XAE2uMC5Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在执行上下文中</p></figure><p id="adcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行上下文中的前两个部分——<code class="fe nj nk nl na b">LexicalEnvironment</code>和<code class="fe nj nk nl na b">VariableEnvironment</code>，非常相似，所以我想我可以称它们为<code class="fe nj nk nl na b">LexicalEnvironment</code>。<code class="fe nj nk nl na b">LexicalEnvironment</code>所做的是跟踪变量、函数名和相关的值。换句话说，如果你声明一个函数<code class="fe nj nk nl na b">foo</code>,如上图所示，那么<em class="np">词汇环境</em>将如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f4b4" class="ne md it na b gy nf ng l nh ni">function foo() {<br/>  var a = 10;<br/>  function bar() {<br/>    <br/>  }<br/>}<br/>foo();<br/><br/>// When foo is called, a new execution environment <br/>// might look like this below<br/>execution_environment: {<br/>  LexicalEnvironment: {<br/>    a: 10,<br/>    bar: function() {}<br/>  },<br/>  ThisBinding: ...<br/>}</span></pre><p id="9a88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在知道什么是<code class="fe nj nk nl na b">LexicalEnvironment</code>了，它有什么作用。</p><p id="594b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如执行上下文由三部分组成一样，<code class="fe nj nk nl na b">LexicalEnvironment</code>也由几部分组成。它有一个<code class="fe nj nk nl na b">EnvironmentRecord </code>——我称之为环境记录，以及一个外部词法环境，你可能认为它是作用域。</p><p id="bb5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你声明一个变量或函数时，它们实际上被存储在它的环境记录中。链接属性值基本上意味着链接属于环境记录的属性值。</p><p id="3ea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe nj nk nl na b">LexicalEnvironment</code>被创建时，对外部词法环境的引用也被创建。它直接链接到父<code class="fe nj nk nl na b">LexicalEnvironment</code>，JavaScript在当前<code class="fe nj nk nl na b">LexicalEnvironment</code>中找不到属性时使用这个值。如果它仍然不能在父词典环境中找到它，那么它将再次找到父词典<code class="fe nj nk nl na b">LexicalEnvironment</code>。这个过程不会停止，直到它找到它要找的东西，或者直到没有东西连接到<code class="fe nj nk nl na b">LexicalEnvironment</code> <em class="np">。</em>全局<code class="fe nj nk nl na b">LexicalEnvironment</code>没有父级<code class="fe nj nk nl na b">LexicalEnvironment</code>。所以，当JavaScript试图在全局<code class="fe nj nk nl na b">LexicalEnvironment</code>中寻找某些东西时，一个<code class="fe nj nk nl na b">Reference Error</code> <em class="np"> </em>发生了。</p><h2 id="dcf8" class="ne md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">附图示例</h2><p id="6aab" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了更好地理解这个流程，让我们看一下这个例子:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bcf1" class="ne md it na b gy nf ng l nh ni">var x = 1;<br/>function foo() {<br/>  var y = 2;<br/>  function bar() {<br/>    var z = 3;<br/>    function baz() {<br/>      console.log(z);<br/>      console.log(y);<br/>      console.log(x);<br/>      console.log(w);<br/>    }<br/>    baz();<br/>  }<br/>  bar();<br/>}<br/>foo();<br/>// 3<br/>// 2<br/>// 1<br/>// Reference Error: w is not defined</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/aaefa4990ef25bf17c4da2dc3d667d8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mgMVD4qrQiHUma0B0bti4w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">全球词汇环境</p></figure><p id="9665" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当JavaScript运行代码时，变量<code class="fe nj nk nl na b">x</code>和函数<code class="fe nj nk nl na b">foo</code>在全局<code class="fe nj nk nl na b">LexicalEnvironment</code>中声明。正如我解释过的，全局的外部不指向任何东西。当JavaScript遇到<code class="fe nj nk nl na b">foo()</code>时，运行该函数，新的<em class="np"> </em> <code class="fe nj nk nl na b">foo</code> <em class="np"> </em>的<code class="fe nj nk nl na b"><em class="np"> </em>LexicalEnvironment</code> <em class="np"> </em>被创建。它的外部链接链接到其父级的全局<code class="fe nj nk nl na b">LexicalEnvironment</code>。下图说明了示例代码中的整个关系:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/23a69e6de0f349568bc82acace3d6a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M0kOEUDXY9Uenz4SwRbyEg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">词汇环境之间的整体关系</p></figure><p id="30f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在每个<code class="fe nj nk nl na b">LexicalEnvironment</code>中看到<code class="fe nj nk nl na b">outer</code>指向父<code class="fe nj nk nl na b">LexicalEnvironment</code>。</p><p id="cb48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe nj nk nl na b">baz()</code>被调用时，它寻找<code class="fe nj nk nl na b">z</code>、<code class="fe nj nk nl na b">y</code>、<code class="fe nj nk nl na b">x</code>和<code class="fe nj nk nl na b">w</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/1852b2bc615fc95593805beafabd0922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ehLSqZrs1vPTpBXCg5akFQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查找z和w时的工作流</p></figure><p id="66e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样的流程，查找变量<code class="fe nj nk nl na b">y</code>和<code class="fe nj nk nl na b">x</code>做同样的工作——检查当前<code class="fe nj nk nl na b"><em class="np"> LexicalEnvironment</em></code>中是否存在该值，如果没有变量，则移动到父变量。但是对于<code class="fe nj nk nl na b">w</code>，它在代码中不存在，所以我们以引用错误结束。</p><p id="48df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是你通常听到的作用域链。<strong class="lb iu">但是请记住，连接到父环境的外部环境是在声明函数时确定的，而不是在调用函数时确定的</strong> ( <a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-10.2" rel="noopener ugc nofollow" target="_blank">单击此处</a>以获得更多信息)。例如，猜测<code class="fe nj nk nl na b">bar()</code>的返回值。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="aced" class="ne md it na b gy nf ng l nh ni">var x = 1;<br/>function foo() {<br/>  var x = 2;<br/>  bar();<br/>}<br/><br/>function bar() {<br/>  console.log(x); <br/>}<br/><br/>foo(); // 1</span></pre><p id="f25d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么<code class="fe nj nk nl na b">foo()</code>的结果是1而不是2？正如我所说，外部引用是父节点的<code class="fe nj nk nl na b">LexicalEnvironment</code>，而不是围绕它的函数。</p><h2 id="d0c6" class="ne md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">这种绑定</h2><p id="cecd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">执行上下文中的引用<code class="fe nj nk nl na b">ThisBinding</code>决定了如何调用函数。我将在另一篇文章中更多地谈论这个话题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5c1d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">返回执行上下文</h1><p id="36a2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，您知道了执行上下文中的内容— <code class="fe nj nk nl na b">LexicalEnvironment</code>和<code class="fe nj nk nl na b">ThisBinding</code>。实际上有两种执行上下文——<strong class="lb iu">全局</strong>执行上下文和<strong class="lb iu">函数</strong>执行上下文。</p><p id="496c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">全局执行上下文是JavaScript中全局对象的执行上下文，是一切的根源。它包含几个对象。其中之一是<code class="fe nj nk nl na b">window </code>——当JavaScript解析和解释您的脚本时，它实际上首先运行这个。(当然，这并不完全是JavaScript的工作方式)。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ba18" class="ne md it na b gy nf ng l nh ni">&lt;script&gt;<br/>  window = {<br/>    ClipboardCopyElement: class ClipboardCopyElement,<br/>    CodeMirror: f Ea,<br/>    DetailDialogElement: class DetailDialogElement,<br/>    ...<br/>  };<br/>  <br/>  GlobalExecutionContext: {<br/>    LexicalEnvironment: {<br/>      window: window,<br/>      outer: null<br/>    },<br/>    ThisBinding: window<br/>  }<br/>&lt;/script&gt;</span></pre><p id="0cbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么你可以使用<code class="fe nj nk nl na b">window.document</code>或<code class="fe nj nk nl na b">window.setTimeout</code>，因为它们都在全局对象的<code class="fe nj nk nl na b">LexicalEnvironment</code>中。</p><p id="0d70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数执行上下文呢？它就像一个全局执行上下文，但是内部不存在<code class="fe nj nk nl na b">window</code>或其他全局对象，它是在函数被调用时创建的。全局执行上下文和函数执行上下文的共同点是它们在运行时都有两个阶段:创建和执行阶段。在创建阶段，声明变量和函数:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3baa" class="ne md it na b gy nf ng l nh ni">var x = 1;<br/>function foo() {<br/>  var x = 2; <br/>  function bar() {<br/>    var x = 3; <br/>  }<br/>}<br/>console.log(y);<br/>var y = 3;<br/><br/>foo();</span></pre><p id="bc30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行代码的第一步是创建全局执行上下文。动作的控制处于创建阶段。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/d030cebbd8a085c01c8cb127b2d1e71b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7JnDblYyuq1dLJRui0Wlg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建阶段—图像源从<a class="ae ky" href="https://tylermcginnis.com/javascript-visualizer/" rel="noopener ugc nofollow" target="_blank">到这里</a></p></figure><p id="f635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在创建阶段，变量默认由<code class="fe nj nk nl na b">undefined</code>设置。另一方面，函数是由一个函数分配的——就像上面例子中的<code class="fe nj nk nl na b">foo</code>。需要注意的是<code class="fe nj nk nl na b">y</code>也被定义为<code class="fe nj nk nl na b">undefined</code>，尽管它是在<code class="fe nj nk nl na b">console.log</code>之后声明的。这种症状在JavaScript中被称为“提升”。提升意味着在执行阶段之前，变量和函数被声明并赋予默认值，通常为<code class="fe nj nk nl na b">undefined</code>。</p><p id="97e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当控件进入执行阶段时，它会从头开始运行每段代码。将被执行的第一条语句是<code class="fe nj nk nl na b">console.log(y)</code>，它打印出<code class="fe nj nk nl na b">undefined</code>。然后<code class="fe nj nk nl na b">y</code>被设置为三。下一步是运行<code class="fe nj nk nl na b">foo()</code>。当调用一个函数时，会创建一个新的执行上下文并将其推入调用堆栈。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/407f6793e8ac6dc7dce5f338d7601508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kcQH7Og2x-74RUNGjWgRyA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">功能-图像源的创建阶段从<a class="ae ky" href="https://tylermcginnis.com/javascript-visualizer/" rel="noopener ugc nofollow" target="_blank">开始，此处为</a></p></figure><p id="39a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个函数被调用时，会产生一个函数执行上下文。那么它的创建阶段首先开始。函数执行上下文的<code class="fe nj nk nl na b">LexicalEnvironment</code>定义了它需要的所有变量。特殊对象<code class="fe nj nk nl na b">arguments</code>，是每个函数<code class="fe nj nk nl na b">LexicalEnvironment</code>中定义的变量的一部分。你可以看到有一个功能<code class="fe nj nk nl na b">bar()</code>。然后调用<code class="fe nj nk nl na b">bar</code>——它的执行上下文在创建后也将存储在堆栈中。</p><p id="88f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦函数中的所有代码都被执行，它的执行上下文就从堆栈中删除。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这个视频是由泰勒·麦金尼斯制作的</p></figure><p id="48ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个视频中，演讲者很好地解释了JavaScript中执行上下文切换的工作流程。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0e41" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">关闭</h1><p id="ba4d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我解释说<code class="fe nj nk nl na b">LexicalEnvironment</code>也有一个外部环境，是指父母的<code class="fe nj nk nl na b">LexicalEnvironment</code>。看一下这个例子:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="78bc" class="ne md it na b gy nf ng l nh ni">var x = 1;<br/>function foo(y) {<br/>  return function(z) {<br/>    return x + y + z;	<br/>  }<br/>}<br/><br/>var f = foo(2);</span></pre><p id="515f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在web控制台上运行此命令，您将看到以下内容:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ee48" class="ne md it na b gy nf ng l nh ni">console.dir(f);</span></pre><div class="kj kk kl km gt ab cb"><figure class="ok kn ol om on oo op paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/a89a91bb7a02430862fd0dbf693eee56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*_88CGX-mKcoIWiibh-p39w.png"/></div></figure><figure class="ok kn oq om on oo op paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/f68eeda8b7030466264e321c6b9b5212.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*JcMQbqnbSqXuyQorlaaH_g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk or di os ot translated">结束看起来像这样</p></figure></div><p id="f337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">左边是你能从谷歌控制台看到的，右边是你能从JavaScript可视化工具看到的——你能在这里看到的网页<a class="ae ky" href="https://tylermcginnis.com/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="8ce6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发生了什么事？当函数<code class="fe nj nk nl na b">foo</code>被执行时，它返回一个新函数。<code class="fe nj nk nl na b">f</code>现在有了<code class="fe nj nk nl na b">foo</code>的返回值。但是在<code class="fe nj nk nl na b">f</code>中，有一个新的范围对象，名为<code class="fe nj nk nl na b">Closure</code>。即使<code class="fe nj nk nl na b">foo</code>的执行上下文已经从堆栈中移除，引用链仍然被变量<code class="fe nj nk nl na b">f</code>激活。那么如果我们执行<code class="fe nj nk nl na b">f</code>，现在是一个函数呢？</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="fe94" class="ne md it na b gy nf ng l nh ni">f(5);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/650cff218f343a47dfd8dd538f87f27b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j9DtoSqMnvPX0GpKnOKcOg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">closure-image源中的执行上下文来自<a class="ae ky" href="https://tylermcginnis.com/javascript-visualizer/" rel="noopener ugc nofollow" target="_blank">这里是</a></p></figure><p id="fc95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后新的执行上下文将被创建，如上图所示。<code class="fe nj nk nl na b">z</code>不在闭包范围内的原因是，它是<code class="fe nj nk nl na b">f</code>运行的函数的属性，在当前执行上下文中是活动的。</p><p id="3080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦<code class="fe nj nk nl na b">return x + y + z;</code>运行并且函数完成，那么<code class="fe nj nk nl na b">f</code>的执行上下文将被清除，闭包也将消失。</p><p id="2d96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MDN定义了闭包:</p><blockquote class="ov ow ox"><p id="296a" class="kz la np lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated">一个<strong class="lb iu">闭包</strong>是一个函数的组合，该函数被捆绑在一起(被封闭)并引用其周围的状态(即<strong class="lb iu">词法环境</strong>)。换句话说，闭包允许您从内部函数访问外部函数的范围。</p></blockquote><p id="d75a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Closure是一个允许您访问父函数作用域的函数，即使它已经从执行上下文堆栈中删除了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b3ee" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最终总结</h1><p id="67d6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要解释什么执行上下文、<code class="fe nj nk nl na b">LexicalEnvironment</code>、闭包等等，那是一个很长的故事。基本上，当JavaScript运行代码时，它会创建一个空间来存储和管理变量和函数。它记录名字和变化。每当一个函数被创建时，JavaScript就会产生这个空间，并把它放在堆栈的顶部，之前存在的空间从底部开始堆叠。这个空间被称为执行上下文。</p><p id="6080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript中有两种执行上下文——全局执行上下文和函数执行上下文。一个执行上下文由<code class="fe nj nk nl na b">LexicalEnvironment</code>和<code class="fe nj nk nl na b">ThisBinding</code>组成。<code class="fe nj nk nl na b">LexicalEnvironment</code>是实际存储和管理变量和函数的地方。<code class="fe nj nk nl na b">ThisBinding</code>是<code class="fe nj nk nl na b">this</code> <em class="np"> </em>的参考，但我们在这里没有涉及。</p><p id="3e33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript在管理变量和函数时有两个阶段——创建阶段和执行阶段。在创建阶段，变量被声明，但由缺省值设置，通常是<code class="fe nj nk nl na b">undefined</code>，而函数被同时声明和初始化。在创建阶段之后，动作控制转移到执行阶段，从文件的顶部开始，一个接一个地执行所有的代码。如果在这个阶段调用了一个函数，将会为该函数创建一个新的执行上下文，并存储在堆栈中。如果堆栈中有太多的上下文，我们也会确认发生引用错误。</p><p id="41d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使执行上下文在运行完内部的所有代码后被从堆栈中删除，当原始函数返回一个使用其作用域之外的变量的新函数时，对该函数的引用仍然有效。然后，到外部函数的链接不会被删除，直到它的代码被执行并完全从堆栈中移除。这就叫完结。闭包是一个允许你访问父函数作用域的函数，即使它的执行阶段已经结束。</p><h1 id="eb85" class="mc md it bd me mf pb mh mi mj pc ml mm jz pd ka mo kc pe kd mq kf pf kg ms mt bi translated">资源</h1><ul class=""><li id="03ca" class="pg ph it lb b lc mu lf mv li pi lm pj lq pk lu pl pm pn po bi translated"><a class="ae ky" href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/" rel="noopener ugc nofollow" target="_blank"> ECMAScript详解—词法环境</a></li><li id="67fa" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/20139050/what-really-is-a-declarative-environment-record-and-how-does-it-differ-from-an-a" rel="noopener ugc nofollow" target="_blank">stack overflow中的环境记录</a></li><li id="8458" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated"><a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-10.2" rel="noopener ugc nofollow" target="_blank">词法环境— ECMAScript规范</a></li><li id="d684" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated"><a class="ae ky" href="https://tylermcginnis.com/" rel="noopener ugc nofollow" target="_blank"> JavaScript可视化工具</a></li><li id="4684" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=Nt-qa_LlUH0" rel="noopener ugc nofollow" target="_blank">执行环境的终极指南——YouTube</a></li><li id="1979" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">MDN中的闭包</a></li></ul></div></div>    
</body>
</html>