<html>
<head>
<title>Build a Plug and Play CI/CD With Reusable GitHub Workflows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用可重用的GitHub工作流构建即插即用的CI/CD</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-plug-and-play-ci-cd-with-reusable-github-workflows-dc45b768a1ce?source=collection_archive---------10-----------------------#2022-10-26">https://betterprogramming.pub/build-a-plug-and-play-ci-cd-with-reusable-github-workflows-dc45b768a1ce?source=collection_archive---------10-----------------------#2022-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="26c9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我是如何停止将每个工作流程复制粘贴到无限的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d8a543c92ab72ca250a9d421059071df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wqVjJiY7LXQ3oF9a"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">管道中所有重复的工作流看起来完全一样。</p></figure><p id="ad4b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在GitHub网站上浏览“<em class="lr">初学者友好”</em>和<em class="lr">“非恐吓”</em>文档时，我发现了可重用工作流。我不打算撒谎，我非常兴奋地想到我可以节省多少复制和粘贴时间，我开始思考如何像乐高积木一样建造管道。事实证明，它需要一些规划才能工作，尽管对您想要运行的工作流和作业的高层次想法应该足以奠定基础。毕竟，你很可能在敏捷方法中工作，而且需求会不断发展。</p><p id="6e18" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你是GitHub平台的新手，<a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/understand-your-release-manager-learn-the-basics-of-ci-cd-in-github-652b3fe7e0e0">我推荐我以前的文章</a>，在那里我回顾了一些我将在这里提到的概念。现在，您已经熟悉了基础知识，让我们后退一步，介绍一下何时以及如何使用这些可重用的工作流。</p><p id="b1d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当在大型甚至中型项目上工作时，为了保持交付的节奏，一个好的CI/CD的实施是必须的。这意味着使用几个环境、流程和工作流，但它可能会很快升级为难以管理的大量脚本来维护和跟踪。因此，解决这个问题的最好方法之一是从软件工程概念中获得一些灵感，比如迪夫·托马斯和安迪·亨特的<em class="lr"> DRY3原则</em>(不要重复自己)，或者肯特·贝克的极限编程核心原则之一<em class="lr">“一次，而且只有一次。”。</em></p><h1 id="85aa" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">我们如何重复使用同样的砖块来建造管道？</h1><p id="b720" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">在编写任何脚本之前，尝试识别管道中的重复流程。一旦你有了它们，你就必须决定你想要运行的工作流程链以及安排它们的最佳方式。</p><p id="99b4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个常见的例子是有两个工作流，一个执行一些质量检查和验证可部署性，另一个在一些环境中实际部署您的代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/36fd05e01f8bbbc5e62394d97a3e2207.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y7CcAgiM3HY675xOblP3Rg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">CI/CD设置中的通用部署和验证工作流。</p></figure><p id="09b4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以这两个工作流为例，您可以假设我们将从执行一些检查开始，然后我们将转移到实际部署。在这种情况下，我们希望在我们的整个组织中执行相同的检查，以使我们的可交付成果每次都具有相同的质量，因此我们可以假设我们将重用验证工作流。</p><p id="10d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，调用者将是执行部署的脚本，它将调用我们的可信验证脚本来进行一些验证。但是在调用脚本之前，您需要首先检查以下条件之一:</p><ul class=""><li id="2808" class="mr ms iq kx b ky kz lb lc le mt li mu lm mv lq mw mx my mz bi translated">被调用的工作流位于公共存储库中。</li><li id="14d3" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated">两个工作流位于同一个存储库中。</li></ul><p id="b8b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你在一个组织中工作，如果还没有的话，记得让被称为的<em class="lr">工作流可访问。您可以转到存储库的设置，选择操作并启用可访问性。</em></p><p id="fa40" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">既然我们已经验证了对文件的访问，我们将把我们的工作流定义为可重用的。它就像任何其他工作流一样，但是我们添加了<code class="fe nf ng nh ni b">workflow_call</code>作为触发器。</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="bd69" class="nn lu iq ni b gy no np l nq nr">name: Validation</span><span id="9b4f" class="nn lu iq ni b gy ns np l nq nr">on:<br/>  <!-- -->workflow_dispatch: #enables manual execution<br/>  <!-- -->workflow_call: <!-- -->#enables reusability</span><span id="00ae" class="nn lu iq ni b gy ns np l nq nr">#add here some checks or jobs</span></pre><p id="0bc9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，通过添加以下语法，您可以在另一个工作流中引用这个<em class="lr">验证</em>工作流:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="ba36" class="nn lu iq ni b gy no np l nq nr">Uses:   USER_OR_ORG_NAME/REPO_NAME/.github/workflows/REUSABLE_WORKFLOW_FILE.yml@TAG_OR_BRANCH</span></pre><p id="9a29" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是整个工作流程的一个例子。</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="bd45" class="nn lu iq ni b gy no np l nq nr">name: Deployment</span><span id="570a" class="nn lu iq ni b gy ns np l nq nr">on:<br/>  pull_request:<br/>    branches:<br/>    - master</span><span id="0164" class="nn lu iq ni b gy ns np l nq nr">jobs:   <br/>  validation:     <br/>    uses: USER_OR_ORG_NAME/REPO_NAME/.github/workflows/validation.yml@main</span><span id="c56a" class="nn lu iq ni b gy ns np l nq nr">deployment:<br/>     #add here deployment steps</span></pre><p id="0e76" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如您所看到的，实现可重用的工作流并不需要太多时间。您不仅可以避免重复，还可以更轻松地跨环境实施一致性！你还需要其他理由来开始使用它们吗？</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><blockquote class="oa ob oc"><p id="6fe8" class="kv kw lr kx b ky kz jr la lb lc ju ld od lf lg lh oe lj lk ll of ln lo lp lq ij bi translated">每当你在代码中看到重复，就意味着错过了抽象的机会。</p><p id="ffe9" class="kv kw lr kx b ky kz jr la lb lc ju ld od lf lg lh oe lj lk ll of ln lo lp lq ij bi translated">——罗伯特·c·马丁在《干净的代码》中</p></blockquote></div></div>    
</body>
</html>