<html>
<head>
<title>React useMemo vs. useCallback: Similarities and Differences</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React useMemo与useCallback:异同</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-usememo-vs-usecallback-similarities-and-differences-ea2b1f8bb22b?source=collection_archive---------15-----------------------#2022-03-08">https://betterprogramming.pub/react-usememo-vs-usecallback-similarities-and-differences-ea2b1f8bb22b?source=collection_archive---------15-----------------------#2022-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a0c8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">两种反应钩的比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/68ee2deda237e7bbbcfabfb3f4cc927b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g6eNnN_ey6oH4V-0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@hichem350z?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Hichem Meghachou </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="002d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在React开发领域，我们得到的最棒的东西之一就是钩子。早在2019年，React hooks的引入实现了一种全新的处理逻辑的方式。钩子极大地改进了我们在不同组件之间实现、构造、隔离和共享逻辑的方式。</p><p id="ee57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直到三年后的今天，在写这篇文章的时候，我还在发现和学习一些关于某些钩子或其内部的新东西。最近引起我好奇心的事情之一是我经常使用的两个React挂钩:<code class="fe lv lw lx ly b">useMemo</code>和<code class="fe lv lw lx ly b">useCallback</code>。</p><h1 id="9102" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">他们的目的</h1><p id="ad70" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">这两个挂钩背后的目的是通过<a class="ae ky" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">记忆</a>来提高React性能。简而言之，记忆化是一种基于输入存储计算值的缓存技术。如果用相同的输入调用该函数，那么它将跳过计算并返回缓存的值。如果输入发生变化，它将重新计算值并缓存。</p><p id="c70b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">useMemo</code>和<code class="fe lv lw lx ly b">useCallback</code>都允许React开发人员轻松地记忆某些实体，这可以用来潜在地防止组件重新呈现。顾名思义，<code class="fe lv lw lx ly b">useCallback</code>钩子是专门用来记忆回调的。<code class="fe lv lw lx ly b">useMemo</code>钩子可以用于所有其他的静态实体，比如原语和对象。</p><h1 id="9ffd" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">相似之处</h1><p id="ed1d" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">实际上，<code class="fe lv lw lx ly b">useMemo</code>和<code class="fe lv lw lx ly b">useCallback</code>挂钩不仅有相同的目的，而且在用法上也非常相似。两个挂钩:</p><ul class=""><li id="12b4" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">必须在组件的顶层调用，就像所有的钩子一样。</li><li id="03b9" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">接受一个函数作为第一个参数，接受一组依赖项作为第二个参数。</li><li id="4a22" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">根据所提供的函数，返回一个在渲染中引用稳定的记忆值。</li><li id="9c24" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">当在依赖关系数组中检测到任何更改时，根据函数重新计算并记忆值。</li></ul><h1 id="a143" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">有区别吗？</h1><p id="ce4b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">那么有趣的问题就变成了:<code class="fe lv lw lx ly b">useMemo</code>和<code class="fe lv lw lx ly b">useCallback</code>有区别吗？如果有，它们到底是什么？</p><p id="da98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如本文前面已经提到的，一个小的区别是,<code class="fe lv lw lx ly b">useCallback</code>只能用于记忆回调，而<code class="fe lv lw lx ly b">useMemo</code>基本上用于所有其他的JavaScript实体。它们的目的和用法基本上是相同的，这使得它们所针对的不同实体似乎是钩子之间唯一的区别。</p><p id="75ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是从概念上讲，也可以通过使用<code class="fe lv lw lx ly b">useMemo</code>的<code class="fe lv lw lx ly b">useCallback</code>来模仿记忆功能的行为。虽然这看起来很奇怪，但是使用<code class="fe lv lw lx ly b">useMemo</code>并从工厂函数返回一个函数是可能的。理论上，这与使用<code class="fe lv lw lx ly b">useCallback</code>是一样的。</p><p id="9919" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这成立，这也意味着除了方便之外，<code class="fe lv lw lx ly b">useCallback</code>和<code class="fe lv lw lx ly b">useMemo</code>之间没有真正的区别。因此，问题变成了通过<code class="fe lv lw lx ly b">useCallback</code>钩子，通过执行<code class="fe lv lw lx ly b">useCallback(() =&gt; doSomething())</code>来记忆一个函数，和通过从工厂函数返回一个回调，通过执行<code class="fe lv lw lx ly b">useMemo(() =&gt; () =&gt; doSomething())</code>来记忆一个函数，这两者之间是否有区别？</p><h1 id="7fdf" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">深入挖掘</h1><p id="30b8" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在<a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">官方React hook docs </a>中，已经有小纸条通知我们<code class="fe lv lw lx ly b">useCallback(fn, deps)</code>等同于<code class="fe lv lw lx ly b">useMemo(() =&gt; fn, deps</code>。然而，这并没有给我们提供很多信息或背景。比如，这是否适用于所有类型的函数，尤其是内联函数？有边缘案例吗？为此，让我们深入研究一下这两个钩子的实现。</p><p id="c68b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个钩子的代码都在<code class="fe lv lw lx ly b">react-reconciler</code>包中，特别是在<a class="ae ky" href="https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiber.new.js" rel="noopener ugc nofollow" target="_blank">文件</a>中，该文件包含钩子的新React Fiber实现。在那里，你会找到所有钩子的代码，它们什么时候挂载，什么时候需要更新。为了发现我们正在考虑的两个记忆挂钩之间的区别，我们必须看看它们的更新函数:<code class="fe lv lw lx ly b">updateCallback</code>和<code class="fe lv lw lx ly b">updateMemo</code>。</p><p id="fbb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说<code class="fe lv lw lx ly b">useCallback</code>钩子的更新功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2214" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生了一些事情，但是最重要的事情是对<code class="fe lv lw lx ly b">useCallback</code>钩子的后续调用以下面的方式处理:</p><ol class=""><li id="622e" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nm nc nd ne bi translated">检索用于调用该挂钩的先前依赖关系(状态),并与当前依赖关系进行比较。</li><li id="09a9" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nm nc nd ne bi translated">如果它们相同，钩子将返回上一次运行的缓存回调。</li><li id="18d3" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nm nc nd ne bi translated">如果它们不相同，该函数将缓存当前的回调以及当前在<code class="fe lv lw lx ly b">hook.memoizedState</code>中的依赖关系。这些可能会在后续调用中重用。</li></ol><p id="3d69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们来看看<code class="fe lv lw lx ly b">useMemo</code>的更新功能实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8bac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们比较这两个更新函数，我们会发现它们几乎是相同的。在随后的钩子调用中，两个钩子基本上经历相同的过程。我们能发现的唯一区别是被记忆的值。</p><p id="f507" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">useCallback</code>的情况下，被记忆的值直接是第一个函数参数。在<code class="fe lv lw lx ly b">useMemo</code>的例子中，也使用了第一个函数参数，但方式略有不同。我们还可以看到，与<code class="fe lv lw lx ly b">callback</code>相比，它有一个不同的名字<code class="fe lv lw lx ly b">nextCreate</code>。钩子不会立即记忆所提供的函数，而是调用它并记忆结果值。</p><p id="35ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于此，我们可以重新回到最初的问题，关于<code class="fe lv lw lx ly b">useCallback(() =&gt; doSomething())</code>和<code class="fe lv lw lx ly b">useMemo(() =&gt; () =&gt; doSomething())</code>之间是否有区别。如果我们关注后者，这意味着钩子将调用工厂函数，并在mount上缓存<code class="fe lv lw lx ly b">() =&gt; doSomething()</code>函数。只要依赖关系不变，它就会一直使用缓存的版本。</p><p id="2927" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这正是<code class="fe lv lw lx ly b">useCallback</code>所做的，但是没有调用工厂函数，而是使用定义的函数。因为内存化是在React钩子中实现的，它只与之前的调用进行比较，这意味着内联定义的函数也可以很好地工作，并且在两个钩子之间完全相同。</p><h1 id="8304" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="ae43" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">本文比较了两种常用的用于记忆的React钩子，<code class="fe lv lw lx ly b">useCallback</code>和<code class="fe lv lw lx ly b">useMemo</code>。它们都是性能反应开发的基础。乍一看，这两个钩子极其相似，以至于人们可以怀疑是否有什么不同。有实际的区别吗？还是为了方便起见，它们用不同的名称包装了相同的逻辑？</p><p id="136c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了回答这个问题，本文深入研究了这两个钩子的实现。在这里，我们发现两个钩子背后的逻辑基本上是相同的，除了如何确定内存化的值。考虑到这种实现方式和React钩子中内存化的实现方式，内存化一个(内联)函数通常使用<code class="fe lv lw lx ly b">useCallback</code>还是从<code class="fe lv lw lx ly b">useMemo</code>返回是没有区别的。</p><p id="d31d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于此，可以得出结论，两个挂钩之间没有技术差异，两个独立的挂钩只是为了方便而存在。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="89c2" class="ny ma it ly b gy nz oa l ob oc"><strong class="ly iu">Want to Connect?</strong></span><span id="eb98" class="ny ma it ly b gy od oa l ob oc">If you liked this article, consider checking out the other entries in the <a class="ae ky" href="https://www.getrevue.co/profile/chakshunyu" rel="noopener ugc nofollow" target="_blank">Uncommon React</a> newsletter and my <a class="ae ky" href="https://twitter.com/keraito" rel="noopener ugc nofollow" target="_blank">Twitter</a> for future updates.</span></pre></div></div>    
</body>
</html>