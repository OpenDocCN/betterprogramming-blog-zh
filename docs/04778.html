<html>
<head>
<title>Implement a Reactive MVVM Architecture in Swift 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift 5中实施反应式MVVM架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mvvm-in-swift-infinite-scrolling-and-image-loading-d47780b06e23?source=collection_archive---------1-----------------------#2020-05-08">https://betterprogramming.pub/mvvm-in-swift-infinite-scrolling-and-image-loading-d47780b06e23?source=collection_archive---------1-----------------------#2020-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0b65" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用RxSwift、Codable和协调器设计模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2b098cb25a134c86be6414763753a9db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*roMy41ZsxUxoMHcbvQnVcg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@wasdrew?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安朵斯·瓦斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="297e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探索一个完整的基于示例应用程序的反应式MVVM实现，该实现从<a class="ae ky" href="https://unsplash.com/developers" rel="noopener ugc nofollow" target="_blank"> Unsplash API </a>获取照片，并以异步方式加载它们。</p><p id="1c71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将讨论如何实现无限滚动、图像缓存和正确导航。我们还将学习如何根据整体应用架构处理一些底层功能，因为MVVM只负责表示层。</p><p id="54b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该项目的源代码可以在文章的底部找到。</p><p id="0506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2971" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">快速设置</h1><p id="6c28" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，为了让我们的应用程序按照我们想要的方式运行，我们需要获得一个免费的Unsplash API密钥:</p><div class="mz na gp gr nb nc"><a href="https://unsplash.com/developers" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">Unsplash图像API |免费高清照片API</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">使用最大的免费高质量图像集合进行创作。受特雷罗信任，中等，和…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">unsplash.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq ks nc"/></div></div></a></div><p id="f091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">粘贴到<code class="fe nr ns nt nu b">Core Layer/Network/API Keys</code>目录下的<code class="fe nr ns nt nu b">APIKeys.swift</code>文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="8371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们准备探索这个项目。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7d53" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们开始吧</h1><p id="6d15" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们的项目分为四层(文件夹):</p><ul class=""><li id="d68e" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated"><strong class="lb iu">应用层:</strong>包含<code class="fe nr ns nt nu b">AppDelegate.swift</code>文件和<code class="fe nr ns nt nu b">AppCoordinator</code>，它负责设置我们应用程序的初始视图控制器(在本文中您将很快了解到更多)</li><li id="db63" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><strong class="lb iu">表示层:</strong>包含视图控制器、视图模型以及它们的协调器。它有两个场景:<code class="fe nr ns nt nu b">Photos</code>(在a <code class="fe nr ns nt nu b">UICollectionView</code>中显示未喷溅的照片)和<code class="fe nr ns nt nu b">PhotoDetail</code>(显示用户在<code class="fe nr ns nt nu b">Photos</code>场景中选择的照片)。</li><li id="c9c7" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><strong class="lb iu">业务逻辑层:</strong>由模型和服务组成。<code class="fe nr ns nt nu b">UnsplashPhoto</code>结构作为一个模型，代表我们从API中获取的一张特定的照片。我们使用服务来实现特定的业务逻辑——例如，获取未曝光照片的列表。</li><li id="ec73" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><strong class="lb iu">核心层:</strong>定义了我们的业务逻辑层和其他小工具运行所需的所有设置。例如，它包含基本URL、API密钥和网络客户端。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/600e21273f95c4adf94173c08081b715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*b7fL11UWBMkqkhhzYsUsDw.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="db5f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用协调员</h1><p id="6302" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我选择使用协调器设计模式，因为MVVM不包括应用程序内部的导航。虽然它相对简单，而且你可以通过阅读这篇文章来领会它的意思，但是你可以在这里随意了解它。</p><p id="93f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们提供基本的<code class="fe nr ns nt nu b">Coordinator</code>协议，<code class="fe nr ns nt nu b">PhotosCoordinator</code>和<code class="fe nr ns nt nu b">PhotoDetailCoordinator</code>将遵循该协议:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="05e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nr ns nt nu b">start()</code>方法负责创建当前的视图控制器及其依赖项，而<code class="fe nr ns nt nu b">coordinate(to)</code>在我们想要导航到另一个视图控制器时运行，它按顺序触发那个视图控制器的<code class="fe nr ns nt nu b">start()</code>方法。</p><p id="9e41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以设置应用程序的初始流程。我们定义了<code class="fe nr ns nt nu b">AppCoordinator</code>，它依赖于<code class="fe nr ns nt nu b">AppDelegate</code>提供的<code class="fe nr ns nt nu b">UIWindow</code>属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="5976" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到在<code class="fe nr ns nt nu b">AppCoordinator</code>的<code class="fe nr ns nt nu b">start()</code>方法内部，我们坐标到了<code class="fe nr ns nt nu b">PhotosCoordinator</code>，这就创建了我们app的初始场景:<code class="fe nr ns nt nu b">Photos</code>。</p><p id="21a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来探讨一下它的实现。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1dfc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">“照片”场景</h1><p id="6a4a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nr ns nt nu b">PhotosCoordinator</code>构造<code class="fe nr ns nt nu b">PhotosViewController</code>和<code class="fe nr ns nt nu b">PhotosViewModel</code>，如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="dde3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们为<code class="fe nr ns nt nu b">PhotosViewModel</code>提供了三个依赖项:</p><ul class=""><li id="a8ff" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated"><code class="fe nr ns nt nu b">UnsplashPhotosService</code>:获取<code class="fe nr ns nt nu b">UnsplashPhoto</code>模型数组</li><li id="1664" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><code class="fe nr ns nt nu b">DataLoadingService</code>:根据提供的URL加载并返回<code class="fe nr ns nt nu b">Data</code></li><li id="2006" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><code class="fe nr ns nt nu b">DataToImageService</code>:根据提供的<code class="fe nr ns nt nu b">Data</code>返回一个<code class="fe nr ns nt nu b">UIImage</code></li></ul><p id="4178" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们屏幕的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/82403294dcec021d06b9b4acc4822d3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JmScSaJIuhw1as8CY_p2Hw.png"/></div></div></figure><p id="4c76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们详细研究一下视图模型和视图控制器的实现(我们将从视图模型开始，因为它是独立于用户界面的，并且有明确的输入/输出区别，因此视图控制器的代码在这之后会更有意义)。</p><h2 id="728b" class="on md it bd me oo op dn mi oq or dp mm li os ot mo lm ou ov mq lq ow ox ms oy bi translated">'照片视图模型'</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="6bd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这个文件中定义了<code class="fe nr ns nt nu b">PhotosViewModel</code>协议及其实现。该协议描述了输入(从视图控制器接收的事件)和输出(视图控制器用来驱动其UI的视图模型的工作结果)。下面是我们如何在<code class="fe nr ns nt nu b">PhotosViewModelImplementation</code>中对输入做出反应并提供输出:</p><ul class=""><li id="6b9b" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated"><code class="fe nr ns nt nu b">PhotosViewController</code>加载并发送一个值到视图模型的<code class="fe nr ns nt nu b">viewDidLoad</code>继电器</li><li id="971b" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">视图模型的<code class="fe nr ns nt nu b">getPhotos()</code>方法被触发</li><li id="d9ac" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">检索一组<code class="fe nr ns nt nu b">UnsplashPhoto</code>并将其发送到<code class="fe nr ns nt nu b">unsplashPhotos</code>继电器</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="e37e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们还将相关的<code class="fe nr ns nt nu b">Bool</code>事件发送到<code class="fe nr ns nt nu b">isLoadingFirstPage</code>和<code class="fe nr ns nt nu b">isLoadingAdditionalPhotos</code>继电器上，我们的视图控制器使用它们来显示/隐藏一个加载指示器(在视图控制器部分中有更多相关信息)。</p><ul class=""><li id="a6a2" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated"><code class="fe nr ns nt nu b">PhotosViewController</code>使用<code class="fe nr ns nt nu b">unsplashPhotos</code>属性来驱动<code class="fe nr ns nt nu b">UICollectionView</code>并显示与收到的模型数量相对应的单元格数量</li><li id="3296" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><code class="fe nr ns nt nu b">PhotosViewController</code>向视图模型的<code class="fe nr ns nt nu b">willDisplayCellAtIndex</code>属性发送值，触发数据加载</li><li id="f7f8" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">当图像被加载时，它被发送到<code class="fe nr ns nt nu b">imageRetrievedSuccess</code>继电器上，<code class="fe nr ns nt nu b">PhotosViewController</code>用它在相应的单元格中显示图像</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们检查<code class="fe nr ns nt nu b">unsplashPhotos</code>属性是否包含正在显示的单元格的索引。然后，我们获取图像的URL并触发<code class="fe nr ns nt nu b">DataLoadingService</code>的<code class="fe nr ns nt nu b">loadData(at:)</code>方法，在后台观察结果，这样我们的主线程就不会被阻塞。</p><p id="691c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们接收到<code class="fe nr ns nt nu b">Data</code>时，我们调用<code class="fe nr ns nt nu b">DataToImageService</code>的<code class="fe nr ns nt nu b">getImage(from:)</code>方法来获得一个<code class="fe nr ns nt nu b">UIImage</code>对象。最后，我们或者向<code class="fe nr ns nt nu b">imageRetrievedError</code>属性发送一个事件(如果我们不能获得图像),或者向<code class="fe nr ns nt nu b">imageRetrievedSuccess</code>中继发送一个事件。</p><p id="70d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了优化内存的使用，我们还希望在数据加载的单元格从屏幕上消失时取消该任务。为此，我们提供了<code class="fe nr ns nt nu b">didEndDisplayingCellAtIndex</code>继电器，其使用如下:</p><ul class=""><li id="b90f" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">视图控制器注意到某个单元格在滚动<code class="fe nr ns nt nu b">UICollectionView</code>时消失了，并将其索引发送到<code class="fe nr ns nt nu b">didEndDisplayingCellAtIndex</code>属性上</li><li id="3add" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">视图模型调用<code class="fe nr ns nt nu b">DataLoadingService</code>的<code class="fe nr ns nt nu b">stopLoading(at:)</code>方法来取消正在进行的任务</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4e31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nr ns nt nu b">DataLoadingService</code>在字典中记录任务，并处理掉我们不再需要的任务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="b132" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还想导航到另一个屏幕，并在其中显示选定的图像及其描述，因此我们定义了<code class="fe nr ns nt nu b">didChoosePhotoWithId</code>继电器。当一个值被发送到继电器上时，我们触发<code class="fe nr ns nt nu b">PhotosCoordinator</code>的<code class="fe nr ns nt nu b">pushToPhotoDetail(with:)</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="e5cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在剩下最后一个特性——无限滚动。它允许我们按页面加载<code class="fe nr ns nt nu b">UnsplashPhoto</code>，节省API资源并优化性能。所以我们的目标是加载一个额外的<code class="fe nr ns nt nu b">UnsplashPhoto</code>数组，并将它附加到现有的数组中。我们通过在视图模型中定义<code class="fe nr ns nt nu b">didScrollToTheBottom</code>中继并像这样使用它来实现:</p><ul class=""><li id="9cdc" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">视图控制器注意到用户滚动到最后一个可用单元格，并向<code class="fe nr ns nt nu b">didScrollToTheBottom</code>继电器发送一个<code class="fe nr ns nt nu b">Void</code>事件</li><li id="b115" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">视图模型通过递增<code class="fe nr ns nt nu b">pageNumber</code>并触发额外的数据获取来做出反应</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0209" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们实现了分页功能:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/c735f232912f8a6f594df1356f33dc8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/1*8byt48cw_FgHp8LrABYjiA.gif"/></div></figure><h2 id="6009" class="on md it bd me oo op dn mi oq or dp mm li os ot mo lm ou ov mq lq ow ox ms oy bi translated">'照片视图控制器'</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="6591" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不会讨论UI是如何创建的，因为这不是本文的重点。如果你想了解程序化的<code class="fe nr ns nt nu b">UICollectionView</code>实现，请访问<a class="ae ky" href="https://medium.com/cleansoftware/quickly-implement-tableview-collectionview-programmatically-df12da694af9" rel="noopener">这篇</a>文章。这里我们将关注两个关键职责:为视图模型提供输入，以及将视图模型的输出连接到我们的UI。</p><p id="1549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建<code class="fe nr ns nt nu b">cachedImages</code>属性将加载的图像保存在一个字典中，这样我们以后就可以通过在单元格中使用缓存的图像来节省资源，而不是再次触发数据加载操作。</p><p id="2757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们将视图模型的<code class="fe nr ns nt nu b">unsplashPhotos</code>属性绑定到<code class="fe nr ns nt nu b">photosCollectionView</code>的方式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="43c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将该值发送到<code class="fe nr ns nt nu b">willDisplayCellAtIndex</code>以触发数据加载(如果在该索引处未找到缓存图像):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d826" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还对视图模型的<code class="fe nr ns nt nu b">imageRetrievedSuccess</code>和<code class="fe nr ns nt nu b">imageRetrievedError</code>事件做出反应:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4a7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个特定的单元格消失时，我们向视图模型的<code class="fe nr ns nt nu b">didEndDisplayingCellAtIndex</code>继电器发送一个值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="b445" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次使用RxSwift的<code class="fe nr ns nt nu b">willDisplayCell</code>包装器，我们确定是否到达了列表的末尾。</p><p id="0685" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果是，我们发送一个<code class="fe nr ns nt nu b">Void</code>值到<code class="fe nr ns nt nu b">didScrollToTheBottom</code>继电器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="933c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过改变<code class="fe nr ns nt nu b">navigationItem</code>上的标题并在每个<code class="fe nr ns nt nu b">PhotoCell</code>中显示/隐藏一个加载指示器来对视图模型的<code class="fe nr ns nt nu b">isLoadingFirstPage</code>和<code class="fe nr ns nt nu b">isLoadingAdditionalPhotos</code>做出反应:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0eef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，当我们点击一个特定的单元格时，我们抓取所选的<code class="fe nr ns nt nu b">UnsplashPhoto</code>的<code class="fe nr ns nt nu b">id</code>，并向<code class="fe nr ns nt nu b">didChoosePhotoWithId</code>继电器发送一个<code class="fe nr ns nt nu b">Int</code>值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="836c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！我们已经讲述了<code class="fe nr ns nt nu b">Photos</code>场景，现在让我们进入最后一个场景——<code class="fe nr ns nt nu b">PhotoDetail</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1597" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">“光细节”</h1><p id="712a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们从<code class="fe nr ns nt nu b">Photos</code>坐标到这个场景时，<code class="fe nr ns nt nu b">PhotoDetailCoordinator</code>是这样构造的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="335f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，我们拥有从前一个协调器获得的<code class="fe nr ns nt nu b">photoId</code>属性，并将其分配给<code class="fe nr ns nt nu b">PhotoDetailViewModel</code>的<code class="fe nr ns nt nu b">photoId</code>属性。</p><h2 id="f187" class="on md it bd me oo op dn mi oq or dp mm li os ot mo lm ou ov mq lq ow ox ms oy bi translated">'光电详细视图模型'</h2><p id="3b02" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">类似于我们在<code class="fe nr ns nt nu b">PhotosViewModel</code>中所做的，这里我们使用<code class="fe nr ns nt nu b">viewDidLoad</code>属性作为输入，使用<code class="fe nr ns nt nu b">isLoading</code>、<code class="fe nr ns nt nu b">imageRetrievedError</code>、<code class="fe nr ns nt nu b">imageRetrievedSuccess</code>和<code class="fe nr ns nt nu b">description</code>属性作为输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和以前一样，当我们在<code class="fe nr ns nt nu b">viewDidLoad</code>上接收到一个<code class="fe nr ns nt nu b">Void</code>值时，我们触发<code class="fe nr ns nt nu b">getPhoto()</code>方法，该方法将结果绑定到<code class="fe nr ns nt nu b">unsplashPhoto</code>属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="c47b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，它触发图像数据及其描述的加载:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="c305" class="on md it bd me oo op dn mi oq or dp mm li os ot mo lm ou ov mq lq ow ox ms oy bi translated">'光电详细视图控制器'</h2><p id="cc5b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这里，我们同样将事件发送到<code class="fe nr ns nt nu b">viewDidLoad</code>属性，并将<code class="fe nr ns nt nu b">imageRetrievedSuccess</code>、<code class="fe nr ns nt nu b">imageRetrievedError</code>、<code class="fe nr ns nt nu b">description</code>和<code class="fe nr ns nt nu b">isLoading</code>绑定到UI:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="fbfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们有了最后的工作流程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/f444baec1e2f8af9827b1c0f308a2ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/1*Eh1Sn4gGfe6U2BrtfxpKsw.gif"/></div></figure><p id="429e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经使用反应式MVVM架构实现了一个全功能的应用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c233" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><p id="f0cb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">该项目的源代码可以在GitHub上找到:</p><div class="mz na gp gr nb nc"><a href="https://github.com/zafarivaev/MVVM-RxSwift" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">扎法里瓦耶夫/MVVM-rx斯威夫特</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">反应MVVM演示应用程序从Unsplash获取照片，并显示在一个UICollectionView。展示了…的用法</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="pb l nn no np nl nq ks nc"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3a33" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">包扎</h1><p id="8801" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">想了解更多关于设计或架构模式的知识吗？请随意查看我的其他相关作品:</p><ul class=""><li id="e3d4" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated"><a class="ae ky" href="https://medium.com/better-programming/implement-the-facade-design-pattern-in-swift-dcc4325754ff" rel="noopener">“在Swift 5 </a>中实现Facade设计模式”</li><li id="f982" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><a class="ae ky" href="https://medium.com/better-programming/implement-the-builder-design-pattern-in-swift-5-ff5bc6f2fc3d" rel="noopener">“在Swift 5 </a>中实现生成器设计模式”</li><li id="7429" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><a class="ae ky" href="https://medium.com/better-programming/implement-the-strategy-design-pattern-in-swift-5d9c3f221277" rel="noopener">“在Swift 5 </a>中实现策略设计模式”</li><li id="ed12" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><a class="ae ky" href="https://medium.com/better-programming/how-to-implement-viper-architecture-in-your-ios-app-rest-api-and-kingfisher-f494a0891c43" rel="noopener">“在Swift 5中实现VIPER架构</a>”</li></ul><p id="544e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>