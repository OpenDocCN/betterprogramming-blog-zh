<html>
<head>
<title>Writing Unit Tests for Your Node.js API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Node.js API编写单元测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-unit-tests-for-your-nodejs-api-13257bd0e46b?source=collection_archive---------0-----------------------#2022-01-16">https://betterprogramming.pub/writing-unit-tests-for-your-nodejs-api-13257bd0e46b?source=collection_archive---------0-----------------------#2022-01-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dbeb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为在MongoDB上执行CRUD操作的真实Node.js API创建单元测试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3b22ef02b36052c10d4addb5b64852d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*02FmrfA5y4ahQgwd"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@battlecreekcoffeeroasters" rel="noopener ugc nofollow" target="_blank">battlecreekcoffeeroasters</a>拍摄的照片</p></figure><p id="7dba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单元测试是开发人员开发生命周期中不可或缺的一部分。尽管编写单元测试有时看起来像是一个多余的过程，但是这些测试的实际使用是在稍后对代码进行修改的时候出现的。</p><p id="1555" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一段代码有写得很好的单元测试，那么如果我们必须对它进行任何更改，我们可以不从头开始对整个特性进行完整的端到端测试。这样，单元测试有助于提高开发人员的生产力。</p><p id="d7a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是理解单元测试过程的问题是，大多数与之相关的内容不是太简单就是太复杂。要么人们试图解释如何为一个简单的加法函数编写单元测试，要么我们看到他们在非常复杂的项目中编写。</p><p id="c6a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在本文中，我将教您如何为一个实际但简单的Node.js API编写单元测试，在MongoDB上执行CRUD操作。</p><p id="d1df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用<code class="fe ls lt lu lv b">chai</code> <code class="fe ls lt lu lv b">mocha</code>和<code class="fe ls lt lu lv b">sinon</code>来编写我们的单元测试。整个项目的源代码可以在<a class="ae kv" href="https://github.com/AkshayCHD/sinon_tutorial" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><h1 id="c924" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">项目设置</h1><p id="b5ba" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们将从设置node js项目开始。所以第一步是创建一个空目录</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="7dc1" class="mx lx iq lv b gy my mz l na nb">mkdir node-api</span></pre><p id="f575" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后进入回购</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="745a" class="mx lx iq lv b gy my mz l na nb">cd node-api</span></pre><p id="c8e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并执行npm初始化</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="e9e1" class="mx lx iq lv b gy my mz l na nb">npm init --y</span></pre><p id="d2a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装以下依赖项</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="be56" class="mx lx iq lv b gy my mz l na nb">npm install chai cors express mocha mongoose sinon</span></pre><p id="3eae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们必须在我们的目录中复制下面的项目结构。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="b992" class="mx lx iq lv b gy my mz l na nb">|-index.js<br/>|-src<br/>  |-models<br/>    |-user.model.js<br/>  |-services<br/>    |-user.service.js<br/>|-test<br/>  index.test.js</span></pre><p id="0d4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在为了简单起见，我们将创建2个API，一个用于将用户添加到我们的MongoDB数据库，另一个用于通过唯一的<code class="fe ls lt lu lv b">profileId</code>获取用户。</p><p id="12e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以用户模型<code class="fe ls lt lu lv b">user.model.js</code>看起来会像这样</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6d8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们创建服务函数来添加用户，并从文件<code class="fe ls lt lu lv b">user.service.js</code>中的DB获取所有用户的列表</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1763" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们将要为之编写单元测试的一段代码。</p><p id="3b48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们在<code class="fe ls lt lu lv b">index.js</code>文件中创建快速路由，以允许通过HTTP请求执行我们的服务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="ad9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们必须编写逻辑来建立到MongoDB数据库的连接。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="85eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我假设您有一个本地MongoDB设置，如果没有，您也可以通过替换URI来使用MongoDB atlas实例。</p><h1 id="3e0d" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">编写单元测试</h1><p id="6b11" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">为了编写单元测试，我们将使用<code class="fe ls lt lu lv b"><a class="ae kv" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">mocha</a></code>和<code class="fe ls lt lu lv b"><a class="ae kv" href="https://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank">chai</a></code>。现在我们不会讨论这些包提供的每个特性，因为那超出了本文的范围。这里我们将只讨论编写一些基本单元测试所需的特性。</p><p id="c0bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们从<code class="fe ls lt lu lv b">saveUser</code>服务功能的测试开始。由于该函数的工作是向数据库添加一个用户，这样每个用户都有一个唯一的<code class="fe ls lt lu lv b">profileId</code>，因此它应该满足两个广泛的场景。</p><ul class=""><li id="3c5b" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">如果数据库中具有相同配置文件的用户数为零，则应成功添加用户。</li><li id="eaf6" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">如果拥有相同<code class="fe ls lt lu lv b">profileId</code>的用户数量不为零，应该抛出一个错误</li></ul><p id="2da6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我们首先使用描述函数为我们的测试用例编写一个框架结构，如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="90de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">describe</code>块为我们的测试提供了结构，而<code class="fe ls lt lu lv b">it</code>块封装了一个单元测试。</p><p id="1e70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要执行上面的空测试，将上面的逻辑添加到测试目录中的<code class="fe ls lt lu lv b">index.test.js</code>文件，并在package.json文件中添加下面的脚本。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="d4bf" class="mx lx iq lv b gy my mz l na nb">"scripts": {<br/>    "test": "mocha"<br/>}</span></pre><p id="f45f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当我们运行<code class="fe ls lt lu lv b">npm run test</code>时，上面的脚本被执行，它依次执行mocha，mocha默认查找所有扩展名为<code class="fe ls lt lu lv b">.test.js</code>的文件并执行它们。</p><p id="cb85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在运行<code class="fe ls lt lu lv b">npm run test</code>时，我们将看到下面的输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/6f08977d85536520bd67c082dbc7c56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPcpXRWEvEEhX4vBOgkB_w.png"/></div></div></figure><p id="cb5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于目前我们的测试中没有逻辑，因此两个测试用例都成功通过。</p><p id="e62e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在是时候在我们的测试用例中添加实际的测试逻辑了，所以对于第一个测试用例，让我们尝试导入我们的save user函数，并尝试使用它将用户保存到DB中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="d5a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">expect</code>关键字用于创建断言，这意味着布尔表达式必须为真，除非程序中有bug。</p><p id="de94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是当我们现在运行上面的测试时，我们会看到下面的错误</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/cd0d000d97da2090577d9ef0ee43fc3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ceOCdnY8m5pR2jWT-mDRzA.png"/></div></div></figure><p id="ca2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的问题是，当我们执行<code class="fe ls lt lu lv b">saveUser</code>服务函数时，我们实际上并没有与数据库建立任何连接。</p><p id="ebfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以像<code class="fe ls lt lu lv b">countDocuments</code>和<code class="fe ls lt lu lv b">save</code>这样的mongoose模式函数不会给我们任何结果，因为它们不能以任何方式与数据库连接。</p><p id="49cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我们尝试在我们的<code class="fe ls lt lu lv b">index.test.ts</code>文件中建立连接，如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="50ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里再次假设您已经启动并运行了一个本地MongoDB。</p><p id="f2d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们运行<code class="fe ls lt lu lv b">test</code>脚本，我们会看到下面的输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/7e3bd445adb88b0b5cf8b211d0011d4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uri43V9zSrRGC_YDekE64w.png"/></div></div></figure><p id="9e1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在一切看起来都很好，我们感觉我们已经成功地编写了测试，但是请等待，再次尝试运行相同的测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/03324835fefa9fb76ee427c9ed2469fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kzLhQkIwEnrZ7wb2DDePZA.png"/></div></div></figure><p id="519c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题之所以存在，是因为现在我们的数据库中已经有一个用户，它拥有我们提供的<code class="fe ls lt lu lv b">profileId</code>，并且由于我们有一个签入位置来验证所提供的<code class="fe ls lt lu lv b">profileId</code>的存在，该检查失败了，因此我们的整个测试失败了。</p><p id="471a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，当我们在实际的数据库上运行测试时，我们还会面临其他问题。</p><ul class=""><li id="c2fc" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">我们可能需要在两次连续测试之间清理数据库，因此，如果由于某些人为错误而错误地连接到生产数据库，我们的测试可能会删除生产数据。</li><li id="d1b3" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">由于依赖于数据库，我们的测试需要互联网连接才能工作，因此它们不能孤立运行。</li><li id="4b4d" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">与实际数据库的交互需要时间，这使得运行测试成为一项耗时的操作，这在理想情况下是不应该的。</li></ul><p id="7fa1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了克服上述问题，我们必须创建所谓的存根。</p><p id="7d4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据定义，软件开发中的存根是一段代码，用来代替一些其他的编程功能</p><p id="61d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，存根可以被视为对某个现有功能的方法的覆盖，这样我们就可以模拟对该功能的调用，这样它总是返回我们想要的输出。</p><p id="beb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以在上面的例子中，我们将使用存根来模拟对<code class="fe ls lt lu lv b">user.model</code>函数的函数调用，比如<code class="fe ls lt lu lv b">save</code>和<code class="fe ls lt lu lv b">countDocuments</code>，这样它们总是返回我们想要的输出，而不需要实际连接到数据库。</p><p id="1861" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了创建存根，我们将使用<code class="fe ls lt lu lv b"><a class="ae kv" href="https://sinonjs.org/" rel="noopener ugc nofollow" target="_blank">sinon.js</a></code>，它为我们创建存根、模拟等提供了一个框架。</p><p id="a3f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用<code class="fe ls lt lu lv b">sinon</code>库来模拟<code class="fe ls lt lu lv b">user.model</code>的响应，如下所示</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="8919" class="mx lx iq lv b gy my mz l na nb">sinon.stub(User, "countDocuments").returns(0);<br/>sinon.stub(User.prototype, "save").returns(<br/>    { name, dob, experience }<br/>);</span></pre><p id="f89f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在添加了<code class="fe ls lt lu lv b">sinon</code>存根并删除了DB连接的逻辑之后，完整的单元测试看起来会像这样</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6948" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，无论DB连接如何，我们多次运行上述测试，都会看到下面的响应。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/2cd0ec84d9eb8e5b2b48ff5e7a9e4c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q_3Bqx9FGjoZHVgzPZoCqg.png"/></div></div></figure><p id="1e05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在剩下的就是为<code class="fe ls lt lu lv b">saveUser</code>服务功能的剩余场景编写测试，以及为<code class="fe ls lt lu lv b">getUser</code>服务功能编写测试。</p><p id="510b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以测试DB中已经存在概要文件的场景，如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1ebe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，<code class="fe ls lt lu lv b">sinon.restore</code>命令在每次测试后运行，以清除测试期间创建的所有存根，并使它们相互独立。</p><p id="f54f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，最后我们为<code class="fe ls lt lu lv b">getUser</code>服务编写测试场景</p><ul class=""><li id="671f" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">应该在计算后返回用户的正确年龄和经验</li><li id="e703" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">如果没有找到提供的<code class="fe ls lt lu lv b">profileId</code>的用户，则应给出一个无效错误</li></ul><p id="31e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述场景可以使用存根以类似的方式实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4d36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以整个测试文件看起来会像这样</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="05d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们运行它时，我们会看到下面的输出</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/22931df6df6e50d10e3ef3fb5f209da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oPExYTWh63IKBFpCANujdw.png"/></div></div></figure><p id="6162" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们已经成功地为我们的两个服务功能编写了单元测试。</p><h1 id="73ac" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="77b3" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在本文中，我试图提供一个简单而实用的演示，展示我们如何为一个简单的Node.js API编写单元测试。但是我们仅仅触及了演示中使用的库所提供的功能的表面。</p><p id="6c14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我希望我已经在本文中帮助你开始了单元测试的概念，这样你会发现将来在这个领域的探索相对容易。</p></div></div>    
</body>
</html>