<html>
<head>
<title>4 Lesser-Known Swift Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">4个鲜为人知的Swift功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-lesser-known-swift-features-ddfbc9268aa9?source=collection_archive---------6-----------------------#2022-01-25">https://betterprogramming.pub/4-lesser-known-swift-features-ddfbc9268aa9?source=collection_archive---------6-----------------------#2022-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="845f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你知道如何解决字典冲突吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e71025f134071d23cbc83eb921743c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zk9Hx9X3WZ0uaLcs"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@lazycreekimages?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克尔·泽兹奇</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="576b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多开发人员使用标准技术，并且经常不知道友好的语言和库下隐藏的许多突出的特性。这些特性对一些读者来说可能已经很熟悉了，但是对我来说这是一个小发现。</p><h1 id="d5be" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">尾部递归优化</h1><p id="6a51" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">许多开发人员知道递归可能是一个不完美的工具，因为函数调用堆栈可能会不受控制地溢出，并由于分段错误而崩溃。一种类型的递归是尾递归，即函数在函数本身的末尾调用自己。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="201c" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">func</strong> tailRecursion(n: Int) {<br/>  <strong class="mq ir">guard</strong> n != 0 <strong class="mq ir">else</strong> { <strong class="mq ir">return </strong>}<br/>  print(n)<br/>  tailRecursion(n: n-1)<br/>}</span></pre><p id="af3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与通常的递归相比:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5ad7" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">func</strong> usualRecursion(n: Int) {<br/>  <strong class="mq ir">if</strong> n &gt; 0 {<br/>    usualRecursion(n: n-1)<br/>  }<br/>  print(n)<br/>}</span></pre><p id="922d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Swift使用尾部递归优化，不在内存中的调用栈中添加方法调用，而是跳转到函数的开头。它消耗的堆栈内存要少得多。</p><p id="eeb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前面的例子中，<code class="fe mz na nb mq b">usualRecursion(n: 300000)</code>因“分段故障”而崩溃，而<code class="fe mz na nb mq b">tailRecursion(n: 1000000)</code>正常运行。</p><p id="25bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实验是在我的电脑上进行的；这些参数的结果在其他计算机上可能会有所不同。<br/>你可以在生成的汇编代码中看到优化。</p><p id="dafe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb mq b">xcrun swiftc -O -S File.swift &gt; main.asm</code></p><p id="8ba5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使你不懂汇编语言，你也可以在main.asm文件中看到，其中一个' jamp '命令(以' j '开头的函数)是为尾部递归而执行的，而标准的callq函数call命令调用通常的递归。</p><p id="f0cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于这种优化，我们可以得出结论，如果有可能在函数本身的末尾递归，那么最好就这么做。</p><h1 id="a47c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">存储负数</h1><p id="ef47" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在许多编程语言中，有符号的数字存储为一组位，其中第一位是数字的符号(0是正数，1是负数)。</p><p id="a607" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">剩余的位代表该值。例如，在存储1个字节的类型中，00000001是数字1，10000001是数字-1。</p><p id="69ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但在Swift中，存储系统针对快速操作进行了优化，数字以一种称为二进制补码的方法存储。要在这个系统中描述一个负数，你需要把这个数写成一个比特表示，然后把比特反转，加1。例如，如果这个数字是-15:</p><ul class=""><li id="6b30" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">写出十进制15: 0001111的位数</li><li id="8b2e" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">反转位数:1110000</li><li id="7122" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">添加号码1: 1110001</li><li id="af19" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">如前所述，在演示开始时，您需要添加第1位</li></ul><p id="2af8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终结果将是11110001。</p><p id="7cb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想将11110001的位表示转换成十进制格式，那么我们需要</p><ul class=""><li id="d97a" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">反转位:0001110(我们应该省略第一位，因为它代表数字的符号)</li><li id="fcab" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">添加1: 0001111</li><li id="238c" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">转换为十进制格式:15</li><li id="7dce" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">并加一个标志:-15</li></ul><p id="7693" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种数字表示允许在低级别更快地执行算术运算。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8f63" class="mu lt iq mq b gy mv mw l mx my">// The way to get inner representation of a negative number:<br/>String(UInt8(bitPattern: Int8(-15)), radix: 2)</span></pre><h1 id="f27f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">一个功能可以以不同的速度工作</h1><p id="5647" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Swift提供各种收集协议，这些协议通常共享相同的功能。乍一看，它们的工作方式是一样的，但实际上，这些功能的操作会因协议的不同而有很大差异。</p><p id="d1e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，Sequence协议上的后缀函数以O(n)复杂度工作，而RandomAccessCollection协议上的相同函数(继承自Sequence；符合该协议的结构的一个例子是规则数组)已经以复杂度O(1)工作。在大量的数据中，这种差异会很明显。因此，请注意您想要使用的协议。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="45a9" class="mu lt iq mq b gy mv mw l mx my">// define an array<br/><strong class="mq ir">let</strong> array = 0...100_000</span><span id="f48d" class="mu lt iq mq b gy nq mw l mx my">print("start array suffix \(Date())")<br/>// suffix(5) works O(1)<br/>array.suffix(5)<br/>print("end array suffix \(Date())")</span><span id="a6c7" class="mu lt iq mq b gy nq mw l mx my">// define a sequence<br/><strong class="mq ir">let</strong> seq = sequence(first: 0, next: { $0 &lt; 100_000 ? $0 + 1 : <strong class="mq ir">nil</strong>})</span><span id="fac9" class="mu lt iq mq b gy nq mw l mx my">print("start sequence suffix \(Date())")<br/>// suffix(5) works O(n), iterates every element of the sequence<br/>seq.suffix(5)<br/>print("end sequence suffix \(Date())")</span></pre><h1 id="3e92" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">字典中的冲突解决</h1><p id="bae2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们知道，在字典中存储元素可能会发生冲突。不同元素的哈希值可以匹配，这是特别解决的典型情况(为此，key元素必须实现<code class="fe mz na nb mq b">==</code>操作)。</p><p id="718c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">冲突存储的一个典型的理论实现经常被听到，例如，在对候选人的面试中，当存储项目在一个链表中排列时，也称为分离链接。</p><p id="7ef4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你通过键搜索一个元素，但是字典已经有了其他元素通过hash的时候，我们会有下面的情况。一个典型的算法遍历链表并测试元素的相等性，直到它遇到一个等价的元素或检查所有具有相同散列的项目。这种方法很好，解释起来也相对简单，但是Swift在现实中有不同的实现。</p><p id="6ee1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单地说，所有记录都存储在一个数组中，通过一个键散列来访问。如果发生冲突，您应该将一个新元素写入到同一个数组中，但是要与发生冲突的项保持一定的距离。如果这个小区也忙，则检查相同距离内的下一个小区，依此类推。这些检查可以从数组的末尾绕到它的开头(一个逻辑环)。冲突解决方法的名称是采用线性探测的开放式寻址。在这个解决方案中，所有项目都存储在一个共享空间中，不需要额外的内存来保持LinkedList运行。</p><p id="d373" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里看到实现<a class="ae kv" href="https://github.com/apple/swift/blob/main/stdlib/public/core/Dictionary.swift" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="4a14" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Swift是开源的</h1><p id="e9ce" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您可能不知道，Swift是一个开源项目，您也可以参与其中。您可以参与标准库的实施，并提供您的想法，这些想法可能会在未来新版本的Swift中出现。在链接<a class="ae kv" href="https://github.com/apple/swift/tree/main/stdlib/public/core" rel="noopener ugc nofollow" target="_blank">https://github.com/apple/swift/tree/main/stdlib/public/core</a>中你可以很容易地找到Swift的常用类型的实现</p><p id="05ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，您可以与社区一起开发几个库，其中包括:swift-markdown、swift-algorithms、swift-numerics、swift-collections、swift-atomics。</p></div></div>    
</body>
</html>