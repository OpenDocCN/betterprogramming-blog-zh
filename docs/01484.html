<html>
<head>
<title>Rich iOS Notifications in Swift Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中丰富的iOS通知说明</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rich-notifications-on-ios-explained-in-swift-4ffe76ea32cf?source=collection_archive---------1-----------------------#2019-09-17">https://betterprogramming.pub/rich-notifications-on-ios-explained-in-swift-4ffe76ea32cf?source=collection_archive---------1-----------------------#2019-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0d06" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">减少无聊的通知</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fb81433f75c785b02ac9de897dc1b34b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KEuCutLay3pkXSRJoqENFw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马特·博茨福德在<a class="ae ky" href="https://unsplash.com/s/photos/radio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="400b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">iOS中丰富的通知允许我们通过添加图像、gif和按钮来使枯燥的默认通知变得更好。在iOS 10中引入，并在后来的操作系统更新中得到增强，当你在应用程序中支持通知时，这是一个不能错过的功能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ddf7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在iOS中测试推送通知</h1><p id="dc8e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们开始实施之前，我们需要一个良好的测试环境。这一切都始于手头有合适的工具。</p><p id="6531" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以从终端或Mac应用程序测试推送通知。推荐后者，因为它给你一个用户界面，使你更容易填写任何细节。</p><p id="f3ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经使用一款名为<a class="ae ky" href="https://github.com/noodlewerk/NWPusher" rel="noopener ugc nofollow" target="_blank"> NWPusher </a>的Mac应用多年了，它从未让我失望过。它易于使用，并带有以下界面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/0500cbda8b1e93b34aeb5ac724a2fe64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S_Pa2VIkR6bIdZvh.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一款测试iOS推送通知的Mac应用</p></figure><p id="b5b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以选择推送证书，然后连接到Apple的推送通知服务(APNS)。该应用程序将从日志中让您知道连接是否已经成功建立。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9dad" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">获取iOS推送通知令牌</h1><p id="d023" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要测试任何通知，您必须拥有推送通知令牌，您可以在Swift中轻松获取该令牌。在您的<code class="fe na nb nc nd b">AppDelegate</code>中，您添加了以下方法，它将把设备令牌打印到控制台:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="1029" class="ni md it nd b gy nj nk l nl nm">func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {<br/>    let deviceToken: String = deviceToken.map { String(format: "%02.2hhx", $0) }.joined()<br/>    print("Device token is: \(deviceToken)")<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a696" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">发送测试通知</h1><p id="1926" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">设置好NWPusher应用程序后，就该发送第一个测试通知了。请确保您已请求推送通知权限来接收大声通知，否则您可能只会看到徽章符号被更新。</p><p id="e3d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切顺利，您已经收到了第一个通知，那么您就可以实现丰富的通知支持了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a533" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在iOS模拟器上测试推送通知</h1><p id="3638" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">虽然有一个包含项目框架的<a class="ae ky" href="https://github.com/acoomans/SimulatorRemoteNotifications" rel="noopener ugc nofollow" target="_blank">解决方案，但是它已经过时了，不推荐使用。它试图复制苹果发送推送通知的方式，但据说并不完全相同。特别要避免，因为它不再被维护了！</a></p><p id="413c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">强烈建议在真实设备上测试推送通知，直到苹果公司可以在模拟器上测试丰富的通知。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1bd9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建带有图像的自定义推送通知</h1><p id="d592" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">创建带有图像作为媒体附件的自定义推送通知会使通知看起来更好。换句话说，它使通知更加丰富！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/0adb7637dd1a69cdca8df572da030f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/0*XidLFNy2mPq7xzqo.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示图像预览的丰富推送通知</p></figure><p id="1a33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要创建一个新的通知服务扩展，它将在远程通知发送给用户之前修改其内容。这可以是任何类型的通知，如更改标题，以及下载图像。</p><p id="b206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅当满足以下要求时，才会调用扩展:</p><ul class=""><li id="48a5" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">远程通知被配置为显示警报</li><li id="bca0" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">远程通知的有效载荷包括值被设置为1的<code class="fe na nb nc nd b">mutable-content</code>键</li></ul><p id="a5f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，您不能修改静默通知或那些只播放声音或标记应用程序图标的通知。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5228" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">添加通知服务扩展</h1><p id="311c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通过选择<code class="fe na nb nc nd b">File -&gt; New -&gt; Target</code>，可以在Xcode中添加通知服务扩展。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/2bb44e7838c0a3815f3aa97f4ed28102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tAYNHWPO62feHpV6.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建新的通知服务扩展</p></figure><p id="7c53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建一个新的Swift文件，包含一个从<code class="fe na nb nc nd b">UNNotificationServiceExtension</code>继承的类。这是我们捕捉远程通知并在显示给用户之前对其进行调整的入口点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="83ab" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将图像添加到推送通知</h1><p id="eb16" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要将图像作为媒体附件添加到推送通知中，我们需要调整我们的<code class="fe na nb nc nd b">UNNotificationServiceExtension</code>类的代码。我们执行以下步骤:</p><ul class=""><li id="4967" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">检查图像URL是否存在</li><li id="1101" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">下载图像并保存到磁盘</li><li id="30d1" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">将图像文件URL附加到通知中</li><li id="3373" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">发回修改后的通知</li></ul><p id="d141" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们创建两个新的扩展，从通知请求中获取图像URL，并将其保存到磁盘。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="cffa" class="ni md it nd b gy nj nk l nl nm">extension UNNotificationRequest {<br/>    var attachment: UNNotificationAttachment? {<br/>        guard let attachmentURL = content.userInfo["image_url"] as? String, let imageData = try? Data(contentsOf: URL(string: attachmentURL)!) else {<br/>            return nil<br/>        }<br/>        return try? UNNotificationAttachment(data: imageData, options: nil)<br/>    }<br/>}<br/><br/>extension UNNotificationAttachment {<br/><br/>    convenience init(data: Data, options: [NSObject: AnyObject]?) throws {<br/>        let fileManager = FileManager.default<br/>        let temporaryFolderName = ProcessInfo.processInfo.globallyUniqueString<br/>        let temporaryFolderURL = URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent(temporaryFolderName, isDirectory: true)<br/><br/>        try fileManager.createDirectory(at: temporaryFolderURL, withIntermediateDirectories: true, attributes: nil)<br/>        let imageFileIdentifier = UUID().uuidString + ".jpg"<br/>        let fileURL = temporaryFolderURL.appendingPathComponent(imageFileIdentifier)<br/>        try data.write(to: fileURL)<br/>        try self.init(identifier: imageFileIdentifier, url: fileURL, options: options)<br/>    }<br/>}</span></pre><p id="47d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它使用UUID后跟JPG文件扩展名来保存文件。如果您的服务返回不同的文件类型，您可以相应地调整代码。如果您想支持显示GIF，这里也是将JPG转换为GIF的地方。</p><p id="4c8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实际使用这段代码，我们必须调整默认实现的<code class="fe na nb nc nd b">didReceive</code>方法:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="b142" class="ni md it nd b gy nj nk l nl nm">final class NotificationService: UNNotificationServiceExtension {<br/><br/>    private var contentHandler: ((UNNotificationContent) -&gt; Void)?<br/>    private var bestAttemptContent: UNMutableNotificationContent?<br/><br/>    override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -&gt; Void) {<br/>        self.contentHandler = contentHandler<br/>        bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)<br/><br/>        defer {<br/>            contentHandler(bestAttemptContent ?? request.content)<br/>        }<br/><br/>        guard let attachment = request.attachment else { return }<br/><br/>        bestAttemptContent?.attachments = [attachment]<br/>    }<br/>    <br/>    override func serviceExtensionTimeWillExpire() {<br/>        // Called just before the extension will be terminated by the system.<br/>        // Use this as an opportunity to deliver your "best attempt" at modified content, otherwise the original push payload will be used.<br/>        if let contentHandler = contentHandler, let bestAttemptContent = bestAttemptContent {<br/>            contentHandler(bestAttemptContent)<br/>        }<br/>    }<br/>}</span></pre><p id="e12e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该代码使用默认通知内容作为最佳尝试后备，尝试获取附件，如果全部成功，则返回修改后的通知。</p><p id="dbb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe na nb nc nd b">didReceive</code>方法执行任务的时间有限。如果您的方法在超时前没有调用完成块，那么将使用此时可用的最佳尝试内容来调用<code class="fe na nb nc nd b">serviceExtensionTimeWillExpire()</code>方法。如果您还没有调整任何内容，它将回落到原始内容。</p><p id="0492" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们在通知中显示图像并生成第一个富通知所需的全部代码！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="40d8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">添加推送通知交互按钮</h1><p id="5a39" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下一步是将交互式动作按钮添加到富通知中。包含按钮的通知也称为可操作通知类型。</p><p id="e948" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要注册一个所谓的<em class="oc">通知类别</em>，我们可以在其中注册按钮。当详细显示时，该类别中的每个通知都将在内容下方显示已注册的按钮。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="251d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">声明您的自定义通知类别和操作</h1><p id="e077" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于可操作的通知类型，我们需要在主应用程序中注册包含启动时操作的通知类别。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="716a" class="ni md it nd b gy nj nk l nl nm">private func registerNotificationCategories() {<br/>    let openBoardAction = UNNotificationAction(identifier: UNNotificationDefaultActionIdentifier, title: "Open Board", options: UNNotificationActionOptions.foreground)<br/>    let contentAddedCategory = UNNotificationCategory(identifier: "content_added_notification", actions: [openBoardAction], intentIdentifiers: [], hiddenPreviewsBodyPlaceholder: "", options: .customDismissAction)<br/>    UNUserNotificationCenter.current().setNotificationCategories([contentAddedCategory])<br/>}</span></pre><p id="3d4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从您的<code class="fe na nb nc nd b">application(_:didFinishLaunchingWithOptions:)</code>方法中调用这个方法将为<code class="fe na nb nc nd b">content_added_notification</code>类别中的所有通知注册一个“Open Board”动作按钮。我们在WeTransfer 应用程序的<a class="ae ky" href="https://collect.wetransfer.com" rel="noopener ugc nofollow" target="_blank"> Collect中为新添加的内容触发的每个通知使用此类别。</a></p><p id="b9f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给你的动作一个唯一的标识符是很重要的，因为这是区分不同动作的唯一方法。这甚至包括属于不同类别的动作。在上面的例子中，我们使用了<code class="fe na nb nc nd b">UNNotificationDefaultActionIdentifier</code>,因为我们只添加了一个动作。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="553f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将类别添加到您的丰富通知中</h1><p id="c32e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下一步是将类别添加到推送通知中。这可以通过将类别键添加到JSON有效负载的“aps”字典中来实现:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="1f49" class="ni md it nd b gy nj nk l nl nm">{<br/>	"aps": {<br/>		"category": "content_added_notification",<br/>		"alert": {<br/>			"title": "Photos",<br/>			"body": "Antoine added something new - take a look"<br/>		},<br/>		"mutable-content": 1<br/>	},<br/>	"image_url": "https://www.example.com/image_url"<br/>}</span></pre><p id="dd56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方法是通过调整<code class="fe na nb nc nd b">didReceive</code>方法中的代码来简单地重用我们的通知服务扩展:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="c76f" class="ni md it nd b gy nj nk l nl nm">override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -&gt; Void) {<br/>    self.contentHandler = contentHandler<br/>    bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)<br/><br/>    defer {<br/>        contentHandler(bestAttemptContent ?? request.content)<br/>    }<br/><br/>    /// Add the category so the "Open Board" action button is added.<br/>    bestAttemptContent?.categoryIdentifier = "content_added_notification"<br/><br/>    guard let attachment = request.attachment else { return }<br/><br/>    bestAttemptContent?.attachments = [attachment]<br/>}</span></pre><p id="5fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这只适用于将<code class="fe na nb nc nd b">mutable-content</code>添加到JSON有效负载的通知。</p><p id="cc52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将足以显示带有“打开电路板”操作按钮的通知:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/5b56708100b457f9f865ec3705e79834.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/0*JIP_VUVryHcOhA7H.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有按钮的丰富的可操作通知</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7268" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">处理丰富通知按钮回调</h1><p id="c9f1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一旦用户选择通知操作，系统将在后台启动您的应用程序。它将通知代理应该在共享的<code class="fe na nb nc nd b">UNUserNotificationCenter</code>实例上设置什么。我们可以使用<code class="fe na nb nc nd b">userNotificationCenter(_:didReceive:withCompletionHandler:)</code>方法来识别选中的动作并执行相关的动作。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="ef1c" class="ni md it nd b gy nj nk l nl nm">func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {<br/>    defer {<br/>        completionHandler()<br/>    }<br/><br/>    /// Identify the action by matching its identifier.<br/>    guard response.actionIdentifier == UNNotificationDefaultActionIdentifier else { return }<br/><br/>    /// Perform the related action<br/>    print("Open board tapped from a notification!")<br/><br/>    /// .. deeplink into the board<br/>}</span></pre><p id="f790" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行完动作后，一定要调用<code class="fe na nb nc nd b">completionHandler</code>。我们可以通过使用defer语句很容易地做到这一点。</p><h1 id="228d" class="mc md it bd me mf od mh mi mj oe ml mm jz of ka mo kc og kd mq kf oh kg ms mt bi translated">结论</h1><p id="87fe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">就是这样，这是一个用丰富的通知来丰富您的应用程序的好方法。我们花了不到一个小时的时间在Collect应用程序中实现，因此没有理由退缩！</p><p id="0695" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于通知的信息，我推荐这个由<a class="ae ky" href="https://twitter.com/kthomas901" rel="noopener ugc nofollow" target="_blank"> Kaya Thomas </a>所做的精彩演讲，它更加详细:<a class="ae ky" href="https://www.youtube.com/watch?v=nKB_pqlfp-M" rel="noopener ugc nofollow" target="_blank">为iOS 12 </a>定制你的通知。</p><p id="213b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢！</p></div></div>    
</body>
</html>