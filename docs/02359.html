<html>
<head>
<title>Using JavaScript BigInt to Represent Large Numbers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript BigInt表示大数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-javascript-bigint-to-represent-large-numbers-d1ad9f6e0079?source=collection_archive---------15-----------------------#2019-11-25">https://betterprogramming.pub/using-javascript-bigint-to-represent-large-numbers-d1ad9f6e0079?source=collection_archive---------15-----------------------#2019-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a2f0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">添加一个新的原始数据类型来处理大整数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3387158354b6c5aabbb417d100ce93b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZL2NNCTlxBD4YZL5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@im_laleeth?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拉利斯T </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e739" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在JavaScript中表示大于2的53次方减1的整数，我们可以使用<code class="fe lv lw lx ly b">BigInt</code>对象来表示这些值。</p><p id="12f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以通过算术运算符之类的常规运算来操作，如加、减、乘、除、余数和取幂。</p><p id="62d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以由数字和十六进制或二进制字符串构成。此外，它还支持像AND、OR、NOT和XOR这样的位运算。唯一不起作用的位运算是零填充右移运算符(<code class="fe lv lw lx ly b">&gt;&gt;&gt;</code>)，因为<code class="fe lv lw lx ly b">BigInts</code>都是有符号的。</p><p id="82e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，不支持一元<code class="fe lv lw lx ly b">+</code>运算符不中断<a class="ae ky" href="http://asmjs.org/" rel="noopener ugc nofollow" target="_blank"> asm.js </a>。只有当所有操作数都是<code class="fe lv lw lx ly b">BigInts</code>时，这些操作才会完成。我们不能有的操作数是<code class="fe lv lw lx ly b">BigInts</code>有的是数字。</p><p id="b7d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中,<code class="fe lv lw lx ly b">BigInt</code>与普通数字不同。它与普通数字的区别在于数字末尾有一个<code class="fe lv lw lx ly b">n</code>。我们可以用<code class="fe lv lw lx ly b">BigInt</code>工厂函数定义一个<code class="fe lv lw lx ly b">BigInt</code>。</p><p id="55b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它接受一个参数，该参数可以是整数，也可以是表示十进制整数、十六进制字符串或二进制字符串的字符串。<code class="fe lv lw lx ly b">BigInt</code>不能与内置的<code class="fe lv lw lx ly b">Math</code>对象一起使用。</p><p id="24fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，当在数字和<code class="fe lv lw lx ly b">BigInt</code>之间进行转换时，我们必须小心，因为在将<code class="fe lv lw lx ly b">BigInt</code>转换为数字时，可能会丢失<code class="fe lv lw lx ly b">BigInt</code>的精度。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5b98" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用</h1><p id="54f2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了定义一个<code class="fe lv lw lx ly b">BigInt</code>，如果我们想传入一个整数，我们可以写如下:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="26ff" class="nh mh it ly b gy ni nj l nk nl">const bigInt = BigInt(1);<br/>console.log(bigInt);</span></pre><p id="d2a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行<code class="fe lv lw lx ly b">console.log</code>语句时，它会记录<code class="fe lv lw lx ly b">1n</code>。如果我们想将一个字符串传递给工厂函数，我们可以这样写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="381f" class="nh mh it ly b gy ni nj l nk nl">const bigInt = BigInt('2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222');<br/>console.log(bigInt);</span></pre><p id="bd88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以将一个十六进制数字字符串和一个以<code class="fe lv lw lx ly b">0x</code>开头的字符串传递给工厂函数:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7307" class="nh mh it ly b gy ni nj l nk nl">const bigHex = BigInt("0x1fffffffffffff111111111");<br/>console.log(bigHex);</span></pre><p id="54b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在<code class="fe lv lw lx ly b">bigHex</code>上运行<code class="fe lv lw lx ly b">console.log</code>时，上面的代码会记录<code class="fe lv lw lx ly b">618970019642690073311383825n</code>。</p><p id="fc1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们可以传入一个二进制字符串，其中一个字符串以<code class="fe lv lw lx ly b">0b</code>开头，另一个二进制字符串位于字符串的剩余部分，以获得一个<code class="fe lv lw lx ly b">BigInt</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7435" class="nh mh it ly b gy ni nj l nk nl">const bigBin = BigInt("0b111111111111111000000000011111111111111111111111");<br/>console.log(bigBin);</span></pre><p id="5b6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在上面运行<code class="fe lv lw lx ly b">console.log</code>时，上面的代码会让我们得到<code class="fe lv lw lx ly b">281466395164671n</code>。如果我们想要创建的<code class="fe lv lw lx ly b">BigInt</code>超出了number类型可以接受的范围，那么传入字符串会很方便。</p><p id="a3a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以用一个<code class="fe lv lw lx ly b">BigInt</code>字面值定义一个<code class="fe lv lw lx ly b">BigInt</code>，我们可以在整数上附加一个<code class="fe lv lw lx ly b">n</code>字符。例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b799" class="nh mh it ly b gy ni nj l nk nl">const bigInt = 22222222222222222222222222222222n;<br/>console.log(bigInt);</span></pre><p id="8be5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们记录值时，我们得到<code class="fe lv lw lx ly b">22222222222222222222222222222222n</code>作为<code class="fe lv lw lx ly b">bigInt</code>的值。</p><p id="328b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">BigInt</code>在JavaScript中有自己的数据类型。当您对<code class="fe lv lw lx ly b">BigInt</code>变量、常量或值运行<code class="fe lv lw lx ly b">typeof</code>操作符时，我们将得到<code class="fe lv lw lx ly b">bigint</code>。例如，当我们运行:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="dc70" class="nh mh it ly b gy ni nj l nk nl">typeof 2n === 'bigint';<br/>typeof BigInt(2) === 'bigint';</span></pre><p id="8af1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两行代码的计算结果都是<code class="fe lv lw lx ly b">true</code>。然而，如果我们用<code class="fe lv lw lx ly b">Object</code>工厂函数包装它，我们得到的类型是一个对象:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b3a8" class="nh mh it ly b gy ni nj l nk nl">typeof Object(2n) === 'object';</span></pre><p id="a6ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将评估为<code class="fe lv lw lx ly b">true</code>。</p><p id="3daf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将数字运算应用于<code class="fe lv lw lx ly b">BigInts</code>。</p><p id="e3a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这包括算术运算符——加、减、乘、除、余数和取幂。此外，它还支持像AND、OR、NOT和XOR这样的位运算。</p><p id="5e51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一不起作用的位运算是零填充右移运算符(<code class="fe lv lw lx ly b">&gt;&gt;&gt;</code>)，因为<code class="fe lv lw lx ly b">BigInts</code>都是有符号的。此外，不支持一元<code class="fe lv lw lx ly b">+</code>操作符，以免破坏asm.js。</p><p id="3cc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些操作只有在所有操作数都是<code class="fe lv lw lx ly b">BigInts</code>时才进行。我们不能有的操作数是<code class="fe lv lw lx ly b">BigInts</code>有的是数字。例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="5cc1" class="nh mh it ly b gy ni nj l nk nl">const bigInt = BigInt(Number.MAX_SAFE_INTEGER);<br/>console.log(bigInt);</span><span id="e032" class="nh mh it ly b gy nm nj l nk nl">const biggerInt = bigInt + BigInt(1);<br/>console.log(biggerInt);</span><span id="3f15" class="nh mh it ly b gy nm nj l nk nl">const evenBiggerInt = bigInt + BigInt(2);<br/>console.log(evenBiggerInt);</span><span id="2197" class="nh mh it ly b gy nm nj l nk nl">const multi = bigInt * BigInt(2);<br/>console.log(multi);</span><span id="085d" class="nh mh it ly b gy nm nj l nk nl">const subtr = bigInt - BigInt(10);<br/>console.log(subtr);</span><span id="a3dc" class="nh mh it ly b gy nm nj l nk nl">const remainder = bigInt % BigInt(1);<br/>console.log(remainder);</span><span id="e5f7" class="nh mh it ly b gy nm nj l nk nl">const bigN = bigInt ** BigInt(54);<br/>console.log(bigN);</span><span id="6432" class="nh mh it ly b gy nm nj l nk nl">const veryNegativeNum = bigN * -BigInt(1)<br/>console.log(veryNegativeNum);</span></pre><p id="2910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到<code class="fe lv lw lx ly b">bigInt</code>的9007199254740991n，<code class="fe lv lw lx ly b">biggerInt</code>的9007199254740992n，<code class="fe lv lw lx ly b">evenBiggerInt</code>的9007199254740993n，<code class="fe lv lw lx ly b">multi</code>的18014398509481982n，<code class="fe lv lw lx ly b">subtr</code>的9007199254740981n，<code class="fe lv lw lx ly b">remainder</code>的0n，353059244</p><p id="2825" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，当我们得到小数结果时，小数部分将被截断。<code class="fe lv lw lx ly b">BigInt</code>是一个大整数，不是用来存储小数的。例如，在下面的示例中:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="4e6d" class="nh mh it ly b gy ni nj l nk nl">const expected = 8n / 2n;<br/>console.log(expected)</span><span id="e5ab" class="nh mh it ly b gy nm nj l nk nl">const rounded = 9n / 2n;<br/>console.log(rounded)</span></pre><p id="c8c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe lv lw lx ly b">expected</code>和<code class="fe lv lw lx ly b">rounded</code>我们得到4n。这是因为小数部分已从<code class="fe lv lw lx ly b">BigInt</code>中删除。</p><p id="0851" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比较运算符可以应用于BigInts。操作数可以是<code class="fe lv lw lx ly b">BigInt</code>或数字。我们可以将大于、大于或等于、小于、小于或等于、两倍等于和三倍等于运算符与BigInts一起使用。</p><p id="d85a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以将1n比作1:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="df3f" class="nh mh it ly b gy ni nj l nk nl">1n === 1</span></pre><p id="8c4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将计算为<code class="fe lv lw lx ly b">false</code>，因为<code class="fe lv lw lx ly b">BigInt</code>和数字不是同一类型。但是当我们用两个相等替换三个相等时，如下面的代码所示:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="5f97" class="nh mh it ly b gy ni nj l nk nl">1n == 1</span></pre><p id="0cdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的语句评估为<code class="fe lv lw lx ly b">true</code>，因为只有值被比较。</p><p id="7019" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在这两个例子中，我们混合了<code class="fe lv lw lx ly b">BigInt</code>操作数和数字操作数。这对于比较运算符是允许的。</p><p id="eaa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">BigInts和numbers也可以与其他运算符一起比较，如下例所示:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9224" class="nh mh it ly b gy ni nj l nk nl">1n &lt; 9<br/>// true</span><span id="565f" class="nh mh it ly b gy nm nj l nk nl">9n &gt; 1<br/>// true</span><span id="f90a" class="nh mh it ly b gy nm nj l nk nl">9 &gt; 9n<br/>// false<br/><br/>9n &gt; 9<br/>// false<br/><br/>9n &gt;= 9<br/>// true</span></pre><p id="037a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它们可以在一个数组中混合在一起并一起排序。例如，如果我们有以下代码:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0c1c" class="nh mh it ly b gy ni nj l nk nl">const mixedNums = [5n, 6, -120n, 12, 24, 0, 0n];<br/>mixedNums.sort();<br/>console.log(mixedNums)</span></pre><p id="4b53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到<code class="fe lv lw lx ly b">[-120n, 0, 0n, 12, 24, 5n, 6]</code>。我们还使用以下代码对其进行降序排序:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="4080" class="nh mh it ly b gy ni nj l nk nl">const mixedNums = [5n, 6, -120n, 12, 24, 0, 0n];<br/>mixedNums.sort((a, b) =&gt; {<br/>  if (a &gt; b) {<br/>    return -1<br/>  } else if (a &lt; b) {<br/>    return 1<br/>  }<br/>  return 0<br/>});<br/>console.log(mixedNums)</span></pre><p id="14a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们使用了比较运算符来比较数字的值，如果第一个数字大于第二个数字，则返回-1，如果第一个数字小于第二个数字，则返回1，否则返回0。</p><p id="e239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们用<code class="fe lv lw lx ly b">Object</code>包装BigInts，那么它们就作为对象进行比较，所以只有引用了同一个实例，两个对象才被认为是相同的。例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8f50" class="nh mh it ly b gy ni nj l nk nl">0n === Object(0n);<br/>Object(0n) === Object(0n);<br/>const o = Object(0n);<br/>o === o;</span></pre><p id="09fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么上面代码中的前三行将计算为<code class="fe lv lw lx ly b">false</code>，而最后一行将计算为<code class="fe lv lw lx ly b">true</code>。</p><p id="d668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当BigInts被强制转换为布尔值时，它们的行为就像是数字一样。例如，<code class="fe lv lw lx ly b">Boolean(0n)</code>会返回<code class="fe lv lw lx ly b">false</code>，其他任何东西都会返回<code class="fe lv lw lx ly b">true</code>。</p><p id="3659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以将它们强制转换为布尔值，如下面的代码所示:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="2c71" class="nh mh it ly b gy ni nj l nk nl">0n || 11n<br/>// 11n<br/><br/>0n &amp;&amp; 11n<br/>// 0n<br/><br/>Boolean(0n)<br/>// false<br/><br/>Boolean(11n)<br/>// true<br/><br/>!11n<br/>// false<br/><br/>!0n<br/>// true</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0b52" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">BigInt方法</h1><p id="891b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">BigInt</code>对象有几个方法。有静态的<code class="fe lv lw lx ly b">asIntN()</code> <strong class="lb iu"> </strong>和<code class="fe lv lw lx ly b">asUintN()</code> <strong class="lb iu"> </strong>方法，以及<code class="fe lv lw lx ly b">toLocaleString()</code>、<code class="fe lv lw lx ly b">toString()</code>和<code class="fe lv lw lx ly b">valueOf() </code>实例方法。</p><p id="df43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">asIntN</code>方法在-2到宽度减1和2到宽度减1之间包装一个<code class="fe lv lw lx ly b">BigInt</code>值。例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7037" class="nh mh it ly b gy ni nj l nk nl">const bigNum = 2n ** (62n - 1n) - 1n;<br/>console.log(BigInt.asIntN(62, bigNum));</span></pre><p id="f10b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到返回的<code class="fe lv lw lx ly b">bigNum</code>模62的实际值的字面量，就是2305843009213693951n。然而，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b3fc" class="nh mh it ly b gy ni nj l nk nl">const bigNum = 2n ** (63n - 1n) - 1n;<br/>console.log(BigInt.asIntN(62, bigNum));</span></pre><p id="4dcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到-1n，因为<code class="fe lv lw lx ly b">2n ** (63n — 1n)</code>模<code class="fe lv lw lx ly b">2n ** 63n</code>被返回。</p><p id="ae9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">asUintN()</code>方法将0和2之间的<code class="fe lv lw lx ly b">BigInt</code>值包装为宽度减1。例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="67fc" class="nh mh it ly b gy ni nj l nk nl">const bigNum = 2n ** 11n - 1n;<br/>console.log(BigInt.asUintN(11, bigNum));</span></pre><p id="1c15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到返回的<code class="fe lv lw lx ly b">bigNum</code>实际值的字面量，是2305843009213693951n。然而，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="1a30" class="nh mh it ly b gy ni nj l nk nl">const bigNum = 2n ** 11n - 1n;<br/>console.log(BigInt.asUintN(11, bigNum));</span></pre><p id="ff81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到2047n，因为返回了<code class="fe lv lw lx ly b">2n ** 11n — 1n</code>模<code class="fe lv lw lx ly b">2n ** 11n</code>。</p><p id="a80f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">BigInt</code>有一个<code class="fe lv lw lx ly b">toLocaleString()</code>方法根据我们传入的地区返回<code class="fe lv lw lx ly b">BigInt</code>的字符串值。例如，如果我们想得到一个<code class="fe lv lw lx ly b">BigInt</code>的法语表示，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c0af" class="nh mh it ly b gy ni nj l nk nl">const bigNum = 2n ** 60n - 1n;<br/>console.log(bigNum.toLocaleString('fr'));</span></pre><p id="6b72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码会记录<code class="fe lv lw lx ly b">1 152 921 504 606 846 975</code>。</p><p id="d5f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方法将把一个<code class="fe lv lw lx ly b">BigInt</code>转换成一个字符串。例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6281" class="nh mh it ly b gy ni nj l nk nl">const bigNum = 2n ** 60n - 1n;<br/>console.log(bigNum.toString());</span></pre><p id="c90a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将记录<code class="fe lv lw lx ly b">1152921504606846975</code>。</p><p id="706e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">valueOf</code>方法将获得<code class="fe lv lw lx ly b">BigInt</code>对象的值。例如，如果我们运行:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b277" class="nh mh it ly b gy ni nj l nk nl">const bigNum = 2n ** 60n - 1n;<br/>console.log(bigNum.valueOf());</span></pre><p id="fe54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到<code class="fe lv lw lx ly b">1152921504606846975n</code>日志。</p><p id="de5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JSON不支持BigInts，所以如果我们试图用<code class="fe lv lw lx ly b">JSON.stringify()</code>将它转换成JSON，就会引发<code class="fe lv lw lx ly b">TypeError</code>。</p><p id="c92b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们可以把它转换成支持的东西，比如一个字符串，然后它可以存储为JSON。我们可以通过编写以下代码来覆盖<code class="fe lv lw lx ly b">BigInt</code>的<code class="fe lv lw lx ly b">toJSON</code>方法:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c6f2" class="nh mh it ly b gy ni nj l nk nl">BigInt.prototype.toJSON = function() {<br/>  return this.toString();<br/>}</span><span id="56b4" class="nh mh it ly b gy nm nj l nk nl">const bigIntString = JSON.stringify(88888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888n)<br/>console.log(bigIntString);</span></pre><p id="b414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们得到:<code class="fe lv lw lx ly b">“88888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888”</code>。</p><p id="574e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">BigInts用于表示大于2的53次方减1的整数。在JavaScript中，我们可以使用<code class="fe lv lw lx ly b">BigInt</code>对象来表示这些值。</p><p id="169a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以通过算术运算符之类的常规运算来操作，如加、减、乘、除、余数和取幂。</p><p id="14d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">BigInts支持大多数位运算，如AND、OR、NOT和XOR。</p><p id="bd22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们也可以从十六进制或二进制数字转换而来。</p><p id="c67e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有当所有操作数都是BigInts时，才会执行这些操作。我们不能有一些操作数是BigInts，一些是数字。</p><p id="73bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，一个<code class="fe lv lw lx ly b">BigInt</code>和一个普通的数字不一样。它与普通数字的区别在于数字末尾有一个<code class="fe lv lw lx ly b">n</code>。我们可以用<code class="fe lv lw lx ly b">BigInt</code>工厂函数定义一个<code class="fe lv lw lx ly b">BigInt</code>。</p><p id="4f53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它接受一个参数，该参数可以是整数，也可以是表示十进制整数、十六进制字符串或二进制字符串的字符串。<code class="fe lv lw lx ly b">BigInt</code>不能与内置的<code class="fe lv lw lx ly b">Math</code>对象一起使用。</p></div></div>    
</body>
</html>