<html>
<head>
<title>The Git Commands Every Software Engineer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个软件工程师都应该知道Git命令</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-git-commands-every-software-engineer-should-know-part-ii-875160a74e92?source=collection_archive---------5-----------------------#2020-02-02">https://betterprogramming.pub/the-git-commands-every-software-engineer-should-know-part-ii-875160a74e92?source=collection_archive---------5-----------------------#2020-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3b05" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">stash | Commit | Reflog | Merge vs . Rebase</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f7f96181d922d41e43326784309d67e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IaPhwvwogazpjAIT05qhAw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">格伦·卡斯滕斯-彼得斯在<a class="ae ky" href="https://unsplash.com/s/photos/type-on-macbook?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="627a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是每个软件工程师都应该知道的Git命令的延续。在这里阅读第1部分:</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/swlh/the-git-commands-every-software-engineer-should-know-part-1-f2b3ebf5c2cf" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">每个软件工程师都应该知道的Git命令(第一部分)</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">软件工程师最常用的Git命令。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="eb27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将讨论临时存储变更，将变更保存到项目的历史中，利用历史，以及合并和重定基础策略。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="4300" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">1.暂时存储更改</h1><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="5c2f" class="nr mv it nn b gy ns nt l nu nv">git stash</span></pre><p id="b19b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nw nx ny nn b">Git stash</code>将当前更改保存到一个临时位置，我们可以在以后应用或恢复。对我们来说，在不丢失我们一直在做的工作的情况下，重置头部的状态是很方便的。当我们的代码还没有准备好提交时，Stashing使我们能够快速切换上下文，并处理其他事情。</p><p id="bfdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在stash中应用最近的更改并保存这些更改，以便我们可以将其应用到不同的分支，我们使用了<code class="fe nw nx ny nn b">git stash <strong class="lb iu"><em class="nz">apply</em></strong></code> <em class="nz">。</em></p><p id="432b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要应用并从stash中完全删除最近的更改，我们可以使用<code class="fe nw nx ny nn b">git stash <strong class="lb iu"><em class="nz">pop</em></strong></code> <strong class="lb iu"> <em class="nz">。</em> </strong></p><p id="9801" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，<code class="fe nw nx ny nn b">git stash</code>不会在我们的本地存储库中存储尚未暂存的新文件，也不会忽略文件。为了隐藏未被跟踪或忽略的文件，我们需要添加适当的选项。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="768c" class="nr mv it nn b gy ns nt l nu nv">git stash <strong class="nn iu"><em class="nz">-u </em></strong># or <strong class="nn iu"><em class="nz">--include-untracked</em></strong> includes untracked files.<br/>git stash <strong class="nn iu"><em class="nz">-a</em></strong> # or <strong class="nn iu"><em class="nz">--all</em></strong> includes all files.</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/7e3202a0a052556b491d8686ba4ef3c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kY0cpaKGWUNLNBWRkV96Ng.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Git隐藏选项——图片来自<a class="ae ky" href="http://www.atlassian.com/" rel="noopener ugc nofollow" target="_blank">Atlassian.com</a></p></figure><p id="4ba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过多次运行<code class="fe nw nx ny nn b">git stash</code> <em class="nz"> </em>来创建多个仓库。要列出所有可用的仓库，我们可以使用<code class="fe nw nx ny nn b">git stash list</code>。</p><p id="406b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能会看到如下隐藏列表:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="bb1e" class="nr mv it nn b gy ns nt l nu nv">stash@{0}: WIP on develop: 3969d68 Refactor:- Localisations <br/>stash@{1}: WIP on develop: 3969d68 Refactor:- Localisations<br/>stash@{2}: WIP on develop: 3969d68 Refactor:- Localisations</span></pre><p id="93d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很难确定哪个是为了什么。因此，在隐藏时，最好使用以下方法提供更多的上下文:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="2ccb" class="nr mv it nn b gy ns nt l nu nv">git stash <strong class="nn iu"><em class="nz">save </em></strong><em class="nz">"we can provide more context here!"</em></span></pre><p id="9877" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于上下文，我们可以通过传递它的限定符来重新应用我们想要的存储。例如，如果我们有这样一个隐藏列表:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="d851" class="nr mv it nn b gy ns nt l nu nv">stash@{0}: on develop: Refactored Food Module<br/>stash@{1}: on develop: Refactored Express Module<br/>stash@{2}: on develop: Refactored Transport Module</span></pre><p id="a21c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们想要重新应用Express模块的重构，即<code class="fe nw nx ny nn b">stash@{1}</code> <em class="nz">，</em>我们可以使用<code class="fe nw nx ny nn b">pop</code>或<code class="fe nw nx ny nn b">apply</code>选项，就像这样:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="7f67" class="nr mv it nn b gy ns nt l nu nv">git stash pop stash@{1} # re-apply and remove stash@{1}, or<br/>git stash apply stash@{1} # re-apply but still keep stash@{1}</span></pre><p id="62a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自然，栈在git存储库中被编码为提交对象。因此，我们可以从一个单独的存储中创建一个新的分支，如下所示:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="5291" class="nr mv it nn b gy ns nt l nu nv">git stash <strong class="nn iu"><em class="nz">branch &lt;branch_name&gt; stash@{&lt;qualifier&gt;}</em></strong></span></pre><p id="b20b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个命令将基于我们用<code class="fe nw nx ny nn b">qualifier</code>创建的提交，检查一个新的分支为<code class="fe nw nx ny nn b">branch_name</code>。<strong class="lb iu"> <em class="nz"> </em> </strong>然后将隐藏的修改弹出到上面。</p><p id="099d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦不再需要存储，我们可以像这样清除整个存储列表:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="84bc" class="nr mv it nn b gy ns nt l nu nv">git stash <strong class="nn iu"><em class="nz">clear</em></strong></span></pre><p id="a9ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要删除一个隐藏，我们可以使用这个:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="4e05" class="nr mv it nn b gy ns nt l nu nv">git stash <strong class="nn iu"><em class="nz">drop stash@{&lt;qualifier&gt;}</em></strong></span></pre><p id="4631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当变更准备好提交时，我们可以进入下一步。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="1c4e" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">2.保存对项目历史记录的更改</h1><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="1a73" class="nr mv it nn b gy ns nt l nu nv">git commit</span></pre><p id="006d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保存更改的最简单的方法是提交被跟踪的文件，然后显示一条提交消息，如下所示</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="fab4" class="nr mv it nn b gy ns nt l nu nv">git commit <strong class="nn iu"><em class="nz">-am</em></strong> <em class="nz">"This is an inline commit message"</em></span></pre><p id="6e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们也可以单独使用这些选项。使用<code class="fe nw nx ny nn b">-m</code>选项可以让我们跳过文本编辑器，而是使用内嵌消息。使用<code class="fe nw nx ny nn b">-a</code>选项使我们能够提交所有被跟踪的文件。</p><p id="767c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要提交一个选择性文件列表，我们可以使用<code class="fe nw nx ny nn b">git add</code> <em class="nz"> </em>命令将文件选择到stage区域，以便下一次提交将包括这些文件。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="08f1" class="nr mv it nn b gy ns nt l nu nv">git add <em class="nz">&lt;file&gt;</em> # stages all changes in &lt;file&gt;<br/>git add <em class="nz">&lt;directory&gt;</em> # stage all changes in &lt;directory&gt;<br/>git add <strong class="nn iu"><em class="nz">-p</em></strong> # stages partial changes with manual selections</span></pre><p id="08a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要注意的是，在我们运行<code class="fe nw nx ny nn b">git commit</code> <em class="nz">之前，<code class="fe nw nx ny nn b">git add</code>不会保存代码更改。</em></p><p id="b7b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想修改历史记录中的提交，该怎么办？<code class="fe nw nx ny nn b">--amend</code>选项来拯救。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="ab31" class="nr mv it nn b gy ns nt l nu nv">git commit <strong class="nn iu"><em class="nz">--amend</em></strong></span></pre><p id="c2e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将打开预先填充了我们之前输入的提交消息的已配置文本编辑器，我们还可以使用<code class="fe nw nx ny nn b">-m</code>选项来处理内嵌消息。为了更新代码变更而不是提交消息，我们可以使用<code class="fe nw nx ny nn b">--no-edit</code>选项。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="4397" class="nr mv it nn b gy ns nt l nu nv">git commit <strong class="nn iu"><em class="nz">--amend --no-edit</em></strong></span></pre><p id="561b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论上，修改后的提交实际上是全新的提交，它替换了旧的提交。因此，可能会出现冲突的情况。</p><p id="474a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nw nx ny nn b">--amend</code>选项只允许我们修改最后一次提交。为了能够做得更多，让我们进入下一部分。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5b46" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">3.利用项目的历史</h1><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="ceb3" class="nr mv it nn b gy ns nt l nu nv">git reflog</span></pre><p id="f0d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，这将打印出HEAD ref的<code class="fe nw nx ny nn b"> reflog</code>，它是对当前活动分支的符号引用。不仅如此，我们还可以通过使用</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="6e29" class="nr mv it nn b gy ns nt l nu nv">git reflog <strong class="nn iu"><em class="nz">show --all</em></strong></span></pre><p id="4c90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，查看名为<code class="fe nw nx ny nn b">branch_name</code>的特定分支的<code class="fe nw nx ny nn b">reflog</code>:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="e680" class="nr mv it nn b gy ns nt l nu nv">git reflog <strong class="nn iu"><em class="nz">show &lt;branch_name&gt;</em></strong></span></pre><p id="7cac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行这些命令，我们可能会得到如下结果:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="ff51" class="nr mv it nn b gy ns nt l nu nv">9f8399b (HEAD -&gt; Refactor/Txn_Flow) HEAD@{0}: commit: Test commit<br/>6f04f27 (origin/Refactor/Txn_Flow) HEAD@{1}: reset: moving to HEAD<br/>1f04e29 (origin/Refactor/Txn_Flow_Test) HEAD@{2}: commit: Added correlationId</span></pre><p id="7f0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据结果，我们可以挑选任何需要的提交，或者将当前HEAD重置回任何时间点。这对我们从<code class="fe nw nx ny nn b">git rebase</code> <em class="nz"> </em>中检索或恢复任何丢失的提交或合并冲突非常有用。</p><p id="7bde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们需要使用hash <code class="fe nw nx ny nn b">1f04e29</code>来挑选提交<code class="fe nw nx ny nn b">Added correlationId</code> <em class="nz"> </em>:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="3adb" class="nr mv it nn b gy ns nt l nu nv">git cherry-pick <em class="nz">1f04e29</em></span></pre><p id="18c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，将当前的<code class="fe nw nx ny nn b">HEAD</code>重置回<code class="fe nw nx ny nn b">HEAD@{1}</code>:</p><p id="44ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个reflog条目都有一个时间戳。我们可以利用这个属性按时间过滤<code class="fe nw nx ny nn b">git reflog</code>。可以使用的一些时间限定符有:</p><ul class=""><li id="ef5a" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated"><code class="fe nw nx ny nn b">1.minute.ago</code></li><li id="bae5" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe nw nx ny nn b">1.hour.ago</code></li><li id="8db1" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe nw nx ny nn b">1.day.ago</code></li><li id="2ac2" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe nw nx ny nn b">1.week.ago</code></li><li id="c3bb" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe nw nx ny nn b">1.month.ago</code></li><li id="d9cf" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe nw nx ny nn b">1.year.ago</code></li><li id="e1d5" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe nw nx ny nn b">yesterday</code></li><li id="cc90" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe nw nx ny nn b">2020-01-30.09:00:00</code></li></ul><p id="cc00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些时间限定符可以组合成<code class="fe nw nx ny nn b">1.week.3.day.ago</code>并像本例一样使用，以查看当前<code class="fe nw nx ny nn b">develop</code>分支与<code class="fe nw nx ny nn b">develop.1.month.ago</code>分支之间的差异。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="253f" class="nr mv it nn b gy ns nt l nu nv">git diff develop@{0} develop@{1.month.ago}</span></pre><p id="c30c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它使我们能够了解在一段时间内发生的变化。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="3e12" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">4.决定合并或重组我们的代码</h1><p id="2384" class="pw-post-body-paragraph kz la it lb b lc op ju le lf oq jx lh li or lk ll lm os lo lp lq ot ls lt lu im bi translated"><code class="fe nw nx ny nn b">git merge</code>和<code class="fe nw nx ny nn b">git rebase</code>是两个Git实用程序，专门用于将变更从一个分支合并到另一个分支。虽然合并总是一个向前移动的变化，有一个全新的合并提交，但rebasing通过为每个提交创建全新的提交，然后在原始分支中替换它们，重写了项目的历史。</p><p id="c109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解这一点，我们举个例子。假设我们的团队正在开发一个<code class="fe nw nx ny nn b">develop</code>分支，我们正在开发一个<code class="fe nw nx ny nn b">feature</code>分支。我们已经提交了一些更改，并且在<code class="fe nw nx ny nn b">develop</code>中有一些提交是相关的，需要包括进来。因此，要合并来自<code class="fe nw nx ny nn b">develop</code> <em class="nz">，</em>的提交，我们必须在两个选项中选择一个:合并或重设基础。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/64197e049db62c000f4581ebd13993b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*gkgjmkFIuhu1LkzRpvZiJw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从develop派生出一个特性分支的例子</p></figure><h2 id="775f" class="nr mv it bd mw ov ow dn na ox oy dp ne li oz pa ng lm pb pc ni lq pd pe nk pf bi translated"><strong class="ak">备选方案1: git重定基数</strong></h2><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="24bc" class="nr mv it nn b gy ns nt l nu nv">git rebase feature develop</span><span id="daa6" class="nr mv it nn b gy pg nt l nu nv"># or</span><span id="dee2" class="nr mv it nn b gy pg nt l nu nv">git checkout feature # make sure that we are on feature branch<br/>git rebase develop # rebase feature branch onto develop</span></pre><p id="dd76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将通过创建新的提交来替换原来的提交，从而将整个<code class="fe nw nx ny nn b">feature</code>分支移动到<code class="fe nw nx ny nn b">develop</code>分支的顶部。因此，由于没有冗余的合并提交，我们获得了更清晰的历史记录。此外，它有助于提交历史是线性的，没有任何分叉，并让我们更容易地浏览我们的历史。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/189a6123368bd8ce536082c27cf5895d.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*HHCfXb8HZMPA7si40cJa3Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="pi">将功能分支重置为开发— *全新提交</em></p></figure><p id="d1a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，使用<code class="fe nw nx ny nn b">git rebase</code> <em class="nz">时还是有取舍的。</em></p><p id="a1f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一，当我们试图改写历史时，安全没有保证。某个时间点的一个错误会打乱后续的提交顺序。第二，可追溯性更难，因为我们没有包含分支的上下文。</p><p id="5c65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我使用<code class="fe nw nx ny nn b">git rebase</code>的经验，我们应该只在没有发布这个分支的提交历史时使用这种方法。在这一点上，我们可以随心所欲。否则，如果其他人在同一个基础上工作，他们稍后在合并他们的变更时会有冲突。因此，在使用<code class="fe nw nx ny nn b">git rebase</code> <em class="nz">，</em>之前，让我们确保没有其他人正在使用这个分支。</p><h2 id="8907" class="nr mv it bd mw ov ow dn na ox oy dp ne li oz pa ng lm pb pc ni lq pd pe nk pf bi translated"><strong class="ak">选项2: git合并</strong></h2><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="d8a6" class="nr mv it nn b gy ns nt l nu nv">git merge feature develop</span><span id="03e5" class="nr mv it nn b gy pg nt l nu nv"># or</span><span id="5fe6" class="nr mv it nn b gy pg nt l nu nv">git checkout feature # make sure that we are on feature branch<br/>git merge develop # merge develop branch into feature</span></pre><p id="9845" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在<code class="fe nw nx ny nn b">develop</code>分支中创建一个全新的合并提交时，这是一个更容易的选择。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/f7738c1bb4031dbca289ac7689634bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*KzWv-Sa390UJinj3SFB-KA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将开发合并到特性分支中— *是一个全新的合并提交</p></figure><p id="25c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现有分支不变。这有助于我们避免重定基础的潜在问题，并使我们更容易恢复合并。同样，合并也有其利弊。每当我们需要与其他分支合并时,<code class="fe nw nx ny nn b">feature</code>分支将会有额外的合并提交。那些提交可能会弄乱历史，让我们的队友很难理解。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="db04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是第二部分。我希望你今天能学到一些新东西。请继续关注第3部分<strong class="lb iu"> <em class="nz"> </em> </strong>，在那里我们将讨论撤销变更的提交和检查存储库。</p></div></div>    
</body>
</html>