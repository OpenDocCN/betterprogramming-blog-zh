<html>
<head>
<title>How to Test If Your Objects Are Created Correctly in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何测试您的对象是否在Swift中正确创建</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-test-if-your-objects-are-created-correctly-in-swift-f932d33aec5f?source=collection_archive---------8-----------------------#2021-11-02">https://betterprogramming.pub/how-to-test-if-your-objects-are-created-correctly-in-swift-f932d33aec5f?source=collection_archive---------8-----------------------#2021-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b9af" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">测试你作文的正确性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d740623906f78893d155f328a6a56407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-XByx_Hg3YQczHsh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@ryan_riggins?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瑞安·里金斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="239b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试是检验我们的代码是否如我们编写时所预期的那样运行的规程。我们通常用单元测试来测试几个不同层次的复杂性:</p><ol class=""><li id="9d7e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">简单的函数通过提供一些输入并检查它们的输出是否符合我们的期望来测试。</li><li id="5b00" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">更新部分应用程序的功能通过执行它们并验证状态是否如我们预期的那样改变来进行测试。</li><li id="176a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将部分工作委托给另一个组件的函数通过验证是否用正确的参数调用了另一个组件来进行测试。另一个组件有它自己的单元测试来确保它的行为，因此，只要我们检查它是用正确的参数调用的，测试就是好的。</li></ol><p id="389a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些测试都确保单个组件按照我们的要求完成工作。然而，即使有一个测试套件，其中所有的组件都被测试，所有的依赖关系都被外部化，我们仍然有一些代码部分没有被单元测试覆盖。</p><p id="e2fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个例子是预置一些工厂或属性的初始化器。这些是我们想要控制的依赖项，但是在不同的情况下，我们不想公开它们:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/94ea9aebdf1190bbd463195809edc468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zrw7zQYGSfB8z6t_q70HYA.png"/></div></div></figure><ol class=""><li id="9527" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在使用一些内部组件的库或模块中，我们希望将具体的组件作为实现细节。我们不想向调用者公开它，这样他们就可以修改它。</li><li id="fc63" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在我们的应用程序的复合根中，我们希望使用将要创建应用程序的具体类型。</li></ol><p id="3d27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两种情况下，我们都想测试这些函数，以确保它们创建了正确的类型和/或确保它们正确地初始化了对象。</p><p id="fc43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天的文章中，我想展示一个为使用一些内部组件的公共接口编写测试的逐步过程。在此过程中，我们将更新产品代码，以提高其可测试性。最后，我将向您展示如何使用Swift的<a class="ae ky" href="https://developer.apple.com/documentation/swift/mirror" rel="noopener ugc nofollow" target="_blank">镜像API </a>来实际检查我们的复合类型。</p><h1 id="6b72" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">(起始)代码</h1><p id="4b2f" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们在本文中使用的示例是一个模块，它定期将应用程序生成的一些文件上传到远程服务。</p><p id="4bf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整个模块包括一些支持类型:</p><ol class=""><li id="8cbf" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">一个<code class="fe nh ni nj nk b">APIManager</code>将文件上传到适当的服务。</li><li id="7a83" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">定义访问磁盘的接口的<code class="fe nh ni nj nk b">StorageManager</code>。</li><li id="97e1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">返回一个<code class="fe nh ni nj nk b">Date</code>值的<code class="fe nh ni nj nk b">DateProvider</code>。</li></ol><blockquote class="nl nm nn"><p id="1e72" class="kz la no lb b lc ld ju le lf lg jx lh np lj lk ll nq ln lo lp nr lr ls lt lu im bi translated">注意:这些组件的实际实现超出了本文的范围。因此，我们将只关注它们的定义。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="11a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些支持类型由一个<code class="fe nh ni nj nk b">SyncProcess</code>使用:执行工作的引擎。这个组件实现超出了本文的范围，我们感兴趣的是如何声明和初始化它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="fc92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">SyncProcess</code>可以通过传递上述三种支持类型的具体实现来创建。我们可以通过调用接受一个<code class="fe nh ni nj nk b">environment</code>参数的<code class="fe nh ni nj nk b">start</code>方法来启动它。<code class="fe nh ni nj nk b">Environemnt</code>是一个简单的<code class="fe nh ni nj nk b">enum</code>，只有两种情况(<code class="fe nh ni nj nk b">.production</code>和<code class="fe nh ni nj nk b">.sandbox</code>)，可用于配置同步过程。</p><p id="2b15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不想向最终用户公开这个对象。我们希望将它保留在模块内部，以便为将来的更改提供更大的灵活性。我们也不想将其他类型公开为公共接口，所以我们将模块隐藏在一个向外界公开的<a class="ae ky" href="https://en.wikipedia.org/wiki/Facade_pattern" rel="noopener ugc nofollow" target="_blank"> Facade </a>后面。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="79ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个片段中，我们有一个公共的<code class="fe nh ni nj nk b">protocol</code>，它定义了组件的行为，并允许我们的客户在他们的代码中创建测试替身。然后我们有了我们的<code class="fe nh ni nj nk b">FileSyncer</code> <code class="fe nh ni nj nk b">protocol</code>的实时实现:它在<code class="fe nh ni nj nk b">init</code>中创建了一个<code class="fe nh ni nj nk b">SyncProcess</code>，并在<code class="fe nh ni nj nk b">start</code>方法中启动它。</p><p id="2e60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文的目标是编写测试来覆盖<code class="fe nh ni nj nk b">LiveFileSyncer</code>组件。</p><h1 id="1dd3" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">写第一个测试…或者也许不是？</h1><p id="8b01" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们上面写的代码完全合法并且有效。但是，我们马上就被卡住了。</p><p id="b0a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可能开始考虑如何测试<code class="fe nh ni nj nk b">init</code>。在测试中，我们可以实例化一个<code class="fe nh ni nj nk b">LiveFileSyncer</code>，但是我们不能检查我们正在创建哪种<code class="fe nh ni nj nk b">SyncProcess</code>。</p><p id="cc6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想测试<code class="fe nh ni nj nk b">start</code>方法，我们没有办法创建一个<code class="fe nh ni nj nk b">SyncProcess</code>测试double来检查它的<code class="fe nh ni nj nk b">start</code>方法是否被正确的参数调用。</p><p id="7006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们编写的代码可以构建和运行，但是它是不可测试的:我们不能编写任何有意义的测试来断言它的行为是正确的。这是一个缺点:当添加更多的功能时，我们不能确定以前的行为是否被保留。而且我们不能安全地重构代码，因为我们没有在犯错时会失败的测试。</p><p id="432c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能想到的时间越早，这个代码就会变得越可怕:人们会对改变它的想法感到害怕，因为没有人想破坏正常工作的东西。</p><p id="e1be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何转换代码以允许可测试性。</p><h2 id="1ec7" class="nu ml it bd mm nv nw dn mq nx ny dp mu li nz oa mw lm ob oc my lq od oe na of bi translated">创建SyncProcess工厂</h2><p id="50bd" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们需要的第一个要素是在<code class="fe nh ni nj nk b">FileSyncer</code>中注入自定义的<code class="fe nh ni nj nk b">SyncProcess</code>实现。我们可以引入一个<code class="fe nh ni nj nk b">Factory</code>对象，我们可以在测试中覆盖它来实现这一点。</p><p id="ff5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个名为<code class="fe nh ni nj nk b">SyncProcessFactory</code>的协议。该协议定义了与<code class="fe nh ni nj nk b">SyncProcess</code>T5签名相同的功能。它也返回一个<code class="fe nh ni nj nk b">SyncProcess</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c1e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工厂的live实现返回<code class="fe nh ni nj nk b">LiveSyncProcess</code>。生产代码会用到这个<code class="fe nh ni nj nk b">LiveSyncProcessFactory</code>。测试代码将使用不同的、可定制的<code class="fe nh ni nj nk b">Factory</code>。</p><h2 id="22f9" class="nu ml it bd mm nv nw dn mq nx ny dp mu li nz oa mw lm ob oc my lq od oe na of bi translated">更新文件同步程序</h2><p id="f508" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">现在我们有了自己的工厂，我们需要使用它。记住，我们不想暴露任何内部/私有对象。所以我们需要一个公共的<code class="fe nh ni nj nk b">init</code>，不带参数。</p><p id="aae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个init可以使用另一个内部的<code class="fe nh ni nj nk b">init</code>，它实际上接受一个类型为<code class="fe nh ni nj nk b">SyncProcessFactory</code>的参数。我们将使用这个内部的<code class="fe nh ni nj nk b">init</code>在测试中通过一个自定义的<code class="fe nh ni nj nk b">Factory</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8c22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe nh ni nj nk b">FileSyncer</code>更新是我们测试的游戏规则改变者。我们现在可以创建带有自定义工厂的<code class="fe nh ni nj nk b">LiveFileSyncer</code>,该工厂可以返回我们可以模仿的<code class="fe nh ni nj nk b">SyncProcess</code>。</p><h1 id="c62f" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">测试启动方法</h1><p id="4209" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated"><code class="fe nh ni nj nk b">LiveFileSyncer</code>将启动操作委托给<code class="fe nh ni nj nk b">SyncProcess</code>。测试<code class="fe nh ni nj nk b">start</code>方法意味着测试<code class="fe nh ni nj nk b">SyncProcess</code>是用正确的参数创建的，并且它的<code class="fe nh ni nj nk b">start</code>方法被调用。</p><p id="5ea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行这个测试的第一步是创建我们需要的测试替身。</p><h2 id="9d8c" class="nu ml it bd mm nv nw dn mq nx ny dp mu li nz oa mw lm ob oc my lq od oe na of bi translated">MockSyncProcess</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="358c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">MockSyncProcess</code>是一个简单的对象，它计算start方法被调用的次数。我们可以定制它的行为来覆盖<code class="fe nh ni nj nk b">startClosure</code>。这个实现有趣的一点是，<code class="fe nh ni nj nk b">startClosure</code>是用一个闭包初始化的，这个闭包在方法被调用时会自动失败。如果在不应该的时候使用了<code class="fe nh ni nj nk b">start</code>方法，这个有用的技巧会使测试失败:这是一种保护，我们可以在对象中设置它来监视它的使用位置。</p><h2 id="e744" class="nu ml it bd mm nv nw dn mq nx ny dp mu li nz oa mw lm ob oc my lq od oe na of bi translated">MockSyncProcessFactory</h2><p id="1d3a" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们需要的第二个测试double是流程工厂的模拟。我们可以使用这个mock在我们的代码中注入一个定制的<code class="fe nh ni nj nk b">SyncProcess</code>,并检查<code class="fe nh ni nj nk b">SyncProcess</code>是用正确的参数创建的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="7bba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个模拟遵循与前一个相同的原则。它包含一个属性来计算<code class="fe nh ni nj nk b">makeSyncProcess</code>方法被调用的次数，还包含一个闭包来定制它的行为。如果工厂使用时没有定制封盖，测试将会失败。</p><h2 id="df59" class="nu ml it bd mm nv nw dn mq nx ny dp mu li nz oa mw lm ob oc my lq od oe na of bi translated">测试开始</h2><p id="4166" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">通过对<code class="fe nh ni nj nk b">FileSyncer</code>的修改和这些新的模拟，我们可以创建我们的第一个测试。</p><p id="7cc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试将遵循标准的AAA模式:<strong class="lb iu"> A </strong> rrange、<strong class="lb iu"> A </strong> ct、<strong class="lb iu"> A </strong> ssert。然而，我们在各种闭包中添加了一些断言，以检查传递的参数是否是正确的类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="e263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<strong class="lb iu">排列</strong>部分，我们创建了测试所需的所有模拟对象，并声明了它们的参数:</p><ol class=""><li id="74d2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们创建了<code class="fe nh ni nj nk b">mockSyncProcess</code>，并检查当<code class="fe nh ni nj nk b">start</code>被调用时，它是用正确的参数调用的。</li><li id="2b43" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们创建了<code class="fe nh ni nj nk b">mockSyncProcessFactory</code>，并检查传递的类型是否与我们想要在生产中使用的类型相匹配。在<code class="fe nh ni nj nk b">mockSyncProcess</code>闭包中，我们还返回在步骤1中创建的<code class="fe nh ni nj nk b">mockSyncProcess</code>。</li><li id="5648" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们通过传递<code class="fe nh ni nj nk b">mockSyncProcessFactory</code>来创建<code class="fe nh ni nj nk b">sut</code>。</li></ol><blockquote class="nl nm nn"><p id="d386" class="kz la no lb b lc ld ju le lf lg jx lh np lj lk ll nq ln lo lp nr lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:在第2步中，我们不能检查<code class="fe nh ni nj nk b">DateProvider</code>是否真的是<code class="fe nh ni nj nk b">Date</code> init。我们有两个选择:我们可以忍受这个限制，或者我们可以创建一个<code class="fe nh ni nj nk b">DateFactory</code>协议并用它替换<code class="fe nh ni nj nk b">DateProvider</code>。第二个解决方案在代码库中引入了更多的实体，但是它让我们更加严谨。</p></blockquote><p id="dbd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<strong class="lb iu">行为</strong>部分，我们调用start方法。如果我们忘记设置闭包，整个测试将会失败。这就是我们想要的:这个测试的行为是<code class="fe nh ni nj nk b">FileSyncer</code>创建一个<code class="fe nh ni nj nk b">SyncProcess</code>，然后它调用<code class="fe nh ni nj nk b">start</code>方法。</p><p id="a6fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<strong class="lb iu">断言</strong>部分，我们检查方法被调用的次数是否正确。</p><p id="83be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以在启用代码覆盖率的情况下运行测试，并检查start方法是否被完全测试。注意屏幕左边的小<code class="fe nh ni nj nk b">1</code>:这意味着start方法在测试代码中执行了一次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/c3c224a04be3d74d6ccc62a366921f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BFbYg0-yGglT-Stg1PJv_w.png"/></div></div></figure><h1 id="8bfe" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">测试初始化</h1><p id="b00d" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们可以滚动到<code class="fe nh ni nj nk b">LiveFileSyncer</code>文件的顶部，看看是否有一些行没有被覆盖。如果我们这样做，我们会看到public <code class="fe nh ni nj nk b">init</code>还没有被测试。那是因为在<code class="fe nh ni nj nk b">test_start</code>方法中，我们直接调用<code class="fe nh ni nj nk b">init(factory: )</code>方法来传递自定义的<code class="fe nh ni nj nk b">syncProcess</code>，绕过了<code class="fe nh ni nj nk b">init()</code>。</p><p id="464c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该测试一下<code class="fe nh ni nj nk b">init()</code>。它是公共接口的一部分，我们模块的客户端将使用它。但是我们如何测试它呢？这段代码创建了一个<code class="fe nh ni nj nk b">LiveSyncProcess</code>并设置了一个<code class="fe nh ni nj nk b">private</code> <strong class="lb iu"> </strong>变量。这种行为用标准方法是观察不到的，所以看起来我们不能真正测试它。</p><p id="975b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe nh ni nj nk b"><a class="ae ky" href="https://developer.apple.com/documentation/swift/mirror" rel="noopener ugc nofollow" target="_blank">Mirror</a></code> API在<code class="fe nh ni nj nk b">init</code>上编写一个测试。<code class="fe nh ni nj nk b">Mirror</code>API包括在Swift中编写反射代码的功能。我们可以在一种只读模式下使用这些API来检查类型的内容。</p><p id="3c2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些新知识，我们可以编写下面的测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="24ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个测试没有任何<strong class="lb iu">安排</strong>的部分，因为<code class="fe nh ni nj nk b">sut</code>的创作也是我们要测试的<strong class="lb iu">行为</strong>。<strong class="lb iu">断言</strong>部分是有趣的部分:我们创建了一个<code class="fe nh ni nj nk b">Mirror</code>来反映我们的<code class="fe nh ni nj nk b">sut</code>。<code class="fe nh ni nj nk b">Mirror</code>让我们探索我们对象的属性，即使它们是私有的。API给了我们这些属性的运行时值:我们可以检查它们是否是我们需要的具体类型。</p><p id="8b23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在检查代码覆盖率，我们有以下情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/8fa5c9aa08e6b70cfad522ac6dd8cd23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LXJetj6PaLbPjc0Y0Ju_PQ.png"/></div></div></figure><p id="fa37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">左边的小<code class="fe nh ni nj nk b">1</code>表示我们最终在测试我们的<code class="fe nh ni nj nk b">public init</code>。</p><h1 id="5247" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">这些测试是必需的吗？</h1><p id="bdb8" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">对这些测试的反对意见可能是，它们会降低代码库的灵活性。如果明天有人想将一种类型改为另一种类型，测试将会失败，从而减慢重构过程。</p><p id="4875" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是绝对正确的，但我认为这是一个很好的功能。这些测试是防御性测试。他们阻止我们合并，并发布一个用我们不想要的东西改变类型的PR。我们总是可以合并它，但是，至少，我们被警告了。</p><p id="1f55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们可以防止一些配置错误。例如，我们可以创建一个<code class="fe nh ni nj nk b">DevelopmentSyncProcess</code>和一个<code class="fe nh ni nj nk b">DevSyncProcessFactory</code>。这些在开发中可能是有用的实体，但是我们不想将它们投入生产。我们确实需要一些自动的方法来检查这一点，而单元测试在这方面做得很好:我们是人，当我们审查同事的拉请求时，我们有时会错过一些细节。</p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><h1 id="1717" class="mk ml it bd mm mn op mp mq mr oq mt mu jz or ka mw kc os kd my kf ot kg na nb bi translated">结论</h1><p id="af63" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在今天的文章中，我们讨论了如何编写测试来检查我们是否以正确的方式组成了我们的模块。</p><p id="3660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从一个不可测试的硬编码实现开始，并努力使其可测试:</p><ul class=""><li id="9a1e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ou mb mc md bi translated">我们使用工厂来分离对象的创建。</li><li id="271f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ou mb mc md bi translated">我们创建了测试doubles来编写灵活的测试，并检查代码是否传递了正确类型的参数。</li><li id="39a0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ou mb mc md bi translated">我们探索了镜像API来检查被测类的私有属性</li><li id="3839" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ou mb mc md bi translated">我们验证了<code class="fe nh ni nj nk b">public init</code>的行为是正确的。</li></ul><p id="3f26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们讨论了这些测试是否过于严格，以及在我们的代码库中是否值得拥有它们。</p><p id="9c09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我个人的观点是，是的，它们是一种强大的防御方法，可以保护我们在生产中不发送错误的类型。</p></div></div>    
</body>
</html>