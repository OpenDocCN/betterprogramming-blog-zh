<html>
<head>
<title>Functional Programming in JavaScript: Map, Filter, and Reduce</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的函数式编程:映射、过滤和归约</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-programming-in-javascript-map-filter-and-reduce-12d9b8bbc56?source=collection_archive---------17-----------------------#2021-03-09">https://betterprogramming.pub/functional-programming-in-javascript-map-filter-and-reduce-12d9b8bbc56?source=collection_archive---------17-----------------------#2021-03-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="117b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">检查map()、filter()和reduce()的不同实现</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7419a045a74a1476b9e23395f612f824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7zMFagIfHp8gN48P"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@mariashanina?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Maria Shanina </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="7ddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我被教导以命令的方式编写JavaScript。这可能是因为在我学习的时候，这是你能做的全部事情。但是随着时间的推移，这种语言已经进化到使各种范例成为可能。</p><p id="96ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我是函数式编程的超级粉丝。几乎在所有情况下我都更喜欢它。所以我喜欢JavaScript包含像<code class="fe lw lx ly lz b">map</code>、<code class="fe lw lx ly lz b">filter</code>和<code class="fe lw lx ly lz b">reduce</code>这样的酷操作——我一直在使用它们。</p><p id="045d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我确实经常想知道我自己将如何编写这些函数。我认为这是一个值得做的练习，因为解构这些抽象意味着我将能够更好地推理它们，并以不同的方式重建它们来解决其他问题。这只会让我成为一个更好的程序员。</p><p id="df08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以下面我就这么做了。我还为每一个包含了两个实现(一个是命令式的，一个是功能式的)，希望能引发一场关于哪种范式总体上更好的讨论。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="cdad" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">地图</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/725e588529ef5beb79264a7c096acb53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mbZ4d3IzTmi46SzfihlJqw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯·劳顿在<a class="ae ky" href="https://unsplash.com/s/photos/change?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="c338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">Map</code>通过应用一些函数来转换数组中的每个元素，然后返回转换后的值列表。</p><p id="5b37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于<code class="fe lw lx ly lz b">[1, 2, 3]</code>变成<code class="fe lw lx ly lz b">f(x) =&gt; x * 2</code>变成<code class="fe lw lx ly lz b">[2, 4, 6]</code>。</p><h2 id="702f" class="na mi it bd mj nb nc dn mn nd ne dp mr li nf ng mt lm nh ni mv lq nj nk mx nl bi translated">简单溶体</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="cd42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是可行的，也是可读的，但是由于一些原因，我不喜欢它。首先，我们使用了循环结构。循环结构不是功能性的，它们有笨拙的语法(打字错误集中)，并且它们内部的东西很难测试。这是一个简单的例子，但是想象一个必须做十件事情的循环。很快就失控了。</p><p id="e868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归可能是更好的方法。</p><h2 id="5e9e" class="na mi it bd mj nb nc dn mn nd ne dp mr li nf ng mt lm nh ni mv lq nj nk mx nl bi translated"><em class="no">递归求解</em></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a8a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，该函数使用spread运算符将数组中的第一个元素与其他元素分开。然后，如果它是未定义的，我们就结束了，我们只是返回。如果没有，我们对当前元素应用回调，然后对其余元素调用<code class="fe lw lx ly lz b">map</code>函数。这个函数将继续调用自己，直到它将回调应用到所有元素，然后它返回所有内容。第11行的spread操作符很重要，因为我们希望以后得到一个扁平的数组。如果没有它，我们会得到这样的结果:<code class="fe lw lx ly lz b">map [1, 2, 3]</code>会变成<code class="fe lw lx ly lz b">[2, [4, [6, []]]]</code>。</p><p id="c2b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，这样好多了。我能够确切地看到发生了什么，每一步都有明确的名称，我没有笨拙的语法，并且很容易测试(因为我不必进入我不能容易地检查其状态的循环范围)。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="5fad" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">过滤器</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/e5ba10de4e4b9ca9d194aef457774aae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_VWFDM8e9mCYOMHoJxFQcg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Simone Hutsch 在<a class="ae ky" href="https://unsplash.com/s/photos/filter?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="fe37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<code class="fe lw lx ly lz b">map</code>，<code class="fe lw lx ly lz b">filter</code>对数组的每个元素应用一个函数。然而，它并不转换这些值，而是通过评估一些布尔条件来确定是否将它们包含在返回的数组中。这被称为一个<em class="lv">谓词</em>函数。</p><p id="3a89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">于是，<code class="fe lw lx ly lz b">[‘Be’, ‘Bed', ‘Ga’]</code>变成<code class="fe lw lx ly lz b">f(x) =&gt; x INCLUDES ‘B’</code>变成了<code class="fe lw lx ly lz b">[‘Be’, ‘Bed’]</code>。</p><h2 id="2cf1" class="na mi it bd mj nb nc dn mn nd ne dp mr li nf ng mt lm nh ni mv lq nj nk mx nl bi translated"><em class="no">简单的解决方案</em></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<code class="fe lw lx ly lz b">map</code>一样，这个简单的解决方案使用了一个循环结构，所以它不是我最喜欢的。我们还有多层嵌套，这使得代码难以阅读。</p><h2 id="0f88" class="na mi it bd mj nb nc dn mn nd ne dp mr li nf ng mt lm nh ni mv lq nj nk mx nl bi translated"><em class="no">递归求解</em></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9a70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这和<code class="fe lw lx ly lz b">map</code>的大部分是一样的。在第一行，我们将当前元素从其他元素中分离出来。如果我们在列表的末尾，我们就提前返回。</p><p id="da06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们在其他项目上调用<code class="fe lw lx ly lz b">filter</code>。这将使用filter调用填充调用堆栈，每个调用操作数组中的下一个元素，直到我们到达最后一个元素(这时第5行开始)。</p><p id="5c7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们检查谓词是否为该元素返回了<code class="fe lw lx ly lz b">true</code>。如果是的话，我们把它包含在返回的数组中。如果没有，我们返回其他被过滤的元素。</p><p id="cc47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于与之前相同的原因，我们需要传播价值观。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="fe25" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">减少</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/79b8d94fca9fe7de826020236ab36dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*deuvGZG-jE39XtNKuNyKvw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Gabriella Clare Marino 在<a class="ae ky" href="https://unsplash.com/s/photos/small?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="002a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可能很难理解(也很难解释)，我认为看到组成它的实际代码会比我尝试的更多。但简而言之，它的目的是将数组从一个值“缩减”到另一个值。</p><p id="9827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">于是，<code class="fe lw lx ly lz b">[1, 2, 3]</code>变成了<code class="fe lw lx ly lz b">f(x, y) =&gt; x + y</code>变成了<code class="fe lw lx ly lz b">6</code>。<code class="fe lw lx ly lz b">x</code>是数组中的当前元素，<code class="fe lw lx ly lz b">y</code>是本次操作的当前缩减值。</p><h2 id="9136" class="na mi it bd mj nb nc dn mn nd ne dp mr li nf ng mt lm nh ni mv lq nj nk mx nl bi translated"><em class="no">简单的解决方案</em></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="936a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在简单的解决方案中使用了另一个循环。在该代码中，<code class="fe lw lx ly lz b">current</code>是指当前减少的值。所以，如果我们用下面的参数调用<code class="fe lw lx ly lz b">reduce</code>:</p><pre class="kj kk kl km gt nr lz ns nt aw nu bi"><span id="6330" class="na mi it lz b gy nv nw l nx ny">reduce ([1, 2], (element, currentTotal) =&gt; currentTotal + element, 0)</span></pre><p id="703e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们最开始的现值就是<code class="fe lw lx ly lz b">0</code>。然后，在循环的第一次迭代中，我们将第一个元素<code class="fe lw lx ly lz b">1</code>传递给回调函数。我们也传递当前值，我们刚才说是<code class="fe lw lx ly lz b">0</code>。所以第一次迭代，我们的回调函数返回<code class="fe lw lx ly lz b">0 + 1</code>，也就是<code class="fe lw lx ly lz b">1</code>。按照数组中下一个元素的相同顺序，回调函数接下来将返回<code class="fe lw lx ly lz b">1 + 2</code>，也就是<code class="fe lw lx ly lz b">3</code>，我们的<code class="fe lw lx ly lz b">reduce</code>函数将返回这个值。</p><p id="4d09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这是有意义的。同样，我更喜欢功能性更强的方法，所以我在下面列出了它。</p><h2 id="8518" class="na mi it bd mj nb nc dn mn nd ne dp mr li nf ng mt lm nh ni mv lq nj nk mx nl bi translated"><em class="no">递归求解</em></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="832e" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="3b0d" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">在这个练习之前，我不知道这些函数的结构是多么相似。它们的核心都是简单地遍历一个列表，并对每个元素应用一个函数。知道这一点非常有价值。这意味着，如果我决定需要为列表编写自己的声明性函数——可能还不存在——我可以相对肯定它们会遵循类似的过程。</p><p id="f5c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这种认识能凸显出做这种事情的价值。您可以一遍又一遍地使用这些抽象，但是如果您自己没有实际地重新构建它们，您将永远无法获得额外的上下文或参考框架。不仅如此，这个特定的练习还突出了函数式编程的魔力:也就是说，使用高阶函数和组合可以产生干净简单但仍能执行复杂操作的代码。</p><p id="7723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，你不仅学习了这门语言，还接触到了强大的范例。</p></div></div>    
</body>
</html>