<html>
<head>
<title>Writing Custom Structural Directives in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Angular编写自定义结构指令</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-custom-structural-directives-in-angular-f9bb5bb93f30?source=collection_archive---------14-----------------------#2022-01-19">https://betterprogramming.pub/writing-custom-structural-directives-in-angular-f9bb5bb93f30?source=collection_archive---------14-----------------------#2022-01-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9c81" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让DOM结构依赖于用户特权</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e1e4aff8ede550b4c67922ca72a524e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VT5JhSAVnygqFawV"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">亚历山大·席默克在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="040a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，您需要根据用户的权限来决定DOM的哪一部分是可见的。这听起来很容易。但是，我们如何为我们的应用程序创建一个松散耦合的声明式解决方案呢？我将向您展示一种方法，我们可以如何受益于有角度的定制结构指令来实现这些目标。</p><h1 id="de88" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">第一种解决方案</h1><p id="0e64" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您可能想到的第一个解决方案如下:</p><p id="903f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在你的组件中提供属性和函数，让<code class="fe mp mq mr ms b">*ngIf</code>决定你的模板的哪些部分被呈现到DOM中，哪些部分没有。代码可能看起来像这样:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="3bb8" class="mx lt iq ms b gy my mz l na nb">&lt;div <em class="nc">*ngIf</em>="user.hasOneOfPrivileges(['VIEW_OVERVIEW'])"&gt;<br/>  user can see the overview<br/>&lt;/div&gt;</span></pre><p id="52bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的组件中，您提供了用户对象:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="de57" class="mx lt iq ms b gy my mz l na nb">constructor(public user: User) {}</span></pre><p id="5c6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">起初看起来很容易，但正如我们所知，事情会变得复杂。</p><h2 id="de1f" class="mx lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">这个解决方案的问题是</h2><ul class=""><li id="d0a5" class="no np iq ky b kz mk lc ml lf nq lj nr ln ns lr nt nu nv nw bi translated">我们代码的可重用性——因为我们需要在任何需要的组件中实现这种行为。</li><li id="3ed9" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">每个组件取决于用户。如果我们的代码变得越来越复杂，构造函数中的参数长度就会越来越长。同样，如果我们的组件是一个基类，并且我们继承了它，子组件也必须在其构造函数中注入用户。</li><li id="b01b" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">如果条件变得复杂，我们可以在模板中使用函数。但是在组件中使用函数对我们应用的整体性能是不利的(因为Angular必须在每个变化检测周期评估一个函数，以决定是否有变化)。</li><li id="5950" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">测试我们代码的复杂性。我们需要一种简单的方法来改变用户的特权，以测试不同的情况。</li></ul><p id="bdb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想知道为什么我使用字符串作为值(例如<code class="fe mp mq mr ms b">VIEW_OVERVIEW</code>):这样，我可以在模板中直接使用字符串值。</p><p id="f144" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我已经创建了一个特殊的类型<code class="fe mp mq mr ms b">Privilege</code>，编译器和IDE可以检查这些值并支持我们完成代码。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="0533" class="mx lt iq ms b gy my mz l na nb">export type Privilege = 'VIEW_OVERVIEW' |'VIEW_DETAILS' | 'DO_COOL_STUFF';</span></pre><p id="1af8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，枚举也是可能的。但是在这种情况下，我们必须在组件类中提供枚举来访问模板中的枚举值。</p><h1 id="a2d1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结构指导方法</h1><p id="7d71" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们真正需要的是一个与我们的组件类完全解耦的解决方案，只有在模板中，我们才希望声明性地确定应该呈现DOM的哪一部分。</p><p id="b652" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Angular有内置的结构指令(<a class="ae kv" href="https://angular.io/guide/structural-directives" rel="noopener ugc nofollow" target="_blank">https://angular.io/guide/structural-directives</a>)来实现这一点。我们都知道他们。他们是<code class="fe mp mq mr ms b">*ngIf</code>、<code class="fe mp mq mr ms b">*ngSwitch</code>、<code class="fe mp mq mr ms b">*ngFor</code>等等。但是我们可以自己写。让我们先看看代码:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="12db" class="mx lt iq ms b gy my mz l na nb">@Directive({<br/>  selector: '[appHasPrivileges]',<br/>})<br/>export class HasPrivilegesDirective implements AfterViewChecked {<br/>  constructor(<br/>    private vcRef: ViewContainerRef,<br/>    private tmpRef: TemplateRef&lt;unknown&gt;,<br/>    private user: User<br/>  ) {<br/>  }<br/><br/>  @Input()<br/>  appHasPrivileges: Privilege[] | undefined = [];<br/>  <br/>  ngAfterViewChecked() {<br/>    this.vcRef.clear();<br/>    if (this.user.hasOneOfPrivileges(this.appHasPrivileges ?? [])) {<br/>      this.vcRef.createEmbeddedView(this.tmpRef);<br/>    }<br/>  }<br/>}</span></pre><p id="381d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在模板中，我们可以写:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="04a0" class="mx lt iq ms b gy my mz l na nb">&lt;div <em class="nc">*appHasPrivileges</em>="['VIEW_OVERVIEW']"&gt;user can see the overview&lt;/div&gt;</span></pre><p id="2e52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在构造函数中，我们需要提供<code class="fe mp mq mr ms b">ViewContainerRef</code> —例如，根据我们的条件，我们的div(<code class="fe mp mq mr ms b">TemplateRef</code>)将作为嵌入视图插入的DOM元素。<code class="fe mp mq mr ms b">TemplateRef</code>是一种通用类型。</p><p id="2de7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，我们不知道上下文有什么类型——因为我们没有。因此我们提供<code class="fe mp mq mr ms b">unknown</code>来清楚地表明我们不知道它。</p><p id="f6e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，你可能已经注意到我们使用了<code class="fe mp mq mr ms b">AfterViewChecked</code>生命周期钩子来决定是否将模板呈现到DOM中。</p><p id="d02d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们的<code class="fe mp mq mr ms b">user</code>对象可以在我们的应用程序的生命周期内改变它的状态，并且组件在这个改变期间被使用，那么这是必需的。如果<code class="fe mp mq mr ms b">user</code>永远不会改变，我们可以将代码放入<code class="fe mp mq mr ms b">OnInit</code>生命周期函数中。</p><h2 id="a9f4" class="mx lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">多参数</h2><p id="8aa4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在我们的指令只能处理用户的特权。但是如果我们有更多的相关条件来决定哪个部分应该被渲染或者不被渲染呢？</p><p id="2779" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在指令中添加更多的输入属性。假设我们想要一个超级功能(例如，用户是管理员，可以做任何事情)。我们可以将输入属性<code class="fe mp mq mr ms b">orIsAdmin</code>添加到我们的指令中，但是这会将模板中的两个信息分开。一种更优雅的方式是将我们的条件作为属性<code class="fe mp mq mr ms b">appHasPrivileges</code>的一部分。<code class="fe mp mq mr ms b">*ngFor</code>指令以类似的方式工作。</p><p id="bb0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们的新输入属性名称以结构化指令的名称开始，这是可能的。在我们的例子中，名称是:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="8e03" class="mx lt iq ms b gy my mz l na nb">@Input()<br/>appHasPrivilegesOrIsAdmin = false;</span></pre><p id="325a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以将我们的附加条件包含到属性值中:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="2c86" class="mx lt iq ms b gy my mz l na nb">&lt;div <em class="nc">*appHasPrivileges</em>="['VIEW_DETAILS']; <strong class="ms ir">orIsAdmin: true</strong>"&gt;<br/>  user can see the details or is admin<br/>&lt;/div&gt;</span></pre><p id="44ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，现在附加属性(<code class="fe mp mq mr ms b">orIsAdmin</code>)及其值被添加在属性值内的分号之后。这真是简洁易读。我们可以扩展我们的指令，而不需要改变代码中已经使用它的每个地方。</p><p id="d3f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便提一下:我们这里使用的语法是简写版本(带星号的那个),我们也可以使用带<code class="fe mp mq mr ms b">ng-template</code>元素的常规版本:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="4276" class="mx lt iq ms b gy my mz l na nb">&lt;ng-template<br/>  [appHasPrivileges]="['VIEW_DETAILS']"<br/>  [appHasPrivilegesOrIsAdmin]="true"<br/>&gt;<br/>  &lt;div&gt;user can see the details or is admin&lt;/div&gt;<br/>&lt;/ng-template&gt;</span></pre><p id="80ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两个版本是等效的。但是带星号的版本更短，在我看来可读性更强。</p><p id="8abd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想知道如何为我们的结构组件编写单元测试，看看GitHub项目:<a class="ae kv" href="https://github.com/mseemann/angular-rights-in-templates" rel="noopener ugc nofollow" target="_blank">https://github.com/mseemann/angular-rights-in-templates</a>。作为如何开始的提示:您需要一个使用结构化指令的测试组件。</p><h1 id="1598" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">改进的结构指导法</h1><p id="0112" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">到目前为止，我们的代码的缺点是，它在每次视图检查时执行——例如，每当我们的应用程序发生变化，angular运行一个变化检测周期，DOM就会重新呈现。让我们看看是否可以避免这些执行，并且只在<code class="fe mp mq mr ms b">user</code>改变时才重新呈现DOM。</p><p id="31ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现这个目标的一个解决方案是我们的<code class="fe mp mq mr ms b">user</code>对象的反应状态，订阅用户的更改，如果用户已经更改，重新呈现DOM。</p><p id="15ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个例子，我使用了【https://ngrx.io/】(<a class="ae kv" href="https://ngrx.io/" rel="noopener ugc nofollow" target="_blank"/>)但是当然你可以使用任何其他的反应状态库。您可能已经在应用程序中使用了这样的库。</p><p id="48ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用原理都是一样的。如果特权改变，我们需要确保<code class="fe mp mq mr ms b">user</code>对象也改变，并在我们的结构指令中订阅改变:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="7199" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的组件被销毁，不要忘记取消订阅，以避免任何内存泄漏。我使用了<code class="fe mp mq mr ms b">takeUntil</code>模式，但是您也可以存储订阅，并在<code class="fe mp mq mr ms b">onDestroy</code>生命周期挂钩中调用<code class="fe mp mq mr ms b">unsubscribe</code>。</p><h1 id="abbd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论和进一步改进</h1><p id="9900" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">就是这样。现在，我们的结构组件是松散耦合的，可以声明性地使用，是独立可测试的，并且可以根据每个新需求进行扩展。</p><p id="18a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，我们可以进一步改进它:</p><ul class=""><li id="e558" class="no np iq ky b kz la lc ld lf oe lj of ln og lr nt nu nv nw bi translated">我们可以将逻辑放在<code class="fe mp mq mr ms b">user</code>类中。这将使测试更加容易。</li><li id="17bf" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">如果您需要对输入变化做出反应，您可以使用setters，将值放入<code class="fe mp mq mr ms b">BehaviorSubject</code>并将<code class="fe mp mq mr ms b">rxjs</code>选择与<code class="fe mp mq mr ms b">combineLatest</code>组合。</li></ul><p id="6391" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对带有完整功能代码的完整示例感兴趣，请查看<a class="ae kv" href="https://github.com/mseemann/angular-rights-in-templates" rel="noopener ugc nofollow" target="_blank"> GitHub项目</a>。</p></div></div>    
</body>
</html>