<html>
<head>
<title>Structural Pattern Matching in Python 3.10</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.10中的结构模式匹配</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/structural-pattern-matching-in-python-3-10-247b2626c525?source=collection_archive---------8-----------------------#2021-10-06">https://betterprogramming.pub/structural-pattern-matching-in-python-3-10-247b2626c525?source=collection_archive---------8-----------------------#2021-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="922c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它不仅仅是一个开关盒</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/800aa4a97462af6c600f755d209163a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nJ9xxcjKzcgPkqq3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@mullyadii?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">穆利亚迪</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5f17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python是最具趋势的语言之一，由于其在数据科学和人工智能领域的流行，工作需求不断增长。</p><p id="4a3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了跟上其他新兴语言(如Go、Julia和Rust)的发展，Python软件基金会投入了大量资源来不断改进Python。</p><p id="a0a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，它发布了一个标志着Python 3.10的重大版本升级。不要以为这是Python 3的最后一个主要版本，因为3.11现在正在考虑中，正如Python的<a class="ae ky" href="https://docs.python.org/3.11/whatsnew/3.11.html" rel="noopener ugc nofollow" target="_blank">官方网站</a>所示。</p><p id="6310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，与3.9相比，Python 3.10提供了几个新特性，代表了一个重大的升级，比如显式类型别名、支持联合操作的更好的注释，当然还有结构化模式匹配——这也是本文的主题。</p><p id="d053" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包括<a class="ae ky" href="https://www.python.org/dev/peps/pep-0634/" rel="noopener ugc nofollow" target="_blank"> 634 </a>、<a class="ae ky" href="https://www.python.org/dev/peps/pep-0635/" rel="noopener ugc nofollow" target="_blank"> 635 </a>和<a class="ae ky" href="https://www.python.org/dev/peps/pep-0636/" rel="noopener ugc nofollow" target="_blank"> 636 </a>在内的许多pep都致力于这一新特性的讨论。所以感兴趣的读者可以从官方的角度全面了解这个功能的发展。在这里，我想简单地提供这种技术的概述，并强调一些最常见的用例。</p><p id="a402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了便于参考，我大胆地将结构化模式匹配称为SPM，这是这种技术的缩写。请注意，据我所知，我在官方文档中没有见过这样的名字。对我来说写作很简单。</p><p id="54c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注:Python 3.10已经正式发布，你可以在Python的官网上找到。这里有一个到下载页面的<a class="ae ky" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank">链接。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="da9e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">概述和基本语法</h1><p id="b4e4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们更进一步之前，让我们先通过一个假设的场景来理解什么是结构模式匹配。</p><p id="9107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们从一个API调用收到一个响应，它恢复一个tuple对象，第一项是状态代码，第二项是数据，这取决于请求是否成功。</p><p id="b8b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，当请求失败时，元组只包含一项。下面向您展示了一个可能的解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不使用SPM时的示例</p></figure><p id="9b19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，该解决方案符合我们的业务需求。然而，当我们的需求发展时，我们将不得不使用多层嵌套的<code class="fe nb nc nd ne b">if…elif…else…</code>语句创建额外的分支。当这种情况发生时，我们代码库的可读性和可维护性会显著下降。</p><p id="ff0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是SPM发挥作用的时候了，它旨在优雅地处理这项业务。这个添加到3.10中的新特性涉及到两个新关键字的使用:<code class="fe nb nc nd ne b">match</code>和<code class="fe nb nc nd ne b">case</code>(严格来说，它们被称为软关键字，参见<a class="ae ky" href="https://docs.python.org/pl/3.10/reference/lexical_analysis.html#soft-keywords" rel="noopener ugc nofollow" target="_blank">这里的</a>进行讨论)。</p><p id="c4e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何使用SPM来实现这一需求。一个可能的解决方案如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SPM示例</p></figure><p id="10bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，基于SPM的实现的整体可读性得到了很大的提高。它可能会让许多人想起许多编程语言中都有的经典switch-case特性。但是，SPM不一样——它更好，接下来我们来探讨一下。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="94b9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">匹配多个值</h1><p id="4962" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在前面的代码片段中，您已经看到我们使用了许多<code class="fe nb nc nd ne b">case</code>子句来创建多个模式，可以对照这些模式来检查<code class="fe nb nc nd ne b">resp</code>。</p><p id="6ca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，SPM是灵活的，因为每个模式可以包含多个值，而不是只有一个值。下面的代码片段向您展示了一个可能的用例。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="6d32" class="nj md it ne b gy nk nl l nm nn">match resp:<br/>    case (200, data) | (100, data):<br/>        ...<br/>    case ((404 | 401), data):<br/>        ...<br/>    case ((404 | 401) as status_code, data):<br/>        ...</span></pre><ul class=""><li id="0c25" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">您可以将不同的模式聚合到一个单独的<code class="fe nb nc nd ne b">case</code>子句中。使用它，您只需测试多个值。这些可选模式或值由并集运算符(竖线)分隔。</li><li id="b7d1" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">或者，在每个模式中，您可以使用union操作指定可能的值。</li><li id="db54" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">为了增加额外的灵活性，我们可以将可能的值转换为变量:<code class="fe nb nc nd ne b">(404 | 401) as status_code</code>，这样我们就可以在后面的步骤中使用<code class="fe nb nc nd ne b">status_code</code>。</li></ul><p id="1a4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更一般地说，模式中显示的变量可以称为捕获。本质上，匹配模式的值被分配给模式中相应的变量，这样这些捕获的值可以用于进一步的处理。</p><h1 id="2ec7" class="mc md it bd me mf oc mh mi mj od ml mm jz oe ka mo kc of kd mq kf og kg ms mt bi translated">应用条件</h1><p id="213f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">除了匹配多个模式和值，您还可以对<code class="fe nb nc nd ne b">case</code>子句应用附加条件。这样，您可以在不改变模式的情况下即时检查模式。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="fa6d" class="nj md it ne b gy nk nl l nm nn">special_codes = [300, 301, 302]<br/>match resp:<br/>    case (code, data) if code in special_codes:<br/>        ...</span></pre><p id="4c45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要应用条件，只需在模式后面添加一个<code class="fe nb nc nd ne b">if</code>语句。请注意，模式中使用的变量在<code class="fe nb nc nd ne b">if</code>语句中立即可用。</p><h1 id="0109" class="mc md it bd me mf oc mh mi mj od ml mm jz oe ka mo kc of kd mq kf og kg ms mt bi translated">带星号的表达式和通配符</h1><p id="5c94" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止，我们处理的元组中的条目不超过两个。然而，在元组或其他类型的数据容器中，您可能会得到数量可变的条目。</p><p id="c25c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些情况下，您可以考虑使用一个带星号的表达式，它将多个条目捕获到一个列表中，以供以后处理，如下所示。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="0a93" class="nj md it ne b gy nk nl l nm nn">&gt;&gt;&gt; def spm_starred(resp):<br/>...     match resp:<br/>...         case (code, *items):<br/>...             print("items:", items)<br/>... <br/>...             <br/>&gt;&gt;&gt; <br/>&gt;&gt;&gt; spm_starred((200, "item1", "item2", "item3"))<br/>items: ['item1', 'item2', 'item3']</span></pre><p id="2127" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个我们没有提到的有用特性是通配符模式。具体来说，我们使用下划线来表示任何与之前的模式不匹配的内容。这有点像其他语言中switch-case语句中的<code class="fe nb nc nd ne b">default</code>子句。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="32f2" class="nj md it ne b gy nk nl l nm nn">match something<br/>    case pattern0:<br/>        ...<br/>    case pattern1:<br/>        ...<br/>    case pattern2:<br/>        ...<br/>    case _:<br/>        # this is the wildcard pattern</span></pre><h1 id="13bc" class="mc md it bd me mf oc mh mi mj od ml mm jz oe ka mo kc of kd mq kf og kg ms mt bi translated">匹配复杂的对象</h1><p id="6aa9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们使用的模式非常简单:字符串、整数和元组。SPM的强大之处在于它可以匹配复杂的模式，包括看似复杂的对象，比如字典和定制实例。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="aba3" class="nj md it ne b gy nk nl l nm nn">match resp_dict:<br/>    case {"code": status_code, "data": data}:<br/>        print("Status Code:", status_code)<br/>        print("Data:", data)</span></pre><p id="e70a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，我们可以创建一个模式，它是一个<code class="fe nb nc nd ne b">dict</code>对象，其值需要与字典中使用的键相匹配。</p><p id="75c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在更高级的场景中，我们甚至可以根据自定义的基于实例的模式来检查值，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SPM匹配类实例</p></figure><p id="1d60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，我们对照一些涉及定制类的模式来检查<code class="fe nb nc nd ne b">person</code>。重要的一点是，您必须使用关键字参数来指定模式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c32f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="c8ff" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们回顾了Python 3.10中最有用的新特性——结构化模式匹配。如您所见，这是一个强大的特性，超越了其他编程语言中的经典switch-case用法，后者通常需要精确匹配。Python更进了一步，支持定义一个通用模式，显著提高了这项技术的灵活性。</p><p id="c898" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当您需要处理多种可能的场景时，这可能是考虑使用结构化模式匹配的最佳时机，它比多个<code class="fe nb nc nd ne b">if…elif…else</code>语句具有更好的可读性。</p></div></div>    
</body>
</html>