<html>
<head>
<title>Combine Pipeline vs Callback Pattern in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS中结合管道和回调模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/combine-pipeline-vs-callback-pattern-an-example-bf2ba1f8bf37?source=collection_archive---------5-----------------------#2022-06-05">https://betterprogramming.pub/combine-pipeline-vs-callback-pattern-an-example-bf2ba1f8bf37?source=collection_archive---------5-----------------------#2022-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f94b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">举例说明</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3febb223dd38161323c9ee51e0100e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CJBGKRw40FxtO7IEp2r7zA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">管道</p></figure><p id="9af0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们将尝试理解合并管道是什么样子，以及它与传统回调方法有何不同。</p><p id="0156" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">自从几年前苹果从iOS 13开始引入Combine框架以来，许多开发人员已经采用了它，他们的应用程序被其以所谓的管道形式简化复杂处理步骤的能力所吸引。</p><p id="c759" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将学习一组非常简单的例子(你甚至可以在Xcode操场上运行它们！)中，我们尝试使用回调和合并方法来完成相同的任务。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="46f6" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">问题是</h1><p id="77e3" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">我们将尝试实现一组处理步骤，在这些步骤中，我们将获取一些员工数据，根据员工所在的部门为他们申请加薪&amp;最后生成一个邮件程序，打印处理的最终结果。</p><p id="fdf5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将使用回调模式和Combine方法来实现这一点，以可视化这种差异。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="e977" class="nb ma iq mx b gy nc nd l ne nf">Fetch Employees -&gt; Apply salary raise -&gt; Generate Mailer -&gt; Print result</span></pre><h1 id="eeb3" class="lz ma iq bd mb mc ng me mf mg nh mi mj jw ni jx ml jz nj ka mn kc nk kd mp mq bi translated">数据结构</h1><p id="53d9" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">我们将使用下面的数据结构，这些数据结构将代表我们试图使用和努力的各种数据模型。</p><p id="ec4f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们有<code class="fe nl nm nn mx b">Employee</code>、<code class="fe nl nm nn mx b">Department</code>、<code class="fe nl nm nn mx b">EmployeeAddress</code>、&amp;、<code class="fe nl nm nn mx b">Mailer</code>数据结构</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="41bd" class="lz ma iq bd mb mc ng me mf mg nh mi mj jw ni jx ml jz nj ka mn kc nk kd mp mq bi translated">抽样资料</h1><p id="6bb5" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">为了保持简单，我们将在代码中创建一组数据，这将有助于我们保持实现的简单性，并更加关注概念(实际上，数据可能来自远程ReST API等)。</p><p id="ad74" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一个<code class="fe nl nm nn mx b">Employee</code> &amp; <code class="fe nl nm nn mx b">EmployeeAddress</code>的数据结构。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="4ddd" class="nb ma iq bd mb nq nr dn mf ns nt dp mj le nu nv ml li nw nx mn lm ny nz mp oa bi translated">获取员工</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="30a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的例子中，我们将<code class="fe nl nm nn mx b">fetchEmployees</code>实现为一个“<em class="lr">回调</em>”&amp;<strong class="kx ir">组合</strong>函数。</p><p id="4239" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第一种方法中，被调用的函数接收一个回调函数作为参数，该参数将由一组雇员调用。第二个函数使用一个内置的便利发布器<code class="fe nl nm nn mx b">Just</code>来帮助包装任何数据并返回一个发布器。</p><p id="f47e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nl nm nn mx b">eraseToAnyPublisher</code>函数有助于删除发布者的输出，以便于客户端处理输出，并允许我们更改发布者输出的底层实现。</p><p id="123f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个发布者从不返回错误，所以将<code class="fe nl nm nn mx b">&lt;[Employee], Never&gt;</code>作为返回类型。</p><h2 id="53b3" class="nb ma iq bd mb nq nr dn mf ns nt dp mj le nu nv ml li nw nx mn lm ny nz mp oa bi translated">申请加薪</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="656e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的函数中，我们循环遍历<code class="fe nl nm nn mx b">Employee</code>数组并申请加薪。我们像以前一样调用<code class="fe nl nm nn mx b">callback</code>或返回类型<code class="fe nl nm nn mx b">AnyPublisher&lt;[Employee], Never&gt;</code>的发布者。</p><h2 id="d6db" class="nb ma iq bd mb nq nr dn mf ns nt dp mj le nu nv ml li nw nx mn lm ny nz mp oa bi translated">生成邮件程序</h2><p id="dcf9" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">作为我们处理的最后一步，我们需要生成一个<code class="fe nl nm nn mx b">Mailer</code>,这样它们就可以被发送到下一个处理步骤(或者只是打印在控制台上，我们很快就会看到)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="218d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上述函数接受一组<code class="fe nl nm nn mx b">Employee</code>，然后用一组<code class="fe nl nm nn mx b">Mailer</code>对象调用回调，或者返回一个发布者。</p><h1 id="0ce8" class="lz ma iq bd mb mc ng me mf mg nh mi mj jw ni jx ml jz nj ka mn kc nk kd mp mq bi translated">把所有的放在一起</h1><p id="12a9" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">我们现在将把上面的单个实现放在一起，以体会其中的区别！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3da6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如你所见，在<em class="lr">回调</em>方法中，我们需要嵌套回调。你可以想象，如果将来处理步骤增多，代码将开始变得复杂，难以理解和维护。</p><p id="2b85" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在组合方法中，您可以立即看到处理步骤“链接”在一起形成一个管道，并且很容易推理和理解。</p><p id="3f19" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将来，如果您需要一个新的处理步骤(例如:发送电子邮件),您可以很容易地引入这个步骤，而不必增加代码复杂性或需要重构。</p><p id="c06e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nl nm nn mx b"><a class="ae ob" href="https://developer.apple.com/documentation/combine/publisher/flatmap(maxpublishers:_:)-3k7z5" rel="noopener ugc nofollow" target="_blank">flatMap</a></code>是一个组合操作符，将上游发布者的元素转换成新的发布者。</p><p id="1f6f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nl nm nn mx b"><a class="ae ob" href="https://developer.apple.com/documentation/combine/publisher/sink(receivevalue:)" rel="noopener ugc nofollow" target="_blank">sink</a></code>是一个内置的订阅者，它将发布者的输出连接到一个闭包(它通常结束一个管道)。</p><p id="7b50" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:<em class="lr">应该注意的是，为了形成流水线，第一个发布者的输出应该与流水线中下一个发布者所期望的输入相匹配。所以在我们的例子中</em> <code class="fe nl nm nn mx b"><em class="lr">fetchEmployee</em></code> <em class="lr">返回一个类型为</em><code class="fe nl nm nn mx b"><em class="lr">AnyPublisher&lt;[Employee], Never</em></code><em class="lr">&amp;</em><code class="fe nl nm nn mx b"><em class="lr">applyRaise</em></code><em class="lr">的发布者期望一个数组或者</em> <code class="fe nl nm nn mx b"><em class="lr">Employee</em></code> <em class="lr">。</em></p><p id="3548" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完整的例子可以在<a class="ae ob" href="https://gist.github.com/mvemjsun/2c07b95fcdce147cd604499839bcb365" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="bd98" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">参考</h1><p id="be48" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">对于那些想要理解这些概念的人来说，来自苹果的<a class="ae ob" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank"> Combine </a> docs是一个极好的文档来源。首先掌握一些关键概念是有用的，例如<code class="fe nl nm nn mx b">Publishers</code>、<code class="fe nl nm nn mx b">Subject</code>、&amp;、<code class="fe nl nm nn mx b">Subscriber</code>，然后是内置发布者(例如<code class="fe nl nm nn mx b">Just</code>、&amp;、<code class="fe nl nm nn mx b">Empty</code>等等)，订阅者(例如<code class="fe nl nm nn mx b">sink</code>，最后是组合操作符(例如<code class="fe nl nm nn mx b">flatMap</code>、<code class="fe nl nm nn mx b">tryMap</code>、<code class="fe nl nm nn mx b">zip</code>、<code class="fe nl nm nn mx b">collect</code>、<strong class="kx ir">、</strong>等等)</p></div></div>    
</body>
</html>