# 如何在 Rust 中编写不和谐机器人

> 原文：<https://betterprogramming.pub/writing-a-discord-bot-in-rust-2d0e50869f64>

## 机器人是不和的命脉，所以让我们写一个我们自己的

![](img/49634ba5b225b3d10786997344977f73.png)

不和谐机器人是许多社区的生命线| [不和谐机器人](https://www.wibidata.com/storage/2019/03/Discord-Bots-696x348.png)由[立体声玛克辛](https://www.wibidata.com/writer/stereomax12/)

在很多圈子里，不和已经成为一种相当普遍的交流方式。例如，在游戏中，玩家为了与他人交流而不和是许多游戏的要求。随着这种流行，人们也越来越渴望创建扩展程序来增强用户体验。这就是机器人发挥作用的地方。

在 Rust 中编写一个不和谐机器人主要是关于抽象。Rust 是这样一种语言，在这种语言中，您可以选择项目的抽象级别，同时对性能的影响最小。对于我们的目的来说，这是一个非常有用的特性，因为 Discord 应用程序编程接口(或 API)往往非常简单，并且会使以可理解的方式编程变得非常困难。

对我们来说幸运的是，也有一些了不起的人花了相当多的时间来创建库，使我们可以做出设计选择，而除了组件如何交互之外，根本不用担心它的内部工作，在我看来，这是标准的做法。

一个这样的库是 [Serenity](https://github.com/serenity-rs/serenity) ，它抽象出我们不需要担心的东西，同时保持我们的选项可用。它包含了 Discord API，而且大部分功能都很完整，有语音支持和所有的功能。

Serenity 是一个全方位的神奇图书馆，但它也有缺点，就像所有东西一样。这个库最大的，也是唯一的缺点是它把多线程留给了库的用户。这不是一个交易断路器的使用；对于利用 Rust 的异步特性来说，这只是一个小小的抱怨，但是对于一些人来说，我认为这是一个很大的损失。

# 入门指南

与任何项目一样，首要任务是实际创建项目。因此，在我们开始研究代码之前，继续进行您的项目。你想怎么命名都行，因为这并不重要。我的名字叫做“examplebot ”,因为我不想想出一个更好的名字。

顺便提一下，我将在 GitHub 上主持这个项目。代码是免费的，你可以随意使用，我会为这个项目更新它。

既然我们已经创建了项目，我们需要做的第一件事就是添加我们的依赖项，即`serenity`。为此，我们将进入我们的`Cargo.toml`，并在`[dependencies]`条目下添加以下内容:

这将 Serenity crate 作为依赖项添加到您的项目中。现在，我们可以开始初始化一个基本的机器人。

# 放弃

这篇文章本质上是对 Serenity library 的认可，尽管它不一定是有意的。Serenity 不是唯一一个用 Rust 编写的 Discord API 包装器，但它是我见过的最先进的。

本文还假设读者对 Rust 语言有一定程度的熟悉。如果你还没有完全做到，或者你是一个寻找有趣的第一个项目的初学者，我将很快为这个特定的主题写一篇文章。当我这样做的时候，我会更新这篇文章的链接。

# 乒乓机器人

这是许多指南开始和结束的地方。他们向你展示如何用他们兜售的框架和语言建立一个基本的机器人，他们通常不会走得更远。我们将更进一步，查看宁静图书馆的细节。

首先，我们应该建立客户端。

现在，让我们打开刚才做的东西。

`**use**` **语句** —文件顶部的`use`语句从`serenity`箱中导入我们需要的所有东西。`prelude`模块包含 Serenity 的面向公众的导出，如`Context`结构，`model::prelude`包含 API 调度的映射对象，如`Message` s。

**`**Handler**`**—`Handler`结构是一个没有字段的单元结构，只实现来自`prelude`模块的`EventHandler`特征。在`message`方法中，宏`unimplemented!()`告诉程序在调用该方法时死机，因为它没有被实现。当我们在 ping bot 中使用这个方法时，我们将删除它。****

******`**main**`**函数** — 在我们的主函数中，我们创建了一个`Client`的新实例。这里使用的`.expect()`方法调用告诉我们创建是否以及何时失败并返回一个`Result`。******

****客户端初始化已经完成，让我们创建一个配置模块。该模块将保存与应用程序配置相关的数据和逻辑。为了节省时间，我们姑且称之为`config`。现在，我们创建几个常量来保存程序的重要数据，比如我们的 bot 帐户需要的 Discord API 令牌，或者我们要为将要创建的命令使用的前缀。****

```
**//in src/config.rs
pub const TOKEN: &'static str = "TOKEN HERE";
pub const PREFIX: &'static str = "PREFIX HERE";**
```

****接下来，让我们使用`ron`的力量将我们的配置序列化为 Rusty Object Notation，因为在我看来，它比 JSON 或 YAML 更好。为了能够使用`ron`，我们必须将板条箱添加到我们的依赖项中，如下所示:****

```
**[dependencies]
ron = "0.5.1"**
```

****现在我们在依赖项中有了它，我们将在`src/main.rs`中将其声明为`extern crate`。一旦我们完成了这些，我们将开始在`config`模块中创建一个`save`函数，但是在此之前，让我们想想我们到底需要做什么。****

****首先，我们需要这个函数将私有模块中的数据加载到一个`Config`结构中。我们需要这个函数来序列化该结构，并将序列化后的数据输出到一个文件中，当我们需要时，可以用另一个函数加载该文件。****

****记住所有这些，让我们将以下内容添加到我们的`config`模块中:****

****这个函数正是我们需要它做的。它序列化我们的结构并根据我们的喜好格式化它，然后它将数据写入一个名为`config.ron`的文件；太完美了。****

****现在我们有了一个`save`函数，我们需要一个`load`函数来反序列化配置文件并初始化我们应用程序的设置。这是一个相当简单的任务，可以用几种不同的方法来完成，但是我们将选择最简单的方法。我们将以类似于使用`save`函数的方式使用`std::fs::File`结构。****

****从`save`功能下面开始，添加一个名为`load`的新`pub fn`。****

****让我们看看这里到底发生了什么。首先，我们从`ron`机箱中导入了`de`模块。这允许我们将来呼叫`de::from_reader`。然后我们声明了一个类型为`std::io::Result<Config>`的`pub fn`。你可能会问，当我们可以直接返回配置实例时，为什么我们要返回结果？因为错误。****

****枚举允许简洁的错误处理。通过返回`Ok(config)`，我们告诉编译器一切按计划进行。现在，如果我们返回了`Err(config)`,这将告诉编译器出错了。这叫做软恐慌。这对你的程序来说不是致命的；这是一个可恢复的错误，因为锈书提到他们。可恢复的错误可以在一个`match`或`if let`语句中处理，这就是我们在项目后面要做的。****

****现在我们已经设置好了`config`模块，让我们看看它整体应该是什么样子:****

****既然我们已经回顾了我们在配置模块中的工作，让我们再次看看根模块，`src/main.rs`。****

****我们现在可以利用在`config`模块中声明的`Config`结构将数据传递给客户端初始化。为此，我们必须首先创建一个新的结构实例(`Config::new()`)，然后，如果文件还不存在，`save`配置。如果文件已经存在，那么我们设置调用`Config::load()`。****

****编辑`main`函数并添加一个变量来保存`Config`实例。在函数的顶部，添加`let config = Config::new();`。这创建了一个新的`Config`结构实例，所以我们可以将`Config`T21 到一个文件，或者，如果文件存在，我们可以`load`它。这可能是你需要使用某种`match`或`if let`语句来完成的地方，这取决于文件是否存在。这是可选的，但出于我们的目的，我们将省略它。****

****我们现在已经启动并运行了我们的`Config`。既然我们这样做了，我们将使用`serenity`提供的`command`框架来实现我们的机器人的`ping`功能。****

# ****实现 Pings 和 Pongs****

****我们可以通过实现来自`EventHandler`特征的`message`方法来实现一个基本的 ping 程序。****

```
**impl EventHandler for Handler {
  fn message(&self, context: Context, msg: Message) {
    if msg.content == "!ping" {
      if let Err(why) = msg.channel_id.say(&context.http, "Pong!") {
        println!("Error sending message: {}", why);
      }
    }
  }
}**
```

****这个代码片段可以让包含`!ping`的消息触发来自机器人的消息，说“Pong！”很简单，但这不是我们在这个项目中要做的。****

****通过`EventHandler`特性处理命令的问题是，它不是特别具有可伸缩性。想象一下，有数百条命令都要通过一条庞大的`match`语句来检查。对于负责维护它的可怜的开发人员来说，那将是地狱，更不用说对于最初编写它的人了。****

****那么，如果我们不想手动处理我们的命令，我们能做什么呢？嗯，`serenity`恰好提供了一个不错的命令框架。该库有一个导出的程序宏(属性),它带来了许多实用工具，除了为命令编写代码之外，我们实际上不必做任何事情。****

## ****命令****

****创建命令主要涉及使用`Context`类型。不需要太多的努力，因为这实际上取决于您希望您的命令如何呈现给最终用户。****

****当编写我们的第一个命令时，有几件事情我们需要考虑:这个命令将在什么样的上下文中使用，以及我们希望用户如何能够与它交互。****

****例如，使用我们的 ping 命令，我们并不真的需要用户与之交互，我们也不真的需要担心调用它的上下文。我们所需要做的就是当用户发送符合我们标准的消息时，用一个设置好的消息进行回复。****

****以这段代码为例:****

****这个函数有两个参数:一个类型为`Context`的可变引用和一个`Message`。它返回一个`CommandResult`。这两个参数是自动填充的，我们永远不用担心手动调用这个函数，因为它由库来处理。****

****我们拥有的 ping 命令与我们之前在`EventHandler`中编写的命令相同，但是它有一些关键的不同。最主要的一点是，它是在自己的函数中声明的，这样更容易维护。然后，还有对`CommandResult`的使用，`serenity`使用它在内部处理错误。****

****这个命令也被设置为一个组的一部分，我们可以在一个没有字段的类似单元的结构上用`group`属性来设置。****

```
**#[group]
#[commands(ping)]
struct Public;**
```

****这就创建了一个名为`Public`的组，其中包含了`ping`命令。****

****现在，在`src/main.rs`中，我们将添加一个框架配置。****

```
**client.with_framework(StandardFramework::new()
    .configure(|c |
      c.prefix(config.prefix()))
    .group(&PUBLIC_GROUP));**
```

****这将标准的`serenity`框架添加到客户机实例中，它还会配置前缀并将命令组添加到实例中。****

****记住所有这些片段，我们的[项目应该看起来像这样](https://gist.github.com/Jakender/72b058b7c63303c0b7c84716de7685d6)。****

****你现在有了一个用 Rust 编写的功能不和谐的机器人，它响应一个`ping`命令。这一切都很好，但是在这个故事结束之前，我还想提到一件事:**嵌入。******

# ****嵌入宁静中****

****在`serenity`中嵌入是相当容易创建的。您可以利用`send_message`方法并创建一个嵌入作为参数。****

****这将向接收命令的通道发送消息。在邮件中，创建一个嵌入并应用于该邮件。这是一种快速简单的方式来构建您想要的嵌入，并且您可以创建更多的字段，如`footer`。在我们的示例中，我们可以通过向 embed 方法参数添加一个`e.footer()`来向 embed 添加一个页脚。****

****您可以在函数中利用这一点。尝试将此添加到您的`src/commands.rs`:****

****现在你有了这些你以前(完全)没有的知识，出去为你的 Discord 服务器做一些精彩的东西，或者，如果你想，和你的朋友们一起为一个群 DM 做一些，看看你能从中得到什么乐趣！****

# ****资源****

****[Serenity](https://github.com/serenity-rs/serenity):Serenity 库的 GitHub 源代码库****

****[文档](https://docs.rs/serenity/0.8.0/serenity/):Serenity 库的源代码文档****

****我用 Serenity 用 Rust 编写的例子 Discord bot****

****感谢您的阅读，祝您度过美好的一天！****