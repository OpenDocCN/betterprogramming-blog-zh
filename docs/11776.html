<html>
<head>
<title>How To Upload Images, Store Them and Serve Them With Vapor 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Vapor 4上传、存储和提供图像</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-upload-images-store-them-and-serve-them-with-vapor-4-6d2f12cee62f?source=collection_archive---------5-----------------------#2022-04-15">https://betterprogramming.pub/how-to-upload-images-store-them-and-serve-them-with-vapor-4-6d2f12cee62f?source=collection_archive---------5-----------------------#2022-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3382" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">展开待办事项应用程序，将图像链接到特定的待办事项列表</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e65d8681e5146783b12af4739dd82a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DuHsgJrzw6zc96EZQVUlRw.png"/></div></div></figure><h1 id="defa" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="e8b9" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在过去的几周里，我一直在研究和分享关于Vapor 4及其功能的文章。我从一个简单的项目结构和API定义开始:</p><div class="mi mj gp gr mk ml"><a rel="noopener  ugc nofollow" target="_blank" href="/getting-started-with-vapor-4-part-1-3d731e64fb45"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd iu gy z fp mq fr fs mr fu fw is bi translated">Vapor 4入门—在Swift中构建一个基本的Todo应用程序</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">了解这一以Swift编写的服务器优先工具的基础知识(不那么基础)</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">better编程. pub</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz ks ml"/></div></div></a></div><p id="de5e" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">并以此为基础来解释DB模型关系:</p><div class="mi mj gp gr mk ml"><a rel="noopener  ugc nofollow" target="_blank" href="/getting-started-with-vapor-4-model-relationships-e6e73d6c2412"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd iu gy z fp mq fr fs mr fu fw is bi translated">Vapor 4入门—模型关系</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">扩展待办事项应用程序，了解这一以Swift编写的服务器优先工具的更多高级功能</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">better编程. pub</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz ks ml"/></div></div></a></div><p id="5ea8" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">在本文中，我们将对原始项目进行扩展，并学习如何上传图像、存储图像和提供图像服务。最后，我将提到一些我在研究中没有提到的其他有趣的特性。如果你迷路了，你可以在这里查看最终项目<a class="ae nf" href="https://github.com/fermoya/vapor-tutorial" rel="noopener ugc nofollow" target="_blank"/>:</p><p id="4db2" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated"><a class="ae nf" href="https://github.com/fermoya/vapor-tutorial" rel="noopener ugc nofollow" target="_blank">https://github.com/fermoya/vapor-tutorial</a></p><h1 id="739e" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">将图像上传到Vapor</h1><p id="87eb" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们在这里的目标是创建一个新的端点<code class="fe ng nh ni nj b">/todo-lists/&lt;id&gt;/upload-image</code>，它将接受一个带有图像的<code class="fe ng nh ni nj b">multipart</code>表单。让我们首先创建端点。转到<code class="fe ng nh ni nj b">TodoListViewController.boot(routes:)</code>方法并创建一条新路线:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="f98c" class="no kv it nj b gy np nq l nr ns">func boot(routes: RoutesBuilder) throws {<br/>  ...<br/>  let singleListRoutes = ...<br/>  singleListRoutes.get("upload-image", use: uploadImage)<br/>}</span><span id="1b2b" class="no kv it nj b gy nt nq l nr ns">private func uploadImage(req: Request) throws -&gt; EventLoopFuture&lt;Response&gt; {<br/>  ...<br/>}</span></pre><p id="01d7" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">现在，我们需要做的就是提取图像数据，但我们如何做呢？一旦我们有了文件，我们如何存储和提供它？</p><p id="2110" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">为此，我们可以利用<code class="fe ng nh ni nj b">FileMiddleware</code>。一个<code class="fe ng nh ni nj b">Middleware</code>只是一个类，它让你在传入的<code class="fe ng nh ni nj b">request</code>到达<code class="fe ng nh ni nj b">route</code>处理程序之前对其进行处理。你可以把它想象成一个代理。例如，您可以创建自己的回复，让所有回复都添加一个所有回复通用的标题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="f682" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">出于我们的目的，Vapor附带了<code class="fe ng nh ni nj b">FileMiddleware</code>，它允许您从一个公共文件夹向客户提供资产。为了简单起见，我们将使用<code class="fe ng nh ni nj b">workingDirectory</code>,但理想情况下，您将从特定的公共目录提供文件。</p><p id="bd35" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">与数据库或迁移类似，任何类型的配置都需要在<code class="fe ng nh ni nj b">configure.swift</code>内的<code class="fe ng nh ni nj b">configure(_:)</code>函数中完成:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="4523" class="no kv it nj b gy np nq l nr ns">app.middleware.use(FileMiddleware(publicDirectory: app.directory.workingDirectory))</span></pre><p id="52d0" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">此外，我们需要增加请求的<code class="fe ng nh ni nj b">defaultMaxBodySize</code>:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="87b6" class="no kv it nj b gy np nq l nr ns">app.routes.defaultMaxBodySize = "10mb"</span></pre><p id="051e" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">否则，你会得到一个有效载荷过大的错误。现在我们需要做的就是解码来自<code class="fe ng nh ni nj b">request</code>的图像，并将其存储在服务器上。让我们这样做:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="a427" class="no kv it nj b gy np nq l nr ns">// 1.<br/>let file = try req.content.decode(File.self)<br/>let path = req.application.directory.workingDirectory + file.filename</span><span id="05b7" class="no kv it nj b gy nt nq l nr ns">// 2.<br/>return req.fileio<br/>  .writeFile(file.data, at: file.filename)</span><span id="7623" class="no kv it nj b gy nt nq l nr ns">// 3.<br/>  .transform(to: Response(status: .accepted))</span></pre><p id="dfdb" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">让我们来分解一下:</p><ul class=""><li id="63ac" class="nw nx it lo b lp na ls nb lv ny lz nz md oa mh ob oc od oe bi translated">首先，我们从响应中解码出一个<code class="fe ng nh ni nj b">File</code>。Vapor附带了这个工具。此外，我们形成了存储文件的路径。</li><li id="0c1e" class="nw nx it lo b lp of ls og lv oh lz oi md oj mh ob oc od oe bi translated">接下来，我们使用<code class="fe ng nh ni nj b">fileIO</code>将文件写入保存到服务器中的一个路径中</li><li id="db98" class="nw nx it lo b lp of ls og lv oh lz oi md oj mh ob oc od oe bi translated">最后，我们返回一个<code class="fe ng nh ni nj b">accepted</code>响应</li></ul><p id="680e" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">说够了，我们试一试好吗？我下载了一个<a class="ae nf" href="https://www.hackingwithswift.com/uploads/vapor.png" rel="noopener ugc nofollow" target="_blank">样本图像</a>，然后我可以将它用于我的<code class="fe ng nh ni nj b">TodoList</code>:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="c086" class="no kv it nj b gy np nq l nr ns">$ curl localhost:8080/v1/todo-lists \<br/>    -X POST \<br/>    -H "Content-Type:application/json" \<br/>    --data "{ \"name\": \"Foo\" }"<br/>{"id":"F65B591A-AFE9-4848-AFCB-4FC606002596","name":"Foo"}</span><span id="fba1" class="no kv it nj b gy nt nq l nr ns">$ curl localhost:8080/v1/todo-lists/F65B591A-AFE9-4848-AFCB-4FC606002596/upload-image \<br/>    -F filename=example.webp \<br/>    -F data=@/Users/fermoya/Desktop/example.webp \<br/>    -H "Content-Type:multipart/form-data"</span></pre><p id="4ec0" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">不错！但是我现在的形象呢？嗯，我们用的文件<code class="fe ng nh ni nj b">path</code>是<code class="fe ng nh ni nj b">/&lt;working_directory&gt;/&lt;file_name&gt;</code>。这意味着该文件将在<code class="fe ng nh ni nj b">localhost:8080/&lt;file_name&gt;</code>下可用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/d212c4adbf33118d04b0f108323ece70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bO-VsKMnShyS_NSYCU-lxA.png"/></div></div></figure><p id="bcb8" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">然而，图像还没有链接到任何<code class="fe ng nh ni nj b">TodoList</code>！事实上，我们只是存储图像，但如果不保存到我们的<code class="fe ng nh ni nj b">TodoList</code>模型中，图像就会丢失。</p><h1 id="f58b" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">将图像链接到我们的模型</h1><p id="9c0d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">目前，<code class="fe ng nh ni nj b">TodoList</code>还没有准备好保存图像。我们需要向模型中添加一个新字段。如果您还记得以前的文章，这很容易做到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="7523" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">请注意，我们只是更新了一个现有的表。对于我们的例子来说，这并不是必需的，因为我们使用的是内存数据库，但是对于真正的应用程序来说，您可能需要它。确保仅在<code class="fe ng nh ni nj b">CreateTodoListMigration</code>中创建表格后才更新表格。</p><p id="9724" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">现在，我们只需要更新<code class="fe ng nh ni nj b">/upload-image</code>实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="fabd" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">这里有什么新鲜事？</p><ul class=""><li id="157b" class="nw nx it lo b lp na ls nb lv ny lz nz md oa mh ob oc od oe bi translated">首先，我们获取列表，如果<code class="fe ng nh ni nj b">notFound</code>失败则中止</li><li id="507c" class="nw nx it lo b lp of ls og lv oh lz oi md oj mh ob oc od oe bi translated">其次，保存图像后更新列表。这与我们在第1部分留给读者的一个练习有些关系</li><li id="187c" class="nw nx it lo b lp of ls og lv oh lz oi md oj mh ob oc od oe bi translated">作为响应返回更新的列表</li></ul><p id="cc1f" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">我们完了！如果您尝试这一次，您应该会得到如下结果:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="4e3a" class="no kv it nj b gy np nq l nr ns">$ curl localhost:8080/v1/todo-lists \<br/>    -X POST \<br/>    -H "Content-Type:application/json" \<br/>    --data "{ \"name\": \"Foo\" }"<br/>{"id":"F65B591A-AFE9-4848-AFCB-4FC606002596","name":"Foo", "imageURL": null}</span><span id="12c7" class="no kv it nj b gy nt nq l nr ns">$ curl localhost:8080/v1/todo-lists/F65B591A-AFE9-4848-AFCB-4FC606002596/upload-image \<br/>    -F filename=example.webp \<br/>    -F data=@/Users/fermoya/Desktop/example.webp \<br/>    -H "Content-Type:multipart/form-data" | jq<br/>{<br/>  "id": "F65B591A-AFE9-4848-AFCB-4FC606002596",<br/>  "name": "Foo",<br/>  "imageURL": "127.0.0.1:8080/example.webp"<br/>}</span></pre><p id="d978" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">这很简洁，尽管在这个实现中有一个很大的缺陷:我们没有真正正确地处理图像，并且如果，比方说，一个同名的图像被上传到一个完全不同的列表，那么覆盖这些改变是相当简单的。</p><p id="3e60" class="pw-post-body-paragraph lm ln it lo b lp na ju lr ls nb jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">解决这个问题的一个方法是忽略<code class="fe ng nh ni nj b">multipart/form-data</code>中的<code class="fe ng nh ni nj b">filename</code>字段，并像<code class="fe ng nh ni nj b">MD5_Hash(#"&lt;uuid&gt;.&lt;timestamp&gt;")</code>一样编写名称，但是我们将把它留给读者作为练习。</p><h1 id="e2b0" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">从这里去哪里？</h1><p id="e6b9" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">由于时间有限，我们在本系列中没有介绍太多特性，但是这些特性值得一提:</p><ul class=""><li id="ebe5" class="nw nx it lo b lp na ls nb lv ny lz nz md oa mh ob oc od oe bi translated"><a class="ae nf" href="https://docs.vapor.codes/4.0/leaf/overview/" rel="noopener ugc nofollow" target="_blank"> Leaf </a>:我们关注的是Vapor的后端，但是框架附带了Leaf，它可以帮助你将<code class="fe ng nh ni nj b">Swift</code>转换成动态的<code class="fe ng nh ni nj b">HTML</code>。这将帮助您创建web应用程序的前端。</li><li id="7a23" class="nw nx it lo b lp of ls og lv oh lz oi md oj mh ob oc od oe bi translated"><a class="ae nf" href="https://docs.vapor.codes/4.0/logging/" rel="noopener ugc nofollow" target="_blank">记录</a>:<code class="fe ng nh ni nj b">Request</code>和<code class="fe ng nh ni nj b">Application</code>都有一个<code class="fe ng nh ni nj b">logger</code>属性，有几个跟踪级别:<code class="fe ng nh ni nj b">INFO</code>、<code class="fe ng nh ni nj b">ERROR</code>、<code class="fe ng nh ni nj b">DEBUG</code> …比如<code class="fe ng nh ni nj b">req.logger.debug("Updating list with id \(id)")</code></li><li id="20fe" class="nw nx it lo b lp of ls og lv oh lz oi md oj mh ob oc od oe bi translated">高级路由:我们没有涉及的一些事情是:<br/>–<a class="ae nf" href="https://docs.vapor.codes/4.0/routing/#redirections" rel="noopener ugc nofollow" target="_blank">重定向</a>:例如，一个端点被重命名，您希望简单地重新路由到新的端点。<br/>–<a class="ae nf" href="https://docs.vapor.codes/4.0/routing/#catchall" rel="noopener ugc nofollow" target="_blank">Catchalls</a>:使用<code class="fe ng nh ni nj b">**</code>作为动态路线来匹配一个或多个组件，即<code class="fe ng nh ni nj b">/foo/**</code>响应<code class="fe ng nh ni nj b">/foo/bar</code>、<code class="fe ng nh ni nj b">/foo/bar/abc</code>、…然后您可以使用<code class="fe ng nh ni nj b">getCatchall</code>将其检索为一个数组<code class="fe ng nh ni nj b">String</code><br/>–<a class="ae nf" href="https://docs.vapor.codes/4.0/routing/#viewing-routes" rel="noopener ugc nofollow" target="_blank">查看所有路线</a>:您可以通过<code class="fe ng nh ni nj b">print(app.routes.all)</code>打印所有注册的路线</li><li id="ad9f" class="nw nx it lo b lp of ls og lv oh lz oi md oj mh ob oc od oe bi translated"><a class="ae nf" href="https://docs.vapor.codes/4.0/client/" rel="noopener ugc nofollow" target="_blank"> HTTP客户端</a>:谁说你不需要从你的一个端点发出HTTP请求？Vapor附带了一个易于使用的HTTP客户端。</li><li id="1fe0" class="nw nx it lo b lp of ls og lv oh lz oi md oj mh ob oc od oe bi translated"><a class="ae nf" href="https://docs.vapor.codes/4.0/websockets/" rel="noopener ugc nofollow" target="_blank"> Websockets </a>:客户端和你的服务器之间的双向通信，比如说一个聊天应用。</li><li id="26d5" class="nw nx it lo b lp of ls og lv oh lz oi md oj mh ob oc od oe bi translated"><a class="ae nf" href="https://docs.vapor.codes/4.0/queues/" rel="noopener ugc nofollow" target="_blank">队列</a>:如果您的端点触发了一些繁重的操作，这非常有用。你可以快速回复客户并安排一个<code class="fe ng nh ni nj b">Job</code>。一个非常常见的例子是需要发送电子邮件的<code class="fe ng nh ni nj b">reset-password</code>端点。</li><li id="d4ec" class="nw nx it lo b lp of ls og lv oh lz oi md oj mh ob oc od oe bi translated"><a class="ae nf" href="https://docs.vapor.codes/4.0/services/" rel="noopener ugc nofollow" target="_blank">服务</a>:在多个端点重用代码或使用第三方库时，它们会派上用场。</li><li id="a1e5" class="nw nx it lo b lp of ls og lv oh lz oi md oj mh ob oc od oe bi translated"><a class="ae nf" href="https://docs.vapor.codes/4.0/apns/" rel="noopener ugc nofollow" target="_blank">APNS:</a>Swift开发的Vapor很可能是为使用过iOS/macOS的人设计的，它使支持苹果通知变得很容易。</li></ul></div></div>    
</body>
</html>