<html>
<head>
<title>Beginning Python Programming — Part 13</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python编程入门—第13部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/beginning-python-programming-part-13-6147ce4cd88d?source=collection_archive---------5-----------------------#2019-06-15">https://betterprogramming.pub/beginning-python-programming-part-13-6147ce4cd88d?source=collection_archive---------5-----------------------#2019-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b63c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入研究异步代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/91326bd49045caa121fdcffa52a381f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HAKdIoahFrqSaxlO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@amir_v_ali?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿米拉里·米尔哈西米安</a>拍摄的照片</p></figure><p id="e5f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前一篇文章中，我们讨论了迭代器和生成器。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/beginning-python-programming-part-12-5450ae804936" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Python编程入门—第12部分</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">迭代器和生成器介绍</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="c283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将深入研究异步代码，或者可以同时做多件事情的代码。提醒一句，这一课会很难。这将要求你很好地掌握我们到目前为止所涉及的一切。好消息是，在这之后，剩下的就比较容易了。</p><p id="0c5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然大多数文章在给出异步编程如何工作的例子时使用了<code class="fe mn mo mp mq b">sleep()</code>,但我向一个朋友保证，我会避免使用这种语法来解释异步代码。你所需要知道的是，当你调用<code class="fe mn mo mp mq b">sleep(3)</code>时，程序的执行将等待<code class="fe mn mo mp mq b">3</code>秒后再继续。</p><p id="f78c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始之前，我们需要了解一些贯穿本文的术语。</p><ul class=""><li id="31ff" class="mr ms it lb b lc ld lf lg li mt lm mu lq mv lu mw mx my mz bi translated"><em class="na">协程</em>——异步编程的最底层，这是一个异步处理的函数。这些可以直接运行或在<em class="na">任务</em>中使用。</li><li id="7b3f" class="mr ms it lb b lc nb lf nc li nd lm ne lq nf lu mw mx my mz bi translated"><em class="na">任务</em> —用于调度协同程序，以供系统异步执行。</li><li id="12d7" class="mr ms it lb b lc nb lf nc li nd lm ne lq nf lu mw mx my mz bi translated"><em class="na"> Future </em> —用于挂起协程，直到另一个协程完成。(请将此视为需要在完成之前获取数据的后台代码)</li><li id="bc1a" class="mr ms it lb b lc nb lf nc li nd lm ne lq nf lu mw mx my mz bi translated"><em class="na">事件循环</em> —在一个或多个任务上迭代直到完成的循环。在web服务器中，这可能是一个等待客户端连接的无限循环。这是Python中async的核心；它协调所有在后台完成的工作。</li><li id="9009" class="mr ms it lb b lc nb lf nc li nd lm ne lq nf lu mw mx my mz bi translated"><em class="na"> CPU </em> —中央处理器；计算机中执行计算(即工作)的硬件。</li><li id="7dc1" class="mr ms it lb b lc nb lf nc li nd lm ne lq nf lu mw mx my mz bi translated"><em class="na"> CPU物理内核</em> —如今的CPU包含多个内核。这些内核可能包括逻辑处理器(例如英特尔i3、i5、i7)。每个物理内核负责处理数据或将工作移交给逻辑处理器。拆一个CPU就能摸到物理核心。</li><li id="28da" class="mr ms it lb b lc nb lf nc li nd lm ne lq nf lu mw mx my mz bi translated"><em class="na">逻辑处理器</em> —如果一个物理内核包含逻辑处理器，这些逻辑处理器执行工作。逻辑处理器仅仅因为软件而存在，但是这允许你的计算机同时做多件事情。(下载文件时一边写代码一边流音乐等。) .逻辑处理器是您在四核计算机上看到八核的原因。</li><li id="8261" class="mr ms it lb b lc nb lf nc li nd lm ne lq nf lu mw mx my mz bi translated"><em class="na">线程</em> —执行工作的物理或逻辑处理器内的队列。处理器可以包含多个队列；它们只是基于优先级进行调度。由于计算机有多个内核，您的代码可能在一个内核的主线程上运行，而您的用户界面可能在另一个内核的主线程上运行。任何不在主线程上运行的代码都被视为在后台运行。</li></ul><h2 id="fdfa" class="ng nh it bd ni nj nk dn nl nm nn dp no li np nq nr lm ns nt nu lq nv nw nx ny bi translated">获奖名单</h2><p id="6096" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated"><code class="fe mn mo mp mq b">asyncio</code>是一个我们可以导入来执行异步代码的模块。它是为那些有很多慢速I/O(输入/输出)连接的情况而设计的，并提供了两个重要的实用程序— <code class="fe mn mo mp mq b">async</code>和<code class="fe mn mo mp mq b">await</code>。使用<code class="fe mn mo mp mq b">asyncio</code>的一个很好的例子是web服务器。</p><p id="1076" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe mn mo mp mq b">awaitable</code>是一个可以在<code class="fe mn mo mp mq b">await</code>表达式中使用的对象。<code class="fe mn mo mp mq b">async</code>用于任何包含<code class="fe mn mo mp mq b">await</code>的函数的<code class="fe mn mo mp mq b">def</code>之前。</p><h2 id="4635" class="ng nh it bd ni nj nk dn nl nm nn dp no li np nq nr lm ns nt nu lq nv nw nx ny bi translated">协程和未来</h2><p id="787f" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">虽然我在上面给了你一个定义，但我希望你在进入细节之前对大局有一个基本的了解。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="6861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道这看起来像很多代码，但是我们将一次一个部分地完成它。这是我在这里找到的<a class="ae ky" href="https://www.pythonsheets.com/notes/python-asyncio.html" rel="noopener ugc nofollow" target="_blank"/>的一个剧本的返工。</p><p id="c662" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在顶部，我们有两个导入:<code class="fe mn mo mp mq b">asyncio</code>和<code class="fe mn mo mp mq b">json</code>。<code class="fe mn mo mp mq b">asyncio</code>是在将数据返回给客户端时要做的重要工作，而<code class="fe mn mo mp mq b">json</code>只是用来将我们的字典编码成一个JSON结构，我们可以将它返回给每个客户端。</p><p id="d54e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个方法<code class="fe mn mo mp mq b">async def connection(reader, writer)</code>用于在客户端请求数据时响应客户端。因为我们使用了<code class="fe mn mo mp mq b">async</code>，所以这是一个协程对象，它将在一个单独的线程上运行，这样服务器就可以在返回响应的同时处理其他请求。<code class="fe mn mo mp mq b">reader</code>用于将请求传递给我们的函数，<code class="fe mn mo mp mq b">writer</code>形成响应返回给客户端。</p><p id="b571" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们使用<code class="fe mn mo mp mq b">await reader.read(1024)</code>读取请求。当我们请求某样东西时，通常会有一些数据伴随着请求。这些数据告诉我们客户想做什么，以及希望如何做。只要这个响应有效，就由我们的服务器来完成。这里我们读取的是前1024个字节，对于任何GET请求来说应该足够了。我们使用<code class="fe mn mo mp mq b">await</code>来暂停这个方法，直到所有的数据都可以被读取。这意味着<code class="fe mn mo mp mq b">reader.read(1024)</code>是一个未来。</p><p id="a627" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们开始构建我们的响应。因为我们需要告诉客户端如何理解我们发送回来的数据，所以我们需要包含一个头。</p><p id="a8ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个标题中，我们告诉客户一些事情:</p><ul class=""><li id="0050" class="mr ms it lb b lc ld lf lg li mt lm mu lq mv lu mw mx my mz bi translated">HTTP/1.1 —我们正在响应的HTTP版本</li><li id="f095" class="mr ms it lb b lc nb lf nc li nd lm ne lq nf lu mw mx my mz bi translated">200 OK —请求的状态代码，200表示成功</li><li id="46e5" class="mr ms it lb b lc nb lf nc li nd lm ne lq nf lu mw mx my mz bi translated">Content-Type: application/json —我们返回的内容类型将是json。</li></ul><p id="4d8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能会注意到我们在请求中包含了<code class="fe mn mo mp mq b">\r\n</code>，并且在末尾出现了两次。</p><p id="b8d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">\r</code>是创建回车(CR)的转义序列。这是老式打字机的典型代表，当你敲击书页边缘时。需要一个回车符来将回车符(固定纸张的横条)带回到页面的左边。<code class="fe mn mo mp mq b">\r</code>用于x之前的Mac OS版本的新行。</p><p id="cf41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">\n</code>是创建换行符(LF)的转义序列。回到打字机前；换行是指你向下翻页开始新的一行。<code class="fe mn mo mp mq b">\n</code>至今仍在Linux和macOS系统中使用，用来表示新行。</p><p id="2c8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是既做回车又做换行符的想法(CRLF)。虽然它更准确地描述了人们使用打字机时发生的事情，但它也被用来在窗口中创建新行。这也是当你在Windows和Linux(或者Windows和macOS)之间切换时，你的代码有时不能工作的一个很大的原因。</p><p id="3df6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，回到正题。接下来，我们有了<code class="fe mn mo mp mq b">data</code>，它只是我使用<a class="ae ky" href="https://next.json-generator.com/NkDNBEp08" rel="noopener ugc nofollow" target="_blank">这个脚本</a>创建的JSON的一个随机位，为了简洁起见稍微修改了一下，并将其作为字典存储在代码片段中。</p><p id="dc89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们使用<code class="fe mn mo mp mq b">json.dumps(data)</code>将字典转换成JSON字符串。<code class="fe mn mo mp mq b">dumps</code>代表“转储字符串”因为我们的web服务器只喜欢处理字节，所以我们将它转换成一个<code class="fe mn mo mp mq b">bytes</code>对象，给它一个UTF-8编码，这样我们的客户端就可以正确地解析它。</p><p id="b7b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们使用<code class="fe mn mo mp mq b">writer.write(header + body)</code>。首先，它将<code class="fe mn mo mp mq b">header</code>与<code class="fe mn mo mp mq b">body</code>连接起来，然后在关闭我们的编写器之前，我们将这些数据写回web服务器以返回给客户端，这有效地刷新了编写器的缓冲区并从内存中删除了对象。</p><p id="06f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">async def main(host, port)</code>是一个协程，用于处理进入web服务器的请求。它接受一个<code class="fe mn mo mp mq b">host</code>和一个<code class="fe mn mo mp mq b">port</code>作为参数，这些参数将在主体中用来创建一个基本的web服务器。</p><p id="0b4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">server = await asyncio.start_server(connection, host, port)</code>很长，但很容易理解。我们使用<code class="fe mn mo mp mq b">asyncio.start_server</code>创建一个<code class="fe mn mo mp mq b">server</code>对象。这是一个未来，它将使用我们上面的<code class="fe mn mo mp mq b">connection()</code>协程、一个<code class="fe mn mo mp mq b">host</code>、这个将被托管的服务器的IP地址以及我们将接受连接的服务器上的<code class="fe mn mo mp mq b">port</code>来创建一个web服务器。</p><p id="ce0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">async with server</code>是我们还没有涉及的新语法。<code class="fe mn mo mp mq b">with</code>本质上是在我们完成任何我们想要做的事情后，进行创建和任何必要的清理。<code class="fe mn mo mp mq b">async with server</code>使用<code class="fe mn mo mp mq b">async</code>启动<code class="fe mn mo mp mq b">server</code>，如果我们遇到任何问题，它会干净利落地关闭服务器。这里我们用它来运行一个未来<code class="fe mn mo mp mq b">await server.serve_forever()</code>。没错，上面为我们创建的服务器也自带了一个<code class="fe mn mo mp mq b">async </code>功能。</p><p id="14de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要设置服务器。</p><p id="cbfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个允许我们运行协程的事件循环。<code class="fe mn mo mp mq b">main("0.0.0.0", 8000)</code>是我们传入的协程，因为它最终会调用我们的<code class="fe mn mo mp mq b">connection</code>协程。</p><p id="2ede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不熟悉IP地址，这里有一个快速的纲要:</p><ul class=""><li id="151a" class="mr ms it lb b lc ld lf lg li mt lm mu lq mv lu mw mx my mz bi translated">127.0.0.1 —没有比家更好的地方了，这是您的本地环回地址。</li><li id="b804" class="mr ms it lb b lc nb lf nc li nd lm ne lq nf lu mw mx my mz bi translated">0.0.0.0 —告知服务器在所有接口(网卡)的所有IP地址上运行主机。如果您有一个以太网端口和一个无线网卡，服务器将对两个接口都可用。这个要小心；您可能只想为一个网络接口指定IP地址，以太网始终是首选。</li></ul><p id="020d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每台计算机都有许多可用的端口，确切地说是65536个，尽管我们从0开始，所以最大端口号是65535。一定要回顾一下<a class="ae ky" href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers" rel="noopener ugc nofollow" target="_blank">知名港口</a>(共有1024个)。在测试期间，您应该尽可能地远离它们，因为它们是为特定的功能保留的。端口80用于HTTP，端口443用于HTTPS。虽然我不能说我都记住了，但我记得我用得最多的。</p><p id="d417" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还应该注意其他端口，例如PostgreSQL-5432、MSSQL-1433、1434、MySQL-3306和RDP-3389。</p><p id="880b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些都是基本的东西，你用得越多，就会越熟悉。</p><p id="e17d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回去吧！您可能会注意到，我将它包装在一个try/except块中。我这样做是因为当我按下键盘上的<code class="fe mn mo mp mq b">ctrl+c</code>时，程序崩溃了。我不喜欢它，所以我处理了用户中断执行时发生的异常<code class="fe mn mo mp mq b">KeyboardInterrupt</code>。我本可以让它安静地结束，但是为了对网站管理员友好，我决定在退出之前打印“停止web服务器”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/0374db98a6052d456a35d661876948ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PGhtm-KrD_GmsbTA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@glenncarstenspeters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格伦·卡斯滕斯-彼得斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h2 id="4888" class="ng nh it bd ni nj nk dn nl nm nn dp no li np nq nr lm ns nt nu lq nv nw nx ny bi translated">任务</h2><p id="93f4" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">说到任务，首先要记住的是任务不是线程安全的。这意味着，如果一个协程更改了另一个协程使用的数据，可能会出现一些意想不到的结果，或者更糟，您的程序可能会崩溃。</p><p id="634e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在线程安全方面，可以这样想:我们俩开同一辆车。我们必须计划好谁在什么时间开车。如果我在8-5点之间开车去上班，而你试图在上午10点开车，你将无法开车，因为车不在那里。</p><p id="8970" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设我们有一个缓冲区，可以包含任何我们想要存储的数据。然后我们有两个任务使用同一个缓冲区来执行工作。一个任务使用整数数据类型，另一个使用字符串。</p><p id="7d8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个任务在缓冲区中存储42，第二个任务用“Hello”替换缓冲区的内容，然后第一个任务试图使用缓冲区将1加到缓冲区中…您看到这会给我们带来什么问题吗？</p><p id="d4e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">警告结束后，让我们深入研究任务。</p><p id="5974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任务用于调度协程。任务也可以用来同时运行多个协同程序。</p><p id="d25b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种方法可用于任务，允许您取消任务、返回任务结果、检查任务状态以及添加或删除任务的<em class="na">回调</em>。</p><p id="fb09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回调本质上是任务完成时将调用的方法或函数。如果我有一个将“Bob”打印到屏幕上的任务，它可能会有一个回调函数，该函数在完成时会打印“程序完成”。</p><p id="841f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候举一个我从<a class="ae ky" href="http://skipperkongen.dk/2016/09/09/easy-parallel-http-requests-with-python-and-asyncio/" rel="noopener ugc nofollow" target="_blank">这页</a>借来的例子了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7b87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">照例，我们<code class="fe mn mo mp mq b">import asyncio</code>。然后我们有一个<code class="fe mn mo mp mq b">count</code>函数，它将当前的运行次数作为参数。然后我们为每次运行打印100次迭代。我们以前做过这些。</p><p id="87b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">create_tasks</code>是一个异步函数，它使用<code class="fe mn mo mp mq b">asyncio.get_event_loop()</code>创建一个内部事件循环。它提供了一个事件循环，我们可以使用它来执行任务。</p><p id="7395" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我创建了一个清单理解，生成300个任务来运行。在这个列表的理解里面，我们使用<code class="fe mn mo mp mq b">inner_loop.run_in_executor</code>。该函数的第一个参数需要一个<em class="na">concurrent . futures . executor</em>实例。如果我们像这里一样传入<code class="fe mn mo mp mq b">None</code>，我们使用默认的执行器。这很好地满足了我们的需求。第二个参数<code class="fe mn mo mp mq b">count</code>，指的是我们希望并发调用的函数，也就是同时调用。最后，<code class="fe mn mo mp mq b">i</code>是我们传入的参数，它将在被调用时交给<code class="fe mn mo mp mq b">count</code>函数。</p><p id="e197" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们使用<code class="fe mn mo mp mq b">for _ in await asyncio.gather(*tasks)</code>将我们所有的任务添加到一个未来中，这个未来将我们所有的任务聚合成一个结果。</p><p id="aa40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的程序将开始创建一个用于调度内循环的外循环，告诉它<code class="fe mn mo mp mq b">run_until_complete</code>并传入函数<code class="fe mn mo mp mq b">create_tasks()</code>作为它需要执行的唯一任务。</p><p id="a0a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦任务完成，外部循环关闭。虽然我们似乎忘记了关闭内部循环，但当<code class="fe mn mo mp mq b">create_tasks</code>结束时，它会自动关闭。如果我们试图在函数结束时关闭它，我们会得到一个运行时错误，即我们不能关闭一个正在运行的事件循环。</p><p id="08cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您运行这段代码，并在输出中寻找任何看起来奇怪的东西。如果你使用小范围，你会看到更少的异常，也许没有。但是如果您这样做了，请不要担心，因为我们并没有以线程安全的方式创建所有这些任务。如果我们想这样做，我们可以一次处理一个任务的结果，如果它们都存储在同一个地方的话。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="a2d7" class="oo nh it bd ni op oq or nl os ot ou no jz ov ka nr kc ow kd nu kf ox kg nx oy bi translated">摘要</h1><p id="a848" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">今天我们学习了协程、任务、未来和事件循环。我认为目前这已经足够好了，但是就异步编程而言，我们还有更多的内容要介绍。没错，兔子洞更深！我们不仅有<code class="fe mn mo mp mq b">asyncio,</code>,而且还有线程和多处理供我们使用。我们还没有讨论后两者，但是它们即将出现。</p><p id="806b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有不明白的地方，不要担心。使用异步代码需要时间和经验。探索，自己尝试，不要害怕改变；它总是可以被修复的。</p><h2 id="eea7" class="ng nh it bd ni nj nk dn nl nm nn dp no li np nq nr lm ns nt nu lq nv nw nx ny bi translated">推荐阅读</h2><div class="lv lw gp gr lx ly"><a href="https://docs.python.org/3/library/asyncio.html" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">asyncio -异步I/O - Python 3.7.3文档</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">asyncio被用作多个Python异步框架的基础，这些框架提供了高性能的网络和…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">docs.python.org</p></div></div></div></a></div><div class="lv lw gp gr lx ly"><a href="https://realpython.com/async-io-python/" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Python中的异步IO:完整的演练-真实的Python</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">Async IO是一种并发编程设计，在Python中获得了专门的支持，它是从Python快速发展而来的…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">realpython.com</p></div></div><div class="mh l"><div class="oz l mj mk ml mh mm ks ly"/></div></div></a></div></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="21ab" class="oo nh it bd ni op oq or nl os ot ou no jz ov ka nr kc ow kd nu kf ox kg nx oy bi translated">下一步是什么</h1><p id="bfa8" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">更多异步代码，呜呜！只是这次我们不会报道<code class="fe mn mo mp mq b">asyncio</code>。相反，在<code class="fe mn mo mp mq b">asyncio</code>可能不理想的地方，我们将寻找其他方法来进行异步编程。当我们讨论完异步的时候，我会添加一篇文章，我发现这篇文章很好地解释了当你选择一个而不是另一个的时候。在那之前，继续练习！</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/beginning-python-programming-part-14-208b9fa2f0a1" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Python编程入门—第14部分</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">多线程简介</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="pa l mj mk ml mh mm ks ly"/></div></div></a></div></div></div>    
</body>
</html>