<html>
<head>
<title>Configure Your Go Microservice for Cloud Using Viper</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Viper为云配置Go微服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modern-rest-api-with-go-and-postgresql-1d48767a813?source=collection_archive---------1-----------------------#2022-08-19">https://betterprogramming.pub/modern-rest-api-with-go-and-postgresql-1d48767a813?source=collection_archive---------1-----------------------#2022-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4590" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Go构建现代REST API第3部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1d4283a2fc0198f2d2c0a77574a82792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Poq7n64LqdvFVBnNk8FhLw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@shutter_hunter" rel="noopener ugc nofollow" target="_blank"> Austin Lowman </a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="1e04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文是一系列文章中的第三篇，涵盖了逐步实现现代REST API微服务的所有方面:</p><ol class=""><li id="2e00" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-c765d571b9e7" rel="noopener">使用sqlc定义SQL first数据模型</a></li><li id="b88f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-39b0e966534a" rel="noopener">用Gin实现REST API</a></li><li id="55cf" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">用Viper配置</strong></li><li id="6a11" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-e0070aa1b383" rel="noopener">在容器中构建和运行</a></li><li id="a305" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-7c916ce2816a" rel="noopener">集装箱测试</a></li></ol><p id="0265" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该系列的所有代码可从以下网址获得:</p><div class="mg mh gp gr mi mj"><a href="https://github.com/bquenin/modern-go-rest-api-tutorial" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd ir gy z fp mo fr fs mp fu fw ip bi translated">GitHub-bque nin/go-modern-rest-API-tutorial:这是一个REST微服务样本。它的特点是:一…</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">这是一个REST微服务示例。它的特点是:一个使用https://gin-gonic.com/数据库的REST API服务器…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">github.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx kp mj"/></div></div></a></div></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="f178" class="nf ng iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">使用哪种配置机制？</h1><p id="0df8" class="pw-post-body-paragraph kw kx iq ky b kz nx jr lb lc ny ju le lf nz lh li lj oa ll lm ln ob lp lq lr ij bi translated">在配置应用程序时，有很多选择。您可以使用命令行参数、配置文件、环境变量、远程配置服务(如<code class="fe oc od oe of b">etcd</code>、consul等。)，或者全部的组合。</p><p id="f1f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每种机制都有意义，这取决于您的用例。由于我们正在构建一个最终将被容器化的微服务，所以依赖命令行参数对我们来说没有太大意义。事实上，为了更好地与一个orchestrator(比如Kubernetes或其他)配合，我们的容器应该立即启动，最好不需要任何额外的配置。</p><p id="540f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任何需要提供或覆盖的值都应该使用环境变量来完成。这为运营团队提供了很大的灵活性，并且可以很好地使用所有基于容器的部署工具。</p><p id="bda6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您的应用程序有很多参数，您不希望让操作者为启动应用程序而提供大量的值。因此，我们将混合使用配置文件和环境变量:</p><ul class=""><li id="29b3" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr og ly lz ma bi translated">配置文件包含所有的默认值，并且嵌入在go二进制文件中:您既不想公开您的配置文件，也不想记录它。这是一个实现细节；您可以稍后决定直接从代码中获取默认值，或者从远程配置服务中获取它们。</li><li id="84c5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr og ly lz ma bi translated">使用环境变量可以覆盖任何值:这是您的公共配置机制，必须记录下来。</li></ul><p id="4ecf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这看起来工作量很大，但幸运的是，有很多Go配置库。最著名的库之一是<a class="ae kv" href="https://github.com/spf13/viper" rel="noopener ugc nofollow" target="_blank"> Viper </a>，它很好地处理了我们的用例。</p><h1 id="1565" class="nf ng iq bd nh ni oh nk nl nm oi no np jw oj jx nr jz ok ka nt kc ol kd nv nw bi translated">实施配置</h1><p id="fd0a" class="pw-post-body-paragraph kw kx iq ky b kz nx jr lb lc ny ju le lf nz lh li lj oa ll lm ln ob lp lq lr ij bi translated">到目前为止，我们一直遵循Go应用程序的标准布局，我们的项目结构如下所示:</p><pre class="kg kh ki kj gt om of on oo aw op bi"><span id="fea2" class="oq ng iq of b gy or os l ot ou">└── cmd<br/>    └── microservice<br/>        └── main.go</span></pre><p id="a625" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有多种方法可以放置配置代码，但是我们将把它放在主包的旁边。毕竟，配置将包含整个应用程序，并可能跨越所有包。根据这一基本原理，我们的项目结构将如下所示:</p><pre class="kg kh ki kj gt om of on oo aw op bi"><span id="29d7" class="oq ng iq of b gy or os l ot ou">└── cmd<br/>    └── microservice<br/>        ├── config<br/>        │   ├── config.go<br/>        │   └── config.yml<br/>        └── main.go</span></pre><h2 id="c1d5" class="oq ng iq bd nh ov ow dn nl ox oy dp np lf oz pa nr lj pb pc nt ln pd pe nv pf bi translated">定义我们的配置模型</h2><p id="3219" class="pw-post-body-paragraph kw kx iq ky b kz nx jr lb lc ny ju le lf nz lh li lj oa ll lm ln ob lp lq lr ij bi translated">不，我们不会在这里回顾代码优先、配置优先的方法！您应该遵循的唯一规则是将配置分解成对用户有意义的块。对于我们的示例应用程序，我们只有数据库的配置数据，所以我们的配置很简单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pg ph l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">config.go</p></figure><p id="677f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经定义了配置模型，我们可以使用Viper来读取配置文件并启用环境变量覆盖机制。</p><h2 id="a21a" class="oq ng iq bd nh ov ow dn nl ox oy dp np lf oz pa nr lj pb pc nt ln pd pe nv pf bi translated">配置文件</h2><p id="5281" class="pw-post-body-paragraph kw kx iq ky b kz nx jr lb lc ny ju le lf nz lh li lj oa ll lm ln ob lp lq lr ij bi translated">Viper支持<a class="ae kv" href="https://github.com/spf13/viper#reading-config-files" rel="noopener ugc nofollow" target="_blank">很多配置文件格式</a>。在本教程中，我们将使用YAML:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pg ph l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">默认配置</p></figure><p id="4176" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，配置文件包含应用程序的所有默认值。</p><h2 id="6654" class="oq ng iq bd nh ov ow dn nl ox oy dp np lf oz pa nr lj pb pc nt ln pd pe nv pf bi translated">关于安全性的说明</h2><p id="e93b" class="pw-post-body-paragraph kw kx iq ky b kz nx jr lb lc ny ju le lf nz lh li lj oa ll lm ln ob lp lq lr ij bi translated">请注意，默认配置文件不得包含敏感数据，如密码、机密、API密钥等。相反，提供非工作默认值，这些值必须在运行时被覆盖，例如上面的“<code class="fe oc od oe of b">changeme</code>”值。</p><p id="71af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我们使用环境变量覆盖配置。虽然这对于运行本地堆栈来说很好，但具有可靠安全性的实际生产部署很可能依赖于一个秘密管理工具，例如与<a class="ae kv" href="https://kubernetes.io/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank"> Kubernetes secrets </a>结合的<a class="ae kv" href="https://www.vaultproject.io/" rel="noopener ugc nofollow" target="_blank"> Hashicorp Vault </a>。</p><h2 id="473e" class="oq ng iq bd nh ov ow dn nl ox oy dp np lf oz pa nr lj pb pc nt ln pd pe nv pf bi translated">嵌入配置文件</h2><p id="70e9" class="pw-post-body-paragraph kw kx iq ky b kz nx jr lb lc ny ju le lf nz lh li lj oa ll lm ln ob lp lq lr ij bi translated">为了嵌入我们的配置文件，我们使用了<code class="fe oc od oe of b"><a class="ae kv" href="https://pkg.go.dev/embed" rel="noopener ugc nofollow" target="_blank">//go:embed</a></code> <a class="ae kv" href="https://pkg.go.dev/embed" rel="noopener ugc nofollow" target="_blank">指令</a>。顾名思义，它允许将任何文件嵌入到go二进制文件中，并在运行时将其用作变量:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pg ph l"/></div></figure><h2 id="3e8e" class="oq ng iq bd nh ov ow dn nl ox oy dp np lf oz pa nr lj pb pc nt ln pd pe nv pf bi translated">读取配置</h2><p id="9aff" class="pw-post-body-paragraph kw kx iq ky b kz nx jr lb lc ny ju le lf nz lh li lj oa ll lm ln ob lp lq lr ij bi translated">我们现在可以使用Viper读取默认配置:</p><ol class=""><li id="6c08" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">我们启用环境变量覆盖机制，</li><li id="dfd0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们使用<code class="fe oc od oe of b">ReadConfig</code>读取配置:它将首先从嵌入式配置中读取默认值，然后用来自环境变量的值覆盖它(如果有的话)。</li><li id="3f63" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将结果解组到我们的配置模型中</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pg ph l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Viper读取配置</p></figure><h2 id="8a45" class="oq ng iq bd nh ov ow dn nl ox oy dp np lf oz pa nr lj pb pc nt ln pd pe nv pf bi translated">使用环境变量覆盖值</h2><p id="7515" class="pw-post-body-paragraph kw kx iq ky b kz nx jr lb lc ny ju le lf nz lh li lj oa ll lm ln ob lp lq lr ij bi translated">使用环境变量覆盖配置的工作原理是定义一个变量，该变量的名称是配置模型中参数的“路径”:</p><p id="7c11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">参数目标覆盖<strong class="ky ir"> →前缀参数目标覆盖</strong></p><p id="d4a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果我们想要覆盖<code class="fe oc od oe of b">postgres.password</code>值，我们定义<code class="fe oc od oe of b">APP_POSTGRES_PASSWORD</code>环境变量，因为我们已经为我们的应用程序配置了前缀<code class="fe oc od oe of b">APP</code>。</p><h1 id="e149" class="nf ng iq bd nh ni oh nk nl nm oi no np jw oj jx nr jz ok ka nt kc ol kd nv nw bi translated">包装它</h1><p id="ed73" class="pw-post-body-paragraph kw kx iq ky b kz nx jr lb lc ny ju le lf nz lh li lj oa ll lm ln ob lp lq lr ij bi translated">我们现在可以相应地更新我们的主函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pg ph l"/></div></figure><h1 id="9e1d" class="nf ng iq bd nh ni oh nk nl nm oi no np jw oj jx nr jz ok ka nt kc ol kd nv nw bi translated">下一步是什么？</h1><p id="b327" class="pw-post-body-paragraph kw kx iq ky b kz nx jr lb lc ny ju le lf nz lh li lj oa ll lm ln ob lp lq lr ij bi translated">现在我们已经实现了配置，我们将看看如何在容器中运行API服务器<a class="ae kv" href="https://medium.com/better-programming/modern-rest-api-with-go-and-postgresql-e0070aa1b383" rel="noopener">！</a></p></div></div>    
</body>
</html>