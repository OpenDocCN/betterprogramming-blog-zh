<html>
<head>
<title>Error Handling in Spring REST Services With Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Kotlin处理Spring REST服务中的错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exception-handling-done-right-58ab85c45038?source=collection_archive---------6-----------------------#2022-12-01">https://betterprogramming.pub/exception-handling-done-right-58ab85c45038?source=collection_archive---------6-----------------------#2022-12-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="38ff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">异常处理做对了！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/48d9de67dc0fb49d6f904eccd947ff46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rwIhTt9HhWrR6Ok-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@naka_mura?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">中村太极</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e840" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将展示如何在Spring web服务中实现异常处理。我们将带您浏览Spring中处理错误场景的选项，并为每个选项返回一个确定的响应。</p><p id="7668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将介绍另一种实现错误处理的基本方法，这种方法不需要Spring组件。</p><p id="e6a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始吧！</p><h1 id="ef23" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">介绍</h1><p id="5f27" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">REST服务中的错误处理一直有点争议。主要原因是可以采用不同的方法，每种方法都有自己的优点和缺点。事实上，在某些情况下，每一种观点的利弊并不完全客观，这无助于解决这些争论。</p><p id="972b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将带你通过不同的方式来处理春假服务中的错误场景，尽量做到客观。我们的目标是让您判断并决定哪种方法最适合您。</p><p id="07f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们进入处理异常的可能方法之前，让我们为我们的前几个例子设置基础。</p><p id="2e2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的前几个例子中，我们将使用一个假的<code class="fe ms mt mu mv b">CustomersRepository</code>，它使用以下接口:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="811e" class="na lw it mv b be nb nc l nd ne">interface CustomersRepository {<br/>    /**<br/>     * Creates a customer and returns the customer including the generated ID<br/>     */<br/>    fun create(customer: Customer): Customer<br/>    /**<br/>     * Finds an existing customer or returns CustomerNotFoundException<br/>     */<br/>    fun findById(id: Long): Customer<br/>}</span></pre><p id="b772" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到在这两种情况下我们是如何返回一个<code class="fe ms mt mu mv b">Customer</code>的，如果事情没有按预期进行会发生什么？我们将抛出一个异常并相应地处理它。</p><p id="2fa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要帮助来引导一个简单的Spring Boot应用程序来运行这些例子，您可以查看我们的文章<a class="ae ky" href="https://theboreddev.com/how-to-bootstrap-a-spring-boot-application/" rel="noopener ugc nofollow" target="_blank">“如何引导一个Spring Boot应用程序</a>”</p><p id="28a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始吧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/e3d112a19fe3b566e37d48dd0ffb0b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*YaqF0m3l7bn_nijY.jpg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@msohebzaidi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Soheb Zaidi </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="178c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基于控制器的异常处理</h1><p id="36ee" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在Spring中处理异常的一个最基本的选项是在控制器级别使用<code class="fe ms mt mu mv b">@ExceptionHandler</code>注释。</p><p id="2b98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何做到这一点？我们来看一个有两个基本端点的<code class="fe ms mt mu mv b">CustomerController</code>。我们将添加一个方法来处理没有找到客户的情况。它看起来像这样:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="1fa5" class="na lw it mv b be nb nc l nd ne">@RestController<br/>@RequestMapping("/api/customers")<br/>class CustomerController(@Autowired val repository: CustomersRepository) {<br/>    @PostMapping<br/>    fun createCustomer(@RequestBody customer: Customer, uriBuilder: UriComponentsBuilder): ResponseEntity&lt;String&gt; {<br/>        val result = repository.create(customer)<br/>        return ResponseEntity<br/>           .created(uriBuilder.path("/api/customers/{id})").buildAndExpand(result.id).toUri())<br/>            .build()<br/>    }<br/>    @GetMapping("/{id}")<br/>    fun findCustomer(@PathVariable("id") id: Long): ResponseEntity&lt;Customer&gt; {<br/>        val result = repository.findById(id)<br/>        return ResponseEntity.ok(result)<br/>    }<br/>    @ExceptionHandler(CustomerNotFound::class)<br/>    fun customerNotFound(exception: CustomerNotFound): ResponseEntity&lt;String&gt; {<br/>        return ResponseEntity.notFound().build()<br/>    }<br/>}</span></pre><p id="c52b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，如果客户不在我们的数据库中，我们的存储库将返回<code class="fe ms mt mu mv b">CustomerNotFound</code>异常。该异常先前已经以这种方式声明:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="7777" class="na lw it mv b be nb nc l nd ne">data class CustomerNotFound(override val message: String? = null, val id: Long): Exception(message)</span></pre><p id="d7c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在应用程序冒泡时处理这个异常，我们必须在控制器中定义一个处理程序。我们通过使用<code class="fe ms mt mu mv b">@ExceptionHandler</code>注释来做到这一点。</p><p id="569f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<code class="fe ms mt mu mv b">@ExceptionHandler</code>，我们将自定义响应映射到给定的异常。在这种情况下，给出的异常是<code class="fe ms mt mu mv b">CustomerNotFound</code>。</p><p id="8a65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有另一种方法可以做类似的事情。这是通过使用<code class="fe ms mt mu mv b">@ResponseStatus</code>注释。</p><p id="d5c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">@ResponseStatus</code>注释将我们的响应映射到相应的状态代码，所以在我们的例子中，它相当于返回<code class="fe ms mt mu mv b">ResponseEntity.notFound()</code>。</p><p id="5db8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们的异常处理程序方法会略有不同:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="651b" class="na lw it mv b be nb nc l nd ne">@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = "Customer could not be found!")<br/>@ExceptionHandler(CustomerNotFound::class)<br/>fun customerNotFound(exception: CustomerNotFound) {}</span></pre><p id="6fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的一些优点是，就可读性或可维护性而言，很容易发现在当前控制器中如何处理异常，以及当异常发生时配置的响应。这也是在我们的代码中定义异常处理的简洁方法。</p><p id="ba7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，使用基于控制器的异常处理不允许重用这些处理程序，甚至不允许配置应用于所有控制器的全局异常处理程序。</p><p id="d746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看另一个选项。</p><h1 id="0b94" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用@ControllerAdvice</h1><p id="03db" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">定义异常处理程序的另一种方式是使用<code class="fe ms mt mu mv b">@ControllerAdvice</code>注释。这将允许我们在应用程序中定义全局异常处理。让我们看看它会是什么样子:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="704c" class="na lw it mv b be nb nc l nd ne">@ControllerAdvice<br/>class GlobalExceptionHandler {<br/>    @ResponseStatus(value = HttpStatus.NOT_FOUND, reason = "Customer could not be found!")<br/>    @ExceptionHandler(CustomerNotFound::class)<br/>    fun customerNotFound(exception: CustomerNotFound) {}<br/>}</span></pre><p id="3a88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们尝试使用curl获取一个不存在的客户，我们也会得到一个404，就像我们看到基于控制器的异常处理时一样。</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="9dc2" class="na lw it mv b be nb nc l nd ne">curl -v http://localhost:8080/api/customers/23                                                                                                                                                                                      <br/>*   Trying 127.0.0.1:8080...<br/>* Connected to localhost (127.0.0.1) port 8080 (#0)<br/>&gt; GET /api/customers/23 HTTP/1.1<br/>&gt; Host: localhost:8080<br/>&gt; User-Agent: curl/7.79.1<br/>&gt; Accept: */*<br/>&gt;<br/>* Mark bundle as not supporting multiuse<br/>&lt; HTTP/1.1 404<br/>&lt; Content-Type: application/json<br/>&lt; Transfer-Encoding: chunked<br/>&lt; Date: Tue, 29 Nov 2022 07:23:16 GMT<br/>&lt;<br/>{"timestamp":"2022-11-29T07:23:16.265+00:00","status":404,"error":"Not Found","trace":"CustomerNotFound(message=Could not find customer 23, id=23)<br/>...</span></pre><p id="ca96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能是Spring Boot定义异常处理最常用的方法。它的主要优点是我们不必在每个控制器中定义一个异常处理程序。我们必须在代码中定义一次，每个控制器都会重用它。</p><p id="7483" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，主要的缺点是，为了能够知道应用程序在哪里配置异常处理，我们需要很好地理解Spring，并且我们必须搜索<code class="fe ms mt mu mv b">@ControllerAdvice</code>来找到它被配置的位置。因此，就可读性而言，对于不熟悉代码或Spring的人来说，这种方法并不是最好的。</p><p id="1dc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一件事我们之前没有提到，那就是Spring如何在内部处理这两种方法。如果我们查看我们的日志，我们将能够看到类似这样的内容:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="e33b" class="na lw it mv b be nb nc l nd ne">2022-11-29 07:29:56.196  WARN 36520 --- [nio-8080-exec-2] .m.m.a.ExceptionHandlerExceptionResolver : Resolved [CustomerNotFound(message=Could not find customer 123, id=123)]</span></pre><p id="906e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，Spring调用<code class="fe ms mt mu mv b">ExceptionHandlerExceptionResolver</code>来解决配置的异常。让我们多了解一下这个组件。</p><h1 id="4362" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">ExceptionHandlerExceptionResolver</h1><p id="c796" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">该组件负责解决通过<code class="fe ms mt mu mv b">@ExceptionHandler</code>注释定义的所有异常。因此，它是Spring异常处理中非常重要的组件！</p><p id="285e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个组件也是从另一个已知组件<code class="fe ms mt mu mv b"><a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/handler/AbstractHandlerMethodExceptionResolver.html" rel="noopener ugc nofollow" target="_blank">AbstractHandlerMethodExceptionResolver</a></code>扩展而来的。该组件从<code class="fe ms mt mu mv b"><a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/HandlerExceptionResolver.html" rel="noopener ugc nofollow" target="_blank">HandlerExceptionResolver</a></code>接口扩展而来，这允许我们定义自己的自定义异常解析器。</p><p id="441c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法不常用，因为现在有更好的方法。然而，如果你仍然想看一个实现定制异常解析器的例子，你可以在这里找到它。</p><p id="e454" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经看到了Spring提供的处理异常的主要方法，但是还有其他方法吗？我们认为还有一种方式，像往常一样，有利有弊。让我们看看如何！</p><h1 id="1931" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用单子的自定义方式</h1><p id="0e43" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一些观点认为春天“太神奇了”因此，我们不知道在我们的应用程序中到底发生了什么。对于站在这一边的人，我们还有一个提议。开始吧！</p><h2 id="4f38" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">引入基于控制器的处理</h2><p id="2c5c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们要做的第一件事是改变我们的<code class="fe ms mt mu mv b">CustomerRepository</code>接口，返回一个<code class="fe ms mt mu mv b">Either</code>单子。</p><p id="da80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中我们也可以使用Arrow，但是我们决定为这个例子创建一个自定义的<code class="fe ms mt mu mv b">Either</code>类。看起来是这样的:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="4786" class="na lw it mv b be nb nc l nd ne">sealed class Either&lt;F, S&gt; {<br/>    <br/>    data class Success&lt;F, S&gt;(private val s: S) : Either&lt;F, S&gt;() {<br/>        fun entity(): S = s<br/>    }<br/>    data class Failure&lt;F, S&gt;(private val f: F) : Either&lt;F, S&gt;() {<br/>        fun exception(): F = f<br/>    }<br/>}<br/>fun &lt;E&gt; E.failure() = Either.Failure&lt;E, Nothing&gt;(this)<br/>fun &lt;T&gt; T.success() = Either.Success&lt;Nothing, T&gt;(this)</span></pre><p id="6e53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，这很简单。我们将通过一个例子来看看如何使用它。</p><p id="9f4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将修改一个定制的<code class="fe ms mt mu mv b">InMemoryCustomerRepository</code>实现来使用我们的<code class="fe ms mt mu mv b">Either</code>类。</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="4a7b" class="na lw it mv b be nb nc l nd ne">@Component("inMemoryCostumersRepository")<br/>class InMemoryCustomerRepository(val configuration: DatabaseConfiguration): CustomersRepository {<br/>    private val customers = mutableMapOf&lt;Long, Customer&gt;()<br/>    override fun create(customer: Customer): Either&lt;Exception, Customer&gt; {<br/>        val created = customer.copy(id = customers.keys.size.toLong())<br/>        customers[created.id!!] = created<br/>        return created.success() as Either&lt;Exception, Customer&gt;<br/>    }<br/>    override fun findById(id: Long): Either&lt;Exception, Customer&gt; {<br/>        return ((<br/>                customers[id]?.success() ?: <br/>                    CustomerNotFound("Could not found customer $id", id).failure()<br/>                ) as Either&lt;Exception, Customer&gt;)<br/>    }<br/>}</span></pre><p id="d745" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将替换任何负责异常处理的基于Spring的配置，并自己定义响应。让我们看看在我们的控制器中应用这些更改后会是什么样子:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="37f3" class="na lw it mv b be nb nc l nd ne">@RestController<br/>@RequestMapping("/api/customers")<br/>class CustomerController(@Autowired val repository: CustomersRepository) {<br/>    @PostMapping<br/>    fun createCustomer(@RequestBody customer: Customer, uriBuilder: UriComponentsBuilder): ResponseEntity&lt;String&gt; {<br/>        return when (val result = repository.create(customer)) {<br/>            is Either.Success -&gt; {<br/>                ResponseEntity<br/>                    .created(uriBuilder<br/>                        .path("/api/customers/{id})")<br/>                        .buildAndExpand(result.entity().id)<br/>                        .toUri()<br/>                    ).build()<br/>            }<br/>            is Either.Failure -&gt; {<br/>                ResponseEntity.internalServerError().build()<br/>            }<br/>        }<br/>    }<br/>    @GetMapping("/{id}")<br/>    fun findCustomer(@PathVariable("id") id: Long): ResponseEntity&lt;Customer&gt; {<br/>        return when (val result = repository.findById(id)) {<br/>            is Either.Success -&gt; ResponseEntity.ok(result.entity())<br/>            is Either.Failure -&gt; {<br/>                when (result.exception()) {<br/>                    is CustomerNotFound -&gt; ResponseEntity.notFound().build()<br/>                    else -&gt; ResponseEntity.internalServerError().build()<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="8188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的主要好处是我们不依赖于冒泡异常。异常处理在我们的代码中，所以我们可以很容易地阅读和理解它的行为。</p><p id="94a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们前面看到的Spring中基于控制器的异常处理，这种方法也有同样的缺点，我们不能在所有的控制器中重用它，我们必须在每个端点中定义它。我们能做些什么来解决这个问题吗？我们试试吧！</p><h2 id="05c2" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">全局异常处理，使用</h2><p id="4bf8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将尝试修改我们的<code class="fe ms mt mu mv b">Either</code>类，使其可用于“全局”异常处理。目标是为我们的响应提供一个“默认”配置，但同时，我们可以在控制器级别覆盖行为。</p><p id="0244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">产生的<code class="fe ms mt mu mv b">Either</code>类将如下所示:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="c5ea" class="na lw it mv b be nb nc l nd ne">sealed class Either&lt;F: Exception, S: Any&gt; {<br/>    protected var successHandler: (Success&lt;F, S&gt;) -&gt; ResponseEntity&lt;S&gt; = { <br/>            e -&gt; ResponseEntity.ok(e.entity()) <br/>    }<br/>    protected var errorHandler: (Failure&lt;F, S&gt;) -&gt; ResponseEntity&lt;F&gt; = { <br/>            e-&gt; ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(e.exception())<br/>    }<br/>    data class Success&lt;F: Exception, S: Any&gt;(private val s: S) : Either&lt;F, S&gt;() {<br/>        fun entity(): S = s<br/>        override fun response(): ResponseEntity&lt;S&gt; = this.successHandler.invoke(this)<br/>    }<br/>    data class Failure&lt;F: Exception, S: Any&gt;(private val f: F) : Either&lt;F, S&gt;() {<br/>        fun exception(): F = f<br/>        override fun response(): ResponseEntity&lt;F&gt; = this.errorHandler.invoke(this)<br/>    }<br/>    abstract fun response(): ResponseEntity&lt;out Any&gt;<br/>    fun onFailureDo(action: (e: Failure&lt;F, S&gt;) -&gt; ResponseEntity&lt;F&gt;): Either&lt;F, S&gt; {<br/>        this.errorHandler = action<br/>        return this<br/>    }<br/>    fun onSuccessDo(action: (e: Success&lt;F, S&gt;) -&gt; ResponseEntity&lt;S&gt;): Either&lt;F, S&gt; {<br/>        this.successHandler = action<br/>        return this<br/>    }<br/>}<br/>fun &lt;E: Exception&gt; E.failure() = Either.Failure&lt;E, Nothing&gt;(this)<br/>fun &lt;T : Any&gt; T.success() = Either.Success&lt;Nothing, T&gt;(this)</span></pre><p id="7bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的新实现中，有几件事情需要强调。我们将一步一步地看它们，让你更容易理解。</p><p id="9671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先要注意的是，我们现在提供了一个<code class="fe ms mt mu mv b">response</code>方法，能够将我们的<code class="fe ms mt mu mv b">Either</code>类转换成一个Spring <code class="fe ms mt mu mv b">ResponseEntity</code>对象。</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="1fed" class="na lw it mv b be nb nc l nd ne">abstract fun response(): ResponseEntity&lt;out Any&gt;</span></pre><p id="fe66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个<code class="fe ms mt mu mv b">Either</code>子类<code class="fe ms mt mu mv b">Success</code>和<code class="fe ms mt mu mv b">Failure</code>都将覆盖这个方法，将我们的方法映射到相应的HTTP响应，包括状态代码和是否有主体。</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="d942" class="na lw it mv b be nb nc l nd ne">data class Success&lt;F: Exception, S: Any&gt;(private val s: S) : Either&lt;F, S&gt;() {<br/>    fun entity(): S = s<br/>        override fun response(): ResponseEntity&lt;S&gt; = this.successHandler.invoke(this)<br/>    }<br/>    data class Failure&lt;F: Exception, S: Any&gt;(private val f: F) : Either&lt;F, S&gt;() {<br/>        fun exception(): F = f<br/>        override fun response(): ResponseEntity&lt;F&gt; = this.errorHandler.invoke(this)<br/>    }</span></pre><p id="2659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在会注意到这两个类调用了两个不同的处理程序，而不是直接返回一个<code class="fe ms mt mu mv b">ResponseEntity</code>对象。这是为什么呢？嗯，我们决定这样做是为了能够提供一个默认响应，但也允许在我们的控制器中覆盖默认响应。</p><p id="3262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可能想知道，默认配置是什么？</p><p id="ffef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用默认配置初始化<code class="fe ms mt mu mv b">successHandler</code>和<code class="fe ms mt mu mv b">errorHandler</code>，如下所示:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="f7ec" class="na lw it mv b be nb nc l nd ne">protected var successHandler: (Success&lt;F, S&gt;) -&gt; ResponseEntity&lt;S&gt; = {<br/>     e -&gt; ResponseEntity.ok(e.entity())<br/>}<br/>protected var errorHandler: (Failure&lt;F, S&gt;) -&gt; ResponseEntity&lt;F&gt; = {<br/>     e-&gt; ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(e.exception())<br/>}</span></pre><p id="d034" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，任何成功的响应都将被转换为200 (OK)响应，包括主体中的实体(如果存在的话)。另一方面，任何失败都将被默认转换为500(服务器错误)响应，包括主体中的异常。</p><p id="8de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是一个简单的例子。你自己决定万一失败要在正文中包含什么。例如，您可以将消息包含在异常中。</p><p id="7e21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经了解了默认行为是如何设置的，那么我们如何在特定的情况下覆盖这种行为呢？为此，我们提供了以下两种方法:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="74fb" class="na lw it mv b be nb nc l nd ne">fun onFailureDo(action: (e: Failure&lt;F, S&gt;) -&gt; ResponseEntity&lt;F&gt;): Either&lt;F, S&gt; {<br/>  this.errorHandler = action<br/>  return this<br/>}<br/>fun onSuccessDo(action: (e: Success&lt;F, S&gt;) -&gt; ResponseEntity&lt;S&gt;): Either&lt;F, S&gt; {<br/>  this.successHandler = action<br/>  return this<br/>}</span></pre><p id="d33d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到这些方法是如何接受一个接收<code class="fe ms mt mu mv b">Either.Success</code>或<code class="fe ms mt mu mv b">Either.Failure</code>的函数，并返回一个带有相应失败或成功类型的<code class="fe ms mt mu mv b">ResponseEntity</code>对象的。</p><p id="d587" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何利用所有这些呢？整合后，让我们看看我们的新<code class="fe ms mt mu mv b">CustomerController</code>:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="ef83" class="na lw it mv b be nb nc l nd ne">@RestController<br/>@RequestMapping("/api/customers")<br/>class CustomerController(@Autowired val repository: CustomersRepository) {<br/>    @PostMapping<br/>    fun createCustomer(@RequestBody customer: Customer, uri: UriComponentsBuilder): ResponseEntity&lt;String&gt; {<br/>        return repository.create(customer)<br/>            .onSuccessDo { e -&gt;<br/>                ResponseEntity<br/>                    .created(uri<br/>                        .path("/api/customers/{id})")<br/>                        .buildAndExpand(e.entity().id)<br/>                        .toUri()<br/>                    ).build()<br/>            }.response() as ResponseEntity&lt;String&gt;<br/>    }<br/>    @GetMapping("/{id}")<br/>    fun findCustomer(@PathVariable("id") id: Long): ResponseEntity&lt;Customer&gt; {<br/>        return repository.findById(id)<br/>            .onFailureDo { e -&gt;<br/>                when (e.exception()) {<br/>                    is CustomerNotFound -&gt; ResponseEntity.notFound().build()<br/>                    else -&gt; ResponseEntity.internalServerError().build()<br/>                }<br/>            }.response() as ResponseEntity&lt;Customer&gt;<br/>    }<br/>}</span></pre><p id="89c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到我们的控制器现在如何使用默认配置来处理<code class="fe ms mt mu mv b">createCustomer</code>方法中的失败和<code class="fe ms mt mu mv b">findCustomer</code>方法中的成功。例如，<code class="fe ms mt mu mv b">findCustomer</code>将返回一个200 (OK)响应，并将客户包含在JSON主体中。</p><p id="4774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们覆盖了在<code class="fe ms mt mu mv b">createCustomer</code>方法中成功的行为和在<code class="fe ms mt mu mv b">findCustomer</code>方法中失败的行为。这是为什么呢？在我们的例子中，成功创建一个客户意味着返回201 (CREATED)和一个<code class="fe ms mt mu mv b">Location</code>头，正如我们在本文前面看到的。我们还需要对<code class="fe ms mt mu mv b">findCustomer</code>中的故障采取不同的行为，以便能够正确处理<code class="fe ms mt mu mv b">CustomerNotFound</code>。</p><p id="956e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好，对吧？这种方法的主要优点是，我们现在能够为异常处理提供全局配置，同时能够容易地阅读和理解在我们的代码中如何配置异常处理，而不涉及Spring“魔法”！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/c70cbce066715ebadf1e37e1d6b1a176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*Re1MQehqTCEsPGji.jpg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/photos/PUvPZckRnOg" rel="noopener ugc nofollow" target="_blank"> Aziz Acharki在Unsplash上拍摄</a></p></figure><p id="1d00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢我们的解决方案，并且对Java版本感兴趣，你可以在这里查看我们的文章和Java示例。</p><h1 id="795e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="36bc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，我们看到了在Spring Boot应用程序中处理异常的不同方法。正如我们之前所说的，异常处理是一个非常有争议的话题，因为对于什么方法在我们的应用程序中最有效有不同的意见。希望我们已经能够对这个话题提出一个客观公正的观点，现在你可以用它来做出你自己的假设，并在你的项目中做出正确的决定。</p><p id="0799" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们今天的全部内容！我们真的希望你喜欢这篇文章，就像我们喜欢写它一样！</p><p id="1ea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">期待很快再次见到您！</p><p id="1fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>