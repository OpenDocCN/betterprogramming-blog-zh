<html>
<head>
<title>How To Build a Secure Login Flow With OAuth 2, OpenId, and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用OAuth 2、OpenId和React构建一个安全的登录流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-secure-login-flow-with-oauth-2-openid-in-react-apps-ce6e8e29630a?source=collection_archive---------0-----------------------#2019-10-31">https://betterprogramming.pub/building-secure-login-flow-with-oauth-2-openid-in-react-apps-ce6e8e29630a?source=collection_archive---------0-----------------------#2019-10-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b60b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让你的应用有一个最好的起点，一个安全的起点</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f9bc6db3403e01f45bb5fe2488dc6edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wkSViHJC9zZUMV4uyYNfxQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔恩·摩尔在Unsplash<a class="ae ky" href="https://unsplash.com/s/photos/security?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">上的照片</a></p></figure><p id="e61b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您是否知道，大约80%的数据泄露都是由于错误的密码选择(如“密码”)造成的？你知道超过2300万人使用密码“123456”吗？</p><p id="55d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个数字时代，个人数据非常重要，大多数国家都制定了严格的法律，作为开发者，我们有责任保护我们的网关，这一点非常重要。</p><p id="3b69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，换句话说，我们构建的应用程序充当了访问或操纵敏感数据的渠道。作为前端开发人员，我们构建界面来创造愉快的用户体验，使读取和操作数据库中存储的数据变得容易。</p><p id="74d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在任何web应用程序中，根据权限识别正确的人并对界面部分进行正确的访问是至关重要的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d2ba" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">动机</h1><p id="557a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">互联网上有许多分散的信息，可用于了解<a class="ae ky" href="https://oauth.net/" rel="noopener ugc nofollow" target="_blank"> OAuth </a>、什么是<a class="ae ky" href="https://openid.net/" rel="noopener ugc nofollow" target="_blank"> OpenID </a> connect，以及如何在我们现代的水疗应用基础设施中使用它们。</p><p id="d61e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现的大部分指南都完全依赖于相应的客户端库。例如，使用JS SDK进行<a class="ae ky" href="https://azure.microsoft.com/en-us/" rel="noopener ugc nofollow" target="_blank"> Microsoft Azure </a>登录会增加71KB( 18KB gzipped)的包大小。</p><p id="da54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他库也是如此，比如脸书SDK JS和谷歌的<code class="fe mz na nb nc b">gapi</code>。</p><p id="c462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们被要求在我们的web应用程序中添加Google或FB登录按钮时，在寻找解决方案时，我们倾向于找到一个框架兼容的包装器来为我们实现这一奇迹，甚至不需要费心去理解该库在内部做什么。</p><p id="ea36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只是简单地寻找如何快速集成它的指南或教程，而不考虑选择一种策略的安全影响。例如，我们检索访问令牌，并在不知情或有意的情况下获得对用户个人信息的访问。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/4095172f316447313f2852f315630c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vq3bCuHnXSA6XgHdYhaKwA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">OAuth中的同意屏幕要求所有联系人同意</p></figure><p id="26ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到这个，<a class="ae ky" href="https://www.netmeds.com/" rel="noopener ugc nofollow" target="_blank">医药配送app net meds</a>请求访问用户所有邮箱联系人的权限，为了什么？而且，可悲的是，容易上当受骗的人甚至不会在匆忙登录订购药品的应用程序时注意到这些事情！</p><p id="3bac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上案例是在用户端。在开发人员方面，我们都倾向于获取访问令牌，即使我们只需要识别用户信息，如电子邮件ID和基本配置文件信息，然后我们将访问令牌存储在localstorage中，并在每个请求的请求标头中发送它。</p><p id="95df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在客户端存储中存储访问令牌容易受到脚本注入攻击。</p><p id="47a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我相信你可能在开发时遇到过这样的情况，你要求你的同事与你分享他们的访问令牌来登录应用程序。</p><p id="f626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何拥有您的访问令牌的人都可以冒充您并代表您执行操作，这实际上违反了信息安全的<a class="ae ky" href="https://whatis.techtarget.com/definition/Confidentiality-integrity-and-availability-CIA" rel="noopener ugc nofollow" target="_blank"> CIA三元模型</a>的<em class="ne"> C(保密性)</em>原则，该原则规定只有正确的人才能访问资源，任何人都不能冒充任何其他用户。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/aa8538fa670ae261e7383183f1084d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ti4bRAzIfkKYhOSkFrUnzw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">中情局三合会安全模式</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6b48" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">议程</h1><p id="b39e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将讨论:</p><ul class=""><li id="f9b1" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">身份验证与授权。</li><li id="fa7e" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">OAuth 2.0及其流程。</li><li id="1b69" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">在具有弹出和重定向UX的React应用中使用OpenID实现授权代码授权流。</li><li id="470d" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">使用<a class="ae ky" href="https://koajs.com/" rel="noopener ugc nofollow" target="_blank"> Koa </a>在Node.js服务器上实现OAuth流。</li><li id="daa4" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://webauthn.io/" rel="noopener ugc nofollow" target="_blank"> WebAuthn </a>。</li></ul><p id="9648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在整个讨论中，我们不会使用任何第三方库来完全理解这些概念。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="86cc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">身份验证与授权</h1><p id="361d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="ne">认证</em> <strong class="lb iu"> </strong>意味着我们只想识别试图登录应用程序的用户。这是一种识别用户的方式，以确保他们是他们所声称的人。</p><p id="ad0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个简单的例子是用户名/密码。天真的假设是所有用户名和密码都是唯一的。如果一个人有这些东西，就可以自称是某个人。</p><p id="5538" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今，我们有两个或多个身份认证系统，它们有点烦人，但是对保护你的身份非常重要。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/9dedd9093a6e70e2149c9e0a328c4adf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NFzl8lM1zsC8u4J8hrBSCQ.jpeg"/></div></div></figure><p id="6e36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ne">另一方面，授权</em>是一种“授权”登录用户访问受保护资源的方式。授权过程通常在认证之后。</p><p id="d539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个例子是API键，通过它可以访问开发人员的REST API。或者，简单地用一个Google访问令牌来访问Google资源，比如Google Drive。</p><p id="442a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你在认证过程中获得了令牌，任何拥有它的人都可以访问你的Google Drive，直到它过期。</p><p id="9011" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">授权的一个很好的类比是电影票，尤其是在过去。</p><p id="4a13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何有票的人都可以进入电影院。人们可以把它卖给其他人，因为在这里购买它的人的身份并不重要。</p><p id="f252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，音乐会门票或通行证可以很容易地卖给其他人，因为它们只用于检查进入场地的授权。</p><p id="f133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，认证<strong class="lb iu"> </strong>就像向警察出示你的驾驶执照来确认你的身份，即你实际上就是你所声称的那个人。</p><p id="604d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">警察将通过检查你的信息来核实你的身份，如生物特征和你的照片，如果他们怀疑这些事情，他们可以提问。</p><p id="f8c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，当通过Google OAuth登录时，Google是机场外的警察，它试图通过检查您的用户名和密码以及MFA(多因素身份验证)等其他因素来识别您的身份。</p><p id="f597" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你用上述方法证明你的身份时，cop会给你一个“访问令牌”，比如说，一个进入机场的虚拟通行证，以访问各种机场资源。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dad5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">OAuth 2.0和OpenID</h1><p id="3c22" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这两者相辅相成。OpenID是用于认证的协议，而OAuth是用于授权的协议。</p><ul class=""><li id="eb86" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">OpenID是一个开放的标准和分散的认证协议，由OpenID基金会控制。</li><li id="5ebc" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">OAuth是访问授权的开放标准。</li><li id="4213" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://openid.net/connect/" rel="noopener ugc nofollow" target="_blank"> OpenID Connect (OIDC) </a>结合了OpenID和OAuth的特性，即它既做认证又做授权。</li></ul><p id="bed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">OIDC使用简单的JSON Web令牌(JWT)，您可以使用符合OAuth 2.0规范的流获得它。OAuth与OIDC直接相关，因为OIDC是建立在OAuth 2.0之上的认证层。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/af4a10a1dfa3c7974c4186f71764811a.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/0*9xZTAdU2IqOKSUpg.jpg"/></div></figure><p id="2daf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Google和其他提供商实现了OpenID和OAuth规范。因此，我们可以同时对用户进行身份验证和授权。</p><p id="d5f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果你选择使用谷歌账户登录<a class="ae ky" href="https://auth0.com/" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>，那么你使用的是OIDC。</p><p id="f274" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦您成功通过Google认证并授权Auth0访问您的信息，Google将向Auth0发回有关用户和所执行认证的信息。</p><p id="0632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该信息在JSON Web令牌(JWT)中返回。您将收到一个访问令牌，如果需要，还会收到一个ID令牌。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="22b8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">OAuth 2.0流程</h1><p id="6f50" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用OIDC实现认证和授权有各种流程。下面是两个主要的例子:</p><h2 id="8b5d" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">1.隐式授权流</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/896c7fe21072ad5eae6d4ca739ff7861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*ZYjN5ONBtCqc6wAnkDwmQQ.png"/></div></figure><p id="2678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是最简单的流程。它可以总结为以下步骤:</p><ol class=""><li id="260a" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu oj nm nn no bi translated">用户从您的web应用程序中点击“使用FB登录”按钮。用户要么被提示一个对话框，要么被重定向到FB的登录屏幕。</li><li id="4f2b" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu oj nm nn no bi translated">认证服务提供者(在这种情况下是FB)接受用户输入，如用户名、密码或MFA等。</li><li id="80de" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu oj nm nn no bi translated">在用户被成功识别之后，授权服务提供者发出一个<code class="fe mz na nb nc b">id_token</code>或<code class="fe mz na nb nc b">access_token</code>。</li><li id="ec71" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu oj nm nn no bi translated">FB使用查询参数中的令牌集或URL中的哈希片段将用户重定向回您的应用程序。</li><li id="11c7" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu oj nm nn no bi translated">该应用程序从URL获取令牌，或者解码JWT <code class="fe mz na nb nc b">id_token</code>以获取用户ID，或者使用访问令牌通过脸书的<a class="ae ky" href="https://developers.facebook.com/docs/graph-api/" rel="noopener ugc nofollow" target="_blank">图形API </a>获取更多用户信息。</li></ol><p id="93a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以Google为例，来自客户端的请求URL如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/bbe27418020ebafc3259ca533e247242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KjsCpU8PLnPmmCv1rHpgSA.png"/></div></div></figure><p id="7f52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个<code class="fe mz na nb nc b">GET</code>调用，这个URL需要直接在浏览器中打开(而不是通过AJAX，因为谷歌不支持CORS)。</p><p id="8989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">URL可以在另一个窗口中一起打开，并通过<code class="fe mz na nb nc b">postmessage</code>与一个打开窗口进行通信，也可以在加载应用程序的同一个窗口中打开，这都取决于您想要遵循的用户体验。</p><p id="1247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的<code class="fe mz na nb nc b">scope</code> <strong class="lb iu"> </strong>参数告诉我们同意需要用户做哪些事情。例如:要管理所有Google日历事件，可以添加<a class="ae ky" href="https://www.googleapis.com/auth/calendar" rel="noopener ugc nofollow" target="_blank"><em class="ne">【https://www.googleapis.com/auth/calendar】</em></a><em class="ne"/>作为该范围的值。</p><p id="8145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">redirect_uri</code> : <strong class="lb iu"> </strong>由于我们将把我们的应用程序让给谷歌，谷歌或任何OAuth提供商需要知道在用户登录并证明他们的身份后重定向回哪里。</p><p id="a39b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，给出一个有效的<code class="fe mz na nb nc b">redirect_uri</code>对于捕获作为查询参数或散列片段附加在同一个<code class="fe mz na nb nc b">redirect_uri</code>中的标记是必要的。</p><p id="d095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">response_type</code> <strong class="lb iu"> </strong>必须是<code class="fe mz na nb nc b">token</code>来表示我们想直接从<code class="fe mz na nb nc b">redirect_uri</code>中获取访问令牌。这与授权码授予流程形成对比，后者涉及更多步骤。</p><p id="3f7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">client_id</code> <strong class="lb iu"> </strong>是你在谷歌开发者<a class="ae ky" href="https://console.developers.google.com/" rel="noopener ugc nofollow" target="_blank">控制台</a>为你的应用注册后得到的ID。</p><p id="e634" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个流程很适合<em class="ne">无服务器</em><strong class="lb iu"/>spa。这有点不太安全，因为我们在客户端公开了访问令牌，这可能会被各种手段攻击。</p><h2 id="e294" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">2.授权码授权流</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/fb9e31e9becfb172d384986fc9efc002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvxGc7stJ1N9dAOtw7soDg.png"/></div></div></figure><p id="81d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，以同样的方式，用户点击登录按钮，Google验证用户，最后在<code class="fe mz na nb nc b">redirect_uri</code>中发送一个<code class="fe mz na nb nc b">code</code> <strong class="lb iu"> </strong>，与我们之前看到的隐式授权流中的<code class="fe mz na nb nc b">token</code> <strong class="lb iu"> </strong>形成对比。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/f4999a714addbea8b239ead961952ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T84IRMqCTrKFipit0V3Xcw.png"/></div></div></figure><p id="4d31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从URL中检索到代码后，在服务器端将其交换为访问令牌。您不能在客户端直接进行POST AJAX调用，因为这会导致CORS错误。</p><p id="c264" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，对服务器进行代理调用，服务器将在内部进行交换调用以获取访问令牌。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/28a23c05358d49544475d82b8a58d33b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iewO5dQRpDl693o4UA3PXw.png"/></div></div></figure><p id="a0ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法更安全，因为被窃取的代码不会有任何问题，因为它是访问用户资源的重要访问令牌。</p><p id="501b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，为了进行交换调用以获得访问令牌，需要在API调用有效负载中发送<code class="fe mz na nb nc b">client_secret</code>密钥，该密钥安全地保存在服务器端。</p><p id="3827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，这是将OAuth安全集成到您的应用程序中的推荐方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6ad6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实施授权码授予流程-前端</h1><p id="407b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我们需要为<code class="fe mz na nb nc b">redirect_uri</code> <strong class="lb iu"> </strong>创建路由处理程序，并将其注册到OAuth提供者，例如Google、FB或Twitter的开发控制台上。应用程序或路线组件如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/fdaa4b89f369f8d21d86addf9d382375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6de_NWzN0-y4lyegYdOmw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">登录路线用户界面</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/3bcc93bf88b7bf0cb5ce44253e05c4f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bW6z8qhoUBvPJCe9hgcO6w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">向Google注册应用程序时提供重定向UI</p></figure><p id="2630" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注册重定向URI很重要，因为否则，注册过程会出错<code class="fe mz na nb nc b">Invalid Redirect URI</code>。出于开发目的，添加本地主机URL。</p><h2 id="fe9d" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">重定向UX</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="a713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们正在进行一个AJAX调用，只是为了获取auth URL以获取授权代码，最终，就像步骤1中一样。</p><p id="3f3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在这里马上构造它，这样做是为了隐藏配置密钥和其他细节，比如客户端的秘密。此外，将构造URL的责任委托给服务器端也是一个好主意。</p><p id="5bdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当从服务器以纯文本的形式收到成功的响应时，它被解析并作为URL分配给当前窗口。这是正常且容易的重定向流程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/f4999a714addbea8b239ead961952ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T84IRMqCTrKFipit0V3Xcw.png"/></div></div></figure><p id="b6b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从该URL成功登录后，Google将重定向到通过<code class="fe mz na nb nc b">code</code> <strong class="lb iu"> </strong>参数传递的<code class="fe mz na nb nc b">redirect_uri</code>，该参数在URL的查询参数中传递，如下所示。</p><pre class="kj kk kl km gt or nc os ot aw ou bi"><span id="3087" class="nw md it nc b gy ov ow l ox oy"><a class="ae ky" href="http://localhost:3000/oauth_callback?state=google&amp;code=4%2FsgHS6bYbqptNXQm3q5hEm3zDPv4pD7WxWuiH2um3-OW1LnLZL7uR4y2kV6RoOK5M4PgkA-7PoVvCszkc1OCt31k&amp;scope=email+profile+openid+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.profile+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email&amp;authuser=0&amp;session_state=a69a895ce6443dc3eee7a14197edb0b8b3d81007..a755&amp;prompt=consent#" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/oauth_callback?<br/><strong class="nc iu">state</strong>=google&amp;<br/><strong class="nc iu">code</strong>=4/sgHS6bYbqptNXQm3q5hEm3zDPv4pD7WxWuiH2um3&amp;<br/><strong class="nc iu">scope</strong>=email profile openid&amp;<br/><strong class="nc iu">authuser</strong>=0&amp;<br/><strong class="nc iu">session_state</strong>=a69a895ce6443dc3eee7a14197edb0b8b3d81007..a755&amp;<br/><strong class="nc iu">prompt</strong>=consent</a></span></pre><p id="98b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe mz na nb nc b">state</code> <strong class="lb iu"> </strong>参数被传递并被重定向以恢复应用程序流。</p><p id="1523" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想在登录后恢复应用程序的状态，这是很有用的，因为当OAuth屏幕打开时，整个应用程序都会卸载，您可能需要将用户重定向到他们试图登录的正确的受保护URL。</p><p id="d9db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个用例，在我们的例子中，我们有多个OAuth提供者，如Google和Azure，我们需要在重定向后知道这些代码属于谁，属于哪个提供者，这样我们就可以调用适当的令牌交换调用。</p><p id="ad0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是<code class="fe mz na nb nc b">oauth_callback</code>处理程序组件的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="bd7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，当应用程序在Google上认证后登陆到<code class="fe mz na nb nc b">/oauth_callback</code> URL时，组件挂载<code class="fe mz na nb nc b">useEffect</code>钩子被触发，我们获取代码和状态来对我们的服务器进行<code class="fe mz na nb nc b">GET</code>调用，服务器将把它转发给服务器端的实际Google请求。您也可以在这里选择创建一个<code class="fe mz na nb nc b">POST</code>请求。</p><p id="59c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于重定向后获得的<code class="fe mz na nb nc b">state</code>参数，我们将适当的路由参数传递给API进行相应的处理。</p><p id="4a69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们讨论的所有事情都可以通过<code class="fe mz na nb nc b">location.href.assign</code>来实现，其中我们改变了浏览器上的当前窗口URL。</p><p id="c15c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，很有可能，您关心UX，并且由于以下原因，您不想再次卸载和加载整个应用程序:</p><ol class=""><li id="0a1c" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu oj nm nn no bi translated">卸载整个应用程序意味着您会丢失应用程序状态。比方说，你在一周后打开你的Mac，试图访问一个dashboard应用程序，它识别出你的访问已经过期，而不是完全重定向到Google，在提示窗口中处理OAuth会更好。</li><li id="471b" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu oj nm nn no bi translated">考虑到你的应用程序上没有服务人员或延迟加载分块功能，在这种情况下刷新应用程序意义重大。</li></ol><h2 id="c0b0" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">弹出UX</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/d7bfde86cb4c2588551b9ac7f6ade3e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j9xOcRYQ85ZUJ1fq5WkoHQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">OAuth的弹出插图</p></figure><p id="a658" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面是Swiggy的一个项目的弹出UX流的例子。是PWA，在桌面上打开。</p><p id="4a20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，我是在检测环境，并决定所需的UX类型。对于移动设备，我选择重定向UX(有一个原因，将进一步讨论)，对于桌面，我选择弹出UX。</p><p id="74f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这背后的<code class="fe mz na nb nc b">AuthService</code>是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="57f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里值得注意的是，我还使用了<a class="ae ky" href="https://gist.github.com/paramsinghvc/d90d5036fa94a7fd8dd6781bb8bdacc1" rel="noopener ugc nofollow" target="_blank">凭证管理API </a>来方便登录。</p><p id="39ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然，我相信它对于用户名/密码类的场景更有用，但是对于联邦或OAuth场景，您只能存储用户的<code class="fe mz na nb nc b">emailId</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/80dc8e5abe1768649ca6fab20ca33838.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*8Lv96-DU4RJBwBh9PymKbQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Creds API提示用户保存密码</p></figure><p id="0dbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:存储<code class="fe mz na nb nc b">code</code>或<code class="fe mz na nb nc b">access_token</code>不是一个好主意，因为它们过期了，需要更新。由于冗长的令牌字符串以及多个重复条目，下次登录时情况会更糟。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/0aec668f69e17dd0536d9cb315879cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qYAsSF7JcB-HMQQ3wBQN7Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">长访问令牌破坏用户界面</p></figure><p id="f813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没什么用。理想情况下，您只能存储<code class="fe mz na nb nc b">emailId</code>，并将其作为<code class="fe mz na nb nc b">login_hint</code>参数传递，只有少数OAuth实现(如Google)支持这个参数。</p><p id="f103" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您的应用程序知道它正在尝试验证哪个用户时，它可以将此参数作为提示提供给验证服务器。传递该提示会取消帐户选择器，或者预先填写登录表单上的电子邮件框，或者选择适当的会话(如果用户使用<a class="ae ky" href="https://support.google.com/accounts/answer/1721977" rel="noopener ugc nofollow" target="_blank">多重登录</a>)。</p><p id="d22b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以帮助您避免应用程序登录错误的用户帐户时出现的问题。该值可以是电子邮件地址或<code class="fe mz na nb nc b">sub</code>字符串，相当于用户的Google ID。</p><p id="7eda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是你所能做的，通过在账户选择器中提示账户，使用<code class="fe mz na nb nc b">FederatedCredentials</code>来减少认证流程。</p><h2 id="a694" class="nw md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">邮件后API</h2><p id="79dd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">回到我们最初关于弹出流的讨论。</p><p id="b059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">策略是使用<code class="fe mz na nb nc b">window.open</code>从应用程序窗口打开另一个窗口，但是您必须将<code class="fe mz na nb nc b">code</code>或<code class="fe mz na nb nc b">token</code>返回到应用程序窗口。这只能通过窗口的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" rel="noopener ugc nofollow" target="_blank"> postMessage </a> API来实现。</p><p id="444b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将让代码在这里说话。下面是弹出的<code class="fe mz na nb nc b">postMessage</code>实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="cf86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">processToken</code> <strong class="lb iu"> </strong>方法，在OAuth回调组件内部调用，将消息或信标发送回打开它的窗口。它检查当前窗口是否是从父窗口打开的，并向包含已处理令牌的父窗口发送postmessage。</p><p id="a0d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我不得不在移动设备上使用重定向流，因为当你把应用程序固定在Android上时，<code class="fe mz na nb nc b">window.opener</code>会给出空值。</p><p id="d9cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一前一后，在父窗口端有一个监听器事件处理器<code class="fe mz na nb nc b">listenToMessageEvent</code>，监听这些<code class="fe mz na nb nc b">postMessages</code>。</p><p id="6760" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传递并检查一个唯一的<code class="fe mz na nb nc b">type</code> <strong class="lb iu"> </strong>参数很重要，因为一个窗口可能会从Chrome extensions等各种来源获得大量消息。</p><p id="7796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且，尽管您会看到<code class="fe mz na nb nc b">OAuthCallback</code>组件的一瞥，但最好给它添加最小化的样式，显示一个加载器或一条错误消息以防登录失败。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/78f2c807a6a53df260046e93c7339b79.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*I0UeRRIbArzpZ4mHlYLxiQ.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2517" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实施授权码授予流程—后端</h1><p id="692c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我已经使用Koa建立了一个Node.js服务器。我们必须在这里为auth创建两个端点。</p><p id="3397" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个是根据提供者获取授权URL:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="03b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是OAuth服务的核心:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="d098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">OAuth是一个通用类，其中的各种子类可以扩展并提供配置值。它提供了所有必要的方法，比如获取Auth URLs、从令牌获取代码以及刷新过期的访问令牌。</p><p id="de02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是从授权码获取访问令牌并启动用户会话的另一种方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="b4c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为调用响应接收到的<code class="fe mz na nb nc b">id_token</code>是一个应该被验证的JWT令牌。这里是谷歌实现<a class="ae ky" href="https://github.com/googleapis/google-auth-library-nodejs/blob/master/src/crypto/node/crypto.ts" rel="noopener ugc nofollow" target="_blank">的例子</a>。</p><p id="0332" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过将用户会话与从访问令牌获得的电子邮件ID进行映射来启动用户会话。我们将用户的信息存储在数据库中，或者用新的访问令牌和刷新令牌更新现有的用户信息，等等。</p><p id="cd14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过对照用户的DB检查请求中cookie头中的会话值，可以为任何受保护的路由提供服务。</p><p id="01ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果会话cookie头不存在或与DB条目不匹配，它可以发送401头，通知用户未登录或访问令牌已被篡改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="6254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以创建一个中间件来更好地实现这一点。</p><p id="6524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已！没有人能那么容易实现OAuth！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8cae" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">网络认证的未来</h1><p id="8d0c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在结束之前，我不想不讨论<a class="ae ky" href="https://webauthn.io/" rel="noopener ugc nofollow" target="_blank">网站认证</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/d51212155e65ab79fadf50e3e284fc7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*qux1NTXzs2yF4PMN-KUJdA.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/3a8750dd1067255d473a99cbbc9576ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AieqN0ZM7oNpeG_7KOYf6g.jpeg"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/9fc19c04de961ddcdb6c231613e91b5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*xcqDAf7fyJpaK0FYWlXXmA.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/7d009d3f681e57210af2f3ef1ede3818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yzjJcMbNpM-jv1NTXDJnUQ.png"/></div></div></figure><p id="61ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得认证变得更加容易。就像苹果已经在做的那样。WebAuthn是一种将指纹登录的优点带到web上的方式，但遗憾的是，并不是所有的浏览器都支持。</p><p id="35db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">IOS还没有拥抱它，甚至在最新的iOS 13中也没有，截至目前。另外，跨设备登录是个问题。YubiKey是一个解决方案，它非常适合需要高度安全性的公司内部仪表盘。</p><p id="c567" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WebAuthn的整个基本原理是基于这样一个事实，即密码是一个长散列，不会被窃取或忘记，它驻留在硬件上。</p><p id="83b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与今天的用户名/密码被盗的情况形成对比，因此，我们必须依赖MFA(多因素身份认证),这给登录增加了越来越多的摩擦。指纹是证明你身份的一个很好的方法，因为从生物学上来说，它对每个人来说都是独一无二的。</p><p id="34ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过检测正在打开的浏览器上的支持来逐步将它添加到我们的应用程序中，同时在尚不支持它的浏览器上提供优雅的降级。</p><p id="f53c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毕竟，我们正在构建<em class="ne">渐进式</em> <em class="ne">网络应用</em> (PWAs)，对吗？但遗憾的是，它对单个设备工作得很好，多设备支持并不那么直接。</p><div class="pg ph gp gr pi pj"><a href="https://github.com/w3c/webauthn/issues/151" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">阐明用户如何从多个设备进行身份验证问题#151 w3c/webauthn</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">当前的规范草案没有试图解决不同用户的认证问题…</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">github.com</p></div></div><div class="ps l"><div class="pt l pu pv pw ps px ks pj"/></div></div></a></div><p id="3adf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是值得投入精力。希望今后支持会有所改善。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6be4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="fe32" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们讨论了OAuth相对于目前流行的传统用户名/密码方法的优势，以及如何使用暴力破解愚蠢的密码来轻易破坏帐户。</p><p id="f69b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个数字化时代，数据比什么都重要，保护数据至关重要。除了用户名/密码方法之外，联合登录是一种方法，或者说是一种很好的方法。</p><p id="c004" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，MFA对保护资源也很重要。我们讨论了OAuth如何工作的流程，React应用程序中Auth代码流的实现，以及不使用任何第三方库的后端用户和auth管理。</p><p id="bbfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们谈到了使用WebAuthn登录的未来前景。</p><p id="2e51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码库可以在<a class="ae ky" href="https://github.com/paramsinghvc/koa-react-spa/tree/auth" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="4a3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢你。建议任何想法，如果我错过了一些，使更安全的应用程序。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="91a2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><div class="pg ph gp gr pi pj"><a href="https://stackoverflow.com/a/51529795/2312848" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">OpenID和OAuth有什么区别？</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">感谢贡献一个堆栈溢出的答案！请务必回答问题。提供详细信息并分享…</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">stackoverflow.com</p></div></div><div class="ps l"><div class="py l pu pv pw ps px ks pj"/></div></div></a></div><div class="pg ph gp gr pi pj"><a href="https://github.com/paramsinghvc/koa-react-spa/tree/auth" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">paramsinghvc/koa-react-spa</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">这个项目是用Create React App引导的。在项目目录中，您可以运行:在…中运行应用程序</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">github.com</p></div></div><div class="ps l"><div class="pz l pu pv pw ps px ks pj"/></div></div></a></div><div class="pg ph gp gr pi pj"><a href="https://github.com/googleapis/google-auth-library-nodejs" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">谷歌API/谷歌授权库节点</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">这是Google官方支持的node.js客户端库，用于使用OAuth 2.0授权和认证…</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">github.com</p></div></div><div class="ps l"><div class="qa l pu pv pw ps px ks pj"/></div></div></a></div></div></div>    
</body>
</html>