<html>
<head>
<title>Building a REST Client with Spring Cloud OpenFeign and Netflix Ribbon</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Spring Cloud OpenFeign和网飞Ribbon构建REST客户端</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-rest-client-with-spring-cloud-openfeign-and-netflix-ribbon-44734c7dfaa7?source=collection_archive---------3-----------------------#2020-11-04">https://betterprogramming.pub/building-a-rest-client-with-spring-cloud-openfeign-and-netflix-ribbon-44734c7dfaa7?source=collection_archive---------3-----------------------#2020-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="61c1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何构建一个声明性的、高度可读的REST客户机，而无需编写样板代码来通过HTTP调用服务</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/58b5ba9981f24ae09f0085a8b88a4101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mJto7yk1I33NHUMK"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">乔恩·泰森在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2f8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用Java在服务之间发出HTTP请求非常简单。有了很多知名的开源HTTP客户端，比如Spring中的OkHttp和RestTemplate，选择一个合适的候选对象似乎并不困难。真正的问题在于未来。</p><p id="6e75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在服务器来来去去的云中，分布式服务的数量越来越多，服务端点是动态的，事先是未知的。我们的REST客户端需要集成到服务注册中心，以便在发出请求之前查找服务端点。</p><p id="d606" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还需要处理请求-响应序列化，并实现负载平衡以在服务器之间分配负载。然后需要容错来实现弹性。所有这些都是分布式系统中的交叉问题。</p><p id="a703" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是Spring Cloud OpenFeign介入的地方。Spring Cloud OpenFeign不仅仅是一个HTTP客户端，还是一个解决现代REST客户端相关问题的解决方案。Spring Cloud OpenFeign通过自动配置和绑定到Spring环境，为Spring Boot提供OpenFeign集成。</p><p id="5b0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">OpenFeign最初被称为Feign，由网飞发起，旨在允许开发人员通过创建带注释的接口，使用声明性的方式构建HTTP客户端，而无需编写任何样板代码。Spring Cloud OpenFeign使用Ribbon来提供客户端负载平衡，并与其他云服务很好地集成，例如用于服务发现的Eureka和用于容错的Hystrix。这些都是现成的，无需编写任何代码。</p><p id="a93a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，您将了解如何使用Spring Cloud OpenFeign构建一个声明性的、高度可读的REST客户端来通过HTTP调用服务。在后面的部分中，您还将学习在OpenFeign中为负载平衡配置带有端点的Ribbon。最后，我们将使您的Spring REST服务中的Eureka客户机能够与Eureka服务器集成。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="879e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">创建一个Maven项目</h1><p id="62ee" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">您可以使用Spring Initializr网站来生成一个带有Spring Boot 2.x的Maven项目。向您的项目添加Spring Web、OpenFeign和Ribbon依赖项。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/9b786e450b72157739206317c728f16b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zfF9w4U7L4CWp3laeiOnRw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Spring Initializr:添加依赖项</p></figure><p id="a0d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您从一个空的Maven项目开始，导入Spring Cloud Dependencies POM，这样您的项目可以继承Spring Cloud家族中的所有工件版本。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="94db" class="nc ma iq my b gy nd ne l nf ng">&lt;!-- spring-cloud --&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;<br/>  &lt;version&gt;Hoxton.SR6&lt;/version&gt;<br/>  &lt;scope&gt;import&lt;/scope&gt;<br/>  &lt;type&gt;pom&lt;/type&gt;<br/>&lt;/dependency&gt;</span></pre><p id="248d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，将Spring Boot启动器Web、Spring Cloud Starter OpenFeign和Spring Cloud Starter网飞功能区模块添加到项目的依赖项中。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="4500" class="nc ma iq my b gy nd ne l nf ng">&lt;!-- spring --&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br/>&lt;/dependency&gt;&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;<br/>&lt;/dependency&gt;&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="8632" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，您可以从<a class="ae kv" href="https://github.com/getstarted-spring/feignclient" rel="noopener ugc nofollow" target="_blank"> GitHub </a>下载完整的项目。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="2633" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">创建一个应用程序启动类</h1><p id="8aeb" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">与任何其他Spring Boot应用程序一样，我们需要一个主类来启动Spring <code class="fe nh ni nj my b">ApplicationContext</code>。用<code class="fe nh ni nj my b">@SpringBootApplication</code>注释创建一个应用程序类，主入口方法调用Spring Boot的<code class="fe nh ni nj my b">SpringApplication.run()</code>来启动应用程序。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="d191" class="nc ma iq my b gy nd ne l nf ng">@SpringBootApplication<br/>@EnableFeignClients<br/>public class Application {<br/><br/>  public static final void main(final String[] args) {<br/>    SpringApplication.run(Application.class, args);<br/>  }<br/>}</span></pre><p id="5170" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj my b">@SpringBootApplication</code>在我们的应用中启用组件扫描和自动配置。我们将<code class="fe nh ni nj my b">@EnableFeignClients</code>注释添加到我们的应用程序类中，以便对用<code class="fe nh ni nj my b">@FeignClient</code>注释的接口进行组件扫描。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0023" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">创建一个REST客户端接口</h1><p id="a38f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">创建一个<code class="fe nh ni nj my b">PostmanEchoClient</code>接口，用<code class="fe nh ni nj my b">@FeignClient</code>注释对其进行注释，命名为<code class="fe nh ni nj my b">postman-echo</code>。Spring会自动扫描我们的接口，并在运行时为我们的REST客户端构建一个实现。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="eaac" class="nc ma iq my b gy nd ne l nf ng">@FeignClient(name = "postman-echo")<br/>public interface PostmanEchoClient {<br/>}</span></pre><p id="bf96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Spring使用与<code class="fe nh ni nj my b">@FeignClient</code>注释一起提供的名称<code class="fe nh ni nj my b">postman-echo</code>作为标识符，为客户端负载平衡器创建一个<code class="fe nh ni nj my b">RibbonClient</code>。</p><p id="8047" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几种方法为创建的<code class="fe nh ni nj my b">RibbonClient</code>提供服务器端点以实现负载平衡，比如使用Java配置、Spring应用程序属性，或者集成到Eureka Server来查找服务器端点。</p><p id="b74e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了超越硬编码的服务器端点URL，实现负载平衡的解决方案，让我们为bow设置一个带有静态<code class="fe nh ni nj my b">listOfServers</code>的Ribbon。在<code class="fe nh ni nj my b">application.yaml</code>文件中的<code class="fe nh ni nj my b">src/main/resources/</code>下，添加以下属性:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="ab66" class="nc ma iq my b gy nd ne l nf ng">postman+echo:<br/>  ribbon:<br/>    listOfServers: <a class="ae kv" href="https://postman-echo.com/," rel="noopener ugc nofollow" target="_blank">https://postman-echo.com/,</a> https://postman-echo.com/</span></pre><p id="e66f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Postman Echo是一个服务，我们可以用它来测试我们的REST客户机并进行示例API调用。它为<code class="fe nh ni nj my b">GET</code>、<code class="fe nh ni nj my b">POST</code>和<code class="fe nh ni nj my b">PUT</code>的端点提供各种认证机制。</p><p id="0a57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">端点的文档以及示例响应可以在<a class="ae kv" href="https://docs.postman-echo.com/?version=latest" rel="noopener ugc nofollow" target="_blank">邮递员回声</a>官方网站上找到。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1183" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">添加GET-Request客户端方法</h1><p id="14d3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">接下来，在Postman Echo客户端接口中添加一个<code class="fe nh ni nj my b">getEcho</code>客户端方法，该方法接受<code class="fe nh ni nj my b">String foo</code>和<code class="fe nh ni nj my b">String bar</code>请求参数并返回一个<code class="fe nh ni nj my b">EchoGetResponse</code>对象。使用这个方法上的<code class="fe nh ni nj my b">@GetMapping</code>注释将<code class="fe nh ni nj my b">path</code> / <code class="fe nh ni nj my b">get</code>附加到这个GET请求上。这个客户端方法在被调用时将调用Postman Echo GET-request端点。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="528b" class="nc ma iq my b gy nd ne l nf ng">@GetMapping(<br/>    path = "/get", <br/>    consumes = "application/json")<br/>EchoGetResponse getEcho(<br/>    @RequestParam("foo") String foo, <br/>    @RequestParam("bar") String bar<br/>    );</span></pre><p id="7e9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Postman Echo GET-request端点将相应地将所有提供的请求参数作为响应体在<code class="fe nh ni nj my b">args</code>元素中进行回显。关于Postman Echo GET请求的文档可以在<a class="ae kv" href="https://docs.postman-echo.com/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="b726" class="nc ma iq my b gy nd ne l nf ng">{<br/>  "args": {<br/>    "foo": "abc",<br/>    "bar": "123"<br/>  }<br/>}</span></pre><p id="7e54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个新的<code class="fe nh ni nj my b">EchoGetResponse</code>类来表示JSON响应。<code class="fe nh ni nj my b">EchoGetResponse</code>是一个普通的旧Java对象(POJO)类。JSON响应将在我们的Postman Echo GET请求客户端方法中被反序列化为<code class="fe nh ni nj my b">EchoGetResponse</code>。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="87a0" class="nc ma iq my b gy nd ne l nf ng">public class EchoGetResponse {<br/><br/>  private Args args;<br/><br/>  public Args getArgs() {<br/>    return args;<br/>  }<br/><br/>  public void setArgs(Args args) {<br/>    this.args = args;<br/>  }<br/><br/>  public static class Args {<br/><br/>    private String foo;<br/><br/>    private String bar;<br/><br/>    public String getFoo() {<br/>      return foo;<br/>    }<br/><br/>    public void setFoo(String foo) {<br/>      this.foo = foo;<br/>    }<br/><br/>    public String getBar() {<br/>      return bar;<br/>    }<br/><br/>    public void setBar(String bar) {<br/>      this.bar = bar;<br/>    }<br/>  }<br/>}</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d63e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">使用“SpringBootTest”测试GET-Request客户端方法</h1><p id="4a5c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们使用<code class="fe nh ni nj my b">SpringBootTest</code>来单元测试我们对远程Postman Echo GET-request端点的GET request客户端方法调用。为此，创建一个<code class="fe nh ni nj my b">PostmanEchoClientTests</code>类。使用带有<code class="fe nh ni nj my b">@SpringBootTest</code> <em class="nk"> </em>注释的随机端口设置测试上下文。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="d123" class="nc ma iq my b gy nd ne l nf ng">@SpringBootTest(<br/>    webEnvironment = WebEnvironment.RANDOM_PORT)<br/>class PostmanEchoClientTests {<br/>}</span></pre><p id="cd83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将Spring创建的<code class="fe nh ni nj my b">PostmanEchoClient</code> <strong class="ky ir"> </strong> bean自动连接到我们的单元测试类中。创建的bean应该使用已配置的功能区服务器列表进行客户端负载平衡。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="9e2a" class="nc ma iq my b gy nd ne l nf ng">@Autowired private PostmanEchoClient client;</span></pre><p id="c6c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个<code class="fe nh ni nj my b">getEcho</code> <code class="fe nh ni nj my b">@Test</code>方法，该方法使用自动连接的<code class="fe nh ni nj my b">PostmanEchoClient</code> bean来调用Postman Echo GET-request端点。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="2bdc" class="nc ma iq my b gy nd ne l nf ng">@Test<br/>void getEcho() throws Exception {<br/>  <br/>  final EchoGetResponse response = <br/>      client.getEcho("abc", "123");<br/>  <br/>  assertThat(<br/>      response.getArgs().getFoo()<br/>      ).isEqualTo("abc");<br/>  assertThat(<br/>      response.getArgs().getBar()<br/>      ).isEqualTo("123");<br/>  <br/>}</span></pre><p id="9300" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在调用远程端点之后，确保返回的<code class="fe nh ni nj my b">EchoGetResponse</code>响应与提供的请求参数匹配，注意它是否如预期的那样正确地从预期的JSON内容反序列化。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="35f8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">添加请求后客户端方法</h1><p id="65cf" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">既然我们已经测试了一个简单的GET请求，那么让我们尝试一个POST请求。在接受<code class="fe nh ni nj my b">String foo</code>和<code class="fe nh ni nj my b">String bar</code>请求参数的<code class="fe nh ni nj my b">PostmanEchoClient</code>接口中添加一个<code class="fe nh ni nj my b">postEcho</code>客户端方法。它应该有一个<code class="fe nh ni nj my b">EchoPostRequest</code>对象请求体，并返回一个<code class="fe nh ni nj my b">EchoPostResponse</code>对象。</p><p id="3f52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这个方法上的<code class="fe nh ni nj my b">@PostMapping</code>注释将<code class="fe nh ni nj my b">path</code> / <code class="fe nh ni nj my b">post</code>附加到这个POST请求。这个客户端方法在被调用时将调用Postman Echo POST-request端点。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="1b91" class="nc ma iq my b gy nd ne l nf ng">@PostMapping(<br/>    path = "/post", <br/>    consumes = "application/json")<br/>EchoPostResponse postEcho(<br/>    @RequestParam("foo") String foo,<br/>    @RequestParam("bar") String bar,<br/>    @RequestBody EchoPostRequest body);</span></pre><p id="e57b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Postman Echo POST-request端点将回显所提供的请求参数，并相应地请求<code class="fe nh ni nj my b">body</code>作为<code class="fe nh ni nj my b">args</code>和<code class="fe nh ni nj my b">data</code>元素中的响应。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="eef2" class="nc ma iq my b gy nd ne l nf ng">{<br/>  "args": {<br/>    "foo": "abc",<br/>    "bar": "123"<br/>  },<br/>  "data": {<br/>    "message": "hello"<br/>  }<br/>}</span></pre><p id="428b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个新的<code class="fe nh ni nj my b">EchoPostRequest</code>类来表示JSON-request主体。<code class="fe nh ni nj my b">EchoPostRequest</code>是一个普通的旧Java对象(POJO)类，包含一个单独的<code class="fe nh ni nj my b">String</code>消息属性。当调用Postman Echo POST-request端点时,<code class="fe nh ni nj my b">EchoPostRequest</code>对象将被序列化为JSON-request主体。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="f54e" class="nc ma iq my b gy nd ne l nf ng">public class EchoPostRequest {<br/><br/>  private String message;<br/><br/>  public String getMessage() {<br/>    return message;<br/>  }<br/><br/>  public void setMessage(String message) {<br/>    this.message = message;<br/>  }<br/>}</span></pre><p id="9dab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建另一个新的<code class="fe nh ni nj my b">EchoPostResponse</code>类来表示JSON响应。<code class="fe nh ni nj my b">EchoPostResponse</code>类包含一个具有<code class="fe nh ni nj my b">foo</code>和<code class="fe nh ni nj my b">bar</code>属性的<code class="fe nh ni nj my b">args</code>和一个具有<code class="fe nh ni nj my b">message</code>属性的<code class="fe nh ni nj my b">data</code>。在我们的Postman Echo POST-request客户端方法中，JSON响应将被反序列化为<code class="fe nh ni nj my b">EchoPostResponse</code>。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="458c" class="nc ma iq my b gy nd ne l nf ng">public class EchoPostResponse {<br/><br/>  private Args args;<br/><br/>  private Data data;<br/><br/>  public Args getArgs() {<br/>    return args;<br/>  }<br/><br/>  public void setArgs(Args args) {<br/>    this.args = args;<br/>  }<br/><br/>  public Data getData() {<br/>    return data;<br/>  }<br/><br/>  public void setData(Data data) {<br/>    this.data = data;<br/>  }<br/><br/>  public static class Args {<br/><br/>    private String foo;<br/><br/>    private String bar;<br/><br/>    public String getFoo() {<br/>      return foo;<br/>    }<br/><br/>    public void setFoo(String foo) {<br/>      this.foo = foo;<br/>    }<br/><br/>    public String getBar() {<br/>      return bar;<br/>    }<br/><br/>    public void setBar(String bar) {<br/>      this.bar = bar;<br/>    }<br/>  }<br/><br/>  public static class Data {<br/><br/>    private String message;<br/><br/>    public String getMessage() {<br/>      return message;<br/>    }<br/><br/>    public void setMessage(String message) {<br/>      this.message = message;<br/>    }<br/>  }<br/>}</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4466" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">使用“SpringBootTest”测试请求后客户端方法</h1><p id="1a43" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">同样，我们将在先前添加的<code class="fe nh ni nj my b">PostmanEchoClientTests</code>类中为新添加的<code class="fe nh ni nj my b">postEcho</code>客户端方法添加一个<code class="fe nh ni nj my b">postEcho</code>测试方法。同样，使用autowired <code class="fe nh ni nj my b">PostmanEchoClient</code> bean来调用Postman Echo POST-request端点。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="9049" class="nc ma iq my b gy nd ne l nf ng">@Test<br/>void postEcho() {<br/>  <br/>  final EchoPostRequest request = <br/>      new EchoPostRequest();<br/>  request.setMessage("xyz");<br/><br/>  final EchoPostResponse response = <br/>      client.postEcho("abc", "123", request);<br/><br/>  assertThat(<br/>      response.getArgs().getFoo()<br/>      ).isEqualTo("abc");<br/>  assertThat(<br/>      response.getArgs().getBar()<br/>      ).isEqualTo("123");<br/>  assertThat(<br/>      response.getData().getMessage()<br/>      ).isEqualTo("xyz");<br/>  <br/>}</span></pre><p id="d676" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在调用远程端点之后，确保返回的<code class="fe nh ni nj my b">EchoPostResponse</code>响应与提供的请求参数和请求体匹配，确保它正确地从预期的JSON内容反序列化。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="356d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">与Eureka服务器集成</h1><p id="2386" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">通过简单的注释和配置，您可以在Spring REST服务中快速启用网飞尤里卡发现客户端。</p><p id="1305" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在此之前，将依赖关系<code class="fe nh ni nj my b">spring-cloud-starter-netfliix-eureka-client</code>模块添加到您的项目中。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="6c64" class="nc ma iq my b gy nd ne l nf ng">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="da4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，将<code class="fe nh ni nj my b">@EnableDiscoveryClient</code>注释添加到您的应用程序类中，以激活网飞尤里卡发现客户端实现。然后，它将向服务注册中心网飞尤里卡服务器注册自己，并使用Spring Cloud <code class="fe nh ni nj my b">DiscoveryClient</code>抽象来询问包含服务端点的服务元数据，功能区客户端将使用这些服务端点进行负载平衡。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="1a3c" class="nc ma iq my b gy nd ne l nf ng">@SpringBootApplication<br/>@EnableFeignClients<br/>@EnableDiscoveryClient<br/>public class Application {<br/><br/>  public static final void main(final String[] args) {<br/>    SpringApplication.run(Application.class, args);<br/>  }<br/>}</span></pre><p id="c93d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，在<code class="fe nh ni nj my b">application.yaml</code>中为您的Eureka服务器配置一个应用程序名称和端点URL。</p><p id="768c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Eureka客户端使用您的应用程序名称注册到Eureka服务器。如果不配置应用程序名称，您的服务将在Eureka服务器上显示为未知。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="a249" class="nc ma iq my b gy nd ne l nf ng">spring:<br/>  application:<br/>    name: feignclient</span><span id="db0e" class="nc ma iq my b gy nl ne l nf ng">eureka:<br/>  client:<br/>    serviceUrl:<br/>      defaultZone: <a class="ae kv" href="http://localhost:8001/eureka" rel="noopener ugc nofollow" target="_blank">http://localhost:8761/eureka</a></span></pre><p id="2322" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这几个步骤，您已经将Spring REST服务集成到了Eureka服务器上。</p><p id="888a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然您的REST服务已经准备好连接到Eureka服务器，那么您需要从<code class="fe nh ni nj my b">application.yaml</code>中移除或注释Ribbon的<code class="fe nh ni nj my b">listOfServers</code>属性。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="8445" class="nc ma iq my b gy nd ne l nf ng"># postmanEcho:<br/>#   ribbon:<br/>#     listOfServers: https://postman-echo.com/</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d784" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">创建尤里卡服务器</h1><p id="1f31" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">使用Spring Initializr网站为Eureka Server生成另一个具有Eureka Server依赖项的项目。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/637309e708c7bfbcba0b43c100205687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Rd6Mu4KyNeB66m1X6PyPQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Spring Initialzr:添加依赖项</p></figure><p id="6e53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您从一个空的Maven项目开始，导入Spring Cloud Dependencies POM并将Spring Cloud Starter网飞尤里卡服务器依赖项添加到您的项目中。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="43cf" class="nc ma iq my b gy nd ne l nf ng">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="3dcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，从<a class="ae kv" href="https://github.com/getstarted-spring/eureka-server" rel="noopener ugc nofollow" target="_blank"> GitHub </a>下载Eureka服务器项目。</p><p id="dfd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您需要创建一个带有<code class="fe nh ni nj my b">@SpringBootApplication</code>注释的标准主入口类。将<code class="fe nh ni nj my b">@EnableEurekaServer</code>注释添加到您的类中，以激活Eureka服务器实现。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="69dd" class="nc ma iq my b gy nd ne l nf ng">@SpringBootApplication<br/>@EnableEurekaServer<br/>public class EurekaServer {<br/><br/>  public static final void main(final String[] args) {<br/>    SpringApplication.run(EurekaServer.class, args);<br/>  }<br/>}</span></pre><p id="0047" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，将您的服务器端口改为<code class="fe nh ni nj my b">8761</code>。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="1844" class="nc ma iq my b gy nd ne l nf ng">server:<br/>  port: 8761</span></pre><p id="c742" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，关闭<code class="fe nh ni nj my b">application.yaml</code>中的自注册和获取注册特性。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="f153" class="nc ma iq my b gy nd ne l nf ng">eureka:<br/>  client:<br/>    serviceUrl:<br/>      defaultZone: http://localhost:8761/eureka<br/>    registerWithEureka: false<br/>    fetchRegistry: false</span></pre><p id="9322" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个，你的尤里卡服务器就准备好了。启动它。</p><p id="053d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于Postman Echo是一个外部服务，您需要手动将其注册到您的Eureka服务器。你可以在这里获得一个Eureka支持的REST操作列表<a class="ae kv" href="https://github.com/Netflix/eureka/wiki/Eureka-REST-operations" rel="noopener ugc nofollow" target="_blank">。您将只使用API注册一个新的应用程序。</a></p><p id="352d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Postman向您的Eureka服务器发送请求。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/5dc9c0face0b717b4b844d7feaffee68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zxOxJUFzWTgchMxE6nLrqg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">邮递员:请求尤里卡服务器</p></figure><p id="5ed8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将Postman Echo注册到Eureka服务器的URL如下:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="1129" class="nc ma iq my b gy nd ne l nf ng">http://localhost:8761/eureka/apps/POSTMAN-ECHO</span></pre><p id="357c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请求内容以将邮递员Echo注册到Eureka服务器，如下所示:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="c7b0" class="nc ma iq my b gy nd ne l nf ng">{<br/>  "instance": {<br/>    "app": "POSTMAN-ECHO",<br/>    "hostName": "postman-echo.com",<br/>    "vipAddress": "postman-echo",<br/>    "secureVipAddress": "postman-echo",<br/>    "ipAddr": "54.90.58.153",<br/>    "status": "UP",<br/>    "port": {"$": "80", "<a class="ae kv" href="http://twitter.com/enabled" rel="noopener ugc nofollow" target="_blank">@enabled</a>": "true"},<br/>    "securePort": {"$": "443", "<a class="ae kv" href="http://twitter.com/enabled" rel="noopener ugc nofollow" target="_blank">@enabled</a>": "true"},<br/>    "healthCheckUrl": "<a class="ae kv" href="http://postman-echo.com/get" rel="noopener ugc nofollow" target="_blank">http://postman-echo.com/get</a>",<br/>    "statusPageUrl": "<a class="ae kv" href="http://postman-echo.com/get" rel="noopener ugc nofollow" target="_blank">http://postman-echo.com/get</a>",<br/>    "homePageUrl": "<a class="ae kv" href="http://postman-echo.com" rel="noopener ugc nofollow" target="_blank">http://postman-echo.com</a>",<br/>    "dataCenterInfo": {<br/>      "<a class="ae kv" href="http://twitter.com/class" rel="noopener ugc nofollow" target="_blank">@class</a>": "com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo", <br/>      "name": "MyOwn"<br/>    }<br/>  }<br/>}</span></pre><p id="e7b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您需要将应用程序注册为<code class="fe nh ni nj my b">POSTMAN-ECHO</code>，因为您之前已经将您的<code class="fe nh ni nj my b">@FeignClient</code>命名为<code class="fe nh ni nj my b">postman-echo</code>。</p><p id="ec5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该得到一个没有内容的成功响应。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/85ffb1679297559186afe0ecf463e97e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HcEKSpTyYZW_I5N2kXlrNw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">邮递员:来自尤里卡服务器的回复</p></figure><p id="72eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开您的Eureka仪表板，您应该看到<code class="fe nh ni nj my b">POSTMAN-ECHO</code>已注册。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/b33b36796e49a3cc198aa8f2171c7540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0OJx7exkR8iju6zkT7mLA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Eureka服务器:注册的实例</p></figure><p id="a00f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再次运行你的<code class="fe nh ni nj my b">PostmanRestClientTests</code>,看看一切都在无缝运行。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ebe2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">摘要</h1><p id="b28a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们已经了解了如何使用Spring Cloud OpenFeign构建声明式REST客户端，使用Spring Cloud网飞功能区提供客户端负载平衡和容错。我们还学习了如何为Ribbon配置静态服务器端点，以及如何集成到Eureka Server以获得注册服务器端点的列表。所有源代码都可以在<a class="ae kv" href="https://github.com/getstarted-spring/feignclient" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="02b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读，我希望这篇文章对您有所帮助。</p></div></div>    
</body>
</html>