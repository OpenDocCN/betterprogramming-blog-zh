<html>
<head>
<title>An iOS Engineer’s Perspective on SOLID Principles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS工程师对坚实原则的看法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-ios-engineers-perspective-on-solid-principles-bf46ddc25d47?source=collection_archive---------6-----------------------#2020-12-07">https://betterprogramming.pub/an-ios-engineers-perspective-on-solid-principles-bf46ddc25d47?source=collection_archive---------6-----------------------#2020-12-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1474" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">iOS和Swift世界的可靠程度如何</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/28de51b4f5ec439fc19df3de8755ecc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-JunOSAeFEt1-ITIMEYViQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="075c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SOLID由五个设计原则组成，旨在使代码更易于理解、灵活和维护。根据维基百科，该原则最早出现在罗伯特·马丁2000年的一篇名为“设计原则和设计模式”的论文中，但缩写词SOLID是由迈克尔·费瑟斯引入的。</p><p id="7081" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望当你读到这篇文章时，你真的想成为一名更好的工程师或者写出更好的代码。当工程师编写代码时，我们应该考虑代码的可伸缩性，以及代码是否可供不同的工程师阅读。如果我们不这样做，我们就有一个大问题——我们需要通过遵循坚实的原则来解决这个问题。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="905c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">原则1:单一责任</h1><h2 id="54b8" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">每个类应该只有一个责任</h2><p id="e651" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">通过查看代码行，我们可能以某种方式测量出类中实际存在多少职责。因此，我从不同的来源选取了不同的例子，以更好地帮助我们衡量我们应该有多少行代码。</p><ul class=""><li id="d971" class="nl nm it la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated">根据Code Complete，1996年的一项研究发现，例程越多的类缺陷越多。</li><li id="ca88" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">根据Ben Nadel的“<a class="ae nz" href="http://www.bennadel.com/resources/uploads/2012/ObjectCalisthenics.pdf" rel="noopener ugc nofollow" target="_blank">对象健身操</a>”，超过50行的类通常做不止一件事，这使得它们更难理解和重用。50行的类有一个额外的好处，就是可以在一个屏幕上看到，不需要滚动，这使得它们更容易快速掌握。</li><li id="1eef" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">根据关于<a class="ae nz" href="https://softwareengineering.stackexchange.com/questions/66523/how-many-lines-per-class-is-too-many-in-java" rel="noopener ugc nofollow" target="_blank">栈交换</a>的一个讨论，200线是一个很好的指导方针。</li><li id="7af7" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">SwiftLint是一个通过使用默认配置来帮助实施Swift风格的工具，它认为一个类的代码应该少于500行。(我知道您可以更改这些设置的配置。)</li></ul><p id="bb7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">至于你的项目中应该有多少行代码，我将留给你自己的权限，因为我相信我们最了解我们自己的项目。我相信我们应该知道我们的代码有多长，但是我绝对喜欢将它保持在200行以内的想法。</p><p id="e4df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据我们拥有的代码行来判断，我们基本上可以测量我们在我们的类中有多少责任，并且可能将它们分成不同的类。</p><h2 id="5746" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">代码示例</h2><p id="58ca" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">让我们看看做这件事的不好的方法，然后看看我们可以做得更好。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="4cfe" class="mt mc it ob b gy of og l oh oi">// You have two responsiblities in this class</span><span id="6165" class="mt mc it ob b gy oj og l oh oi">struct Person {</span><span id="624d" class="mt mc it ob b gy oj og l oh oi">let name: String</span><span id="c270" class="mt mc it ob b gy oj og l oh oi">let age: Int</span><span id="3215" class="mt mc it ob b gy oj og l oh oi">func checkAge() -&gt; String {</span><span id="9c47" class="mt mc it ob b gy oj og l oh oi">    if age &lt; 8 {</span><span id="ddac" class="mt mc it ob b gy oj og l oh oi">      return "Underage"</span><span id="f28c" class="mt mc it ob b gy oj og l oh oi">    } else {</span><span id="c655" class="mt mc it ob b gy oj og l oh oi">      return "Qualified"</span><span id="0c6a" class="mt mc it ob b gy oj og l oh oi">    }</span><span id="df31" class="mt mc it ob b gy oj og l oh oi">  }</span><span id="89ef" class="mt mc it ob b gy oj og l oh oi">}<br/></span><span id="27b6" class="mt mc it ob b gy oj og l oh oi">let person = Person(name: "Kelvin", age: 27)</span><span id="4ff0" class="mt mc it ob b gy oj og l oh oi">person.checkAge()</span></pre><p id="183c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你明白这里划分责任的意义。是的，如果我们打算走这条路，我们可能会有很多文件，但让我们想想我们的代码将如何组织，随着时间的推移它将如何容易维护。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="8cdd" class="mt mc it ob b gy of og l oh oi">// One responsibility in one class</span><span id="f624" class="mt mc it ob b gy oj og l oh oi">struct Person {</span><span id="db87" class="mt mc it ob b gy oj og l oh oi">  let name: String</span><span id="e168" class="mt mc it ob b gy oj og l oh oi">  let age: Int</span><span id="dac7" class="mt mc it ob b gy oj og l oh oi">}</span><span id="0552" class="mt mc it ob b gy oj og l oh oi">// another responsibility in another class</span><span id="7325" class="mt mc it ob b gy oj og l oh oi">struct AgeVerifier {</span><span id="9f9e" class="mt mc it ob b gy oj og l oh oi">    func checkAge(age: Int) -&gt; String {</span><span id="8b65" class="mt mc it ob b gy oj og l oh oi">        if age &lt; 8 {</span><span id="e417" class="mt mc it ob b gy oj og l oh oi">          return "Underage"</span><span id="1904" class="mt mc it ob b gy oj og l oh oi">        } else {</span><span id="ad8c" class="mt mc it ob b gy oj og l oh oi">          return "Qualified"</span><span id="aa8c" class="mt mc it ob b gy oj og l oh oi">        }</span><span id="05cc" class="mt mc it ob b gy oj og l oh oi">    }</span><span id="1c1c" class="mt mc it ob b gy oj og l oh oi">}</span><span id="dda5" class="mt mc it ob b gy oj og l oh oi">let person = Person(name: "Lexton", age: 1)</span><span id="26a8" class="mt mc it ob b gy oj og l oh oi">let verifyAge = AgeVerifier()</span><span id="1371" class="mt mc it ob b gy oj og l oh oi">verifyAge.checkAge(age: person.age)</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="ec9e" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">原则2:开放-封闭</h1><h2 id="6c65" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated"><em class="nf">类应该为扩展而打开，为修改而关闭</em></h2><p id="2db0" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">这个原则通过两个重要的特征促进了可维护代码的编写:</p><ul class=""><li id="e02c" class="nl nm it la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated">开放供扩展</li><li id="c220" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">关闭以进行修改</li></ul><p id="a036" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简而言之，你应该能够很容易地向你的类添加几乎任何新的特性，而不必重新构造你的整个类，因为我们都知道进行重新构造会导致额外的开发和测试时间。</p><p id="0236" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我敢肯定，作为软件工程师，我们经常被提醒要构建一个以客户为中心的应用程序，这导致我们的产品经理在最后一刻推出大量新功能。作为一种预防措施，请始终编写可扩展的代码来实现一些附加功能。</p><p id="60b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们用一个非常简单的代码示例来说明这一点。想象一下，你有一个动物园，目前你的动物园里只有一只老虎。我们必须现实一点——只有一只老虎是赚不到钱的。你需要更多的动物，所以我们需要建造一个允许我们在任何时候添加任何动物的动物园。</p><h2 id="e839" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">代码示例</h2><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="1766" class="mt mc it ob b gy of og l oh oi">protocol AnimalProtocol {</span><span id="4113" class="mt mc it ob b gy oj og l oh oi">func makeSound() -&gt; String</span><span id="7e10" class="mt mc it ob b gy oj og l oh oi">}</span><span id="b209" class="mt mc it ob b gy oj og l oh oi">class Tiger: AnimalProtocol {</span><span id="2cbf" class="mt mc it ob b gy oj og l oh oi">    func makeSound() -&gt; String {</span><span id="67a5" class="mt mc it ob b gy oj og l oh oi">      return "Roar"</span><span id="831d" class="mt mc it ob b gy oj og l oh oi">    }</span><span id="66d5" class="mt mc it ob b gy oj og l oh oi">}</span><span id="0d3b" class="mt mc it ob b gy oj og l oh oi">struct Zoo {</span><span id="0c0a" class="mt mc it ob b gy oj og l oh oi">let animals: [AnimalProtocol]</span><span id="b928" class="mt mc it ob b gy oj og l oh oi">    func animalNoise() -&gt; [String] {</span><span id="15ea" class="mt mc it ob b gy oj og l oh oi">      return animals.map { $0.makeSound() }</span><span id="2c2e" class="mt mc it ob b gy oj og l oh oi">    }</span><span id="df0e" class="mt mc it ob b gy oj og l oh oi">}</span><span id="bebe" class="mt mc it ob b gy oj og l oh oi">let tiger = Tiger()</span><span id="4cdb" class="mt mc it ob b gy oj og l oh oi">var zooAnimals = Zoo(animals: [tiger])</span><span id="a3d9" class="mt mc it ob b gy oj og l oh oi">zooAnimals.animalNoise() // [roar]</span></pre><p id="7a65" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们终于有了一只新的动物，我们想把它加入动物园。简单！只需创建一个新类，并将其添加到动物园中。我们准备好了。也许在将来，当我们有更多的动物时，我们可以做同样的事情。</p><p id="c1da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我没有修改上面的大部分代码，但它仍然能够扩展功能。这就是所谓的<em class="ok">可扩展性。</em></p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="7c11" class="mt mc it ob b gy of og l oh oi">class Horse: AnimalProtocol {</span><span id="a6db" class="mt mc it ob b gy oj og l oh oi">  func makeSound() -&gt; String {</span><span id="9846" class="mt mc it ob b gy oj og l oh oi">    return “Neigh”</span><span id="0715" class="mt mc it ob b gy oj og l oh oi">  }</span><span id="e93b" class="mt mc it ob b gy oj og l oh oi">}</span><span id="30ed" class="mt mc it ob b gy oj og l oh oi">let horse = Horse()</span><span id="a2c8" class="mt mc it ob b gy oj og l oh oi">zooAnimals = Zoo(animals: [tiger, horse])</span><span id="235f" class="mt mc it ob b gy oj og l oh oi">zooAnimals.animalNoise() // [roar, neigh]</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="4076" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">原则3:利斯科夫替代原则</h1><h2 id="fcb3" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated"><em class="nf">子类不应该破坏父类的类型定义</em></h2><p id="334c" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">子类应该能够以不破坏基类功能的方式覆盖父类方法。这个原则的好处是，当代码可互换时，它变得更加可重用。</p><p id="249b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，如果一个override方法什么都不做或者只是抛出一个异常，那么您就违反了Liskov替换原则。</p><h2 id="e3b5" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">代码示例</h2><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="c2d5" class="mt mc it ob b gy of og l oh oi">class Bird {</span><span id="64e4" class="mt mc it ob b gy oj og l oh oi">  func makeNoise() {</span><span id="19b5" class="mt mc it ob b gy oj og l oh oi">    print(“Chirp chirp”)</span><span id="a45b" class="mt mc it ob b gy oj og l oh oi">  }</span><span id="75e2" class="mt mc it ob b gy oj og l oh oi">}</span><span id="a618" class="mt mc it ob b gy oj og l oh oi">class Eagle: Bird {</span><span id="3b5e" class="mt mc it ob b gy oj og l oh oi">  override func makeNoise() {</span><span id="c398" class="mt mc it ob b gy oj og l oh oi">    print(“Almight eagle roar”)</span><span id="d303" class="mt mc it ob b gy oj og l oh oi">  }</span><span id="4c3c" class="mt mc it ob b gy oj og l oh oi">}</span><span id="fdb8" class="mt mc it ob b gy oj og l oh oi">// This is where it violates the Liskov Substitution as doing so will break the parent class</span><span id="53f5" class="mt mc it ob b gy oj og l oh oi">class Crow: Bird {</span><span id="2a43" class="mt mc it ob b gy oj og l oh oi">  override func makeNoise() {</span><span id="c6f5" class="mt mc it ob b gy oj og l oh oi">    fatalError(“I forgot what my sound is”)</span><span id="67b6" class="mt mc it ob b gy oj og l oh oi">  }</span><span id="f74c" class="mt mc it ob b gy oj og l oh oi">}</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="8ec6" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">原则#4:界面分离</h1><h2 id="501d" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated"><em class="nf">仅实施您需要的内容</em></h2><p id="c5e7" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">通过分离我们的接口，我们解决了fat接口的问题— <em class="ok"> fat </em>意味着当一个接口有太多的方法，包含了比我们真正需要使用的更多的信息。简单来说，我们有时候只是用了一些东西，而不是我们所拥有的一切。这里的教训应该是:只使用你需要的东西。</p><p id="dbcd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，您正在进行您的个人项目，并且您购买了一大堆工具来帮助您构建项目。但最终，你只使用了你拥有的五个工具中的一个或两个。嗯，有时候我们会不知不觉地这样做。</p><h2 id="aa1e" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">代码示例</h2><p id="3a4f" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">看下面的代码，从逻辑上讲，我们知道baby不能真正去工作，但是因为我们符合<code class="fe ol om on ob b">Action</code>协议，我们需要声明这个方法。这是一个我们没有使用的方法的例子。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="18a1" class="mt mc it ob b gy of og l oh oi">protocol Action {</span><span id="c422" class="mt mc it ob b gy oj og l oh oi">  func eat()</span><span id="16b5" class="mt mc it ob b gy oj og l oh oi">  func work()</span><span id="087f" class="mt mc it ob b gy oj og l oh oi">}</span><span id="9164" class="mt mc it ob b gy oj og l oh oi">class Adult: Action {</span><span id="fd41" class="mt mc it ob b gy oj og l oh oi">  func eat() {</span><span id="e1cc" class="mt mc it ob b gy oj og l oh oi">    // adult eat</span><span id="22c7" class="mt mc it ob b gy oj og l oh oi">  }</span><span id="fd05" class="mt mc it ob b gy oj og l oh oi">  func work() {</span><span id="8d46" class="mt mc it ob b gy oj og l oh oi">    // adult work</span><span id="74ab" class="mt mc it ob b gy oj og l oh oi">  }</span><span id="04b2" class="mt mc it ob b gy oj og l oh oi">}</span><span id="3bf6" class="mt mc it ob b gy oj og l oh oi">class Baby: Action {</span><span id="791e" class="mt mc it ob b gy oj og l oh oi">  func eat() {</span><span id="7364" class="mt mc it ob b gy oj og l oh oi">    // baby eat</span><span id="2f29" class="mt mc it ob b gy oj og l oh oi">  }</span><span id="962c" class="mt mc it ob b gy oj og l oh oi">  func work() {</span><span id="d27a" class="mt mc it ob b gy oj og l oh oi">    // baby can’t work</span><span id="f6e9" class="mt mc it ob b gy oj og l oh oi">  }</span><span id="54c0" class="mt mc it ob b gy oj og l oh oi">}</span></pre><p id="abdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的代码可以简单地重写如下。我们只使用我们需要的。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="6be6" class="mt mc it ob b gy of og l oh oi">protocol EatAction {</span><span id="3370" class="mt mc it ob b gy oj og l oh oi">  func eat()</span><span id="2721" class="mt mc it ob b gy oj og l oh oi">}</span><span id="f287" class="mt mc it ob b gy oj og l oh oi">protocol WorkAction {</span><span id="6f41" class="mt mc it ob b gy oj og l oh oi">  func work()</span><span id="00b5" class="mt mc it ob b gy oj og l oh oi">}</span><span id="5b5f" class="mt mc it ob b gy oj og l oh oi">class Adult: EatAction, WorkAction {</span><span id="a195" class="mt mc it ob b gy oj og l oh oi">  func eat() {</span><span id="3dc3" class="mt mc it ob b gy oj og l oh oi">    // adut eat</span><span id="f425" class="mt mc it ob b gy oj og l oh oi">  }</span><span id="ff86" class="mt mc it ob b gy oj og l oh oi">  func work() {</span><span id="3204" class="mt mc it ob b gy oj og l oh oi">    // adult work</span><span id="9666" class="mt mc it ob b gy oj og l oh oi">  }</span><span id="92ac" class="mt mc it ob b gy oj og l oh oi">}</span><span id="17b9" class="mt mc it ob b gy oj og l oh oi">class Baby: EatAction {</span><span id="2450" class="mt mc it ob b gy oj og l oh oi">  func eat() {</span><span id="91a8" class="mt mc it ob b gy oj og l oh oi">    // baby eat</span><span id="7ce9" class="mt mc it ob b gy oj og l oh oi">  }</span><span id="dc61" class="mt mc it ob b gy oj og l oh oi">}</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="3c64" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">原则#5:依赖性倒置</h1><h2 id="8bed" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">依靠抽象，而不是具体</h2><p id="0228" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">高级模块不应该依赖低级模块。根据这个理论，像视图控制器这样的高级模块不应该直接依赖于像网络组件这样的低级组件。相反，它们应该依赖于抽象，或者使用一个快捷的术语，<em class="ok">协议。</em>这里的要点是减少耦合。</p><p id="710e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您的类严重依赖于另一个类的实现，就会发生耦合。耦合可能是危险的，因为它使得将来很难改变代码库。</p><p id="6529" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于大多数iOS工程师来说，Firebase是最喜欢使用的工具。比方说，Firebase将在明天关闭，没有任何提前通知。我们应该能够快速切换到Realm(例如)轻松部署我们的应用程序。这里的整个思想是通过避免紧密耦合来轻松替换我们的依赖性的能力。</p><h2 id="08e2" class="mt mc it bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">代码示例</h2><p id="62cd" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">下面代码的问题是高级模块<code class="fe ol om on ob b">DatabaseController</code>与低级模块<code class="fe ol om on ob b">NetworkRequest</code>紧密耦合。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="ed9b" class="mt mc it ob b gy of og l oh oi">class DatabaseController {</span><span id="4b56" class="mt mc it ob b gy oj og l oh oi">  private let networkRequest: NetworkRequest</span><span id="0e86" class="mt mc it ob b gy oj og l oh oi">  <br/>  init(network: NetworkRequest) {</span><span id="c61b" class="mt mc it ob b gy oj og l oh oi">    self.networkRequest = network</span><span id="8714" class="mt mc it ob b gy oj og l oh oi">  }</span><span id="db13" class="mt mc it ob b gy oj og l oh oi">  func connectDatabase() {</span><span id="c8b9" class="mt mc it ob b gy oj og l oh oi">    networkRequest.connect()</span><span id="12d8" class="mt mc it ob b gy oj og l oh oi">  }</span><span id="23e1" class="mt mc it ob b gy oj og l oh oi">}</span><span id="831e" class="mt mc it ob b gy oj og l oh oi">class NetworkRequest {</span><span id="d52c" class="mt mc it ob b gy oj og l oh oi">  func connect() {</span><span id="05e4" class="mt mc it ob b gy oj og l oh oi">    // connect to the database</span><span id="fc1a" class="mt mc it ob b gy oj og l oh oi">  }</span><span id="3509" class="mt mc it ob b gy oj og l oh oi">}</span></pre><p id="3163" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解决这个问题的方法可能是使用<code class="fe ol om on ob b">protocol</code>来避免紧耦合。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="1eb6" class="mt mc it ob b gy of og l oh oi">protocol Database {</span><span id="2a07" class="mt mc it ob b gy oj og l oh oi">  func connect()</span><span id="0fcb" class="mt mc it ob b gy oj og l oh oi">}</span><span id="db10" class="mt mc it ob b gy oj og l oh oi"><br/>class DatabaseController {</span><span id="7d52" class="mt mc it ob b gy oj og l oh oi">  private let database: Database</span><span id="c62c" class="mt mc it ob b gy oj og l oh oi">  <br/>  init(db: Database) {</span><span id="90bd" class="mt mc it ob b gy oj og l oh oi">    self.database = db</span><span id="7b3a" class="mt mc it ob b gy oj og l oh oi">}</span><span id="b860" class="mt mc it ob b gy oj og l oh oi">  func connectDatabase() {</span><span id="0596" class="mt mc it ob b gy oj og l oh oi">    database.connect()</span><span id="6643" class="mt mc it ob b gy oj og l oh oi">  }</span><span id="f3fd" class="mt mc it ob b gy oj og l oh oi">}</span><span id="90d2" class="mt mc it ob b gy oj og l oh oi">class NetworkRequest: Database {</span><span id="4961" class="mt mc it ob b gy oj og l oh oi">  func connect() {</span><span id="f796" class="mt mc it ob b gy oj og l oh oi">    // Connect to the database</span><span id="9d78" class="mt mc it ob b gy oj og l oh oi">  }</span><span id="aa67" class="mt mc it ob b gy oj og l oh oi">}</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="dca3" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">快速小结</h1><p id="7f0b" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">在你成为一名更好的工程师的旅程中，请记住以下坚实的原则。</p><ul class=""><li id="ebc8" class="nl nm it la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated">每个类应该只有一个责任</li><li id="4d93" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">该类应该对扩展开放，但对修改关闭</li><li id="a341" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">子类不应该破坏父类的类型定义</li><li id="3c9d" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">仅实施您需要的内容</li><li id="44b0" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">依靠抽象，而不是具体</li></ul></div></div>    
</body>
</html>