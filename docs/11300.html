<html>
<head>
<title>Caolan Asyncjs vs. Async/Await: What to Use for Async Operations in Node.js?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">曹兰Asyncjs与Async/Await:node . js中的异步操作使用什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/caolan-asyncjs-vs-async-await-what-to-use-for-async-operations-in-node-js-90307c73f12b?source=collection_archive---------14-----------------------#2022-03-07">https://betterprogramming.pub/caolan-asyncjs-vs-async-await-what-to-use-for-async-operations-in-node-js-90307c73f12b?source=collection_archive---------14-----------------------#2022-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="95c0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">异步/等待足够了吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7400c0b7ae9d9f9138dbe80aaea34063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fk8DgRZdp6PsC0r44BkQjg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=medium" rel="noopener ugc nofollow" target="_blank">费伦茨·阿尔马西</a>在<a class="ae kv" href="https://unsplash.com/s/photos/async-%2F-await?utm_source=medium&amp;utm_medium=medium" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="e08f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使用JavaScript的过程中，我们都曾在web开发旅程的某个时刻遇到过异步操作。在javaScript/nodeJS中有多种方法可以处理异步操作，可以使用回调、承诺或async/await。这为开发人员在代码方面提供了极大的灵活性，这也是为什么今天您仍然可以在现实世界的项目中找到不同的方法。</p><p id="6cdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果处理不好，异步操作可能会以最微妙的方式被证明是有害的。我们都知道回调地狱，对不对？</p><p id="faa9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将看看曹兰的<code class="fe ls lt lu lv b">asyncjs</code>库，它如何提供一种易于阅读的方式来处理nodeJS中的异步操作，以及通常的控制流是否仍然需要它。</p><h1 id="aa60" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">javascript中的异步操作</h1><p id="935d" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">nodeJS中的异步操作是不能立即返回结果的操作。例如，它可以是网络调用或数据库操作。</p><p id="b8d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为停止执行等待异步操作完成是没有意义的，所以回调和承诺来解决这个问题。</p><p id="1a62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用回调/承诺，我们告诉事件循环当异步操作的结果到达时做什么。</p><p id="f1e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回调/承诺被推到事件循环中，并在下一次迭代中被重新访问。如果异步操作在事件循环的下一次迭代前没有解决，则重复此过程。</p><p id="c7fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个使用异步操作的基于回调的方法示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b4a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，代码看起来不干净，功劳归于回调。如果你想了解更多关于回调和回调地狱，有一个完整的网站致力于此。点击查看<a class="ae kv" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4b75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着<code class="fe ls lt lu lv b">asyncjs</code>库的出现，这种情况得到了极大的改善。让我们看看<code class="fe ls lt lu lv b">asyncjs</code>库是如何提高可读性的。</p><h1 id="2c42" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">用asyncjs处理异步流</h1><p id="4492" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">该库提供了一种简单的方法来处理NodeJS中的异步函数。除了一个很好的数组和对象的函数集合之外，这个库还提供了各种控制流，让开发人员的工作变得简单。</p><p id="edfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Asyncjs</code>库也提供了对承诺和异步/等待的支持，但我将展示使用回调的例子。</p><h2 id="97c5" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">异步系列</h2><p id="178b" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">这个流允许您放置任意多的处理程序，它们将一个接一个地连续运行。一个的输出不依赖于前一个处理程序(不像<code class="fe ls lt lu lv b"><a class="ae kv" href="https://caolan.github.io/async/v3/docs.html#waterfall" rel="noopener ugc nofollow" target="_blank">async.waterfall</a></code>)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="49e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，两个异步函数串行运行，最后的回调包含一个数组，该数组包含这些函数的返回值。</p><p id="4725" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果任何函数中有错误，将不会执行进一步的处理程序，控件将直接跳转到最后一个抛出错误的回调函数。</p><blockquote class="nh ni nj"><p id="1d58" class="kw kx nk ky b kz la jr lb lc ld ju le nl lg lh li nm lk ll lm nn lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>输出数组将按照函数编写的顺序包含结果，而不考虑它们的执行时间。</p></blockquote><h2 id="9ae4" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">异步并行</h2><p id="3db2" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">当处理程序完全不相互依赖时，这个控制流就很方便了。你可以同时触发它们。</p><p id="ced4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并行执行意味着启动I/O任务(如果有的话),如果您的函数不执行任何I/O，那么这些函数将以同步方式串行运行。</p><p id="b01b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Javascript将<em class="nk">仍然</em>连续处理同步代码块。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b3c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，任何处理程序中的错误都会导致跳过所有剩余处理程序的执行。</p><h2 id="4716" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">异步竞赛</h2><p id="eefd" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">这与<code class="fe ls lt lu lv b">Promise.race</code>完全相似，最终回调的结果将来自首先调用回调的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="f7a3" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">使用异步/等待</h1><p id="5ba3" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们在上一节中看到的控制流可以使用async/await复制，而不需要asyncjs库。让我们使用async/await重新创建这些示例:</p><h2 id="6e03" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">异步系列</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1b52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设上面的代码块在一个异步函数中，我们很容易在这里复制了<code class="fe ls lt lu lv b">async.series</code>功能。</p><ol class=""><li id="83b1" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated">我们确保在<code class="fe ls lt lu lv b">asyncFnThatReturnsTwo</code>运行之前<code class="fe ls lt lu lv b">asyncFnThatReturnsOne</code>首先解析并返回结果。</li><li id="6b4f" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">最终结果数组与之前完全相同，即['一'，'二']。<code class="fe ls lt lu lv b">asyncFnThatReturnsOne</code>是否比<code class="fe ls lt lu lv b">asyncFnThatReturnsTwo</code>花费更长时间并不重要。</li><li id="cb84" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">我们使用try-catch块来捕捉错误。</li></ol><h2 id="636d" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">异步并行</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ca63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们并行启动两个异步函数，并将它们包装在<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank"> Promise.all </a>中。我们正在等待，瞧，我们得到了同样的结果！</p><h2 id="6790" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">异步竞赛</h2><p id="d345" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">类似地，我们可以使用承诺来重新创建一个竞赛场景，而不需要<code class="fe ls lt lu lv b">asyncjs</code>库:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8d60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，图书馆提供了一些好处，使它值得。有一点要记住，你可以自己定制解决方案，从头开始重新创建一切。但是，当已经有了一个完全符合你需要的库时，重新发明轮子通常不是一个好主意。</p><h1 id="9380" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">您可能仍然需要asyncjs</h1><p id="7ce7" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们已经看到了几个安装asyncjs库没有多大意义的场景。但是在其他用例中，asyncjs可以证明是有价值的，并且可以让您不用编写自己的定制解决方案。</p><h2 id="3721" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">异步队列</h2><p id="1ca9" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">这个队列实用程序帮助您编写一个工人函数，并提供一组由工人函数处理的任务。任务并行运行的最大限制称为并发限制。一旦运行的并发工作线程少于并发限制，任务就会被拾取。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e2a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随意调整<code class="fe ls lt lu lv b">concurrent_workers</code>的数字，看看它是如何影响正在处理的异步操作的。操场链接在<a class="ae kv" href="https://stackblitz.com/edit/caolan-async-queue-demo?devtoolsheight=33&amp;file=index.js" rel="noopener ugc nofollow" target="_blank">这里</a>可用。</p><p id="501a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这对于确保您不会试图并行运行超过CPU/磁盘能力的任务非常有用。请记住，并行方面仅适用于I/O和定时器。如果您的所有任务都有I/O，并且您正在并行运行无限数量的任务，那么您的服务器将会因为高磁盘I/O使用率和资源匮乏而崩溃。</p><p id="6249" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">async.queue</code>提供了一个很好的节流应用用例，因为它能够设置并行执行数量的最大上限。</p><blockquote class="nh ni nj"><p id="55b0" class="kw kx nk ky b kz la jr lb lc ld ju le nl lg lh li nm lk ll lm nn lo lp lq lr ij bi translated">看看<code class="fe ls lt lu lv b"><a class="ae kv" href="https://caolan.github.io/async/v3/docs.html#priorityQueue" rel="noopener ugc nofollow" target="_blank">async.priorityQueue</a></code>，它类似于<code class="fe ls lt lu lv b">async.queue</code>，但是提供了优先级机制来确保高优先级任务不会因为低优先级任务而被饿死。</p></blockquote><h2 id="72a9" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">异步重试</h2><p id="0666" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">有时，请求失败可能不是因为我们的应用程序的错误(例如，网络连接问题)。您可以使用<code class="fe ls lt lu lv b">async.retry</code>发出相同的请求X次，直到收到成功的响应。例如，尝试相同的请求3次，但失败了，这给了我们对服务行为的判断的确定性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="89ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们以100毫秒的间隔触发了<code class="fe ls lt lu lv b">someAPIMethod</code> 5次。如果任何方法成功，回调将立即被成功的<code class="fe ls lt lu lv b">result</code>调用。如果没有方法成功，回调将被错误调用。</p><p id="e255" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">asyncjs</code>中还有其他的控制流可以派上用场，你可以在这里查看它们<a class="ae kv" href="https://caolan.github.io/async/v3/docs.html#controlflow" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="5483" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="2a50" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">这是对<code class="fe ls lt lu lv b">asyncjs</code>库、它提供的一些控制流以及我们如何使用async/await复制相同的流的一个简短概述。我们还看了几个案例，在这些案例中使用<code class="fe ls lt lu lv b">asyncjs</code>确实很有帮助，可以让你避免重复劳动。</p><p id="ac30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望它能让您对这个库的好处有所了解，并让您知道在使用第三方解决方案之前，我们应该如何理解我们的具体用例(<a class="ae kv" href="https://github.com/Marak/colors.js/commit/074a0f8ed0c31c35d13d28632bd8a049ff136fb6#diff-92bbac9a308cd5fcf9db165841f2d90ce981baddcb2b1e26cfff170929af3bd1R18" rel="noopener ugc nofollow" target="_blank">有时一次提交就足够了</a>)。</p><p id="8565" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章最初发表在<a class="ae kv" href="https://rrawat.com/blog/asyncjs-in-nodejs" rel="noopener ugc nofollow" target="_blank">rrawat.com</a>上。</p><h1 id="adc3" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">接下来呢？</h1><p id="a3fb" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">asyncjs 的<a class="ae kv" href="https://caolan.github.io/async/" rel="noopener ugc nofollow" target="_blank">文档非常简单易懂。由于我们在本文中只看到了几个用例，我建议浏览一下<code class="fe ls lt lu lv b">asyncjs</code>文档，并查看一下库的其他可能性。你也可以尝试使用<code class="fe ls lt lu lv b">async/await</code>来复制同样的东西，以巩固你对这个库仍然有意义的地方的理解。</a></p><pre class="kg kh ki kj gt oc lv od oe aw of bi"><span id="dd32" class="mv lx iq lv b gy og oh l oi oj"><strong class="lv ir">Want more such articles?</strong></span><span id="cac8" class="mv lx iq lv b gy ok oh l oi oj">You can join my newsletter <a class="ae kv" href="https://buttondown.email/rishabh570" rel="noopener ugc nofollow" target="_blank">here</a>.</span><span id="b897" class="mv lx iq lv b gy ok oh l oi oj">I write about my learnings and experiences related to web development technologies biweekly.</span></pre></div></div>    
</body>
</html>