<html>
<head>
<title>Drop Pattern With Timeout in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中超时的丢弃模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/drop-pattern-with-timeout-in-go-29c41b0488b7?source=collection_archive---------3-----------------------#2022-09-09">https://betterprogramming.pub/drop-pattern-with-timeout-in-go-29c41b0488b7?source=collection_archive---------3-----------------------#2022-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="46e7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">简单看一下这个极其有用的功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c731abc45eb95a329acec067e6006c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S5hNosz0kx0_6LxpJJIuoQ.jpeg"/></div></div></figure><p id="7aa1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常，服务器端系统的规模可以处理预期数量的传入请求。如果设计是正确的，向服务器发送请求的客户机在正常工作条件下，在特定系统可接受的延迟内收到响应。</p><p id="6103" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，有时工作条件会变得不正常。数据库会降低其性能，网络变慢，并且突然出现请求高峰。</p><p id="3456" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，请求开始在队列中堆积，客户端经历响应延迟，最终整个系统可能崩溃。</p><p id="c1bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，系统“抵制数据流”这种现象称为<a class="ae lq" href="https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7" rel="noopener">背压</a>。</p><p id="1a85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这与交通拥挤时高速公路上发生的现象相同。只要不发生事故或者汽车密度低于某个阈值，汽车就会以合理的速度流动。事故一发生，汽车就开始排队。即使在道路清理完毕后，这些长队还会持续很长时间，尽管我们可能经历过堵在高速公路中间的烦恼。</p><p id="2b38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们对汽车和高速公路无能为力，但有了IT系统，我们可以在异常情况发生时找到减少损失的策略。一种这样的策略是所谓的“超时丢弃模式”，这意味着如果请求等待的时间太长，就取消请求。</p><p id="86a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们更详细地看看这种模式是如何工作的，并使用Go举例说明这种模式的一种可能的实现。</p><h1 id="55ff" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">队列和延迟传播</h1><p id="6ded" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">让我们考虑一个理想的系统，其中服务器的大小可以响应不断传入的请求。</p><p id="9965" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说，具有以下特征:</p><ul class=""><li id="bc8b" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp mt mu mv mw bi translated">服务器可以服务一个执行时间为<code class="fe mx my mz na b">E</code>的请求</li><li id="9885" class="mo mp it kw b kx nb la nc ld nd lh ne ll nf lp mt mu mv mw bi translated">请求到达的时间间隔等于<code class="fe mx my mz na b">E</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/99226359909f047483156dfa2913a009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lAvz8M_rTX9NKnkbYBVJ6Q.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">一种系统，其大小正好能以指定的延迟响应请求</p></figure><p id="d2bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，如果服务器在一段时间内停止响应，一旦它再次运行，就会有一个请求队列等待处理。因为，在这个理想的场景中，每个请求需要<code class="fe mx my mz na b">E</code>时间来执行和产生响应，在停止之后，客户端将经历<code class="fe mx my mz na b">E+S</code>的响应时间，这意味着与正常情况相比有<code class="fe mx my mz na b">S</code>的延迟。同样重要的是，在问题出现后，这种延迟对于所有到达服务器的请求都将保持不变，并且永远不会减少。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/50e894924899e5cda47fba3519219377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3UKiNZXyZ9g13gX7CIseIA.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">服务器的停止会产生一个随时间传播的延迟</p></figure><p id="ad22" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个极端的例子，但有助于说明这样一个事实:如果我们什么都不做，事故的负面影响可能会在事故解决后很长时间内传播(事故解决后几个小时，你可能会在高速公路上排队)。</p><h1 id="8227" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">暂停救援</h1><p id="ecd8" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">减轻这些长期负面影响的常用策略之一是引入超时。如果请求在队列中停留的时间超过了一定的限制(超时)，该请求将被终止并从队列中删除。</p><p id="52ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是以一些请求失败为代价的，一些客户端会收到超时错误消息，但它带来的好处是当正常工作条件重新建立时，限制了所有其他客户端的延迟。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/3efc4e5e4752fd4cf1fe443c4602ba97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3a5tjpp2jMFNo2mzEW85Q.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">超时表示请求可以拥有的最大响应时间</p></figure><p id="70aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的理想情况下，如果我们设置一个等于<code class="fe mx my mz na b">TO</code>的超时，在事件被解决后进入的请求将经历最多等于<code class="fe mx my mz na b">TO</code>的响应时间(如果是<code class="fe mx my mz na b">TO &lt; E+S</code>，这比前面的情况有所改进)。</p><p id="8b48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是“超时丢弃模式”的工作原理。</p><h1 id="8b29" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">Go中超时的丢弃模式</h1><p id="84af" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">使用通道、上下文和goroutines可以在Go中实现“超时丢弃模式”。这个模式实现的所有代码都可以在<a class="ae lq" href="https://github.com/EnricoPicci/drop-pattern-with-timeout/tree/master/" rel="noopener ugc nofollow" target="_blank">这个repo </a>中找到。</p><h2 id="85a1" class="nn ls it bd lt no np dn lx nq nr dp mb ld ns nt md lh nu nv mf ll nw nx mh ny bi translated">起作用的因素</h2><p id="9852" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">要查看“超时丢弃模式”的运行情况，我们需要三个基本要素:</p><ul class=""><li id="22ed" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp mt mu mv mw bi translated">能够以一定吞吐量处理请求的服务器</li><li id="a183" class="mo mp it kw b kx nb la nc ld nd lh ne ll nf lp mt mu mv mw bi translated">我们希望服务器处理的请求的生成器</li><li id="6030" class="mo mp it kw b kx nb la nc ld nd lh ne ll nf lp mt mu mv mw bi translated">类似于位于中间的等候室，实现“超时丢弃模式”逻辑</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/dfc2fc39eda20e1964d39d62e69e6ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ozQ0a7V0cUOwdMduAfz8rQ.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">起作用的因素</p></figure><p id="2a8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们更详细地看看这些元素。</p><h2 id="d015" class="nn ls it bd lt no np dn lx nq nr dp mb ld ns nt md lh nu nv mf ll nw nx mh ny bi translated">工人池服务器</h2><p id="680c" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们将使用一个工作池来实现一个可以并发服务请求的服务器(服务器是一个工作池的事实与模式无关，它只是实现服务器的一种常见方式)。</p><p id="470d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">工人池是按照标准的Go模式实现的。启动一组goroutines，每个实现一个worker。每个工作者在池的输入通道的接收端循环，<code class="fe mx my mz na b">reqCh</code>。</p><p id="b9da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">工人一收到请求，就开始处理它。当一个请求的处理完成时，worker返回到输入通道<code class="fe mx my mz na b">reqCh</code>上的receive，准备开始处理一个新的请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/1d65e24288f07e9c4cbf027a60811be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UYTS_jK4WXzd3G-VDVQN0Q.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">工人池</p></figure><p id="8b5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实现工人池的代码可以在<a class="ae lq" href="https://github.com/EnricoPicci/drop-pattern-with-timeout/tree/master/src/workerpool" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="548c" class="nn ls it bd lt no np dn lx nq nr dp mb ld ns nt md lh nu nv mf ll nw nx mh ny bi translated">“超时丢弃模式”的实现</h2><p id="7d2a" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">“带超时的丢弃模式”核心的实现基于带超时的<code class="fe mx my mz na b">context</code>和强大的<code class="fe mx my mz na b">select</code> on channels语句的使用。在示例代码中，逻辑是由<code class="fe mx my mz na b">WaitingRoom</code>类型实现的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/31ddca0c7c48b079ecefabe0525047d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*plhlYeTXLOZ_iIjes0GiPQ.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">等候室实施“超时丢弃模式”</p></figure><p id="c831" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">必须进入等候室的请求被发送到其输入通道<code class="fe mx my mz na b">inCh</code>。驱动等候室工作的goroutine从该通道中读取数据，并为每个请求启动一个新的goroutine，启动<code class="fe mx my mz na b">sendOrDrop</code>功能，其中实现了“超时丢弃模式”的核心逻辑。</p><p id="1674" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于每个请求，<code class="fe mx my mz na b">sendOrDrop</code>函数创建一个超时的<code class="fe mx my mz na b">context</code>，然后在通道上运行<code class="fe mx my mz na b">select</code>语句。</p><p id="ca48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第一种情况下,<code class="fe mx my mz na b">select</code>检查工作池输入通道上的发送,<code class="fe mx my mz na b">reqCh</code>是否完成。如果请求完成，池中的一个工作线程已经收到请求，并将处理它。</p><p id="0ec0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第二种情况使用<code class="fe mx my mz na b">select</code>检查<code class="fe mx my mz na b">context</code>的<code class="fe mx my mz na b">Done</code>通道是否关闭。如果发生这种情况，这意味着在请求能够被池接收之前，超时已经过期，因此，请求必须被丢弃。</p><p id="35a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实现<code class="fe mx my mz na b">WaitingRoom</code>的代码可以在这里找到<a class="ae lq" href="https://github.com/EnricoPicci/drop-pattern-with-timeout/tree/master/src/waitingroom" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="9c17" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">请求生成器</h1><p id="94b6" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">请求生成器可以是生成请求的任何东西，从REST端点到接收消息的队列。</p><p id="a25c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的例子中，为了简单起见，我们有一个简单的Go函数，它生成请求并将它们发送给<code class="fe mx my mz na b">WaitingRoom</code>。</p><h1 id="182b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">最终的画面</h1><p id="c220" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">因此，使用两个通道实现“带超时的丢弃模式”，一个作为<code class="fe mx my mz na b">WaitingRoom</code>的输入，一个作为服务器的输入(以及作为<code class="fe mx my mz na b">WaitingRoom</code>本身的输出)，带超时的<code class="fe mx my mz na b">context</code>和<code class="fe mx my mz na b">select</code> on channels语句，所有这些都由goroutines提供的并发性支持。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/34c3f4915e9f24936457cc7ce011bb64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L8a-CATBkXVTA4ccCz2V3w.png"/></div></div></figure><p id="493c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">“超时丢弃模式”的一个工作示例在<a class="ae lq" href="https://github.com/EnricoPicci/drop-pattern-with-timeout/tree/master/" rel="noopener ugc nofollow" target="_blank">这个回购</a>中实现。</p></div></div>    
</body>
</html>