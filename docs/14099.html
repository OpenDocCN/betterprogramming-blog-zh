<html>
<head>
<title>Generate Code Coverage Checks In Pull Requests and Coverage Badges in the Repository</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在库中的拉请求和覆盖率标记中生成代码覆盖率检查</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/coverage-checks-in-prs-coverage-badges-in-repository-249dc6bd7e0?source=collection_archive---------6-----------------------#2022-11-05">https://betterprogramming.pub/coverage-checks-in-prs-coverage-badges-in-repository-249dc6bd7e0?source=collection_archive---------6-----------------------#2022-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7e49" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何编写一个脚本来自动完成这项任务</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d01ab75866a88d13d377142eb39fdf28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D6kAiGjENsuH9bf7"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@olloweb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">通讯社跟随</a>于<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="c4db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎阅读我关于代码覆盖率的第二篇文章。在<a class="ae kv" href="https://medium.com/@meliksahcakirr/unit-tests-and-coverage-reports-in-multi-package-flutter-project-5b0ce47d2fc2" rel="noopener">第一篇文章</a>中，我试图解释如何为多模块颤振项目创建代码覆盖报告。在这一篇中，我将展示一个平台无关的解决方案，用于在拉请求中创建覆盖率检查，并向您的存储库中添加一个漂亮的覆盖率标记。️​</p><p id="1ee7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">剧透警报！如果你把文章看完，你会得到类似下面的东西:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/82aad52ace7101708d54ec56fdf0e9b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3G13Y6ekaY-KFeYjmfxxw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">README.md文件中的承保范围徽章</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/88002397ab9a626d5a64b6a445fe5f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*11ps29DJcWHrNZtcj5926w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">拉动式请求中的附加覆盖范围检查</p></figure><h1 id="1e69" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">先决条件</h1><p id="e428" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在深入研究解决方案之前，我必须假设几件事:</p><ol class=""><li id="b6fd" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">您拥有一个包含全部代码覆盖率信息的文件。不管是Android项目，还是Flutter项目，还是别的什么都无所谓。只要你有一个综合的覆盖率结果，你就可以了。从现在开始，我把这个文件称为<code class="fe na nb nc nd b">&lt;COVERAGE_FILE&gt;</code>。</li><li id="3410" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated">您可以访问专用云存储。它可以是谷歌云存储，S3桶，或任何其他你可以上传文件并通过CLI获取的存储。在本文中，我将使用<a class="ae kv" href="https://cloud.google.com/sdk/gcloud" rel="noopener ugc nofollow" target="_blank"> google cloud CLI工具</a>来上传/下载我们的覆盖报告和我们的覆盖徽章。</li></ol><h1 id="e32e" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">步骤1:文件解析和获取覆盖率</h1><p id="0a31" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在文章的开始，我假设您已经生成了您的<code class="fe na nb nc nd b">&lt;COVERAGE_FILE&gt;</code>。我们必须能够在我们的自定义脚本中解析该文件，以便我们可以在我们的覆盖率徽章和PRs中使用该百分比。</p><p id="3e6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您有一个这样的文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">覆盖报告的一个例子</p></figure><p id="4421" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们必须读取文件，确定<code class="fe na nb nc nd b">GLOBAL</code>下的行，并解析该行中“%”字符之前的覆盖率值。下面的神奇代码为我们做到了这一点:</p><pre class="kg kh ki kj gt nl nd nm nn aw no bi"><span id="9faa" class="np lv iq nd b gy nq nr l ns nt">line=$(grep 'GLOBAL' -A1 $COVERAGE_FILE | grep -v 'GLOBAL')<br/>coverage=$(echo "$line" | cut -d'%' -f 1)</span></pre><h1 id="0d62" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">步骤2:生成覆盖徽章</h1><p id="51d6" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在上一步中，我们获得了代码覆盖率。现在，我们想使用这个值创建一个徽章。如果您也想给徽章添加一些颜色，您可以执行以下操作:</p><pre class="kg kh ki kj gt nl nd nm nn aw no bi"><span id="bcd2" class="np lv iq nd b gy nq nr l ns nt">if (( $(echo "$coverage &lt;= 50" | bc -l) )) ; then<br/>  color=red<br/>elif (( $(echo "$coverage &gt; 80" | bc -l) )); then<br/>  color=green<br/>else<br/>  color=orange<br/>fi</span></pre><p id="6603" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们已经准备好了<code class="fe na nb nc nd b">coverage</code>和<code class="fe na nb nc nd b">color</code>变量。为了创建一个可爱的徽章，我们将使用一个开发者友好的<a class="ae kv" href="https://shields.io/category/coverage" rel="noopener ugc nofollow" target="_blank"> shield.io </a> API。我们唯一需要做的是:</p><pre class="kg kh ki kj gt nl nd nm nn aw no bi"><span id="e94a" class="np lv iq nd b gy nq nr l ns nt">curl "<a class="ae kv" href="https://img.shields.io/badge/coverage-$coverage%25-$COLOR" rel="noopener ugc nofollow" target="_blank">https://img.shields.io/badge/coverage-$coverage%25-$</a>color" &gt; coverage_badge.svg</span></pre><p id="5eca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开始了。我们创造了我们的徽章。如果您在本地机器上运行这些命令，您现在应该在您的目录中看到<code class="fe na nb nc nd b">coverage_badge.svg</code>文件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/919a8cddfc55a90bb2f3dfc669982fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*yQxGz-dvzmV4_uAy5cK8zA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">coverage_badge.svg</p></figure><h1 id="e079" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">步骤3:上传徽章和<coverage_file/></h1><p id="06d2" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">至此，我们已经准备好了以后需要用到的一切。为了在未来访问这些文件，我们必须将它们存储在云中。我更喜欢使用谷歌云存储，但这个选择完全取决于你。我们在这里要做的事情也与该工具类似。</p><p id="944b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在Google云存储中创建我们的存储桶。在创建它的时候，我们必须考虑一些重要的事情。首先，我们不想“在这个桶上实施公共访问预防”相反，我们将选择“细粒度”访问控制，因为在确保我们的<code class="fe na nb nc nd b">&lt;COVERAGE_FILE&gt;</code>是私有的同时，我们希望让<code class="fe na nb nc nd b">coverage_badge.svg</code>公开。</p><p id="c944" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建bucket之后，我们需要生成一个服务帐户，以便稍后访问这个bucket。同样，我们必须确保为服务客户提供正确的角色。否则，我们无法从脚本中控制文件的可见性。我们必须添加存储对象管理员、存储对象创建者、存储查看者和存储管理员。创建新的服务帐户后，我们可以下载<code class="fe na nb nc nd b">service_account.json</code>文件，并在建立身份验证时使用它。</p><pre class="kg kh ki kj gt nl nd nm nn aw no bi"><span id="4221" class="np lv iq nd b gy nq nr l ns nt">echo "---- Authenticating google cloud ----"<br/>gcloud auth activate-service-account -q --key-file service_account.json</span></pre><p id="530d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果认证成功，我们可以继续文件上传部分。下面，您可以看到上传文件的必要命令:</p><pre class="kg kh ki kj gt nl nd nm nn aw no bi"><span id="959e" class="np lv iq nd b gy nq nr l ns nt">echo "---- Uploading badge to Google Cloud Storage ----"<br/>gsutil -h "Cache-Control: no-cache" cp coverage_badge.svg gs://$BUCKET_NAME/coverage_badge.svg<br/>gsutil acl ch -u AllUsers:R gs://$BUCKET_NAME/coverage_badge.svg</span><span id="c815" class="np lv iq nd b gy nv nr l ns nt">echo "---- Uploading coverage result to Google Cloud Storage ----"<br/>gsutil cp $COVERAGE_FILE gs://$BUCKET_NAME/$COVERAGE_FILE</span></pre><p id="3d14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所注意到的，我们正在上传文件。但是，我们也修改了徽章文件的访问控制列表(ACL)。要在我们的<code class="fe na nb nc nd b">README.md</code>文件中看到生成的徽章，我们必须给每个人读权限。此外，为了在我们的存储库中拥有徽章的更新版本，我们需要在命令中添加<code class="fe na nb nc nd b">no-cache</code>头。</p><p id="2c97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您到达这里并运行您的脚本，您将在您的bucket中看到这两个文件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/2ae95c206888de4f00e6c7e19d084df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2RamImG003momHYY1MTAKQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">桶中的文件</p></figure><p id="01bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您看到文件已经上传到存储器，您可以检索徽章文件的公共URL。要在您的存储库中显示这个，您需要将URL添加到<code class="fe na nb nc nd b">README.md</code>文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">README.md文件</p></figure><p id="9f5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是目前为止的整体脚本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="a878" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">步骤4:将脚本添加到CI / CD主工作流</h1><p id="b752" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在这里，我不会深入研究具体的CI / CD工具，如Bitrise、GitHub Actions等。相反，我将解释工作流的一般行为。</p><p id="e268" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，您可以通过在本地运行脚本来确保脚本运行无误。如果一切正常，我们可以将此步骤添加到CI/CD工作流中。</p><p id="cacf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当一个新的提交被推送到我们的默认分支，比如<code class="fe na nb nc nd b">main</code>，我们都希望运行这个脚本。每当一个新的PR被批准并与这个分支机构合并时，我们希望更新我们的云存储中现有的覆盖徽章和覆盖报告。因此，此工作流的一般图表如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/87f58e596dcce636fa48c359699eb801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IlJH_cZZTNtlNsYXuKjcJA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">主分支推送工作流</p></figure><h1 id="af09" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">步骤5:代码覆盖率比较的另一个脚本</h1><p id="2dcd" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在这一步中，我们想要创建另一个脚本来解析<code class="fe na nb nc nd b">&lt;COVERAGE_FILE&gt;</code>，就像我们之前在步骤3中所做的那样。并且还必须下载云存储中已有的<code class="fe na nb nc nd b">&lt;COVERAGE_FILE&gt;</code>并再次解析。因此，最终，我们将拥有主请求代码和拉请求代码。您可以根据这些值更新GitHub状态，并确定<code class="fe na nb nc nd b">COVERAGE_THRESHOLD</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9881" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你在最后一部分看到的，我们又创建了两个变量:<code class="fe na nb nc nd b">STATE</code>和<code class="fe na nb nc nd b">DESC</code>。这可以在GitHub状态更新步骤中使用。</p><h1 id="4090" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">步骤6:将脚本添加到配置项/光盘提取请求工作流</h1><p id="8370" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">与前面的工作流不同，每当针对我们的默认分支<code class="fe na nb nc nd b">main</code>创建新的拉请求时，我们都要运行这个脚本。每当一个新的PR被创建时，我们想要检查新的代码覆盖率是否小于整个代码覆盖率或者甚至小于<code class="fe na nb nc nd b">COVERAGE_THRESHOLD</code>。因此，此工作流的一般图表如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/aa9f2d53070e902a5ea089d7a88cc315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D6ThjZjy1JkDLox9IBHh6Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">主分支拉式请求工作流</p></figure><p id="b91d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果您现在根据默认分支创建一个PR，您将在您的PR状态中看到第二个检查:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/a2d41f2d13455a9b74ed92c7e7ae0a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W-rMTt2afjbGM2vNQmybvA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">覆盖范围登记申请</p></figure></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="ce0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">恭喜你，你坚持到了最后！有点长。</p><p id="ada3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你会对这篇文章感兴趣，并且它会对你的这次冒险有所启发。</p><pre class="kg kh ki kj gt nl nd nm nn aw no bi"><span id="61ac" class="np lv iq nd b gy nq nr l ns nt"><strong class="nd ir">Want to Connect?</strong></span><span id="8c93" class="np lv iq nd b gy nv nr l ns nt">Feel free to ask for more information if needed. You can also connect with me on <a class="ae kv" href="http://www.linkedin.com/in/meliksahcakir" rel="noopener ugc nofollow" target="_blank">LinkedIn</a> ☺️.</span></pre></div></div>    
</body>
</html>