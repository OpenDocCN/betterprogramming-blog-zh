<html>
<head>
<title>A Cloud Data Migration Framework on APIs Using Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用容器的API云数据迁移框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-cloud-data-migration-framework-on-apis-leveraging-containers-aa4495bcae29?source=collection_archive---------15-----------------------#2020-01-31">https://betterprogramming.pub/a-cloud-data-migration-framework-on-apis-leveraging-containers-aa4495bcae29?source=collection_archive---------15-----------------------#2020-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="79af" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更好地迁移，更安全地迁移</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1464a65e146ae88bc77ddfdf2f6d95b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxR-XlqYYbdj4A2UzcfO5Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:桑基特·纳伊克</p></figure><p id="b0cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着我们从单个集群发展到跨越不同云提供商的多个集群，有时出于真正的需求，有时出于突发奇想，我们需要一种方法来跨集群移动客户及其相关数据或重新组织它们。我们评估了多种ETL解决方案，但是没有一种能够满足我们的需求，因为客户的数据分散在基于SQL和基于NoSQL的技术中。</p><p id="59ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">慢慢地，但稳步地，我们开始意识到这项工作将是多么艰巨。这时我们意识到，我们必须在API级别解决这个问题，而不是在数据存储级别。随着我们进一步探索这个想法，我们开始花时间分析我们的应用程序部署结构，随着时间的推移，它已经从单块服务有机地发展到多个微服务，并随着我们的工作进行分区。这提供了一个独特的机会，也是一个挑战。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="d96c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">应用程序</h1><p id="2455" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">每个应用程序(部署的逻辑单元)使用管理它的开发人员认为最适合他们需求的技术来管理它自己的数据。</p><p id="4a06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个应用程序:</p><ul class=""><li id="3e56" class="my mz it la b lb lc le lf lh na ll nb lp nc lt nd ne nf ng bi translated">管理自己的数据</li><li id="f551" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">最了解为每个客户存储了什么数据，并且是如何导出和接收数据的最佳判断者</li><li id="ec08" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">负责管理数据的生命周期，因此最适合迁移数据</li></ul><p id="115a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们要求每个应用程序团队提出一个或多个API，这些API可以分为以下几类:</p><ul class=""><li id="43c7" class="my mz it la b lb lc le lf lh na ll nb lp nc lt nd ne nf ng bi translated">用于数据转换的元数据API</li><li id="a134" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">每个客户的导出数据</li><li id="b6df" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">导入每个客户的数据</li></ul><p id="66ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们将迁移过程分为以下几个阶段:</p><ol class=""><li id="8e4e" class="my mz it la b lb lc le lf lh na ll nb lp nc lt nm ne nf ng bi translated">迁移前</li><li id="32d8" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nm ne nf ng bi translated">出口</li><li id="b525" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nm ne nf ng bi translated">获取元数据</li><li id="4da9" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nm ne nf ng bi translated">转换</li><li id="2584" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nm ne nf ng bi translated">吸收</li><li id="45b9" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nm ne nf ng bi translated">确认</li><li id="4eed" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nm ne nf ng bi translated">迁移后</li><li id="70a2" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nm ne nf ng bi translated">清理</li></ol><p id="2d8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个应用程序将负责挂钩到各自的阶段，负责定义处理故障的步骤和补偿步骤，并负责恢复迁移过程。</p><p id="af33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">细心的读者应该已经注意到，这些迁移阶段将分布在不同的集群中，需要跨集群的数据访问来执行迁移过程。为此，我们决定使用S3自动气象站。</p><p id="95c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本质上，迁移过程是一个小型迁移<strong class="la iu">步骤</strong>、<strong class="la iu">、</strong>跨越<strong class="la iu">阶段</strong>、<strong class="la iu">、</strong>跨越不同<strong class="la iu">集群</strong>(源和目的地)的编排，其中每个应用都对迁移过程有贡献。我们有<strong class="la iu">补偿步骤</strong>在每一级关联，以便能够回滚我们的迁移过程。</p><p id="5f33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个<code class="fe nn no np nq b">Step</code>将迁移过程中的一个逻辑步骤总结为一个特定的阶段。所有必要的参数都是上下文的一部分，上下文只不过是一个变量状态。下面的Python片段是一个步骤的代表性实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b968" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nn no np nq b">StepExecutor</code>是步骤的容器，允许在正常步骤执行失败的情况下，关联步骤定义和补偿步骤。下面的Python片段是一个步骤执行器的代表性实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="f541" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意<code class="fe nn no np nq b">rollback</code>旗。<code class="fe nn no np nq b">Rollback</code>引入了标记，以便在默认回滚失败的情况下重试<code class="fe nn no np nq b">rollback</code>。</p><p id="fd71" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于以上部分，我们引入了一个目录，它允许轻松访问<code class="fe nn no np nq b">Step</code> s。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5ab3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了这些基础部分，我们就能够提供一个通用框架，以分阶段的方式组织每个应用程序的数据迁移流程，更像是数据迁移的工作流。</p><p id="c81c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了说明这一点，下面是一个示例应用程序的示例数据迁移流程片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="0575" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">集装箱化</h1><p id="8a90" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">一旦创建了每个应用程序的数据迁移工作流，合乎逻辑的下一步就是在集群中部署这些工作流。我们选择了集装箱路线。</p><p id="ca08" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们为每个应用程序创建了容器图像，这些图像被推送到注册中心。我们为数据迁移过程维护了一个JSON文件，其中每个应用程序都必须注册一个阶段，并指定映像名称和版本。为了便于说明，您可以在下面找到一个示例JSON文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2867" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了JSON作业定义，我们所做的就是控制Jenkins作业的迁移过程，提供源集群、目的集群和客户id作为输入，加上一些其他的控制参数(为了简洁起见省略了)作为输入。</p><p id="c9b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">容器的选择使我们的清理过程变得简单，我们能够从Jenkins管理非常复杂的分布式编排，并能够回滚和重试迁移。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="9c36" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是的，作为API层迁移框架的明显缺点是它不能很快，不能处理大量数据。但它很好地满足了我们的需求，因为我们需要在不停止群集的情况下将客户从一个群集转移到另一个群集的能力，只需阻止正在迁移的特定客户即可。</p><p id="4113" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p></div></div>    
</body>
</html>