<html>
<head>
<title>AsyncResourceView — Simplified Resource Loading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AsyncResourceView —简化的资源加载</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/asyncresourceview-558ec1f49ea2?source=collection_archive---------13-----------------------#2022-03-16">https://betterprogramming.pub/asyncresourceview-558ec1f49ea2?source=collection_archive---------13-----------------------#2022-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d81b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建异步SwiftUI应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c0b34f1cf1a7cdc092d5c6562a42a913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mpfYsMs-rHqlFPvDzmwvDw.png"/></div></div></figure><p id="3e84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">今天，我们将看看如何在SwiftUI应用程序中处理异步数据。现代应用严重依赖于通过网络接收的资源，因此可能会受到连接问题或数据丢失的影响。例如，如果你在德国境内乘火车旅行，你可能会惊讶地发现，由于手机信号接收微弱，你会经常遇到无线电信号中断的情况。</p><p id="3ef8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，作为开发人员，我们必须设计我们的应用程序，当一个动作花费的时间比预期的长时，要包括反馈，并在失败的情况下提供重试该动作的能力。这样，我们可以让我们的应用程序脱颖而出，因为它们可以应对远非最佳的条件。</p><p id="e310" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文介绍了可重用的组件<code class="fe ln lo lp lq b">AsyncResourceView</code>,它抽象了获取异步数据时的加载和失败状态，这样我们就可以专注于特性，而不是编写重复的容易出错的代码。</p><p id="d889" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以在GitHub上查看这个项目(<a class="ae lr" href="https://github.com/LinkAndreas/AsyncResourceView" rel="noopener ugc nofollow" target="_blank">链接</a>)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/c5582e9933c9f8f12741717f77174d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2DBKZMlzUyZyEmoCWnxcBA.gif"/></div></div></figure><h1 id="327c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">查看商店</h1><p id="6120" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">首先，让我们实现负责驱动UI的<code class="fe ln lo lp lq b">AsyncResourceViewStore&lt;Resource&gt;</code>。给定加载程序，商店最初保持在<code class="fe ln lo lp lq b">notRequested</code>状态，直到<code class="fe ln lo lp lq b">loadResource</code>被调用并且进入<code class="fe ln lo lp lq b">loading</code>状态。最后，根据操作结果，进入<code class="fe ln lo lp lq b">success</code>或<code class="fe ln lo lp lq b">failure</code>状态。</p><p id="7538" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，商店独立于SwiftUI，将来可能会与替代的UI框架一起使用。此外，我们使用<code class="fe ln lo lp lq b">@MainActor</code>注释来确保状态变化只发生在主线程上:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="bca1" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">测试</h1><p id="5a84" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">尽管它的实现看起来很简单，但让我们包含单元测试，以确保我们将来可以自由地重构商店，而不会改变它的行为。</p><p id="4edb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一，店铺要处于<code class="fe ln lo lp lq b">notRequested</code>状态。<code class="fe ln lo lp lq b">makeSUT</code>助手用一个加载器存根实例化了<code class="fe ln lo lp lq b">AsyncResourceViewStore</code>，这样我们就可以在断言预期行为时控制其结果。</p><p id="02ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二，当资源加载成功时，我们期望商店进入<code class="fe ln lo lp lq b">success</code>状态。类似地，如果资源加载失败，我们期望商店进入<code class="fe ln lo lp lq b">failure</code>状态。</p><p id="d60c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们还希望商店在资源加载最初失败但后来成功后进入<code class="fe ln lo lp lq b">success</code>状态。这样，我们可以确保用户在失败的情况下可以选择重试操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="f90f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">视角</h1><p id="66d1" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">完成存储后，让我们继续使用特定于状态的闭包来呈现其子元素的<code class="fe ln lo lp lq b">AsyncResourceView</code>。虽然<code class="fe ln lo lp lq b">notRequested-</code>、<code class="fe ln lo lp lq b">failure-</code>和<code class="fe ln lo lp lq b">loading-</code>视图是可选的，但是我们需要指定给定资源的<code class="fe ln lo lp lq b">success</code>视图。这样，我们就可以分解复杂性，并且只需要同时处理一个状态，而不是多个状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="7f2f" class="ms lu iq bd lv mt mu dn lz mv mw dp md la mx my mf le mz na mh li nb nc mj nd bi translated">asynccresourcedefaultnotrequestedview</h2><p id="2dde" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">例如，使用<code class="fe ln lo lp lq b">notRequested</code>视图，我们可以指定在请求资源之前UI应该是什么样子。请注意，默认表示是不可见的，仅用于在出现时触发回调。取而代之的是，我们也可以想到一个可视化的表示，它有一个按钮，让用户决定何时运行操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="0366" class="ms lu iq bd lv mt mu dn lz mv mw dp md la mx my mf le mz na mh li nb nc mj nd bi translated">asynccresourcedefaultloadingview</h2><p id="4328" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">相反，默认的<code class="fe ln lo lp lq b">loading</code>视图是可见的，并且将指示进度，直到进入<em class="ne">成功</em>或<em class="ne">故障状态</em>为止。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/016f4dd2233844a6c45c7850ab235531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/1*IYPu-2a7D6ZkXbg-M6iFIA.gif"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="734d" class="ms lu iq bd lv mt mu dn lz mv mw dp md la mx my mf le mz na mh li nb nc mj nd bi translated">asynccresourcedefaultfailureview</h2><p id="a824" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">最后，如果不存在<code class="fe ln lo lp lq b">failure</code>闭合，则<code class="fe ln lo lp lq b">AsyncResourceDefaultFailureView</code>会呈现一个逆时针箭头，以在失败时重试该动作。请注意，自定义视图也可能会考虑该错误，以提供有关操作未按预期工作的原因的附加信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/bb563e56586781467fe35523c017a273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T55XkNBiAku--NAFS_zdjg.png"/></div></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="fb4b" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">试映</h1><p id="285a" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">毫无疑问，SwiftUI相对于UI Kit的一大优势就是我们可以获得渲染是如何构成的实时反馈。在处理交互式预览时，尤其如此，交互式预览提供了对组件的外观和感觉的深刻见解。随后，您可以找到静态和交互式预览的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="4487" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">静态预览基于商店的预定义状态呈现自身，而交互式预览与加载器显式通信，并等待直到产生结果。因为加载器可能会失败，所以我们抛出一个骰子并返回资源(即“Hello World”)或一个错误。后者将导致失败状态，我们可以在不离开预览的情况下重试操作。</p><h1 id="85ce" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">用例示例:“颜色库”</h1><p id="dac2" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">为了可视化组件的使用方式，让我们实现一个颜色库，其中的项目排列在一个三列网格中。每个项目都有一个<code class="fe ln lo lp lq b">AsyncResourceView</code>来请求加载程序的颜色，加载程序要么返回一个随机的颜色，要么在[0.3，3.0]秒后失败。如上所述，如果操作失败，会显示一个重试按钮。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/cd6c8c2771df77a8e1463bf05ddcd5ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lekRUYime0Bxt1iPa1qmpQ.gif"/></div></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="3db5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们没有指定定制的<code class="fe ln lo lp lq b">notRequested</code>视图，所以使用默认视图，它一出现就请求资源。通过将项目包装在SwiftUI的<code class="fe ln lo lp lq b">LazyVGrid</code>中，它们仅在需要时被创建。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="669c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每一个项目都由它自己的存储驱动，即<code class="fe ln lo lp lq b">AsyncResourceViewStore</code>根据动作花费的时间在状态之间转换。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="5186" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们创建一个<code class="fe ln lo lp lq b">GalleryStore</code>来驱动合成，并为每个单独的加载器提供一种颜色。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="9fa2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="1003" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">在本文中，我介绍了<code class="fe ln lo lp lq b">AsyncResourceView</code>，这是一种在SwiftUI应用程序中处理异步资源的一致方法。</p><p id="75e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用该组件，我们可以避免重复的代码，并将更多的时间花在实现功能上，而不是在整个应用程序中编写相同的加载或错误处理代码。</p><p id="13d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">快乐编码。</p></div></div>    
</body>
</html>