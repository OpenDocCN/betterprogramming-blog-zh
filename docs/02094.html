<html>
<head>
<title>Stop Using i++ in Your Loops</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止在循环中使用i++</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stop-using-i-in-your-loops-1f906520d548?source=collection_archive---------0-----------------------#2019-11-06">https://betterprogramming.pub/stop-using-i-in-your-loops-1f906520d548?source=collection_archive---------0-----------------------#2019-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1fe5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么++i通常比i++好(前增量与后增量)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/01b09e23d92b9f5f45613db48273ff5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*spWyBwNlrLhUc3Ie"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@codestorm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">萨法尔·萨法罗夫</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="94f6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍</h1><p id="8693" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果你以前写过for循环，那么你几乎肯定以前使用过<code class="fe mu mv mw mx b">i++</code>来增加循环变量。</p><p id="54f0" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">但是，你有没有想过<em class="nd">为什么</em>你选择那样做？</p><p id="51dc" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">显然，<code class="fe mu mv mw mx b">i++</code>的最终结果是<code class="fe mu mv mw mx b">i</code>比以前高了一级——这正是我们想要的。但是，有很多方法可以做到这一点，比如<code class="fe mu mv mw mx b">++i</code>、<code class="fe mu mv mw mx b">i++</code>，甚至<code class="fe mu mv mw mx b">i = i + 1</code>。</p><p id="5a02" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在本文中，我将介绍加1、<code class="fe mu mv mw mx b">++i</code>和<code class="fe mu mv mw mx b">i++</code>的两种方法，并解释为什么在大多数情况下<code class="fe mu mv mw mx b">++i</code>可能比<code class="fe mu mv mw mx b">i++</code>更好。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5844" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">后增量(i++)</h1><p id="4149" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe mu mv mw mx b">i++</code>方法，或称后增量，是最常见的方法。</p><p id="18c0" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在psuedocode中，变量<code class="fe mu mv mw mx b">i</code>的后递增运算符大致如下:</p><pre class="kj kk kl km gt ne mx nf ng aw nh bi"><span id="d566" class="ni lh it mx b gy nj nk l nl nm">int j = i;<br/>i = i + 1;<br/>return j;</span></pre><p id="cc08" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">因为后递增运算符必须返回原始值<code class="fe mu mv mw mx b">i</code>，而不是递增值<code class="fe mu mv mw mx b">i + 1</code>，所以它必须存储旧版本的<code class="fe mu mv mw mx b">i</code>。</p><p id="0a59" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">这意味着它通常会不必要地使用额外的内存来存储该值，因为在大多数情况下，我们实际上并不使用旧版本的<code class="fe mu mv mw mx b">i</code>，而是简单地将其丢弃。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="daaa" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">前增量(++i)</h1><p id="0f10" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe mu mv mw mx b">++i</code>方法，或称预增量，不太常见，通常由C和C++等语言中的老程序员使用。</p><p id="34fc" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在psuedocode中，变量<code class="fe mu mv mw mx b">i</code>的前递增运算符大致如下:</p><pre class="kj kk kl km gt ne mx nf ng aw nh bi"><span id="3ad9" class="ni lh it mx b gy nj nk l nl nm">i = i + 1;<br/>return i;</span></pre><p id="a847" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">值得注意的是，在这里，我们不需要保存旧的值<code class="fe mu mv mw mx b">i</code>——我们可以简单地增加它并返回。这更符合for循环中的典型用例，因为我们很少需要旧的<code class="fe mu mv mw mx b">i</code>值。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="88ec" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">警告</h1><p id="d88e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在看到后增量和前增量之间的区别后，人们可能会注意到，由于缓存的值<code class="fe mu mv mw mx b">i</code>在后增量中从不使用，编译器会优化掉那一行，使两个操作符等价。</p><p id="734a" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">对于基本类型(如整数)来说，这很可能是正确的。</p><p id="141f" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">然而，对于更复杂的类型，比如用户定义的类型或者重载了<code class="fe mu mv mw mx b">+</code>操作的迭代器，编译器可能无法安全地优化缓存操作。</p><p id="8979" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">因此，似乎在大多数情况下，前递增操作符比后递增操作符更好，或者等于后递增操作符，只要您不需要正在递增的任何内容的前一个值。</p></div></div>    
</body>
</html>