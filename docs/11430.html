<html>
<head>
<title>How To Render Markdown To HTML With Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Golang将Markdown渲染成HTML</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-render-markdown-to-html-with-golang-957fd0f98326?source=collection_archive---------1-----------------------#2022-03-19">https://betterprogramming.pub/how-to-render-markdown-to-html-with-golang-957fd0f98326?source=collection_archive---------1-----------------------#2022-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dc56" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们将把一个标准的Markdown文件呈现给一个使用布尔玛CSS框架的HTML页面。我们用Golang Markdown包和Golang模板实现了这个程序。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7b558b37c960b21251bf75df2c15c86b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zZv-TZgnK9LtDxSK"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@lukelung1991?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Luke Lung </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="d4da" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这篇文章将向你展示如何将一个Markdown文件转换成一个HTML页面。这个HTML页面将使用布尔玛CSS框架。为了应用这个CSS框架提供的一些特殊类，我们需要编写一个特殊的“钩子”来适应一些HTML标签的呈现方式。对于这个例子，我将坚持修改<code class="fe mc md me mf b">h1</code>和<code class="fe mc md me mf b">img</code>标签的渲染，并添加<code class="fe mc md me mf b">figure</code>标签，但是如果需要的话，这可以很容易地扩展。</p><p id="113e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">要查看我们将使用的降价文件<a class="ae ky" href="https://gist.githubusercontent.com/jfjensen/0affc6fef055b1289e03ab2b3eff10c3/raw/8800f72181e93593ad5623b911e2c80cab1b7103/blog-post-example.md" rel="noopener ugc nofollow" target="_blank">，请点击此处</a>。我们将使用的Golang降价包是<a class="ae ky" href="https://github.com/gomarkdown/markdown" rel="noopener ugc nofollow" target="_blank">这个</a>。如果你不太熟悉Markdown或者需要复习，那么<a class="ae ky" href="https://www.markdownguide.org/cheat-sheet/" rel="noopener ugc nofollow" target="_blank">这是一个很好的资源</a>。</p><p id="5092" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">你可以在这里找到布尔玛CSS框架。这是一个纯CSS框架，所以你只需要在你的HTML文件中包含一个到布尔玛CSS样式表的链接。不需要JavaScript。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="d25c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">程序的Go代码</h1><p id="2132" class="pw-post-body-paragraph lg lh it li b lj my ju ll lm mz jx lo lp na lr ls lt nb lv lw lx nc lz ma mb im bi translated">你可以在这里找到完整的代码。</p><p id="05e4" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">下面，我将分别讨论<code class="fe mc md me mf b">main()</code>和<code class="fe mc md me mf b">renderHook()</code>功能。</p><h2 id="b0a4" class="nd mh it bd mi ne nf dn mm ng nh dp mq lp ni nj ms lt nk nl mu lx nm nn mw no bi translated">main()函数</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c066" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第3–22行，您可以找到我们希望呈现的HTML页面的HTML页眉和页脚。这些都是非常基本的，除了我们还在第9行导入了布尔玛CSS框架。</p><p id="a395" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第24–27行，我们使用<code class="fe mc md me mf b">ioutil.ReadFile()</code>读取markdown文件，然后使用<code class="fe mc md me mf b">panic()</code>处理任何可能发生的错误。</p><p id="85a0" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第29–32行，我们确定了希望发送给降价呈现器的选项。在这里，我发现<code class="fe mc md me mf b">html.FlagsNone</code>是最好用的标志。如果不放任何标志，默认设置为<code class="fe mc md me mf b">html.CommonFlags</code>。然而，根据我的经验，这可能会产生不想要的结果。不渲染项目符号就是一个例子。</p><p id="6e1a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这里要注意的第二件事是，我们将<code class="fe mc md me mf b">RenderNodeHook</code>设置为<code class="fe mc md me mf b">renderHook()</code>函数。这个定制函数负责呈现<code class="fe mc md me mf b">heading</code>和<code class="fe mc md me mf b">image</code>节点。稍后会详细介绍。</p><p id="a8d2" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第33和34行，我们将降价内容呈现为HTML。markdown渲染器似乎返回了一个<code class="fe mc md me mf b">[]byte</code>切片。因此，在将<code class="fe mc md me mf b">output</code>输入模板之前，我使用<code class="fe mc md me mf b">string()</code>函数将其转换成一个字符串。</p><p id="4bdf" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第36–38行，我们创建了一个简单的Golang模板，它由标题、一个在双括号之间的可变点和页脚组成。然后用<code class="fe mc md me mf b">template.Must()</code>检查模板的正确性。</p><p id="41bf" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">对于这样一个小应用程序来说，使用Golang模板似乎有些大材小用，但是这看起来是在几行代码中连接三个字符串的最简单的方法。此外，在web环境中，您可能会使用模板。</p><p id="8b8e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这里需要注意的是，我们需要使用<code class="fe mc md me mf b">text/template</code>包，这样HTML标签就不会被转义。</p><p id="788d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第40和41行，我们创建了一个名为<code class="fe mc md me mf b">processed</code>的<code class="fe mc md me mf b">bytes.Buffer</code>类型的输出缓冲区，并使用<code class="fe mc md me mf b">Execute()</code>将模板渲染到其中。我们将HTML页面渲染到一个字节缓冲区中的原因是为了将它发送到<code class="fe mc md me mf b">ioutil.WriteFile()</code>。</p><p id="098d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第43–46行，我们使用<code class="fe mc md me mf b">ioutil.WriteFile()</code>将输出缓冲区<code class="fe mc md me mf b">processed</code>写入一个名为<code class="fe mc md me mf b">index.html</code>的文件。如果出现错误，我们还会检查错误。</p><h2 id="6929" class="nd mh it bd mi ne nf dn mm ng nh dp mq lp ni nj ms lt nk nl mu lx nm nn mw no bi translated">自定义renderHook()函数</h2><p id="2f47" class="pw-post-body-paragraph lg lh it li b lj my ju ll lm mz jx lo lp na lr ls lt nb lv lw lx nc lz ma mb im bi translated">该功能属于<code class="fe mc md me mf b">RenderNodeFunc</code>类型。你可以在这里阅读<a class="ae ky" href="https://pkg.go.dev/github.com/gomarkdown/markdown@v0.0.0-20220310201231-552c6011c0b8/html#RenderNodeFunc" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="94fe" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当markdown解析器运行时，它创建一个节点树来表示要呈现的HTML。如果我们希望节点以不同于默认的方式呈现，我们可以使用自定义函数来呈现节点。</p><p id="5b02" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第3–15行，我们处理标题节点<a class="ae ky" href="https://pkg.go.dev/github.com/gomarkdown/markdown@v0.0.0-20220310201231-552c6011c0b8/ast#Heading" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="2bf2" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第4行，我们得到了标题节点的级别。我们对级别1感兴趣，因为在这个例子中，我们只想修改<code class="fe mc md me mf b">h1</code>标签的输出。</p><p id="3b9a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第6行，我们检查节点是否是开始节点。这意味着变量<code class="fe mc md me mf b">entering</code>应该为<em class="nr">真</em>。这里我们还测试了<code class="fe mc md me mf b">level</code>是否等于1。</p><p id="bd46" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第7行，我们按照我们希望的那样编写输出<code class="fe mc md me mf b">h1</code>标签。查看<a class="ae ky" href="https://bulma.io/" rel="noopener ugc nofollow" target="_blank">布尔玛文档</a>了解这些类的含义。对于任何其他CSS框架，我们可以在这里做类似的事情。</p><p id="8a97" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第8行和第9行，我们再次测试<code class="fe mc md me mf b">entering</code>是否为真。这一次，我们处理的是不是第1级的其他标题节点。同样，我们根据需要编写输出。在这种情况下，标签中没有添加特定的类。</p><p id="93a7" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第10行和第11行中，<code class="fe mc md me mf b">entering</code>将为假，这意味着我们正在处理结束标记。对于所有标题级别，结束标记以相同的方式呈现。我们将它写入输出流。</p><p id="0bbe" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第14行，我们从函数返回两个值。第一个值<code class="fe mc md me mf b">ast.GoToNext()</code>告诉程序处理树中的下一个节点。这可以是一个子节点。第二个值是布尔值。在这种情况下，布尔值为<em class="nr"> true </em>，因为我们的自定义函数会呈现标签。如果标准渲染器渲染标签，布尔值将为<em class="nr">假</em>。</p><p id="662d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第16–30行，我们处理了<a class="ae ky" href="https://pkg.go.dev/github.com/gomarkdown/markdown@v0.0.0-20220310201231-552c6011c0b8/ast#Image" rel="noopener ugc nofollow" target="_blank">图像节点</a>。注意，在这个例子中，我们将把image ( <code class="fe mc md me mf b">img</code>)标签放在<code class="fe mc md me mf b">figure</code>标签中。这允许我们使用布尔玛CSS框架中的一些特殊样式。</p><p id="64cb" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第17行，我们得到了图像节点的源节点<code class="fe mc md me mf b">src</code>。</p><p id="1def" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第19行和第20行，我们找到了image节点的第一个子节点，它包含“alt”文本。(这是我通过试错发现的)。</p><p id="7ae7" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第22行和第23行，我们测试看我们是否是图像节点<code class="fe mc md me mf b">entering</code>以及文本<code class="fe mc md me mf b">alt</code>是否不是空字符串。然后我们输出我们想要的<code class="fe mc md me mf b">figure</code>和<code class="fe mc md me mf b">img</code>标签；在<code class="fe mc md me mf b">figure</code>标签中有几个类，在<code class="fe mc md me mf b">img</code>标签中有<code class="fe mc md me mf b">alt</code>文本。</p><p id="0737" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第24行和第25行，我们再次测试我们是否是一个图像节点，但是这次文本应该是空的。我们输出<code class="fe mc md me mf b">figure</code>和<code class="fe mc md me mf b">img</code>标签，因为我们希望它们出现，但是在<code class="fe mc md me mf b">img</code>标签中没有<code class="fe mc md me mf b">alt</code>文本属性，因为它是空白的。</p><p id="6efc" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第26行和第27行中<code class="fe mc md me mf b">entering</code>将为假，我们写结束<code class="fe mc md me mf b">figure </code>标签。这里不需要<code class="fe mc md me mf b">img</code>标签。</p><p id="6c95" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第30行，我们从函数中返回，但是带有与之前不同的值。我们将返回<code class="fe mc md me mf b">ast.SkipChildren</code>作为第一个返回值，因为不应该呈现图像节点的子节点。这确保了<code class="fe mc md me mf b">alt</code>文本不会在HTML页面中呈现为段落文本。第二个值再次为真。</p><p id="ce99" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在第31行和第32行，我们处理所有其他节点，即不代表标题或图像标签的节点。我们从带有<code class="fe mc md me mf b">ast.GoToNext</code>和<em class="nr">假</em>的函数返回。这里我们返回<em class="nr"> false </em>作为第二个值，因为默认渲染器需要渲染标签。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="48d4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">产生的HTML页面</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/33bc44d84b46a7fb6028ac80b489c0f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tLIAeOIhGy6nCD-P6QXh9g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">呈现的HTML/布尔玛CSS页面的屏幕截图</p></figure><p id="b7b9" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在上面的截图中，我们可以看到，包括图像和标题在内的所有内容都按照预期进行了渲染。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="2808" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">关于Golang模板的更多信息:</p><div class="nt nu gp gr nv nw"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-use-templates-in-golang-46194c677c7d"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">如何在Golang中使用模板？</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">标准模板包概述。</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">better编程. pub</p></div></div><div class="of l"><div class="og l oh oi oj of ok ks nw"/></div></div></a></div><div class="nt nu gp gr nv nw"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-generate-html-with-golang-templates-5fad0d91252"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">如何用Golang模板生成HTML</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">如何使用Go模板生成HTML页面的示例</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">better编程. pub</p></div></div><div class="of l"><div class="ol l oh oi oj of ok ks nw"/></div></div></a></div></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="721d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">参考</h1><p id="0532" class="pw-post-body-paragraph lg lh it li b lj my ju ll lm mz jx lo lp na lr ls lt nb lv lw lx nc lz ma mb im bi translated"><a class="ae ky" href="https://github.com/gomarkdown/markdown" rel="noopener ugc nofollow" target="_blank">用于Go的Markdown解析器和HTML呈现器</a></p><p id="b41c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae ky" href="https://www.markdownguide.org/cheat-sheet/" rel="noopener ugc nofollow" target="_blank">《降价指南》中的“降价备忘单”</a></p><p id="0116" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">《布尔玛:刚刚运转的现代CSS框架》</p></div></div>    
</body>
</html>