<html>
<head>
<title>Functional Components vs. Class Components in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的功能组件与类组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-components-vs-class-components-in-react-2f28adccc993?source=collection_archive---------1-----------------------#2021-01-08">https://betterprogramming.pub/functional-components-vs-class-components-in-react-2f28adccc993?source=collection_archive---------1-----------------------#2021-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e8cd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">主要区别，何时选择一个而不是另一个，以及为什么你应该知道两者</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/173944cb038b906a8c119784999d86d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F_8axWksLKFjCcd3aAwmew.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://wallpapercave.com/w/wp4923981" rel="noopener ugc nofollow" target="_blank">壁纸洞</a>的照片。</p></figure><p id="7500" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React是由脸书创建的JavaScript库。它使用声明式方法，简化了用户界面的创建。React中构建的web应用程序由几个称为React组件的小而独立的代码组成。有两种主要类型的组件:</p><ul class=""><li id="24a0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">功能组件</li><li id="9a4a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">类别组件</li></ul><p id="d9a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将帮助你理解其中的区别，什么时候选择一个而不是另一个，以及为什么你应该知道这两个。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="db37" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">A L <strong class="ak"> eap进入过去</strong></h1><p id="c382" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">为了理解这些差异，了解React生态系统以前是什么样子是很重要的。几年前，功能组件仅用于<em class="nn"> </em>渲染JSX以向用户显示内容。另一方面，类组件也能够利用生命周期方法系统或状态系统。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/bffe7bf97765410e22cf2ba4eb8f0b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*mgLCai47P4NLLYKogIFAIg.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生态系统<strong class="bd np"> </strong>过去是怎样反应的。</p></figure><p id="feff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2019年2月，React团队引入了Hooks作为React v16.8.0的新功能。React Hooks <strong class="lb iu"> </strong>赋予了功能组件与类组件相同的功能，可以使用状态系统并实现与类组件生命周期方法相同的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/0749d389d1e4ff659080deb92986ac36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FN_DhmKwn8s_QvUVb5POsA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">今天的React生态系统。</p></figure><p id="3823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们来分析一下主要的区别。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="cbc3" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">1.渲染JSX以显示内容</h1><p id="2020" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><a class="ae ky" href="https://www.w3schools.com/react/react_jsx.asp" rel="noopener ugc nofollow" target="_blank"> JSX </a>代表JavaScript XML。正如<a class="ae ky" href="https://www.w3schools.com/react/react_jsx.asp" rel="noopener ugc nofollow" target="_blank"> W3Schools </a>所解释的，它“允许我们用JavaScript编写HTML元素并将它们放在DOM中，而无需使用任何<code class="fe nr ns nt nu b">createElement()</code>和/或<code class="fe nr ns nt nu b">appendChild()</code>方法。”</p><h2 id="27a0" class="nv mr it bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated"><strong class="ak">渲染类组件中的JSX</strong></h2><p id="8ade" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">类组件是扩展了<code class="fe nr ns nt nu b">React.Component</code>渲染方法的ES6类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="a1e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用析构也可以达到同样的效果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h2 id="32d9" class="nv mr it bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">在功能组件中呈现JSX</h2><p id="e2b1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">功能组件<strong class="lb iu"> </strong>是返回JSX的JavaScript函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2b5a" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">2.处理状态</h1><p id="b38b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">使用状态系统，我们创建一个JavaScript对象，其中包含一些与我们正在处理的组件严格相关的数据。在Hooks出现之前，状态系统只能用于类组件。但是有了这个新的补充，现在可以用功能组件获得相同的结果。</p><p id="862c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地了解这两个组件之间的区别，让我们制作一个简单的计数器，通过单击+按钮从零开始递增。</p><h2 id="22dc" class="nv mr it bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">处理类组件中的状态</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="d0e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个类组件中，我们在顶部初始化包含一个名为<code class="fe nr ns nt nu b">count</code>的属性的状态对象，并将其设置为<code class="fe nr ns nt nu b">0</code>。我们用<code class="fe nr ns nt nu b">this.state.count</code>来引用render方法中的状态。最后，我们调用一个箭头函数，每当用户点击+时，它用<code class="fe nr ns nt nu b">this.setState</code>改变<code class="fe nr ns nt nu b">count</code>的状态。</p><h2 id="c77b" class="nv mr it bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">处理功能组件中的状态</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="6392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个功能组件中，首先，我们必须从React库中获取<code class="fe nr ns nt nu b">useState</code>函数。然后，我们利用数组析构<strong class="lb iu"> </strong>到<strong class="lb iu"> </strong>初始化一个新的状态。数组中的第一个变量是我们试图跟踪的状态，而第二个元素(<code class="fe nr ns nt nu b">setCount</code>)是一个函数，我们调用它来更新我们的状态。<code class="fe nr ns nt nu b">useState</code>接受一个参数，这是我们的状态块的默认值。最后，我们调用一个arrow函数，每当用户点击+时，它使用<code class="fe nr ns nt nu b">setCount</code>改变<code class="fe nr ns nt nu b">count</code>的状态。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d4fe" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">3.传递道具</h1><p id="9240" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">为了将数据作为参数从一个React组件传递到另一个组件，我们使用React的props。</p><h2 id="244b" class="nv mr it bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">在类组件中传递属性</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="7ecf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在类组件中，通过使用<code class="fe nr ns nt nu b">this</code>接收道具。</p><h2 id="858e" class="nv mr it bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">在功能组件中传递属性</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="3025" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在函数组件中，我们将props作为函数的参数传递。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6f70" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">4.生命周期方法体系</h1><p id="19c0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">React中的每个组件都经历一个事件生命周期。生命周期在呈现时间上有着重要的作用。生命周期方法的一个例子是与功能组件中的<code class="fe nr ns nt nu b">useEffect()</code>方法相对应的<code class="fe nr ns nt nu b">componentDidMount()</code>。</p><h2 id="7609" class="nv mr it bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated"><strong class="ak">componentidmount()中的一个类组件</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="6f29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nr ns nt nu b">componentDidMount</code>是一个生命周期方法，在组件挂载到DOM上之后调用。</p><h2 id="30d2" class="nv mr it bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated"><strong class="ak">功能组件</strong>中的useEffect()</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="b6b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在功能组件中获得相同的结果，我们使用带有第二个参数<code class="fe nr ns nt nu b">[]</code>的<code class="fe nr ns nt nu b">useEffect</code>钩子。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f092" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">功能组件还是类组件？</h1><p id="ebc8" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在本文中，我们注意到今天的类组件和功能组件具有相同的功能。这就引出了一个重要的问题:“我们应该学习和使用哪一个？”</p><p id="9598" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案很简单:都有！</p><p id="34d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您正在与一家已经使用React一段时间的公司合作。他们很可能在利用基于类的组件，因为这曾经是我们使用状态系统和生命周期方法的唯一方式。</p><p id="a4cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，任何从事新项目的公司都可能使用类组件或功能组件。</p><p id="bc29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解这两种方法将有助于我们确定在任何给定的情况下使用哪一种。</p></div></div>    
</body>
</html>