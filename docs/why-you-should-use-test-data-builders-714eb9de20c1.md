# 为什么您应该使用测试数据构建器

> 原文：<https://betterprogramming.pub/why-you-should-use-test-data-builders-714eb9de20c1>

## 通过隐藏不相关的数据，使我们的测试更容易阅读和理解

![](img/86ef9c7ada5ad25690f7c0b756df3d35.png)

[Marjan Blan | @marjanblan](https://unsplash.com/fr/@marjan_blan?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

当我们编写测试代码时，尽可能简单易懂是很重要的。否则，当代码库随着时间增长或新的开发人员加入我们的团队时，理解他们将是一项不必要的耗时工作。

在我之前的一篇文章中，我写了为什么我们应该避免将我们的测试耦合到生产代码中的构造函数，以防止我们的测试在我们改变这些生产类的实例化方式时中断。

在本文中，我们将:

1.  检查一个例子，其中我们的测试与生产类中的构造函数相耦合。
2.  了解如何实现测试数据构建器以避免几个陷阱。
3.  使用测试数据生成器的好处。

# 我们的例子

让我们来看看科特林的一个例子:

人员类别

在我们的例子中，一个人有几个字段和几个方法:

*   `bmi()`:根据体重和身高计算人的体重指数(身体质量指数)。
*   `eatFood(calories: Int)`:无论何时进食，都会增加人的热量摄入。

这里我们对每种方法都有一个测试:

与生产类的构造函数紧密耦合的测试

# 这些问题

上述测试提出了几个重要问题:

*   在生产代码中，它们与构造函数紧密耦合。
*   他们利用与测试用例无关的数据。

## 1.与生产代码中的构造函数紧密耦合

我们的测试直接使用生产代码中的构造函数来实例化生产类。例如，我们可以看到在`line 7`上，我们的测试调用了`Person`类的构造函数。这样做的后果是，无论出于什么原因，如果我们决定改变`Person`类的实例化方式，我们所有的测试都将不再编译。例如，如果我们用静态工厂方法或构建器替换构造函数，也会发生这种情况。

这个问题在我之前的一篇文章中已经有过深入的解释:[避免将测试耦合到构造函数](https://medium.com/@albloptor/avoid-coupling-tests-to-constructors-9b3b98c4676f)。

此外，不清楚哪个参数放在构造函数的哪个位置。事实上，`Person`类是用一个简单的构造函数实例化的，它有如此多的参数，这影响了我们测试的清晰性。我们肯定能做得更好。

## 2.无关数据的使用

如果我们再次查看`PersonTest`的`line 7`，我们可以看到我们指定了五个字段:`name`、`age`、`weight`、`height`和`calorieIntake`。这些都是`Person`类的构造函数所需要的字段。然而，这个测试只关注人的卡路里摄入量。

类似地，如果我们看一下`line 18`，我们再次指定了`Person`类的构造函数所需的所有参数，尽管只有体重和身高与这个特定的测试相关。

解决这一问题的一种常见方法是定义具有虚拟值的字段，以明确所使用的值是不相关的。看起来是这样的:

使用虚拟值进行测试

修改后，我们现在可以看到，对于第一次测试，唯一相关的值是 100 卡路里的摄入量，而对于第二次测试，则是身高和体重。

稍微好一点，但是如果我们能找到一种方法在测试中指定相关的值，甚至不提及不相关的值，那就更好了。换句话说，去掉测试中所有的虚拟值会很好。

此外，我们的测试仍然耦合到生产类的构造函数。

此时，通常在测试类或单独的工厂类中创建助手方法，方法只指定相关的值。这种方法被称为[对象母模式](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.18.4710&rep=rep1&type=pdf):

这样，肯定更好。每个测试现在只指定与测试用例相关的值，而不指定其他的。我们现在有几个助手方法负责`Person`类的实例化，我们可以决定将它们移到一个单独的类中，这样它们就可以在其他测试类中重用。

然而，这种方法仍然很不理想。`Person` 类的字段越多，需要测试的行为越多，我们需要的帮助方法就越多，从而导致潜在的组合爆炸和代码重复。

例如，考虑一些潜在的用例:

*   `*createPersonWithName(String name)*`
*   `*createPersonWithNameAndAge(String name, int age)*`
*   `*createPersonWithAgeAndCalorieIntake(int age, int calorieIntake)*`

## 理想的解决方案是什么样的？

理想情况下，我们需要一种实例化生产类的方法，以解决上述问题，并尽可能类似自然语言。例如:

*   一个摄入 100 卡路里的人
*   体重 80 公斤，身高 1.8 米的人

# 测试数据构建器模式来拯救

![](img/d3d77a3d773336395629e4af3c217a58.png)

Bob(测试数据)生成器

在软件开发中 [Builder 设计模式](https://refactoring.guru/design-patterns/builder)有许多用途，但是我总是发现自己在测试中最大限度地利用它。当在这个上下文中使用时，它通常接收[测试数据构建器模式](https://wiki.c2.com/?TestDataBuilder)的名称。

让我们看看如何在 Groovy 中实现它，尽管这些概念可以应用于任何其他编程语言:

Groovy 中的 PersonBuilder

这个新的`PersonBuilder`级有以下特点:

*   它是在我们的`tests`源集中定义的。它只能由测试代码使用。
*   它有和`Person`类一样多的字段，都用在大多数用例中有意义的合理默认值初始化。
*   一个`aPerson`静态工厂方法来创建`PersonBuilder`的实例。
*   私有默认构造函数，因此实例化`PersonBuilder`的唯一方式是通过它的`aPerson`静态工厂方法。
*   类中的每个字段都有一个方法，用于在需要时修改 instant 的默认值。
*   从`PersonBuilder`实例的内容创建`Person`实例的`build`方法。

如果你不熟悉 Groovy，你可能想知道`tap`是什么。基本上，`tap`是一个闭包，它接收`this`作为参数，并在闭包中应用语句后返回`this`。Java 中的对等词应该是这样的:

Java 中的人员生成器

实现这样的测试数据构建器使我们的测试能够以如下方式利用它:

PersonTest 利用了 PersonBuilder，这是一个使用测试数据构建器模式实现的测试类

# 使用测试数据构建器的好处

*   测试与生产类的构造函数相分离，减少了每当这些构造函数改变时的副作用。更多关于它的[这里](https://medium.com/@albloptor/avoid-coupling-tests-to-constructors-9b3b98c4676f)。
*   测试更容易理解，也更简洁:它们只显示测试用例的相关数据。
*   如果默认情况下全面使用，测试数据构建器使测试能够一致地实例化生产类。
*   测试中的类设置读起来像一个句子，使测试更容易理解。对于这些方法的可读性，没有任何限制。例如，您可以实现方法，这样测试就可以像`aPerson().with().aHeightInMetersOf(1.8).and().aWeightInKilogramsOf(80).build()`一样使用它们。
*   创建带有明确名称的方法，清楚地表明它们的意图是可能的。例如，如果我们想测试一个人不能用负年龄实例化，我们可以在构建器中定义一个`withInvalidAge`方法。

具有明确意图的方法

*   对于复杂的对象，可以嵌套测试数据构建器。例如，如果一个人有地址，我们可以这样做:

嵌套测试数据生成器

*   由于前者的灵活性，将测试数据构建器模式与 ObjectMother 模式结合起来而没有其缺点是可能的。

# 测试数据构建器不同于生产类的构建器(如果有的话)

这是要记住的一件非常重要的事情。生产类可能会也可能不会使用构建器模式进行实例化。从测试的角度来看，我们不在乎。

> “测试数据生成器是我们创建的特定于测试的类，用于实例化生产类以进行测试，而不管在生产中实例化类的方式如何。”

理论生产类构建器和测试数据构建器之间的一个关键区别是，它们有在测试环境中有意义的默认值。生产类的构建者可能有也可能没有默认值，但通常情况下，他们没有。这可能会有问题，原因如下:

*   我们可能必须在测试中指定不相关的数据，以便向生产类的构造函数提供所有必需的字段。
*   如果我们不能提供这些强制值，我们可能会在测试中面临`NullPointerExceptions`。

# 结论

测试数据构建器是为了测试而实例化生产类的好方法。它们通过隐藏不相关的数据，使我们的测试更容易阅读和理解，并允许它们随着代码库的增长和新用例的出现而扩展。如果全面使用，它们还提供了在测试中实例化生产类的一致且方便的方式。

不要再等了，试试吧！

你可以在 https://github.com/albloptor/medium-code-samples 找到我所有的代码样本。