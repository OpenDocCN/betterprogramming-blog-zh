<html>
<head>
<title>Implementing RabbitMQ With Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node.js实现RabbitMQ</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-rabbitmq-with-node-js-93e15a44a9cc?source=collection_archive---------0-----------------------#2019-04-06">https://betterprogramming.pub/implementing-rabbitmq-with-node-js-93e15a44a9cc?source=collection_archive---------0-----------------------#2019-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/baf7c05740c09e49f83d05b5c429759e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FhTDAGuYcJo1C7Zm4ZQFog.png"/></div></div></figure><p id="298b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文是<a class="ae kz" href="https://medium.com/@pankaj.panigrahi/list-of-node-js-articles-ededa6dd304b" rel="noopener">系列文章</a>中的第8篇，它将帮助您掌握Node.js背后的不同概念，并使您能够创建生产就绪的应用程序。这篇文章期望读者了解巴别塔以及如何设置它。如果你需要知道如何设置，请阅读这篇<a class="ae kz" href="https://medium.com/@pankaj.panigrahi/using-babel-and-other-dependencies-in-node-js-18f74973c1f0" rel="noopener">文章</a>。</p><p id="f08f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您需要抑制发送到API或workers的请求，或者您希望事情异步发生，那么使用消息队列是显而易见的。如果你还想要更多的理由，请浏览下面这篇文章。</p><div class="la lb gp gr lc ld"><a href="https://stackify.com/message-queues-12-reasons/" rel="noopener  ugc nofollow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd iu gy z fp li fr fs lj fu fw is bi translated">消息队列&amp;使用消息队列的12个理由</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">在Stackify，我们从您的应用程序接收大量数据到我们的Retrace APIs。我们会尽快对所有数据进行排队…</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">stackify.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr jz ld"/></div></div></a></div><p id="07e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一些流行的消息队列有:</p><ul class=""><li id="9995" class="ls lt it kd b ke kf ki kj km lu kq lv ku lw ky lx ly lz ma bi translated">兔子q</li><li id="425c" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky lx ly lz ma bi translated">卡夫卡</li><li id="e550" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky lx ly lz ma bi translated">IBM MQ</li><li id="f8ca" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky lx ly lz ma bi translated">ActiveMQ</li><li id="0e92" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky lx ly lz ma bi translated">RocketMQ</li><li id="4eac" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky lx ly lz ma bi translated">Qpid</li></ul><p id="08d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">RabbitMQ是最流行的开源消息代理。RabbitMQ是轻量级的，易于部署。它支持多种消息协议。RabbitMQ有不错的表现和强大的社区。如果您的需求是每秒处理数千条消息，我建议您使用RabbitMQ。</p><p id="f0cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我见过人们没有正确地了解他们的需求就跳到卡夫卡那里。毫无疑问，Kafka提供了比RabbitMQ等消息队列更好的性能和特性，但是设置起来相当复杂。Kafka服务器使用<a class="ae kz" href="https://zookeeper.apache.org/" rel="noopener ugc nofollow" target="_blank"> Zookeeper </a>作为集群成员和路由。如果有效负载不是那么高，设置两个服务器将是不必要的。</p><p id="ce83" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将探索RabbitMQ以及如何将它与<code class="fe mg mh mi mj b">node.js/express</code>API一起使用。</p><p id="de91" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">老实说，RabbitMQ文档写得太好了，你不需要其他的东西。但是我们需要一个RabbitMQ教程作为这个系列的一部分。所以我将在一定程度上总结文档，看看我们如何构建一个REST API来处理RabbitMQ驱动程序。</p><p id="5f49" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">RabbitMQ中正常的工作队列设置如下:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/465c8ed0204ac3140a44d5f60f435b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/0*ykyMN4e7221uqmLl.png"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">RabbitMQ中的工作队列设置</p></figure><p id="0cbb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">RabbitMQ设置中有3个重要部分:</p><ol class=""><li id="ace8" class="ls lt it kd b ke kf ki kj km lu kq lv ku lw ky mt ly lz ma bi translated">制片人。发送消息的程序是<em class="mu">生产者。</em>(图中用P表示)。</li><li id="be8d" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky mt ly lz ma bi translated">排队。消息存储在一个<em class="mu">队列中。</em>它本质上是一个大的消息缓冲区。一个队列<em class="mu"> </em>只受主机的内存和磁盘限制。(图中用红色矩形框表示)<em class="mu">。</em></li><li id="4c5e" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky mt ly lz ma bi translated">消费者。一个<em class="mu">消费者</em>是一个主要等待接收消息的程序。(图中以C1 &amp; C2为代表)<em class="mu">。</em></li></ol><p id="1eae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个队列可以有多个生产者和消费者。但是在正常的用例中，我们不需要多个生产者，因为将消息放入队列非常简单和快速。但是使用队列中的消息并基于该消息执行任务通常需要时间。因此，我们倾向于为一个队列实现多个消费者，以便当一个消费者忙碌时，另一个消费者可以从队列中读取数据并执行任务。</p><p id="b796" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">执行一项任务可能需要几秒钟。您可能想知道，如果一个消费者开始了一项长期任务，但只完成了一部分就去世了，会发生什么。在这种情况下，如果worker崩溃，我们将丢失它刚刚处理的消息。为了确保消息不会丢失，RabbitMQ支持消息<strong class="kd iu">确认</strong>。</p><p id="31d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">消费者发回一个<code class="fe mg mh mi mj b">ack</code> (nowledgement)消息，告诉RabbitMQ已经收到并处理了一个特定的消息，RabbitMQ可以删除它。RabbitMQ将理解消息没有被完全处理，并将它重新排队。如果同时有其他消费者在线，它会迅速将它重新交付给另一个消费者。</p><p id="e110" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是如果RabbitMQ服务器崩溃了呢？队列中的消息会丢失吗？</p><p id="3170" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，是的。但是有一些步骤可以确保您的队列和消息在您的磁盘上是持久的。以便在服务器崩溃的情况下，您可以重新启动服务器并处理消息。</p><p id="8278" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们必须确保我们的队列被声明为<code class="fe mg mh mi mj b">durable</code>。我们可以在RabbitMQ管理控制台中或者通过代码来实现。然后，我们应该通过将<code class="fe mg mh mi mj b">persistent</code>字段设置为<code class="fe mg mh mi mj b">true</code>来确保队列中的消息是持久的。</p><p id="80db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们编码时，我们将检查它们。</p><p id="5d54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以通过<a class="ae kz" href="https://www.rabbitmq.com/download.html" rel="noopener ugc nofollow" target="_blank">安装RabbitMQ </a>在本地机器上安装RabbitMQ，但是为了增加趣味，我们将像在生产环境中一样使用远程RabbitMQ服务器。</p><p id="bce3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有一家公司很慷慨，为开发者提供免费计划。</p><div class="la lb gp gr lc ld"><a href="https://www.cloudamqp.com/plans.html" rel="noopener  ugc nofollow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd iu gy z fp li fr fs lj fu fw is bi translated">计划和定价- CloudAMQP</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">我们为您的所有需求提供灵活的RabbitMQ计划。您在找什么？按秒计费，随时取消…</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">www.cloudamqp.com</p></div></div><div class="lm l"><div class="mv l lo lp lq lm lr jz ld"/></div></div></a></div><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/296d818a058ec58fe4ee664520bf9b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QlyHU9N5t5Natz4Ttu5TAQ.png"/></div></div></figure><p id="1e4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">他们的免费计划足以达到学习的目的。在他们的网站上创建一个帐户，并创建一个实例。</p><p id="981c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建实例后，单击“RabbitMQ管理器”按钮。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/8404e9b120b408a1bd6d289efe12e17a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MBSozDNIIPNB2ncgS4P5tQ.png"/></div></div></figure><p id="feb5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将打开标准的RabbitMQ管理控制台。让我们在同一个控制台中创建一个持久队列。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/a30a0b61c41a0fdffa02c4de6e3f1c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dK_42VpGEE0mzPJJn-4sHg.png"/></div></div></figure><p id="2aee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也可以从代码中创建一个队列。队列应该在几秒钟内准备好。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/0973cc23a8f34c65c6ba0389c04ae0e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2p_ja0VfXUmtpog7DIfkRQ.png"/></div></div></figure><p id="ffed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们需要从代码中连接RabbitMQ实例，为此我们需要连接URL。单击“实例名称/行”以获取连接和其他实例详细信息。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/a6854e2d505b21b5c5e8fef53e8887fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RsvRw-F5qt73GmvdqvIbIw.png"/></div></div></figure><p id="0890" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能会看到许多简单的程序只是将一条消息放入队列中。但是在现实生活中，更有可能调用REST API，然后将消息放入队列中。</p><p id="7d42" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们从我之前创建的锅炉板<a class="ae kz" href="https://github.com/pankaj805/medium-00_boiler_with_db" rel="noopener ugc nofollow" target="_blank">开始。如果你一开始就跟着系列走，锅炉板块应该很清楚了。</a></p><p id="6d8a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先安装下面的库。</p><pre class="ml mm mn mo gt nb mj nc nd aw ne bi"><span id="e3d5" class="nf ng it mj b gy nh ni l nj nk">npm install amqplib --save</span></pre><p id="d94c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第5篇文章<a class="ae kz" href="https://medium.com/@pankaj.panigrahi/getting-data-from-mongodb-creating-an-api-key-validation-middleware-in-express-944382205d3e" rel="noopener">中，</a>我们看到了重用MongoDB连接的一种方法是将它注入请求对象。在这篇文章中，我们将看到另一种方法来实现同样的事情。</p><p id="6c20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建以下文件<code class="fe mg mh mi mj b">services/MQService.js</code></p><p id="04b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">导入库并将连接url保存在一个常量变量中。</p><pre class="ml mm mn mo gt nb mj nc nd aw ne bi"><span id="3f92" class="nf ng it mj b gy nh ni l nj nk">import amqp from 'amqplib/callback_api';</span><span id="7f7b" class="nf ng it mj b gy nl ni l nj nk">const CONN_URL = 'amqp://gsgmnvnl:NITe9ThLkXQvKVLl7L6gEtMllb6obQmw@dinosaur.rmq.cloudamqp.com/gsgmnvnl';</span></pre><p id="d6e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用由<a class="ae kz" href="https://www.amqp.org/" rel="noopener ugc nofollow" target="_blank"> AMQP </a>提供的<code class="fe mg mh mi mj b">connect()</code>方法来创建一个连接。为了从队列中发送或接收消息，我们必须使用通道对象。做到这一点的方法是:</p><pre class="ml mm mn mo gt nb mj nc nd aw ne bi"><span id="8f74" class="nf ng it mj b gy nh ni l nj nk">let ch = null;<br/>amqp.connect(CONN_URL, function (err, conn) {<br/>   conn.createChannel(function (err, channel) {<br/>      ch = channel;<br/>   });<br/>});</span></pre><p id="bb8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，让我们创建一个方法，向实现了<code class="fe mg mh mi mj b">sendToQueue</code>方法的队列发送消息。</p><pre class="ml mm mn mo gt nb mj nc nd aw ne bi"><span id="54df" class="nf ng it mj b gy nh ni l nj nk">export const publishToQueue = async (queueName, data) =&gt; {<br/>   ch.sendToQueue(queueName, new Buffer(data));<br/>}</span></pre><p id="197a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">MQService文件看起来像这样:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2864" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还添加了一个进程监听器，在我们终止进程时关闭RabbitMQ连接。</p><p id="e803" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们在我们的<code class="fe mg mh mi mj b">routes/User.js</code>文件中添加另一条路线。首先让我们导入我们在服务中创建的<code class="fe mg mh mi mj b">publishToQueue</code>方法。</p><pre class="ml mm mn mo gt nb mj nc nd aw ne bi"><span id="4524" class="nf ng it mj b gy nh ni l nj nk">import {publishToQueue} from '../services/MQService';</span></pre><p id="d9f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后添加以下路由方法。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8b97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们正在将消息发送到队列，并且我们正在发送一个成功响应。</p><p id="e7af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们来看看消费者。创建一个新项目，我们将在其中定义我们的员工/消费者。</p><p id="7c00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在项目中创建一个类似<code class="fe mg mh mi mj b">worker-1.js</code>的文件。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi no"><img src="../Images/a840357a2c4e6e19b934eb74cd29b2ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*Y0rJFy2Y4hL_tlyOAqe-yA.png"/></div></figure><p id="eca5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最佳实践是保持工作器精简，因为您可能需要生成相同的多个实例来处理流量。</p><p id="d533" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了简单起见，我在这里没有使用巴别塔。所以在worker文件中看不到任何ES6。</p><p id="08d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在worker文件中编写以下代码。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ad40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，我们首先导入我们的依赖项，然后进行我们之前进行的连接初始化。一旦我们有了通道连接，我们就使用consume方法，它有三个参数:</p><p id="4df8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mg mh mi mj b">consume</code> ( <code class="fe mg mh mi mj b">queue_name</code>、<code class="fe mg mh mi mj b">callback</code>、<code class="fe mg mh mi mj b">ack</code>)</p><p id="2897" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个参数是队列名称，第二个参数是回调方法，一旦我们在队列中获得一条消息，就会调用该方法。第三个参数是确认设置。</p><pre class="ml mm mn mo gt nb mj nc nd aw ne bi"><span id="8bcd" class="nf ng it mj b gy nh ni l nj nk">noAck:true</span></pre><p id="1ae9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们将<em class="mu"> </em> <code class="fe mg mh mi mj b">noAck</code>字段设置为<code class="fe mg mh mi mj b">true</code>，那么队列将在从队列中读取消息时删除该消息。</p><p id="33a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在回调函数中，我们在延迟4秒后打印消息，只是为了模拟I/O操作。</p><pre class="ml mm mn mo gt nb mj nc nd aw ne bi"><span id="67c6" class="nf ng it mj b gy nh ni l nj nk">function (msg) {<br/>  console.log('.....');<br/>  setTimeout(function(){<br/>    console.log("Message:", msg.content.toString());<br/>  },4000);<br/>}</span></pre></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/045968ae1dc043bd07381ad67fa0543d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wPB8aa7Y5kvk6oyr14aFNw.png"/></div></div></figure><p id="934e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，让我们只运行生产者。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/91ad03c39e7cae011aa2edb2400651db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GBKiGAb93RC-os-pTYvuDw.png"/></div></div></figure><p id="4f78" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">像我们在之前的文章中所做的那样，使用REST API。提及如图所示的<code class="fe mg mh mi mj b">queueName</code>和<code class="fe mg mh mi mj b">payload</code>。</p><p id="c27a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您应该会立即得到回应，因为我们不会在这里等待消费者执行任务。</p><p id="ae1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于我们没有启动我们的worker，我们应该在队列中看到消息。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/5d590a54b3b0cd19c222c9e036a09db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q0asdZpLFlXArzr7PjGq6Q.png"/></div></div></figure><p id="8224" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们开始工作。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/4fb4dd91b71176d02cb0f76815e5a861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEyWK-vSUwUao8ludZeNJA.png"/></div></div></figure><p id="25c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们应该在4秒钟后看到消息。</p><p id="4940" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用不同的有效负载再次点击API。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/2777d31368231ac50c978345e2460e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*42cTquWcSlSF0wfwSnBhkA.png"/></div></div></figure><p id="73af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">worker从队列中读取消息，并在4秒钟后打印出来。<br/>完美！</p><p id="e102" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，在现实生活中，消费者可能会在执行某些操作时崩溃。在这种情况下，我们希望消息回到队列中，这样消息就可以被另一个工作线程使用，或者在我们再次生成它时被同一个工作线程使用。</p><p id="4b25" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了实现这一点，我们必须做几件事。</p><p id="a2dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先要做的，是改变<code class="fe mg mh mi mj b">consume</code>方法中的第三个参数值。<code class="fe mg mh mi mj b">noAck : false</code></p><p id="9f96" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于我们已经将<code class="fe mg mh mi mj b">noAck</code>设置为<code class="fe mg mh mi mj b">false</code>，我们必须显式调用<code class="fe mg mh mi mj b">channel.ack()</code>方法。现在我们的<code class="fe mg mh mi mj b">consume</code>方法看起来像:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c372" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还增加了睡眠时间，这样我们就很容易重现这个场景。</p><p id="5892" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们将另一条消息推送到队列中，然后在八秒钟的等待结束之前杀死这个工人。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/12d3364d2184a37798e64d05e98b7668.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oGpwwrJkF2UVxXjBNuEjpQ.png"/></div></div></figure><p id="82ab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的截图中，我们在消费者等待超时的时候杀死了它。从而模拟任务之间的消费者崩溃。</p><p id="629e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">消息回到队列中。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/a7ff47ffc5ead92dde004405a69da013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_2iivcmuSVVTyZO3wvdb0g.png"/></div></div></figure><p id="fe76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重新启动worker，看它是否再次读取消息。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/aa4548cedea86ae82d1e5dd691afa507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PcDCVrC4FGnVG9oQN4eRpQ.png"/></div></div></figure><p id="b75f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们的RabbitMQ实例崩溃了怎么办？我们如何确保有效载荷不丢失？</p><p id="2421" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们必须声明我们的队列是持久的，我们已经在RabbitMQ管理控制台中这样做了。其次，我们必须向生产者代码中的<code class="fe mg mh mi mj b">sendToQueue</code>方法添加第三个参数。</p><pre class="ml mm mn mo gt nb mj nc nd aw ne bi"><span id="210f" class="nf ng it mj b gy nh ni l nj nk">{persistent: true}</span></pre><p id="3be7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以这个函数看起来像:</p><pre class="ml mm mn mo gt nb mj nc nd aw ne bi"><span id="ef0e" class="nf ng it mj b gy nh ni l nj nk">export const publishToQueue = async (queueName, data) =&gt; {<br/>  ch.sendToQueue(queueName, new Buffer(data), {persistent: true});<br/>}</span></pre><p id="27f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是RabbitMQ的一个非常基本的用法。你可以用它做更多的事情。您可以运行多个消费者，并决定向他们发送消息的策略。您还可以使用RabbitMQ设计一个发布/订阅服务，以及基于主题的路由。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="afe6" class="oe ng it bd of og oh oi oj ok ol om on oo op oq or os ot ou ov ow ox oy oz pa bi translated">密码</h1><p id="28cd" class="pw-post-body-paragraph kb kc it kd b ke pb kg kh ki pc kk kl km pd ko kp kq pe ks kt ku pf kw kx ky im bi translated"><a class="ae kz" href="https://github.com/pankaj805/medium-08_mq" rel="noopener ugc nofollow" target="_blank">https://github.com/pankaj805/medium-08_mq</a></p><p id="7f8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">https://github.com/pankaj805/medium-08_mq_workers<a class="ae kz" href="https://github.com/pankaj805/medium-08_mq_workers" rel="noopener ugc nofollow" target="_blank"/></p><p id="a629" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你喜欢这篇文章，请评论并与他人分享。你可以在这里找到整个<a class="ae kz" href="https://medium.com/@pankaj.panigrahi/list-of-node-js-articles-ededa6dd304b" rel="noopener">系列文章</a>。</p></div></div>    
</body>
</html>