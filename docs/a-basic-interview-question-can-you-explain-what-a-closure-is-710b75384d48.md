# 一个基本的面试问题:你能解释一下什么是闭包吗？

> 原文：<https://betterprogramming.pub/a-basic-interview-question-can-you-explain-what-a-closure-is-710b75384d48>

## 答案没有你担心的那么复杂

![](img/4f08c835c92233807936627284c37c0b.png)

约翰·T 在 [Unsplash](https://unsplash.com/s/photos/maze?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

# 臭名昭著的面试问题

这些天，我积极地申请和面试工作。也许你也是，亲爱的读者。

几天前，我参加了一个面试，工程团队让我解释什么是闭包。这当然不是我第一次被问到这个术语，但我不想撒谎，我有点惊慌失措。

闭包因为是一个极其困难的筛选问题而声名狼藉。

面试结束后，我很沮丧这个话题仍然让我望而生畏。我决心全力以赴，一劳永逸地战胜封闭。这篇博客带你了解我的旅程。

# 匿名函数和生命不是闭包

在这篇文章的开始，我想澄清一下我将要写的是什么。在 ES6 之前的时代，闭包的一个常见用例是用来模拟私有方法的匿名函数/life，这不是 JavaScript 固有的。

通过在 ES6 中引入`let`和`const`以及模块**，导致这种和其他类似用例的`var`范围的限制在很大程度上得到了解决。也就是说，生活有结束，但是生活没有结束。**

匿名函数也是*而不是*闭包。

```
anonymousFunc !== closure && IIFE !== closure // true
```

了解这些用例仍然是有价值的。如果你能理解 closure 在过去是如何使用的，你就会理解它在现在是如何使用的。

更不用说还有大量的 ES5 遗留代码。然而，这不是我今天要讲的内容。既然我们已经澄清了，让我们开始吧。

# 作为一个概念的终结

在计算机科学中，闭包是一个函数，它有自己的环境，并且在该环境中至少有一个变量。MDN 声明:

> "在 JavaScript 中，闭包是在每次创建函数时创建的."

因此，函数和闭包是密切相关的。每次你创建一个函数，你都在构建一个闭包，这意味着你可能一直在创建它们，即使你没有意识到这一点！MDN 接着说:

> “一个**闭包**是一个函数的组合，该函数与对其周围状态的引用捆绑在一起(封闭在一起)。”

这就把我们带到了*的范围*。

# 范围和这有什么关系

让我们更深入地挖掘前面引用的术语*周围状态*。在 JavaScript 函数中，周围的状态被称为*范围*。

当你创建一个 JS 文件时，这个环境就是你的程序的*全局作用域*。当你创建一个函数时，它有自己的作用域。

你可能认为全球范围是一个国家。在一个国家内，有许多城市，每个城市都封闭在自己的边界内。类似地，在程序的特定部分，我们会发现用*局部作用域*包围的对象。

Javascript 中有两个局部作用域:*函数作用域*和*块作用域*。

函数存在于全局作用域中，并且可以访问全局作用域。在那个函数中声明的任何东西也可以访问全局作用域，即使它存在于自己的*函数作用域*中。

类似地，如果你在代码中的任何地方用花括号将一个变量括起来，这个变量也将被截掉，它是*块范围的*。

# **关闭和范围**

把 closure 想象成封闭一个功能的有感觉或有自我意识的门可能会有帮助。例如，当我们创建一个新函数时，该函数的闭包会环顾四周并注意它的周围环境，它的*作用域*。

```
function highestBoxOffice() {
   const context = “The highest grossing movie of all time is “;
      return context + “Avengers: Endgame”;
}
```

即使这个函数没有子函数，它仍然有闭包。闭包不仅仅存在于嵌套函数中。这个函数的闭包环顾四周，看到变量存在于其中，在这个例子中，变量是`context`。

# 嵌套函数中的闭包

如果我们创建一个嵌套函数，那么这个函数的闭包会看到它所在的父函数的壁。父函数的作用域是嵌套函数的*外部作用域*。这包括其父函数内部的变量。

这就是闭包真正派上用场的地方。我们的函数`genreTopGross()`有一个闭包。它的闭包向内看，看到自己的*内部作用域* ，里面围着`return Math.Max(…movies.genre.boxOffice)`。

它也向外看，看到它的*外部作用域*，表明它在函数`highestBoxOffice()`内部。它还可以看到并访问传递给其父函数的任何参数。现在让我们加入一个论点。

正如你所看到的，我们已经声明了一个新的变量，`topGrossing()`，并为其赋值`highestBoxOffice(domesticMoviesObj)`。目前，`topGrossing`还未定义，但现在我们开始下一步:

我们调用`topGrossing()`并将`“Romantic Comedy”`作为参数传递。现在我们看到了行动的终结！

我们的函数`genreTopGross()`的内部作用域需要一个`movies`参数，它位于实参`domesticMoviesObj`的外部作用域中，它将通过闭包来访问。

这允许代码成功执行，并返回给我们我们正在寻找的值。

# 闭包和范围链

在 JavaScript 中，每个变量在第一次创建时都属于一个特定的[词法范围](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch2.md)。

在一个编写的程序中，每个变量的作用域通过所谓的*作用域链*联系在一起，全局作用域总是位于链的顶端。

JavaScript 编译器遍历这个链。然而，编译器就像一辆汽车，只能倒车，不能前进。

当使用一个变量时，编译器沿着作用域链向上返回，直到找到该变量的一个条目。

所以，当函数`genreTopGross()`使用变量`movies`时，JavaScript 并没有在`genreTopGross()`的范围内找到`movies`。因此，JavaScript 沿着作用域链向上移动，直到发现`movies`被传入`highestBoxOffice()`。

这和结案有什么关系？

闭包只提供从内部到外部范围的访问，不提供从外部到内部范围的访问。

因此，如果您在几个嵌套函数中声明并定义了一个变量，但在父函数的外部范围内使用它，编译器将返回一个未定义的错误。记住，汽车只能倒车行驶。

# **结论**

正如你所看到的，理解闭包需要对功能、作用域和作用域链有一个坚实的理解，这正是雇主在问这个问题时所寻求的。

这篇博客涵盖了闭包是什么，但没有涉及它们的许多用例。如果您理解了这一点，您应该能够更深入地研究这些用例，而不会感到完全迷失。

如果没有别的，我希望这提供了一个简单的基础或回顾，让您不要对闭包感到恐慌。

一如既往，感谢阅读。

现在去面试吧！