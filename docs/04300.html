<html>
<head>
<title>Build a Board Game Without the Politics (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个没有政治的棋盘游戏(第1部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-board-game-without-the-politics-part-1-3f17f29eeb0b?source=collection_archive---------11-----------------------#2020-04-03">https://betterprogramming.pub/build-a-board-game-without-the-politics-part-1-3f17f29eeb0b?source=collection_archive---------11-----------------------#2020-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1736" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过拖放使用SwiftUI</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b8a35e4ade81994a186b3a1dd55876fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kn807wnhha9RuHsk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Randy Fath 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="9d02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文基于iOS 11.4和2020年3月下旬发布的Swift 5的一个版本。警告:如果你还没有更新你的iDevice和/或Xcode，显然它不会工作。</p><p id="eb09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将通过几个例子来介绍新的拖放协议的构建。最终目标是创建一个迷你数独板，然后您可以填充它。我们的目标只是创建一个你可以拖动棋子的板子。当然，它可以是你想尝试和构建的任何棋盘游戏的任何棋盘。</p><p id="df66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在潜入太深之前，让我们先把脚弄湿。在我们的实现中，我们会发现SwiftUI和拖放有一些小问题——其中最明显的是SwiftUI不鼓励您访问任何坐标。事实上，要做到这一点，您必须实现特定的视图。</p><p id="316a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI中的那个视图被称为<code class="fe lv lw lx ly b">GeometryReader</code>。它是一个容器，您可以在其中读取用于布局应用程序的值。随着时间的推移，这是一个拖放障碍的原因将变得更加清楚。</p><p id="8239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从一些简单的<code class="fe lv lw lx ly b">GeometryReader</code>例子开始。</p><p id="ddcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个新项目并更改<code class="fe lv lw lx ly b">ContentView.swift</code>，使其看起来像这样，用<code class="fe lv lw lx ly b">GeometryReader</code>封装标签:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="7632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行它，它会报告你的设备的尺寸。是的，是的，我知道这不是你想要的。<code class="fe lv lw lx ly b">GeometryReader</code>返回从运行视图的父视图中获取的值。因此，为了获得文本“Hello World”的坐标，我们需要在标签的视图中运行<code class="fe lv lw lx ly b">GeometryReader</code>。这段代码将完成这个任务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="e0a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是做什么的？它在我们的文本框的背景视图中绘制了一个零尺寸的矩形，并返回它用来这样做的坐标。其父视图的坐标。我添加了一个<code class="fe lv lw lx ly b">onTapGesture</code>标签，这样你也可以看到这些数字，并画了一个黄色的小圆圈来表示返回了哪个坐标。</p><p id="6814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这么简单。让我们接着吃主菜。配置<code class="fe lv lw lx ly b">drag</code>是小菜一碟，而配置<code class="fe lv lw lx ly b">drop</code>就不那么容易了。让我们尝试将它添加到我们的“Hello World”部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="9a7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我需要做三件事:</p><ul class=""><li id="b2fb" class="mb mc it lb b lc ld lf lg li md lm me lq mf lu mg mh mi mj bi translated">定义一个<code class="fe lv lw lx ly b">dropDelegate</code>呼叫。</li><li id="af2c" class="mb mc it lb b lc mk lf ml li mm lm mn lq mo lu mg mh mi mj bi translated">对象的可删除标签(在本例中是my <code class="fe lv lw lx ly b">Text Object</code>)。</li><li id="48e1" class="mb mc it lb b lc mk lf ml li mm lm mn lq mo lu mg mh mi mj bi translated">一个我可以把它放在上面的对象。</li></ul><p id="c9de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">dropDelegate</code>本质上是模板代码，唯一有挑战性的位出现在末尾前几行——用于解码被拾取的对象并将其分配到正确位置的行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="26d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，您应该能够编译和运行了。将“Hello World”从家中拖到黄色方框中。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="301a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，我注意到你根本没有拖《Hello World》。原文还在。官方的做法是添加一个<code class="fe lv lw lx ly b">dropProposal</code>，虽然在撰写本文时，这似乎还没有在iOS SwiftUI中实现。我记录了与苹果的通话，如果我错了，我会更新这个。你可能也注意到了我们拖动的图像没有出现——这是我还在探索的另一个iOS功能。</p><p id="1ce8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">后一个问题目前仍未解决。我找到了一种绕过前者的方法，即使这不是官方路线。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="6f5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们需要实现一些东西，让我可以拖动“Hello World”到多个框中。让我们保持简单。创建两个黄色的盒子并使其工作。您需要更改顶部的代码来构建一个包含两个框的界面:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="6222" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将该方法添加到您的<code class="fe lv lw lx ly b">dropDelegate</code>结构中。显然，我没有实现我的“修复”,因此我可以将“Hello World”拖动到两个框中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="9875" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你发现那里的障碍了吗？<code class="fe lv lw lx ly b">DropTarget</code>方法不是模板的一部分。它是我的。它使用你的设备的尺寸来计算哪个盒子在调用<code class="fe lv lw lx ly b">dropDelegate</code>。想象一下，你有一个完整的网格要做。你需要一种方法来知道你的网格把你的盒子放在了界面的什么地方。你需要坐标。你需要那个禁果。</p><p id="18ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用<code class="fe lv lw lx ly b">insideView</code>方法创建一个坐标数组。然后我们可以用我们的坐标把这个例子带到下一个层次。让我们把标签的数量和盒子的数量增加一倍。我们需要胸怀大志。</p><p id="dc58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的新<code class="fe lv lw lx ly b">ContentView</code>看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="780e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的变化。我们升级了<code class="fe lv lw lx ly b">InsideView</code>，现在它可以在一个数组中记录它的测量值。我还为我们的拖放目标引入了一个循环，这样我们就可以很容易地生成更多的拖放目标。我不知道…</p><p id="05c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">升级了<code class="fe lv lw lx ly b">insideView</code>之后，我需要修改<code class="fe lv lw lx ly b">dropTarget</code>，以便它现在使用<code class="fe lv lw lx ly b">rect </code>数组来识别它需要更新哪个盒子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="7fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还需要更新<code class="fe lv lw lx ly b">TheDropDelegate</code>方法，以反映它现在也引用一个数组的事实:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="9064" class="na nb it ly b gy nc nd l ne nf">struct TheDropDelegate: DropDelegate {<br/>@Binding var textID:Int<br/>@Binding var textText:[String]<br/>@Binding var rect:[CGRect]</span></pre><p id="16d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，你应该会编译运行了。这一次，你会有“Hello World 1”和“Hello World 2”，你可以将其中任何一个拖到下面四个黄色方框中的任何一个。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/6e9271acc4c694260ea62be1cca64f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1E8JrQmq0_JjhRGJa1soAw.png"/></div></div></figure><p id="b710" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是你要的:拖放的绝对要素，没有任何花哨的东西。继续读。在本系列的第2部分中，我们将把事情推向无限甚至更远。嗯…差不多了。</p></div></div>    
</body>
</html>