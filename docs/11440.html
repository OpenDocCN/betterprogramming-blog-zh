<html>
<head>
<title>How to Listen for Speed Up and Cancelled Transactions on Ethereum?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何监听以太坊上的加速和取消交易？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-listen-for-speed-up-and-canceled-transactions-on-ethereum-b2e850796e1c?source=collection_archive---------2-----------------------#2022-03-21">https://betterprogramming.pub/how-to-listen-for-speed-up-and-canceled-transactions-on-ethereum-b2e850796e1c?source=collection_archive---------2-----------------------#2022-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="db43" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">您是否遇到过确认加速和取消交易的挑战？不要再看了！以下是解决方案</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8eca55db477b8f16460ba84cbdd17df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JJI9J_3lzguz8scpl8ARyw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在Metamask中监听加速就像…</p></figure><p id="9ded" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最近，我负责创建一个系统，允许取消和加速事务监控？你不知道我在说什么？你是个幸运的男人/女人(或者不负责任的男人/女人)。可能你只是没有考虑到问题的存在。让我告诉你我在说什么。</p><p id="5547" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您正在创建dapp，那么您的用户很有可能会通过元掩码与区块链和事务进行交互。虽然具有给定nonce的第一个事务总是直接从您的dapp发生，并且您能够了解用户操作，但是下面的事务并不真正了解。除了通常的交易，您还有两种选择(如您在下面的截图中所见),分别是:</p><ol class=""><li id="04bf" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">加快速度，</li><li id="cdc0" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">取消。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/7fd49a4800eee6cac850249feedf80e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*hKQUFbH-W1Mneznkhmdmww.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">加速和取消元掩码上的操作</p></figure><p id="7248" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们从头开始。</p><h2 id="69b3" class="mg mh iq bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">理想场景</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/14b2fd20f93e3ba874aba4b55a163b66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wl8ELj__G5q2FIil5qwyvw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">快乐状态表示</p></figure><p id="8b92" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在理想的情况下，人们不会在你的应用之外使用Metamask，你可以完全控制这个过程，也就是说，你可以轻松地验证交易是否成功，UX是否完美无缺，并且不需要额外的检查。不幸的是，正如理想世界中经常发生的那样，它们并不真的存在。</p><h2 id="d6a2" class="mg mh iq bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">以太坊交易</h2><p id="7a7c" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">为了更好地理解一个问题，我们必须考察以太坊中的交易是如何进行的。除了数据、值、从、到、气、<code class="fe nf ng nh ni b">gasLimit</code>等。它们还有两个重要的特性。它的随机数和事务哈希。nonce仅仅是从给定地址进行的交易的计数器，其防止“<a class="ae nj" href="https://en.wikipedia.org/wiki/Double-spending" rel="noopener ugc nofollow" target="_blank">双重花费攻击</a>”，并且交易散列仅仅是从所有其他属性计数的散列。</p><h2 id="48c7" class="mg mh iq bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">加速</h2><p id="3639" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">既然一切都是围绕金钱振荡的，以太坊也不例外。就交易起诉令而言，矿商选择利润最高的交易，即天然气价值最高的交易。假设你做了一笔交易，但是很久都没有确认。你想加速它，所以你…除了点击加速按钮，你到底在这里做什么？</p><p id="eac5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你用同样的随机数创建了第二个交易，并希望它能更快地被矿工发现。因为散列是基于所有参数计算的，所以它将不同于第一个事务，因为gas不同。挑战从这里开始。因为你可以通过使用元掩码从几乎每个页面加速交易，所以没有办法在应用程序中从元掩码获取这些信息。我们必须以不同的方式对待它。</p><h2 id="a629" class="mg mh iq bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">取消</h2><p id="1b1c" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">取消过程与加速过程几乎完全相同。如果你的交易还没有被确认，就有机会挽回你的交易价值(你还是要付油钱)。由于以太坊将拒绝具有相同nonce的事务，如果它已经存在，您创建一个具有您想要取消的相同nonce的事务，您将该值设置为0，并设置一个更高的gas，希望矿工将比具有该值的事务更快地选择该事务。</p><p id="962c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">没那么复杂，对吧？我甚至会说这太棒了。但是由于没有直接为这两个活动的元掩码获取用户动作的机制，所以我们必须随机应变。这就是乐趣的开始。</p><h1 id="2e99" class="nk mh iq bd mi nl nm nn ml no np nq mo jw nr jx mr jz ns ka mu kc nt kd mx nu bi translated">我们将如何解决这个问题</h1><p id="c8fe" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">首先，我们必须注意到这两个交易之间的相似之处。nonce是相同的，from address也是相同的，只有这两个属性我们才能唯一地区分来自某个地址的事务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/ea3b73c0ed98ffd697b849bfa2f27bb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aFaHXYEgPd40RxjCLOIotw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">tx差异比较</p></figure><p id="61bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其次，我们必须看看我们需要什么，以便能够说交易已被确认。它是一个事务哈希(txHash)。仅此而已！下面将以代码为例讨论详细的机制。</p><h1 id="e101" class="nk mh iq bd mi nl nm nn ml no np nq mo jw nr jx mr jz ns ka mu kc nt kd mx nu bi translated">Javascript实现</h1><h2 id="1247" class="mg mh iq bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">1.前端</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/8deddea02cd223e40a23d1a7c2d7953e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YflhTz2cjtrgH_2OIx9MCg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">建议的实施</p></figure><p id="6df9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们就这样做。在前端，在我们创建一个事务后，我们将获取事务信息，如txHash、nonce、from、to等。，并发布到我们的后端。</p><p id="172a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以在前端监听确认，但由于用户仍在我们的网站上时交易被确认的概率非常低(因为这是一个回调函数，他需要仍在我们的网站上，以捕捉确认)，我们只需获取交易信息，将其委托给后端，让前端成为前端。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/911825454f623d7c33e49ba021f0bc35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UI0o8DLW9pvtFyXoz4PfVg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在前端发送事务</p></figure><h2 id="340a" class="mg mh iq bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">2.后端</h2><p id="4a66" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">后端将在这里做繁重的工作。让我们从一个简单的express端点开始，它将负责获取txInfo。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/ebf346d60748d3033e7df9b00f50dcb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kL4BIo-DLD3bUimoamX6JQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个简单的express服务器实现</p></figure><p id="cea4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nf ng nh ni b">TxToWatch</code>只是一个JavaScript对象。我选择它而不是阵列，因为在这种情况下它更易于管理。为了能够区分交易，我们需要三样东西:</p><ol class=""><li id="6c21" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">发件人地址，</li><li id="b586" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">现在，</li><li id="5084" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">事务哈希。</li></ol><p id="b474" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">记住要小写from和to，因为这毕竟无关紧要，它可以成为一个比较为假的原因。对象创建后，我们将它保存在txToWatch字典中，结构如下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/ea18f7bb8b470cba6f81bb7330dfce8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B6FWnTAcSCHv-LC5ZpMreQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">addTxToWatch</p></figure><p id="f4ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在此之前，我们必须创建一个区块链节点，因为我们将检查大量的请求，所以我建议使用Infura。您可以免费使用它，每天最多100k个请求。虽然不多，但对于开发目的来说已经足够了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/ed6c33a855316a5d4cb5713a14d236e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S1aHl1Z1j8FkeRyQh9AIig.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">节点初始化</p></figure><p id="3e43" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可以如上初始化。从Infura获取项目id，并在代码中创建一个具有该名称的变量。</p><p id="289b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这很简单。在我向你展示如何创建一个嗅探器之前，让我们先描述一下我们要做什么。为了找出所有的事务，我们不能只监听一个已确认的事务，因为对于一个给定的nonce只有一个已确认的事务，正如我们从前面所知道的，对于一个给定的nonce，我们可以有多个未决的事务。</p><p id="91df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">幸运的是，我们可以订阅一个事件，该事件将列出所有的<strong class="kx ir">未决交易，</strong>即尚未确认的交易。答对了。在检索未决事务信息以便能够判断事务是否被提交之后，我们必须观察<code class="fe nf ng nh ni b">blockNumber</code>和<code class="fe nf ng nh ni b">blockHash</code>信息。如果它们被设置为空，这意味着它们还没有被确认。如果<code class="fe nf ng nh ni b">blockNumber</code>和<code class="fe nf ng nh ni b">blockHash</code>出现，则意味着该交易被包含在一个块中并已被确认。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/9ccdcb0b1f86c5bb7664c95e4a735020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0NEgX7q312kQISGWEr7wYg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">监视事务机制</p></figure><p id="c39f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们从前面的段落中得到我的解释，它会转化为你在上面看到的代码。对于每个未决事务(对于未决事务，最好将其视为未确认的事务，即您不知道它是否包含在块中)，我们触发一个订阅事件，该事件返回给我们一个事务哈希，我们可以用它来获取事务信息。然后我们检查块号的存在，如果我们找到一个，我们在<code class="fe nf ng nh ni b">txToWatch</code>数组中设置成功参数为真。</p><p id="0a6a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从我所注意到的，有一个机会，你会错过你的交易只是听未决的交易。区块链分布在许多不同的节点上。由于未决事务没有反映在实际的区块链中，因为它们还没有被挖掘出来，所以不能保证您会嗅到您正在嗅到的东西。</p><p id="3a80" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是为什么我还创建了一个<code class="fe nf ng nh ni b">txToWatch</code>嗅探器，即迭代一个<code class="fe nf ng nh ni b">txToWatch</code>事务并检查你在那里的每个事务散列。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/24464176bad424d2256b493d9508d8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qkk33uzbu5Febjd7DAoDXQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">TxToWatch嗅探器</p></figure><p id="5db7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它的外观和工作方式与观察交易功能相似，只是它是主动的，即它不是被动地监听，而是主动检查我们观察的交易是否反映在区块链中。</p><h2 id="55f7" class="mg mh iq bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">检查交易结果</h2><p id="59f5" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">感谢我们之前所做的结构化，现在可以使用第一个创建的哈希(我们从我们的网站使用Metamask签名时获得的哈希)来检查加速和取消。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/df66090a3449c071cd64004a539e7b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ilKA7PoWr5YL9wznlVGWLA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">新的express端点和checkTxHash函数</p></figure><p id="6400" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们已经很好地将它组织到了一个字典中，所以我们可以使用条件链接来优雅地检查给定的事务是否成功。</p><p id="3d1f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编码快乐！</p></div></div>    
</body>
</html>