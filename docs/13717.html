<html>
<head>
<title>Understand Point Clouds: Implement Ground Detection Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解点云:使用Python实现地面检测</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-point-clouds-a-simple-ground-detection-algorithm-71aaa0dd2b2d?source=collection_archive---------1-----------------------#2022-09-20">https://betterprogramming.pub/understand-point-clouds-a-simple-ground-detection-algorithm-71aaa0dd2b2d?source=collection_archive---------1-----------------------#2022-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b92e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">地面检测算法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/00efbe436d14c732a4f07615cd5616ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cz9MdenlT1bfOoDlHciefw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者的相机视野</p></figure><p id="aef6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我的“点云处理”教程的第三篇文章。“点云处理”教程是初学者友好的，其中我们将简单介绍从数据准备到数据分割和分类的点云处理流水线。</p><ul class=""><li id="2895" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><a class="ae ma" href="https://medium.com/@chimso1994/introduction-to-point-cloud-processing-dbda9b167534" rel="noopener">第一篇:点云处理简介</a></li><li id="ea16" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae ma" href="https://medium.com/better-programming/point-cloud-computing-from-rgb-d-images-918414d57e80" rel="noopener">文章2:用Python从深度图像中估计点云</a></li><li id="8f1d" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/understand-point-clouds-a-simple-ground-detection-algorithm-71aaa0dd2b2d">第三篇:理解点云:用Python实现地面检测</a></li><li id="7896" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae ma" href="https://medium.com/@chimso1994/point-cloud-filtering-in-python-e8a06bbbcee5" rel="noopener">第四篇:Python中的点云过滤</a></li><li id="f365" class="lr ls iq kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae ma" href="https://medium.com/@chimso1994/point-cloud-segmentation-in-python-2fdbf5ea0617" rel="noopener">第五篇:Python中的点云分割</a></li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="eb7e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<a class="ae ma" href="https://medium.com/@chimso1994/point-cloud-computing-from-rgb-d-images-918414d57e80" rel="noopener">之前的教程</a>中，我们从深度数据中计算点云，而没有使用Open3D库。在本教程中，我们将首先描述系统坐标。然后，我们将以地面检测为例，对点云进行细致的分析。我们还将介绍有组织的点云，这是一种有趣的三维表现。</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="cf25" class="ms mt iq mo b gy mu mv l mw mx"><strong class="mo ir">Table of contents:</strong></span><span id="72df" class="ms mt iq mo b gy my mv l mw mx">· <a class="ae ma" href="#b104" rel="noopener ugc nofollow">1. Computer vision coordinates systems</a><br/>· <a class="ae ma" href="#bc98" rel="noopener ugc nofollow">2. Ground Detection</a><br/>· <a class="ae ma" href="#daa8" rel="noopener ugc nofollow">3. Organized point cloud</a><br/>· <a class="ae ma" href="#248a" rel="noopener ugc nofollow">4. Conclusion</a></span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="b104" class="mz mt iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">1.计算机视觉坐标系统</h1><p id="c8b7" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated">开始之前，理解计算机视觉中的常规坐标系很重要。在Open3D [1]和微软Kinect传感器[2]中紧随其后。在计算机视觉中，图像在独立的2D坐标系中表示，其中X轴从左指向右，Y轴从上到下。对于相机，3D坐标系原点位于相机的焦点，X轴指向右侧，Y轴指向下方，Z轴指向前方。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/dc0051348bdb6c147cf7c77993e257c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*1gOlvSbznYTdTfkNwYF1BA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">计算机视觉坐标系统</p></figure><p id="03ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们从导入所需的库开始:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="b444" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了更好地理解，让我们从PLY文件导入点云，使用Open3D创建默认的3D坐标系并显示它们:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/6c7e8fce5a5972a8b5ee621301d40b5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UqAq2Tb-m_mNVlL8_TwkDw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带有坐标系原点的显示点云。蓝色箭头是Z轴，红色箭头是X轴，绿色箭头是Y轴。</p></figure><p id="dc7c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">知道蓝色、红色和绿色箭头分别代表Z轴、X轴和Y轴，可以看到点云是在与Open3D坐标系相同的坐标系中表示的。现在，让我们得到具有每个轴的最小值和最大值的点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="b90d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以打印它们，但是为了更好的可视化，我们在每个点的位置创建一个球体几何体。默认情况下，Open3D在原点位置创建3D几何图形:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/4427cef8a1ac9f8d3a1da114b5db1327.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*1L6kZZPn2FOUsw6PqZEwpg.gif"/></div></figure><p id="b2fb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要将球体移动到给定位置，需要平移变换。在下面的例子中，球体被向量[1，1，1]平移:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/d299a4146f4abff0a096b0a0e12d630a.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*XCiCcwxQynZA0jgmlWYF7A.gif"/></div></figure><p id="aaa8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们回到我们的例子，给每个球体分配一种颜色。对于每个位置，我们创建一个球体并将其平移到该位置。然后，我们分配正确的颜色，最后我们将它添加到最后显示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/fd079fdbb32c325e3b1ba2d897f08abe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*tEpDexQXfr1tHss2lZOX0A.gif"/></div></figure><p id="7fd4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">嗯，我们可以看到对应<code class="fe ob oc od mo b">y_min </code>的黄色球体在墙上，对应<code class="fe ob oc od mo b">y_max</code>的绿色球体在地上。事实上，Y轴代表点的高度:在现实世界中，最高的球是黄色的，最低的球是绿色的。但是，由于Y轴指向下方，黄色球体具有最小值，绿色球体具有最大值。</p><p id="19b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一个有趣的球体是原点上的青色球体。正如我们在前面的教程中提到的，深度值为0的像素是噪声点，因此位于原点的点是从这些噪声像素计算的点(当<code class="fe ob oc od mo b">z=0</code>然后<code class="fe ob oc od mo b">x=0</code>和<code class="fe ob oc od mo b">y=0</code>)。</p><h1 id="bc98" class="mz mt iq bd na nb oe nd ne nf of nh ni jw og jx nk jz oh ka nm kc oi kd no np bi translated">2.地面探测</h1><p id="a254" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated">现在我们展示了一些重要的点，如何检测地面？在前面的例子中，绿色球体在地面上。确切地说，其对应于Y轴最高点的中心是接地点。假设为了检测地面，我们将所有带有<code class="fe ob oc od mo b">y_max</code>的点的颜色都改为绿色。</p><p id="1db3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果显示点云，您会注意到并非所有的地面点都是绿色的。事实上，只有一个对应于前一个绿色球体中心的点是绿色的。这是由于深度相机的精度和噪声水平。</p><p id="7de2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了克服这个限制，我们需要添加一个阈值，这样在<code class="fe ob oc od mo b">[y_max-threshold, y_max]</code>中具有<em class="oj"> y </em>坐标的点都被视为地面点。为此，在获得<code class="fe ob oc od mo b">y_max</code>后，我们检查每个点的<em class="oj"> y </em>坐标是否在该区间内，然后，我们将其颜色设置为绿色。最后，我们更新点云的颜色属性并显示结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/05ae05cce66febaafff46f93a6446b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*HX5KRPrS4qdqReV2H_QJVg.gif"/></div></figure><p id="5abf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本例中，我们仅将代表地面的点着色为绿色。在现实世界的应用中，提取地面是为了定义可行走的区域，就像在机器人或视障系统中一样，或者像在室内设计系统中一样，在地面上放置物体。它也可以被删除，因此剩余的点可以像在场景理解和对象检测系统中一样被分割或分类。</p><h1 id="daa8" class="mz mt iq bd na nb oe nd ne nf of nh ni jw og jx nk jz oh ka nm kc oi kd no np bi translated">3.有序点云</h1><p id="dcd0" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated">在我们的第一个教程中，我们将点云定义为一组3D点。集合是一种无序的结构，因此由集合表示的点云称为无序点云。类似于RGB矩阵，有组织的点云是一个2D矩阵，有3个通道表示点的<em class="oj"> x </em> -、<em class="oj"> y </em> -、和<em class="oj"> z </em> -坐标。矩阵结构提供了相邻点之间的关系，从而降低了最近邻等算法的时间复杂度。</p><p id="bb5c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">举个例子，我们正在写一篇研究论文，我们想把地面检测算法的结果显示成一个图形。不幸的是，无法选择动画人物。因此，我们可以对点云进行截图，或者将结果显示在深度图像上，如下图所示。在我看来，第二种选择是最好的。在这种情况下，需要有组织的点云来保留深度像素的位置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/f78f49a7f7002bc04eb210add1b05c39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*iy34vseLacfNLCjs3Rvqpg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">左图:3D可视化的屏幕截图。右图:深度图像的结果。</p></figure><p id="807d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们从之前的深度图像创建一个有组织的点云。我们首先像在上一篇文章中一样导入相机参数。我们还导入深度图像并将其转换为3通道灰度图像，这样我们可以将地面像素设置为绿色:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="3689" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了计算一个有组织的点云，我们按照上一课的方法进行。代替展平深度图像，我们将<code class="fe ob oc od mo b">jj</code>和<code class="fe ob oc od mo b">ii</code>整形为具有与深度图像相同的形状，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="e489" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你打印出创建的点云的形状，你可以看到它是一个有三个通道的矩阵<code class="fe ob oc od mo b">(480, 640, 3)</code>。如果你觉得这段代码很难理解，请回到之前的教程，如果仍然不清楚，请不要犹豫，给我你的问题，我很乐意帮助你。</p><p id="4d70" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类似地，我们像上面一样检测地面，但不是更新点的颜色和显示点云，而是更新灰度图像的像素并显示它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="248a" class="mz mt iq bd na nb oe nd ne nf of nh ni jw og jx nk jz oh ka nm kc oi kd no np bi translated">4.结论</h1><p id="281d" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated">在本教程中，为了适应点云，我们引入了默认坐标系，并实现了一个简单的地面检测算法。实际上，地面检测在诸如导航的某些应用中是一项重要的任务，并且在文献中已经提出了几种算法。实现的算法简单；它将最低点视为地面。然而，它的局限性是深度相机必须平行于地面，而大多数现实世界的应用程序都不是这样。</p><p id="2527" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在轮到你了，试着检测最近的物体(不是地面)，比如给它们涂上红色。<a class="ae ma" href="https://medium.com/@chimso1994/point-cloud-filtering-in-python-e8a06bbbcee5" rel="noopener">在下一个教程</a>中，我们将学习如何预处理点云以减少噪音。你可以在我的<a class="ae ma" href="https://github.com/Chim-SO/pointcloudprocessing" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到例子。如果你有任何问题或建议，欢迎在下面给我留言。</p><div class="ol om gp gr on oo"><a href="https://medium.com/@chimso1994/point-cloud-filtering-in-python-e8a06bbbcee5" rel="noopener follow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">Python中点云过滤</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">利用Open3D进行点云预处理</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">medium.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc kp oo"/></div></div></a></div><div class="ol om gp gr on oo"><a href="https://medium.com/@chimso1994/point-cloud-computing-from-rgb-d-images-918414d57e80" rel="noopener follow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">基于RGB-D图像的点云计算</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">通过编码从深度图像估计点云</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">medium.com</p></div></div><div class="ox l"><div class="pd l oz pa pb ox pc kp oo"/></div></div></a></div><h1 id="3846" class="mz mt iq bd na nb oe nd ne nf of nh ni jw og jx nk jz oh ka nm kc oi kd no np bi translated">参考</h1><p id="2eb7" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated">[1]<a class="ae ma" href="https://github.com/isl-org/Open3D/issues/1347#issuecomment-558205561" rel="noopener ugc nofollow" target="_blank">https://github . com/ISL-org/open 3d/issues/1347 # issue comment-558205561</a></p><p id="8adb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[2]<a class="ae ma" href="https://docs.microsoft.com/en-us/azure/kinect-dk/coordinate-systems" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/azure/Kinect-dk/coordinate-systems</a></p></div></div>    
</body>
</html>