<html>
<head>
<title>Build in 3D for Android Using LibGDX in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin中的LibGDX为Android构建3D版本</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-in-3d-for-android-using-libgdx-in-kotlin-1cbf496cae2e?source=collection_archive---------0-----------------------#2022-07-29">https://betterprogramming.pub/build-in-3d-for-android-using-libgdx-in-kotlin-1cbf496cae2e?source=collection_archive---------0-----------------------#2022-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="14f1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">进入3D空间的第一步</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/89b73a9fe2bcb42c0a0005f930e36abd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GAhtECHQA-OhC-90"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@amokraneaitk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿莫克兰·艾特-卡茨</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="f9ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有没有想过用3D技术为手机制作一些东西？</p><p id="fe48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">做it多平台怎么样？</p><p id="ee9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们知道有许多本地替代方案。例如，如果你想在iOS上使用<a class="ae ky" href="https://developer.apple.com/documentation/scenekit/" rel="noopener ugc nofollow" target="_blank"> SceneKit </a>，或者在Android上使用<a class="ae ky" href="https://developer.android.com/ndk/guides/graphics" rel="noopener ugc nofollow" target="_blank"> Vulkan </a>。但是我们的想法是构建一次，然后部署两个目标。此外，桌面或网络，如果我们想要的。</p><h1 id="15ff" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">关于LibGDX</h1><p id="9218" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我选择用来玩2d或3d图形的框架是<a class="ae ky" href="https://libgdx.com/" rel="noopener ugc nofollow" target="_blank"> LibGDX </a>。那到底是什么？它只是围绕<a class="ae ky" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwil-OWn57vzAhWCHLkGHagcC5wQFnoECAMQAQ&amp;url=https%3A%2F%2Fopengl.org%2F&amp;usg=AOvVaw3RZRi5yeacEaeWok1WYv1h" rel="noopener ugc nofollow" target="_blank"> OpenGL </a>低级API的一个包装器。它有一个很棒的社区，并且有许多关于网络的文章和教程。</p><p id="f755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他图形多平台工具呢？好吧，在我看来，我更喜欢LibGDX，因为你在代码中有它。我知道还有其他的选择，但是你可以把一种脚本和一个非可选的GUI系统结合起来。也许你可以通过代码来完成，但这不是这里的想法。使用LibGDX，您必须通过代码来完成所有工作，我认为您会学到更多的东西，并对您想要做的事情有更多的控制</p><h1 id="713d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">创建项目</h1><p id="eb94" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要启动一个新的LibGDX项目，我们必须转到<a class="ae ky" href="https://libgdx.com/dev/project-generation/" rel="noopener ugc nofollow" target="_blank">项目生成页面</a>并下载稳定版安装程序。</p><p id="de53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在写这篇文章的时候，稳定版将安装LibGDX 1.10.0</p><p id="3b1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将下载一个<code class="fe ms mt mu mv b">gdx-setup_latest.jar</code>文件。点击它</p><p id="fa58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(如果您使用的是macOS，并且在打开文件时遇到问题，只需从“系统偏好设置”-&gt;“安全与隐私”中允许即可)</p><p id="b8a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您打开该工具，您将看到如下对话框:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/0d3d790fd14f12a6ad9db3977139df35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*baPFntViQC1iWGuVO_AHxA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">LibGDX安装工具</p></figure><p id="80bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们完成信息:</p><ul class=""><li id="589a" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">名称:项目的名称。在我的例子中是LibGDX3DTest</li><li id="9881" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">包:这将是Android中的包名或iOS中的包标识符</li><li id="2a2d" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">游戏类:LibGDX应用程序的主类和起始点</li><li id="288f" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">目的地:项目所在的位置</li><li id="ab12" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">Android SDK:Android SDK的默认目标</li><li id="7b0a" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">子项目:在这里，我们现在只使用Android和iOS</li><li id="799f" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">扩展:暂时没有人。如果我们想在未来模拟物理，如果是2d项目，我们将需要<a class="ae ky" href="https://box2d.org/" rel="noopener ugc nofollow" target="_blank"> Box2d </a>或者3D项目的<a class="ae ky" href="https://github.com/bulletphysics/bullet3" rel="noopener ugc nofollow" target="_blank"> Bullet </a>。这些是LibGDX包装器，以避免与原始SDK混淆。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/3aa3a98b6e7e29f6a1dd02e3b5b96c0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9tkOD34qWSVcYnEifx5JFg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最终设置</p></figure><p id="4ba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一件事是，我们需要让Kotlin在这个项目中使用它。否则会生成只是为了用Java。点击高级，出现设置:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/55f5c86362cb17e36de88b30e093cd7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Nrw2xBlaBjdL1cppJAGgA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">启用“使用Kotlin”并点击保存</p></figure><p id="6527" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们点击Generate，它将在所需的文件夹中创建项目。</p><p id="82c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于生成LibGDX项目的更多信息<a class="ae ky" href="https://libgdx.com/wiki/start/project-generation" rel="noopener ugc nofollow" target="_blank">在这里</a></p><p id="aab0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要在Android Studio中打开项目。我目前使用的是AS 2020.3.1，但使用新版本应该没有问题。</p><p id="b6a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Android Studio中运行项目。它应该显示以下屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/ec402418bbb9ae2b21e2fa1fc4cbb66f.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*7RUOK0Qb7E646harCrWkww.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">LibGDX应用的第一个屏幕</p></figure><p id="eeff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用程序将显示一个红色屏幕，上面有LibGDX旧所有者的原始徽标，<a class="ae ky" href="https://www.badlogicgames.com/" rel="noopener ugc nofollow" target="_blank"> BadLogicGames </a>。</p><p id="9116" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在<code class="fe ms mt mu mv b">AndroidManifest.xml</code>文件的<code class="fe ms mt mu mv b">android:screenOrientation</code>属性中更改应用程序方向，将其设置为<code class="fe ms mt mu mv b">portrait</code>而不是<code class="fe ms mt mu mv b">landscape</code>:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="0e49" class="nr lw it mv b gy ns nt l nu nv">...<br/>android:screenOrientation="portrait"<br/>...</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/36a9f0ac853af86c0103c4067f197729.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*R0qgfoiXI_3M1cR2yo3K9Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“纵向”模式下的屏幕</p></figure><h1 id="1f94" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">学习基础知识</h1><p id="e32d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在开始在我们的屏幕上绘制一个基本的立方体之前，我们将去掉<code class="fe ms mt mu mv b">LibGDX3DTest.kt</code>文件中的所有代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="67d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LibGDX安装程序创建了一个Java文件，但是因为我们将使用Kotlin，所以我们删除了<code class="fe ms mt mu mv b">LibGDX3DTest.java</code>文件并用这个<code class="fe ms mt mu mv b">LibGDX3DTest.kt</code>文件替换。</p><p id="0e62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LibGDX应用程序通常使用<code class="fe ms mt mu mv b">ApplicationListener</code>接口的实现来运行，但在这种情况下，我们将使用一个名为<code class="fe ms mt mu mv b">ApplicationAdapter</code>的类，它实现了<code class="fe ms mt mu mv b">ApplicationListener</code>接口，并让我们摆脱一些未使用的方法。这就是为什么我们只覆盖我们需要的方法。</p><p id="2e72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个基本示例包含三个LibGDX生命周期方法:</p><ul class=""><li id="faad" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated"><code class="fe ms mt mu mv b">create()</code>:创建应用程序时调用一次的方法。用于为我们的应用程序/游戏创建整个环境</li><li id="e9f5" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe ms mt mu mv b">render()</code>:每次渲染时游戏循环从应用程序调用的方法。游戏逻辑更新通常也用这种方法进行。</li><li id="90d3" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe ms mt mu mv b">dispose()</code>:应用程序销毁时调用。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/38489d64af1955fd83aa8d80603b4c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/0*kiUXNdjNUAj-SypC.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">LibGDX应用程序生命周期的完整流程图</p></figure><p id="9af3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在LibGDX应用程序运行中调用了其他方法。关于完整生命周期的更多信息<a class="ae ky" href="https://libgdx.com/wiki/app/the-life-cycle" rel="noopener ugc nofollow" target="_blank">请点击此处</a></p><p id="dfe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个最小的例子中，我们在我们的<code class="fe ms mt mu mv b">LibGDX3DTest</code>类中创建了两个变量:</p><ul class=""><li id="c765" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated"><code class="fe ms mt mu mv b">lateinit var batch: SpriteBatch</code></li><li id="39bb" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe ms mt mu mv b">lateinit var img: Texture</code></li></ul><h2 id="4f6e" class="nr lw it bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">SpriteBatch</h2><p id="6fbc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">由于OpenGL的工作方式，最好将调用分组或“批量”绘制在一起，以获得最佳性能。一个<code class="fe ms mt mu mv b">SpriteBatch</code>是一个<code class="fe ms mt mu mv b">Batch</code>，用于绘制精灵。更具体地说，它在OpenGL中处理在四边形上绘制一堆纹理。</p><p id="b9ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种分组就是为什么你在没有首先调用<code class="fe ms mt mu mv b">batch.begin()</code>的情况下试图绘制到<code class="fe ms mt mu mv b">Batch</code>会得到一个错误，因为这标志着批处理开始分组绘制调用的工作。当你在批处理上调用<code class="fe ms mt mu mv b">draw()</code>时，它还没有完成绘图工作，它只是组织你给它的数据。它将等待绘制到屏幕，直到<code class="fe ms mt mu mv b">batch.end()</code>被调用。</p><p id="b3c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们调用<code class="fe ms mt mu mv b">batch.dispose()</code>来释放分配给特定资源的内存。</p><p id="923a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参考<code class="fe ms mt mu mv b">SpriteBatch.java</code>源代码<a class="ae ky" href="https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteBatch.java" rel="noopener ugc nofollow" target="_blank">此处</a></p><h2 id="daaf" class="nr lw it bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">纹理</h2><p id="ad31" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一个纹理包装了一个标准的OpenGL ES纹理。纹理是可以管理的。如果OpenGL上下文丢失，所有托管纹理都将失效。当用户切换到另一个应用程序或收到来电时，就会发生这种情况。托管纹理会自动重新加载。</p><p id="ae7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们使用了一个名为<code class="fe ms mt mu mv b">badlogic.jpg</code>的文件中的LibGDX纹理，它被分配到内存中，在<code class="fe ms mt mu mv b">batch</code>中使用，并最终在生命周期结束时被释放。</p><p id="a6c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参考<code class="fe ms mt mu mv b">Texture.java</code>源代码<a class="ae ky" href="https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/Texture.java" rel="noopener ugc nofollow" target="_blank">这里</a></p><h2 id="2898" class="nr lw it bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">ScreenUtils</h2><p id="a06a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我们的例子中，我们使用<code class="fe ms mt mu mv b">ScreenUtils.clear</code>方法清除整个屏幕，背景为红色。如果我们改变这个方法的值，我们可以改变它的颜色。目前，也许没有必要这样做，但是如果我们想要一个动画精灵，我们需要清空屏幕以避免看到之前的动画帧。</p><p id="7677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此处引用ScreenUtils源代码<a class="ae ky" href="https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/utils/ScreenUtils.java" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3380" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经了解了LibGDX应用程序的基础，我们将继续3D绘图。</p><h1 id="1c21" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">渲染立方体</h1><p id="6809" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将用以下内容更新<code class="fe ms mt mu mv b">LibGDX3DTest.kt</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="9e0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个特定的代码将为我们提供以下屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/eae0a99c89042f280ea9c4c85be745d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/0*SPWtsnAnEmw0Pgmw.gif"/></div></figure><p id="3ba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这段代码是如何工作的。我用方法组织了代码，使其更容易理解。</p><p id="31ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将回顾一下我们现在使用的新组件:</p><ul class=""><li id="6f4b" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated"><code class="fe ms mt mu mv b">PerspectiveCamera</code>:会给我们3D场景的视觉。我们可以调整位置、方向和范围。此处参考<a class="ae ky" href="https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/PerspectiveCamera.java" rel="noopener ugc nofollow" target="_blank"/>。</li><li id="4a8d" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe ms mt mu mv b">ModelBatch</code>:和<code class="fe ms mt mu mv b">SpriteBatch</code>一样，但是是3D渲染。参考<a class="ae ky" href="https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g3d/ModelBatch.java" rel="noopener ugc nofollow" target="_blank">此处</a></li><li id="b05d" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe ms mt mu mv b">Model</code>:这是对我们想要渲染的特定模型的引用。包含有关顶点数据、纹理映射等的信息。这里引用<a class="ae ky" href="https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g3d/Model.java" rel="noopener ugc nofollow" target="_blank"/>。</li><li id="90f4" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe ms mt mu mv b">ModelInstance</code>:使用一个<code class="fe ms mt mu mv b">Model</code>引用创建一个具有特定数据的实际实例。在我们的例子中，如果我们想要创建许多立方体，我们将使用一个<code class="fe ms mt mu mv b">Model</code>和许多<code class="fe ms mt mu mv b">ModelInstance</code>实例。此处参考<a class="ae ky" href="https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g3d/ModelInstance.java" rel="noopener ugc nofollow" target="_blank"/>。</li><li id="89c4" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">它帮助我们设置灯光，以便更好地看到3D世界。此处参考<a class="ae ky" href="https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g3d/Environment.java" rel="noopener ugc nofollow" target="_blank"/>。</li></ul><p id="d99c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">呈现该立方体的过程很容易用这些方法的名称来解释:</p><h2 id="c95e" class="nr lw it bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">创建()</h2><ol class=""><li id="36f2" class="mx my it lb b lc mn lf mo li ol lm om lq on lu oo nd ne nf bi translated">我们创建<code class="fe ms mt mu mv b">PerspectiveCamera</code>并调整位置和视野范围</li><li id="a35f" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu oo nd ne nf bi translated">然后我们创建<code class="fe ms mt mu mv b">ModelBatch</code>、<code class="fe ms mt mu mv b">Model</code>和<code class="fe ms mt mu mv b">ModelInstance</code>，它们将使用那个<code class="fe ms mt mu mv b">Model</code></li><li id="7995" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu oo nd ne nf bi translated">最后，我们用特定的灯光类型创建<code class="fe ms mt mu mv b">Environment</code>，用各自的位置、方向和颜色创建<code class="fe ms mt mu mv b">DirectionalLight</code>。</li></ol><h2 id="e538" class="nr lw it bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">渲染()</h2><ol class=""><li id="1ee1" class="mx my it lb b lc mn lf mo li ol lm om lq on lu oo nd ne nf bi translated">首先，我们用黑色清空屏幕</li><li id="5106" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu oo nd ne nf bi translated">每次执行渲染时(FPS速率取决于硬件)，我们以随机的方向旋转相机</li><li id="6b21" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu oo nd ne nf bi translated">我们需要为每个渲染帧更新摄像机的位置</li><li id="9429" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu oo nd ne nf bi translated">对于给定的<code class="fe ms mt mu mv b">ModelInstance</code>和<code class="fe ms mt mu mv b">Environment</code>，最重要的部分是在屏幕上呈现<code class="fe ms mt mu mv b">ModelBatch</code>的内容</li></ol><h2 id="63c7" class="nr lw it bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">处置()</h2><p id="c6c0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这里，我们最终为<code class="fe ms mt mu mv b">ModelBatch</code>和立方体<code class="fe ms mt mu mv b">Model</code>释放内存资源</p><h1 id="8e5b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">移动立方体</h1><p id="3dd3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将在我们的项目中添加以下与<code class="fe ms mt mu mv b">CameraInputController</code>相关的代码，并移除<code class="fe ms mt mu mv b">spinCamera()</code>方法来停止自动移动:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="e329" class="nr lw it mv b gy ns nt l nu nv">class LibGDX3DTest: ApplicationAdapter() {<br/>    ...<br/>    private lateinit var cameraInputController: CameraInputController<br/>    ...<br/>override fun create() {<br/>    ...<br/>    createCameraInput()<br/>    ...<br/>}<br/>...<br/>private fun updateCamera() {<br/>    camera.update()<br/>    cameraInputController.update()<br/>}<br/>...</span></pre><p id="af96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是完整的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="b4cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe ms mt mu mv b">CameraInputController</code>将把相机移动委托给用户在屏幕上的触摸/滑动手势。就这么简单。这就是为什么我们现在可以在应用程序中随意移动立方体。在本例中，我们使用光标进行操作，因为我们使用的是Android模拟器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/a7a16d772a620ea9c5b3eac57a2bbfdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/0*-zG47LQxwDFnBYrA.gif"/></div></figure><h1 id="e42b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">画一个搅拌机模型</h1><p id="8d52" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们知道了使用LibGDX进行3D渲染的基础，我们可以继续下一步:绘制一个Blender模型。</p><h2 id="f27a" class="nr lw it bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">搅拌机是什么？</h2><p id="e2fa" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://www.blender.org/" rel="noopener ugc nofollow" target="_blank"> Blender </a>是一款免费开源的3D创作软件。它支持整个3D管道——建模、装配、动画、模拟、渲染、合成和运动跟踪，甚至视频编辑和游戏创作。</p><p id="af49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用Blender制作的模型来获得LibGDX支持呈现的格式。我已经从本页中选择了一款车型。我们需要下载的文件是<code class="fe ms mt mu mv b">R8 Low Poly Model.fbx</code>。</p><p id="dc8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个特殊的文件需要用<a class="ae ky" href="https://github.com/libgdx/fbx-conv" rel="noopener ugc nofollow" target="_blank">这个特殊的工具</a>转换成<code class="fe ms mt mu mv b">.g3dj</code>文件。命令应该是这样的:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="defa" class="nr lw it mv b gy ns nt l nu nv">./fbx-conv -v ../model.fbx model.g3dj</span></pre><p id="39cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建一个准备在我们的LibGDX应用程序中使用的<code class="fe ms mt mu mv b">.g3dj</code>文件。</p><p id="3b97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的项目中，我们需要替换这一行:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="52b0" class="nr lw it mv b gy ns nt l nu nv">cubeModel = modelBuilder.createBox(2f, 2f, 2f, material, attributes)</span></pre><p id="abfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用那个:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="255a" class="nr lw it mv b gy ns nt l nu nv">carModel = G3dModelLoader(JsonReader()).loadModel(Gdx.<em class="op">files</em>.internal("model.g3dj"))</span></pre><p id="d761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们可以从<code class="fe ms mt mu mv b">.g3dj</code>文件生成<code class="fe ms mt mu mv b">Model</code>数据。该文件将被添加到<code class="fe ms mt mu mv b">assets</code>文件夹中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/c5a6a77744d4619324c859fb4c4f16a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*HJtX6ElkN7B4trMXqPknNw.png"/></div></figure><p id="f6a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还调整相机，以充分看到汽车模型。</p><p id="a60d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的代码将是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="e78e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是汽车渲染的演示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/604580bb8585a9335ca2cdb61f1ec137.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/0*jFZNlWZ1fqf1EJPo.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">糟糕的分辨率是因为我使用的MOV到GIF转换工具:P</p></figure><p id="1f8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个项目的完整源代码可以在<a class="ae ky" href="https://github.com/fedejordan/LibGDX3DTest" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><h1 id="75ff" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="181d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">将LibGDX与Kotlin结合使用是一种试验2D和3D渲染的简单方法。只需几行代码，我们就可以开始以一种简单的方式在手机屏幕上呈现对象。</p><p id="d988" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以后的文章中，我将展示如何在iOS设备上编译，如何使用Box2D模拟物理，等等。</p><p id="7280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p><h1 id="8568" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">来源</h1><ul class=""><li id="9cff" class="mx my it lb b lc mn lf mo li ol lm om lq on lu nc nd ne nf bi translated">https://xoppa.github.io/blog/basic-3d-using-libgdx/<a class="ae ky" href="https://xoppa.github.io/blog/basic-3d-using-libgdx/" rel="noopener ugc nofollow" target="_blank"/></li><li id="7a05" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">【https://libgdx.com/wiki/app/the-life-cycle T4】</li><li id="8720" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><a class="ae ky" href="https://gamedev.stackexchange.com/a/121340" rel="noopener ugc nofollow" target="_blank">https://gamedev.stackexchange.com/a/121340</a></li><li id="bbaf" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><a class="ae ky" href="https://gamefromscratch.com/libgdx-minimal-3d-app/" rel="noopener ugc nofollow" target="_blank">https://gamefromscratch.com/libgdx-minimal-3d-app/</a></li><li id="41a0" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><a class="ae ky" href="https://medium.com/swlh/3d-game-programming-with-java-and-libgdx-setting-up-a-model-with-blender-1eadab56d45d" rel="noopener">https://medium . com/swlh/3d-game-programming-with-Java-and-libgdx-setting-a-model-with-blender-1 eadab 56d 45d</a></li><li id="e6d5" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><a class="ae ky" href="https://libgdx.com/wiki/graphics/3d/importing-blender-models-in-libgdx" rel="noopener ugc nofollow" target="_blank">https://libgdx . com/wiki/graphics/3d/importing-blender-models-in-libgdx</a></li></ul></div></div>    
</body>
</html>