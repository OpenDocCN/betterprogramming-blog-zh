<html>
<head>
<title>Stop Messing With Kubernetes Finalizers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要再和Kubernetes终结器捣乱了</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stop-messing-with-kubernetes-finalizers-b849511b2329?source=collection_archive---------4-----------------------#2022-06-01">https://betterprogramming.pub/stop-messing-with-kubernetes-finalizers-b849511b2329?source=collection_archive---------4-----------------------#2022-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="68e4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这就是为什么你不应该强制删除Kubernetes资源或者移除它们的终结器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d15ea7ac32b9ac6d9cd1d17c4f1a4f28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xTgmKm6P35YvtxribbCfcg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">背景照片由<a class="ae ky" href="https://unsplash.com/@melocokr?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Sam Pak </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="846e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们都经历过——看到Kubernetes资源的删除被卡住、挂起或花费很长时间令人沮丧。您可能已经使用移除终结器或运行<code class="fe lv lw lx ly b">kubectl delete ... --force --grace-period=0</code>强制立即删除的可怕建议“解决”了这个问题。99%的时候，这是一个可怕的想法，在这篇文章中，我会告诉你为什么。</p><h1 id="226d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">终结器</h1><p id="1e5a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在我们讨论为什么强制删除是个坏主意之前，我们首先需要讨论一下终结器。</p><p id="761e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">终结器是资源元数据中的值，表示所需的预删除操作。它们告诉资源控制器在删除对象之前需要执行什么操作。</p><p id="f281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最常见的是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9417" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们的目的是防止资源被删除，同时控制器或Kubernetes操作员干净利落地清理任何相关对象，比如底层存储设备。</p><p id="8da5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当删除具有终结器的对象时，<code class="fe lv lw lx ly b">deletionTimestamp</code>被添加到资源元数据中，使该对象成为只读的。只读规则的唯一例外是可以移除终结器。一旦所有终结器都消失了，对象就排队等待删除。</p><p id="2702" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解终结器只是资源元数据中的项/键是很重要的。终结器不指定要执行的代码。它们必须由资源控制器添加/删除。</p><p id="9b21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，不要混淆终结器和所有者引用。</p><p id="e522" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">.metadata.OwnerReferences</code>字段指定对象间的父/子关系，如【部署-】&gt;复制集- &gt; Pod。当您删除一个对象时，例如<code class="fe lv lw lx ly b">Deployment</code>，可以删除整个子对象树。这个过程(删除)是自动的，与终结器不同，在终结器中，控制器需要采取一些操作并移除终结器字段。</p><h1 id="3d34" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">什么会出错？</h1><p id="bb76" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如前所述，您可能遇到的最常见的终结器是附加到永久卷(PV)或永久卷声明(PVC)的终结器。这个终结器保护存储在被Pod使用时不被删除。因此，如果PV或PVC不想删除，很可能意味着它仍然由Pod装载。</p><p id="7a09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您决定强制删除PV，请注意，云或任何其他基础架构中的后备存储可能不会被删除，因此您可能会留下一个悬而未决的资源，这仍然会耗费您的资金。</p><p id="f607" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个例子是<code class="fe lv lw lx ly b">namespace</code>，它可能陷入<code class="fe lv lw lx ly b">Terminating</code>状态，因为资源仍然存在于名称空间中，而名称空间控制器无法移除这些资源。强制删除名称空间可能会在您的集群中留下悬而未决的资源，例如包括<a class="ae ky" href="https://github.com/kubernetes/kubernetes/issues/60807#issuecomment-658875036" rel="noopener ugc nofollow" target="_blank">云提供商的负载平衡器</a>，以后可能很难追踪到这些资源。</p><p id="e7a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然不一定与终结器相关，但值得一提的是，除了等待终结器之外，资源还可能因为许多其他原因而被阻塞:</p><p id="67cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最简单的例子是<code class="fe lv lw lx ly b">Pod</code>卡在<code class="fe lv lw lx ly b">Terminating</code>状态，这通常表明运行<code class="fe lv lw lx ly b">Pod</code>的节点有问题。用<code class="fe lv lw lx ly b">kubectl delete pod --grace-period=0 --force ...</code>来“解决”这个问题将会从API服务器(<code class="fe lv lw lx ly b">etcd</code>)中删除<code class="fe lv lw lx ly b">Pod</code>，但是它可能仍然在节点上运行，这肯定是不可取的。</p><p id="bd29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个例子是<code class="fe lv lw lx ly b">StatefulSet</code>，其中<code class="fe lv lw lx ly b">Pod</code>强制删除会产生问题，因为<code class="fe lv lw lx ly b">Pods</code>有固定的标识(<code class="fe lv lw lx ly b">pod-0</code>、<code class="fe lv lw lx ly b">pod-1</code>)。分布式系统可能依赖于这些名称/身份。</p><p id="c3c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe lv lw lx ly b">Pod</code>被强制删除，但仍在该节点上运行，当<code class="fe lv lw lx ly b">StatefulSet</code>控制器替换原来的“已删除”<code class="fe lv lw lx ly b">Pod</code>时，您可以得到两个具有相同身份的pod。然后，这两个<code class="fe lv lw lx ly b"> Pod</code>可能会尝试访问同一个存储，这可能会导致数据损坏。更多信息请参见<a class="ae ky" href="https://kubernetes.io/docs/tasks/run-application/force-delete-stateful-set-pod" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="a2d4" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">野生环境中的终结器</h1><p id="cbe9" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们现在知道，我们不应该乱用带有终结器的资源，但是这些资源是什么呢？</p><p id="2fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在“普通”Kubernetes中，你会遇到的三个最常见的例子是分别与持久卷和持久卷声明相关的<code class="fe lv lw lx ly b">kubernetes.io/pv-protection</code>和<code class="fe lv lw lx ly b">kubernetes.io/pvc-protection</code>(加上在1.23版中引入的<a class="ae ky" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolume-deletion-protection-finalizer" rel="noopener ugc nofollow" target="_blank">和</a>)以及存在于名称空间中的<code class="fe lv lw lx ly b">kubernetes</code>终结器。不过最后一个不在<code class="fe lv lw lx ly b">.metadata.finalizers</code>场，而是在<code class="fe lv lw lx ly b">.spec.finalizers</code>。这种特殊情况在<a class="ae ky" href="https://github.com/kubernetes/design-proposals-archive/blob/main/architecture/namespaces.md#finalizers" rel="noopener ugc nofollow" target="_blank">架构文档</a>中有描述。</p><p id="a6a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了这些“普通的”终结器之外，如果安装Kubernetes操作符，您可能会遇到更多的终结器，这些操作符经常在它们的定制资源上执行预删除逻辑。快速搜索一些流行项目的代码会发现以下内容:</p><ul class=""><li id="33e5" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated"><a class="ae ky" href="https://github.com/istio/istio/blob/master/operator/pkg/controller/istiocontrolplane/istiocontrolplane_controller.go#L65" rel="noopener ugc nofollow" target="_blank"> Istio </a> — <code class="fe lv lw lx ly b">istio-finalizer.install.istio.io</code></li><li id="dd8e" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><a class="ae ky" href="https://github.com/cert-manager/cert-manager/blob/ee8ec69fadff165afa96c2dd22264c16fdb7d065/internal/apis/acme/v1beta1/const.go#L20" rel="noopener ugc nofollow" target="_blank">证书管理器</a> — <code class="fe lv lw lx ly b">finalizer.acme.cert-manager.io</code></li><li id="34be" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><a class="ae ky" href="https://github.com/strimzi/strimzi-kafka-operator/commit/69e77ce8d5918c25048a253f91f4bca8e89028d9#diff-0f711d9ed233c37fbe749fd6c4aadce73849f48de3c414d86d9af89d51ea5ef7R317" rel="noopener ugc nofollow" target="_blank">斯特里姆齐(卡夫卡)</a>——<code class="fe lv lw lx ly b">service.kubernetes.io/load-balancer-cleanup</code></li><li id="0ff4" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><a class="ae ky" href="https://github.com/quay/quay-operator/pull/405/files#diff-db06dd075ea792819f15dcbfb9c2376eea2e17832c2bd64ae6b381d3c947b57eR56" rel="noopener ugc nofollow" target="_blank">码头</a>——<code class="fe lv lw lx ly b">quay-operator/finalizer</code></li><li id="f501" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><a class="ae ky" href="https://github.com/rook/rook/blob/master/Documentation/ceph-teardown.md#removing-the-cluster-crd-finalizer" rel="noopener ugc nofollow" target="_blank"> Ceph/Rook </a> — <code class="fe lv lw lx ly b">ceph.rook.io/disaster-protection</code></li><li id="352b" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><a class="ae ky" href="https://github.com/argoproj-labs/argocd-operator/pull/247/files#diff-1078fd6d90631dae21aebe2e5cb7b8f2e559f568d61b8277117dd19344462d47R188" rel="noopener ugc nofollow" target="_blank">逃离</a>——<code class="fe lv lw lx ly b">argoproj.io/finalizer</code></li><li id="6fa7" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><a class="ae ky" href="https://github.com/litmuschaos/chaos-operator/blob/master/pkg/controller/chaosengine/chaosengine_controller.go#L57" rel="noopener ugc nofollow" target="_blank">石蕊混沌</a>——<code class="fe lv lw lx ly b">chaosengine.litmuschaos.io/finalizer</code></li></ul><p id="f037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果要查找集群中存在的所有终结器，则必须针对每种资源类型运行以下命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe lv lw lx ly b">kubectl api-resources</code>来获取集群中可用资源类型的列表。</p><p id="e633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管哪个终结器停止删除您的资源，强制删除这些资源的负面影响通常是相同的:留下了一些东西，可能是存储、负载平衡器或简单的pod。</p><p id="92c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，正确的解决方案通常是相同的，即找到停止删除的终结器，可能通过查看控制器/操作符的源代码来弄清楚它的目的，并解决阻止控制器移除终结器的任何问题。</p><p id="03d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您决定强制删除有问题的资源，那么解决方案应该是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ad41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个例外是<code class="fe lv lw lx ly b">Namespace</code>，它有<code class="fe lv lw lx ly b">finalize</code> API方法，通常在所述<code class="fe lv lw lx ly b">Namespace </code>中的所有资源被清理时调用。如果<code class="fe lv lw lx ly b">Namespace</code>拒绝删除，即使没有资源可以删除，那么您可以自己调用这个方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="acc7" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">构建您自己的</h1><p id="eaa9" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">现在我们知道了它们是什么以及它们是如何工作的，应该很清楚它们非常有用，所以让我们看看如何将它们应用到我们自己的资源和工作负载中。</p><p id="7d9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes生态系统是基于围棋的，但为了简单起见，我在这里将使用Python。如果您不熟悉Python Kubernetes客户端库，可以考虑先阅读我以前的文章:</p><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/automate-all-the-boring-kubernetes-operations-with-python-7a31bbf7a387"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">用Python自动化所有枯燥的Kubernetes操作</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">了解如何使用Python的Kubernetes客户端库来自动化所有枯燥的Kubernetes任务和操作</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">better编程. pub</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ks np"/></div></div></a></div><p id="1900" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始使用终结器之前，我们首先需要在集群中创建一些资源——在本例中，是一个<code class="fe lv lw lx ly b">Deployment</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="efc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码创建了一个名为<code class="fe lv lw lx ly b">my-deploy</code>的示例<code class="fe lv lw lx ly b">Deployment</code>，此时没有任何终结器。要添加几个终结器，我们将使用以下补丁:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ca23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里重要的部分是对<code class="fe lv lw lx ly b">patch_namespaced_deployment</code>的调用，它将<code class="fe lv lw lx ly b">.metadata.finalizers</code>设置为我们定义的终结器列表。每个都必须完全合格，这意味着它们必须包含<code class="fe lv lw lx ly b">/</code>，因为它们需要遵守<code class="fe lv lw lx ly b">DNS-1123</code>规范。理想情况下，为了让它们更容易理解，你应该使用像<code class="fe lv lw lx ly b">kubernetes.io/pvc-protection</code>这样的格式，在格式前面加上你的服务的主机名，这个主机名与负责终结器的控制器相关。</p><p id="4aa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面代码片段中的其余代码只是确保<code class="fe lv lw lx ly b">Deployment</code>的副本可用，然后我们可以继续管理终结器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c7bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的一般顺序如下:</p><ul class=""><li id="33c8" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">观察所需的资源(在本例中是一个部署)是否有任何变化/事件。</li><li id="46dd" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">寻找与资源修改相关的事件，我们特别检查<code class="fe lv lw lx ly b">deletionTimestamp</code>是否存在。如果有，我们从资源的元数据中获取一个终结器列表，并开始处理其中的第一个。</li><li id="52e7" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">使用<code class="fe lv lw lx ly b">finalize</code>功能执行所有必要的删除前任务</li><li id="b52c" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">最后，用原来的终结器列表减去我们处理的列表，对资源应用一个补丁。</li></ul><p id="888d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果Python中的补丁看起来很复杂，那么只需知道它相当于下面的<code class="fe lv lw lx ly b">kubectl</code>命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1e02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果补丁被接受，我们将收到另一个修改事件，此时我们将处理另一个终结器。我们重复这个过程，直到所有终结器都消失。此时，资源会被自动删除。</p><p id="b494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，您可能会不止一次收到这些事件，因此使预删除逻辑幂等非常重要。</p><p id="98a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您运行上面的代码片段，然后执行<code class="fe lv lw lx ly b">kubectl delete deployment my-deploy</code>，那么您应该会看到如下日志:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面使用Python的演示是可行的，但是不够健壮。在真实的场景中，您很可能希望使用Operator框架，或者在Python中使用，或者更常见的是在Kubebuilder for Go中使用。Kubebuilder文档还包括一整页关于如何使用终结器的内容，包括示例代码。</p><p id="a7b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不想实现整个Kubernetes操作符，也可以选择构建变异的Webhook，这在<a class="ae ky" href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/" rel="noopener ugc nofollow" target="_blank">动态接纳控制</a>文档中有描述。流程应该是相同的——接收事件，处理业务逻辑，然后移除终结器。</p><h1 id="aee7" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="f5d0" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">你应该从这篇文章中学到的一点是，在使用<code class="fe lv lw lx ly b">--force --grace-period=0</code>或从资源中移除终结器之前，你可能要三思。可能有些情况下可以忽略finalizer，但是为了您自己的利益，在使用nuclear解决方案之前进行调查，并了解可能的后果，因为这样做可能会隐藏集群中的系统问题。</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h1 id="a87c" class="lz ma it bd mb mc ol me mf mg om mi mj jz on ka ml kc oo kd mn kf op kg mp mq bi translated">你可能也喜欢</h1><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/building-github-apps-with-golang-43b27f3e9621"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">用Golang构建GitHub应用</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">在几分钟内启动并运行您的第一个GitHub应用程序，并使用它来自动化您在GitHub上做的所有事情</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">better编程. pub</p></div></div><div class="ny l"><div class="oq l oa ob oc ny od ks np"/></div></div></a></div><pre class="kj kk kl km gt or ly os ot aw ou bi"><span id="6688" class="ov ma it ly b gy ow ox l oy oz"><strong class="ly iu">Want to Connect?</strong></span><span id="0e9b" class="ov ma it ly b gy pa ox l oy oz">This article was originally posted at <a class="ae ky" href="https://martinheinz.dev/blog/74?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_74" rel="noopener ugc nofollow" target="_blank">martinheinz.dev</a></span></pre></div></div>    
</body>
</html>