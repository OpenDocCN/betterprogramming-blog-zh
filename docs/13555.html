<html>
<head>
<title>Why You Should Use Test Data Builders</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么您应该使用测试数据构建器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-you-should-use-test-data-builders-714eb9de20c1?source=collection_archive---------18-----------------------#2022-09-06">https://betterprogramming.pub/why-you-should-use-test-data-builders-714eb9de20c1?source=collection_archive---------18-----------------------#2022-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9e43" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过隐藏不相关的数据，使我们的测试更容易阅读和理解</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/86ef9c7ada5ad25690f7c0b756df3d35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k4bV9-Af_XtHcQTK"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/fr/@marjan_blan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Marjan Blan | @marjanblan </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7621" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们编写测试代码时，尽可能简单易懂是很重要的。否则，当代码库随着时间增长或新的开发人员加入我们的团队时，理解他们将是一项不必要的耗时工作。</p><p id="0d76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我之前的一篇文章中，我写了为什么我们应该避免将我们的测试耦合到生产代码中的构造函数，以防止我们的测试在我们改变这些生产类的实例化方式时中断。</p><p id="8798" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将:</p><ol class=""><li id="1da8" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">检查一个例子，其中我们的测试与生产类中的构造函数相耦合。</li><li id="a42a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">了解如何实现测试数据构建器以避免几个陷阱。</li><li id="87ee" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用测试数据生成器的好处。</li></ol><h1 id="5ac6" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">我们的例子</h1><p id="efdf" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">让我们来看看科特林的一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">人员类别</p></figure><p id="fd17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，一个人有几个字段和几个方法:</p><ul class=""><li id="6d4b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nf ly lz ma bi translated"><code class="fe ng nh ni nj b">bmi()</code>:根据体重和身高计算人的体重指数(身体质量指数)。</li><li id="eda0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nf ly lz ma bi translated"><code class="fe ng nh ni nj b">eatFood(calories: Int)</code>:无论何时进食，都会增加人的热量摄入。</li></ul><p id="f988" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们对每种方法都有一个测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">与生产类的构造函数紧密耦合的测试</p></figure><h1 id="1ba6" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">这些问题</h1><p id="1168" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">上述测试提出了几个重要问题:</p><ul class=""><li id="ffc5" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nf ly lz ma bi translated">在生产代码中，它们与构造函数紧密耦合。</li><li id="2a06" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nf ly lz ma bi translated">他们利用与测试用例无关的数据。</li></ul><h2 id="5c80" class="nk mh iq bd mi nl nm dn mm nn no dp mq lf np nq ms lj nr ns mu ln nt nu mw nv bi translated">1.与生产代码中的构造函数紧密耦合</h2><p id="2eb0" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们的测试直接使用生产代码中的构造函数来实例化生产类。例如，我们可以看到在<code class="fe ng nh ni nj b">line 7</code>上，我们的测试调用了<code class="fe ng nh ni nj b">Person</code>类的构造函数。这样做的后果是，无论出于什么原因，如果我们决定改变<code class="fe ng nh ni nj b">Person</code>类的实例化方式，我们所有的测试都将不再编译。例如，如果我们用静态工厂方法或构建器替换构造函数，也会发生这种情况。</p><p id="74c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题在我之前的一篇文章中已经有过深入的解释:<a class="ae kv" href="https://medium.com/@albloptor/avoid-coupling-tests-to-constructors-9b3b98c4676f" rel="noopener">避免将测试耦合到构造函数</a>。</p><p id="71b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，不清楚哪个参数放在构造函数的哪个位置。事实上，<code class="fe ng nh ni nj b">Person</code>类是用一个简单的构造函数实例化的，它有如此多的参数，这影响了我们测试的清晰性。我们肯定能做得更好。</p><h2 id="53fd" class="nk mh iq bd mi nl nm dn mm nn no dp mq lf np nq ms lj nr ns mu ln nt nu mw nv bi translated">2.无关数据的使用</h2><p id="d24f" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">如果我们再次查看<code class="fe ng nh ni nj b">PersonTest</code>的<code class="fe ng nh ni nj b">line 7</code>，我们可以看到我们指定了五个字段:<code class="fe ng nh ni nj b">name</code>、<code class="fe ng nh ni nj b">age</code>、<code class="fe ng nh ni nj b">weight</code>、<code class="fe ng nh ni nj b">height</code>和<code class="fe ng nh ni nj b">calorieIntake</code>。这些都是<code class="fe ng nh ni nj b">Person</code>类的构造函数所需要的字段。然而，这个测试只关注人的卡路里摄入量。</p><p id="f2dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似地，如果我们看一下<code class="fe ng nh ni nj b">line 18</code>，我们再次指定了<code class="fe ng nh ni nj b">Person</code>类的构造函数所需的所有参数，尽管只有体重和身高与这个特定的测试相关。</p><p id="a253" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决这一问题的一种常见方法是定义具有虚拟值的字段，以明确所使用的值是不相关的。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用虚拟值进行测试</p></figure><p id="a7a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">修改后，我们现在可以看到，对于第一次测试，唯一相关的值是100卡路里的摄入量，而对于第二次测试，则是身高和体重。</p><p id="076d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">稍微好一点，但是如果我们能找到一种方法在测试中指定相关的值，甚至不提及不相关的值，那就更好了。换句话说，去掉测试中所有的虚拟值会很好。</p><p id="fb9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我们的测试仍然耦合到生产类的构造函数。</p><p id="2688" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，通常在测试类或单独的工厂类中创建助手方法，方法只指定相关的值。这种方法被称为<a class="ae kv" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.18.4710&amp;rep=rep1&amp;type=pdf" rel="noopener ugc nofollow" target="_blank">对象母模式</a>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="41e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，肯定更好。每个测试现在只指定与测试用例相关的值，而不指定其他的。我们现在有几个助手方法负责<code class="fe ng nh ni nj b">Person</code>类的实例化，我们可以决定将它们移到一个单独的类中，这样它们就可以在其他测试类中重用。</p><p id="846d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这种方法仍然很不理想。<code class="fe ng nh ni nj b">Person </code>类的字段越多，需要测试的行为越多，我们需要的帮助方法就越多，从而导致潜在的组合爆炸和代码重复。</p><p id="748a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，考虑一些潜在的用例:</p><ul class=""><li id="608b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nf ly lz ma bi translated"><code class="fe ng nh ni nj b"><em class="nw">createPersonWithName(String name)</em></code></li><li id="9cdb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nf ly lz ma bi translated"><code class="fe ng nh ni nj b"><em class="nw">createPersonWithNameAndAge(String name, int age)</em></code></li><li id="3a42" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nf ly lz ma bi translated"><code class="fe ng nh ni nj b"><em class="nw">createPersonWithAgeAndCalorieIntake(int age, int calorieIntake)</em></code></li></ul><h2 id="6b55" class="nk mh iq bd mi nl nm dn mm nn no dp mq lf np nq ms lj nr ns mu ln nt nu mw nv bi translated">理想的解决方案是什么样的？</h2><p id="9d6c" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">理想情况下，我们需要一种实例化生产类的方法，以解决上述问题，并尽可能类似自然语言。例如:</p><ul class=""><li id="0495" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nf ly lz ma bi translated">一个摄入100卡路里的人</li><li id="4d95" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nf ly lz ma bi translated">体重80公斤，身高1.8米的人</li></ul><h1 id="7a79" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">测试数据构建器模式来拯救</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/d3d77a3d773336395629e4af3c217a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*TLTlpsMHcAEL9CfwFQYDDQ.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Bob(测试数据)生成器</p></figure><p id="fe12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在软件开发中<a class="ae kv" href="https://refactoring.guru/design-patterns/builder" rel="noopener ugc nofollow" target="_blank"> Builder设计模式</a>有许多用途，但是我总是发现自己在测试中最大限度地利用它。当在这个上下文中使用时，它通常接收<a class="ae kv" href="https://wiki.c2.com/?TestDataBuilder" rel="noopener ugc nofollow" target="_blank">测试数据构建器模式</a>的名称。</p><p id="9aee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看如何在Groovy中实现它，尽管这些概念可以应用于任何其他编程语言:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Groovy中的PersonBuilder</p></figure><p id="9d62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个新的<code class="fe ng nh ni nj b">PersonBuilder</code>级有以下特点:</p><ul class=""><li id="d5f1" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nf ly lz ma bi translated">它是在我们的<code class="fe ng nh ni nj b">tests</code>源集中定义的。它只能由测试代码使用。</li><li id="2f58" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nf ly lz ma bi translated">它有和<code class="fe ng nh ni nj b">Person</code>类一样多的字段，都用在大多数用例中有意义的合理默认值初始化。</li><li id="5322" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nf ly lz ma bi translated">一个<code class="fe ng nh ni nj b">aPerson</code>静态工厂方法来创建<code class="fe ng nh ni nj b">PersonBuilder</code>的实例。</li><li id="07bc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nf ly lz ma bi translated">私有默认构造函数，因此实例化<code class="fe ng nh ni nj b">PersonBuilder</code>的唯一方式是通过它的<code class="fe ng nh ni nj b">aPerson</code>静态工厂方法。</li><li id="791b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nf ly lz ma bi translated">类中的每个字段都有一个方法，用于在需要时修改instant的默认值。</li><li id="1c64" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nf ly lz ma bi translated">从<code class="fe ng nh ni nj b">PersonBuilder</code>实例的内容创建<code class="fe ng nh ni nj b">Person</code>实例的<code class="fe ng nh ni nj b">build</code>方法。</li></ul><p id="6720" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不熟悉Groovy，你可能想知道<code class="fe ng nh ni nj b">tap</code>是什么。基本上，<code class="fe ng nh ni nj b">tap</code>是一个闭包，它接收<code class="fe ng nh ni nj b">this</code>作为参数，并在闭包中应用语句后返回<code class="fe ng nh ni nj b">this</code>。Java中的对等词应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Java中的人员生成器</p></figure><p id="6fac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现这样的测试数据构建器使我们的测试能够以如下方式利用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">PersonTest利用了PersonBuilder，这是一个使用测试数据构建器模式实现的测试类</p></figure><h1 id="bbd9" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">使用测试数据构建器的好处</h1><ul class=""><li id="7766" class="ls lt iq ky b kz my lc mz lf ny lj nz ln oa lr nf ly lz ma bi translated">测试与生产类的构造函数相分离，减少了每当这些构造函数改变时的副作用。更多关于它的<a class="ae kv" href="https://medium.com/@albloptor/avoid-coupling-tests-to-constructors-9b3b98c4676f" rel="noopener">这里</a>。</li><li id="161c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nf ly lz ma bi translated">测试更容易理解，也更简洁:它们只显示测试用例的相关数据。</li><li id="4545" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nf ly lz ma bi translated">如果默认情况下全面使用，测试数据构建器使测试能够一致地实例化生产类。</li><li id="bad9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nf ly lz ma bi translated">测试中的类设置读起来像一个句子，使测试更容易理解。对于这些方法的可读性，没有任何限制。例如，您可以实现方法，这样测试就可以像<code class="fe ng nh ni nj b">aPerson().with().aHeightInMetersOf(1.8).and().aWeightInKilogramsOf(80).build()</code>一样使用它们。</li><li id="04cd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nf ly lz ma bi translated">创建带有明确名称的方法，清楚地表明它们的意图是可能的。例如，如果我们想测试一个人不能用负年龄实例化，我们可以在构建器中定义一个<code class="fe ng nh ni nj b">withInvalidAge</code>方法。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">具有明确意图的方法</p></figure><ul class=""><li id="9c95" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nf ly lz ma bi translated">对于复杂的对象，可以嵌套测试数据构建器。例如，如果一个人有地址，我们可以这样做:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">嵌套测试数据生成器</p></figure><ul class=""><li id="41f6" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nf ly lz ma bi translated">由于前者的灵活性，将测试数据构建器模式与ObjectMother模式结合起来而没有其缺点是可能的。</li></ul><h1 id="b7ed" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">测试数据构建器不同于生产类的构建器(如果有的话)</h1><p id="0485" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这是要记住的一件非常重要的事情。生产类可能会也可能不会使用构建器模式进行实例化。从测试的角度来看，我们不在乎。</p><blockquote class="ob"><p id="d830" class="oc od iq bd oe of og oh oi oj ok lr dk translated">“测试数据生成器是我们创建的特定于测试的类，用于实例化生产类以进行测试，而不管在生产中实例化类的方式如何。”</p></blockquote><p id="2ad4" class="pw-post-body-paragraph kw kx iq ky b kz ol jr lb lc om ju le lf on lh li lj oo ll lm ln op lp lq lr ij bi translated">理论生产类构建器和测试数据构建器之间的一个关键区别是，它们有在测试环境中有意义的默认值。生产类的构建者可能有也可能没有默认值，但通常情况下，他们没有。这可能会有问题，原因如下:</p><ul class=""><li id="6a69" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nf ly lz ma bi translated">我们可能必须在测试中指定不相关的数据，以便向生产类的构造函数提供所有必需的字段。</li><li id="2d6a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nf ly lz ma bi translated">如果我们不能提供这些强制值，我们可能会在测试中面临<code class="fe ng nh ni nj b">NullPointerExceptions</code>。</li></ul><h1 id="a3fa" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="751d" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">测试数据构建器是为了测试而实例化生产类的好方法。它们通过隐藏不相关的数据，使我们的测试更容易阅读和理解，并允许它们随着代码库的增长和新用例的出现而扩展。如果全面使用，它们还提供了在测试中实例化生产类的一致且方便的方式。</p><p id="34d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要再等了，试试吧！</p></div><div class="ab cl oq or hu os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="ij ik il im in"><p id="352d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在https://github.com/albloptor/medium-code-samples找到我所有的代码样本。</p></div></div>    
</body>
</html>