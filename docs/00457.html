<html>
<head>
<title>A Simple Note-Taking App With Flutter — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个简单的带Flutter的笔记应用程序—第2部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/simple-notes-app-with-flutter-part-2-5c982b8473bc?source=collection_archive---------3-----------------------#2019-05-24">https://betterprogramming.pub/simple-notes-app-with-flutter-part-2-5c982b8473bc?source=collection_archive---------3-----------------------#2019-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e0e7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">完成我们的Flutter应用程序数据库结构。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/66639c74dc8600c893555c78876218da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IQrftlQirpRHnb1ESc9EvQ.png"/></div></div></figure><p id="91cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">欢迎回来！</p><p id="0ca8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们开始我们的应用程序。到目前为止，我们已经取得了良好的进展。这是第二部分，请看这里的<a class="ae ln" href="https://medium.com/better-programming/simple-notes-app-with-flutter-part-1-ab66e15c8635" rel="noopener">第一部分</a>。</p><p id="c9c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这一块，我将尝试完成整个数据库结构。让我们开始吧。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="9558" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated"><strong class="ak">统计所有行</strong></h1><p id="508f" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">这个方法将帮助您获得所有行的计数。</p><p id="2ac4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是什么意思？假设你从你的应用程序中输入了两个音符，它将返回两个整数，如果什么都没有，则返回零。有道理？</p><p id="5ac9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些方法有时会在编码中帮助你，例如，如果你想显示一个类似“没有注释要显示”的文本，你可以使用这个方法。如果它将返回零，这意味着什么都没有，所以你可以显示文本，反之亦然。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="7971" class="mx lw iq mt b gy my mz l na nb">Future&lt;int&gt; getCount() <strong class="mt ir">async </strong>{<br/>  <strong class="mt ir">var </strong>dbClient = <strong class="mt ir">await </strong>db;<br/>  int count = Sqflite.<em class="nc">firstIntValue</em>(<strong class="mt ir">await </strong>dbClient<br/>      .rawQuery("SELECT COUNT(*) FROM ${Constants.<em class="nc">TABLE_NAME</em>}"));<br/>  <strong class="mt ir">return </strong>count;<br/>}</span></pre></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="6b19" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">从数据库中获取单个项目或单个注释</h1><p id="56c5" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我们将通过其<strong class="kt ir"> </strong> <code class="fe nd ne nf mt b">id</code> <em class="nc"> </em>检索单个音符，借助于将在数据库中迭代的<code class="fe nd ne nf mt b">whereclause</code>，找到该特定<code class="fe nd ne nf mt b">id</code>的音符<code class="fe nd ne nf mt b">Map</code>，并将其返回给我们。</p><p id="7561" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">查看我们方法的返回类型。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="d54b" class="mx lw iq mt b gy my mz l na nb">Future&lt;Note&gt; getSingleItem(int id) <strong class="mt ir">async </strong>{<br/>  <strong class="mt ir">var </strong>dbClient = <strong class="mt ir">await </strong>db;<br/>  <strong class="mt ir">var </strong>result = <strong class="mt ir">await </strong>dbClient.rawQuery(<br/>      "SELECT * FROM ${Constants.<em class="nc">TABLE_NAME</em>} WHERE ${Constants.<em class="nc">COLUM_ID</em>} = $id");<br/>  <strong class="mt ir">if </strong>(result == <strong class="mt ir">null</strong>) <strong class="mt ir">return null</strong>;<br/>  <strong class="mt ir">return new </strong>Note.fromMap(result.first);<br/>}</span></pre><p id="ae68" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我在这里定义我们之前创建的<code class="fe nd ne nf mt b">Note.fromMap()</code>构造函数。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="e110" class="mx lw iq mt b gy my mz l na nb">Note.fromMap(Map&lt;String, <strong class="mt ir">dynamic</strong>&gt; map) {<br/>  <strong class="mt ir">this</strong>._text = map['name'];<br/>  <strong class="mt ir">this</strong>._id = map['id'];<br/>  <strong class="mt ir">this</strong>._date = map['date'];<br/>}</span></pre><p id="520c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所知，我们的数据库已经将所有内容存储在了<code class="fe nd ne nf mt b">Map</code>对象中。</p><p id="e66d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当它遍历并找到我们的数据时，显然该数据必须在<code class="fe nd ne nf mt b">Map</code>对象中，而该对象对我们来说是无用的，因为我们无法读取它。</p><p id="cc2c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们必须将值从<code class="fe nd ne nf mt b">Map</code>中提取到可读的格式，<code class="fe nd ne nf mt b">Note.fromMap()</code>将为我们完成这项工作。</p><p id="071d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你所看到的，它将<code class="fe nd ne nf mt b">Map&lt;String,dynamic&gt;</code>作为一个参数，由此，映射值将存储在类<code class="fe nd ne nf mt b">note.dart</code> <em class="nc">的实例变量中。这样，我们将有一个返回给我们的对象。</em></p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="6894" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated"><strong class="ak">从数据库中删除特定项目或便笺</strong></h1><p id="cf3e" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">从db中删除值类似于从db中获取单个项目，这一点我们刚刚讨论过。</p><p id="3a33" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您所看到的，这里有一点变化，因为我们使用了sqflite的<code class="fe nd ne nf mt b">delete()</code>方法，该方法将表名、子句作为ID，并将where参数。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="55b0" class="mx lw iq mt b gy my mz l na nb">Future&lt;int&gt; deleteItem(int id) <strong class="mt ir">async </strong>{<br/>  <strong class="mt ir">var </strong>dbClient = <strong class="mt ir">await </strong>db;<br/>  int count = <strong class="mt ir">await </strong>dbClient.delete(Constants.<em class="nc">TABLE_NAME</em>,<br/>      where: "${Constants.<em class="nc">COLUM_ID</em>} = ?", whereArgs: [id]);<br/>  <strong class="mt ir">return </strong>count;<br/>}</span></pre></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="314a" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated"><strong class="ak">更新注释</strong></h1><p id="885e" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">为了更新注释，我传递了一个单注释对象作为update方法的参数，因为在注释对象中，我们有文本、日期和ID。因此，当我们想要更新一个注释时，我们可能需要更改文本，因此，日期也会相应地更改。</p><p id="07ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nd ne nf mt b">Id</code>将用于从数据库中获取特定的注释来更新它。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="ef96" class="mx lw iq mt b gy my mz l na nb">Future&lt;int&gt; updateItem(Note note) <strong class="mt ir">async </strong>{<br/>  <strong class="mt ir">var </strong>dbClient = <strong class="mt ir">await </strong>db;<br/>  int count = <strong class="mt ir">await </strong>dbClient.update(Constants.<em class="nc">TABLE_NAME</em>, note.toMap(),<br/>      where: "${Constants.<em class="nc">COLUM_ID</em>} = ?", whereArgs: [note.id]);<br/><br/>  <strong class="mt ir">return </strong>count;<br/>}</span></pre><p id="657d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这对你有用。我们现在已经完成了一个完整的数据库结构。我不会将UI部分集成到本文中。我将在下一篇文章中重点讨论这个问题。感谢阅读。</p></div></div>    
</body>
</html>