<html>
<head>
<title>SwiftUI: We’re Loading, We’re Loading…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们正在加载，我们正在加载…</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-were-loading-we-re-loading-7d689fa8b0c7?source=collection_archive---------7-----------------------#2022-03-14">https://betterprogramming.pub/swiftui-were-loading-we-re-loading-7d689fa8b0c7?source=collection_archive---------7-----------------------#2022-03-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3981" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何让你的API调用加载一次…并且只加载一次。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d54a4f14bcd9e1ddd1ffb5bfe3c4e6b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yctDEp8rYkyl5zqmiWBXAA.jpeg"/></div></div></figure><p id="ce7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">UIKit和UIViewControllers在控制生命周期事件方面给了我们很多选择:<code class="fe lq lr ls lt b">viewDidLoad</code>、<code class="fe lq lr ls lt b">viewWillAppear</code>、<code class="fe lq lr ls lt b">viewDidAppear</code>、<code class="fe lq lr ls lt b">viewWillDisappear</code>、<code class="fe lq lr ls lt b">viewDidDisappear</code>等等。</p><p id="c1cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">SwiftUI则基本上给了我们<code class="fe lq lr ls lt b">onAppear</code>和<code class="fe lq lr ls lt b">onDisappear</code>。因此，如果我们想为一个视图加载一些数据，我们通常会像下面这样做:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="332e" class="ly lz it lt b gy ma mb l mc md">struct MyAccountListView: View {</span><span id="2e87" class="ly lz it lt b gy me mb l mc md">    @StateObject var viewModel = MyAccountListViewModel()</span><span id="8068" class="ly lz it lt b gy me mb l mc md">    var body: some View {<br/>        List {<br/>            ForEach(viewModel.accounts, id: \.id) { account in<br/>                NavigationLink(destination: Details(account)) {<br/>                    AccountListCellView(account: account)<br/>                }<br/>            }<br/>        }<br/>        .onAppear {<br/>            viewModel.load()<br/>        }<br/>    }<br/>}</span></pre><p id="ddcc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只需在<code class="fe lq lr ls lt b">onAppear</code>中调用<code class="fe lq lr ls lt b">load()</code>，天下太平。对吗？</p><p id="a651" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧，如果你已经使用SwiftUI有一段时间了，那么你可能知道答案并不那么简单。虽然下面的大多数解决方案相对简单，但我在互联网上看到了足够多的问题(和有问题的解决方案),表明它们也不是那么明显。</p><p id="69ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以让我们开始吧。首先，我们需要理解手头的问题。</p><h2 id="0961" class="ly lz it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">去了又回来</h2><p id="67e1" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">第一个也是最明显的问题在于我们的导航链接。点击列表中的一个“账户”,你会进入一个新的账户详情页面。但是当你从那个页面返回时会发生什么呢？</p><p id="0deb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正确。您的视图再次“出现”,因此加载您的数据的请求也再次发出。</p><p id="6b08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当使用选择器列表和数据输入子表单进行大量来回导航的表单时，也会出现同样的问题。点击一个项目，在新屏幕上显示一个选择列表。选择一个项目，列表返回到再次出现的原始屏幕。</p><p id="9b3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有这些问题都可能因为SwiftUI(出于只有SwiftUI知道的原因)在给定的转换期间也可能不止一次调用<code class="fe lq lr ls lt b">onAppear</code>和<code class="fe lq lr ls lt b">onDisappear</code>处理程序而加剧。在3.0中，这种情况有所改善，但仍有可能发生。</p><p id="ea34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这并不重要<em class="mf">为什么，</em>是吗？我们仍然有导航问题，我们仍然希望加载我们的数据一次，只有一次。</p><p id="4939" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那我们该怎么办？</p><p id="e41a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">标志</strong></p><p id="677f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧，如果你已经编程好几天了，第一个(也是最明显的解决方案)是拿起我们工具箱里的锤子，设置一个标志。考虑一下。</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="11e4" class="ly lz it lt b gy ma mb l mc md">class MyAccountListViewModel: ObservableObject {</span><span id="3662" class="ly lz it lt b gy me mb l mc md">    @Published var accounts: [Account] = []</span><span id="b6f5" class="ly lz it lt b gy me mb l mc md">    private var shouldLoad = true</span><span id="3c4b" class="ly lz it lt b gy me mb l mc md">    func load() {<br/>        guard shouldLoad else { return }<br/>        shouldLoad = false<br/>        // load our data here<br/>    }<br/>}</span></pre><p id="3f1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结案了。问题解决了。但是这个解决方案，就解决方案而言，还有一点需要改进，因为我们必须在视图模型中声明变量，保护它，然后记得重置我们的标志。</p><p id="f2ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">而且它太挑剔了，我们可能想要写一些额外的单元测试，只是为了确保我们得到了所有正确的东西。</p><p id="cf94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总的来说，它有点…嗯，只能说它不太优雅。我们能做得更好吗？</p><h2 id="276f" class="ly lz it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">原子学</h2><p id="3f7b" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">嗯，我们可以导入新的Atomics库并删除额外的赋值语句。</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="8f8a" class="ly lz it lt b gy ma mb l mc md">private var loading = ManagedAtomic(true)</span><span id="4cda" class="ly lz it lt b gy me mb l mc md">func load() {<br/>  guard loading.exchange(false, ordering: .relaxed) else { return }<br/>  // load our data here<br/>}</span></pre><p id="5c75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">原子值上的<code class="fe lq lr ls lt b">exchange</code>函数会将loading设置为新值(false)，但会返回原始值进行评估。它消除了对额外代码行的需求，但这样做的代价是一些复杂性和许多Swift开发人员可能不熟悉的库的使用。</p><p id="b2c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，这也是矫枉过正，因为这段代码不太可能是可重入的，也不太可能跨多个线程调用。</p><h2 id="bd2b" class="ly lz it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">派遣一次</h2><p id="e23c" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">在过去，当大规模的Objective-C程序还在地球上运行时，我们可以使用GCD和<code class="fe lq lr ls lt b">dispatch_once</code>来确保给定的代码块被调用一次，并且只被调用一次。</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="b1e9" class="ly lz it lt b gy ma mb l mc md">var token: dispatch_once_t = 0</span><span id="e91a" class="ly lz it lt b gy me mb l mc md">func load() {<br/>  dispatch_once(&amp;token) {<br/>    // load our data here<br/>  }<br/>}</span></pre><p id="697d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不幸的是，<code class="fe lq lr ls lt b">dispatch_once</code>在Swift 3.0中被弃用，现在试图使用<code class="fe lq lr ls lt b">dispatch_once_t</code>会给你一个错误，告诉你使用惰性变量来代替。我们可以编写自己的版本来处理这种情况，但是…懒惰变量？</p><p id="5458" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们考虑一下。</p><h2 id="2fdb" class="ly lz it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">惰性变量</h2><p id="222c" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">惰性变量在使用之前不会被实例化，Swift保证所述初始化只会发生一次。听起来正是我们需要的行为。</p><p id="c7d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，如果我们用一个延迟加载的函数替换我们的加载函数会怎么样呢？</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="94cd" class="ly lz it lt b gy ma mb l mc md">class MyAccountListViewModel: ObservableObject {</span><span id="f00d" class="ly lz it lt b gy me mb l mc md">  @Published var accounts: [Account] = []</span><span id="6bd0" class="ly lz it lt b gy me mb l mc md">  lazy var load: () -&gt; Void = {<br/>     // load our data here<br/>     return {}<br/>  }()<br/>}</span></pre><p id="0fac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们创建一个带有闭包的惰性变量，它执行我们的load函数，然后返回一个空闭包。添加到末尾的<code class="fe lq lr ls lt b">()</code>确保了当变量被访问时闭包本身被求值。</p><p id="2193" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，在这个解决方案中，我们的加载代码在第一次计算惰性函数时被调用，然后每当再次调用<code class="fe lq lr ls lt b">load()</code>时，将使用<em class="mf">空</em>闭包。</p><p id="380d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，如果需要的话，我们仍然可以向load函数传递一个值，当然，请注意，我们返回的存根闭包也需要反映一个空的、未使用的值<code class="fe lq lr ls lt b">{ _ in }</code>。</p><p id="1238" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个解决方案……还不错。它消除了额外的标志变量和守卫，代价是变得有点棘手，并让我们的加载例程纯粹作为初始惰性求值的副作用而被调用。</p><h2 id="745c" class="ly lz it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">呼叫一次</h2><p id="5976" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">当然，确保我们的代码只执行一次的最好方法是只调用它一次。考虑我们的视图模型的以下变化。</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="e167" class="ly lz it lt b gy ma mb l mc md">class MyAccountListViewModel: ObservableObject {</span><span id="0cd0" class="ly lz it lt b gy me mb l mc md">    enum State {<br/>        case loading<br/>        case loaded([Account])<br/>        case empty(String)<br/>        case error(String)<br/>    }</span><span id="dfc7" class="ly lz it lt b gy me mb l mc md">    @Published var state: State = .loading</span><span id="0511" class="ly lz it lt b gy me mb l mc md">    @Injected(Container.userServiceType) var service:</span><span id="735d" class="ly lz it lt b gy me mb l mc md">    private var cancellables = Set&lt;AnyCancellable&gt;()</span><span id="4c84" class="ly lz it lt b gy me mb l mc md">    func load() {<br/>        service.fetch()<br/>            .receive(on: DispatchQueue.main)<br/>            .sink { [weak self] completion in<br/>                switch completion {<br/>                case .failure(let error):<br/>                    self?.state = .error(error.localizedDescription)<br/>                case .finished:<br/>                    break<br/>                }<br/>            } receiveValue: { [weak self] (users) in<br/>                if users.isEmpty {<br/>                    self?.state = .empty("No users found...")<br/>                } else {<br/>                    self?.state = .loaded(users)<br/>                }<br/>            }<br/>            .store(in: &amp;cancellables)<br/>    }</span><span id="ab8e" class="ly lz it lt b gy me mb l mc md">}</span></pre><p id="d03d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意我们的状态枚举，以及我们现在正在处理错误、空状态等的事实。老实说，这些都是我们在现实生活中可能要做的事情。</p><p id="2098" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在来看看我们的视图的相应变化。</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="da47" class="ly lz it lt b gy ma mb l mc md">struct MyAccountListLoadingView: View {</span><span id="69ed" class="ly lz it lt b gy me mb l mc md">    @StateObject var viewModel = MyAccountListViewModel()</span><span id="0d0e" class="ly lz it lt b gy me mb l mc md">    var body: some View {<br/>        switch viewModel.state {<br/>        case .loaded(let accounts):<br/>            AccountListView(accounts: accounts)<br/>        case .empty(let message):<br/>            MessageView(message: message, color: .gray)<br/>        case .error(let message):<br/>            MessageView(message: message, color: .red)<br/>        case .loading:<br/>            ProgressView()<br/>                .onAppear {<br/>                    viewModel.load()<br/>                }<br/>        }<br/>    }<br/>}</span></pre><p id="1b0b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们根据视图模型的状态显示不同的视图，并且<code class="fe lq lr ls lt b">onAppear</code>现在被附加到了<code class="fe lq lr ls lt b">ProgressView</code>上。因为我们的视图模型的初始状态是<code class="fe lq lr ls lt b">.loading</code>，所以<code class="fe lq lr ls lt b">ProgressView</code>出现并且我们的load函数被调用。</p><p id="552f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦账户被加载，进度视图将被移除，取而代之的是我们的账户列表视图(或者错误消息或空消息)。</p><p id="2c25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是在任何情况下，拥有<code class="fe lq lr ls lt b">onLoad</code>修饰符的视图都被删除，因此<code class="fe lq lr ls lt b">load()</code>永远不会被再次调用。</p><p id="5510" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我曾在SwiftUI中使用视图模型协议的<a class="ae nc" rel="noopener ugc nofollow" target="_blank" href="/swiftui-view-models-are-not-protocols-8c415c0325b1">中详细讨论过这种技术。你做错了。</a>在那里，我还解释了如何将这种方法与协议一起使用，以帮助测试和模拟数据。看看这个。</p><p id="f139" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，如果你有妄想症，你可以使用这种技术<em class="mf">和</em>其中一个早期的技术只是为了绝对积极的加载只会被调用一次。(类似腰带和吊带的方法。)</p><h2 id="9f31" class="ly lz it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">拉至刷新</h2><p id="3f97" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">我们最后一种方法的另一个好处是，它使得像拉至刷新这样的行为变得简单而容易。</p><p id="dcf0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只需再次调用视图模型中的<code class="fe lq lr ls lt b">load()</code>,当它完成时，加载将使用新数据、错误或消息再次更新结果状态。</p><p id="28b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您<em class="mf">可以</em>将状态重置为<code class="fe lq lr ls lt b">.loading</code>，但是那会显示我们原始的进度视图以及拉至刷新微调器，这可能不是最好的用户体验。</p><h2 id="1e44" class="ly lz it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">OnAppearOnce视图修改器</h2><p id="76a5" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">最后，虽然我更喜欢state方法，但它也可以方便地回到我们最初的基于标志的方法……稍加改动。我们将把标志放在<em class="mf">视图</em>中，而不是<em class="mf">视图模型</em>中。</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="68e5" class="ly lz it lt b gy ma mb l mc md">extension View {<br/>    func onAppearOnce(_ action: @escaping () -&gt; ()) -&gt; some View {<br/>        self.modifier(OnAppearOnceModifier(action: action))<br/>    }<br/>}</span><span id="69b7" class="ly lz it lt b gy me mb l mc md">private struct OnAppearOnceModifier: ViewModifier {<br/>    let action: () -&gt; ()<br/>    @State private var appearOnce = true<br/>    func body(content: Content) -&gt; some View {<br/>        content<br/>            .onAppear {<br/>                if appearOnce {<br/>                    appearOnce = false<br/>                    action()<br/>                }<br/>            }<br/>    }<br/>}</span></pre><p id="b9c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建我们自己的<code class="fe lq lr ls lt b">onAppearOnce</code>视图修改器，并添加我们自己的视图扩展来调用它，这允许我们在应用程序的许多地方和情况下使用基于标志的代码。</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="454d" class="ly lz it lt b gy ma mb l mc md">var body: some View {<br/>    List {<br/>        ...<br/>    }<br/>    .onAppearOnce {<br/>        viewModel.load()<br/>    }<br/>}</span></pre><p id="afbb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我认为这让我们兜了一圈。</p><h2 id="344b" class="ly lz it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">完成块</h2><p id="b42c" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">所以你有它。解决我们问题的几种方法。</p><p id="2ff2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你自己有吗？在评论里说说吧。当然，如果你想看更多，请鼓掌并订阅。</p><p id="ead2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下次见。</p></div></div>    
</body>
</html>