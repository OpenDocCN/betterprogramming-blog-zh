<html>
<head>
<title>How To Use Mocking in JavaScript Tests Using Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在使用Jest的JavaScript测试中使用嘲讽</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-mocking-in-javascript-tests-using-jest-67cf513f47c0?source=collection_archive---------6-----------------------#2019-10-25">https://betterprogramming.pub/how-to-use-mocking-in-javascript-tests-using-jest-67cf513f47c0?source=collection_archive---------6-----------------------#2019-10-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d77b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用mocking轻松编写令人敬畏的测试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b2bf528c320e0cfa2d67bf1aeb9728b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0UyP_l-RSYRmFlnH"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卢卡·布拉沃在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="992c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你曾经在软件项目中编写过测试，那么你可能熟悉各种测试方法。</p><p id="6586" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试是最基本但看似强大的测试方式。单元测试开发成本低，易于执行和调试，因为与端到端测试等更复杂的测试方法相比，单元测试可以隔离故障，并且执行速度相当快。</p><p id="d9cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能见过测试金字塔:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/808544a8d25c31867a0c1846b7940392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RyjdZYERRjU9ToT2nbb6Pw.png"/></div></div></figure><p id="1caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用单元测试可以测试什么？</p><ul class=""><li id="21cc" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">功能</li><li id="02b6" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">纯类</li><li id="daa1" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">组件(包括DOM):例如Angular / React / Vue.js / Web组件</li></ul><p id="c383" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@ali.dev/how-to-decide-between-unit-tests-end-to-end-tests-in-web-apps-429f53bc7357" rel="noopener">查看这篇文章，了解如何选择最合适的测试方法。</a></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="29c7" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">为什么函数、类或组件可能很难测试？</h1><ul class=""><li id="8c80" class="lw lx it lb b lc nj lf nk li nl lm nm lq nn lu mb mc md me bi translated">该类具有难以提供的依赖关系(例如，构造函数需要多个参数)</li><li id="2330" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">一个类的某些功能可能无法从外部访问(例如，<a class="ae ky" href="http://www.typescriptlang.org/docs/handbook/classes.html#public-private-and-protected-modifiers" rel="noopener ugc nofollow" target="_blank">在TypeScript </a>中使用private这样的访问修饰符)</li><li id="6cf3" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">函数/类/组件做了太多我们在测试中不想要的事情</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="af9a" class="no ms it bd mt np nq dn mx nr ns dp nb li nt nu nd lm nv nw nf lq nx ny nh nz bi translated">嘲讽对写出更好的测试有什么帮助？</h2><ul class=""><li id="08cd" class="lw lx it lb b lc nj lf nk li nl lm nm lq nn lu mb mc md me bi translated">手动模拟用于剔除我们在测试范围内不真正需要的功能。</li><li id="714e" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">通过避免依赖性(例如，访问真实的数据库，使用第三方库)使您的测试更快、更可靠</li><li id="3357" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">使事情更容易测试。使用mocking，您可以很容易地创建理想的测试设置来用于您的测试。</li><li id="5162" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">减少测试的设置。许多图书馆期望做一些设置以便工作。使用mocking，您可以忽略所有这些，而是专注于测试实际的功能。</li><li id="4bb3" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">我们不需要测试第三方代码，因为它可能已经测试过了。在单元测试中，我们希望专注于我们自己开发的应用程序的较小部分。模仿第三方依赖有助于让测试更关注我们的定制逻辑，而不是内部实现细节。</li></ul><p id="d1c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，在端到端和集成测试中，嘲讽也是可能的。然而，模拟对于单元测试来说更有意义。集成，尤其是端到端的测试，为您的应用程序及其构建块的正常运行提供了更高的有效性。因此，我们将重点放在单元测试中的嘲讽上。</p><p id="f45c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将在下面的例子中使用<a class="ae ky" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>,但是它也以类似的方式处理普通的JavaScript。我更喜欢将<a class="ae ky" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>作为JavaScript项目中的测试框架。我写过关于在<a class="ae ky" href="https://itnext.io/how-to-use-jest-in-angular-aka-make-unit-testing-great-again-e4be2d2e92d1" rel="noopener ugc nofollow" target="_blank">客户端</a>和<a class="ae ky" href="https://itnext.io/test-driven-develop-your-api-with-jest-supertest-in-node-js-7e1c6489b0a6" rel="noopener ugc nofollow" target="_blank">服务器端</a>应用以及<a class="ae ky" href="https://medium.com/better-programming/how-to-use-puppeteer-with-jest-typescript-530a139ffe40" rel="noopener">端到端测试</a>中使用Jest的帖子。简而言之，Jest是一个很好的选择，因为它使用简单，功能强大(例如，CLI，许多插件，框架无关的支持，不需要浏览器)。</p><p id="dab2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，您可以使用Jasmine、Mocha或其他测试框架，因为大多数测试框架都支持模拟，不管是哪种语言。这意味着这个概念也可以应用于其他编程语言，如Python、Java或C#。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="cb8c" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">模仿一个类的函数</h1><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="94bc" class="no ms it ob b gy of og l oh oi">describe('Email client', () =&gt; {<br/>  it('can receive emails', () =&gt; {<br/>     // we don't want to access any database in this test so we mock<br/>     // the <em class="oj">get</em> function of the <em class="oj">UserDao</em> class which connects to a <br/>     // database<br/>     spyOn(UserDao, 'get').and.returnValue({id: 123, name: 'John Doe'});<br/>     getEmails(UserDao.get('123'));<br/>  });<br/>});</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="3878" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">模仿导出的函数或常数</h1><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="86a9" class="no ms it ob b gy of og l oh oi"><em class="oj">// dev.helpers.js contains this exported function</em></span><span id="11c8" class="no ms it ob b gy ok og l oh oi"><em class="oj">export function isProduction() {<br/>  return process.env.</em>NODE_ENV === 'production';<br/><em class="oj">}<br/></em></span><span id="6536" class="no ms it ob b gy ok og l oh oi"><em class="oj">// email-client.spec.ts contains tests</em></span><span id="f3b7" class="no ms it ob b gy ok og l oh oi"><em class="oj">// we need to import with an alias since we can't spy on exported functions or constants directly<br/>import </em>* <em class="oj">as </em>devHelpers from "helpers/dev.helpers";</span><span id="be0a" class="no ms it ob b gy ok og l oh oi">describe('Email client', () =&gt; {<br/>  it('can send emails', () =&gt; {<br/>    spyOn(devHelpers, 'isProduction').and.returnValue(<em class="oj">false</em>);<br/>    sendEmail(); // we don't want to attempt to send a real email in this test<br/>  });<br/>});</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="f51c" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">模仿第三方库或自定义模块</h1><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="ddd5" class="no ms it ob b gy of og l oh oi">// we don't care about the actual implementation of this module (e.g. jQuery) in our tests since it is not important for our tests</span><span id="dd08" class="no ms it ob b gy ok og l oh oi">jest.mock('module_name');</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="818f" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="fdf4" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li ol lk ll lm om lo lp lq on ls lt lu im bi translated">感谢您阅读这篇关于如何使用嘲讽在JavaScript中编写更简单、更可靠的测试的文章。正如您所看到的，嘲讽帮助我们编写更稳定、更容易编写的测试。特别是对于单元测试，它允许我们测试东西而不用担心外部依赖。如果这有帮助，请在评论中告诉我。</p></div></div>    
</body>
</html>