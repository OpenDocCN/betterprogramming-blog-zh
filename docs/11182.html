<html>
<head>
<title>A Step-by-Step Guide on React Router 6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Router 6分步指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-step-by-step-guide-on-react-router-6-8964c10af364?source=collection_archive---------4-----------------------#2022-02-24">https://betterprogramming.pub/a-step-by-step-guide-on-react-router-6-8964c10af364?source=collection_archive---------4-----------------------#2022-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="71a9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">React路由器的综合示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4e81cc15a63b7aaa6f3a7badb7c493c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZbGsqURkn0X2Z7I3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@itfeelslikefilm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">🇸🇮·扬科·菲利</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="709d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于web应用程序，路由是根据提供的URL、参数或用户对按钮、链接、图标等的操作来呈现整个或部分页面的机制。</p><p id="9721" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React本身不包括路由。<code class="fe lv lw lx ly b"><a class="ae ky" href="https://npm.im/react-router" rel="noopener ugc nofollow" target="_blank">react-router</a></code>兼容React最新版本，是React应用最受欢迎的路由选择。React Router支持在各种组件的视图之间导航。它读取和控制浏览器URL，并保持UI与URL同步。</p><p id="c531" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React路由器6于2021年11月3日发布。让我们过一遍如何使用它的细节。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6c1d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">导航术语</h1><p id="47d0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先，我们回顾一些在浏览器导航中经常使用的术语。</p><h2 id="8cb4" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">统一资源定位器</h2><p id="910a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">URL(统一资源定位器)是网络上给定的唯一资源的地址。浏览器有一个地址栏，供用户键入特定的URL，或者以编程方式填充。</p><p id="85c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">URL</code>接口用于解析、构造、规范化和编码URL。它有许多可以读取和修改的属性。</p><p id="2078" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个URL:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="c9b1" class="nd mh it ly b gy nt nu l nv nw">const url = new URL('https://john:password@www.mycompany.com:8080/users/?id=5#profile');</span></pre><p id="1f1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是生成的对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="cde4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">url.searchParams.get('id')</code>返回5。</p><h2 id="bc00" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">位置</h2><p id="d03d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Location是一个表示URL位置的对象。它基于浏览器的<code class="fe lv lw lx ly b">window.location</code>对象。</p><p id="e3fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在浏览器的地址栏中键入URL，<code class="fe lv lw lx ly b">www.google.com</code>，并且<code class="fe lv lw lx ly b">window.location</code>被设置为以下值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="c3ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是React路由器中的<code class="fe lv lw lx ly b">Path</code>和<code class="fe lv lw lx ly b">Location</code>定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="17a7" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">历史</h2><p id="5911" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有两个历史API可以跟踪和操作浏览器历史:</p><ul class=""><li id="d0fa" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><code class="fe lv lw lx ly b">history</code> API:它在概要文件的生命周期内跟踪用户在任何选项卡中访问过的主框架URL。</li><li id="820d" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">History</code>接口:管理浏览器会话历史。即它跟踪每个标签中的导航。</li></ul><p id="2b9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe lv lw lx ly b">History</code>界面在现代浏览器中更有意义，<code class="fe lv lw lx ly b">window.history</code>包含了一个<code class="fe lv lw lx ly b">History</code>的条目。这里有一个<code class="fe lv lw lx ly b">window.history</code>的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="50a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是React路由器中的<code class="fe lv lw lx ly b">History</code>定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ada2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">建立工作环境</h1><p id="bbb8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">React路由器发布了3个包:</p><ul class=""><li id="aa96" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><code class="fe lv lw lx ly b">react-router</code>包含React路由器的大部分核心功能，包括路由匹配算法和大部分核心组件和钩子。</li><li id="4e5c" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">react-router-dom</code>包含了来自<code class="fe lv lw lx ly b">react-router</code>的所有东西，并添加了一些特定于DOM的API，包括<code class="fe lv lw lx ly b">&lt;BrowserRouter&gt;</code>、<code class="fe lv lw lx ly b">&lt;HashRouter&gt;</code>和<code class="fe lv lw lx ly b">&lt;Link&gt;</code>。</li><li id="6535" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">react-router-native</code>包含了来自<code class="fe lv lw lx ly b">react-router</code>的所有内容，并添加了一些专门针对React Native的API，包括<code class="fe lv lw lx ly b">&lt;NativeRouter&gt;</code>和一个本地版本的<code class="fe lv lw lx ly b">&lt;Link&gt;</code>。</li></ul><p id="faab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于web应用程序，我们需要的只是<code class="fe lv lw lx ly b">react-router-dom</code>。</p><p id="4060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往，我们构建了<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/an-in-depth-guide-for-create-react-app-5-cra-5-b94b03c233f2"> Create React App </a>环境:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="7b3d" class="nd mh it ly b gy nt nu l nv nw">npx create-react-app react-router<br/>cd react-router</span></pre><p id="88fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置<code class="fe lv lw lx ly b">react-router-dom</code>:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="d1bb" class="nd mh it ly b gy nt nu l nv nw">npm i <!-- -->react-router-dom</span></pre><p id="1153" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，安装了<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/knicklabs/lorem-ipsum.js" rel="noopener ugc nofollow" target="_blank">lorem-ipsum</a></code>来为页面生成lorem ipsum占位符文本。Lorem ipsum文本通常用作出版、图形设计和web开发中的占位符文本。</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="8752" class="nd mh it ly b gy nt nu l nv nw">npm i lorem-ipsum</span></pre><p id="7fe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">react-router-dom</code>和<code class="fe lv lw lx ly b">lorem-ipsum</code>成为<code class="fe lv lw lx ly b">package.json</code>中<code class="fe lv lw lx ly b"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/package-jsons-dependencies-in-depth-a1f0637a3129">dependencies</a></code>的一部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="45d0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">设置路线</h1><p id="4912" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">路由器是一个有状态的顶级组件，它使所有其他导航组件和挂钩都可以工作。React路由器有<code class="fe lv lw lx ly b">BrowserRouter</code>、<code class="fe lv lw lx ly b">HashRouter</code>、<code class="fe lv lw lx ly b">StaticRouter</code>、<code class="fe lv lw lx ly b">NativeRouter</code>、<code class="fe lv lw lx ly b">MemoryRouter</code>。对于web应用程序，通常使用<code class="fe lv lw lx ly b">BrowserRouter</code>。一个应用程序应该有一个<code class="fe lv lw lx ly b">&lt;BrowserRouter&gt;</code>，它包装了一个或多个<code class="fe lv lw lx ly b">&lt;Routes&gt;</code>。</p><p id="2efb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">&lt;Routes&gt;</code>检查其所有的<code class="fe lv lw lx ly b">children</code> <code class="fe lv lw lx ly b">&lt;Route&gt;</code>元素，以找到最佳匹配，并呈现UI的该部分。</p><p id="d513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">&lt;Route&gt;</code>被定义为一个对象或一个路线元素。如果是物体，物体的形状为<code class="fe lv lw lx ly b">{ path, element }</code>。如果是路由元素，组件的形状为<code class="fe lv lw lx ly b">&lt;Route path element&gt;</code>。当路径模式匹配当前URL时，<code class="fe lv lw lx ly b">element</code>属性被渲染。</p><p id="96c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们准备在<code class="fe lv lw lx ly b">src/Pages.js</code>管理几个页面:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="41bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第3–10行定义了函数<code class="fe lv lw lx ly b">getPage</code>。它生成一个标题页面，页面内容由<code class="fe lv lw lx ly b">loremIpsum()</code>生成，包含5个随机的句子(第7行)。</p><p id="0858" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">getPage</code>函数用于生成<code class="fe lv lw lx ly b">PageOne</code>(第12行)和<code class="fe lv lw lx ly b">PageTwo</code>(第13行)。下面是<code class="fe lv lw lx ly b">PageOne</code>的样子，和<code class="fe lv lw lx ly b">PageTwo</code>看起来差不多。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/14cccea5e6b2f55f89701ecee214bfd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qKIzxqiQQBGQY6xHgx488g.png"/></div></div></figure><p id="2a38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">src/App.js</code>中，创建了两条路线:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="3b47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">&lt;BrowserRouter&gt;</code>和<code class="fe lv lw lx ly b">&lt;Routes&gt;</code>用于定义路由器(第6-11行)。</p><p id="e43e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">app里有两个<code class="fe lv lw lx ly b">&lt;Route&gt;</code>。当URL与路径<code class="fe lv lw lx ly b">"one"</code>匹配时，app显示<code class="fe lv lw lx ly b">PageOne</code>(第8行)。当URL匹配路径时，<code class="fe lv lw lx ly b">"two"</code>，app显示<code class="fe lv lw lx ly b">PageTwo</code>(第9行)。</p><p id="8aee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过运行命令<code class="fe lv lw lx ly b">npm start</code>执行应用程序。</p><p id="5b5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">http://localhost:3000/one</code>显示<code class="fe lv lw lx ly b">PageOne</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/02b4d0b37192b89d8db926eed7e48a74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMfZQAQz4L0krkRw6oAbcg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8e4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">http://localhost:3000/two</code>显示<code class="fe lv lw lx ly b">PageTwo</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/927bacce522e341487c0bb67bef9f056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bzoZzsCrr_o7-ORzVnr9IQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2876" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用程序适用于路径<code class="fe lv lw lx ly b">"one"</code>和<code class="fe lv lw lx ly b">"two"</code>。但是，<code class="fe lv lw lx ly b">http://localhost:3000</code>不显示任何内容，和任何无效的URL一样，比如<code class="fe lv lw lx ly b">http://localhost:3000/anything</code>。</p><p id="9a4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题可以通过通配符路径(第8行)来解决:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="a88c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">http://localhost:3000/two</code>显示<code class="fe lv lw lx ly b">PageTwo</code>。否则显示<code class="fe lv lw lx ly b">PageOne</code>。</p><p id="ab19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于React Router 6足够智能，可以选择最具体的匹配，因此路由顺序并不重要。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7808" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">设置嵌套路线</h1><p id="6dcb" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">上例中的两条路线如预期的那样工作。但是，在浏览器地址栏中键入URL并不方便。我们希望通过点击一个链接来获得导航功能，这个链接就是<code class="fe lv lw lx ly b">&lt;Link&gt;</code>。</p><p id="8913" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">&lt;Link&gt;</code>用一个真实的<code class="fe lv lw lx ly b">href</code>呈现一个可访问的<code class="fe lv lw lx ly b">&lt;a&gt;</code>元素，该元素指向它所链接的资源。单击该链接可以设置URL并跟踪浏览历史。</p><p id="bfb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">src/MainPage.js</code>是用<code class="fe lv lw lx ly b">&lt;Link&gt;</code>创造的s:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="8052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第4–13行用一组导航链接定义了<code class="fe lv lw lx ly b">&lt;nav&gt;</code>元素。</p><p id="2fd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第7行是指向路径<code class="fe lv lw lx ly b">"/one"</code>的链接。链接文字为<code class="fe lv lw lx ly b">"Page One"</code>。</p><p id="e41b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第10行是指向路径<code class="fe lv lw lx ly b">"/two"</code>的链接。链接文字为<code class="fe lv lw lx ly b">"Page Two"</code>。</p><p id="96d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">&lt;Link to&gt;</code>值可以相对于呈现它们的路线的路径。即指定路径时不带前导<code class="fe lv lw lx ly b">/</code>。或者，7号线可以指向<code class="fe lv lw lx ly b">"one"</code>，10号线可以指向<code class="fe lv lw lx ly b">"two"</code>。</p><p id="1d29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">src/App.js</code>中使用<code class="fe lv lw lx ly b">MainPage</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="0349" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">9号线是一条<code class="fe lv lw lx ly b">index</code>路由，是一条没有路径的子路由。当网址匹配<code class="fe lv lw lx ly b">"/"</code>时，app显示<code class="fe lv lw lx ly b">MainPage</code>。这是索引页:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/72b789176408875c22fca7e5c9df78c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UK-j94fcXh6NiBYqAWzrWg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0e80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击<code class="fe lv lw lx ly b">Page One</code>链接，进入<code class="fe lv lw lx ly b">PageOne</code>。点击<code class="fe lv lw lx ly b">Page Two</code>链接，进入<code class="fe lv lw lx ly b">PageTwo</code>。</p><p id="2e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在<code class="fe lv lw lx ly b">PageOne</code>或<code class="fe lv lw lx ly b">PageTwo</code>中，我们不能使用链接来导航。为了解决这个问题，我们在<code class="fe lv lw lx ly b">MainPage</code>中创建了<code class="fe lv lw lx ly b">&lt;Outlet&gt;</code>组件。outlet组件呈现路径中的下一个匹配(<code class="fe lv lw lx ly b">PageTwo</code>的<code class="fe lv lw lx ly b">"one"</code>和<code class="fe lv lw lx ly b">PageTwo</code>的<code class="fe lv lw lx ly b">"two"</code>)。</p><p id="362b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是带出口的<code class="fe lv lw lx ly b">src/MainPage.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="36ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第15行是<code class="fe lv lw lx ly b">&lt;hr&gt;</code>元素，它是分隔内容的水平标尺。</p><p id="da0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第16行是呈现活动子路线的<code class="fe lv lw lx ly b">&lt;Outlet&gt;</code>组件。</p><p id="eb47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">&lt;Outlet&gt;</code>调出嵌套路由，其中每个路由可以有子路由来占据URL的一部分。嵌套路由通常使用相对链接(第8行和第11行)。</p><p id="0812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是修改后的<code class="fe lv lw lx ly b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b4d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第9行，顶层的route是<code class="fe lv lw lx ly b">"/"</code>，它呈现了<code class="fe lv lw lx ly b">MainPage</code>组件。它下面有三个子路由:</p><ul class=""><li id="b790" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">索引路径(第10行):它显示文本，<code class="fe lv lw lx ly b">No page is selected</code>。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/d40c97ac2241560898781ab0e320cec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X_XbCN-e58lHZTv8wp3C8Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ul class=""><li id="d1ce" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">通配符路由(第11行):它显示了组件，<code class="fe lv lw lx ly b">PageOne</code>。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/eccb86b75b67044b98ed65110e82830f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DADxHNI5CtFjTm-DXiRASw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ul class=""><li id="6766" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><code class="fe lv lw lx ly b">"two"</code>路线(第12行):显示组件<code class="fe lv lw lx ly b">PageTwo</code>。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/825ded75f6d7d39059faf25dc087ff7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z69I7uPOZEn9b3VeUjmdRQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3e91" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">用户出口挂钩</h1><p id="483b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">代替<code class="fe lv lw lx ly b">&lt;Routes&gt;</code>，我们也可以使用钩子<code class="fe lv lw lx ly b">useRoutes</code>来完成同样的事情。</p><p id="5a6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">src/App.js</code>中的嵌套路线可以用<code class="fe lv lw lx ly b">useRoutes</code>重写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第6–16行，我们使用钩子<code class="fe lv lw lx ly b">useRoutes</code>，从数据结构生成<code class="fe lv lw lx ly b">routes</code>对象。</p><p id="98c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须创建<code class="fe lv lw lx ly b">AppWrapper</code>来将<code class="fe lv lw lx ly b">routes</code>包装在<code class="fe lv lw lx ly b">&lt;browserRouter&gt;</code>中(第20–26行)。否则，我们会遇到以下错误:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="08ea" class="nd mh it ly b gy nt nu l nv nw">Error: useRoutes() may be used only in the context of a component.</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e965" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用位置</h1><p id="bcd5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Location是一个表示URL位置的对象。它基于浏览器的<code class="fe lv lw lx ly b">window.location</code>对象。</p><p id="fccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">钩子<code class="fe lv lw lx ly b">useLocation</code>返回当前位置对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="f5aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第7行，<code class="fe lv lw lx ly b">location</code>由钩子生成，<code class="fe lv lw lx ly b">useLocation</code>。</p><p id="3646" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第8–10行定义了<code class="fe lv lw lx ly b">useEffect</code>，如果位置值发生变化，它将记录位置值。</p><ul class=""><li id="f018" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">当URL为<code class="fe lv lw lx ly b">http://localhost:3000/</code>时，控制台记录:</li></ul><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="8f53" class="nd mh it ly b gy nt nu l nv nw">Current location is {pathname: '/', search: '', hash: '', state: null, key: 'default'}</span></pre><ul class=""><li id="95a5" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">当URL为<code class="fe lv lw lx ly b">http://localhost:3000/one</code>时，控制台记录:</li></ul><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="9b05" class="nd mh it ly b gy nt nu l nv nw">Current location is {pathname: '/one', search: '', hash: '', state: null, key: 'f2114bru'}</span></pre><ul class=""><li id="09ef" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">当URL为<code class="fe lv lw lx ly b">http://localhost:3000/two</code>时，控制台记录:</li></ul><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="2a60" class="nd mh it ly b gy nt nu l nv nw">Current location is {pathname: '/two', search: '', hash: '', state: null, key: 'if9ngy0q'}</span></pre><ul class=""><li id="e779" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">当URL为<code class="fe lv lw lx ly b">http://localhost:3000/anything</code>时，控制台记录:</li></ul><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="d0d7" class="nd mh it ly b gy nt nu l nv nw">Current location is {pathname: '/anything', search: '', hash: '', state: null, key: 'default'}</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f775" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">useParams挂钩</h1><p id="bea4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了让这个例子更有趣，我们嵌套了更多的路由。在<code class="fe lv lw lx ly b">MainPage</code>上，除了<code class="fe lv lw lx ly b">"Page One"</code>和<code class="fe lv lw lx ly b">"Page Two"</code>的链接，还有更详细的<code class="fe lv lw lx ly b">"P1"</code>(第1段)和<code class="fe lv lw lx ly b">"P2"</code>(第2段)的链接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/59430780152cf9d200f4f2f6b7dbdcf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NdnM7bDRokeNJ_Cmx2CqYA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c52e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是修改后的<code class="fe lv lw lx ly b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="2a0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在路径<code class="fe lv lw lx ly b">"one"</code>(第23行)下，有另一个子路由，带有动态参数<code class="fe lv lw lx ly b">":id"</code>(第25行)。</p><p id="7879" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在路径<code class="fe lv lw lx ly b">"two"</code>(第28行)下，有另一个子路由，带有动态参数<code class="fe lv lw lx ly b">":id"</code>(第30行)。</p><p id="16ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是改装过的<code class="fe lv lw lx ly b">src/MainPage.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="6278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在链接<code class="fe lv lw lx ly b">"Page One"</code>旁边，添加了链接<code class="fe lv lw lx ly b">P1</code>(路径<code class="fe lv lw lx ly b">"one/1"</code>)和P2(路径<code class="fe lv lw lx ly b">"one/2"</code>)(第9-10行)。</p><p id="a890" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在链接<code class="fe lv lw lx ly b">"Page Two"</code>旁边，添加了链接<code class="fe lv lw lx ly b">P1</code>(路径<code class="fe lv lw lx ly b">"two/1"</code>)和<code class="fe lv lw lx ly b">P2</code>(路径<code class="fe lv lw lx ly b">"two/2"</code>)(第13–14行)。</p><p id="0827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">useParams</code>钩子从当前URL返回动态参数的键/值对对象。这里是修改后的<code class="fe lv lw lx ly b">src/Pages.js</code>，使用<code class="fe lv lw lx ly b">useParams</code>挂钩:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="c20e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为在React组件中必须使用一个钩子，所以第4–14行将<code class="fe lv lw lx ly b">getPage</code>函数改为<code class="fe lv lw lx ly b">BuildPage</code>组件。</p><p id="fe58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第5行使用钩子<code class="fe lv lw lx ly b">useParams</code>来检索动态路径<code class="fe lv lw lx ly b">id</code>。<code class="fe lv lw lx ly b">id</code>值显示在内容的开头(第10行)。</p><p id="07ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">14线通过<code class="fe lv lw lx ly b">BuildPage</code>产生<code class="fe lv lw lx ly b">PageOne</code>。</p><p id="a018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">15线通过<code class="fe lv lw lx ly b">BuildPage</code>产生<code class="fe lv lw lx ly b">PageTwo</code>。</p><p id="2cf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当URL为<code class="fe lv lw lx ly b">http://localhost:3000/one/1</code>时，控制台记录:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="9eff" class="nd mh it ly b gy nt nu l nv nw">Current location is {pathname: '/one/1', search: '', hash: '', state: null, key: 'qpdrrtyg'}</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4141" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><code class="fe lv lw lx ly b">useNavigate</code></h1><p id="3395" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">useNavigate</code>钩子返回一个函数，该函数可用于编程导航。将<code class="fe lv lw lx ly b">src/MainPage.js</code>中的两个<code class="fe lv lw lx ly b">&lt;Link&gt;</code>替换为<code class="fe lv lw lx ly b">&lt;button&gt;</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="0822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4号线返回<code class="fe lv lw lx ly b">useNavigate</code>钩。</p><p id="d140" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第10–12行定义了按钮<code class="fe lv lw lx ly b">"Page One"</code>，其中<code class="fe lv lw lx ly b">onClick</code>处理程序导航到相对路径<code class="fe lv lw lx ly b">"one"</code>。</p><p id="ec02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第16–18行定义了按钮<code class="fe lv lw lx ly b">"Page Two"</code>，其中<code class="fe lv lw lx ly b">onClick</code>处理程序导航到相对路径<code class="fe lv lw lx ly b">"two"</code>。</p><p id="4a4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行应用程序。按钮的作用类似于链接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/89dec8f0c0bdbae3c4d9896e6b764946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MmzbNDkKcHT5VSyUM2gRbg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8211" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">navigate</code>函数有两个签名:</p><ul class=""><li id="217d" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">用可选的第二个参数<code class="fe lv lw lx ly b">{ replace, state }</code>传递一个<code class="fe lv lw lx ly b">To</code>值(与<code class="fe lv lw lx ly b">&lt;Link to&gt;</code>类型相同)。</li><li id="e15e" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">将增量编号传递到历史堆栈中。比如<code class="fe lv lw lx ly b">navigate(-1)</code>就相当于点击了返回键。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="632f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">其他挂钩</h1><p id="e0d7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们已经展示了如何使用<code class="fe lv lw lx ly b">useLocation</code>、<code class="fe lv lw lx ly b">useNavigate</code>、<code class="fe lv lw lx ly b">useParams</code>和<code class="fe lv lw lx ly b">useRoutes</code>。</p><p id="9384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有其他React路由器挂钩:</p><ul class=""><li id="56b0" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><code class="fe lv lw lx ly b">useHref</code>:它返回一个URL，可以用来链接到给定的<code class="fe lv lw lx ly b">to</code>位置，甚至在React路由器之外。</li><li id="7961" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">useLinkClickHandler</code>:构建自定义链接时，返回一个用于导航的click事件处理程序。</li><li id="7c59" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">useInRouterContext</code>:如果组件正在<code class="fe lv lw lx ly b">&lt;Router&gt;</code>的上下文中呈现，则返回<code class="fe lv lw lx ly b">true</code>，否则返回<code class="fe lv lw lx ly b">false</code>。</li><li id="4d92" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">useNavigationType</code>:返回用户如何到达当前页面，通过历史堆栈上的<code class="fe lv lw lx ly b">Action.Pop</code>、<code class="fe lv lw lx ly b">Action.Push</code>或<code class="fe lv lw lx ly b">Action.Replace</code>。</li><li id="9710" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">useMatch</code>:返回给定路径相对于当前位置的路径匹配数据。</li><li id="6ebb" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">useOutlet</code>:返回该层路由层次中子路由的元素。</li><li id="0a41" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">useResolvedPath</code>:根据当前位置的路径名，解析给定<code class="fe lv lw lx ly b">to</code>值中位置的<code class="fe lv lw lx ly b">pathname</code>。</li><li id="63b0" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lv lw lx ly b">useSearchParams</code>:用于读取和修改当前位置的URL中的查询字符串。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e161" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="db03" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">React Router 6功能丰富，易于使用。它与React的最新版本兼容。由于它从版本5引入了一些突破性的变化，建议在升级应用程序之前等待向后兼容包的发布。</p><p id="b8e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。如果你有兴趣，可以看看<a class="ae ky" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener">我的其他媒体文章</a>。</p><p id="0f6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oq">注:感谢Urian Chang和Josh Brown与我一起评估React Router 6。</em></p></div></div>    
</body>
</html>