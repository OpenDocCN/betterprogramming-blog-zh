<html>
<head>
<title>Working With Texture In Three.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Three.js中使用纹理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/working-with-texture-in-three-js-40ce5e8b96c4?source=collection_archive---------9-----------------------#2022-06-06">https://betterprogramming.pub/working-with-texture-in-three-js-40ce5e8b96c4?source=collection_archive---------9-----------------------#2022-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5c84" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在曲面上试验纹理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/1acadd64356155c819461130e704ddca.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*QpkAq6XATMPN1TqxxMr27g.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="8714" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经写过<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/working-with-three-js-the-popular-3d-javascript-library-bd2e9b03c95a"> three.js基础</a>、<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/working-with-3d-model-in-three-js-e228621141af"> 3D建模</a>，是时候检查一下纹理了。</p><p id="cc80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在视觉艺术中，纹理是艺术作品的感知表面质量。它是2D和3D设计的一个元素，通过其感知的视觉和物理属性来区分。</p><p id="6a33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<a class="ae lq" href="https://github.com/mrdoob/three.js/" rel="noopener ugc nofollow" target="_blank"> three.js </a>中，创建纹理是为了应用于表面，或者作为反射或折射贴图。纹理映射是一种在计算机生成的2D图形或3D模型上定义高频细节、表面纹理或颜色信息的方法。用最简单的术语来说，纹理映射意味着获取一幅图像并在一个表面上拉伸它。在本文中，我们将重点讨论如何进行纹理映射。</p><h1 id="b95d" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">设置Create React应用程序工作环境</h1><p id="d44c" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们使用<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/an-in-depth-guide-for-create-react-app-5-cra-5-b94b03c233f2"> Create React App </a>作为基础来探索three.js。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="3bc3" class="mt ls it mp b gy mu mv l mw mx">% npx create-react-app react-three<br/>% cd react-three</span></pre><p id="26d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">设置几个包:</p><ul class=""><li id="f67f" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated">three.js ( <code class="fe nh ni nj mp b">three</code>):是一个3D JavaScript库，在网页上渲染3D内容。它旨在创建一个易于使用、轻量级、跨浏览器、通用的3D库。</li><li id="f68a" class="my mz it kw b kx nk la nl ld nm lh nn ll no lp nd ne nf ng bi translated"><a class="ae lq" href="https://github.com/pmndrs/react-three-fiber" rel="noopener ugc nofollow" target="_blank"> react-three-fiber </a> ( <code class="fe nh ni nj mp b">@react-three/fiber</code>):是three.js的react渲染器，它允许我们使用JSX编写three.js，更具声明性。React包装器还在幕后处理很多事情，比如调整画布大小和处理卸载的对象。</li><li id="cdda" class="my mz it kw b kx nk la nl ld nm lh nn ll no lp nd ne nf ng bi translated"><code class="fe nh ni nj mp b"><a class="ae lq" href="https://github.com/pmndrs/drei" rel="noopener ugc nofollow" target="_blank">@react-three/drei</a></code>:这是一个渲染react-three-fiber的有用助手集合。它使得使用多种类型的对象变得更加容易，例如相机、控件、图像、形状、3D模型、环境等。</li></ul><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="09a6" class="mt ls it mp b gy mu mv l mw mx">% npm i three @react-three/fiber @react-three/drei</span></pre><p id="ad16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些包裹在<code class="fe nh ni nj mp b">package.json</code>变成了<code class="fe nh ni nj mp b"><a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/package-jsons-dependencies-in-depth-a1f0637a3129">dependencies</a></code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="db63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Create React应用程序已经为three.js项目做好了准备。</p><h1 id="41e0" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">给平面添加纹理</h1><p id="f3ab" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在几何学中，平面是向各个方向无限延伸的平面。在three.js中，<code class="fe nh ni nj mp b">PlaneBufferGeometry</code>是定义了宽度和高度的平面。等价地，它是react-three-fiber中的<code class="fe nh ni nj mp b">planeBufferGeometry</code>元素，以小写的p开头。</p><p id="27f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的<code class="fe nh ni nj mp b">src/App.js</code>显示一架飞机:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8897" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/working-with-three-js-the-popular-3d-javascript-library-bd2e9b03c95a">详细解释了</a>什么是three.js以及它在React中是如何工作的。网格是一种基于三角形多边形网格的对象。骨骼构成了三维物体的外形。它由几何体(形状)、材质(表面)和场景(位置)定义。</p><p id="ff0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码中，<code class="fe nh ni nj mp b">Shape</code>组件(第3-9行)由一个<code class="fe nh ni nj mp b">mesh</code>(第5-8行)定义，它包括一个宽度和高度定义为<code class="fe nh ni nj mp b">[0.5, 0.5]</code>的平面。</p><p id="0fc4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nh ni nj mp b">Shape</code>显示在<code class="fe nh ni nj mp b">Canvas</code>上(第13-18行)，呈现三的组件。<code class="fe nh ni nj mp b">Canvas</code>将<code class="fe nh ni nj mp b">camera</code>的道具设置为<code class="fe nh ni nj mp b">{ fov: 70, near: 0.01, far: 100, position: [0, 0, 2] }</code>(第14行)，并以<code class="fe nh ni nj mp b">black</code>背景占据整个视口(第15行)。</p><p id="70ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">执行<code class="fe nh ni nj mp b">npm start</code>，我们看到一架飞机。默认情况下，<code class="fe nh ni nj mp b">planeBufferGeometry</code>为白色。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/c3a9e6beb15dae8b03b6399f6ee351be.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*ZQh68gUSg7gAgZ0PEchk7w.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="bde2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">纹理映射在曲面上拉伸图像。即，每个像素处的纹理由图像的映射像素定义，该像素被称为纹理元素。文本图像的轴也称为UV坐标，以区别于XYZ坐标的3D空间。所以纹理贴图也叫UV贴图。</p><p id="7392" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的图像被用作我们的纹理。文件<code class="fe nh ni nj mp b">flower.jpg</code>位于<code class="fe nh ni nj mp b">public</code>文件夹下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/c1eaf2d7ec54d0654b700684177bbb7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*vSM-6cHWyZ6Apyp60FHQpA.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="cbf6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nh ni nj mp b">src/App.js</code>被修改为显示纹理:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="582d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于加载文件可能需要一些时间，<code class="fe nh ni nj mp b">flower.jpg</code>，<code class="fe nh ni nj mp b">Suspense</code>用于显示一个空屏幕(<code class="fe nh ni nj mp b">null</code>)作为后备(第21行)。参考<a class="ae lq" href="https://medium.com/p/e228621141af" rel="noopener">另一篇文章</a>关于如何显示进度文本或其他用于后退的更好的用户界面。</p><p id="416e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第6行，来自<code class="fe nh ni nj mp b">@react-three/fiber</code>的<code class="fe nh ni nj mp b">useLoader</code>钩子调用三的<code class="fe nh ni nj mp b">TextureLoader</code>来加载图像到一个<code class="fe nh ni nj mp b">colorMap</code>，它是一个<code class="fe nh ni nj mp b">Texture</code>对象，有以下数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/d8f58d741f2d9cbe3e1a379ced1f181c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYutH-M5ZlAmTvyny2bpmA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="6304" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">材质使用多个贴图来描述对象的外观。<code class="fe nh ni nj mp b">MeshBasicMaterial</code>是绘制几何图形的材料。这种材质不受灯光影响。在第10行，<code class="fe nh ni nj mp b">meshBasicMaterial</code>将<code class="fe nh ni nj mp b">map</code>道具设置为<code class="fe nh ni nj mp b">colorMap</code>。<code class="fe nh ni nj mp b">mesh</code>里面的纹理应用到平面上，我们看到的是有图像纹理的平面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/bab41864b72340f3313d1ce36ee14d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*IrolHnGjGYwLIYGIhBrCLA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="356e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">UV比率被箝位以适应方形，这是可以理解的。为什么纹理颜色看起来洗出来了？</p><p id="7e3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是因为<code class="fe nh ni nj mp b">@react-three/fiber</code>的实施。如果代码是用<code class="fe nh ni nj mp b">THREE.MeshBasicMaterial</code>写的，颜色和原来一样新鲜。</p><p id="bd8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nh ni nj mp b">meshBasicMaterial</code>中的每个纹理元素由三种成分决定:</p><ul class=""><li id="0a82" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated">从源(<code class="fe nh ni nj mp b">flower.jpg</code>)到目的(<code class="fe nh ni nj mp b">white</code>)的混合颜色</li><li id="077d" class="my mz it kw b kx nk la nl ld nm lh nn ll no lp nd ne nf ng bi translated"><code class="fe nh ni nj mp b">transparent</code> ( <code class="fe nh ni nj mp b">boolean</code>)和<code class="fe nh ni nj mp b">opacity</code> ( <code class="fe nh ni nj mp b">0.0 — 1.0</code>)的设定</li><li id="fd6a" class="my mz it kw b kx nk la nl ld nm lh nn ll no lp nd ne nf ng bi translated">其他道具</li></ul><p id="6b57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">纹理颜色可以使用以下道具的自定义混合进行调整:</p><ul class=""><li id="de33" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated"><code class="fe nh ni nj mp b">blending</code>:在<code class="fe nh ni nj mp b">THREE.NoBlending</code>、<code class="fe nh ni nj mp b">THREE.NormalBlending</code>、<code class="fe nh ni nj mp b">THREE.AdditiveBlending</code>、<code class="fe nh ni nj mp b">THREE.SubtractiveBlending</code>、<code class="fe nh ni nj mp b">THREE.MultiplyBlending</code>、<code class="fe nh ni nj mp b">THREE.CustomBlending</code>中选择<code class="fe nh ni nj mp b">THREE.CustomBlending</code>。</li><li id="50b1" class="my mz it kw b kx nk la nl ld nm lh nn ll no lp nd ne nf ng bi translated"><code class="fe nh ni nj mp b">blendEquation</code>:在<code class="fe nh ni nj mp b">THREE.SubtractEquation</code>、<code class="fe nh ni nj mp b">THREE.ReverseSubtractEquation</code>、<code class="fe nh ni nj mp b">THREE.MinEquation</code>、<code class="fe nh ni nj mp b">THREE.MaxEquation</code>选项中选择<code class="fe nh ni nj mp b">THREE.AddEquation</code>(默认)。</li><li id="eb61" class="my mz it kw b kx nk la nl ld nm lh nn ll no lp nd ne nf ng bi translated"><code class="fe nh ni nj mp b">blendSrc</code>:在<code class="fe nh ni nj mp b">THREE.ZeroFactor</code>、<code class="fe nh ni nj mp b">THREE.OneFactor</code>、<code class="fe nh ni nj mp b">THREE.SrcColorFactor</code>、<code class="fe nh ni nj mp b">THREE.OneMinusSrcColorFactor</code>、<code class="fe nh ni nj mp b">THREE.SrcAlphaFactor</code>、<code class="fe nh ni nj mp b"> THREE.OneMinusSrcAlphaFactor</code>、<code class="fe nh ni nj mp b">THREE.DstAlphaFactor</code>、<code class="fe nh ni nj mp b"> THREE.OneMinusDstAlphaFactor</code>、<code class="fe nh ni nj mp b">THREE.DstColorFactor</code>、<code class="fe nh ni nj mp b"> THREE.OneMinusDstColorFactor</code>、<code class="fe nh ni nj mp b">THREE.SrcAlphaSaturateFactor</code>中选择<code class="fe nh ni nj mp b">THREE.SrcColorFactor</code>。</li><li id="ead0" class="my mz it kw b kx nk la nl ld nm lh nn ll no lp nd ne nf ng bi translated"><code class="fe nh ni nj mp b">blendDst</code>:从<code class="fe nh ni nj mp b">THREE.ZeroFactor</code>、<code class="fe nh ni nj mp b">THREE.OneFactor</code>、<code class="fe nh ni nj mp b">THREE.SrcColorFactor</code>、<code class="fe nh ni nj mp b">THREE.OneMinusSrcColorFactor</code>、<code class="fe nh ni nj mp b">THREE.SrcAlphaFactor</code>、<code class="fe nh ni nj mp b"> THREE.OneMinusSrcAlphaFactor</code>、<code class="fe nh ni nj mp b">THREE.DstAlphaFactor</code>、<code class="fe nh ni nj mp b"> THREE.OneMinusDstAlphaFactor</code>、<code class="fe nh ni nj mp b">THREE.DstColorFactor</code>、<code class="fe nh ni nj mp b"> THREE.OneMinusDstColorFactor</code>中选择<code class="fe nh ni nj mp b">THREE.ZeroFactor</code>。</li></ul><p id="9bcb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">复杂的描述由下面的<code class="fe nh ni nj mp b">meshBasicMaterial</code>元素完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3d1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能想知道如何做出这样的组合。</p><p id="364c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://threejs.org/examples/webgl_materials_blending_custom.html" rel="noopener ugc nofollow" target="_blank">本页面</a>帮助编写道具，其中列显示<code class="fe nh ni nj mp b">blendSrc</code>选项，行显示<code class="fe nh ni nj mp b">blendDst</code>选项，选择的<code class="fe nh ni nj mp b">blendEquation</code>在右侧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nw"><img src="../Images/f1aac0ac1f93554ca68d12b32ea2e825.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jvtpUMUdgId0ASqRz-7YvQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="50b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">执行<code class="fe nh ni nj mp b">npm start</code>，我们看到一架颜色更鲜艳的飞机。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/2c5862a46a49fb5fdb30188738a2e1ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*rpvVdzPX7XdWiNcy02b9gA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="f3fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有一个替代方法，从<code class="fe nh ni nj mp b">@react-three/drei</code>调用<code class="fe nh ni nj mp b">useTexture</code>(下面代码中的第6行)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b910" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过<code class="fe nh ni nj mp b">npm start</code>运行代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/39b1470c110d2a5eceb5c1f732238bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*n72al3D6JMC27znGouSCtQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="e928" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在颜色是不是太鲜艳了？</p><p id="3e02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也许吧。但是我们继续用这种颜色。</p><h1 id="1067" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">给平面的两面添加纹理</h1><p id="1a8e" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">让我们玩点自动旋转飞机的游戏。这可以通过将<code class="fe nh ni nj mp b">@react-three/drei</code>中的<code class="fe nh ni nj mp b">OrbitControls</code>添加到<code class="fe nh ni nj mp b">Canvas</code>元素中来实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="90f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">飞机以5的速度旋转(第5行)，这相当于以60fps(帧每秒)的速度每轨道旋转12秒。如果显示器刷新率更高，它实际上旋转得更快。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/65538dae874bdb0f20bde6af03108d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*MdTY3VBki-b6Ya7rhhkefg.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="b5bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Ops，飞机实际上有两面，纹理被添加到正面，而不是背面。</p><p id="1f54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果<code class="fe nh ni nj mp b">meshBasicMaterial</code>配置了双面，这个问题可以解决(下面代码的第11行)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1ffe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过<code class="fe nh ni nj mp b">npm start</code>运行代码，我们可以看到两边都添加了纹理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/c72f3610e3a8106be1ae7577a0e9954f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*ToxpMHzoKmqKCNifPRFhRQ.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><h1 id="6b6a" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">向立方体添加纹理</h1><p id="a8b8" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们已经看到了如何在平面上映射纹理。让我们试着给立方体添加纹理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9841" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第9行，使用了<code class="fe nh ni nj mp b">boxBufferGeometry</code>，带有3D坐标。</p><p id="ec3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">执行<code class="fe nh ni nj mp b">npm start</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/9867295dde2bbd80cc53c6b13ecac0b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*spBKggyTkLdsOe3C4RHxZA.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="0438" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它对每张脸都有相同的纹理。</p><p id="02dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个<code class="fe nh ni nj mp b">useText</code>钩子能够建立一个纹理数组。我们将六个图像文件放在public文件夹下，调用<code class="fe nh ni nj mp b">useText</code> hook上传六个图像。<code class="fe nh ni nj mp b">Shape</code>组件修改如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="cd08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第2–9行，六幅图像被加载到<code class="fe nh ni nj mp b">colorMap</code>，这是一个包含以下数据的<code class="fe nh ni nj mp b">Texture</code>对象的数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nx"><img src="../Images/b26246452e5611a7e0e43263cd34a174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LnsuUp0PVf2jA3jwMnRcBA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="c130" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第13–19行，在<code class="fe nh ni nj mp b">mesh</code>元素中创建了六个<code class="fe nh ni nj mp b">meshBasicMaterial</code>元素。</p><p id="f49b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第16行的道具配置每个图像如何映射到立方体的每个面。通过贴图，立方体的每个面都有独特的纹理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d923e271f6c0d6519bdc7e406ff0420d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*DYzr9j7QqFKe1vUCkMvJyw.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="fb60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从目前的角度，我们只能看到四张脸。</p><p id="c33f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将摄像机降低一点到位置，<code class="fe nh ni nj mp b">[0, -1, 1]</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/af6bafd07316c2e3a2481b943b784624.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*-VgFo2C0YG6EclXWk_YMnQ.gif"/></div></figure><p id="3f3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">仍有一张脸不可见。</p><p id="52aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有许多方法可以解决这个问题。我们将绘制两个以不同顺序映射图像的立方体(<code class="fe nh ni nj mp b">ascending</code>和<code class="fe nh ni nj mp b">descending</code>)？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0276" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第5–26行，<code class="fe nh ni nj mp b">Shape</code>组件有两个道具:</p><ul class=""><li id="3c38" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated"><code class="fe nh ni nj mp b">position</code>:指定立方体位置(第15行)。</li><li id="804d" class="my mz it kw b kx nk la nl ld nm lh nn ll no lp nd ne nf ng bi translated"><code class="fe nh ni nj mp b">ascending</code>:指定纹理是否按升序映射(第20行)。</li></ul><p id="5780" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们可以看到六幅图像的纹理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/050c7bdaa9b7a788638fed847ca689ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*04OJVEeGqocEzzm0ll9dbw.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="e6d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有意思？</p><p id="07c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了这些参数，我们可以再添加两个立方体(下面代码中的第36行和第38行)来绘制标题图像，四个带有纹理图像的旋转立方体。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="e7f4" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="b84e" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们已经在平面或立方体的表面上实验了纹理。纹理图像被映射到表面上。</p><p id="99da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下一篇文章中，我们将探索更多的JavaScript代码技术来操作Three.js中的纹理。</p><p id="b012" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读。我希望这有所帮助。如果你有兴趣，可以看看<a class="ae lq" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener">我的其他媒体文章</a>。</p></div></div>    
</body>
</html>