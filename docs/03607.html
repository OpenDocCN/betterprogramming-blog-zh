<html>
<head>
<title>JavaScript Best Practices — Things to Avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践——要避免的事情</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-best-practice-things-to-avoid-be8e8fa30cca?source=collection_archive---------1-----------------------#2020-02-21">https://betterprogramming.pub/javascript-best-practice-things-to-avoid-be8e8fa30cca?source=collection_archive---------1-----------------------#2020-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8577" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们看到了各种我们应该避免的旧结构</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d607445aab62f4cb1f3c124674babcfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*URffWRjorq2E2CKc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卢卡斯·法夫尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="05f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像任何其他编程语言一样，JavaScript有自己的最佳实践列表，使程序更容易阅读和维护。JavaScript有很多棘手的部分，所以有很多东西要避免。</p><p id="0146" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以很容易地遵循一些最佳实践，使我们的JavaScript代码易于阅读。</p><p id="3a98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们着眼于要避免的事情，包括尽可能声明全局变量、将字符串传递给<code class="fe lv lw lx ly b">setInterval</code>和<code class="fe lv lw lx ly b">setTimeout</code>、<code class="fe lv lw lx ly b">with</code>语句等等。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8d6d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">避免声明全局变量</h1><p id="e88b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">出于各种原因，我们应该尽可能避免使用全局变量。</p><p id="ce5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个是它们很容易在不同的地方被覆盖，因为它们在任何地方都是可用的。它们也可以覆盖<code class="fe lv lw lx ly b">window</code>对象中的东西，因为全局变量是<code class="fe lv lw lx ly b">window</code>对象的属性。</p><p id="5c91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个是使我们的代码难以遵循的真实问题。因此，我们应该尽可能多地定义局部变量。</p><p id="bcfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用<code class="fe lv lw lx ly b">var</code>、<code class="fe lv lw lx ly b">let</code>或<code class="fe lv lw lx ly b">const</code>关键字来定义局部变量。</p><p id="b17e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe lv lw lx ly b">var</code>定义的变量在定义时可用，在定义前可用。例如，如果我们写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="dda9" class="nh mh it ly b gy ni nj l nk nl">const log = () =&gt; {<br/>  console.log(x);<br/>}<br/>log();<br/>var x = 1;<br/>log();</span></pre><p id="8e16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到第一个<code class="fe lv lw lx ly b">console.log</code>的<code class="fe lv lw lx ly b">undefined</code>和第二个日志的一个。</p><p id="83f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这和写作是一样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe lv lw lx ly b">let</code>声明的变量只有在定义后才可用，所以如果我们给:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6d1a" class="nh mh it ly b gy ni nj l nk nl">const log = () =&gt; {<br/>  console.log(x);<br/>}<br/>log();<br/>let x = 1;<br/>log();</span></pre><p id="4a6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到错误:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="bac1" class="nh mh it ly b gy ni nj l nk nl">Uncaught ReferenceError: Cannot access ‘x’ before initialization</span></pre><p id="a912" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">const</code>关键字，我们定义了只能赋值一次且不能再赋值的常量。它也只有在被声明为不像<code class="fe lv lw lx ly b">var</code>之后才可用。</p><p id="5971" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8197" class="nh mh it ly b gy ni nj l nk nl">const log = () =&gt; {<br/>  console.log(x);<br/>}</span><span id="521f" class="nh mh it ly b gy no nj l nk nl">const x = 1;<br/>log();</span></pre><p id="d2f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">const x = 1</code>之前调用<code class="fe lv lw lx ly b">log</code>也会得到<code class="fe lv lw lx ly b">Uncaught ReferenceError: Cannot access ‘x’ before initialization</code>。</p><p id="dcc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们希望变量在程序的不同部分都可用，我们应该使用JavaScript模块，然后在发布代码时将模块构建到一个或几个大文件中。这从ES6开始就有了。</p><p id="c3b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以<code class="fe lv lw lx ly b">export</code>我们的变量并将它们<code class="fe lv lw lx ly b">import</code>到其他模块中。还有<code class="fe lv lw lx ly b">export default</code>可以导出整个模块。这样，我们只导出应该在模块外部可用的东西，其他的都是私有的。</p><p id="a55e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用闭包将变量保存在函数内部，这样就不能在外部访问它们。简单闭包的一个例子是:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="63ef" class="nh mh it ly b gy ni nj l nk nl">const divide = () =&gt; {<br/>  const x = 3;<br/>  return () =&gt; x * 2;<br/>}</span></pre><p id="d46c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将<code class="fe lv lw lx ly b">x</code>放在<code class="fe lv lw lx ly b">divide</code>函数中，这样它就不能被外部访问，并返回一个函数来处理它。</p><p id="7951" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们把它写成:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c89c" class="nh mh it ly b gy ni nj l nk nl">console.log(divide()());</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/df86d84499e4e0fdf91a8d23c4d1bf4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SAFNVI7sYUItR9iE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@mattrobinjones?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马特·琼斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9f6a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">不要将字符串传递给setInterval或setTimeout</h1><p id="2912" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们不应该将字符串传递给<code class="fe lv lw lx ly b">setInterval</code>或<code class="fe lv lw lx ly b">setTimeout</code>函数的第一个参数，而不是一个回调函数。</p><p id="7aa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们向它传递一个字符串，而不是一个回调函数，浏览器将使用<code class="fe lv lw lx ly b">eval</code>来运行字符串中的代码，这很慢，并且容易受到代码注入攻击。</p><p id="b740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，没有理由，除非我们真的需要运行动态生成的代码，这应该是非常非常罕见的。</p><p id="a136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而不是写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e457" class="nh mh it ly b gy ni nj l nk nl">setTimeout(<br/>  "document.getElementById('foo').textContent = 'foo'", 1000<br/>);</span></pre><p id="d6eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d832" class="nh mh it ly b gy ni nj l nk nl">setTimeout(() =&gt; {<br/>  document.getElementById('foo').textContent = 'foo';<br/>}, 1000);</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1868" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">不要使用“with”语句</h1><p id="f9e0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">表面上看，<code class="fe lv lw lx ly b">with</code>语句似乎是访问对象深层嵌套属性的捷径。例如，我们可以写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c73e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而不是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="62a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，它污染了全局范围，并产生了在<code class="fe lv lw lx ly b">with</code>语句之外是否可以访问<code class="fe lv lw lx ly b">baz</code>的模糊性。这是因为我们也可以在<code class="fe lv lw lx ly b">with</code>语句中声明新的变量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ba3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在<code class="fe lv lw lx ly b">with</code>内部声明了<code class="fe lv lw lx ly b">baz</code>，但是在外部是不可访问的。</p><p id="ca7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，它不允许在JavaScript严格模式下使用，所以我们现在不必担心使用<code class="fe lv lw lx ly b">with</code>语句。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="334d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">var关键字</h1><p id="522b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对于ES6，我们有块范围的<code class="fe lv lw lx ly b">let</code>和<code class="fe lv lw lx ly b">const</code>关键字分别用于声明变量和常量。我们可以用它们来声明变量，因为它们有明确的作用域。</p><p id="453a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe lv lw lx ly b">var</code>声明的变量有一个混乱的范围。当它在像<code class="fe lv lw lx ly b">if</code>块或循环这样的块中声明时，它在块外是可用的。</p><p id="dd21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="675a" class="nh mh it ly b gy ni nj l nk nl">for (let i = 0; i &lt; 10; i++){<br/>  var j = i;<br/>}<br/>console.log(j);</span></pre><p id="b516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe lv lw lx ly b">var</code>一起工作，但是如果我们用<code class="fe lv lw lx ly b">let</code>代替<code class="fe lv lw lx ly b">var</code>，我们会得到一个错误。</p><p id="ff00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为范围混乱，我们应该停止使用<code class="fe lv lw lx ly b">var</code>来声明变量。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="007a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="ab17" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当我们编写JavaScript时，我们希望避免早期版本的JavaScript中存在的许多旧结构。它们使我们的代码难以阅读，很容易产生错误。</p><p id="4fe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们希望避免全局变量声明，以避免在全局范围内意外引用和声明。它还减少了意外修改全局变量的值的机会。</p><p id="b2d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也应该停止在字符串中传递代码，而不是在<code class="fe lv lw lx ly b">setTimeout</code>和<code class="fe lv lw lx ly b">setInterval</code>函数的第一个参数中传递回调函数。这是因为<code class="fe lv lw lx ly b">eval</code>将用于运行存储在字符串中的代码，这将我们的代码暴露于代码注入攻击，并且它也很慢。</p><p id="6260" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们应该避免使用<code class="fe lv lw lx ly b">with</code>语句，因为它会在全局范围内创建变量。</p><p id="e824" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，由于用<code class="fe lv lw lx ly b">var</code>关键字声明的变量的范围令人困惑，我们应该避免用<code class="fe lv lw lx ly b">var</code>关键字声明变量。</p></div></div>    
</body>
</html>