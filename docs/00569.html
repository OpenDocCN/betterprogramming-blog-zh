<html>
<head>
<title>Practical Kubernetes: Deploying a Back End Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用Kubernetes:部署后端服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/practical-kubernetes-deploying-a-backend-service-dadc773975c?source=collection_archive---------2-----------------------#2019-06-11">https://betterprogramming.pub/practical-kubernetes-deploying-a-backend-service-dadc773975c?source=collection_archive---------2-----------------------#2019-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="136a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实用Kubernetes系列的第二部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/36c81613ece010ce08245de61a6bf604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UFUdg5qwOxMjilkj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@ihor_dvoretskyi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ihor Dvoretskyi </a>拍摄</p></figure><p id="c318" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们实用的<a class="ae ky" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>系列(<a class="ae ky" href="https://medium.com/tsftech/kubernetes-stories-starting-with-k8s-on-aws-2c9a409bd69e" rel="noopener">在这里阅读</a>)的第一部分中，我们介绍了Kubernetes及其试图解决的问题。</p><p id="a476" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还描述了一个“基础设施即代码”的设置，以在<a class="ae ky" href="https://aws.amazon.com/eks/" rel="noopener ugc nofollow" target="_blank"> AWS EKS </a>(亚马逊的托管Kubernetes服务)上使用<a class="ae ky" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>来提供一个工作集群。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a92d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">先决条件</strong></h1><ul class=""><li id="c92c" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated">运行K8s集群，kubectl配置为与它通信(详见我们之前的<a class="ae ky" href="https://medium.com/tsftech/kubernetes-stories-starting-with-k8s-on-aws-2c9a409bd69e" rel="noopener">帖子</a>)</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="260a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">演示应用程序</h1><p id="97e7" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">为了演示部署和访问Kubernetes上运行的服务，我们将使用一个现成的Docker映像，其中内置了一个用户管理服务。</p><p id="226d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户管理是一个简单的用户管理服务，构建在MERN堆栈之上，服务器公开REST API和<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>前端。</p><p id="1713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用的图片已经发布到了Docker Hub上，但是如果你想研究代码，可以在这里找到:</p><div class="ni nj gp gr nk nl"><a href="https://github.com/aleksav/user-admin" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">aleksav/用户管理</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">使用MERN堆栈的简单用户Amin客户端-服务器应用程序</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz ks nl"/></div></div></a></div><p id="b793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户管理服务在运行时依赖于一个<a class="ae ky" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> Mongo </a>数据库。作为练习的一部分，我们还将在Kubernetes上部署和运行MongoDB集群。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bea3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将服务部署到K8s</h1><p id="23ce" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">让我们首先创建一个<strong class="lb iu">名称空间</strong>资源。</p><p id="2ffb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Kubernetes中，名称空间用于分隔Kubernetes中的虚拟集群。默认情况下，它们不提供完全隔离，但是当您想要隔离不同的环境或者在同一个物理集群中运行工作负载的团队时，它们是基本的</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="48a5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">部署清单和运行Pod</h1><p id="8940" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">好了，我们有了后端应用程序的Docker映像，REST API在<a class="ae ky" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>和<a class="ae ky" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>中实现。首先，我们需要用Kubernetes语言描述应用程序——这意味着用<a class="ae ky" href="https://yaml.org/" rel="noopener ugc nofollow" target="_blank"> YAML </a>将部署清单放在一起。</p><p id="1c78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">K8s部署是单个可部署单元的描述符——它包含关于部署的细节，例如应用程序的映像、实例数量、环境变量、卷等。</p><p id="6288" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当Pod状态改变时，Kubernetes将咨询部署，以决定部署到其上的应用程序的期望状态，以及是否需要计划新的状态(例如，计划创建另一个Pod，以防Pod崩溃将实例数量降低到部署中定义的数量之下)。</p><p id="0027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我们的用户管理服务的部署清单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="24c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是清单文件中的一些要点:</p><ul class=""><li id="615b" class="mu mv it lb b lc ld lf lg li oc lm od lq oe lu nb nc nd ne bi translated">部署的目标是我们之前创建的<code class="fe of og oh oi b">user-admin namespace</code>(第4行)。</li><li id="e2cf" class="mu mv it lb b lc oj lf ok li ol lm om lq on lu nb nc nd ne bi translated">我们将<code class="fe of og oh oi b">replicas</code>的数量设置为1(第7行)，因此Kubernetes将只为这个部署安排一个Pod。</li><li id="f4a1" class="mu mv it lb b lc oj lf ok li ol lm om lq on lu nb nc nd ne bi translated">接下来，我们指定创建的pod将拥有的<code class="fe of og oh oi b">labels</code>(第8–11行)。标签是在Kubernetes中标记对象的简单而强大的方法。在这里，我们说该清单的所有pod都标记有<code class="fe of og oh oi b">app:user-admin-backend</code>标签。当我们在本文后面讨论服务时，我们会看到这有多有用。</li><li id="fefa" class="mu mv it lb b lc oj lf ok li ol lm om lq on lu nb nc nd ne bi translated">我们指定了<code class="fe of og oh oi b">image</code>的名字。该图像将从公共Docker Hub中提取，在运行该示例之前，我们将它上传到这里(第15行)。</li><li id="b5fe" class="mu mv it lb b lc oj lf ok li ol lm om lq on lu nb nc nd ne bi translated">我们将<code class="fe of og oh oi b">image pull policy</code>设置为<code class="fe of og oh oi b">Always</code>，以便K8s在每次启动Pod时尝试下载图像(第16行)。如果在部署期间，您使用相同的版本对映像进行多次推送，这将非常有用。如果图像拉策略没有设置为<code class="fe of og oh oi b">Always</code>，图像将被缓存，Kubernetes不会尝试下载它，除非版本改变。</li><li id="2251" class="mu mv it lb b lc oj lf ok li ol lm om lq on lu nb nc nd ne bi translated">服务监听的<code class="fe of og oh oi b">port</code>是公开的(第18行)。</li><li id="2121" class="mu mv it lb b lc oj lf ok li ol lm om lq on lu nb nc nd ne bi translated">最后，我们设置配置服务所需的环境变量(第19–25行)。我们现在不必关注这些，我们稍后将回到这些。但是请注意，我们现在在容器中运行嵌入式MongoDB(这种方法有问题吗？)，并且我们有一些秘密密钥直接暴露在清单文件中(这是好的做法吗？)</li></ul><p id="cfa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们将清单保存在一个文件中，我们就可以通过应用它来告诉Kubernetes:</p><pre class="kj kk kl km gt oo oi op oq aw or bi"><span id="c852" class="os md it oi b gy ot ou l ov ow">kubectl apply -f user-admin-backend-service.yml</span></pre><p id="a2be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以在命名空间中列出Pod，并查看Pod的运行情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/40531578536f7838c308f2a696faf19f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E3nZ-vvNSPvGNAgthf-TyA.png"/></div></div></figure><p id="9b07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pod是该服务的一个实例——它不是短暂的，可能会在任何时候崩溃、停止或重启，而不会提前通知。这就是为什么Pod的名称在部署名称后有一个随机的后缀——如果您重新部署服务，您会注意到这个后缀会发生变化。</p><p id="6132" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，因为我们在部署清单中指定了一个名称空间，所以我们总是必须引用该名称空间来获取关于Pod的信息(否则您将得不到任何数据——试试看！).</p><p id="6e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的Pod处于运行模式，这意味着K8s成功下载了映像并启动了容器。</p><p id="a1d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果出现问题(找不到图像，或者容器注册需要认证，或者容器由于代码中的错误而无法启动)，您将会看到显示的不同状态。</p><p id="2c23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，Kubernetes将继续重新启动Pod，以防它在启动时崩溃(以匹配清单中配置的所需副本数量)。</p><p id="2115" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在运行状态下，您可以检查Pod的日志以确保它按预期启动:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/f77dbd940afa656cc9166a1365ec9259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sK4ryb33WGZMccIBegNHCQ.png"/></div></div></figure><p id="28d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要查看Pod的完整状态历史，您可以运行kubectl <code class="fe of og oh oi b">describe pod</code>命令，这在排除Pod未按预期启动的故障时非常有用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4541" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">放大和缩小</h1><p id="b3f1" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">要扩展Pod，您可以简单地更新清单中副本的数量并重新应用更改，或者运行<code class="fe of og oh oi b">scale</code>命令:</p><pre class="kj kk kl km gt oo oi op oq aw or bi"><span id="592f" class="os md it oi b gy ot ou l ov ow">kubectl -n user-admin scale deployment user-admin-backend \<br/>--replicas 3</span></pre><p id="eab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您再次列出pod，您会看到现在有三个，每个都运行相同的服务映像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/36816d0204848bdd8963a28bea951477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dggMB2ODMwtKYtI8ZRQPLw.png"/></div></div></figure><p id="daf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以根据需要尝试扩大和缩小服务。请注意，作为单独实例的每个Pod都有不同的名称(不同的随机后缀)。</p><p id="33f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">扩展到零个副本有效地移除了服务:</p><pre class="kj kk kl km gt oo oi op oq aw or bi"><span id="eaa5" class="os md it oi b gy ot ou l ov ow">kubectl -n user-admin scale deployment user-admin-backend \<br/>--replicas 0</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1533" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">处理敏感配置</h1><p id="495d" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我们之前制作的部署清单充分描述了我们的服务——我们可以在任何集群上运行它，以完全相同的方式部署完全相同的容器。</p><p id="2eaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预计我们会将清单推送到我们的代码库(<a class="ae ky" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>或类似的)，在那里我们可以跟踪代码的更改，在更广泛的开发/开发运维/SRE团队和个人之间共享代码和配置，或者在CI/CD管道中使用它。</p><p id="ed07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样的一系列清单充分描述了我们应用程序的理想状态。我们希望部署什么以及如何拥有一个工作系统的单一事实来源，当编写脚本时，意味着我们可以快速启动我们的环境，运行所有需要的服务。</p><p id="85e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您已经注意到我们的服务需要三个环境变量作为配置:</p><ol class=""><li id="8ca2" class="mu mv it lb b lc ld lf lg li oc lm od lq oe lu pa nc nd ne bi translated">Mongo网址，</li><li id="b711" class="mu mv it lb b lc oj lf ok li ol lm om lq on lu pa nc nd ne bi translated">主密钥(用于以管理员身份调用REST API)。</li><li id="8cfa" class="mu mv it lb b lc oj lf ok li ol lm om lq on lu pa nc nd ne bi translated"><a class="ae ky" href="https://jwt.io/introduction/" rel="noopener ugc nofollow" target="_blank"> JWT </a>秘密(用于签署JWT令牌，这些令牌用于REST API端点的认证和授权)。</li></ol><p id="657d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些配置中的每一个都是非常敏感的信息，并且以不同于代码其余部分的方式进行管理。这不是我们通常会推到共享代码库中的东西。但是在这里，它们是明文的(sight ),任何有权访问代码的人都可以看到。我们如何能以更好的方式处理这个问题？</p><p id="7a40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是Kubernetes <a class="ae ky" href="https://kubernetes.io/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank">秘密</a>出现的地方。机密是由Kubernetes管理的对象，用于存储敏感数据(如密码)，在集群中用于服务配置。</p><p id="5ea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以使用秘密清单文件(然后与其余的服务清单分开管理)来创建秘密，或者通过kubectl <code class="fe of og oh oi b">create secret</code>命令来创建秘密，该命令可以根据组织的策略编写脚本。</p><p id="23ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以创建主密钥的秘密为例:</p><pre class="kj kk kl km gt oo oi op oq aw or bi"><span id="e4c0" class="os md it oi b gy ot ou l ov ow">kubectl create secret -n user-admin generic master \<br/>--from-literal=key=”m4st3r”</span></pre><p id="72f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令将创建一个名为<code class="fe of og oh oi b">master</code>的通用密码。它有一个属性键，设置为我们的主键<code class="fe of og oh oi b">m4st3r</code>的值。</p><p id="e32d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们在运行Pod的同一个名称空间user admin中创建密码，否则Pod将无法访问它。</p><p id="00ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以在部署清单中引用这个秘密(第23–26行):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="b461" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们重新应用了部署清单，它应该会正常启动(注意，如果我们之前没有创建这个秘密，那么Pod会显示一个错误，说明这个秘密不存在)。</p><p id="e133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在应用更新的清单后列出了pod，您应该会看到K8s终止旧的pod并启动新的pod。请记住，我们说过pod是可消耗的，将根据需要停止和重启，而不是就地更新。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/afe94f6bd3e7f3c9460f9da6d945ebc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ItUOvNLAg1PC3Jhn-aiisg.png"/></div></div></figure><p id="2bd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以更改其他环境变量来使用Secrets。</p><p id="5f74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将服务部署为K8s Pods，但是我们现在如何访问它呢？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3d27" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">向外界公开服务</h1><p id="10c5" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我们已经看到了如何通过指定部署清单在pod中部署容器。应用部署将告诉Kubernetes使用清单中描述的容器映像和配置来调度和启动Pod。</p><p id="2141" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还说过K8s Pods是不可变的——我们不能对正在运行的Pod进行更改，并且每次启动Pod时，它都会被赋予一个新的唯一名称和IP地址。</p><p id="ec3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是Kubernetes服务的用武之地。</p><p id="a945" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务充当一个或多个Pods的逻辑标识符，允许我们使用一致的IP地址或主机名为每个K8s服务进行寻址。</p><p id="34b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们可以添加和删除Pod，启动新的Pod或重启已经崩溃的Pod——服务保持不变，对于任何访问它的人来说，Pod后端的更改将被完全抽象出来。</p><p id="57af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了pod的可寻址性之外，服务还能让我们轻松实现负载平衡。如果服务引用多个单元，则单元的流量将由服务进行负载平衡(默认使用的负载平衡策略是循环法，但这可以配置)。</p><p id="8198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes中的服务只是另一种类型的对象，并在服务清单中定义——一个YAML文件，其结构类似于我们已经看到的部署清单。</p><p id="1101" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了定义服务，我们需要定义选择器，它定义了:</p><ul class=""><li id="ac86" class="mu mv it lb b lc ld lf lg li oc lm od lq oe lu nb nc nd ne bi translated">哪些pod被组合在一起以形成服务。</li><li id="787b" class="mu mv it lb b lc oj lf ok li ol lm om lq on lu nb nc nd ne bi translated">服务映射到的Pod端口(属于服务的所有Pod都需要公开指定的端口)。</li><li id="20a8" class="mu mv it lb b lc oj lf ok li ol lm om lq on lu nb nc nd ne bi translated">将向服务使用者公布的映射端口。</li></ul><p id="2a97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种不同类型的服务，这取决于它们是应该在集群外部公开访问，还是应该在内部公开访问。</p><p id="b05d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我们的用户管理微服务的服务清单示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="f01b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看我们在这里做了什么:</p><ul class=""><li id="2e3e" class="mu mv it lb b lc ld lf lg li oc lm od lq oe lu nb nc nd ne bi translated">这是一个K8s服务清单，在<code class="fe of og oh oi b">kind</code>字段(第2行)中指定。</li><li id="d2bf" class="mu mv it lb b lc oj lf ok li ol lm om lq on lu nb nc nd ne bi translated">我们将在放置部署和其他用户管理资源的同一个<code class="fe of og oh oi b">namespace</code>中创建服务(第4行)。与我们之前讨论的名称空间类似，服务需要与它选择的pod在同一个名称空间中——如果我们没有在这里指定名称空间，就不会选择pod，服务也不会起作用。</li><li id="a2a1" class="mu mv it lb b lc oj lf ok li ol lm om lq on lu nb nc nd ne bi translated">我们使用的服务<code class="fe of og oh oi b">type</code>是<code class="fe of og oh oi b">LoadBalancer</code> —这种服务类型为服务创建一个外部负载平衡器，可以从集群外部访问。我们还可以使用其他类型的服务，比如ClusterIP(只能从集群内部访问)或NodePort(可以在集群外部的工作节点上的特定端口上访问)。</li><li id="5b41" class="mu mv it lb b lc oj lf ok li ol lm om lq on lu nb nc nd ne bi translated">接下来，我们指定服务要公开的端口(第8–11行)。<code class="fe of og oh oi b">port</code>属性指定服务将公开的端口，而<code class="fe of og oh oi b">targetPort</code>指定将流量路由到的Pod端口。最佳实践是命名公开的端口，这样我们可以在其他地方通过名称引用它们。我们将在未来的Kubernetes商店中看到这样的例子，但是现在让我们把它作为可读性的最佳实践。)</li><li id="50d8" class="mu mv it lb b lc oj lf ok li ol lm om lq on lu nb nc nd ne bi translated">最后，但同样重要的是，我们指定了<code class="fe of og oh oi b">selector</code>(第13行)。这就是我们如何告诉服务它应该将哪些pod逻辑地分组在一起，并对运行在所选pod内的容器的流量进行负载平衡。如果您还记得，当我们制作部署清单时，我们用<code class="fe of og oh oi b">app:user-admin-backend</code>标签标记了用户管理面板。在这里，我们将相同的标记指定为选择器，这样所有用它标记的pod都被选择为所创建服务的后端</li></ul><p id="b09c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以通过应用以下清单来创建服务:</p><pre class="kj kk kl km gt oo oi op oq aw or bi"><span id="b41c" class="os md it oi b gy ot ou l ov ow">kubectl apply -f user-admin-backend-service.yml</span></pre><p id="acd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">支持这篇文章的代码已经创建了这个清单，所以您可以应用它，并看到服务被创建。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/c6a80b51cfedd75404aa9451858e464d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uApP9bFpKfHH1PPhknor_A.png"/></div></div></figure><p id="bbd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，我们第一次查询服务(<code class="fe of og oh oi b">kubectl -n user-admin get services</code>，我们将看到服务名称、类型和公开的端口。</p><p id="069c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">外部IP仍处于待定状态，这是因为在云提供商(本例中为AWS)上为外部负载平衡器提供公共IP需要时间。如果您几秒钟后尝试，您将看到带有标准AWS动态主机名的外部IP。</p><p id="4a2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">LoadBalancer</code>服务嵌入到云提供商的基础设施中，根据云提供商的规范提供负载平衡器。</p><p id="ca87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在AWS的情况下，每个<code class="fe of og oh oi b">LoadBalancer</code>服务将提供一个ELB(弹性负载平衡器Classic)，您可以在AWS控制台中看到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/a5790f2941a6f51f69281b359fed7b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vzLOrf7jVlzbM7_zsKMQsw.png"/></div></div></figure><p id="3ed5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，新生成的公共域名的DNS可能需要更长时间才能被发现。如果您看到“无法解析:未知主机错误”，请首先检查您键入的域名是否正确，如果正确，请等待几分钟，让DNS更改完全传播。</p><p id="679b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用kubectl命令来描述服务，以确认它已经发现了作为端点的所有三个pod(参见端点部分):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/84efa4d39a0d93f83d5760f4c111db29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wl6zlJRlzvIMlQHMzO_Ilw.png"/></div></div></figure><p id="1b77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们终于可以访问我们的服务了！为了进行演示，我们将使用Kubernetes提供的服务域名<code class="fe of og oh oi b">curl</code>，并调用<code class="fe of og oh oi b">GET /api/user</code>端点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/4226c63532ba446a0fc24b9c7f139b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1w0zh1vImhKOtpuXm5xsUQ.png"/></div></div></figure><p id="7215" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到了一个“401未授权”响应，但是查看标签，我们可以看到我们确实到达了Express端点(我们的示例服务使用了Express Node.js框架)。</p><p id="2fab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过传递我们用来配置Pod的主密钥来进行同样的尝试:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/093bd95e19c6ee9e0914ae5c9d900dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YoOGPk6HYAexqxiFKzgp7g.png"/></div></div></figure><p id="1587" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果！我们刚刚成功调用了部署在Kubernetes集群上的负载平衡用户管理微服务！</p><p id="da3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，每次我们销毁服务资源时，AWS ELB也会被销毁。每次创建服务时，都会用新的IP/域名提供一个新的AWS ELB。如果你已经注意到我们在一些curl例子和截图中使用了不同的域名，那是因为我们在这个过程中重新创建了服务。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6f99" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">删除资源</h1><p id="7fe7" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">打扫卫生是一个好习惯。当我们运行演示代码时，我们经常忘记在演示后销毁我们不需要的资源，导致不必要的精力和金钱花费在我们不需要的基础设施上。</p><p id="36d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要删除我们在本文中创建的K8s资源，只需运行:</p><pre class="kj kk kl km gt oo oi op oq aw or bi"><span id="297f" class="os md it oi b gy ot ou l ov ow">kubectl delete -f user-admin-backend-service.yml</span><span id="8f9f" class="os md it oi b gy ph ou l ov ow">kubectl delete -f user-admin-backend-deployment.yml</span><span id="5f48" class="os md it oi b gy ph ou l ov ow">kubectl delete namespace user-admin</span></pre><p id="f97b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，我们可以通过再次应用清单来立即重新创建它—这是关于开发运维以及基础架构即代码的一个伟大之处，使用Kubernetes，我们可以立即启动并运行，而不管我们的基础架构的当前状态如何。</p><p id="e3ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想起我们以前的帖子，在那里我们提供了K8s集群，我们甚至可以破坏我们正在使用的整个环境，并用<a class="ae ky" href="https://www.terraform.io/intro/index.html" rel="noopener ugc nofollow" target="_blank"> Terraform </a>脚本让它复活。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cc5e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="e3cf" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在这篇文章中，我们使用了现有的Docker映像，公开了一个我们不太了解的REST API，并将其部署在K8s集群上。</p><p id="8d3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑一下我们如何使用一些特定于云的资源(AWS ELB)，而无需了解我们所处的云环境——我们所需要的只是kubectl与Kubernetes集群进行对话，后者反过来为我们编排容器，包括抽象基础架构层。</p><p id="0ae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将我们刚刚制作的清单带到另一个K8s集群，也许是在<a class="ae ky" href="https://azure.microsoft.com/" rel="noopener ugc nofollow" target="_blank"> Azure </a>、<a class="ae ky" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> GCP </a>或一个私有数据中心，使用相同的工具和命令，立即在那里部署服务。</p><p id="74d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们保持事情非常简单。例如，我们在部署的每个容器中都使用了嵌入式MongoDB。这意味着每个Pod都有自己的数据库，所以如果我们要在数据库中创建一个用户记录，并查询它，我们可能得不到它(因为我们可能会从一个不同的Pod得到一个响应，它对保存在其他Pod上的数据一无所知)。</p><p id="411e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了克服这个问题，我们需要为REST API单独部署一个数据库。</p><p id="fc1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将给我们带来其他挑战。我们说过Pod是可消耗的—它们可以在群集中的任何节点上停止和重启，并且它们没有静态IP和存储。如果我们运行一个数据库，我们实际上需要的所有东西。</p><p id="d141" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是不要担心——我们将在下一篇文章中了解这一点，很快就会发布</p></div></div>    
</body>
</html>