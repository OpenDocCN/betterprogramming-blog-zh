<html>
<head>
<title>Finishing a Ruby Method After Interrupt, Before Exiting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中断后退出前完成Ruby方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ruby-tip-how-to-finish-a-method-after-an-interrupt-before-exiting-c29950c129f4?source=collection_archive---------9-----------------------#2022-04-07">https://betterprogramming.pub/ruby-tip-how-to-finish-a-method-after-an-interrupt-before-exiting-c29950c129f4?source=collection_archive---------9-----------------------#2022-04-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4e58b0351f66e791e1f44760b4b7da5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mlFUUkTW8v99ArGs"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">托马斯·博尔曼斯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="905d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">恭喜你！你被一家前途光明的初创公司<strong class="kf ir"> <em class="lb">录用了，这是一家炙手可热的公司</em> </strong>。你的任务是找到最好的新推文，给作者送去煎饼。不要担心收入:我们稍后会解决这个问题。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lc"><img src="../Images/7ada6a59e713ee19780037faa60c82cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EpCNEScpay2JrTUKtLJeww.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">你创业的防弹商业模式。<a class="ae kc" href="https://www.pexels.com/photo/pancake-with-sliced-strawberry-376464/" rel="noopener ugc nofollow" target="_blank">来自Pexels的Ash拍摄的煎饼照片</a></p></figure><p id="05e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你的生意取决于你的蛋糕是新鲜出炉的。没人喜欢冷煎饼。冷煎饼是你被雇来解决的关键问题。请允许我解释。</p><p id="a122" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">热门蛋糕雇佣寻找推特的英语专业学生，他们将推特提交给网络应用程序。然而，辛勤工作的煎饼厨师网络依赖于一个古老的工作站程序，名为<em class="lb">阿宝的煎饼党</em> (PPP)。Po的软件通过本地网络API接受新订单，然后通过telnet和信鸽的混合方式将订单分发给你的厨师。</p><p id="cbe7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不知何故，你不得不从互联网到PPP获得订单，但你可以肯定，通过你的防火墙将公共互联网流量转发给一个15年前的专有软件不会带来任何好处。所以你想出了一个不同的方法。</p><h1 id="94da" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">该计划</h1><p id="271a" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">因为你不想把PPP暴露在互联网上，所以你需要一个中介在网上查询一些新订单，然后插入PPP。您可以查询web应用程序，但是您必须弄清楚您的web应用程序将如何跟踪哪些订单被输入PPP。</p><p id="683a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，你设置网络应用程序来使用在线排队服务，比如亚马逊SQS。您将通过运行在PPP工作站上的一个连续循环的Ruby脚本来查询队列。该脚本执行以下操作。</p><ol class=""><li id="c3af" class="mk ml iq kf b kg kh kk kl ko mm ks mn kw mo la mp mq mr ms bi translated"><strong class="kf ir">获取请求:</strong>查询在线队列中的新订单请求。当队列服务响应时，它还会对其他查询隐藏一分钟的请求(例如，对脚本的其他副本)。SQS称之为<em class="lb">可见性超时。</em></li><li id="cd3a" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated"><strong class="kf ir">创建订单:</strong>收到消息后，通过PPP的本地网络API创建订单</li><li id="f3b6" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated"><strong class="kf ir">确认请求:</strong>将队列中的请求标记为已处理，这样当可见性超时过期时，它将不会被重新处理。</li></ol><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/26f2676214de6c2e5426c27466640f42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aqrDjFzDBUPHvrW-yBBGqw.png"/></div></div></figure><p id="57da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总的来说，这种实现可能类似于以下内容:</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><pre class="ld le lf lg gt nb nc nd ne aw nf bi"><span id="3db8" class="ng li iq nc b gy nh ni l nj nk">❯ ruby naive.rb      <br/>[INFO 2022-04-04 20:53:02 -0400] #--- Starting Worker Program ---#<br/>[INFO 2022-04-04 20:53:02 -0400] Start operation, iteration 0. Part one: Eg. we might long poll for messages here<br/>[INFO 2022-04-04 20:53:07 -0400] Operation part two. Eg. we might process messages here.<br/>[INFO 2022-04-04 20:53:08 -0400] Operation part three. Eg. we might acknowledge the message as processed here.<br/>[INFO 2022-04-04 20:53:09 -0400] Operation, iteration 0, complete.<br/>[INFO 2022-04-04 20:53:09 -0400] Start operation, iteration 1. Part one: Eg. we might long poll for messages here<br/>...</span></pre><p id="8fe1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单。</p><h1 id="dd6f" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">秘诀——我们的动力</h1><p id="301b" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">等等。如果第2步“创建订单”成功，但脚本在第3步“确认”之前崩溃或退出，该怎么办？我们已经创建了订单，但是将请求留在了请求队列中。</p><p id="d784" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们开始备份脚本时，我们会重新处理消息。我们至少会创建两个订单。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/f3b69270ab87c4ed7ea48880e05904c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rOAn02ecbMXqBIDqnspZBQ.png"/></div></div></figure><p id="09cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，如果我们改变行动的顺序呢？我们可以在收到消息后立即将其标记为已处理，然后<em class="lb">在PPP中创建一个订单。</em></p><p id="00f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果崩溃发生在我们确认请求之后，但在我们创建订单之前，将不会创建任何订单。有人吃不到煎饼了！</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/6d2ed03be99218b0840108ed1d663c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6jwSz1MH3f0MqnX7GWyxwA.png"/></div></div></figure><p id="8516" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你决定送两份薄煎饼比不送要好，并坚持原来的操作顺序。但是每条推特上有多个煎饼订单并不理想。如果脚本a)在代码的这个“关键部分”崩溃或b)退出，就会出现这种重复的问题。</p><p id="54e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好消息是:这个问题涉及的所有参与者(Hot Cakes web app、SQS和阿宝的煎饼党)都是相当成熟的程序，不太可能有影响你的脚本的突破性变化或错误。只要你能让脚本在第一时间工作，它很可能会继续工作。脚本崩溃<strong class="kf ir"> </strong>不太可能。</p><p id="f357" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">脚本退出<strong class="kf ir"> </strong>的可能性很大。每当工作站重新启动或有人试图退出ruby脚本时，就会发生这种情况。然而，脚本出口也在您的控制之下！在退出之前，一个表现良好的操作系统会给你一个信息，给你一个清理的机会。所以，至少对于正常的退出，你<em class="lb">应该</em>能够在退出程序之前完成临界区的处理。</p><blockquote class="nl nm nn"><p id="1c7a" class="kd ke lb kf b kg kh ki kj kk kl km kn no kp kq kr np kt ku kv nq kx ky kz la ij bi translated">这里的“正常”退出意味着操作系统给程序一个优雅退出的机会。在UNIX bash中，这些情况是程序被发送<a class="ae kc" href="https://www.baeldung.com/linux/sigint-and-other-termination-signals" rel="noopener ugc nofollow" target="_blank"> SIGINT、SIGTERM或SIGQUIT </a>而不是SIGKILL或SIGSTOP。如果你是一个Windows用户，这就是当你关闭一个程序(优雅的退出)和当你得到程序不响应对话框并点击“现在结束”的区别。</p></blockquote><p id="97c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们中途退出程序，它看起来像这样:</p><pre class="ld le lf lg gt nb nc nd ne aw nf bi"><span id="f8d6" class="ng li iq nc b gy nh ni l nj nk">❯ ruby naive.rb      <br/>[INFO 2022-04-04 20:53:02 -0400] #--- Starting Worker Program ---#<br/>[INFO 2022-04-04 20:53:02 -0400] Start operation, iteration 0. Part one: Eg. we might long poll for messages here<br/>[INFO 2022-04-04 20:53:07 -0400] Operation part two. Eg. we might process messages here.<br/>[INFO 2022-04-04 20:53:08 -0400] Operation part three. Eg. we might acknowledge the message as processed here.<br/>[INFO 2022-04-04 20:53:09 -0400] Operation, iteration 0, complete.<br/><strong class="nc ir">[INFO 2022-04-04 20:53:09 -0400] Start operation, iteration 1. Part one: Eg. we might long poll for messages here<br/>^Cnaive.rb:5:in `sleep': Interrupt<br/>        from naive.rb:5:in `operation'<br/>        from naive.rb:29:in `&lt;main&gt;'</strong><br/>❯</span></pre><h1 id="d6d4" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">明显的、有缺陷的方法</h1><p id="1e54" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">当Ruby收到操作系统的退出系统时，它抛出一个<code class="fe nr ns nt nc b"><a class="ae kc" href="https://www.exceptionalcreatures.com/bestiary/SignalException.html" rel="noopener ugc nofollow" target="_blank">SignalException</a></code>。主线程跳转来处理该异常。您可以通过包装中断抛出时正在执行的块来<code class="fe nr ns nt nc b">rescue</code>它。</p><p id="ccc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管如此，您已经中断了方法的执行，执行转移到了您的rescue块。这不能解决我们的问题！</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><pre class="ld le lf lg gt nb nc nd ne aw nf bi"><span id="2e77" class="ng li iq nc b gy nh ni l nj nk">❯ ruby signal_trap.rb <br/>[INFO 2022-04-04 20:49:22 -0400] #--- Starting Worker Program ---#<br/>[INFO 2022-04-04 20:49:22 -0400] Start operation, iteration 0. Part one: Eg. we might long poll for messages here<br/>[INFO 2022-04-04 20:49:27 -0400] Operation part two. Eg. we might process messages here.<br/>[INFO 2022-04-04 20:49:28 -0400] Operation part three. Eg. we might acknowledge the message as processed here.<br/>[INFO 2022-04-04 20:49:29 -0400] Operation, iteration 0, complete.<br/>[INFO 2022-04-04 20:49:29 -0400] Start operation, iteration 1. Part one: Eg. we might long poll for messages here<br/><strong class="nc ir">^C[WARN 2022-04-04 20:49:33 -0400] #--- Received interrupt ---#</strong></span><span id="57ba" class="ng li iq nc b gy nu ni l nj nk">❯</span></pre><p id="cb95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个选择是添加一个<code class="fe nr ns nt nc b">at_exit</code>块。当程序响应中断而退出时，该块中的代码将执行。</p><p id="aa86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法稍微紧凑一些，但是有和信号陷阱一样的问题:中断程序仍然会中断我们代码的执行，并跳转到<code class="fe nr ns nt nc b">at_exit</code>块。这还是不能解决我们的问题！</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><pre class="ld le lf lg gt nb nc nd ne aw nf bi"><span id="66c0" class="ng li iq nc b gy nh ni l nj nk">❯ ruby at_exit.rb                                                                                                     <br/>[INFO 2022-04-04 21:00:40 -0400] #--- Starting Worker Program ---#<br/>[INFO 2022-04-04 21:00:40 -0400] Start operation, iteration 0. Part one: Eg. we might long poll for messages here<br/>[INFO 2022-04-04 21:00:45 -0400] Operation part two. Eg. we might process messages here.<br/>[INFO 2022-04-04 21:00:46 -0400] Operation part three. Eg. we might acknowledge the message as processed here.<br/>[INFO 2022-04-04 21:00:47 -0400] Operation, iteration 0, complete.<br/>[INFO 2022-04-04 21:00:47 -0400] Start operation, iteration 1. Part one: Eg. we might long poll for messages here<br/><strong class="nc ir">^C[WARN 2022-04-04 21:00:48 -0400] #--- Received interrupt ---#<br/>at_exit.rb:5:in `sleep': Interrupt<br/>        from at_exit.rb:5:in `operation'<br/>        from at_exit.rb:35:in `&lt;main&gt;'</strong></span><span id="31d6" class="ng li iq nc b gy nu ni l nj nk">❯</span></pre><h1 id="223a" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">解决方案</h1><p id="930e" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">这两种方法都不起作用，因为它们不能阻止主线程跳出执行来处理中断。相反，我们需要将方法的执行从主线程中分离出来，这样它仅仅是被中断所暂停。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/ff2e9cdb8b76988363c58dc10628e995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Ykxljz0EO28ZIwFIE6KvQ.png"/></div></div></figure><p id="78c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要做到这一点，我们可以使用第二个线程来运行我们的“不可中断”方法，避免中断处理。然后，我们可以通过等待不间断方法的完成，在<code class="fe nr ns nt nc b">at_exit</code>块中“清理”我们的程序。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><pre class="ld le lf lg gt nb nc nd ne aw nf bi"><span id="b69b" class="ng li iq nc b gy nh ni l nj nk">❯ ruby at_exit_uninterruptable.rb <br/>[INFO 2022-03-12 12:52:21 -0500] #--- Starting Worker Program ---#<br/>[INFO 2022-03-12 12:52:21 -0500] Start operation, iteration 0. Part one: Eg. we might long poll for messages here<br/>[INFO 2022-03-12 12:52:26 -0500] Operation part two. Eg. we might process messages here.<br/>[INFO 2022-03-12 12:52:27 -0500] Operation part three. Eg. we might acknowledge the message as processed here.<br/>[INFO 2022-03-12 12:52:28 -0500] Operation, iteration 0, complete.<br/><strong class="nc ir">[INFO 2022-03-12 12:52:28 -0500] Start operation, iteration 1. Part one: Eg. we might long poll for messages here<br/>^C[WARN 2022-03-12 12:52:30 -0500] #--- INTERRUPT RECEIVED ---#<br/>[WARN 2022-03-12 12:52:30 -0500] Waiting for current iteration to complete. Interrupt again for immediate (unsafe) termination.<br/>[INFO 2022-03-12 12:52:33 -0500] Operation part two. Eg. we might process messages here.<br/>[INFO 2022-03-12 12:52:34 -0500] Operation part three. Eg. we might acknowledge the message as processed here.<br/>[INFO 2022-03-12 12:52:35 -0500] Operation, iteration 1, complete.<br/>[INFO 2022-03-12 12:52:35 -0500] #--- ITERATION COMPLETED. EXITING SAFELY ---#<br/>delay_script_exit.rb:51:in `join': Interrupt<br/>        from delay_script_exit.rb:51:in `&lt;main&gt;'</strong></span><span id="8acc" class="ng li iq nc b gy nu ni l nj nk">❯</span></pre><p id="29da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有用！</p><p id="1458" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想在退出时得到更漂亮的输出，而不是stacktrace，你也可以通过一个<code class="fe nr ns nt nc b">SignalException</code>陷阱来暂停线程。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><pre class="ld le lf lg gt nb nc nd ne aw nf bi"><span id="a996" class="ng li iq nc b gy nh ni l nj nk">❯ ruby signal_trap_uninterruptable.rb<br/>[INFO 2022-04-04 21:12:23 -0400] #--- Starting Worker Program ---#<br/>[INFO 2022-04-04 21:12:23 -0400] Start operation, iteration 0. Part one: Eg. we might long poll for messages here<br/>[INFO 2022-04-04 21:12:28 -0400] Operation part two. Eg. we might process messages here.<br/>[INFO 2022-04-04 21:12:29 -0400] Operation part three. Eg. we might acknowledge the message as processed here.<br/>[INFO 2022-04-04 21:12:30 -0400] Operation, iteration 0, complete.<br/><strong class="nc ir">[INFO 2022-04-04 21:12:30 -0400] Start operation, iteration 1. Part one: Eg. we might long poll for messages here<br/>^C[WARN 2022-04-04 21:12:33 -0400] #--- INTERRUPT RECEIVED ---#<br/>[WARN 2022-04-04 21:12:33 -0400] Waiting for current iteration to complete. Interrupt again for immediate (unsafe) termination.<br/>[INFO 2022-04-04 21:12:35 -0400] Operation part two. Eg. we might process messages here.<br/>[INFO 2022-04-04 21:12:36 -0400] Operation part three. Eg. we might acknowledge the message as processed here.<br/>[INFO 2022-04-04 21:12:37 -0400] Operation, iteration 1, complete.<br/>[INFO 2022-04-04 21:12:37 -0400] #--- ITERATION COMPLETED. EXITING SAFELY ---#</strong></span><span id="77b3" class="ng li iq nc b gy nu ni l nj nk">❯</span></pre><p id="99e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！我们已经捕获了信号中断，并在退出之前等待不间断操作完成。编码快乐！</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="450f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想了解“不间断信号陷阱”解决方案的完整代码，这里有:</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure></div></div>    
</body>
</html>