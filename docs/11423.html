<html>
<head>
<title>Introduction to TCP Connection Establishment for Software Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向软件开发人员的TCP连接建立介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-tcp-connection-establishment-for-software-developers-233878c5143d?source=collection_archive---------1-----------------------#2022-03-18">https://betterprogramming.pub/introduction-to-tcp-connection-establishment-for-software-developers-233878c5143d?source=collection_archive---------1-----------------------#2022-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2df7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于TCP你绝对应该知道的事情</h2></div><p id="e47a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传输控制协议(TCP)提供可靠的、面向连接的字节流传输层服务。它的实现非常有趣。</p><p id="46c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将探索TCP连接建立是如何工作的，它如何通过维护连接状态来确保可靠性，以及它是否适合每一个用例。</p><p id="4fff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在进入握手的内部之前，我们先来看看TCP。</p><h1 id="8af3" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">了解TCP</h1><p id="eccb" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">TCP连接被定义为由两个IP地址和两个端口号组成的四元组。每个IP地址端口号对代表一个端点。</p><p id="8fc4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着，如果客户端的IP地址和/或端口号是唯一的，一台服务器可以连接到许多客户端。</p><h1 id="45bb" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">TCP适合哪里？</h1><p id="c8e9" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">传输控制协议(TCP)是我们可用的传输层协议之一，它被广泛使用是有原因的。</p><p id="e9d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了理解为什么需要它，让我们看一下TCP/IP模型中的协议栈:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/bcd69c484bb3fbb28894e661c4b7cc35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sE_i9LqC5WF0L5LpG_P-iQ.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">TCP/IP模型</p></figure><p id="0c07" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来自应用层(例如，您的浏览器)的HTTP请求会通过所有层在互联网上发送。互联网层处理发送小块数据，也称为IP数据报。数据报充当TCP数据段的信封，IP层的工作是通过互联网发送它们。</p><p id="6525" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为IP层不知道TCP连接，所以对应于同一连接的两个数据包经常通过不同的路由发送。这使得互联网上的数据传输不可靠，并引起各种问题，如重复分组、无序分组、分组丢失等。</p><p id="5a2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TCP提供对所有这些情况的处理，并在接收端提供有保证的、无丢失的、有序的数据包传送。</p><p id="a00f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="mo">注意:</em></strong><em class="mo">TCP的可靠性方面只适用于一个连接的两端。数据包在传输过程中不断被打乱、丢失、复制。</em></p><h1 id="cf43" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">TCP报头和IP数据报</h1><p id="d4ae" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">TCP数据段在报头中携带有关连接的所有元信息。基本TCP报头为20字节(无选项)；这意味着任何数据包的传输都需要20字节的数据开销。</p><p id="5902" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们了解一下TCP报头是由什么组成的:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mp"><img src="../Images/d1f04717f04a8380844b003346dfccce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AGfmAvBtsJvDHaGZCxJV9A.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">TCP报头</p></figure><p id="c9d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mo">确认号、窗口大小、ECE和ACK位携带相对于发送方以相反方向流动的数据。</em></p><p id="1988" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.源端口和目的端口。</p><p id="1d6a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.<code class="fe mq mr ms mt b">Sequence Number</code>:标识发送给接收TCP的数据段的第一个字节。</p><p id="8325" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.<code class="fe mq mr ms mt b">Acknowledgement Number</code>:包含确认发送方期望接收的下一个<code class="fe mq mr ms mt b">Sequence Number</code>；即，</p><p id="edbc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mq mr ms mt b">Acknowledgement Number = Sequence Number + 1</code></p><p id="85be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.窗口大小:这是接收TCP愿意接收的字节数。它是一个16位字段，将窗口大小限制为65，535字节。我们使用<code class="fe mq mr ms mt b">Window Scaling</code>来解决这个瓶颈。</p><p id="6ae9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5.TCP校验和:由发送TCP强制发送，并由接收端验证，以检测数据损坏。</p><p id="3f13" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">6.紧急指针(urgent Pointer):TCP中的这种机制用于向另一端发送一些特定的紧急数据。仅当设置了URG字段时，它才有效。</p><p id="8437" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">7.其他位字段:在连接建立过程中主要使用两个字段:</p><ul class=""><li id="5ec8" class="mu mv iq kh b ki kj kl km ko mw ks mx kw my la mz na nb nc bi translated">SYN:在连接建立阶段开始时，该位在第一个数据段中打开。</li><li id="361a" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated">ACK:当需要发出确认时使用。始终开启，除了第一个和最后一个(连接拆除)数据包。</li></ul><p id="b453" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有这些关于连接的信息都存储在TCP报头中。将此报头与应用程序数据相结合，我们就得到TCP数据段，如下所示:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ni"><img src="../Images/f36dd6680752832b209bf2c86aae47a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uWI0SPDcwK_A8P3kW_b26Q.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">TCP数据段由报头和应用数据组成</p></figure><p id="b190" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是到目前为止，我们只知道源端口和目的端口。我们还需要源IP地址和目的IP地址，以便唯一地标识TCP连接(还记得吗？).并且这发生在传输期间的下一层(即，IP层)。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nj"><img src="../Images/75192662472a52c618368923e4402555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gkpE5S42dQZmhXAlD4ds9A.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">TCP/IP数据报在TCP报头的顶部包含IP报头</p></figure><p id="ee86" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">IP层只是在收到的TCP数据段上添加自己的报头，使其成为IP数据报。这些报头在接收端以相反的顺序被逐渐剥离。</p><p id="3b13" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，TCP和IP层共同构成了一个唯一的TCP连接。我们得到了TCP/IP协议套件。</p><h1 id="57c2" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">让我们握手吧</h1><p id="f767" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated"><em class="mo">我推荐打开Chris Greer旁边的这个</em> <a class="ae nk" href="https://www.cloudshark.org/captures/98ad8cdd3082" rel="noopener ugc nofollow" target="_blank"> <em class="mo">包跟踪文件</em> </a> <em class="mo">。下面讨论的所有字段都可以在每个数据包的TCP层找到。只有前三个数据包对应于握手过程。</em></p><p id="a473" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">连接建立由一个想要连接到一个被动开启器(通常是一个服务器)的<a class="ae nk" href="https://stackoverflow.com/questions/29335144/what-are-the-difference-between-an-active-open-and-a-passive-open-in-a-tcp-socke" rel="noopener ugc nofollow" target="_blank">主动开启器</a>(通常是客户端)启动，在此过程中总共传输了三个TCP段。</p><p id="4d15" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本练习的目标是让连接的每一端都知道连接正在启动，共享一些重要的配置(也称为TCP选项)，并交换初始序列号(ISN)。</p><p id="e25d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">主动开启者在发起连接时决定ISN。ISN的不可预测性对于连接的安全性至关重要。一个局外人可以欺骗接收主机(或被动开启)，并假装是实际的发送者，如果他们可以预测的ISN。</p><p id="e491" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们更仔细地看一下每个步骤:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/35e3d0cccf381eb8a95ccc249fce1da3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*sKzss0sUSp_26nPRotDzDQ.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">TCP三次握手</p></figure><h2 id="9392" class="nm lc iq bd ld nn no dn lh np nq dp ll ko nr ns ln ks nt nu lp kw nv nw lr nx bi translated"><strong class="ak">【段1】:客户端发送一个SYN段</strong></h2><p id="592b" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">主动开启者(或客户端)发送的第一个TCP数据段包含以下内容:</p><p id="6774" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.存储在目标端口中的服务器端口</p><p id="4ca7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.TCP标志中设置的SYN位</p><p id="0e92" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.是存储在<code class="fe mq mr ms mt b">Sequence Number</code>中的客户端</p><p id="d375" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="mo">注</em> </strong> <em class="mo">:跟踪文件显示</em> <code class="fe mq mr ms mt b"><em class="mo">Sequence Number</em></code> <em class="mo">的相对值，使其可读，其真实值以十六进制显示在右边。</em></p><p id="9bd8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.存储在TCP选项中的一些配置选项(我们将在接下来处理它们)</p><h2 id="67da" class="nm lc iq bd ld nn no dn lh np nq dp ll ko nr ns ln ks nt nu lp kw nv nw lr nx bi translated">[段2]:服务器用SYN-ACK段进行响应</h2><p id="8c67" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">服务器发送自己的SYN数据段。它还会确认从客户端收到的数据段。它发送包含以下内容的数据段:</p><p id="88fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.SYN位开启</p><p id="6d06" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.<code class="fe mq mr ms mt b">Sequence Number = ISN(server)</code></p><p id="2b91" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.ACK位打开(以确认从对等方收到的数据段)</p><p id="3b93" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.<code class="fe mq mr ms mt b">Acknowledgement Number = ISN(client) + 1</code></p><h2 id="756e" class="nm lc iq bd ld nn no dn lh np nq dp ll ko nr ns ln ks nt nu lp kw nv nw lr nx bi translated">[段3]:客户端发送最后一个ACK段</h2><p id="bc49" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">最后，客户机用ACK确认从服务器收到的SYN。本质上:</p><p id="a7eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.它设置ACK位来确认服务器的SYN段</p><p id="259c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.<code class="fe mq mr ms mt b">Sequence Number = ISN(client) + 1</code></p><p id="5e7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.<code class="fe mq mr ms mt b">Acknowledgement Number = ISN(server) + 1</code></p><p id="ebf4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果SYN数据段丢失，它将被重新传输，直到收到它的ACK。</p><h1 id="3fa7" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">TCP选项</h1><p id="2e38" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">有一些附加的配置设置有助于TCP连接中的高效数据流。其中一些选项在连接建立过程中只能设置一次，而其他选项可以在连接生命周期中的任何时间点使用。</p><p id="63d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看一些最常用的TCP选项。</p><h2 id="af4a" class="nm lc iq bd ld nn no dn lh np nq dp ll ko nr ns ln ks nt nu lp kw nv nw lr nx bi translated">最大段大小(MSS)</h2><p id="4456" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">它是TCP愿意从其对等方接收的最大数据段，因此也是其对等方在发送时应该使用的最大数据段。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/d08e0e7e7aa35ffbd15bd1b053f0b2fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*U1tltx36o06EaUJhzSypyw.jpeg"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">最大段尺寸</p></figure><p id="6208" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里需要注意的重要一点是，MSS只计算应用程序数据，而不计算TCP和IP报头。另一方面，最大可传输单元(MTU)查看整个数据包，包括TCP和IP报头。</p><p id="6aa3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">MSS和MTU的大小是可配置的，但它必须低于承载这些数据包的以太网帧的最大容量。MTU大小可以设置为大于帧的容量，但这样数据包就需要经过分段才能传送。</p><h2 id="ab42" class="nm lc iq bd ld nn no dn lh np nq dp ll ko nr ns ln ks nt nu lp kw nv nw lr nx bi translated">窗口缩放</h2><p id="0fbc" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">窗口大小告诉连接中的对等方它已经为该特定连接分配或剩余了多少接收缓冲区。此选项在连接建立阶段设置，在连接生存期内不能更改。</p><p id="23d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TCP报头中的窗口大小为16位，这使得最大值仅为65536字节(2 ⁶)。在高延迟网络的情况下，64KB的窗口大小会使往返时间更长，往返时间(RTT)也更长。</p><p id="e82b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">窗口缩放TCP选项是一个14位字段，用于左移窗口大小值，使其显著变大，最大值可达1GB (65，535字节* 2 ⁴).这在处理高延迟、大带宽的情况时非常有用。</p><p id="4832" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们借助这里的图示来理解:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nz"><img src="../Images/fea93d17e94d9d8625a49a93e59d7a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y6i2K3WqHB9sTkd8gYsfMw.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">缩放前的原始窗口大小</p></figure><p id="cd88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，发送方在收到任何确认之前可以发送的最大数据包大小是64KB。我们可以观察到，发送方在发送了最大可能字节的数据后处于空闲状态，并且正在等待确认，以便可以发送更多的数据。</p><p id="be60" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们看看引入窗口缩放后的数据包传输:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi oa"><img src="../Images/c8be8fd8cc0da50624f1a806061bf03e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KyJI9CzCW_4m87ar0anVzQ.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">缩放后增加了窗口大小</p></figure><p id="438a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设置窗口缩放后，发送方能够发送两倍的数据量，并减少了发送端的空闲时间。因此，更好的利用。</p><p id="6408" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，使用更大的窗口缩放因子将进一步增加有效窗口大小。窗口越大，发送TCP在没有收到任何确认的情况下可以发送的数据就越多。</p><h2 id="548c" class="nm lc iq bd ld nn no dn lh np nq dp ll ko nr ns ln ks nt nu lp kw nv nw lr nx bi translated">选择性确认</h2><p id="750e" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">通过网络发送的数据包经常丢失，导致确认号突然跳跃，并使字节流不连续。这在接收的数据中产生了漏洞，发送TCP不知道哪些包需要重传。</p><p id="ef12" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于SACK在两端都得到支持(在连接建立期间协商)，接收方能够在间隙之后传送它接收到的数据包。两个字段有助于找出丢失的数据包:</p><p id="a306" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.<code class="fe mq mr ms mt b">Acknowledgement Number</code>设置为间隙前收到的最后一个数据包偏移量。</p><p id="8a15" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.TCP选项中的SACK块，包含它在间隙后接收的数据块。</p><p id="32c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">发送TCP采用间隙之后的第一个数据包和间隙之前的最后一个数据包之间的偏移差。这使得发送TCP很容易识别它需要重新传输的数据块。</p><p id="2a59" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，举例来说，如果接收TCP发送1，000的(<a class="ae nk" href="https://www.youtube.com/watch?v=KWiHAMDbrng" rel="noopener ugc nofollow" target="_blank">重复</a>)确认，并且SACK块包含1100–1500的范围，显然发送TCP只需要重新传输1，000到1，100的数据包。</p><h2 id="0e9b" class="nm lc iq bd ld nn no dn lh np nq dp ll ko nr ns ln ks nt nu lp kw nv nw lr nx bi translated">nototherwiseprovided（for）除非另有规定</h2><p id="17cf" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">当实际数据不符合大小限制时，这有助于TCP将字段填充为四个字节的倍数。</p><h2 id="7c0c" class="nm lc iq bd ld nn no dn lh np nq dp ll ko nr ns ln ks nt nu lp kw nv nw lr nx bi translated">寿命终止</h2><p id="c4bb" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">它指示“选项结束”列表，并显示不需要对选项列表进行进一步处理。</p><h1 id="1eda" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">为什么我们需要三次握手？</h1><p id="4a4f" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">如果我们仔细观察握手过程中发生的事情，双方都在跟踪他们用来发送和接收数据的偏移值(<code class="fe mq mr ms mt b">sequence number</code>)。两端保持连接状态。</p><p id="9238" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">跟踪偏移值使连接双方能够确定发送和接收的数据包是否有问题。它有助于确定重复的数据包，纠正无序的数据包，并在数据包丢失的情况下重新传输。</p><p id="68f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mo">出现这些问题是因为IP层的工作方式。它没有TCP连接的上下文。在路由器级别，它根据一些路径计算发送数据包，这意味着对应于同一TCP连接的两个数据包可能会通过不同的路由到达同一目的地。这就是TCP必须处理这些场景的原因。</em></p><p id="5b1e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个温和的数据包重新排序示例:</p><h2 id="a11d" class="nm lc iq bd ld nn no dn lh np nq dp ll ko nr ns ln ks nt nu lp kw nv nw lr nx bi translated">纠正无序数据包</h2><p id="860f" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">由于对应于同一TCP连接的数据包通常在不同的路由上传输，因此它们到达接收TCP的顺序是混乱的。由于TCP保证按顺序传送，它将无序的数据包存储在其接收方缓冲区中，并等待丢失的数据包来填充字节流中的“洞”。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ob"><img src="../Images/c26fdfb42f467b027c6b398232ea3dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c5HIlC1BEMUfQJz3o5ecJw.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">可以观察到轻微的分组重新排序</p></figure><ol class=""><li id="0163" class="mu mv iq kh b ki kj kl km ko mw ks mx kw my la oc na nb nc bi translated">接收端在收到P3之前收到了P4数据包。因此，它将P4保存在其接收缓冲区中，并发送一个(重复的)收到的最后一个数据包的确认。然后，它等待P3进来。</li><li id="80c7" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la oc na nb nc bi translated">一旦P3到达，它就发送与成功接收的最后一个数据包(即P4)相对应的确认信息。</li></ol><p id="9f06" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="mo">注</em> </strong> <em class="mo">:由于TCP确认在本质上是累积的，发送P4的确认也意味着P3的成功接收。</em></p><p id="7695" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<code class="fe mq mr ms mt b">Sequence Number</code>在跟踪丢失的数据包、无序的数据包，甚至重复的数据包中起着至关重要的作用。这就需要在两端建立连接并保持连接状态。</p><h1 id="7e35" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">为什么选择UDP而不是TCP？</h1><p id="74d0" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">在一些情况下，UDP优于TCP。造成这种情况的一些因素有:</p><p id="dc6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.服务负担不起TCP握手的开销，或者握手开销相对于实际发送的数据来说相当大。</p><p id="cd04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.偶尔丢包是可以接受的(取决于使用情况)。</p><p id="a9f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">UDP优于TCP的一些例子有<a class="ae nk" href="https://gafferongames.com/post/udp_vs_tcp/" rel="noopener ugc nofollow" target="_blank">多人游戏</a>、天气数据、视频流等。</p><h1 id="bbd1" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">结论</h1><p id="aa60" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">我们已经了解了TCP连接的必要性及其作用，并研究了各种配置选项以满足各种需求。</p><p id="213a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看到TCP提供了多少抽象是很有趣的。在应用程序级别工作的开发人员从来不需要考虑这个问题。</p><p id="9e55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想探索更多，一个好的起点是Chris Greer在TCP上的<a class="ae nk" href="https://www.youtube.com/playlist?list=PLW8bTPfXNGdAZIKv-y9v_XLXtEqrPtntm" rel="noopener ugc nofollow" target="_blank">播放列表</a>。</p><p id="cb1b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想深入研究TCP/IP，我强烈推荐TCP/IP图文并茂的第一卷书。它非常深入地涵盖了这个主题。</p><p id="7652" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文原载于rrawat.com<a class="ae nk" href="https://rrawat.com/blog/three-way-handshake" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="lz ma mb mc gt od mt oe of aw og bi"><span id="6e2a" class="nm lc iq mt b gy oh oi l oj ok"><strong class="mt ir">Want more such articles?</strong></span><span id="92d4" class="nm lc iq mt b gy ol oi l oj ok">You can join my newsletter <a class="ae nk" href="https://buttondown.email/rishabh570" rel="noopener ugc nofollow" target="_blank">here</a>.</span><span id="4ea8" class="nm lc iq mt b gy ol oi l oj ok">I write about my learnings and experiences related to web development technologies biweekly.</span></pre></div></div>    
</body>
</html>