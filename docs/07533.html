<html>
<head>
<title>Reducing App Testing Time Using Jest and CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Jest和CircleCI缩短应用测试时间</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/reducing-app-testing-time-using-jest-and-circleci-39170231fee2?source=collection_archive---------11-----------------------#2021-01-25">https://betterprogramming.pub/reducing-app-testing-time-using-jest-and-circleci-39170231fee2?source=collection_archive---------11-----------------------#2021-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1809" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Jest和CircleCI并行测试指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/619913c8e110c33e48f55252067c8e10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*stqT_O1Hwv5AgaID"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@krisroller?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kristopher Roller </a>拍摄。</p></figure><p id="c384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将带你了解如何使用CircleCI 进行测试分割，以及如何减少你的应用程序的测试时间。它还将详细说明如何分割前端测试以改进DX。</p><p id="d4c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是GitHub的最终代码:</p><div class="lv lw gp gr lx ly"><a href="https://github.com/manakuro/testing-in-parallel-example" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">manakuro/并行测试示例</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">与Jest和CircleCI并行测试。通过创建……为manakuro/并行测试示例开发做出贡献</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">github.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="471c" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">设置React应用程序</h1><p id="3743" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">为了快速开始，我们将使用create-next-app来设置React应用程序:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="9e8b" class="nw mv it ns b gy nx ny l nz oa">npx create-next-app test-app</span></pre><p id="787e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装完成后，通过运行以下命令运行开发服务器:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="54b4" class="nw mv it ns b gy nx ny l nz oa">yarn dev</span></pre><p id="49ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到欢迎页面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/c2d545970cc00b3066f645871a338a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QW2PGapQTiIzlHLBRj9BBg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">欢迎页面</p></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="4c14" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">开个玩笑</h1><p id="3597" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">接下来，我们将设置一个Jest环境。</p><p id="f981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装依赖项:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="029c" class="nw mv it ns b gy nx ny l nz oa">yarn add -D babel-jest jest</span></pre><p id="81b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个<code class="fe oc od oe ns b">babel.config.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="3e95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并将测试脚本添加到<code class="fe oc od oe ns b">package.json</code>:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="908d" class="nw mv it ns b gy nx ny l nz oa">"scripts": {<br/>  ...<br/>  "test": "jest"<br/>},</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="b72c" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">写一个测试</h1><p id="1209" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">假设我们有两种文件:</p><ul class=""><li id="0092" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu om on oo op bi translated">测试不会花很长时间的简单模块。</li><li id="f593" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">测试大型组件将花费大量时间。</li></ul><p id="bff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将编写一些模块测试。像这样创建一个名为<code class="fe oc od oe ns b">some1.test.js</code>的测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="3807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并执行测试，这将只需要几秒钟:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/cee22712fce8f44d0885bdab0298e98d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Ccsxp7ntJKoNzirZ16jfQ.png"/></div></div></figure><p id="c73d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将创建第二个类别，它将测试大型组件，需要很长时间。</p><p id="36cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我不会实现细节，但这些测试类似于在酶中使用<code class="fe oc od oe ns b"><a class="ae ky" href="https://enzymejs.github.io/enzyme/docs/api/mount.html" rel="noopener ugc nofollow" target="_blank">mount()</a></code>的测试。</p><p id="8b7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与浅层或静态呈现不同，<code class="fe oc od oe ns b">mount()</code>很重，因为它将呈现整个组件——包括所有子组件——并将组件挂载到DOM中。</p><p id="06f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">得益于此，一个完整的DOM API在全球范围内可用。它将使您能够在您的应用程序中测试实际案例。</p><p id="a469" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果你的应用程序中存在大量这样的测试，这可能会花费相当多的时间，并影响你的团队的生产力。</p><p id="0cc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们来编写测试。</p><p id="5708" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个名为<code class="fe oc od oe ns b">some2.test.js</code>的文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="64fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您运行测试时:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/14812d839464d9e013d0b455f309365b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jfS0t1tAJTx-PZXLWnrdsA.png"/></div></div></figure><p id="21b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要104秒，尽管第一个只需要几秒钟。</p><p id="356e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实际情况下，这是因为你的应用程序越大，你的应用程序中需要的测试就越多。</p><p id="6dca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，如果你一直加上<code class="fe oc od oe ns b">some3.test.js</code>、<code class="fe oc od oe ns b">some4.test.js</code>、<code class="fe oc od oe ns b">some5.test.js</code>等等，那么在CI中的时间会更长。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="d03f" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">前端测试</h1><p id="1301" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们如何应对这个问题？在回答这个问题之前，让我们考虑一下前端测试应该覆盖哪些内容。</p><p id="fa1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前端开发中，您的测试套件应该由三层组成:</p><ul class=""><li id="309e" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu om on oo op bi translated">E2E测试</li><li id="3fa7" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">集成测试</li><li id="fc10" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">单元测试</li></ul><h2 id="feab" class="nw mv it bd mw ox oy dn na oz pa dp ne li pb pc ng lm pd pe ni lq pf pg nk ph bi translated">E2E测试</h2><p id="c213" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">端到端(E2E)测试用于模拟用户与应用程序交互的实际步骤。</p><p id="6775" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们是在真实浏览器中工作的所有组件和API的组合，这让您确信它们真的会在您的应用程序中工作。</p><p id="f5f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前端开发中，E2E测试应该只覆盖应用程序中的基本特性，而不应该覆盖所有的功能，因为它可能会变得昂贵和不可靠。</p><h2 id="773d" class="nw mv it bd mw ox oy dn na oz pa dp ne li pb pc ng lm pd pe ni lq pf pg nk ph bi translated">集成测试</h2><p id="1dc2" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">集成测试由组件和函数组成，它们只断言组件的公共接口。他们不应该关注组件的内部实现细节和完整的基于行的覆盖。</p><p id="ae40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于单个测试用例，它应该只关注组件的预期输出，如<a class="ae ky" href="https://en.wikipedia.org/wiki/Black-box_testing" rel="noopener ugc nofollow" target="_blank">黑盒测试</a>。这样做的好处是，无论您如何更改组件的内部实现，只要输出与之前相同，测试就会通过。</p><p id="5bcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，应该在DOM中安装组件来模拟用户交互。但是如果有很多测试，这可能会变得很麻烦，因为安装整个组件及其所有依赖项可能会变得很慢。</p><p id="14f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前端开发中，集成测试应该覆盖什么样的组件？例如，在原子设计中，集成测试应该在模板或页面层编写。它们由原子、分子和有机体组成，并在页面上提供一组特征。他们不关心孩子们如何工作，只关心投入和产出。</p><h2 id="a3ed" class="nw mv it bd mw ox oy dn na oz pa dp ne li pb pc ng lm pd pe ni lq pf pg nk ph bi translated">单元测试</h2><p id="2e54" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">单元测试用于测试更小的模块或组件，例如原子设计中的原子、模块和有机体。</p><p id="47b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与集成测试不同，组件中的单元测试使用浅层呈现，这允许您挂载组件，而无需通过模仿子组件来呈现它们。单元测试的范围应该更窄，并使代码可测试，这样您就可以轻松地运行它们，而无需任何开销。</p><p id="3afe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以单元测试的数量可能远远超过任何其他类型的测试。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="496e" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">将测试分为单元测试和集成测试</h1><p id="5b6e" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">如果您在测试中遇到性能问题，尝试将它们分成单元测试和集成测试，并在不同的线程中运行它们。这可以减少所需的测试时间。</p><p id="bec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设我们有十个测试文件。其中七个使用mount render，与其他相比成本较高，如下所示:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="0b21" class="nw mv it ns b gy nx ny l nz oa">some1.test.js<br/>some2.test.js<br/>some3.test.js</span><span id="345b" class="nw mv it ns b gy pi ny l nz oa">// use mount render<br/>some4.test.js<br/>some5.test.js<br/>some6.test.js<br/>some8.test.js<br/>some9.test.js<br/>some10.test.js</span></pre><p id="3d18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们将它们的扩展名重命名为<code class="fe oc od oe ns b">intg.js</code>，就像这样:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="c2f8" class="nw mv it ns b gy nx ny l nz oa">some1.test.js<br/>some2.test.js<br/>some3.test.js</span><span id="6d31" class="nw mv it ns b gy pi ny l nz oa">// use mount render<br/>some4.<strong class="ns iu">intg</strong>.js<br/>some5.<strong class="ns iu">intg</strong>.js<br/>some6.<strong class="ns iu">intg</strong>.js<br/>some8.<strong class="ns iu">intg</strong>.js<br/>some9.<strong class="ns iu">intg</strong>.js<br/>some10.<strong class="ns iu">intg</strong>.js</span></pre><p id="d8fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们这里有七个集成测试。</p><p id="ddb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而在<code class="fe oc od oe ns b">jest.config.js</code>中，像这样添加<code class="fe oc od oe ns b">testMatch</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="e826" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对<code class="fe oc od oe ns b">package.json</code>做如下修改:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="7702" class="nw mv it ns b gy nx ny l nz oa">"scripts": {<br/>   ...<br/>  "test:unit": "jest",<br/>  "test:integration": "INTEGRATION=true jest"<br/>},</span></pre><p id="626d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经将测试分为单元测试和集成测试。</p><p id="01f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您添加一个新的单元测试时，运行所有的单元测试会更容易，而不需要昂贵的单元测试:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/260146ecbe8db1955d2574795d932653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1JoLFuY6kSILvwnOvZMrGA.png"/></div></div></figure><p id="224b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，运行集成测试仍然很昂贵。让我们让它们并行执行。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="9ada" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">CircleCI的平行测试</h1><p id="aac6" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">CircleCI提供了通过测试分割进行并行测试的能力，它接受一个测试列表，并将它们分割到由<code class="fe oc od oe ns b">config.yml</code>中的<code class="fe oc od oe ns b">parallelism</code>定义的节点数上。</p><p id="4677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是在CircleCI上加速构建和运行的最简单的方法之一。</p><p id="9096" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，为<code class="fe oc od oe ns b">package.json</code>中的CI添加<code class="fe oc od oe ns b">test:integration:ci</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="f03b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到您的<code class="fe oc od oe ns b">.circleci/config.yml</code>并添加<code class="fe oc od oe ns b">parallelism</code>键:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在测试作业中，添加如下命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="301b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oc od oe ns b">circleci test glob src/**/*.intg.js</code>将接收测试文件列表，CircleCI CLI将根据计时数据对其进行分割。CircleCI查看历史计时数据，并跨节点动态拆分测试。</p><p id="e607" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了能够在CircleCI中做到这一点，我们需要安装<code class="fe oc od oe ns b">jest-junit</code>:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="b02e" class="nw mv it ns b gy nx ny l nz oa">yarn add -D jest-junit</span></pre><p id="e3e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经准备好了。当您推动变更时，CircleCI会自动拆分您的测试并并行运行它们:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/baaa8cba794fce67193d2a5de395314c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e6WDDaWRmi3VG2-nX6_ucw.png"/></div></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="fa09" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="5d06" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">就是这样！我们已经介绍了前端测试应该覆盖的内容，以及如何通过拆分来加速测试。</p><p id="05b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着应用程序的增长，测试中需要的内容会发生变化。</p><p id="ce9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拆分测试并并行运行它们是提高测试性能的方法之一。在某些情况下，例如对于较大的应用程序，它可能适合您的需要。</p><p id="085a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题可能有其他的解决方法，所以请在评论中告诉我。</p></div></div>    
</body>
</html>