<html>
<head>
<title>Quick ES6 Development Guide — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES6快速开发指南—第2部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/quick-es6-development-guide-part-2-c782740064fc?source=collection_archive---------22-----------------------#2019-11-12">https://betterprogramming.pub/quick-es6-development-guide-part-2-c782740064fc?source=collection_archive---------22-----------------------#2019-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d66f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">粗箭头函数、析构、扩展操作符等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5c66a5b1cb1b19a400cc74b1a4695940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*995gWzK2AfkUfzwTU-WVfg.jpeg"/></div></div></figure><p id="a819" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章是ES6系列文章的第2部分。如果您跳过了第1部分，您可以在<a class="ae ln" href="https://medium.com/better-programming/quick-es6-development-guide-9b9cd9894a7" rel="noopener">媒体</a>上观看。虽然本文涉及的主题与第1部分无关，但建议先阅读第1部分。</p><p id="b5c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本帖中，我们将讨论更多真正有用的ES6特性。如果你掌握了这些，你就可以跳到Angular 2+里，反应原生开发。开始吧！</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="158a" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">粗箭头函数</h1><p id="752e" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">如果你已经在使用ES6中的胖箭头功能，你就知道它们是多么的简单和神奇。首先，让我们看一个使用ES5的简单例子:</p><p id="71b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">匿名函数:没有名字的函数。</p><p id="43cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="c555" class="mx lw iq mt b gy my mz l na nb">setTimeout(function() {<br/>    console.log('I am here after 3 light-years ;)');<br/>}, 3000);</span></pre><p id="3745" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们给这个匿名函数起个名字:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="3f06" class="mx lw iq mt b gy my mz l na nb">function myFunction() {<br/>    console.log('I am your function');<br/>}<br/>setTimeout(myFunction, 3000);</span></pre><p id="eecd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的函数有一个名字，<code class="fe nc nd ne mt b">myFunction</code>。注意<code class="fe nc nd ne mt b">setTimeout</code>函数的参数。我们将函数作为参数传递，因为JavaScript函数是一级函数。这意味着一个函数可以接受另一个函数作为它的参数。</p><p id="8cfe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">ES6引入了胖箭头函数，这是一种稍微短一点的编写匿名函数的方式。</p><blockquote class="nf ng nh"><p id="8eaa" class="kr ks ni kt b ku kv jr kw kx ky ju kz nj lb lc ld nk lf lg lh nl lj lk ll lm ij bi translated">箭头函数表达式的语法比<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function" rel="noopener ugc nofollow" target="_blank">函数表达式</a>短，并且没有自己的<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank"> this </a>、<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" rel="noopener ugc nofollow" target="_blank"> arguments </a>、<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super" rel="noopener ugc nofollow" target="_blank"> super </a>或<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target" rel="noopener ugc nofollow" target="_blank"> new.target </a>。这些函数表达式最适合于非方法函数，它们不能用作构造函数。— Mozilla文档</p></blockquote><p id="baca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于箭头函数没有自己的<code class="fe nc nd ne mt b">this</code>，输出与函数表达式不相似。示例:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="97eb" class="mx lw iq mt b gy my mz l na nb">var compareObj= {<br/>  age: 26,<br/>  ageArrow: () =&gt; console.log(this.age, this),<br/>  ageExpression: function() {<br/>    console.log(this.age, this);<br/>  }<br/>}</span><span id="69a8" class="mx lw iq mt b gy nm mz l na nb"> &gt;   compareObj.ageArrow();<br/> //   undefined<br/>Window      <br/>     <br/>&gt;  compareObj.ageExpression();<br/>// 26 {age: 26, ageArrow: ƒ, ageExpression: ƒ}</span></pre><p id="19e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的<code class="fe nc nd ne mt b">setTimeout</code>匿名函数也可以使用粗箭头函数编写:</p><p id="8e19" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例子一:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="7305" class="mx lw iq mt b gy my mz l na nb">setTimeout(() =&gt; {<br/>     console.log("I am here after 3 light-years ;)");<br/>}, 3000);</span></pre><p id="4fa7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例子二:简单的<code class="fe nc nd ne mt b">sum</code>函数遗留声明和粗箭头表示。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="b30a" class="mx lw iq mt b gy my mz l na nb">const sumFun = function(arg1, arg2, arg3) {<br/>    return arg1 + arg2 + arg3;<br/>};</span></pre><p id="b406" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">粗箭头表示:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="6f80" class="mx lw iq mt b gy my mz l na nb">const sumFun = ( arg1, arg2, arg3 ) =&gt;  arg1 + arg2 + arg3;</span></pre><p id="2f36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">或者，对于函数中的多行语句，需要使用<code class="fe nc nd ne mt b">return</code>关键字显式返回，如下例所示。如果是一行语句，它会自动返回(如上例所述)。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="7bfd" class="mx lw iq mt b gy my mz l na nb">const sumFun = ( arg1, arg2, arg3 ) =&gt;  {<br/>    return arg1 + arg2 + arg3;<br/>}</span></pre></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="428f" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">解构</h1><p id="c54a" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">析构是一种将数组和对象中的值直接提取到变量中的方法。让我们用一个例子来理解这一点:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="ec35" class="mx lw iq mt b gy my mz l na nb">const modusEmployee = {<br/>    name: ‘Nikhil’,<br/>    country: ‘India’,<br/>    city: ‘New Delhi’,<br/>    nativeLanguage: ‘Hindi’<br/>};</span></pre><p id="1a7d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在ES5中，我们可以这样提取对象值:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="1411" class="mx lw iq mt b gy my mz l na nb">const empName = modusEmployee.name;<br/>// Nikhil<br/>const empCity = modusEmployee.city;<br/>// New Delhi</span></pre><p id="4497" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在ES6中，它得到了改进:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="5b2e" class="mx lw iq mt b gy my mz l na nb">const { name, city } = modusEmployee;<br/>console.log(name);<br/>	// Nikhil<br/>console.log(city);<br/>	// New Delhi</span></pre><p id="4363" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，我们使用别名作为属性名。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="300f" class="mx lw iq mt b gy my mz l na nb">const { name: empName, city: empCity } = modusEmployee;<br/>console.log(empName);<br/>// Nikhil<br/>console.log(empCity);<br/>// New Delhi</span></pre><p id="0f8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">析构可以以下列方式使用:</p><ul class=""><li id="099c" class="nn no iq kt b ku kv kx ky la np le nq li nr lm ns nt nu nv bi translated">对象析构。</li><li id="5ef5" class="nn no iq kt b ku nw kx nx la ny le nz li oa lm ns nt nu nv bi translated">数组析构。</li><li id="7c13" class="nn no iq kt b ku nw kx nx la ny le nz li oa lm ns nt nu nv bi translated">函数参数析构。</li></ul><p id="4886" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们已经讨论了对象析构，让我们看看数组析构是如何工作的。</p><p id="d874" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">数组析构非常类似于对象析构。不同之处在于，它根据索引提取值。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="51d1" class="mx lw iq mt b gy my mz l na nb">const myCoins = [ 1,2,5,10 ];<br/>const [ coin1, coin2 ] = myCoins;<br/>console.log(coin1)<br/>// 1<br/>console.log(coin2);<br/>// 2</span></pre><h2 id="e8c0" class="mx lw iq bd lx ob oc dn mb od oe dp mf la of og mh le oh oi mj li oj ok ml ol bi translated"><strong class="ak">奖励积分</strong></h2><p id="352c" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">如果您只想要第三个值:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="3bdf" class="mx lw iq mt b gy my mz l na nb">const [ , , coin3 ] = myCoins;<br/>console.log(coin3);<br/>// 5;</span></pre><p id="2f26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果希望一个变量中包含所有值:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="7f6c" class="mx lw iq mt b gy my mz l na nb">const [ ...all ] = myCoins;<br/>console.log(all);<br/> // [1,2,5,10]</span></pre><p id="df6a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您想获得其余的值:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="1d86" class="mx lw iq mt b gy my mz l na nb">const myCoins = [ 1,2,5,10 ];<br/>const [ coin1, ...otherCoins ] = myCoins;<br/>console.log(coin1);<br/>// 1<br/>console.log(otherCoins);<br/>// [ 2, 5, 10 ]</span></pre><p id="c370" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">没有可用于析构的值时的处理条件:默认值。当要析构的属性未定义时，可以提供默认值:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="40fe" class="mx lw iq mt b gy my mz l na nb">const [ random = ‘not found’ ] = [ ‘Available’ ];<br/>	console.log(random);<br/>// Available</span><span id="2d25" class="mx lw iq mt b gy nm mz l na nb">const  [ random = ‘not found’ ] = [];<br/>	console.log(random);<br/>	// not found</span></pre></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="8fba" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">面向对象:类</h1><p id="1ece" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">JavaScript是一种基于原型的编程语言，在ES5中没有可用的关键字<code class="fe nc nd ne mt b">class</code>。这并不意味着我们不能在ES5中使用面向对象编程来编码。</p><p id="5483" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以通过用原型方法创建一个对象来模仿ES5中的面向对象编程。也可以通过使用这些对象来实现继承。这就是我们如何用ES5创建一个<code class="fe nc nd ne mt b">class</code>:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="4f8c" class="mx lw iq mt b gy my mz l na nb">var Automobile = function (engineSound) {<br/>    this.engineSound = engineSound;<br/>} </span><span id="01fa" class="mx lw iq mt b gy nm mz l na nb">Automobile.prototype.engineSoundFun = function() {<br/>    console.log(this.engineSound)<br/>};</span><span id="ad5a" class="mx lw iq mt b gy nm mz l na nb">var enfield = new Automobile(‘dhuk dhuk’);</span><span id="d64c" class="mx lw iq mt b gy nm mz l na nb">enfield.engineSoundFun();</span><span id="5b13" class="mx lw iq mt b gy nm mz l na nb">Output:<br/>// dhuk dhuk</span></pre><p id="2023" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您熟悉C++或Java，您可能会想:“上面的例子中没有使用<code class="fe nc nd ne mt b">class</code>关键字，那么面向对象在哪里？”</p><p id="223b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为其他语言中经典的面向对象模式，ES6中的语法变得更容易理解。ES6引入了<code class="fe nc nd ne mt b">class</code>关键字，使其更容易理解。</p><p id="8327" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">ES6类支持基于原型的继承、超级调用、实例和静态方法以及构造函数。</p><p id="d7f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们以ES6的方式来做上面的例子:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="6611" class="mx lw iq mt b gy my mz l na nb">class Automobile {<br/>    constructor(engineSound) {<br/>        this.engineSound = engineSound;<br/>    }</span><span id="b61b" class="mx lw iq mt b gy nm mz l na nb">    engineSoundFun() {<br/>        console.log(this.engineSound);<br/>    }<br/>}</span><span id="8937" class="mx lw iq mt b gy nm mz l na nb">const enfield = new Automobile(‘Dhuk Dhuk’);<br/>	<br/>enfield.engineSoundFun()</span><span id="2d21" class="mx lw iq mt b gy nm mz l na nb">Output:<br/>// Dhuk Dhuk</span></pre><p id="3631" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，在ES6中，代码更干净、更容易，也更熟悉。然而，原型模式仍然可以在ES6中使用。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="acc4" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">模板文字</h1><p id="9537" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">记住，使用<code class="fe nc nd ne mt b">console.log</code>和变量串联调试代码:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="e198" class="mx lw iq mt b gy my mz l na nb">var name = ' Welcome! ' + first + ' ' + last + '.';<br/>console.log(‘Hi ‘ + name + ‘ your username is ‘ + username):</span></pre><p id="7484" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是，在ES6中，我们可以在反勾字符串中使用新的语法<code class="fe nc nd ne mt b">${first}</code>来清理它:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="e550" class="mx lw iq mt b gy my mz l na nb">const name = ` Welcome! ${first} ${last}.`;<br/>console.log(`Hi ${name} your username is: ${username}`);</span></pre><p id="44a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之前的另一个问题是使用<em class="ni">多行字符串</em>，使用的新行语句是用特殊字符打印的，如<code class="fe nc nd ne mt b">\n</code>:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="3f1f" class="mx lw iq mt b gy my mz l na nb">var message = ‘Individuals in semler project \n are not just developers or testers, they are \n good friends’;</span></pre><p id="5c2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，使用带反勾号的模板文字可以像您预期的那样工作:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="909f" class="mx lw iq mt b gy my mz l na nb">const message = `Individuals in semler project are not just developers or testers, they are<br/>good friends`;</span></pre></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="bcbd" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">传播算子</h1><p id="892b" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">如果你知道JavaScript中的<em class="ni">深度复制</em>和<em class="ni">浅度复制</em>的概念(看一下下面这篇文章的附加部分)，你就会明白，有时候，分析对象复制和它们的使用之间发生了什么变得很困难。</p><p id="e98a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">代码说话，让我们用一个例子来理解这个场景(没有展开操作符):</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="4391" class="mx lw iq mt b gy my mz l na nb">const myCurrencyNotes = [1, 5, 10, 1000]; <br/>const piratedNotes = myCurrencyNotes;</span><span id="9a5f" class="mx lw iq mt b gy nm mz l na nb">console.log(piratedNotes);</span><span id="24c4" class="mx lw iq mt b gy nm mz l na nb">Output:</span><span id="3d96" class="mx lw iq mt b gy nm mz l na nb"> [1, 5, 10, 1000]</span><span id="5fdb" class="mx lw iq mt b gy nm mz l na nb">&gt; piratedNotes.push(50);</span><span id="2d5b" class="mx lw iq mt b gy nm mz l na nb">console.log(piratedNotes);</span><span id="d82d" class="mx lw iq mt b gy nm mz l na nb">Output:<br/>[1, 5, 10, 1000, 50]</span><span id="2f46" class="mx lw iq mt b gy nm mz l na nb">Now, when you log:</span><span id="19c9" class="mx lw iq mt b gy nm mz l na nb">&gt; console.log(myCurrencyNotes);</span><span id="bdb8" class="mx lw iq mt b gy nm mz l na nb">Output:<br/>[1, 5, 10, 1000, 50]</span></pre><p id="1198" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们知道在JavaScript中处理对象时(数组是对象的一种类型)，我们通过引用赋值，而不是通过值。</p><p id="ef68" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">spread运算符的用法也是如此:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="56a8" class="mx lw iq mt b gy my mz l na nb">const myCurrencyNotes = [1, 5, 10, 1000];<br/>const piratedNotes = [ ...myCurrencyNotes ];</span><span id="e5b0" class="mx lw iq mt b gy nm mz l na nb">console.log(piratedNotes);</span><span id="a6b8" class="mx lw iq mt b gy nm mz l na nb">Output:<br/>[1, 5, 10, 1000]</span><span id="e784" class="mx lw iq mt b gy nm mz l na nb">&gt; piratedNotes.push[50,100]</span><span id="d112" class="mx lw iq mt b gy nm mz l na nb">&gt; console.log(myCurrencyNotes);</span><span id="9d98" class="mx lw iq mt b gy nm mz l na nb">Output:<br/> [1, 5, 10, 1000]</span></pre><p id="4968" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意这里的区别，当我们推送<code class="fe nc nd ne mt b">piratedNotes</code>数组中的元素时，原始数组<code class="fe nc nd ne mt b">myCurrencyNotes</code>不受影响。</p><p id="496f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">传播的另一个用例是:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="76a1" class="mx lw iq mt b gy my mz l na nb">var newCurrencyNotes = [ 50,100 ];<br/>var myAllCurrencyNotes = [ 1, 5, 10, newCurrencyNotes, 1000 ];</span><span id="1541" class="mx lw iq mt b gy nm mz l na nb">console.log(myAllCurrencyNotes);</span><span id="b28a" class="mx lw iq mt b gy nm mz l na nb">Output:</span><span id="75ee" class="mx lw iq mt b gy nm mz l na nb">[1, 5, 10, Array(2), 1000].</span><span id="504f" class="mx lw iq mt b gy nm mz l na nb">0:1<br/>1:5<br/>2:10<br/>3:(2) [50, 100]<br/>4:1000</span></pre><p id="bdeb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能不希望输出中出现第三步，因为它变成了一个嵌套数组。为了消除这样的问题，我们可以利用扩展运算符:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="e086" class="mx lw iq mt b gy my mz l na nb">const myAllCurrencyNotes = [1, 5, 10, ...newCurrencyNotes, 1000]<br/>console.log(myAllCurrencyNotes);</span><span id="efcf" class="mx lw iq mt b gy nm mz l na nb">Output:</span><span id="b96c" class="mx lw iq mt b gy nm mz l na nb">[1, 5, 10, 50, 100, 1000]</span></pre><p id="0489" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">功能分布:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="87b0" class="mx lw iq mt b gy my mz l na nb">function checkFakeCurrencyNote(...notesVariations) {<br/>    if (notesVariations.includes(1000)) {<br/>        return ‘Contains an invalid currency denomination’;<br/>    } else{<br/>        return ‘Aha! nice currency’;<br/>    }<br/>}</span><span id="4865" class="mx lw iq mt b gy nm mz l na nb">const currency = [ 1, 10, 1000 ];<br/>	&gt; checkFakeCurrencyNote(...currency);<br/>			<br/>Output:<br/>	"Contains an invalid currency denomination"</span></pre></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="0771" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">承诺</h1><p id="507e" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">对象在JavaScript中随处可见。承诺也是一个在未来返回其价值的对象。当您要执行异步操作时，使用承诺非常有用。一个承诺可以被解决，也可以被拒绝。</p><p id="65cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">JavaScript中的承诺类似于我们现实生活中的承诺。假设你邀请你的朋友参加一个聚会(请求已发送)，他们告诉你他们可能会组织聚会(<code class="fe nc nd ne mt b">resolve</code>)或者不会(<code class="fe nc nd ne mt b">rejected</code>)。</p><p id="d54c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果承诺被称为已解决，您可以使用<code class="fe nc nd ne mt b">.then()</code>进一步处理它。如果承诺被拒绝，可以在<code class="fe nc nd ne mt b">.catch()</code>中处理，或者作为<code class="fe nc nd ne mt b">.then()</code>中的第二个参数处理。</p><p id="85b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可以用<code class="fe nc nd ne mt b">new Promise</code>做出承诺。这个Promise构造函数接受一个包含两个参数的函数— <code class="fe nc nd ne mt b">resolve</code>和<code class="fe nc nd ne mt b">reject</code>。创造承诺的基本框架是:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="18bb" class="mx lw iq mt b gy my mz l na nb">new Promise((resolve, reject) =&gt; {<br/>    /* Do something here */<br/>});</span></pre><p id="1cd7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe nc nd ne mt b">.then()</code>和<code class="fe nc nd ne mt b">error</code>的情况下，承诺以名称<code class="fe nc nd ne mt b">promise</code>创建，正如我们在上面已经讨论过的:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="945a" class="mx lw iq mt b gy my mz l na nb">promise.then((resolvedValue) =&gt; {<br/>    console.log(resolvedValue);<br/>}, (error) =&gt; {<br/>    console.log(error);<br/>});</span></pre><p id="4e32" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们通过一个完整的片段来理解这一点:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="e6e9" class="mx lw iq mt b gy my mz l na nb">const yourAge = window.prompt(‘Enter your age’, 13);<br/>console.log(`Entered age is ${yourAge}`);</span></pre><p id="3d64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">变量<code class="fe nc nd ne mt b">yourAge</code>被声明，并准备在浏览器提示中存储用户的随机输入值。我们将在程序的后面使用这个随机值:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="20b1" class="mx lw iq mt b gy my mz l na nb">new Promise((resolve, reject) =&gt; {<br/>    If ( yourAge &lt; 99  ) {<br/>        resolve("Congrats!! you are still young Carlos");<br/>    } else {<br/>        reject(new Error(‘Now at this stage, you should start eating tons of veggies’));<br/>    }<br/>});</span></pre><p id="47bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，我使用新的<code class="fe nc nd ne mt b">Promise</code>初始化了一个承诺，并传递了两个参数。嵌套逻辑比较变量<code class="fe nc nd ne mt b">yourAge</code>的值。如果值小于99，promise返回<code class="fe nc nd ne mt b">resolve</code>，否则拒绝并错误输出。</p><p id="1628" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们简单地用一个正的case值<code class="fe nc nd ne mt b">i.e value &lt; 99</code>运行上面的代码片段，我们将得不到任何输出，如果我们提供一个负的case值<code class="fe nc nd ne mt b">i.e value &gt; 99</code>，我们将得到一个<code class="fe nc nd ne mt b">Uncaught</code>错误:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="3181" class="mx lw iq mt b gy my mz l na nb">Uncaught (in promise) Error:  Now at this stage, you should start  eating tons of veggies<br/>    at Promise (:5:13)<br/>    at new Promise ()<br/>    at :1:17</span></pre><p id="3466" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意:虽然您可以从<code class="fe nc nd ne mt b">reject</code>中删除<code class="fe nc nd ne mt b">new Error</code>并简单地返回一个类似<code class="fe nc nd ne mt b">resolve</code>的字符串，但最好是出错拒绝，但这不是必需的。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="9250" class="mx lw iq mt b gy my mz l na nb">reject(‘Now at this stage, you should start eating tons of veggies’);</span></pre><p id="a28e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，如果您的输入是一个负的case值，您仍然会得到:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="717b" class="mx lw iq mt b gy my mz l na nb">Uncaught (in promise)<br/>Now at this stage, you should start eating tons of veggies</span></pre><p id="d155" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些反应是意料之中的。如果你看到上面的例子，我们必须使用<code class="fe nc nd ne mt b">.then</code>和<code class="fe nc nd ne mt b">.catch</code>来获得预期的响应。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="752c" class="mx lw iq mt b gy my mz l na nb">promise.then((resolvedValue) =&gt; {<br/>    console.log(resolvedValue);<br/>}, (error) =&gt; {<br/>    console.log(error);<br/>});</span></pre><p id="15ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设您提供89作为输入值，输出将是:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="d912" class="mx lw iq mt b gy my mz l na nb">Congrats!! you are still young Carlos</span><span id="0f63" class="mx lw iq mt b gy nm mz l na nb">Promise {: undefined}<br/>__proto__: Promise<br/>[[PromiseStatus]]: "resolved"<br/>[[PromiseValue]]: undefined</span></pre><p id="f705" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于负案例输入，假设您提供120:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="e34c" class="mx lw iq mt b gy my mz l na nb">Now at this stage, you should start  eating tons of veggies</span><span id="b585" class="mx lw iq mt b gy nm mz l na nb">Promise {: undefined}<br/>__proto__:Promise<br/>[[PromiseStatus]]:"resolved"<br/>[[PromiseValue]]:undefined</span></pre></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="139e" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">好处:JavaScript中的浅层和深层复制</h1><p id="b18b" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">一个<em class="ni">浅拷贝</em>意味着两个对象的内存位置是相同的。因此，如果您更改副本对象的属性值，原始对象的属性值也会在对象的深层发生变化。</p><p id="cbb8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">浅层副本将复制顶级属性，但嵌套对象在原始对象(源)和副本对象(目标)之间共享。</p><p id="9bf9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，在<em class="ni">深度复制</em>中，存储位置将会不同/分开。更改copies对象的属性值不会更改原始对象。</p><p id="8a08" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">浅层复制示例:<code class="fe nc nd ne mt b">Object.assign()</code>方法用于将属性的值从一个或多个源对象复制到目标对象:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="f2f1" class="mx lw iq mt b gy my mz l na nb">let oldObj = {<br/>    id:1<br/>}</span><span id="5d05" class="mx lw iq mt b gy nm mz l na nb">&gt; oldObj<br/>  {id: 1}<br/>				<br/>let newObj = { ...oldObj };</span><span id="2d27" class="mx lw iq mt b gy nm mz l na nb">&gt; newObj<br/>  {id: 1}</span><span id="6ae3" class="mx lw iq mt b gy nm mz l na nb">&gt; newObj.id = 9;<br/> <br/>&gt; newObj<br/>   {id: 9}</span><span id="c8b7" class="mx lw iq mt b gy nm mz l na nb">&gt; oldObj<br/>    {id: 1}</span></pre><p id="ecd6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在此之前，一切都很好，但是，根据声明，“浅层复制将复制顶级属性。”让我们用一个例子来理解这一点:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="254d" class="mx lw iq mt b gy my mz l na nb">let oldObj = {<br/>  a: 1,<br/>  b: {<br/>    c: 2,<br/>  },<br/>}<br/>let newObj = Object.assign({}, oldObj );<br/>&gt;newObj<br/> { a: 1, b: { c: 2} }</span><span id="8474" class="mx lw iq mt b gy nm mz l na nb">oldObj.a = 10;</span><span id="0d59" class="mx lw iq mt b gy nm mz l na nb">&gt; oldObj <br/>// { a: 10, b: { c: 2} }</span><span id="08c5" class="mx lw iq mt b gy nm mz l na nb">&gt;newObj <br/>// { a: 1, b: { c: 2} }</span><span id="8f93" class="mx lw iq mt b gy nm mz l na nb">newObj.a = 20;<br/>&gt;oldObj<br/> // { a: 10, b: { c: 2} }</span><span id="8231" class="mx lw iq mt b gy nm mz l na nb">&gt; newObj<br/> // { a: 20, b: { c: 2} }</span><span id="c7f5" class="mx lw iq mt b gy nm mz l na nb">newObj.b.c = 30;<br/>&gt; oldObj<br/> // { a: 10, b: { c: 30} }</span><span id="1034" class="mx lw iq mt b gy nm mz l na nb">&gt; newObj<br/>// { a: 20, b: { c: 30} }</span></pre><p id="9466" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决这个问题，我们进行了深入的复制，检查如下。感谢我的同事Mitchell为我简化了这个。深层拷贝示例:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="da70" class="mx lw iq mt b gy my mz l na nb">const oldObj = {<br/>    id: 1,<br/>    foo: {<br/>        bar: 8<br/>    }<br/>};</span><span id="5442" class="mx lw iq mt b gy nm mz l na nb">&gt; const newObj  = JSON.parse(JSON.stringify(oldObj));<br/>&gt; newObj.foo.bar = 10<br/>// 10</span><span id="c10d" class="mx lw iq mt b gy nm mz l na nb">&gt; oldObj.foo.bar;<br/>// 8</span></pre></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="da5d" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">下一步是什么</h1><p id="cbb1" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我将在这里更新我即将发布的帖子的链接。在那里，我们将了解用户如何访问您的应用程序，即使他们的网络连接性很差或者根本没有网络。</p><p id="3472" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将分享您的web应用程序如何在三秒钟内加载(这是一个web应用程序的性能基准标准)。我还将讨论如何在移动设备上使用您的web应用程序，比如带有应用程序图标的混合移动应用程序。所以，请继续关注，还有更多精彩。</p><p id="1195" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了更好地理解ES6，我建议阅读本主题的第<a class="ae ln" href="https://moduscreate.com/blog/quick-practical-guide-for-es6/" rel="noopener ugc nofollow" target="_blank">部分</a>。</p><p id="7339" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这是一本好书。请分享您的反馈和建议。</p><p id="e3dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">编码快乐！</p></div></div>    
</body>
</html>