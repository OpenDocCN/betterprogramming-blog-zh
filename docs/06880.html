<html>
<head>
<title>Production-Grade Logging in Rust Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust应用中的生产级测井</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/production-grade-logging-in-rust-applications-2c7fffd108a6?source=collection_archive---------0-----------------------#2020-11-13">https://betterprogramming.pub/production-grade-logging-in-rust-applications-2c7fffd108a6?source=collection_archive---------0-----------------------#2020-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2079" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">强大的应用程序是日志记录良好的应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6b0bc338866d9e70b4d4e38835e70123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hXiPgjJYT_DlRRMdRJbbKQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马丁·比约克在<a class="ae kv" href="https://unsplash.com/s/photos/footstep-sand?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d010" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的应用程序每天为数百名客户提供服务。有一天，一些客户打电话给你，抱怨他们无法继续工作，因为功能被破坏了。然后，您查看数据库，发现来自其他客户的新数据非常好。接下来你会怎么做来解决这个问题？</p><p id="745b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您的应用程序被部署到生产环境中时，日志记录是必不可少的。没有记录，你就是盲目飞行。在上面的场景中，下一个合乎逻辑的事情是检查应用程序日志。其中必须记录一些错误，您可以使用这些信息来了解导致问题的原因。</p><p id="8619" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，仅仅记录应用程序中发生的事情是不够的。关于记录什么和如何记录，需要考虑一些因素。信息太多或太少都会使日志不可用。</p><p id="fe67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将了解日志记录的最佳实践，以及如何在Rust应用程序中实现它们。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d4ad" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">典型生产部署</h1><p id="5acb" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">最佳实践因为上下文而成为最佳实践。为了最佳实践是公认的最佳实践而应用它们是不明智的。理解应用程序如何部署以及日志将如何使用的背景很重要。</p><p id="1064" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的应用程序通常部署在多台机器上，通常是为了实现<a class="ae kv" href="https://www.digitalocean.com/community/tutorials/what-is-high-availability" rel="noopener ugc nofollow" target="_blank">高可用性</a>。负载平衡器通常放在它们前面，用于将请求分发到应用程序。当应用程序处理一个请求时，它通常会生成日志来告诉服务请求时发生了什么。除此之外，您的应用程序在系统中可能不是孤立的。在同一个系统中还部署了其他应用程序来满足不同的业务需求。其他应用程序也有自己的日志。</p><p id="93f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来自系统内所有应用程序的日志将被传输到一个集中的日志记录系统，例如<a class="ae kv" href="https://www.elastic.co/elastic-stack" rel="noopener ugc nofollow" target="_blank">弹性堆栈</a>。集中式日志记录系统有助于高效地读取从多个来源生成的日志。因此，您不需要登录到十个节点中的每一个节点并逐一查看那里的日志，而是登录到一个位置并在那里查找日志。效率更高，对吧？</p><p id="e957" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Elastic Stack使用的存储是<a class="ae kv" href="https://github.com/elastic/elasticsearch" rel="noopener ugc nofollow" target="_blank"> Elasticsearch </a>，一个开源的分布式搜索和分析引擎。这项技术允许您进行全文搜索，这使您能够更快地在日志中搜索特定的内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/ddc717a1d2cbd0906963956eba109fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nrvSU-gSn9zpfIrN1Yws8Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">典型的生产部署图，其中日志作为集中式日志记录解决方案导出到弹性堆栈</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="91ec" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">记录最佳实践</h1><p id="3bc0" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在我们已经了解了我们的应用程序运行的上下文以及如何使用日志，让我们来理解到底需要记录什么来使我们的日志有效。</p><p id="e2b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的片段是一个有效日志的例子。在接下来的几节中，我们将解构它，以理解是什么使它有效。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">有效日志的一个例子</p></figure><h2 id="f74c" class="mz ma iq bd mb na nb dn mf nc nd dp mj lf ne nf ml lj ng nh mn ln ni nj mp nk bi translated">一致且结构化的格式</h2><p id="e2c5" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">日志应该具有一致的结构化格式。有一个结构化的格式是有帮助的，因为它将很容易被机器阅读。该机器可以是弹性堆栈或简单的一行shell命令。结构化格式的一个用例是，当我们想要按特定字段(如用户ID)过滤日志时。</p><p id="c585" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结构化日志还需要保持一致。相同的信息应该存储在相同的字段名中。如果我们在一个日志中使用<code class="fe nl nm nn no b">uid</code>而在另一个日志中使用<code class="fe nl nm nn no b">user_id</code>来存储用户ID信息，将会造成混乱。过滤时，我们可能会错过一些日志，因为我们只查看了其中一个字段，而忘记了另一个字段。</p><h2 id="e264" class="mz ma iq bd mb na nb dn mf nc nd dp mj lf ne nf ml lj ng nh mn ln ni nj mp nk bi translated">不要记录敏感信息</h2><p id="772a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">日志通常被视为非敏感数据。让日志易于访问以帮助快速解决问题非常重要。对敏感数据的谨慎处理通常是不存在的。敏感信息的一些例子是密码和访问令牌。</p><h2 id="89f4" class="mz ma iq bd mb na nb dn mf nc nd dp mj lf ne nf ml lj ng nh mn ln ni nj mp nk bi translated">放更多的上下文</h2><p id="cd3c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">您的应用程序同时服务于多个请求。想象一下查看日志，看到下面几行:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="55e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那不会很有帮助，不是吗？你最终会有更多的问题:这是什么时候发生的？哪个请求或用户受此影响？没有上下文，日志将几乎毫无用处。</p><p id="6977" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果附加到您的日志中，以下是一些有用的上下文:</p><ol class=""><li id="4018" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated"><strong class="ky ir">时间<br/> </strong>这是一个显而易见的。没有关于时间的信息，您将不会知道记录的事件何时发生。时间信息是必不可少的，因为这使得集中式日志记录系统能够按时间顺序对来自多个源的日志进行排序。除此之外，您可以将时间与日志之外的其他事件关联起来(例如，“哦，在那个时间，我们有一个数据库问题，因此数据库读取失败”)。需要注意的一点是用RFC3339格式和UTC记录时间，因为这是大多数系统都理解的标准。</li><li id="3205" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><strong class="ky ir">严重性级别</strong> <br/>该信息可用于根据严重性快速查找日志。常用的级别有信息、警告和错误。对它们的含义没有严格的共识；但是，我将信息用于与业务相关的事件(例如，客户下了订单)，警告不紧急的问题(例如，与外部系统的连接暂时失败)，错误用于紧急的问题(例如，数据库关闭)。使用此信息的一个例子是过滤错误日志，以找到需要立即解决的紧迫问题。</li><li id="1948" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><strong class="ky ir">请求ID<br/>T5】也称为<em class="od">关联ID </em>或<em class="od">跟踪ID </em>。您的应用程序同时处理多个请求。一个请求可能会产生多个日志。通过在日志中包含这些信息，您可以通过过滤请求ID轻松地找到与一个请求相关的所有日志。</strong></li><li id="7a6d" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><strong class="ky ir">用户ID </strong> <br/>一个常见的日志用例是解决用户投诉。此信息有助于找到用户在系统中执行的所有操作。一旦您发现用户抱怨的特定操作或请求，那么您可以通过请求ID进行过滤，并最终查看在该特定请求中发生了什么。</li><li id="41db" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><strong class="ky ir">应用程序实例ID <br/> </strong>当应用程序被部署到多个节点时，您需要识别应用程序的哪个实例产生了这个日志。该信息可以从应用程序名称、应用程序版本、主机名和进程ID的组合中推断出来。在错误配置的节点上运行的应用程序实例可能会抛出许多错误。如果您手头有这些信息，您将能够识别出，嘿，原来所有的错误都来自特定的应用程序实例。您可能会猜测应用程序实例运行的环境有问题，而不是应用程序本身有问题。</li></ol></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="fc06" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">Rust应用中的日志记录</h1><p id="1e7a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在上一节中，我们已经学习了通过有效的日志来实现什么。在这一节中，我们将把遵循上述最佳实践的日志记录放到Rust应用程序中。我们要修改的应用程序是我为另一篇文章构建的认证模块。我们将在以下情况下写一些日志:</p><ol class=""><li id="fb2e" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">用户成功登录系统</li><li id="e704" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">用户无法登录系统</li><li id="6404" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">从数据库读取数据失败</li></ol><h2 id="878f" class="mz ma iq bd mb na nb dn mf nc nd dp mj lf ne nf ml lj ng nh mn ln ni nj mp nk bi translated">Rust日志库简介</h2><p id="d6ab" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">有很多库可以登录Rust。然而，我们将使用的是<code class="fe nl nm nn no b"><a class="ae kv" href="https://docs.rs/tracing/0.1.21/tracing/" rel="noopener ugc nofollow" target="_blank">tracing</a></code>。这个库的文档对理解如何使用它非常有帮助。我鼓励你读一读，因为我不会在这里详述图书馆。</p><p id="56c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">tracing</code>库的核心概念是<em class="od">跨度</em>、<em class="od">事件</em>、以及<em class="od">订阅者</em>。跨度代表事件发生的一段时间。一个平移可以嵌套在另一个跨度内。我们可以将数据作为跨度的上下文放入跨度中。与该跨度相关的事件将共享上下文。一个实际的例子是将请求ID放在范围的上下文中，并在该范围内产生各种事件。这样，事件可以使用请求ID关联在一起，因为它们共享相同的跨度。</p><p id="e248" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当发生事件或进入或退出跨度时，都会通知订阅者。然后，订阅者可以对这些通知做他们想做的任何事情。显然，主要的用例是将这些通知作为日志写在某个地方。<code class="fe nl nm nn no b">tracing</code>图书馆本身没有订户。这是为了让库作者可以使用<code class="fe nl nm nn no b">tracing</code>编写日志，同时让库用户决定如何处理日志。不用担心，基本用户可以作为另一个库使用，您只需要导入并使用它。</p><p id="d25d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了跟踪，我们还将使用这些库:</p><ol class=""><li id="6478" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated"><code class="fe nl nm nn no b"><a class="ae kv" href="https://crates.io/crates/tracing-appender" rel="noopener ugc nofollow" target="_blank">tracing-appender</a></code> <code class="fe nl nm nn no b"><br/></code>该库提供了一个进行非阻塞写入的订阅者。将日志写入stdout或文件是一个I/O操作。如果我们阻塞输入/输出操作，我们的CPU将闲置。通过将它作为非阻塞操作，我们的CPU可以做其他事情。这将导致更好的应用程序吞吐量。</li><li id="0cfc" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe nl nm nn no b"><a class="ae kv" href="https://crates.io/crates/tracing-futures" rel="noopener ugc nofollow" target="_blank">tracing-futures</a></code> <br/>该库提供与异步/等待的兼容性。</li><li id="8ce1" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe nl nm nn no b"><a class="ae kv" href="https://crates.io/crates/tracing-subscriber" rel="noopener ugc nofollow" target="_blank">tracing-subscriber</a></code> <br/>该库提供了一些构建订阅者的辅助功能。</li><li id="5148" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe nl nm nn no b"><a class="ae kv" href="https://docs.rs/tracing-actix-web/0.2.1/tracing_actix_web/" rel="noopener ugc nofollow" target="_blank">tracing-actix-web</a></code> <br/>这个库提供了与<a class="ae kv" href="https://github.com/actix/actix-web" rel="noopener ugc nofollow" target="_blank"> Actix web </a>的集成，Actix web是Rust中构建web服务器的领先库之一。这个库做的重要事情之一是为每个请求生成一个请求ID。</li><li id="0c26" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe nl nm nn no b"><a class="ae kv" href="https://crates.io/crates/tracing-bunyan-formatter" rel="noopener ugc nofollow" target="_blank">tracing-bunyan-formatter</a></code> <br/>该库根据<a class="ae kv" href="https://github.com/trentm/node-bunyan" rel="noopener ugc nofollow" target="_blank">班扬格式</a>将日志格式化为JSON。<code class="fe nl nm nn no b">tracing-subscriber</code>实际上能够将日志格式化为JSON。但是，我发现Bunyan格式更好，在Elastic Stack中更容易查询。</li><li id="08f3" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe nl nm nn no b"><a class="ae kv" href="https://crates.io/crates/tracing-log" rel="noopener ugc nofollow" target="_blank">tracing-log</a></code> <br/> <code class="fe nl nm nn no b">tracing</code>并不是唯一处理日志记录的库。Rust有自己的官方日志库，名为<code class="fe nl nm nn no b"><a class="ae kv" href="https://docs.rs/log/0.4.11/log/" rel="noopener ugc nofollow" target="_blank">log</a></code>。然而，它有一些限制，使得生成我们想要的日志很困难，因此我们不使用它。不过很多库都在用<code class="fe nl nm nn no b">log</code>。<code class="fe nl nm nn no b">tracing-log</code>允许将来自<code class="fe nl nm nn no b">log</code>的日志转发给<code class="fe nl nm nn no b">tracing</code>的订户。</li></ol><h2 id="e5fe" class="mz ma iq bd mb na nb dn mf nc nd dp mj lf ne nf ml lj ng nh mn ln ni nj mp nk bi translated">写日志</h2><p id="787a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在让我们开始实现。如果你没有读过我上面提到的另一篇文章，为了方便起见，我在这里写了一些重要的结构和特征。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="491f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们在<code class="fe nl nm nn no b">AuthServiceImpl</code>上实施如下测井:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4f57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于记录的重要部分在<code class="fe nl nm nn no b">login</code>功能的实现上。我们看到我们添加了<code class="fe nl nm nn no b">#[instrument(skip(self, credential), fields(username = %credential.username))]</code>。</p><ol class=""><li id="f1c7" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">创建一个新的span，将函数名(本例中为“login”)作为span名称。</li><li id="7f25" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">不要将<code class="fe nl nm nn no b">self</code>和<code class="fe nl nm nn no b">credential</code>参数放入span的上下文中。显然，我们不希望<code class="fe nl nm nn no b">credential</code>中的密码被记录。</li><li id="1c25" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">将值为<code class="fe nl nm nn no b">credential.username</code>的新字段<code class="fe nl nm nn no b">username</code>添加到span的上下文中。在这种情况下，我们将使用<code class="fe nl nm nn no b">username</code>作为用户ID。</li></ol><p id="ce86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们看到使用了<code class="fe nl nm nn no b">info!</code>和<code class="fe nl nm nn no b">error!</code>宏。它们所做的是分别产生带有信息和错误严重性级别的事件，并将给定的字符串作为日志消息。因为修饰这个函数的<code class="fe nl nm nn no b">#[instrument]</code>产生了一个跨度，这些宏产生的事件将与这个跨度相关。实际上，这意味着事件可以与跨度中的<code class="fe nl nm nn no b">username</code>字段相关联。这就是我们不把<code class="fe nl nm nn no b">username</code>放在日志消息中的原因。</p><p id="5f96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将日志放入<code class="fe nl nm nn no b">PostgresCredentialRepo</code>。我们主要想知道数据库查询何时因某种原因失败。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a159" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，我们这里也有<code class="fe nl nm nn no b">#[instrument]</code>和<code class="fe nl nm nn no b">error!</code>。注意我们如何通过使用<code class="fe nl nm nn no b">{}</code>并传递任何实现<code class="fe nl nm nn no b">Display</code>特征的类型来显示消息中的错误。</p><p id="a7dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们需要配置订户。如果没有订阅者，日志记录将什么也不做。我们要做的是用JSON格式打印到stdout。我们在<code class="fe nl nm nn no b">main.rs</code>中对此进行了配置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5f99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">main</code>功能从<code class="fe nl nm nn no b">LogTracer::init()</code>开始。这来自于<code class="fe nl nm nn no b">tracing-log</code>库。这个一行程序基本上将日志从<code class="fe nl nm nn no b">log</code>库重定向到<code class="fe nl nm nn no b">tracing</code>的订户。</p><p id="6936" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们设置订户。这是一个多步骤的过程。</p><p id="fed9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们设置<code class="fe nl nm nn no b">BunyanFormattingLayer</code>。这张来自<code class="fe nl nm nn no b">tracing-bunyan-formatter</code>图书馆。它需要应用程序名称和编写器。对于app名称，我们通过结合<code class="fe nl nm nn no b">Cargo.toml</code>中定义的包名和包版本来构建。对于编写器，我们使用<code class="fe nl nm nn no b">tracing_appener::non_blocking</code>函数设置了一个非阻塞的stdout编写器。这个函数来自<code class="fe nl nm nn no b">tracing-appender</code>库。</p><p id="2505" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后通过创建<code class="fe nl nm nn no b">Registry</code>(从<code class="fe nl nm nn no b">tracing-subscriber</code>库中)来创建订户。我们在这个注册表中注册了多层功能。首先，我们创建一个<code class="fe nl nm nn no b">EnvFilter</code>。这一层的目的是过滤掉严重级别低于INFO的日志。在下一层，我们添加了刚刚设置好的<code class="fe nl nm nn no b">JsonStorageLayer</code>和<code class="fe nl nm nn no b">bunyan_formatting_layer</code>。这两层使得日志能够被写成JSON。</p><p id="3821" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，全局默认订户被设置为我们刚刚创建的订户。设置好订阅者后，我们将能够看到日志以JSON格式输出到stdout。</p><p id="a8e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外很重要的一点是<code class="fe nl nm nn no b">TracingLogger</code>的使用。这来自于<code class="fe nl nm nn no b">tracing-actix-web</code>。它支持请求ID生成和日志记录，以及附带的其他有用的东西。</p><h2 id="4c09" class="mz ma iq bd mb na nb dn mf nc nd dp mj lf ne nf ml lj ng nh mn ln ni nj mp nk bi translated">查看运行中的日志</h2><p id="4340" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当我们运行应用程序并发送登录请求时，我们会看到以下日志(格式便于人们阅读):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ee04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似地，当我们有目的地关闭mySQL数据库并发送登录请求时，我们将获得以下日志:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0007" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">提示:</strong>如果您发现上面的日志过于冗长，因为它记录了进入和退出span的情况，您可以将span严重性级别配置为DEBUG，如下所示:</p><pre class="kg kh ki kj gt oe no of og aw oh bi"><span id="1fe8" class="mz ma iq no b gy oi oj l ok ol">#[instrument(level = "debug")]</span></pre><p id="1dcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们已经配置为过滤掉低于INFO的日志，所以不会打印这些日志。</p><p id="52aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们仔细检查这些日志是否符合上述最佳实践:</p><ol class=""><li id="7702" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">✅ <strong class="ky ir">一致的结构化格式</strong> <br/>我们使用JSON并且字段名是一致的。</li><li id="31ce" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">✅ <strong class="ky ir">不记录敏感信息</strong> <br/>我们不记录密码和令牌。</li><li id="d212" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">在<code class="fe nl nm nn no b">time</code>字段中找到✅ <strong class="ky ir">时间信息</strong> <br/>。</li><li id="f18c" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">在<code class="fe nl nm nn no b">level</code>字段中发现✅ <strong class="ky ir">严重级别</strong> <br/>，尽管它被翻译成数字而不是信息、错误等。</li><li id="f512" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">在<code class="fe nl nm nn no b">request_id</code>字段中找到的✅ <strong class="ky ir">请求ID </strong> <br/>对于每个请求都是唯一的。</li><li id="777d" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">在<code class="fe nl nm nn no b">username</code>字段中找到✅ <strong class="ky ir">用户ID </strong>和<br/>。在这种情况下，我们使用<code class="fe nl nm nn no b">username</code>作为用户标识符。</li><li id="6b85" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">✅ <strong class="ky ir">申请ID </strong> <br/>是<code class="fe nl nm nn no b">name</code>、<code class="fe nl nm nn no b">hostname</code>和<code class="fe nl nm nn no b">pid</code>的组合。</li></ol></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f336" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="01d4" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在本文中，我们已经了解了日志的重要性，什么是好的日志，以及如何在Rust应用程序中实现它。</p><p id="052f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">日志对于理解生产应用程序中发生的事情和解决问题非常重要。仅仅记录是不够的。日志需要一致、结构化，并填充有用的上下文。没有这些品质，原木几乎毫无用处。Rust的生态系统在这一领域相当成熟，因为我们有好的、有竞争力的日志库，可以用来实现我们想要的那种日志记录。</p><p id="e2cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这篇文章对你有用。你有什么让登录生产更好的小技巧？</p></div></div>    
</body>
</html>