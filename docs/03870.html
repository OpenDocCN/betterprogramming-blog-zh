<html>
<head>
<title>6 Easy React Tricks That May Surprise You</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6个让你吃惊的简单反应技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-easy-react-tricks-that-may-surprise-you-822f5be43520?source=collection_archive---------5-----------------------#2020-03-10">https://betterprogramming.pub/6-easy-react-tricks-that-may-surprise-you-822f5be43520?source=collection_archive---------5-----------------------#2020-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b905" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">带有片段的键、作为HTML元素的字符串等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cca8b915e1d9d77f5d6b2c6981dfd1d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d0v6pC5ijXN2Uy8l"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@baher366?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Baher Khairy </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="feab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大部分时间我和React一起工作。随着时间的推移，我遇到了一些我以前从未想过的简单事情，这让我真正“啊哈！”时刻。我也注意到许多和我一起工作的人并没有意识到这些小技巧——可以让他们开心的简单事情！</p><p id="f606" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面所有的例子都是围绕功能组件和钩子构建的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fe09" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用碎片反应键</h1><p id="276b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时你需要在列表中呈现多个组件。如果不需要容器，使用React Fragment。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="2b35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码是完全合法的，但React将开始抱怨键:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="61a2" class="ng md it nc b gy nh ni l nj nk">Warning: Each child in a list should have a unique "key" prop.</span></pre><p id="90ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你看到了错误，然后说“是啊，管它呢。”然后你用一个<code class="fe nl nm nn nc b">div</code>替换这个片段。</p><p id="4d18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，你的思路是正确的——你只是错过了一个你可能没有想到的棘手问题。你<em class="no">可以</em>使用带有React Fragment的键，但是不能使用上面看到的语法。您必须用<code class="fe nl nm nn nc b">&lt;React.Fragment&gt;</code>改变语法，然后就可以开始了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4850" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">HTML元素形式的字符串值</h1><p id="ffc0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时你想创建一个组件，它可以是一个灵活的HTML元素。或者你可能已经看过来自CSS-in-JS库中的<code class="fe nl nm nn nc b">as</code> prop，比如<code class="fe nl nm nn nc b">emotion</code>。</p><p id="4ff1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您想要创建一个可以呈现为<code class="fe nl nm nn nc b">button</code>或<code class="fe nl nm nn nc b">a</code>的<code class="fe nl nm nn nc b">&lt;Button&gt;</code>组件。有哪些选择？你可以抽象样式，用它创建两个不同的组件，或者你可以只创建一个组件，用<code class="fe nl nm nn nc b">React.createElement</code>和<code class="fe nl nm nn nc b">as</code>属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ea26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于一个简单的组件来说很好，但是如果有另一种看起来感觉更好的方式呢？这是JSX的诀窍:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5b81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，你可以在JSX使用一个字符串作为组件——只要确保字符串组件名称以大写字母开头。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="56f1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将函数传递给setState</h1><p id="7ac2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nl nm nn nc b">useState</code>和<code class="fe nl nm nn nc b">useEffect</code>大概是使用频率最高的钩子了。您需要将您的依赖项传递给<code class="fe nl nm nn nc b">useEffect</code>，或者预期一些错误或不想要的效果，但是，如果您的依赖项只是一个与相对<code class="fe nl nm nn nc b">setState</code>一起使用的状态，也许您不需要传递它。先来看不太好的版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9bac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个简单的方法可以摆脱这种情况:使用功能更新形式的<code class="fe nl nm nn nc b">setState</code>，就像这样:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="63a5" class="ng md it nc b gy nh ni l nj nk">const [count, setCount] = useState(0)</span><span id="cab3" class="ng md it nc b gy np ni l nj nk">setCount(c =&gt; c + 1)</span></pre><p id="068e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是更新后的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5680" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用useReducer实现useState</h1><p id="4a27" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是我在推特上听说的一个有趣的小把戏。虽然没有真正的好处，但了解一下<code class="fe nl nm nn nc b">useReducer</code>的能力还是有好处的。</p><p id="25d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你直接从<code class="fe nl nm nn nc b">useReducer</code>返回动作，那么它的行为几乎和<code class="fe nl nm nn nc b">useState</code>一样。所以你可以争辩说<code class="fe nl nm nn nc b">useState</code>没有必要。下面是推文:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq na l"/></div></figure><p id="db7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是您可以复制粘贴并试用的代码:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="0534" class="ng md it nc b gy nh ni l nj nk">const [name, setName] = useReducer((_, value) =&gt; value, 'James');</span><span id="f61e" class="ng md it nc b gy np ni l nj nk">&lt;input value={name} onChange={e =&gt; setName(e.target.value)} /&gt;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="32b3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">手动重新渲染组件</h1><p id="9e4b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您是否曾经需要手动重新渲染组件？例如，你需要重新渲染一个组件，但是没有状态或者任何你可以触摸的东西。比方说，出于某种奇怪的原因，你想在一个按钮被点击时这样做。</p><p id="d896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以这样做:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="e89f" class="ng md it nc b gy nh ni l nj nk">const [, rerender] = useState()</span><span id="e68e" class="ng md it nc b gy np ni l nj nk">rerender({})</span></pre><p id="5c45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！你使用<code class="fe nl nm nn nc b">useState</code>但是你实际上并不需要状态本身。你只需要<code class="fe nl nm nn nc b">setState</code>函数或者<code class="fe nl nm nn nc b">rerender</code>函数来重新渲染。重要的是，每次它像一个空对象或数组一样运行时，你都需要传递一个新值。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="64a9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如果没有直接的属性/状态依赖，将对象或函数移出组件</h1><p id="3cc8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我经常看到这个错误。为了描述，首先，让我们看一下代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个想法很好——比<code class="fe nl nm nn nc b">if/else</code>或<code class="fe nl nm nn nc b">switch</code>案例好得多。但是有一个问题。每次这个组件被重新渲染，一个新的<code class="fe nl nm nn nc b">cardProps</code>对象被创建。即使没有任何变化，它也会导致所有依赖组件的重新渲染。</p><p id="4e36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我看到使用了<code class="fe nl nm nn nc b">useMemo</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn nc b">useMemo</code>解决了问题，但一切都有代价。如果您仔细查看代码，您会发现没有理由将<code class="fe nl nm nn nc b">cardProps</code>对象放入组件中。自然，也不需要<code class="fe nl nm nn nc b">useMemo</code>开销，因为该对象不直接依赖于任何道具或状态。即使它来自外部，您仍然可以使用<code class="fe nl nm nn nc b">...cardProps[types]</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5fd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见——不需要挂钩。如果不需要把东西放在里面，就把它们搬到外面去，功能也是一样。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c81c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="c182" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">每当你认为你已经学得足够多的时候，你会发现令你惊讶的事情——学习是没有止境的。</p><p id="1734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，继续学习，惊喜吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8b86" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">推荐故事</h1><div class="nr ns gp gr nt nu"><a href="https://medium.com/better-programming/should-you-use-recoil-as-a-react-state-management-library-38ef14f3de10" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">你应该使用反冲作为一个反应状态管理库吗？</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">看一看脸书开发的新的反应状态管理库</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">medium.com</p></div></div><div class="od l"><div class="oe l of og oh od oi ks nu"/></div></div></a></div><div class="nr ns gp gr nt nu"><a href="https://medium.com/better-programming/using-css-modules-with-react-in-2020-73c2223f495c" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">将CSS模块与React一起使用</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">有时候纯CSS是更好的选择</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">medium.com</p></div></div><div class="od l"><div class="oj l of og oh od oi ks nu"/></div></div></a></div><div class="nr ns gp gr nt nu"><a href="https://medium.com/better-programming/master-usestate-in-imperative-and-declarative-ways-e298f6d9c352" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">以命令和声明的方式掌握使用状态</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">了解如何以多种方式使用useState来获得最佳结果</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">medium.com</p></div></div><div class="od l"><div class="ok l of og oh od oi ks nu"/></div></div></a></div></div></div>    
</body>
</html>