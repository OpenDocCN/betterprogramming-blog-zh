<html>
<head>
<title>How to Change Your App’s Icon in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在SwiftUI中更改您的应用程序图标</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-change-your-apps-icon-in-swiftui-1f2ff3c44344?source=collection_archive---------9-----------------------#2020-01-31">https://betterprogramming.pub/how-to-change-your-apps-icon-in-swiftui-1f2ff3c44344?source=collection_archive---------9-----------------------#2020-01-31</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="0a23" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">让您的用户以编程方式设置替代图标</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/1fb6c62bff80958f9dbe98367cb4ffd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UHqqq8Ulm7qDoBnYXr6W6w.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://www.flickr.com/photos/williamhook/" rel="noopener ugc nofollow" target="_blank">威廉·胡克</a>在<a class="ae kz" href="https://www.flickr.com/photos/williamhook/38109880456" rel="noopener ugc nofollow" target="_blank"> Flickr </a>上拍摄</p></figure><p id="d364" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以编程方式改变应用程序图标的功能已经存在好几年了。具体来说，这项功能是在iOS 10.3中发布的，它允许开发人员在一组预定义的备用图标之间切换。</p><p id="cacb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当您的应用程序基于订阅时，动态图标非常有用。Tinder是一个很好地利用这一功能的应用程序，因为它给Tinder Gold会员提供了一个切换图标的选项。</p><h2 id="77f7" class="lw lx iu bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated">我们的目标</h2><ul class=""><li id="408e" class="mp mq iu lc b ld mr lg ms lj mt ln mu lr mv lv mw mx my mz bi translated">在本文中，我们将向您展示如何使用SwiftUI以编程方式更改您的应用程序图标</li><li id="9b77" class="mp mq iu lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">我们将利用SwiftUI <code class="fe nf ng nh ni b">Picker</code> s来允许用户从菜单列表中选择他们最喜欢的图标。</li><li id="53fb" class="mp mq iu lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">最后，我们将解决一个严重的陷阱。<code class="fe nf ng nh ni b">Picker</code> s和<code class="fe nf ng nh ni b">NavigationView</code>目前没有按照我们希望的方式相处——我们会看到原因。</li></ul></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><h1 id="98ef" class="nq lx iu bd ly nr ns nt mb nu nv nw me ka nx kb mh kd ny ke mk kg nz kh mn oa bi translated">以编程方式设置备用应用程序图标</h1><p id="00db" class="pw-post-body-paragraph la lb iu lc b ld mr jv lf lg ms jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">设置替代图标的代码并没有那么大。几乎算不上一句台词。这是需要一点时间的设置。</p><h2 id="2883" class="lw lx iu bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated">获取备选应用程序图标</h2><p id="17ed" class="pw-post-body-paragraph la lb iu lc b ld mr jv lf lg ms jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">下面一行代码返回一个可选字符串，代表当前应用程序图标的键名。如果正在使用默认的应用程序图标，它将返回<code class="fe nf ng nh ni b">nil</code>:</p><pre class="kk kl km kn gu oe ni of og aw oh bi"><span id="aed1" class="lw lx iu ni b gz oi oj l ok ol">UIApplication<strong class="ni iv">.</strong>shared<strong class="ni iv">.</strong>alternateIconName</span></pre><h2 id="0bd7" class="lw lx iu bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated">设置备用图标</h2><p id="116a" class="pw-post-body-paragraph la lb iu lc b ld mr jv lf lg ms jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">要设置替代图标，只需在下面的函数中传递图标的名称。处理完成处理程序来检查错误是一个很好的实践。</p><pre class="kk kl km kn gu oe ni of og aw oh bi"><span id="0d8b" class="lw lx iu ni b gz oi oj l ok ol">UIApplication.shared.setAlternateIconName(<strong class="ni iv">iconName</strong>, completionHandler: {error in})</span></pre><p id="59f2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是我们在哪里设置图标名称呢？<em class="om"> </em>我们一会儿再回到这个话题。</p><p id="ae2b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是在应用程序中使用替代图标时需要遵循的规则:</p><h2 id="44db" class="lw lx iu bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated">1.不要在资产目录中添加替代图标</h2><p id="4b77" class="pw-post-body-paragraph la lb iu lc b ld mr jv lf lg ms jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">创建一个单独的组来保存所有备用图标(包括2x和3x文件)是至关重要的。</p><h2 id="caca" class="lw lx iu bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated">2.小心处理Info.plist文件</h2><p id="f9e2" class="pw-post-body-paragraph la lb iu lc b ld mr jv lf lg ms jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">在<code class="fe nf ng nh ni b">Info.plist</code>文件中，你需要为备用图标(和主图标)建立字典。由于字典是嵌套的，我发现编辑原始XML格式的<code class="fe nf ng nh ni b">Info.plist</code>比编辑那些按钮容易得多。</p><p id="f343" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面的代码片段显示了<code class="fe nf ng nh ni b">CFBundleIcons</code>键的字典结构。将它添加到您看到的XML字典的顶层。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="on oo l"/></div></figure><p id="2da4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一开始看起来可能有点吓人，但这很简单。<code class="fe nf ng nh ni b">CFBundleIcons</code>容纳两个字典:</p><ul class=""><li id="15f7" class="mp mq iu lc b ld le lg lh lj op ln oq lr or lv mw mx my mz bi translated"><code class="fe nf ng nh ni b">CFBundlePrimaryIcon</code>对于资产目录中的主要图标</li><li id="9ef3" class="mp mq iu lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><code class="fe nf ng nh ni b">CFBundleAlternateIcons</code>用于保存备用图标。<code class="fe nf ng nh ni b">CFBundleAlternateIcons</code>中的键代表您将在代码中使用的名称。这个名字取代了我们之前看到的<code class="fe nf ng nh ni b">iconName</code>。</li><li id="aad1" class="mp mq iu lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">在<code class="fe nf ng nh ni b">CFBundleIconFiles</code>中，我们传递图标文件名——没有扩展名，也没有2x和3x变体。只有名字。</li><li id="dba2" class="mp mq iu lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><code class="fe nf ng nh ni b">UIPrerenderedIcon</code> <strong class="lc iv"> </strong>是表示光泽效果的布尔键。将此项设置为<code class="fe nf ng nh ni b">false</code>，让系统在您的图标上添加闪亮效果。</li></ul></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><h1 id="d265" class="nq lx iu bd ly nr ns nt mb nu nv nw me ka nx kb mh kd ny ke mk kg nz kh mn oa bi translated">项目结构</h1><p id="5353" class="pw-post-body-paragraph la lb iu lc b ld mr jv lf lg ms jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">现在我们都准备好了，让我们看看项目结构。我们在应用目标的<code class="fe nf ng nh ni b">Icons</code>群组文件夹中添加了三种图标。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj os"><img src="../Images/bd5d177b2d30570153af348b99129b9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iB2kS1EO3zSOlSIagEg9vA.png"/></div></div></figure></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><h1 id="0692" class="nq lx iu bd ly nr ns nt mb nu nv nw me ka nx kb mh kd ny ke mk kg nz kh mn oa bi translated">解码替代图标字典</h1><p id="f832" class="pw-post-body-paragraph la lb iu lc b ld mr jv lf lg ms jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">我们的想法是获取所有可选图标的键名，并将它们设置在一个数组中。下面的函数就是通过解码<code class="fe nf ng nh ni b">Info.plist</code>来实现的。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="on oo l"/></div></figure><p id="9b3d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nf ng nh ni b">iconNames</code>是在下面的<code class="fe nf ng nh ni b">ObservableObject</code>类中定义的字符串数组，在<code class="fe nf ng nh ni b">init</code>方法中调用<code class="fe nf ng nh ni b">getAlternateIconNames</code>函数:</p><pre class="kk kl km kn gu oe ni of og aw oh bi"><span id="502d" class="lw lx iu ni b gz oi oj l ok ol">class IconNames: ObservableObject {<br/>    var iconNames: [String?] = [nil]<br/>    @Published var currentIndex = 0<br/>    <br/>    init() {<br/>        <strong class="ni iv">getAlternateIconNames()</strong><br/>        <br/>        if let currentIcon = UIApplication.shared.alternateIconName{<br/>            self.currentIndex = iconNames.firstIndex(of: currentIcon) ?? 0<br/>        }</span><span id="bcd3" class="lw lx iu ni b gz ot oj l ok ol">}</span></pre><ul class=""><li id="b025" class="mp mq iu lc b ld le lg lh lj op ln oq lr or lv mw mx my mz bi translated">在上面的代码中，<code class="fe nf ng nh ni b">iconNames</code>数组的第一个元素被设置为<code class="fe nf ng nh ni b">nil</code>，作为主应用程序图标的指示器。</li><li id="cb32" class="mp mq iu lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">活动图标的索引被设置为<code class="fe nf ng nh ni b">@Published</code>属性包装。它由当前活动的图标初始化。</li></ul><p id="5c56" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将通过SwiftUI <code class="fe nf ng nh ni b">ContentView</code>到<code class="fe nf ng nh ni b">@EnvironmentObject</code>共享上面的数据模型，它从<code class="fe nf ng nh ni b">SceneDelegate</code>传递到视图层次结构。</p><pre class="kk kl km kn gu oe ni of og aw oh bi"><span id="7351" class="lw lx iu ni b gz oi oj l ok ol">window.rootViewController = UIHostingController(rootView: contentView.environmentObject(<strong class="ni iv">IconNames</strong>()))</span></pre></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><h1 id="9072" class="nq lx iu bd ly nr ns nt mb nu nv nw me ka nx kb mh kd ny ke mk kg nz kh mn oa bi translated">在ContentView中设置SwiftUI选择器</h1><p id="8880" class="pw-post-body-paragraph la lb iu lc b ld mr jv lf lg ms jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">在下面的代码中，我们用来自<code class="fe nf ng nh ni b">EnvironmentObject</code>属性包装器实例的图标名填充SwiftUI <code class="fe nf ng nh ni b">Picker</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="on oo l"/></div></figure><ul class=""><li id="f91e" class="mp mq iu lc b ld le lg lh lj op ln oq lr or lv mw mx my mz bi translated">每当<code class="fe nf ng nh ni b">Picker</code>的选择改变时，就会触发<code class="fe nf ng nh ni b">onReceive</code>修改器。它发布它得到的最新值(所选图标的索引)。</li><li id="b32e" class="mp mq iu lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">在闭包内部，我们将新选择的图标名称与当前活动的应用程序图标名称进行比较。这是至关重要的一步，因为只有当用户选择不同的图标时，它才会触发图标变化。</li></ul><p id="3771" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面看一下我们的应用程序:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ou"><img src="../Images/f4df9b709910e2858aae49eccb16d337.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/1*1X52xPTWO3OzB9KSlZKOyQ.gif"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">输出</p></figure><p id="017b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如我们在上面看到的，当替代图标被成功更改时，系统会发送一个警报。因此，一旦视图被设置，从主线程调用<code class="fe nf ng nh ni b">setAlternateIconName</code>是很重要的。</p><p id="9f3e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，让我们看看如何在SwiftUI视图中设置替代图标，并解决当<code class="fe nf ng nh ni b">Picker</code>和<code class="fe nf ng nh ni b">NavigationView</code>一起操作时的问题。</p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><h1 id="7d30" class="nq lx iu bd ly nr ns nt mb nu nv nw me ka nx kb mh kd ny ke mk kg nz kh mn oa bi translated">SwiftUI选择器和导航视图缺陷</h1><p id="d01c" class="pw-post-body-paragraph la lb iu lc b ld mr jv lf lg ms jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">虽然上面的SwiftUI应用程序在管理状态方面做得很好，但是在使用NavigationView和Pickers时还是有一些缺陷。不小心处理这些案件可能会困扰你以后。</p><h2 id="4beb" class="lw lx iu bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated">陷阱1</h2><p id="4304" class="pw-post-body-paragraph la lb iu lc b ld mr jv lf lg ms jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">以下屏幕截图将备选图标添加到Pickers下的SwiftUI图像中，并且由于<code class="fe nf ng nh ni b">NavigationView</code>它们被屏蔽:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ov"><img src="../Images/61b4ff84be15735d27f35b8955097ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Jt1BIZZfGJMvYDTAX3phBw.gif"/></div></div></figure><p id="f194" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们可以通过在NavigationView上设置一个按钮样式来解决覆盖问题，如<a class="ae kz" href="https://medium.com/better-programming/swiftui-navigation-links-and-the-common-pitfalls-faced-505cbfd8029b" rel="noopener">这个片段</a>所示。但随后，我们失去了SwiftUI <code class="fe nf ng nh ni b">Picker</code>的选择指标:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ov"><img src="../Images/759f030f013aedaa4b9437c7fe680fbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lZcT6tOipdEgeFM5UAllIQ.gif"/></div></div></figure><h2 id="f3a8" class="lw lx iu bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated"><strong class="ak">补救措施</strong></h2><p id="61c3" class="pw-post-body-paragraph la lb iu lc b ld mr jv lf lg ms jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated"><strong class="lc iv">将</strong> <code class="fe nf ng nh ni b"><strong class="lc iv">renderingMode</strong></code> <strong class="lc iv">设置为</strong> <code class="fe nf ng nh ni b"><strong class="lc iv">Image</strong></code> <strong class="lc iv"> <br/> </strong>上的原件通过将<code class="fe nf ng nh ni b">renderingMode</code>设置为原件，叠加被隐藏，拾取器选择可见，我们不需要为NavigationView设置<code class="fe nf ng nh ni b">buttonStyle</code>。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ov"><img src="../Images/95448c817e8173dad7a73ca83a104b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*AaYNyOLm2Dhqk1_oKtmRTg.gif"/></div></div></figure><p id="35a2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，我们最终让我们的应用程序使用显示在SwiftUI选择器中的替代图标。</p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><h2 id="2cbd" class="lw lx iu bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated"><strong class="ak">陷阱二</strong></h2><p id="13c7" class="pw-post-body-paragraph la lb iu lc b ld mr jv lf lg ms jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">此外，还有另一种情况，SwiftUI <code class="fe nf ng nh ni b">Picker</code>和<code class="fe nf ng nh ni b">NavigationView</code>目前不能按预期工作。将<code class="fe nf ng nh ni b">NavigationView</code>的样式设置为<code class="fe nf ng nh ni b">automatic</code>或更大将导致<code class="fe nf ng nh ni b">Picker</code>在导航期间重新定位一次，从而在UI中显示抖动。</p><h2 id="7e79" class="lw lx iu bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated">治疗</h2><p id="5681" class="pw-post-body-paragraph la lb iu lc b ld mr jv lf lg ms jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">目前，唯一的解决方法是将NavigationView的<code class="fe nf ng nh ni b">displayMode</code>设置为inline。更多详细信息，请参考<a class="ae kz" href="https://stackoverflow.com/questions/58773687/why-is-swiftui-picker-in-form-repositioning-after-navigation" rel="noopener ugc nofollow" target="_blank">该堆栈溢出帖子</a>。</p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><h1 id="8965" class="nq lx iu bd ly nr ns nt mb nu nv nw me ka nx kb mh kd ny ke mk kg nz kh mn oa bi translated">结论</h1><p id="5413" class="pw-post-body-paragraph la lb iu lc b ld mr jv lf lg ms jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">我们看到了如何使用SwiftUI <code class="fe nf ng nh ni b">Picker</code>菜单以编程方式设置应用程序的图标。</p><p id="1c5b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，我们解决了在SwiftUI中使用<code class="fe nf ng nh ni b">NavigationView</code>和<code class="fe nf ng nh ni b">Pickers</code>时的两个常见陷阱。这些问题导致子视图中出现叠加颜色，并寻找解决方法。</p><p id="5e94" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这篇文章的完整源代码可以在这个<a class="ae kz" href="https://github.com/anupamchugh/iowncode/tree/master/SwiftUIAlternateIcons" rel="noopener ugc nofollow" target="_blank"> Github库</a>中找到。</p><p id="0b93" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一篇就到此为止——感谢阅读。</p></div></div>    
</body>
</html>