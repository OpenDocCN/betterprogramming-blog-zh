<html>
<head>
<title>Useful New Features in ES2016 and 2017</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2016和2017中有用的新功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/useful-new-features-in-es2016-and-2017-3df7b29cc503?source=collection_archive---------11-----------------------#2019-11-19">https://betterprogramming.pub/useful-new-features-in-es2016-and-2017-3df7b29cc503?source=collection_archive---------11-----------------------#2019-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0de6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们看看新的字符串和对象方法以及异步和等待</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b4c188acefa6f24865cbe1f9ce70b59c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Wok_wLIfnyhPkxHK"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@tormius?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Adri Tormo </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0540" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ES2015引入了许多功能，如箭头函数、对象创建和继承的类语法、<code class="fe lv lw lx ly b">let</code>和<code class="fe lv lw lx ly b">const</code>以及许多其他新功能。在接下来的几年里，该语言和标准库中将会引入更多的优秀特性。ES2016是一个具有新功能的小版本，例如将<code class="fe lv lw lx ly b">includes</code>函数引入数组和指数运算符。ES2017引入了更多功能，如<code class="fe lv lw lx ly b">Object.values</code>和<code class="fe lv lw lx ly b">Object.entries</code>，以及字符串功能，如<code class="fe lv lw lx ly b">padStart</code>和<code class="fe lv lw lx ly b">padEnd</code>，以及<code class="fe lv lw lx ly b">async</code>和<code class="fe lv lw lx ly b">await</code>。这些便利的特性给JavaScript开发人员带来了更多的便利，使得JavaScript应用程序的开发更加容易。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f00a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">ES2016特性</h1><h2 id="a974" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">数组.包含</h2><p id="5e59" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><code class="fe lv lw lx ly b">Array.includes</code>检查数组中是否存在项目。它接受一个数字或字符串，函数可以将它作为第一个参数进行比较，并将要搜索的索引作为第二个参数。第二个参数可以是正的，也可以是负的。</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="e2df" class="my mh it ly b gy nt nu l nv nw">const array = [1,2,3];<br/>const includesTwo = array.includes(2); // returns true</span></pre><p id="fa0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以从负索引开始搜索数组，然后从计算的索引开始函数搜索，计算的索引是数组的长度加上第二个参数。所以如果我们写:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="7d54" class="my mh it ly b gy nt nu l nv nw">array.includes(2, -2);</span></pre><p id="5c0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后<code class="fe lv lw lx ly b">includes</code>函数将从索引<code class="fe lv lw lx ly b">3 +(-2).</code>开始搜索，这意味着<code class="fe lv lw lx ly b">array.includes(2, -2);</code>将返回<code class="fe lv lw lx ly b">true</code>。如果传入的绝对数量大于长度，那么就搜索整个数组。</p><p id="73a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">includes</code>功能也被添加到TypedArray类型中，如<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array" rel="noopener ugc nofollow" target="_blank">Int8Array</a></code>或<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" rel="noopener ugc nofollow" target="_blank">Uint8Array</a></code>。</p><h2 id="2a0f" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">指数算子</h2><p id="96c3" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">指数运算符是ES2016的另一项新功能。指数运算符用<code class="fe lv lw lx ly b">**</code>表示。这是计算指数值的新语法，是<code class="fe lv lw lx ly b">Math.pow</code>函数的替代。例如，要计算2的3次方，我们可以写:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="aaa4" class="my mh it ly b gy nt nu l nv nw">2**3</span></pre><p id="42a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是8。注意，在JavaScript中，当我们将指数运算符和一元运算符如<code class="fe lv lw lx ly b">-</code>组合在一起时，不可能编写出模糊的表达式，所以像<code class="fe lv lw lx ly b">-2**2</code>这样的东西在JavaScript中是无效的。然而，<code class="fe lv lw lx ly b">-(2**2)</code>是有效的，因为它是明确的，因为我们知道值是-4，因为指数在括号内，负号在外面。</p><p id="4eaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过编写以下内容来强制幂运算表达式的基数为负数:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="4fa3" class="my mh it ly b gy nt nu l nv nw">(-2)**2</span></pre><p id="82f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这意味着<code class="fe lv lw lx ly b">base</code>必须在括号中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9218" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">ES2017功能</h1><h2 id="82b9" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">对象.值</h2><p id="5bff" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object.values</code>让我们获得一个数组，数组中有一个对象的值。除了<code class="fe lv lw lx ly b">Object.values</code>不返回原型链中的值之外，这些值的返回顺序与<code class="fe lv lw lx ly b">for...in</code>循环提供的顺序相同。</p><p id="60d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="a8bb" class="my mh it ly b gy nt nu l nv nw">const obj = { a: 1, b: 2 };<br/>console.log(Object.values(obj)); // [1, 2]<br/><br/>const obj = { 0: 'd', 1: 'e', 2: 'f' };<br/>console.log(Object.values(obj)); // ['d', 'e', 'f']<br/><br/>const obj2 = { 100: 'd', 2: 'e', 7: 'f' };<br/>console.log(Object.values(obj2)); // ['e', 'f', 'd']<br/><br/>console.log(Object.values('abc')); // ['a', 'b', 'c']</span></pre><p id="dcc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，<code class="fe lv lw lx ly b">Object.values</code>处理对象和字符串。如果键是数字，那么它们以升序返回，就像上面的<code class="fe lv lw lx ly b">obj2</code>例子一样。对于字符串，它返回字符串的单个字符的数组。</p><h2 id="9212" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated"><strong class="ak"> Object.entries() </strong></h2><p id="438a" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object.entries</code>函数返回一个数组，每个条目都是各自数组中的键值对。条目的返回顺序与<code class="fe lv lw lx ly b">for...in</code>循环提供的顺序相同，只是<code class="fe lv lw lx ly b">Object.values</code>不返回原型链中的值。与任何对象一样，我们可以使用<code class="fe lv lw lx ly b">sort</code>函数对数组进行排序，以获得我们想要的条目顺序。</p><p id="4c6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="9b64" class="my mh it ly b gy nt nu l nv nw">const obj = { foo: 1, bar: 2 };<br/>console.log(Object.entries(obj)); // [ ['foo', 1], ['bar', 2] ]<br/><br/>const obj = { 0: 'x', 1: 'y', 2: 'z' };<br/>console.log(Object.entries(obj)); // [ ['0', 'x'], ['1', 'y'], ['2', 'z'] ]<br/><br/>const obj2 = { 100: 'x', 2: 'y', 7: 'z' };<br/>console.log(Object.entries(obj2)); // [ ['2', 'x'], ['7', 'y'], ['100', 'z'] ]<br/><br/>console.log(Object.entries('abc')); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]<br/><br/>console.log(Object.entries(100)); // [ ]<br/><br/>const obj = { a: 1, b: 2, c: 3};<br/>for (const [key, value] of Object.entries(obj)) {<br/>  console.log(`${key} ${value}`); // "a 1", "b 2", "c 3"<br/>}<br/><br/>Object.entries(obj).forEach(([key, value]) =&gt; {<br/>  console.log(`${key} ${value}`); // "a 1", "b 2", "c 3"<br/>});</span></pre><p id="ffd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们可以看到<code class="fe lv lw lx ly b">Object.entries</code>返回一个键-值对的数组，每个条目作为一个数组，键是第一个元素，值是第二个元素。如果键是整数，那么它们按数字升序排序。所以<code class="fe lv lw lx ly b">Object.entries(obj2)</code>返回<code class="fe lv lw lx ly b">[ ['2', 'x'], ['7', 'y'], ['100', 'z'] ]</code>。它还可以处理字符串，以字符的索引作为键返回单个字符，因此键是字符串的索引，它是每个条目的第一个元素，单个字符是字符串的值，它作为第二个字符返回。对于没有属性的对象，比如数字和布尔值，<code class="fe lv lw lx ly b">Object.entries</code>返回一个空数组。</p><p id="9be7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object.entries</code>返回的数组可以转换成<code class="fe lv lw lx ly b">Map</code>对象。它可以像下面的例子一样使用:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="2c74" class="my mh it ly b gy nt nu l nv nw">const obj = { a: 1, b: 2 }; <br/>const map = new Map(Object.entries(obj));<br/>console.log(map); // Map { a: 1, b: 2 }</span></pre><h2 id="5896" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">String.padStart()</h2><p id="59af" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><code class="fe lv lw lx ly b">padStart()</code>函数将一个字符串添加到一个字符串之前，直到它达到您指定的长度。该函数有两个参数。第一个是字符串的目标长度。如果目标长度小于字符串的长度，则字符串按原样返回。第二个参数是要添加填充的字符串。这是一个可选参数，如果没有指定，它默认为<code class="fe lv lw lx ly b">' '</code>。</p><p id="e0d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以这样写:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="c294" class="my mh it ly b gy nt nu l nv nw">'<!-- -->def<!-- -->'.padStart(10);         // "       <!-- -->def<!-- -->"<br/>'<!-- -->def<!-- -->'.padStart(10, "123");  // "<!-- -->1231231def<!-- -->"<br/>'<!-- -->def<!-- -->'.padStart(6,"123465"); // "<!-- -->abcdef<!-- -->"<br/>'<!-- -->def<!-- -->'.padStart(8, "0");     // "<!-- -->00000def<!-- -->"<br/>'<!-- -->def<!-- -->'.padStart(1);          // "<!-- -->def<!-- -->"</span></pre><p id="3ed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，每个字符串都用第二个参数中的字符串填充到目标长度。第二个参数中的整个字符串可能并不总是包含在内。只包括让函数将字符串填充到目标长度的部分。</p><h2 id="2236" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">String.padEnd()</h2><p id="957c" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><code class="fe lv lw lx ly b">padEnd()</code>函数在一个字符串之后添加一个字符串，直到它达到您指定的长度。该函数有两个参数。第一个是字符串的目标长度。如果目标长度小于字符串的长度，则字符串按原样返回。第二个参数是要添加填充的字符串。这是一个可选参数，如果没有指定，默认为<code class="fe lv lw lx ly b">' '</code>。</p><p id="388c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以这样写:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="a921" class="my mh it ly b gy nt nu l nv nw">'<!-- -->def<!-- -->'.<!-- -->padEnd<!-- -->(10);         // "<!-- -->def       <!-- -->"<br/>'<!-- -->def<!-- -->'.<!-- -->padEnd<!-- -->(10, "123");  // "<!-- -->def1231231<!-- -->"<br/>'<!-- -->def<!-- -->'.<!-- -->padEnd<!-- -->(6,"123465"); // "<!-- -->defabc<!-- -->"<br/>'<!-- -->def<!-- -->'.<!-- -->padEnd<!-- -->(8, "0");     // "<!-- -->def00000<!-- -->"<br/>'<!-- -->def<!-- -->'.<!-- -->padEnd<!-- -->(1);          // "<!-- -->def<!-- -->"</span></pre><h2 id="8620" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated"><strong class="ak">object . getownpropertydescriptors()</strong></h2><p id="a9f1" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">函数返回一个对象的所有属性描述符。</p><p id="e96a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以像下面的代码一样使用它:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="bac9" class="my mh it ly b gy nt nu l nv nw">const obj = {<br/>  a: 1<br/>};</span><span id="4386" class="my mh it ly b gy nx nu l nv nw">const descriptors = Object.getOwnPropertyDescriptors(obj);</span></pre><p id="643c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">descriptors</code>对象应该具有:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="b7d3" class="my mh it ly b gy nt nu l nv nw">{<br/>  a: {<br/>    configurable: true,<br/>    enumerable: true,<br/>    value: 1,<br/>    writable: true<br/>  }<br/>}</span></pre><h2 id="2b87" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">异步和等待</h2><p id="add5" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">通过<code class="fe lv lw lx ly b">async</code>和<code class="fe lv lw lx ly b">await</code>，我们可以缩短承诺代码。在<code class="fe lv lw lx ly b">async</code>和<code class="fe lv lw lx ly b">await</code>之前，我们必须使用<code class="fe lv lw lx ly b">then</code>函数，我们把回调函数作为所有<code class="fe lv lw lx ly b">then</code>函数的参数。这使得代码很长，因为我们有很多承诺。相反，我们可以使用<code class="fe lv lw lx ly b">async</code>和<code class="fe lv lw lx ly b">await</code>语法来替换<code class="fe lv lw lx ly b">then</code>及其相关的回调，如下所示。例如，我们有使用Fetch API向后端发出请求的代码:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="b411" class="my mh it ly b gy nt nu l nv nw">const APIURL = "<a class="ae ky" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>";</span><span id="b425" class="my mh it ly b gy nx nu l nv nw">const subscribe = async data =&gt; {<br/>  const response = await fetch(`${APIURL}/subscribers`, {<br/>    method: "POST",<br/>    mode: "cors",<br/>    cache: "no-cache",<br/>    headers: {<br/>      "Content-Type": "application/json"<br/>    },<br/>    body: JSON.stringify(data)<br/>  });<br/>  return response.json();<br/>};</span><span id="9101" class="my mh it ly b gy nx nu l nv nw">window.onload = () =&gt; {<br/>  nameForm.method = "post";<br/>  nameForm.target = "_blank";<br/>  nameForm.action = "";<br/>  nameForm.addEventListener("submit", async e =&gt; {<br/>    e.preventDefault();<br/>    const firstName = document.getElementById("firstName").value;<br/>    const lastName = document.getElementById("lastName").value;<br/>    const email = document.getElementById("email").value;<br/>    let errors = [];<br/>    if (!firstName) {<br/>      errors.push("First name is required.");<br/>    }</span><span id="b8d7" class="my mh it ly b gy nx nu l nv nw">    if (!lastName) {<br/>      errors.push("Last name is required.");<br/>    }</span><span id="ca5c" class="my mh it ly b gy nx nu l nv nw">    if (!email) {<br/>      errors.push("Email is required.");<br/>    }</span><span id="6c33" class="my mh it ly b gy nx nu l nv nw">    if (!/[^@]+@[^\.]+\..+/.test(email)) {<br/>      errors.push("Email is invalid.");<br/>    }</span><span id="25a9" class="my mh it ly b gy nx nu l nv nw">    if (errors.length &gt; 0) {<br/>      alert(errors.join(" "));<br/>      return;<br/>    }<br/>    try {<br/>      const response = await subscribe({<br/>        firstName,<br/>        lastName,<br/>        email<br/>      });<br/>      alert(`${response.firstName} ${response.lastName} has subscribed`);<br/>    } catch (error) {<br/>      alert(error.toString());<br/>    }<br/>  });<br/>};</span></pre><p id="08b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用<code class="fe lv lw lx ly b">await</code>替换了<code class="fe lv lw lx ly b">then</code>和回调。然后，我们可以将每个承诺的解析值指定为变量。注意，如果我们使用<code class="fe lv lw lx ly b">await</code>作为我们的承诺代码，那么我们必须把<code class="fe lv lw lx ly b">async</code>放在函数签名中，就像我们在上面的例子中所做的那样。为了捕捉错误，我们没有在最后链接<code class="fe lv lw lx ly b">catch</code>函数，而是使用<code class="fe lv lw lx ly b">catch</code>子句来完成。此外，我们没有在底部链接<code class="fe lv lw lx ly b">finally</code>函数来在承诺结束时运行代码，而是在<code class="fe lv lw lx ly b">catch</code>子句后使用<code class="fe lv lw lx ly b">finally</code>子句来做这件事。</p><p id="4936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们获得了分配给变量的promise的解析值，而不是在<code class="fe lv lw lx ly b">then</code>函数的回调中获得值，就像上面的<code class="fe lv lw lx ly b">const response = await subscribe({...})</code>行一样。</p><p id="4d32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数总是返回承诺，不能像任何使用承诺的函数那样返回任何其他东西。在上面的例子中，我们使用了基于承诺的获取API和<code class="fe lv lw lx ly b">async</code>和<code class="fe lv lw lx ly b">await</code>语法，我们表明我们可以用比使用回调作为参数传入的<code class="fe lv lw lx ly b">then</code>函数更短的方式链接承诺。</p><p id="5bcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ES2016和2017为我们提供了方便的功能，增强了ES2015中添加的已经很棒的语法糖和功能，这是对其前身的重大改进。这两个版本的JavaScript通过新的对象、字符串和数组方法以及链接承诺的简写，使得JavaScript开发更加出色。</p></div></div>    
</body>
</html>