<html>
<head>
<title>Solving Four Kubernetes Networking Challenges</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决四个Kubernetes网络挑战</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solving-four-kubernetes-networking-challenges-a5fb034db8bd?source=collection_archive---------12-----------------------#2022-01-20">https://betterprogramming.pub/solving-four-kubernetes-networking-challenges-a5fb034db8bd?source=collection_archive---------12-----------------------#2022-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1057" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">应对云原生系统的动态性和复杂性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/987d52d209398cd5cddea64b9d36bafc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/0*Cn6LdkS4n1sHbAwj.png"/></div></figure><p id="8430" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Kubernetes 的主要职责之一是在应用程序之间共享节点。联网是一项基本要求，因为这些应用程序需要相互通信以及与外界通信。</p><p id="fb97" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">来自Kubernetes集群外部的请求通常通过路由器或负责将它们代理给适当服务的<a class="ae lm" href="https://konghq.com/learning-center/api-gateway/?utm_source=guest&amp;utm_medium=devspotlight&amp;utm_campaign=community" rel="noopener ugc nofollow" target="_blank"> API网关</a>。Kubernetes网络的职责是提供底层通信层，使请求能够到达它们的目的地。</p><p id="f319" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">分布式应用程序分布在许多节点上。当每个应用程序有多个副本时，Kubernetes处理<a class="ae lm" href="https://thenewstack.io/how-does-service-discovery-work-in-kubernetes/#:~:text=The%20services%20model%20in%20Kubernetes,%2C%20aspect%20of%20microservices%3A%20discovery.&amp;text=Kubernetes%20refers%20to%20these%20key,with%20a%20set%20of%20pods." rel="noopener ugc nofollow" target="_blank">服务发现</a>和<a class="ae lm" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>与Pods之间的通信。在Pod内部，容器可以轻松透明地进行通信。在一个集群中，pod可以连接到其他pod，这是通过虚拟网络接口、网桥和路由规则的组合，通过<a class="ae lm" href="https://en.wikipedia.org/wiki/Overlay_network" rel="noopener ugc nofollow" target="_blank">覆盖网络</a>实现的。</p><p id="c207" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">尽管处理是透明的，但是，Kubernetes网络比看起来更复杂。跨多个云部署、维护多个环境以及确保可靠和可扩展的网络策略是巨大的挑战。Kubernetes本身并没有解决所有这些复杂问题。在本文中，我们将探讨如何应对这些挑战。</p><h1 id="1aec" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">Kubernetes网络的基础知识</h1><p id="ebf0" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">在Kubernetes中，<a class="ae lm" href="https://kubernetes.io/docs/concepts/workloads/pods/" rel="noopener ugc nofollow" target="_blank">pod</a>负责处理容器到容器的通信。Pods通过自己的网络资源(接口和路由表)利用网络名称空间。在Pod中，容器共享这些资源，允许它们通过本地主机进行通信。</p><p id="a52e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Pod-to-Pod通信必须满足以下Kubernetes要求:</p><ul class=""><li id="7166" class="mk ml it ks b kt ku kw kx kz mm ld mn lh mo ll mp mq mr ms bi translated">pod需要在没有<a class="ae lm" href="https://en.wikipedia.org/wiki/Network_address_translation" rel="noopener ugc nofollow" target="_blank">网络地址转换(NAT) </a>的情况下进行通信。</li><li id="e342" class="mk ml it ks b kt mt kw mu kz mv ld mw lh mx ll mp mq mr ms bi translated">节点需要能够在没有NAT的情况下与pod通信。</li><li id="4ada" class="mk ml it ks b kt mt kw mu kz mv ld mw lh mx ll mp mq mr ms bi translated">Pod可以看到的分配给自己的IP地址必须与其他Pod看到的IP地址相匹配。</li></ul><p id="f550" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae lm" href="https://github.com/containernetworking/cni" rel="noopener ugc nofollow" target="_blank">容器网络接口(CNI) </a>包括编写网络插件来配置网络接口的规范。这允许你创建<a class="ae lm" href="https://en.wikipedia.org/wiki/Overlay_network" rel="noopener ugc nofollow" target="_blank">覆盖网络</a>来满足吊舱对吊舱的通信需求。</p><p id="1e12" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一个<a class="ae lm" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>是一个Kubernetes抽象，它允许Pods公开和接收请求。它通过Pod标签和基本的负载平衡功能提供服务发现机制。在Pods中运行的应用程序可以很容易地使用服务连接到集群中运行的其他应用程序。来自集群外部的请求可以通过<a class="ae lm" href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/" rel="noopener ugc nofollow" target="_blank">入口控制器</a>进行路由。这些控制器将使用<a class="ae lm" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank">入口</a>资源来配置路由规则，通常利用<a class="ae lm" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>来促进路由到正确的应用。</p><h1 id="9fca" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">重大挑战</h1><p id="49ef" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">虽然这些网络功能为Kubernetes托管工作负载提供了基础构建模块，但<a class="ae lm" href="https://konghq.com/blog/cloud-native-infrastructure/?utm_source=guest&amp;utm_medium=devspotlight&amp;utm_campaign=community" rel="noopener ugc nofollow" target="_blank">云原生</a>系统的动态和复杂特性带来了一些挑战。</p><h2 id="0b81" class="my lo it bd lp mz na dn lt nb nc dp lx kz nd ne lz ld nf ng mb lh nh ni md nj bi translated">服务对服务的通信可靠性</h2><p id="73d2" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">在分布式系统中，业务功能被划分为多个自治的服务，这些服务在一个节点、单元和容器集群上运行。微服务架构引入了通过网络进行通信的服务需求。</p><p id="5b33" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">云的易变性和弹性要求持续监控Kubernetes集群，并在出现故障时进行重新路由。有了短暂的pod和持续的资源重新路由，可靠的服务对服务的通信就不是必然的了。</p><p id="3d6d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">高效的负载平衡算法需要将流量分配给可用的副本，并隔离过载的副本。类似地，服务失败意味着客户端请求需要重试并正常超时。复杂的场景可能需要<a class="ae lm" href="https://en.wikipedia.org/wiki/Circuit_breaker" rel="noopener ugc nofollow" target="_blank">断路器</a>和减载技术来应对需求激增和故障。</p><h2 id="d00e" class="my lo it bd lp mz na dn lt nb nc dp lx kz nd ne lz ld nf ng mb lh nh ni md nj bi translated">精心设计的多云部署</h2><p id="c920" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">复杂的大规模系统通常被划分为多个环境，不同的部分被部署到不同的云平台。这些异构环境需要相互通信。</p><p id="a6df" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">即使在同一个云租户或内部，相同的工作负载也可以在不同的环境中运行(开发、试运行和生产)。虽然是分离的，但这些环境有时需要相互通信。例如，试运行环境可能需要模拟生产工作负载，并在应用程序投入使用之前对其进行严格测试。随着测试的成功，代码和数据可能都需要从中迁移。</p><p id="f695" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这种情况下，无缝迁移可能具有挑战性。此外，可能会有团队同时支持VM和Kubernetes托管的服务的情况。或者，也许一个团队设计了支持多云(或者至少是多区域)部署的系统以获得可靠性，指定了复杂的网络配置和详细的入口和出口规则。</p><h2 id="ffb4" class="my lo it bd lp mz na dn lt nb nc dp lx kz nd ne lz ld nf ng mb lh nh ni md nj bi translated">服务发现</h2><p id="ffed" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">当在云原生环境中运行Kubernetes时，可以通过在多个节点上生成多个副本来轻松扩展服务。这些应用程序副本是短暂的——在Kubernetes认为必要时被实例化和销毁。对于应用程序中的<a class="ae lm" href="https://konghq.com/learning-center/microservices/" rel="noopener ugc nofollow" target="_blank">微服务</a>来说，跟踪所有这些IP地址和端口的变化非常重要。尽管如此，这些微服务需要一种有效的方法来找到服务副本。</p><h2 id="4692" class="my lo it bd lp mz na dn lt nb nc dp lx kz nd ne lz ld nf ng mb lh nh ni md nj bi translated">网络规则可扩展性</h2><p id="59e0" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">安全最佳实践和行业法规，如<a class="ae lm" href="https://en.wikipedia.org/wiki/Payment_Card_Industry_Data_Security_Standard" rel="noopener ugc nofollow" target="_blank">支付卡行业数据安全标准(PCI DSS) </a>执行严格的网络规则。这些规则规定了服务之间严格的通信约束。</p><p id="bd49" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Kubernetes有<a class="ae lm" href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" rel="noopener ugc nofollow" target="_blank">网络政策</a>的概念。这些允许您在IP地址或端口级别控制流量。您可以指定使用标签和选择器使Pod与其他服务进行通信的规则。</p><p id="c766" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">随着您的微服务系统数量的增长，达到数百或数千个服务，网络策略管理成为一个复杂、乏味且容易出错的过程。</p><h1 id="0b29" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">Kong Ingress控制器如何提供帮助</h1><p id="aa68" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">孔的<a class="ae lm" href="https://konghq.com/solutions/kubernetes-ingress/?utm_source=guest&amp;utm_medium=devspotlight&amp;utm_campaign=community" rel="noopener ugc nofollow" target="_blank"> Kubernetes Ingress控制器(KIC) </a>是Kubernetes的<a class="ae lm" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank"> Ingress </a>实现。这个入口控制器由<a class="ae lm" href="https://konghq.com/kong/?utm_source=guest&amp;utm_medium=devspotlight&amp;utm_campaign=community" rel="noopener ugc nofollow" target="_blank"> Kong Gateway </a>提供支持，充当云原生的、平台无关的、可扩展的API网关。它专为混合和多云环境而构建，并针对微服务和分布式架构进行了优化。</p><p id="8e81" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">KIC允许创建路由规则、健康检查和负载平衡的配置，它支持各种提供高级功能的<a class="ae lm" href="https://docs.konghq.com/hub/" rel="noopener ugc nofollow" target="_blank">插件</a>。这种广泛的功能有助于解决我们已经讨论过的挑战。</p><h2 id="6160" class="my lo it bd lp mz na dn lt nb nc dp lx kz nd ne lz ld nf ng mb lh nh ni md nj bi translated">可靠的服务对服务通信</h2><p id="2b2b" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">Kubernetes <a class="ae lm" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>提供简单的负载平衡能力(循环)。KIC的核心特性之一是在同一应用程序的副本之间实现负载平衡。它可以使用加权连接或最小连接等算法，甚至是复杂的自定义实现。这些算法利用KIC的服务注册中心来提供高效的路由。</p><p id="25d6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用KIC，您可以轻松地配置服务关闭时的重试、合理的超时、将请求重新路由到健康的服务实例或错误处理。您还可以实现故障模式，如断路和减载，以平滑和抑制流量。</p><h2 id="9a05" class="my lo it bd lp mz na dn lt nb nc dp lx kz nd ne lz ld nf ng mb lh nh ni md nj bi translated">更简单的多云环境部署</h2><p id="dd3d" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">多环境和异构基础架构部署需要复杂的网络策略和路由配置。建在的孔闸解决了许多这样的挑战。</p><p id="dec8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Kong Gateway允许<a class="ae lm" href="https://docs.konghq.com/gateway/2.6.x/get-started/quickstart/configuring-a-service/#main" rel="noopener ugc nofollow" target="_blank">服务注册</a>独立于服务部署的位置。有了注册的服务，你将能够<a class="ae lm" href="https://docs.konghq.com/gateway/2.6.x/get-started/quickstart/configuring-a-service/#2-add-a-route-for-the-service" rel="noopener ugc nofollow" target="_blank">添加路线</a>，KIC将准备好代理对你的服务的请求。此外，虽然复杂的系统有时可以使用不同的协议进行通信(REST和gRPC)，但是您可以轻松地配置KIC来支持多种协议。</p><p id="d70c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae lm" href="https://docs.konghq.com/hub/plugins/overview/" rel="noopener ugc nofollow" target="_blank">插件系统</a>允许你为更复杂的场景扩展KIC的功能。<a class="ae lm" href="https://docs.konghq.com/hub/" rel="noopener ugc nofollow" target="_blank"> Kong Plugin Hub </a>包含了一个强大的有用且久经考验的插件集合，<a class="ae lm" href="https://docs.konghq.com/gateway/2.6.x/plugin-development/" rel="noopener ugc nofollow" target="_blank">也能让你开发</a>并使用任何最适合你需求的插件。</p><h2 id="c7ac" class="my lo it bd lp mz na dn lt nb nc dp lx kz nd ne lz ld nf ng mb lh nh ni md nj bi translated">增强的服务发现</h2><p id="5ab4" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">如前所述，KIC通过其服务注册来跟踪可用的实例。随着服务与KIC集成，他们可以自助注册并报告其可用性。这种注册也可以通过第三方注册服务来完成。通过利用服务注册中心，KIC可以随时将客户端请求代理到适当的后端。</p><h2 id="f86e" class="my lo it bd lp mz na dn lt nb nc dp lx kz nd ne lz ld nf ng mb lh nh ni md nj bi translated">可扩展的网络规则</h2><p id="9fe4" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">尽管通过<a class="ae lm" href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" rel="noopener ugc nofollow" target="_blank">网络策略</a>执行网络规则可能会很复杂，但KIC可以<a class="ae lm" href="https://docs.konghq.com/kubernetes-ingress-controller/2.0.x/guides/getting-started-istio/#main" rel="noopener ugc nofollow" target="_blank">轻松地将</a>与<a class="ae lm" href="https://konghq.com/learning-center/service-mesh/what-is-a-service-mesh/?utm_source=guest&amp;utm_medium=devspotlight&amp;utm_campaign=community" rel="noopener ugc nofollow" target="_blank">服务网格</a>集成，就像CNCF的<a class="ae lm" href="https://kuma.io/" rel="noopener ugc nofollow" target="_blank">库马</a>或<a class="ae lm" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> Istio </a>与<a class="ae lm" href="https://konghq.com/blog/istio-gateway/?utm_source=guest&amp;utm_medium=devspotlight&amp;utm_campaign=community" rel="noopener ugc nofollow" target="_blank"> Kong Istio网关</a>集成一样，扩展<a class="ae lm" href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" rel="noopener ugc nofollow" target="_blank">网络策略</a>的功能并保证额外的安全性。</p><p id="37e9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">借助<a class="ae lm" href="https://kuma.io/docs/1.4.1/security/certificates/" rel="noopener ugc nofollow" target="_blank">认证和授权</a>策略，您将能够以安全、一致和自动化的方式增强网络安全性。此外，您可以结合使用<a class="ae lm" href="https://kuma.io/docs/1.4.1/policies/general-notes-about-kuma-policies/" rel="noopener ugc nofollow" target="_blank">网络策略和服务网格策略</a>来提供更好的安全态势。</p><p id="7b55" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">服务网格集成的另一个好处是，它允许金丝雀部署和蓝/绿部署这样的部署模式。它还通过可靠的度量和跟踪增强了可观察性。</p><h1 id="09db" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">结论</h1><p id="a256" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">Kubernetes可以处理常见的网络任务，使开发者和运营商更容易获得服务。然而，对于大型复杂的云原生系统，网络问题很少是简单的。组织想要将<a class="ae lm" href="https://konghq.com/learning-center/microservices/monolith-vs-microservices/?utm_source=guest&amp;utm_medium=devspotlight&amp;utm_campaign=community" rel="noopener ugc nofollow" target="_blank">单片</a>分割成微服务，但是他们需要解决一些独特的问题，比如高效的负载平衡或者容错。同样，实现不同环境之间的无缝服务迁移和转换也不容易。Kubernetes的网络功能需要扩展以支持更广泛的场景。</p><p id="48c7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">KIC可以有效地应对这些挑战。它提供了广泛的功能，包括高级路由和负载平衡规则、复杂的入口和出口规则以及容错措施。您可以使用KIC的服务注册中心大大改进服务发现，它可以跟踪每个服务的所有可用实例。与KIC和服务网格的轻松集成有助于建立强大的网络安全策略，并利用不同的部署模式。</p></div></div>    
</body>
</html>