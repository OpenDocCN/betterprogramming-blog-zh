<html>
<head>
<title>Replicating the Standard Clock Android App With RxJava and Room</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用RxJava和Room复制标准时钟Android应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/replicating-the-standard-clock-app-with-rxjava-and-room-9497a01daf42?source=collection_archive---------9-----------------------#2022-03-03">https://betterprogramming.pub/replicating-the-standard-clock-app-with-rxjava-and-room-9497a01daf42?source=collection_archive---------9-----------------------#2022-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="feac" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Android中的可观察模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/37d19630e7071fcfcc397f386683d618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PcoaWfkHD3Q5Uw2T"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@malvestida?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Malvestida </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="41d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我学习流和反应式编程时，我发现了RxJava，但是因为它看起来很复杂而推迟了学习。</p><p id="d7ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最终决定试一试，创建一个应用程序，在那里我很容易找到可观察的模式，所以我选择创建一个标准Android时钟应用程序的克隆。</p><h1 id="1630" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">该应用程序</h1><p id="0fa3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我把这个项目命名为“<code class="fe mp mq mr ms b">ClockClone</code>”我的目标是识别标准时钟应用程序中适用观察者模式的所有用例，然后使用RxJava自己重新创建它，以便我可以学习它。</p><p id="7b9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简单明了，我没有把这个应用程序做成了一个完全的克隆——不是所有的功能都被复制了。其中，警报实际上并不工作，也没有全屏通知。</p><h1 id="2a18" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用案例</h1><p id="5116" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">该应用程序的主要功能源自时钟应用程序主屏幕上的四个选项卡:</p><ul class=""><li id="3a4f" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">警报—设置和管理警报。只有报警数据的持久存储，实际上不会安排报警。</li><li id="9b8b" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">世界时钟-查看世界主要城市的时间和天气情况。</li><li id="007d" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">秒表—运行秒表。它还可以显示分割时间和单圈时间。</li><li id="12d7" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">计时器—运行一个简单的倒计时计时器。</li></ul><p id="9fbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将只讨论应用程序中与RxJava相关的部分。</p><h1 id="11ba" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">代码</h1><p id="becf" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">所有代码都可以在Github <a class="ae kv" href="https://github.com/DavidGrath/Clock-Clone" rel="noopener ugc nofollow" target="_blank">这里</a>找到。为了简洁起见，本文中的代码被缩短了。</p><h1 id="e086" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">RxJava</h1><p id="b192" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">RxJava是<a class="ae kv" href="https://reactivex.io/" rel="noopener ugc nofollow" target="_blank">react vex API</a>的Java实现。引用他们的主页:</p><blockquote class="nh ni nj"><p id="bdc2" class="kw kx nk ky b kz la jr lb lc ld ju le nl lg lh li nm lk ll lm nn lo lp lq lr ij bi translated">ReactiveX结合了观察者模式、迭代器模式和函数式编程的最佳理念</p></blockquote><p id="71f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ReactiveX中的所有操作都围绕着<a class="ae kv" href="https://reactivex.io/documentation/observable.html" rel="noopener ugc nofollow" target="_blank">可观测量</a>的使用。它们的功能类似于Java期货，但是是为处理异步值序列而不是单个值而构建的。</p><p id="353b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Observables发出三种主要的事件:onNext、onComplete和onError。可观察序列由零个或多个onNext事件组成，并以onComplete或onError事件终止，但不能同时以两者终止。</p><p id="cb83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ReactiveX附带了一大组操作符，可用于对可观测量进行各种操作，如转换、过滤、合并可观测量、聚合操作等。我只在应用程序中使用了其中的一些，我将对此进行讨论。</p><p id="ae49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个应用程序，我使用的是RxJava 3，特别是版本<code class="fe mp mq mr ms b">3.0.0</code>。查看他们的Github <a class="ae kv" href="https://github.com/ReactiveX/RxJava/releases" rel="noopener ugc nofollow" target="_blank">发布版</a>页面，获取完整版本列表。</p><h1 id="7e6c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">假设</h1><p id="808f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您熟悉以下内容:</p><ul class=""><li id="ffa4" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">观察者模式</li><li id="e748" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">加装</li><li id="3dd4" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">房间</li><li id="a504" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">Android应用架构</li><li id="ebd3" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">Java并发框架</li><li id="3091" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">匕首</li></ul><h1 id="cf84" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用的库</h1><ul class=""><li id="4af3" class="mt mu iq ky b kz mk lc ml lf no lj np ln nq lr my mz na nb bi translated"><a class="ae kv" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a></li><li id="b56f" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><a class="ae kv" href="https://github.com/ReactiveX/RxAndroid" rel="noopener ugc nofollow" target="_blank"> RxAndroid </a></li><li id="d83d" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><a class="ae kv" href="https://developer.android.com/jetpack/androidx/releases/room" rel="noopener ugc nofollow" target="_blank">房间</a> —包括RxJava适配器</li><li id="2b84" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><a class="ae kv" href="https://developer.android.com/jetpack/androidx/releases/lifecycle#java" rel="noopener ugc nofollow" target="_blank">生命周期</a> —包括使用RxJava的反应流</li><li id="0a3f" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><a class="ae kv" href="https://github.com/square/retrofit#download" rel="noopener ugc nofollow" target="_blank">改装</a></li><li id="e37d" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><a class="ae kv" href="https://github.com/square/retrofit/tree/master/retrofit-adapters/rxjava3#download" rel="noopener ugc nofollow" target="_blank">改装RxJava适配器</a></li></ul><h1 id="190a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">跑表</h1><p id="400e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">秒表所需的可观察数据包括自启动以来经过的时间(以毫秒计)——运行时间、自用户最后一次单击“lap”以来经过的时间(以毫秒计)——分段时间、状态(<code class="fe mp mq mr ms b">OFF</code>、<code class="fe mp mq mr ms b">RUNNING</code>、<code class="fe mp mq mr ms b">PAUSED</code>)——主要用于UI和通知，以及分段和分段时间列表，每次单击“分段”或“分段”时都会更新。想到这一点后，我发现需要一种特殊的可观察对象才能手动发出事件。</p><h2 id="3dd2" class="nr lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">学科</h2><p id="b46a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://reactivex.io/documentation/subject.html" rel="noopener ugc nofollow" target="_blank">主体</a>同时充当数据的观察者和被观察者。有四种主题:</p><ol class=""><li id="a1a2" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr od mz na nb bi translated">PublishSubject:从订阅点向观察者发出值。在订阅之前发出的所有值都不会被接收。</li><li id="c5e6" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr od mz na nb bi translated">ReplaySubject:从头开始重放流，并发出新值。</li><li id="396e" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr od mz na nb bi translated">BehaviorSubject:与PublishSubject相同，但发出订阅前的最新值。有初始状态的流就是一个很好的例子。</li><li id="7158" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr od mz na nb bi translated">AsyncSubject:只向观察者发出最后一个值。该值仅在主体调用<code class="fe mp mq mr ms b">onComplete()</code>时发出。</li></ol><p id="5a76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我为UI选择了BehaviorSubject，以便当它从后台重启或配置更改时，能够获取可观察对象的最后状态。</p><p id="17f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了跟踪时间并以固定的时间间隔发送更新，我使用了<a class="ae kv" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html" rel="noopener ugc nofollow" target="_blank">ScheduledThreadPoolExecutor</a>。这是比Handler更好的选择，因为Handler是在主(UI)线程上执行的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="bb06" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">计时器</h1><p id="8f8e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">计时器的工作原理与秒表非常相似。可观测的数据包括以毫秒为单位的剩余时间和状态(<code class="fe mp mq mr ms b">OFF</code>、<code class="fe mp mq mr ms b">COUNTING</code>或<code class="fe mp mq mr ms b">PAUSED</code>)。我还使用了BehaviorSubject和ScheduledThreadPoolExecutor。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="5b28" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">世界时钟</h1><p id="f426" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">世界时钟的主要子功能是能够看到世界上所有主要城市的当前时间。第二个子功能是能够看到这些城市的汇总的当前天气情况。</p><p id="e95a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可观测数据包括一个计时器，用于更新当前显示的时间、天气状况和城市列表。我要指出的是，我在开发世界时钟时遇到了困难——我一直在改变代码的结构，直到我找到一个运行良好的类结构。</p><p id="c6eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个特性的核心数据是时区标识符。看起来是这样的:</p><pre class="kg kh ki kj gt og ms oh oi aw oj bi"><span id="5fe5" class="nr lt iq ms b gy ok ol l om on">Africa/Lagos</span></pre><p id="5383" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它可以用来获取主要城市的当前时间以及天气状况。我使用来自<a class="ae kv" href="https://www.iana.org/time-zones" rel="noopener ugc nofollow" target="_blank"> TZDB </a>的数据创建了一个时区列表，并将它作为CSV文件存储在应用程序资产中。</p><p id="fc11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当前时间是从<code class="fe mp mq mr ms b">DateFormat</code>获得的，它使用时区标识符为UI适当地格式化它。计时器在每分钟的第0秒停止计时，以触发UI更新。</p><p id="fc00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">天气状况是从网络请求中获取的，我稍后会谈到。用户保存的城市列表存储为简单的逗号分隔字符串。</p><p id="0898" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用了<code class="fe mp mq mr ms b">SharedPreferences</code>,因为无论何时发生变化，它都可以向观察者发出信号，而且数据库也是多余的。</p><h2 id="a3ec" class="nr lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">气象条件</h2><p id="02a1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我选择使用<a class="ae kv" href="https://developer.accuweather.com/" rel="noopener ugc nofollow" target="_blank"> AccuWeather </a>来进行改造和试用RxJava呼叫适配器。</p><p id="7340" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过调用<code class="fe mp mq mr ms b">Builder</code>对象上的<code class="fe mp mq mr ms b">addCallAdapterFactory()</code>来创建带有适配器的客户端接口。</p><p id="6b45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以选择为适配器设置一个调度程序。调度程序用于多线程。查看<a class="ae kv" href="https://www.baeldung.com/rxjava-schedulers" rel="noopener ugc nofollow" target="_blank">此处的</a>了解更多信息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="6f50" class="nr lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">单事件可观测量</h2><p id="0a0d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">标准的Observable是为处理一系列异步任务而构建的，但是网络请求只是一个单独的任务。虽然可以将Observable与reform一起使用，但RxJava中有一些特殊类型是为了处理一次性事件而构建的。</p><ul class=""><li id="83ea" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">单一:发射<code class="fe mp mq mr ms b">onSuccess </code>或<code class="fe mp mq mr ms b">onError</code>。onSuccess是用单个项目发出的。</li><li id="054d" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">Completable:发出<code class="fe mp mq mr ms b">onCompleted </code>或<code class="fe mp mq mr ms b">onError</code>，但不发出任何未完成的项目。</li><li id="bd7d" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">可能:会发出<code class="fe mp mq mr ms b">onSuccess</code>、<code class="fe mp mq mr ms b">onComplete</code>或<code class="fe mp mq mr ms b">onError </code>事件中的任意一个。<code class="fe mp mq mr ms b">onSuccess </code>有单品。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="7e0a" class="nr lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">取消订阅</h2><p id="4f55" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在处理天气状况时，我意识到，如果应用程序在网络请求完成前关闭，能够取消这些请求是非常重要的。</p><p id="921a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">网络请求是内存泄漏的潜在来源，进而可能导致崩溃。在ReactiveX中，订阅者是表示订阅可观察对象的特殊类型，但在RxJava中，它们被称为一次性的。</p><p id="cfec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一次性用品将在需要时用于取消请求。他们有一个<code class="fe mp mq mr ms b">dispose()</code>方法，取消订阅Observables。</p><p id="dd63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个可观察对象通过调用<code class="fe mp mq mr ms b">subscribe()</code>返回一个可处置对象。<code class="fe mp mq mr ms b">CompositeDisposables</code>帮助一次性处理一组一次性物品，类似于标准收集的forEach操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="56c4" class="nr lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">每分钟更新一次</h2><p id="1cc3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">interval observable每分钟发出一个带有无用项的事件，通知UI更新当前时间。为了每分钟更新列表，我使用了<code class="fe mp mq mr ms b">combineLatest()</code>操作符。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="1c6a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">警告</h1><p id="d603" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我决定使用一个数据库来跟踪警报，以便查看、修改和删除它们，这样就为RxJava适配器留出了空间。</p><p id="231e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我从这篇文章<a class="ae kv" href="https://medium.com/androiddevelopers/room-rxjava-acb0cd4f3757" rel="noopener">中发现</a>Observable，Maybe，Single和Completable可以作为一个Room DAO方法的返回类型。另外，也可以使用<code class="fe mp mq mr ms b">Flowable </code>。</p><p id="b523" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可流动是一种支持背压的可观察对象，背压是一种可观察对象发送事件的速度快于观察者处理它们的速度的情况。可以使用<code class="fe mp mq mr ms b">toFlowable()</code>将可观察值转换为可流动值，并将背压策略作为参数。像Maybe和single这样的单个事件类型不将策略作为转换的参数。我只在代码中使用了<code class="fe mp mq mr ms b">BackpressureStrategy.BUFFER</code>。查看更多关于<a class="ae kv" href="https://www.baeldung.com/rxjava-backpressure" rel="noopener ugc nofollow" target="_blank">背压</a>和<a class="ae kv" href="https://www.baeldung.com/rxjava-2-flowable" rel="noopener ugc nofollow" target="_blank">流量</a>的链接。</p><h2 id="b485" class="nr lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">转换到LiveData</h2><p id="c43e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">所有可观察的类型都可以转换成LiveData，这样它们就可以用于视图模型。它们必须被转换成可流动的形式，并被传递给<code class="fe mp mq mr ms b">LiveDataReactiveStreams.fromPublisher()</code>方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="0ad6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我没有用LiveData实现的一件事是错误处理。来自可观察对象的错误事件将导致LiveData抛出RuntimeException，这将导致应用程序崩溃。</p><p id="e6e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在将可能的错误传递给LiveData之前，您应该将它们转换成有意义的UI状态对象。从Google示例中查看这个实现。</p><h1 id="d8a0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="8956" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我对RxJava有一些想法。这是一个强大的库，有很大的潜力，我觉得我仅仅触及了<code class="fe mp mq mr ms b">ClockClone</code>的表面。然而，我确实学会了很好地利用它来观察Android上的模式。</p><p id="ccd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还喜欢它不是Android开发独有的这一事实，因此它可能在其他领域派上用场。我松了口气，我终于有时间来学习这个。我希望你也学到了一些东西。</p></div></div>    
</body>
</html>