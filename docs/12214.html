<html>
<head>
<title>Method Hiding in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中隐藏的方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/method-hiding-in-c-d653f822ab33?source=collection_archive---------9-----------------------#2022-05-19">https://betterprogramming.pub/method-hiding-in-c-d653f822ab33?source=collection_archive---------9-----------------------#2022-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ffd2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何通过在子类中实现来掩盖父类中的更改</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/84563d145afec6e85cb1078795de1736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OanCJYzbrH68-ULh"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">约书亚·雷德科普在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8a4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">方法隐藏意味着通过重新实现父类的方法来改变它在子类中的行为。</p><p id="8354" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据定义，我们所做的就是隐藏或隐藏，或者更好地“忽略”父类方法。</p><p id="e94e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等一下！这正是方法重写的含义。那么，如果方法隐藏服务于相同的目的，为什么我们还需要它呢？这就是我们在本文中要回答的问题。</p><p id="15e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是多态性系列的第三部分，在这里我们将深入探讨多态性。以下是拼图的三个部分。</p><ol class=""><li id="cacd" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/compile-time-polymorphism-in-c-f5ca6934cc55">编译时多态性</a></li><li id="b016" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/@RikamPalkar/run-time-polymorphism-in-c-6f9687857ba6" rel="noopener">运行时多态性</a></li><li id="476e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">方法隐藏/隐藏</li></ol><blockquote class="mg mh mi"><p id="10bf" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated">注意:方法覆盖和方法隐藏的方法签名应该相同。</p></blockquote><p id="4271" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将看到这两者之间的实现差异，然后我们将看到操作差异。</p><h1 id="e98b" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">实现差异</h1><ol class=""><li id="dd3e" class="ls lt iq ky b kz nf lc ng lf nh lj ni ln nj lr lx ly lz ma bi translated">在方法覆盖中，在<code class="fe nk nl nm nn b">child</code>类中只允许覆盖<code class="fe nk nl nm nn b">virtual</code>或<code class="fe nk nl nm nn b">abstract</code>方法，但是在方法隐藏的情况下<code class="fe nk nl nm nn b">child</code>类可以重新实现父类的任何方法，不管是<code class="fe nk nl nm nn b">virtual</code>还是<code class="fe nk nl nm nn b">abstract</code>。</li><li id="d52a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">关键字<code class="fe nk nl nm nn b">override</code>用于被覆盖的方法，其中关键字<code class="fe nk nl nm nn b">new</code>用于隐藏方法。</li></ol><p id="6f98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过创建一个有一个虚拟方法<code class="fe nk nl nm nn b">Speed()</code>和另一个普通方法<code class="fe nk nl nm nn b">SetFuelType()</code>的<code class="fe nk nl nm nn b">class Vehicle</code>来一步步破解这个难题。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单1:车辆类别</p></figure><p id="6caa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我用<code class="fe nk nl nm nn b">parent</code>的对象运行项目，我将得到以下输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/41393ed7f267ee9e506e32835e4b6b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gr0CoAgXohO4IFPG1Bm5vg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图1:父对象调用自己的方法</p></figure><p id="0ecd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建一个<code class="fe nk nl nm nn b">child</code> <code class="fe nk nl nm nn b">class Car</code>来重新实现这两个方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单2:汽车类</p></figure><p id="7f20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在看看当我用一个<code class="fe nk nl nm nn b">child</code>类的对象调用这些方法时会发生什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/d62d99c674aa3c83ed8dc8159146e5de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HYW9y0ExspqUtOqZtDSTMA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2:子对象调用自己的重新实现的方法</p></figure><p id="52f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对象调用自己的重新实现的方法。</p><p id="7c14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有更重要的一点要注意，关键字<code class="fe nk nl nm nn b">new</code>是可选的，但是如果你没有使用它，编译器会抛出一个警告。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/b095ecf241a57d89d8ab1ac6f79a5433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7GzXTt8oJ5Ld5ns6cCYIbg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3:不使用新关键字的警告</p></figure><blockquote class="mg mh mi"><p id="d0ca" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated">警告:<code class="fe nk nl nm nn b"><em class="iq">‘Car.SetFuelType()’</em></code>隐藏了继承的成员<code class="fe nk nl nm nn b"><em class="iq">‘Vehicle.SetFuelType()’</em></code>。如果想要隐藏，请使用new关键字。</p></blockquote><p id="90d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，你可能会问，覆盖和隐藏之间的具体区别是什么，因为我们看到它们在做同样的事情，但方法不同。</p><h1 id="c7b7" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">操作差异</h1><p id="0bab" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">当我们试图用<code class="fe nk nl nm nn b">child</code>类对象调用<code class="fe nk nl nm nn b">parent</code>类方法时，区别就来了。</p><p id="a6e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有两种方法可以在<code class="fe nk nl nm nn b">child</code>类中引用<code class="fe nk nl nm nn b">parent</code>类。</p><ol class=""><li id="9711" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">使用<code class="fe nk nl nm nn b">child</code>类中的<code class="fe nk nl nm nn b">base</code>关键字，查看清单3中的第19行和第25行。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单3:使用base关键字的car类</p></figure><p id="234f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下图中，您可以看到一个<code class="fe nk nl nm nn b">child</code> <code class="fe nk nl nm nn b">class car</code>的实例是如何调用其<code class="fe nk nl nm nn b">parent</code> <code class="fe nk nl nm nn b">class vehicle</code>的实现的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/8be575806aae3f80cf52159a08e06c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DPfR0NzNTV7L22_L04-ncw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3:子类car调用其父类vehicle的实现</p></figure><p id="7fb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.第二种方式:这是一切开始真正可疑的地方。</p><p id="019c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用<code class="fe nk nl nm nn b">parent</code>类的<code class="fe nk nl nm nn b">reference variable</code>来存储<code class="fe nk nl nm nn b">child</code>类<code class="fe nk nl nm nn b">object</code>。</p><p id="d58e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它看起来会像这样:</p><p id="36da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nk nl nm nn b">Vehicle parent = new Car();</code></p><p id="b9d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个<code class="fe nk nl nm nn b">reference variable</code>将可以访问属于<code class="fe nk nl nm nn b">Parent</code>类的所有方法，但是当访问<code class="fe nk nl nm nn b">child</code>类的成员时，它不能调用任何属于<code class="fe nk nl nm nn b">child</code>类的纯成员函数的方法，除了被覆盖的方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单4:覆盖和隐藏方法的父子关系</p></figure><ol class=""><li id="0b8f" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">您可以在清单4中看到，第17行的<code class="fe nk nl nm nn b">method Speed()</code>是<code class="fe nk nl nm nn b">class Car</code>中被覆盖的方法。在图4中，<code class="fe nk nl nm nn b">parent</code> <code class="fe nk nl nm nn b">class Vehicle</code>的<code class="fe nk nl nm nn b">reference variable</code>正在调用<code class="fe nk nl nm nn b">child</code> <code class="fe nk nl nm nn b">class Car</code>的覆盖版本<code class="fe nk nl nm nn b">Speed()</code>。按照我们上面的规则，它按预期工作，“它不能调用任何纯成员函数的方法，除了被覆盖的方法。”</li><li id="5987" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">清单4中要观察的下一件事是第23行的<code class="fe nk nl nm nn b">method SetFuelType()</code>；是<code class="fe nk nl nm nn b">class Car</code>中的隐藏方法。在图4中，<code class="fe nk nl nm nn b">parent</code> <code class="fe nk nl nm nn b">class Vehicle</code>的引用变量忽略了<code class="fe nk nl nm nn b">child</code> <code class="fe nk nl nm nn b">class Car</code>的实现，调用了<code class="fe nk nl nm nn b">parent</code> <code class="fe nk nl nm nn b">class Vehicle</code>的<code class="fe nk nl nm nn b">SetFuelType()</code>版本。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/8a1f25af387eda76c3415941dba75a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kqoZTI4-lSmEp1yrTb9k8Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4:父引用变量调用自己的隐藏方法实现</p></figure><blockquote class="mg mh mi"><p id="975b" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>带<code class="fe nk nl nm nn b">new</code>关键字的方法被认为是纯成员函数，因为<code class="fe nk nl nm nn b">new</code>关键字隐藏了<code class="fe nk nl nm nn b">parent</code>的方法，现在属于<code class="fe nk nl nm nn b">child</code>。在清单5中，我将第17行的<code class="fe nk nl nm nn b">method Speed()</code>的关键字从<code class="fe nk nl nm nn b">override</code>改为<code class="fe nk nl nm nn b">new</code>。现在，它将被视为<code class="fe nk nl nm nn b">class Car</code>的纯定义方法。</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单5:带有两个隐藏方法的父子关系</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/328c6f2e194db06b5de12bce0daf86a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d4C9jin9Fg5eVn9bg_aavA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图5:父引用变量使用新关键字调用其子方法</p></figure><h1 id="4973" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">结论</h1><p id="2954" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">当图4中的<code class="fe nk nl nm nn b">parent</code>类被类型转换为<code class="fe nk nl nm nn b">child</code>类时，<code class="fe nk nl nm nn b">parent</code>类可以有<code class="fe nk nl nm nn b">virtual</code>方法或者它自己的纯成员函数。</p><p id="f448" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在重写中，它跳过虚拟方法并调用<code class="fe nk nl nm nn b">child</code>类重写的方法。这就是为什么在图4中，调用了<code class="fe nk nl nm nn b">child</code>的<code class="fe nk nl nm nn b">speed()</code>方法。</p><p id="04f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在方法隐藏的情况下，它首先在自身中寻找纯成员函数。如果找到它们，它会跳过带有关键字<code class="fe nk nl nm nn b">new</code>的<code class="fe nk nl nm nn b">child</code>类隐藏方法。这就是为什么在图4中，调用了<code class="fe nk nl nm nn b">parent</code>的<code class="fe nk nl nm nn b">SetFuelType()</code>方法。</p><p id="90ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:如果虚拟方法没有任何被覆盖的方法，那么<code class="fe nk nl nm nn b">parent</code>类将调用自己的方法。找不到被覆盖的实例。</p><p id="6d1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道这是一篇非常令人困惑和难以置信的文章，但是一旦你知道编译器是如何工作的，你就知道语言是如何工作的。</p><p id="23c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是编程的全部内容:理解编译器是如何工作的，任何语言都不会成为你的障碍。</p><pre class="kg kh ki kj gt nz nn oa ob aw oc bi"><span id="990f" class="od mo iq nn b gy oe of l og oh"><strong class="nn ir">Want to Connect?</strong></span><span id="3152" class="od mo iq nn b gy oi of l og oh">Hit me up on <a class="ae kv" href="https://www.linkedin.com/in/rikampalkar" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>.</span></pre></div></div>    
</body>
</html>