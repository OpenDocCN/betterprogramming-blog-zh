<html>
<head>
<title>Thread Sanitizer Explained: Data Races in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线程清除器解释:Swift中的数据竞争</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/thread-sanitizer-explained-data-races-in-swift-768e1a1efe61?source=collection_archive---------14-----------------------#2019-11-19">https://betterprogramming.pub/thread-sanitizer-explained-data-races-in-swift-768e1a1efe61?source=collection_archive---------14-----------------------#2019-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a557" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">修复古怪的测试、exc_bad_access和奇怪的崩溃</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1904693f4d7edc5f99b91c405a80ffd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qpi4_qHKZydwb0Dea1wHsg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿什利·朱利斯在Unsplash<a class="ae ky" href="https://unsplash.com/s/photos/data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><p id="8efe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Thread Sanitizer，也称为TSan <em class="lv">，</em>，是一个基于LLVM的工具，用于审计您的Swift和C语言编写的代码中的线程问题。它最初是在Xcode 8中引入的，可以作为一个很好的工具来发现代码中不太明显的问题。</p><p id="7ae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在WeTransfer，Thread Sanitizer帮助我们解决了古怪的测试和奇怪的崩溃，我们无法真正查明特定的原因。这个工具的作用和工作原理可能有点不清楚。因此，是时候深入解释如何使用线程杀毒器改进代码了。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b4f0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">什么是数据竞争？</h1><p id="e296" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在我们开始研究消毒剂之前，我们首先需要知道我们实际上在寻找什么。我们将解决一个叫做<em class="lv">数据竞赛</em>的问题。</p><p id="7a77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当多个线程在不同步的情况下访问同一个内存，并且至少有一次访问是写操作时，就会发生数据争用。数据竞争会导致几个问题:</p><ul class=""><li id="dba9" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">不可预知行为</li><li id="3a1c" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">内存损坏</li><li id="c796" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">古怪的测试</li><li id="7c69" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">奇怪的撞车</li></ul><p id="e382" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于数据竞争是不可预测的，所以在测试应用程序时，它可能会不一致地发生。您可能会在启动时崩溃，但第二次启动应用程序时不会再次发生。如果是这种情况，您可能正在处理一场数据竞赛。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3806" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Swift中的数据竞争示例</h1><p id="b6b0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">一旦你知道了什么是数据竞争，你就可以更好地检测代码中的潜在问题。然而，有时代码可能会导致数据竞争这一点不太清楚。这里有几个例子向您展示什么是数据竞赛。</p><p id="0fb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面这段代码中，两个不同的线程访问同一个<code class="fe no np nq nr b">String</code>属性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/3a47b9f71a449e7081e5786f95362d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4fph61Tnhk9sKiMW.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">线程清除器捕获的数据竞争示例</p></figure><p id="4281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于后台线程正在写这个名字，我们至少有一个写权限。这种行为是不可预测的，因为它取决于首先执行的是print语句还是write语句。这是一个由线程杀毒器确认的数据竞争的例子。</p><h2 id="29de" class="nt me it bd mf nu nv dn mj nw nx dp mn li ny nz mp lm oa ob mr lq oc od mt oe bi translated">懒惰变量导致的数据竞争</h2><p id="5c3c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">惰性变量将实例的初始化延迟到第一次被调用的时候。这意味着数据写入将在第一次访问惰性变量时发生。当两个线程第一次访问同一个惰性变量时，可能会发生数据竞争:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/6d6e85176c1a8c806984c69a87117af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hQBWTRdaJJjZyn46.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">懒惰变量导致的数据竞争</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1a34" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">使用线程清除器检测数据竞争</h1><p id="8bee" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">上面的例子告诉我们，数据竞争很容易发生。在小段代码中，您可能能够捕捉到这一点，但是随着项目的增长，这将变得更加困难。因此，是时候通过使用线程清除器获得一些帮助了。</p><p id="eb42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以对您的测试方案做同样的事情，这是一种捕捉数据竞争的有效方法。</p><h2 id="e3bd" class="nt me it bd mf nu nv dn mj nw nx dp mn li ny nz mp lm oa ob mr lq oc od mt oe bi translated">螺纹消毒剂是如何工作的？</h2><p id="c384" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">启用线程杀毒器后，您的应用将从头开始重建。将在每个内存访问周围添加代码，以检查某个访问是否参与竞争。上面的代码示例经过编译器转换后将如下所示:</p><pre class="kj kk kl km gt of nr og oh aw oi bi"><span id="11dd" class="nt me it nr b gy oj ok l ol om">func updateName() {<br/>    DispatchQueue.global().async {<br/>        self.recordAndCheckWrite(self.name)<br/>        self.name.append("Antoine van der Lee")<br/>    }<br/><br/>    // Executed on the Main Thread<br/>    self.recordAndCheckWrite(self.name)<br/>    print(self.name)<br/>}</span></pre><p id="848a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">recordAndCheckWrite</code>方法将为杀毒程序用来检测数据竞争的每个访问和每个线程存储一个时间戳。</p><h2 id="e927" class="nt me it bd mf nu nv dn mj nw nx dp mn li ny nz mp lm oa ob mr lq oc od mt oe bi translated">如何启用线程杀毒器</h2><p id="07bc" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">可以从方案配置中启用线程杀毒器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/b968298077bc4e01697ffdb58cfc8736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UDAY833LYLu2GAYV.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">可以从方案配置中启用线程杀毒器</p></figure><p id="2abd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以对您的测试方案做同样的事情，这是一种捕捉数据竞争的有效方法。</p><h2 id="ae00" class="nt me it bd mf nu nv dn mj nw nx dp mn li ny nz mp lm oa ob mr lq oc od mt oe bi translated">螺纹消毒剂有什么限制吗？</h2><p id="0fec" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">线消毒剂有一些限制:</p><ul class=""><li id="5846" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">它仅支持64位macOS和64位iOS和tvOS模拟器</li><li id="bdb1" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">不支持watchOS</li><li id="c5d9" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">您不能在设备上使用TSan</li></ul><h2 id="52b8" class="nt me it bd mf nu nv dn mj nw nx dp mn li ny nz mp lm oa ob mr lq oc od mt oe bi translated">性能影响</h2><p id="a60c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">正如从<a class="ae ky" href="https://developer.apple.com/documentation/code_diagnostics/thread_sanitizer" rel="noopener ugc nofollow" target="_blank">苹果文档</a>中引用的，使用TSan会导致性能下降:</p><blockquote class="on oo op"><p id="ac22" class="kz la lv lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated">“在启用线程清除器检查的情况下运行您的代码可能会导致2⨉到20⨉的CPU速度降低，以及5⨉到10⨉.的内存使用量增加您可以通过在-O1优化级别进行编译来提高内存利用率和CPU开销。— Apple Thread Sanitizer文档</p></blockquote></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="bee7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">如何解决数据竞赛</h1><p id="4795" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在您了解了什么是数据竞争以及如何检测它们之后，是时候写一个解决方案了，这样它们就不会再发生了。以上述示例为例，我们可以编写如下解决方案:</p><pre class="kj kk kl km gt of nr og oh aw oi bi"><span id="6533" class="nt me it nr b gy oj ok l ol om">private let lockQueue = DispatchQueue(label: "name.lock.queue")<br/>private var name: String = "Antoine van der Lee"<br/><br/>func updateNameSync() {<br/>    DispatchQueue.global().async {<br/>        self.lockQueue.async {<br/>            print(self.name)<br/>        }<br/>    }<br/><br/>    // Executed on the Main Thread<br/>    lockQueue.async {<br/>        // Executed on the lock queue<br/>        print(self.name)<br/>    }<br/>}<br/><br/>// Prints:<br/>// Antoine van der Lee<br/>// Antoine van der Lee</span></pre><p id="8715" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用锁队列，我们同步了访问，并确保name变量一次只被一个线程访问。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b4c9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="3d68" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">就是这样！深入探讨Swift中的数据竞争。希望您可以开始捕获bug并修复一些在您的代码中存在了很长时间的崩溃。</p><p id="8bbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有任何额外的提示或反馈，请随时留下您的评论。</p><p id="944f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢！</p></div></div>    
</body>
</html>