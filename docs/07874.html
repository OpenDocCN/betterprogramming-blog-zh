<html>
<head>
<title>The Implicit Sides of Python — 4 Notable Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python隐含的一面——4个显著的特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-implicit-sides-of-python-4-notable-features-961939f224e4?source=collection_archive---------6-----------------------#2021-03-01">https://betterprogramming.pub/the-implicit-sides-of-python-4-notable-features-961939f224e4?source=collection_archive---------6-----------------------#2021-03-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="99d9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">知道引擎盖下发生了什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/94b7dc8ea92b676d9313e35acc30597a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*osfHpXhxJhGgJ42M"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@lamine__belhadj?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">贝尔哈德·拉明</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="edf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个众所周知的Python技巧是在你的Python控制台中展示Python的禅宗。在《Python的禅》一书中，作者Tim Peters为编写Python程序创造了19条指导原则。第二个原则是“显式比隐式好”，这意味着当我们编写Python代码时，它应该足够显式，无需过多的口头解释就能说出它做了什么。</p><p id="6ccb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，许多Python特性的实际实现涉及到幕后的隐式操作。在本文中，我想回顾五个这样的特性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6337" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.实例方法的调用</h1><p id="01b3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Python类中，我们声明实例对象可以调用的实例方法。您可能知道，这些实例方法都有一个额外的参数，通常称为<code class="fe mz na nb nc b">self</code>。这个<code class="fe mz na nb nc b">self</code>参数指的是将要调用该方法的实例对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自定义类别</p></figure><p id="6bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，<code class="fe mz na nb nc b">speak</code>方法包含了<code class="fe mz na nb nc b">self</code>参数，使其成为一个实例方法。然而，当我们对一个实例对象使用这个方法时，我们不会显式地对这个参数做任何事情。相反，实例对象不带任何参数调用此函数，如下所示:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="9155" class="nj md it nc b gy nk nl l nm nn">&gt;&gt;&gt; person0 = Person()<br/>&gt;&gt;&gt; person0.speak()<br/>Speak method is called by &lt;__main__.Person object at 0x11a8b04c0&gt;</span></pre><p id="1897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在幕后(或隐式)，实例方法的调用涉及属性查找链，这导致通过包装器使用类的<code class="fe mz na nb nc b">speak</code>函数。实际上，代码<code class="fe mz na nb nc b">person0.speak()</code>被执行为<code class="fe mz na nb nc b">Person.speak(person0)</code>。如果您有兴趣更深入地理解底层机制，您可以看看在<a class="ae ky" href="https://docs.python.org/3/howto/descriptor.html#invocation-from-an-instance" rel="noopener ugc nofollow" target="_blank">官方文档</a>中说明的实例对象的调用链。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1740" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.特殊方法</h1><p id="71f9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Python中，我们使用两对下划线，一对在函数名之前，另一对在函数名之后，来表示一个特殊的方法。有些人把这些称为魔术方法或邓德尔斯。Python中有许多特殊的方法，它们在适用的情况下被隐式或自动调用。</p><p id="1caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，当创建一个对象时，调用最著名的特殊方法<code class="fe mz na nb nc b">__init__</code>。值得注意的是，我们自己并不直接调用<code class="fe mz na nb nc b">__init__</code>。相反，我们使用类名来间接调用这个方法。</p><p id="fa63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更一般地说，许多内置函数(例如<code class="fe mz na nb nc b">len</code>、<code class="fe mz na nb nc b">callable</code>)都有它们相关的特殊方法，允许你覆盖它们来定义你的类中的定制行为。让我们考虑下面这个微不足道的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在重写特殊方法之前</p></figure><p id="a629" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们尝试执行两个操作——这两个操作都不起作用。请注意，这对括号被称为调用操作符(即调用某些东西，如调用函数):</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="ac46" class="nj md it nc b gy nk nl l nm nn">&gt;&gt;&gt; person1 = Person1("John Smith", 38)<br/>&gt;&gt;&gt; len(person1)<br/>Traceback (most recent call last):<br/>  File "&lt;input&gt;", line 1, in &lt;module&gt;<br/>TypeError: object of type 'Person1' has no len()<br/>&gt;&gt;&gt; person1()<br/>Traceback (most recent call last):<br/>  File "&lt;input&gt;", line 1, in &lt;module&gt;<br/>TypeError: 'Person1' object is not callable</span></pre><p id="ce6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使它们工作，我们需要覆盖该类的底层特殊方法，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">重写特殊方法后</p></figure><ul class=""><li id="5772" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">我们覆盖了<code class="fe mz na nb nc b">__len__</code>方法。通过这次更新，我们可以看到，调用内置的<code class="fe mz na nb nc b">len()</code>方法隐式地调用了这个特殊的方法。</li></ul><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="96f7" class="nj md it nc b gy nk nl l nm nn">&gt;&gt;&gt; person1 = Person1("John Smith", 38)<br/>&gt;&gt;&gt; len(person1)<br/>__len__ is invoked<br/>38</span></pre><ul class=""><li id="d168" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">以类似的方式，我们覆盖了<code class="fe mz na nb nc b">__call__</code>方法，我们可以看到调用操作符现在使用实例对象。更重要的是，底层的<code class="fe mz na nb nc b">__call__</code>特殊方法被调用。或者:</li></ul><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="2973" class="nj md it nc b gy nk nl l nm nn">&gt;&gt;&gt; person1()<br/>__call__ is invoked<br/>'John Smith'</span></pre><ul class=""><li id="ed32" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">在一般意义上，这些操作相当于使用底层的特殊方法。例如，<code class="fe mz na nb nc b">len(person1)</code>实际上就是<code class="fe mz na nb nc b">person1.__len__()</code>。Python只是隐式地为我们调用底层的特殊方法。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1b20" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.装饰函数</h1><p id="8ea6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">装饰器是高阶函数，它向被装饰函数添加额外的行为，而不改变被装饰函数的实际实现。考虑下面的例子来理解装饰者做什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">装饰示例</p></figure><ul class=""><li id="0669" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">装饰器被命名为<code class="fe mz na nb nc b">alert</code>，它简单地告诉我们被装饰的函数被调用。</li><li id="fe27" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">我们通过把装饰器放在被装饰的函数上面来使用它。当我们调用修饰函数时，我们会看到类似这样的内容:</li></ul><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="d96c" class="nj md it nc b gy nk nl l nm nn">&gt;&gt;&gt; greeting("John")<br/>Alert: greeting is being called.<br/>Hello, John!</span></pre><p id="2d21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修饰所隐含的是，被修饰的函数实际上是由修饰函数创建的闭包。换句话说，函数修饰的过程实际上如下:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="0687" class="nj md it nc b gy nk nl l nm nn">&gt;&gt;&gt; def greeting1(person):<br/>...     print(f"Hello, {person}!")<br/>&gt;&gt;&gt; # Create the closure to provide decoration<br/>&gt;&gt;&gt; greeting1 = alert(greeting1)<br/>&gt;&gt;&gt; greeting1("John")<br/>Alert: greeting1 is being called.<br/>Hello, John!</span></pre><ul class=""><li id="d1d1" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">第一步是像我们通常做的那样定义函数。</li><li id="062b" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">第二步，将此函数发送给更高阶的函数(即<code class="fe mz na nb nc b">alert</code>)进行修饰。如您所见，返回值是一个内部函数，它定义在<code class="fe mz na nb nc b">alert</code>函数体内。</li></ul><p id="b589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当我们使用装饰特性时，我们依赖Python隐式地将即将被装饰的函数发送给装饰器，并将包装后的函数分配给原始函数名。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f8dc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.迭代次数</h1><p id="e639" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">开发人员通常通过简单地插入一个<code class="fe mz na nb nc b">for</code>循环来使用迭代来避免重复代码。以下代码向您展示了一个简单的迭代示例:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="4968" class="nj md it nc b gy nk nl l nm nn"># A simple iteration<br/>numbers = [1, 2]<br/>for a in numbers:<br/>    print(a)</span></pre><p id="de95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更一般地，迭代具有以下一般格式:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="3f1c" class="nj md it nc b gy nk nl l nm nn">for item in iterable:<br/>    pass</span></pre><p id="2306" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是迭代期间到底发生了什么？为了更深入地了解这个特性，让我们考虑下面的自定义类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自定义可迭代</p></figure><ul class=""><li id="27f0" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">在Python中，iterables是可以迭代的对象，它们实现了特殊的<code class="fe mz na nb nc b">__iter__</code>方法。</li><li id="8c8e" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">然而，为了使iterables可以在一个<code class="fe mz na nb nc b">for</code>循环中使用，我们必须实现<code class="fe mz na nb nc b">__next__</code>方法，该方法使迭代器让Python知道如何检索下一项。</li></ul><p id="6512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何在一个<code class="fe mz na nb nc b">for</code>循环中使用这个自定义类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用自定义迭代器进行迭代</p></figure><ul class=""><li id="3622" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">执行这个<code class="fe mz na nb nc b">for</code>循环的第一个值得注意的事情是通过调用<code class="fe mz na nb nc b">__iter__</code>方法隐式创建一个迭代器，正如打印输出所证明的。</li><li id="cea1" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">在迭代过程中，每次迭代都会隐式调用<code class="fe mz na nb nc b">__next__</code>方法来检索下一个可用项。</li><li id="e40c" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">在迭代完所有可用的项目后，我们通过引发<code class="fe mz na nb nc b">StopIteration</code>异常来完成迭代。然而，我们在控制台中看不到这样的异常。这是因为Python已经在常规的<code class="fe mz na nb nc b">for</code>循环迭代中隐式地为我们处理了异常。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5b7c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="6761" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们回顾了四个重要的Python特性，它们涉及一些隐含的操作。了解这些机制将让我们更好地掌握Python的特性。这里有一个快速回顾:</p><ul class=""><li id="f014" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">实例方法的调用包括创建一个中间包装器，该包装器使用类中定义的相应函数。此外，调用对象也被发送给函数进行评估。</li><li id="33ea" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">许多函数(如<code class="fe mz na nb nc b">len</code>)都有相应的特殊方法负责这些行为。</li><li id="d991" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">函数修饰包括创建一个内部函数，它是在decorator函数中定义的。本质上，修饰函数是一个闭包。</li><li id="6c6e" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">迭代涉及迭代器的创建，两个特殊的方法(<code class="fe mz na nb nc b">__iter__</code>和<code class="fe mz na nb nc b">__next__</code>)在执行迭代时很重要。此外，Python隐式地为我们处理了<code class="fe mz na nb nc b">StopIteration</code>异常。</li></ul></div></div>    
</body>
</html>