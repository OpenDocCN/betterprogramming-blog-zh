<html>
<head>
<title>How to Query Multiple APIs With ‘DispatchWorkItem’ and ‘DispatchGroup’</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用“DispatchWorkItem”和“DispatchGroup”查询多个API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-query-multiple-apis-with-dispatchworkitem-and-dispatchgroup-41a757692367?source=collection_archive---------11-----------------------#2020-06-03">https://betterprogramming.pub/how-to-query-multiple-apis-with-dispatchworkitem-and-dispatchgroup-41a757692367?source=collection_archive---------11-----------------------#2020-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="01a0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用“DispatchWorkItem”和“DispatchGroup”构建一个简单的搜索屏幕，以便对多个源进行多个异步服务调用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/572bddd9d41d0412be731cfa9d6a4706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vBR_Z-0Ss9N2Z7ZLRRvZjQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@thisisengineering?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">在</a><a class="ae ky" href="https://unsplash.com/collections/9641853/i-am-a-creator%3A-chaitra-radhakrishna?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="bfa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里找到这篇文章的组合框架版本</p><p id="9882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/better-programming/how-to-query-multiple-apis-with-the-combine-framework-1c4e0298418e" rel="noopener">https://medium . com/better-programming/how-to-query-multiple-API-with-the-combine-framework-1c4e 0298418 e</a></p><p id="cd96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，您希望在一个动作被触发时完成一项任务，但您无法区分该动作和完成事件。</p><p id="a488" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，有些动作会被触发，但是你不知道这些动作是否是最后一个。</p><p id="63e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，您要做的就是延迟启动任务。如果事件继续发生，您可以取消之前的任务并开始新的任务。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/8955c338b5ee99909d9f6c3448afb551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wUZg9qJVWkgIn2iWAT8Fqg.png"/></div></div></figure><p id="e885" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自动完成是这种情况的一个很好的例子。每次按键时，自动完成功能都会提供一些快捷方式选项。很有用。这样的功能让用户体验更好。</p><p id="0bc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们能造出这样的东西吗？嗯，你每敲一次键就打一个服务电话，取消前一个电话。但是，根据网络速度或打字速度，您可能无法按时取消您的请求。</p><p id="8479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的请求在您取消之前就到达了您的服务器，这将为您的服务器创建太多的请求来处理，最终可能导致您的服务器过载。你不想那样。</p><p id="f967" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能做的就是使用延迟机制。我们将建立一个搜索屏幕，用户可以写一个主题，并看到与该主题相关的图像。我们将查询两个不同的源(用于<a class="ae ky" href="https://unsplash.com/documentation#example-image-use" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>和<a class="ae ky" href="https://www.pexels.com/api/documentation/" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的API)。让我们从基础开始。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="70fa" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">' DispatchWorkItem '</h1><p id="fb65" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">使用<code class="fe na nb nc nd b"><a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchworkitem" rel="noopener ugc nofollow" target="_blank">DispatchWorkItem</a></code>，您可以在<code class="fe na nb nc nd b">DispatchQueue</code>中运行您的代码块，并随时取消它(在任务完成之前)。</p><h2 id="e2e6" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated"><em class="nq">样本代码</em></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="bc3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在你的操场上试试这段代码，然后观察结果。</p><p id="660b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您在每次击键时都调用了<code class="fe na nb nc nd b">search</code>函数。它可能在一个<code class="fe na nb nc nd b">UITextFieldDelegate</code>或<code class="fe na nb nc nd b">UISearchController</code>方法中。<code class="fe na nb nc nd b">search</code>功能将完成这项工作。</p><p id="fe51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码已经足够好了。然而，这不是完美的解决方案。用户键入的速度可能太慢，以至于一秒钟的操作延迟可能不够。</p><p id="4756" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，这里有两个异步操作。一个是延迟，一个是网络运营。我们总是取消第一个。如果我们能继承<code class="fe na nb nc nd b">DispatchWorkItem</code> <strong class="lb iu"> </strong>和<strong class="lb iu"> </strong>来覆盖取消<strong class="lb iu"> </strong>方法就好了。</p><p id="af4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这样做，我们也将取消我们的网络运营。但是我们不能这样做，因为出于某种原因<code class="fe na nb nc nd b">DispatchWorkItem</code>不是一个公开课。如果你尝试，你会看到这样的错误信息。</p><pre class="kj kk kl km gt nt nd nu nv aw nw bi"><span id="d4fc" class="ne me it nd b gy nx ny l nz oa">Cannot inherit from non-open class 'DispatchWorkItem' outside of its defining module</span></pre><p id="8030" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">别担心。您仍然可以使用操作 API通过<a class="ae ky" href="https://developer.apple.com/documentation/foundation/operation" rel="noopener ugc nofollow" target="_blank">取消您的网络操作并延迟您的操作。是苹果提供的另一个API。在这篇文章中我不打算详细讨论操作。如果那是你正在寻找的，你可能想要检查其他文章或博客。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6b5f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">'调度组'</h1><div class="ob oc gp gr od oe"><a href="https://developer.apple.com/documentation/dispatch/dispatchgroup" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">调度组</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">声明组允许您聚合一组任务并同步组上的行为。您附加了多个…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">developer.apple.com</p></div></div></div></a></div><p id="363f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe na nb nc nd b">DispatchGroup</code>，您可以观察多个异步操作作为单个任务的结果。</p><p id="760f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设您需要发出两个网络请求来收集关于您的用户的信息。当然，您可以用一个bool变量来处理这种情况。但是不要这样做！如果你必须发出两个以上的网络请求，那就很难管理了。有一种更简单、更优雅的方法可以做到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt nt nd nu nv aw nw bi"><span id="d9ee" class="ne me it nd b gy nx ny l nz oa"><strong class="nd iu">getImages starting...<br/>getFollowers starting...<br/>Notify starting...<br/>getImages finishing...<br/>getFollowers finishing...<br/>Notify finishing...</strong></span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="895f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">让我们把它们放在一起</h1><p id="e412" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们将使用<code class="fe na nb nc nd b">DispatchWorkItem</code>和<code class="fe na nb nc nd b">DispatchGroup</code> <strong class="lb iu"> </strong>对不同的API进行多个异步服务调用。我已经使用了<a class="on oo ep" href="https://medium.com/u/2053395ac335?source=post_page-----41a757692367--------------------------------" rel="noopener" target="_blank"> Unsplash </a>和<a class="on oo ep" href="https://medium.com/u/5c7773c5a002?source=post_page-----41a757692367--------------------------------" rel="noopener" target="_blank">Pexels</a>API来构建下面的示例。当然，我们可以改进UX，让它看起来更好。但不是今天的话题，我就不说了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/363fba9636e86bd01371e0c1b139386f.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/1*vnAf-X_YIbF8HluqUDVBaw.gif"/></div></figure><p id="288c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8a28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们一直等到查询字符串超过三个字符。然后，我们取消任何等待的请求，并创建一个新的请求。之后，我们在<code class="fe na nb nc nd b">services</code>数组中搜索来自每个API的查询字符串。我们使它异步，这意味着所有的请求是同时(几乎)发出的。</p><p id="5ca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第22行，我们等待每个API的结果，并用URL的组合数组调用完成回调。这个过程不会立即运行。相反，它封装在<code class="fe na nb nc nd b">DispatchWorkItem</code>中。每次调用第28行的<code class="fe na nb nc nd b">search</code>函数时，这个<code class="fe na nb nc nd b">DispatchWorkItem</code>的执行都会延迟。</p><p id="638f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，<code class="fe na nb nc nd b">DispatchWorkItem</code>将被执行，完成将被调用。正如您所看到的，您可以使用本机API轻松地将来自多个数据源的多个网络调用结合起来。你可以在底部找到完整的源代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="71b7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="f856" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">对于这类任务，您不需要使用第三方库。本机库可以很容易地做到这一点。我建议您首先学习本机方法，然后决定是否使用第三方库。感谢您的阅读。</p><div class="ob oc gp gr od oe"><a href="https://github.com/ibrahimoktay/AsyncProgramming" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">Ibrahim oktay/异步编程</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">演示应用程序-使用DispatchWorkItem和DispatchGroup。通过创建……为ibrahimoktay/async编程开发做出贡献</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oe"/></div></div></a></div></div></div>    
</body>
</html>