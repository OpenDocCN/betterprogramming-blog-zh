<html>
<head>
<title>How To Write Generic Helper Functions With Go 1.18 — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Go 1.18编写通用助手函数—第2部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-generic-helper-functions-with-go-1-18-part-2-19e3d2ab45f5?source=collection_archive---------13-----------------------#2022-05-25">https://betterprogramming.pub/how-to-write-generic-helper-functions-with-go-1-18-part-2-19e3d2ab45f5?source=collection_archive---------13-----------------------#2022-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c5b0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们创建一个map函数，它调用数组/切片中每个元素的回调</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2a4685b5664cb0dc404da43cdbcce1bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MZtHPDf4d3I_SfGxJ24xkA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">地鼠是由埃贡·厄尔布尔画的。</p></figure><p id="95d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我们将创建一个函数，为数组/片的每个元素调用一个回调函数来调整各自的值并返回它。现在，你可能会问自己，“管它呢！我为什么要这么做？”。想象一下，如果你必须将数组中的每个单词都大写，反转布尔值，或者将每个数字相乘。</p><p id="285d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在许多类似的情况下，这样的函数会很有用。可惜在围棋中，你得自己开发这样的地图功能。但是不用担心。今天我们来看看如何自己实现这种功能。所以系好安全带，我们开始吧。</p><blockquote class="ls lt lu"><p id="c24c" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">这是我新系列的第三篇文章。在第一部分的<a class="ae kv" href="https://henrysteinhauer.medium.com/how-to-write-generic-helper-functions-with-go-d47c52986016" rel="noopener">中，我已经谈了一点关于泛型的内容。这不是必需的，但可能会有所帮助。</a></p></blockquote><h1 id="5e75" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">介绍</h1><p id="e36d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">开始前有一件事。对于我们的解决方案，我们需要泛型。这意味着我们必须再次使用Golang版本。</p><h1 id="da1a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">方法</h1><p id="19c9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们想要的非常简单，可以分为三个步骤:</p><ol class=""><li id="3d2c" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">我们希望对数组/切片中的每个元素调用回调。</li><li id="044b" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">调整后的值应该存储在新的切片中。</li><li id="d1ed" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">最后，该函数应该返回调整后的值。</li></ol><h1 id="605d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">解决办法</h1><p id="d129" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">为此，我们的函数需要两个参数。第一个是我们的数组，第二个是回调。下面，你可以看到我们主要的<code class="fe nk nl nm nn b">Map</code>功能。我们遍历数组，用每个项目调用回调函数，并将调整后的值追加到新的切片中。最后，我们要做的就是返回我们的新切片。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7910" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们只需要调整一种类型的数组/切片的值，这个解决方案就足够了。但是如果有不同类型的数组，我们需要为每种类型实现相同的函数。这导致了完全笨拙和重复的代码库。为了避免这种情况，我们可以像第一篇文章一样使用泛型。但是这一次，我们使用了不同的泛型类型。</p><h1 id="c6f5" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">丰富</h1><p id="0f35" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">上次，我们使用了“可比较的”泛型类型。这一次，我们需要通用类型“any”正如您在下面看到的，我们需要将我们的类名<code class="fe nk nl nm nn b">T</code>写在函数名后面的括号中，并将其类型设为“any”我们还给出了两个参数类型<code class="fe nk nl nm nn b">T</code>以及临时结果片。这允许我们指定我们的函数所期望的数组类型以及结果片应该是什么类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4a92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用它，我们必须进行以下函数调用:<br/> <code class="fe nk nl nm nn b">Map[int]([1, 2], func(num int){return num + 1})</code>。<br/>括号中的单词“int”指定了我们的泛型类型。</p><h1 id="1a5c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">基准</h1><p id="4d3a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">最后，我们对每个解决方案运行表基准测试，以证明我们在使用通用版本时没有任何关键的性能问题。下面你可以看到测试命令以及测试结果。</p><pre class="kg kh ki kj gt nq nn nr ns aw nt bi"><span id="fddd" class="nu ma iq nn b gy nv nw l nx ny">go test -bench="BenchmarkMap" -run=^# -benchtime=10000x</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/6f004dd7a85e2838e24f84e856455242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tLNCWNsrp-IiRVFqlinTag.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基准映射函数</p></figure><p id="fa61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和上次一样，与通用版本相比，静态版本的每个操作的纳秒数几乎相同。事实上，如果你看第四个样本，情况正好相反。<code class="fe nk nl nm nn b">MapInt</code>函数的第四个例子有点突出，但这只发生在这次运行中。我又运行了几个测试，总的来说，两个测试每次操作花费的时间是一样的。</p><h1 id="2798" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="fdb6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我希望对数组中的每个元素调用回调的方法是有趣且有帮助的。如果你有其他的解决方案，一些要提及的事情，或者问题，如果你能在评论中留下它们，那就太好了。回头见。</p><p id="5bfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">附:这是我计划的新系列的第三篇文章。在接下来的几周里，我将研究各种通用的助手函数、有趣的基准和有用的特性。</p><p id="58b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你和我一样兴奋，敬请期待！</p></div></div>    
</body>
</html>