<html>
<head>
<title>How to Stop Kubenetes From DOSing Your Application During Deployment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在部署期间阻止Kubenetes给应用程序添加剂量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-stop-kubenetes-from-dosing-your-application-during-deployment-42672b4dfa42?source=collection_archive---------16-----------------------#2020-03-11">https://betterprogramming.pub/how-to-stop-kubenetes-from-dosing-your-application-during-deployment-42672b4dfa42?source=collection_archive---------16-----------------------#2020-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5404" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入了解K8s部署</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2fdb95ee388b836e072aae9c77efe78c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vr3mUCBqZ4lBh01ZEok5Hg.png"/></div></div></figure><p id="7312" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">没有正确的上下文，图表可能会很吓人。上图显示了特定应用程序每秒发送到Pods的请求数。</p><p id="ac65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可怕的是，这个应用程序每秒只能接收大约120个请求。红线最大值是166，紫色的也不远了。实际上，这是对这些应用程序的拒绝服务。</p><p id="d5c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文探讨了Kubernetes为什么这样做，以及如何防止这种情况。</p><ul class=""><li id="7d3f" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">DOS —拒绝服务，一种使资源不可用的网络攻击，通常通过向系统发送大量请求来实现。参见<a class="ae lz" href="https://en.wikipedia.org/wiki/Denial-of-service_attack" rel="noopener ugc nofollow" target="_blank">维基百科</a>了解更多信息。</li></ul></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="0df4" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">那么，这是怎么回事？</h1><p id="4bc6" class="pw-post-body-paragraph ku kv it kw b kx mz ju kz la na jx lc ld nb lf lg lh nc lj lk ll nd ln lo lp im bi translated">该图的时间范围大约是这个应用程序发布的时间，一个新版本被部署到Kubernetes (K8s)集群。它是使用K8s <code class="fe ne nf ng nh b">deployment</code>部署的，该K8s<code class="fe ne nf ng nh b">deployment</code>处理优雅的卷展，但是如本例中的图表所示，它并不优雅。</p><p id="179d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个吊舱在图上是一条不同的彩色线，在15:28之前，你可以看到新的彩色线出现。这是新版本的应用程序带来了新的Pods。</p><p id="c167" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在发布之前和之后，每个Pod的每秒请求数是稳定的，Pod收到的请求数大致相同。</p><p id="5e26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可悲的是，就在发布之前，一个Pod显示它的流量少得多，而另外两个Pod看起来流量大得多。这与K8s默认部署方式有关。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="8e61" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">Kubernetes部署策略</h1><p id="053a" class="pw-post-body-paragraph ku kv it kw b kx mz ju kz la na jx lc ld nb lf lg lh nc lj lk ll nd ln lo lp im bi translated">K8s有两种方法对部署进行更改。他们是<em class="ni">滚动更新</em>和<em class="ni">再造</em>部署。</p><p id="895f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">重新创建部署会删除所有现有单元，然后创建包含更新的新单元。如果您想要零停机部署，这是不合适的，因为客户可能会在新pod等待变得健康时收到错误。</p><p id="1833" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一种选择，滚动更新，缓慢地引入和移除吊舱，保持一些健康的吊舱在服务中。滚动更新策略是默认策略，有关更多信息，请查看<a class="ae lz" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="83f1" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">听起来不错。有什么问题？</h1><p id="18dd" class="pw-post-body-paragraph ku kv it kw b kx mz ju kz la na jx lc ld nb lf lg lh nc lj lk ll nd ln lo lp im bi translated">这个特定的应用程序使用K8s自动缩放。因此，当服务接收到更多的流量时，就会创建更多的实例来处理负载。这意味着，如果不进行扩展，它就没有足够的容量来处理更多的请求。</p><p id="4d19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个问题的关键是<code class="fe ne nf ng nh b">maxUnavailable</code>部署属性，这是部署期间可以移除的单元数量或单元百分比。</p><p id="2a59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认情况下，这是25%。这意味着，一旦部署开始，在引入任何新的应用单元之前，25%的应用单元将被删除。由于自动伸缩，服务接近饱和，我们的服务在部署过程中会过载。</p><p id="142a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解决方案相当简单，在您的部署中设置<code class="fe ne nf ng nh b">maxUnavailabe</code>到<code class="fe ne nf ng nh b">0</code>，这将在移除旧的pod之前引入新的pod，为请求数量保留足够的容量。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="5fbb" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">演示时间</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2fd7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的K8s配置创建了一个有四个pod的NGINX部署，策略设置为滚动更新，<code class="fe ne nf ng nh b">maxUnavailable</code>设置为<code class="fe ne nf ng nh b">0</code>。</p><p id="19fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">复制该文件并将其保存在本地，K8s集群通过<a class="ae lz" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank"> Docker </a>或<a class="ae lz" href="https://kubernetes.io/docs/tasks/tools/install-minikube/" rel="noopener ugc nofollow" target="_blank"> Minikube </a>在本地运行。运行kubectl的<code class="fe ne nf ng nh b">apply -f <a class="ae lz" href="https://gist.github.com/HarryEMartland/87f66b09b0460c2ebd86e50d97439018#file-rolling-update-example-yaml" rel="noopener ugc nofollow" target="_blank">rolling-update-example.yaml</a></code>，这将创建部署。</p><p id="8b13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了监控部署的行为，我建议使用<a class="ae lz" href="https://github.com/derailed/k9s" rel="noopener ugc nofollow" target="_blank"> K9s </a>，因为它会自我更新并给你一个漂亮的UI。运行<code class="fe ne nf ng nh b">k9s</code>，您应该会看到一个基于文本的UI，显示了四个窗格。</p><p id="f2db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在是时候更新应用程序了，将<code class="fe ne nf ng nh b">image</code>改为<code class="fe ne nf ng nh b">nginx:1.17.9 </code>，然后重新应用文件。当<code class="fe ne nf ng nh b">maxUnavailable</code>设置为<code class="fe ne nf ng nh b">0</code>时，您应该会看到在删除任何旧的Pod之前创建了一个新的Pod。</p><p id="a24b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，当新的吊舱变得健康时，旧的吊舱被删除，循环重复，保持四个吊舱随时准备就绪。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/7061da030d7bc3e71589faef3d86a108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/1*EKcKRfSaS0jp6tQL-44ICg.gif"/></div><p class="nm nn gj gh gi no np bd b be z dk translated">K9s显示部署</p></figure><p id="fdda" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们删除配置中的整个策略部分(包括第6-9行)，将NGINX映像改回<code class="fe ne nf ng nh b">nginx:1.17.8</code>，并重新应用该文件，我们将看到不同的行为。</p><p id="d775" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一次，我们看到一个现有的Pod被直接删除，同时新的Pod被创建。在整个部署过程中，只有三个pod准备就绪，为流量提供服务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/6cc72bc7ef9ab87c6fe3c0274571ee70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/1*jZTSiHpNuiBUg9jXYdMPmQ.gif"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="2922" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="a3b5" class="pw-post-body-paragraph ku kv it kw b kx mz ju kz la na jx lc ld nb lf lg lh nc lj lk ll nd ln lo lp im bi translated">部署时，留意它的行为是很重要的。注意不均衡的负载和比预期流量多或少的实例。</p><p id="f67a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您使用Kubernetes和自动缩放，您可能希望将<code class="fe ne nf ng nh b">maxUnavailable</code>设置为<code class="fe ne nf ng nh b">0</code>。有关这方面的更多信息，请参见<a class="ae lz" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy" rel="noopener ugc nofollow" target="_blank"> K8s文档</a>。</p></div></div>    
</body>
</html>