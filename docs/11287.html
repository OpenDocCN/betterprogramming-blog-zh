<html>
<head>
<title>Understanding Zero-Knowledge Proofs Through the Source Code of Tornado Cash</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Tornado Cash的源代码理解零知识证明</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f?source=collection_archive---------1-----------------------#2022-03-07">https://betterprogramming.pub/understanding-zero-knowledge-proofs-through-the-source-code-of-tornado-cash-41d335c5475f?source=collection_archive---------1-----------------------#2022-03-07</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="93ce" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">零知识证明，深入智能合同的世界</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/7b9bfe3e92669989628d51d501a38f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uJmdJkcXqGykJWRm"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">来源:https://unsplash.com/photos/JrrWC7Qcmhs</p></figure><p id="8da5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">基于<a class="ae kw" href="https://en.wikipedia.org/wiki/Zero-knowledge_proof" rel="noopener ugc nofollow" target="_blank">维基百科</a>，零知识证明(ZKP)的定义如下:</p><blockquote class="lt lu lv"><p id="2ef7" class="kx ky lw kz b la lb js lc ld le jv lf lx lh li lj ly ll lm ln lz lp lq lr ls ik bi translated">…零知识证明或零知识协议是一种方法，通过这种方法，一方(证明者)可以向另一方(验证者)证明给定的陈述是真实的，同时证明者避免传达除了陈述确实是真实的事实之外的任何附加信息。零知识证明的本质是，通过简单地揭示信息来证明一个人拥有某种信息的知识是微不足道的；面临的挑战是在不披露信息本身或任何其他信息的情况下证明这种拥有。</p></blockquote><p id="ecae" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">ZKP的技术可以广泛应用于许多不同的领域，如匿名投票或匿名转账，这些问题很难在区块链这样的公共数据库中解决。</p><p id="c7bb" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><a class="ae kw" href="https://tornado.cash/" rel="noopener ugc nofollow" target="_blank"> Tornado Cash </a>是一个硬币混合器，你可以用它来匿名化你的以太坊交易。因为区块链的逻辑，每一笔交易都是公开的。如果你的账户上有一些ETH，你不能匿名转账，因为任何人都可以在区块链上跟踪你的交易历史。像Tornado Cash这样的硬币混合器可以通过使用ZKP打破源地址和目的地址之间的链上链接来解决这个隐私问题。</p><p id="b20f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果你想匿名化你的一笔交易，你必须在Tornado现金合约(例如:1 ETH)。过一会儿，你可以用不同的账户提取这笔钱。诀窍在于，没人能在储户账户和取款账户之间建立联系。如果数百个账户在一边存入1 ETH，而其他数百个账户在另一边提取1 ETH，那么没有人能够跟踪资金流动的路径。技术上的挑战是，智能合约交易也像以太坊网络上的任何其他交易一样是公开的。这就是ZKP的相关之处。</p><p id="a0be" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当你在合同上签字时，你必须提供一份“承诺”。该承诺由智能合约存储。在对方撤回1 ETH的时候，你要提供一个“作废器”和一个零知识证明。作废者是与承诺相关联的唯一ID，ZKP证明了这种关联，但是没有人知道哪个作废者被分配给了哪个承诺(除了存款人/提款账户的所有者)。</p><p id="2922" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">再次声明:我们可以证明其中一个承诺被分配给我们的取消者，而不暴露我们的承诺。</p><p id="501f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">取消者由智能合约跟踪，因此我们只能通过一个取消者提取一个存放的ETH。</p><p id="849a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">听起来很容易？不是的！:)让我们深入技术内部。但在此之前，我们必须了解另一件棘手的事情，那就是<a class="ae kw" href="https://en.wikipedia.org/wiki/Merkle_tree" rel="noopener ugc nofollow" target="_blank"> Merkle树</a>。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ma"><img src="../Images/2d340660c73338c98e48bb589f33acb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GfKImZAfzpvxdPX4xNJKXg.png"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">来源:https://en.wikipedia.org/wiki/Merkle_tree<a class="ae kw" href="https://en.wikipedia.org/wiki/Merkle_tree" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="a7f9" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Merkle树是散列树，其中叶子是元素，每个节点是子节点的散列。树的根是Merkle根，它代表整个元素集。如果您添加、删除或更改树中的任何元素(叶子)，Merkle根将会改变。Merkle根是元素集的唯一标识符。但是怎么用呢？</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj mb"><img src="../Images/c66f251f0b190c105e9037b82ef6fa43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PdCWjHFRJkUVv6Wr.png"/></div></div></figure><p id="9266" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">还有一个东西叫Merkle proof。如果我有一个Merkle根，你可以发给我一个Merkle证明，证明一个元素在这个根所代表的集合中。下图显示了它是如何工作的。如果你想向我证明H <em class="lw"> K </em>在集合中，你得把H <em class="lw"> L </em>，H <em class="lw"> IJ </em>，H <em class="lw"> MNOP </em>，H <em class="lw"> ABCDEFGH </em>哈希发给我。使用这些散列，我可以计算出Merkle根。如果根与我的根相同，那么H <em class="lw"> K </em>在集合中。我们可以在哪里使用它？</p><p id="fa94" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">一个简单的例子就是白名单。想象一个智能契约，它有一个只能被白名单中的用户调用的方法。问题是有1000个白名单账号。如何将它们存储在智能合约中？简单的方法是将每个账户都存储在mapping中，但是代价非常大。一个更便宜的解决方案是构建一个Merkle树，并且只存储Merkle根(1个hash vs 1000也不错)。如果有人想调用这个方法，她必须给出一个Merkle证明(在本例中是10个散列的列表),这个证明很容易被智能契约验证。</p><p id="7112" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is">同样:Merkle树用于用一个散列(Merkle根)来表示一组元素。一个元素的存在可以用Merkle证明来证明。</strong></p><p id="a192" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">接下来我们要了解的是零知识证明本身。有了ZKP，你可以证明你知道一些事情，而不用透露你知道的事情。为了产生ZKP，你需要一个电路。电路就像一个小程序，有公共输入、输出和私有输入。这些私人输入是你为了验证而不透露的知识，这就是为什么它被称为零知识证明。有了ZKP，我们可以证明给定电路的输入可以产生输出。</p><p id="4900" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">一个简单的电路是这样的:</p><pre class="kh ki kj kk gu mc md me mf aw mg bi"><span id="3f63" class="mh mi ir md b gz mj mk l ml mm">pragma circom 2.0.0;<br/><br/>include "node_modules/circomlib/circuits/bitify.circom";<br/>include "node_modules/circomlib/circuits/pedersen.circom";<br/><br/>template Main() {<br/>    signal input nullifier;<br/>    signal output nullifierHash;<br/><br/>    component nullifierHasher = Pedersen(248);<br/>    component nullifierBits = Num2Bits(248);<br/><br/>    nullifierBits.in &lt;== nullifier;<br/>    for (var i = 0; i &lt; 248; i++) {<br/>        nullifierHasher.in[i] &lt;== nullifierBits.out[i];<br/>    }<br/><br/>    nullifierHash &lt;== nullifierHasher.out[0];<br/>}<br/><br/>component main = Main();</span></pre><p id="89da" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">使用这个电路，我们可以证明我们知道给定散列的来源。该电路有一个输入(零化器)和一个输出(零化器散列)。输入的默认可访问性是私有的，而输出总是公共的。该电路使用Circomlib中的2个库。<a class="ae kw" href="https://github.com/iden3/circomlib" rel="noopener ugc nofollow" target="_blank"> Circomlib </a>是一组有用的电路。第一个库是bitlify，包含位操作方法，第二个库是pedersen，包含Pedersen哈希函数。彼得森哈希法是一种可以在ZKP电路中高效运行的哈希方法。在主模板的主体中，我们填充散列值并计算散列值。(关于circom语言的更多信息，请查看<a class="ae kw" href="https://docs.circom.io/" rel="noopener ugc nofollow" target="_blank"> circom文档</a>)</p><p id="eba5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">为了生成零知识证明，您将需要一个证明密钥。这是ZKP最敏感的部分，因为使用用于生成证明密钥的源数据，任何人都可以生成伪造的证明。这些源数据被称为必须丢弃的“有毒废物”。因此，有一个生成证明密钥的“仪式”。该仪式有许多成员，每个成员都对证明密钥做出贡献。只有一个非恶意成员就足以生成有效的证明密钥。使用私有输入、公共输入和证明密钥，ZKP系统可以运行电路并生成证明和输出。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj mn"><img src="../Images/512e7e9a151820f7fa50894d443bd7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/0*jFHwERxrnWyuEBHZ.png"/></div></figure><p id="f683" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">验证密钥有一个验证密钥，可用于验证。验证系统使用公共输入、输出和验证密钥来验证证据。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj mo"><img src="../Images/d9e33c407394c498e1a443440eaee8d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/0*SlVAKC2jfKq1c4Dk.png"/></div></figure><p id="23d1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Snarkjs是一个全功能的工具，可以通过仪式生成证明密钥和验证密钥，生成证明并验证它。它还可以生成一个用于验证的智能契约，任何其他契约都可以使用它来验证零知识证明。更多信息，请查看<a class="ae kw" href="https://github.com/iden3/snarkjs" rel="noopener ugc nofollow" target="_blank"> snarkjs文档</a>。</p><p id="91d5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在，我们有一切来了解龙卷风现金(TC)如何工作。当你在TC合同上存入1 ETH时，你必须提供一个承诺散列。这个提交散列将被存储在Merkle树中。当你用不同的账户提取这个1 ETH的时候，你要提供2个零知识证明。第一个证明默克尔树包含了你的承诺。这个证明是一个Merkle证明的零知识证明。但这是不够的，因为你应该只被允许撤回这第一次。因此，您必须为承诺提供一个唯一的取消符。合同中储存了这个作废器，这可以确保你不能提取存入的钱超过一次。</p><p id="90f0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">承诺生成方法确保了取消符的唯一性。该承诺由无效符和一个秘密通过散列产生。如果您更改取消符，则承诺也会更改，因此一个取消符只能用于一个承诺。由于散列的单向性质，不可能将承诺和无效符联系起来，但是我们可以为它生成一个ZKP。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj mp"><img src="../Images/eb52269c17c17aa2c725e9d6cc4c3453.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/0*4L6nd2nGRKyd-b2w.png"/></div></figure><p id="3c84" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">理论完了，我们来看看TC 的<a class="ae kw" href="https://github.com/tornadocash/tornado-core/blob/master/circuits/withdraw.circom" rel="noopener ugc nofollow" target="_blank">撤电路是什么样子的:</a></p><pre class="kh ki kj kk gu mc md me mf aw mg bi"><span id="46b8" class="mh mi ir md b gz mj mk l ml mm">include "../node_modules/circomlib/circuits/bitify.circom";<br/>include "../node_modules/circomlib/circuits/pedersen.circom";<br/>include "merkleTree.circom";</span><span id="bef7" class="mh mi ir md b gz mq mk l ml mm">// computes Pedersen(nullifier + secret)<br/>template CommitmentHasher() {<br/>    signal input nullifier;<br/>    signal input secret;<br/>    signal output commitment;<br/>    signal output nullifierHash;</span><span id="44ac" class="mh mi ir md b gz mq mk l ml mm">    component commitmentHasher = Pedersen(496);<br/>    component nullifierHasher = Pedersen(248);<br/>    component nullifierBits = Num2Bits(248);<br/>    component secretBits = Num2Bits(248);<br/>    nullifierBits.in &lt;== nullifier;<br/>    secretBits.in &lt;== secret;<br/>    for (var i = 0; i &lt; 248; i++) {<br/>        nullifierHasher.in[i] &lt;== nullifierBits.out[i];<br/>        commitmentHasher.in[i] &lt;== nullifierBits.out[i];<br/>        commitmentHasher.in[i + 248] &lt;== secretBits.out[i];<br/>    }</span><span id="2237" class="mh mi ir md b gz mq mk l ml mm">    commitment &lt;== commitmentHasher.out[0];<br/>    nullifierHash &lt;== nullifierHasher.out[0];<br/>}</span><span id="51c5" class="mh mi ir md b gz mq mk l ml mm">// Verifies that commitment that corresponds to given secret and nullifier is included in the merkle tree of deposits<br/>template Withdraw(levels) {<br/>    signal input root;<br/>    signal input nullifierHash;<br/>    signal private input nullifier;<br/>    signal private input secret;<br/>    signal private input pathElements[levels];<br/>    signal private input pathIndices[levels];</span><span id="0cdf" class="mh mi ir md b gz mq mk l ml mm">    component hasher = CommitmentHasher();<br/>    hasher.nullifier &lt;== nullifier;<br/>    hasher.secret &lt;== secret;<br/>    hasher.nullifierHash === nullifierHash;</span><span id="7af3" class="mh mi ir md b gz mq mk l ml mm">    component tree = MerkleTreeChecker(levels);<br/>    tree.leaf &lt;== hasher.commitment;<br/>    tree.root &lt;== root;<br/>    for (var i = 0; i &lt; levels; i++) {<br/>        tree.pathElements[i] &lt;== pathElements[i];<br/>        tree.pathIndices[i] &lt;== pathIndices[i];<br/>    }<br/>}</span><span id="e1d2" class="mh mi ir md b gz mq mk l ml mm">component main = Withdraw(20);</span></pre><p id="9d79" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">第一个模板是CommitmentHasher。它有两个输入，零化符和秘密，这是两个随机的248位数字。该模板计算无效散列和承诺散列，后者是我之前写的无效散列和秘密的散列。</p><p id="30b9" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">第二个模板是取款本身。它有两个公共输入，Merkle根和nullifierHash。需要Merkle根来验证Merkle证明，智能合约需要nullifierHash来存储它。私有输入参数是Merkle证明的nullifier、secret、pathElements和pathIndices。该电路通过从无效符和秘密生成承诺来检查无效符，并且还检查给定的Merkle证明。如果一切正常，将生成可由TC智能契约验证的零知识证明。</p><p id="b638" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">您可以在回购的<a class="ae kw" href="https://github.com/tornadocash/tornado-core/tree/master/contracts" rel="noopener ugc nofollow" target="_blank">合同文件夹</a>中找到智能合同。验证符是从电路中产生的。Tornado合同使用它来验证给定无效哈希和Merkle根的ZKP。</p><p id="d86a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">使用契约最简单的方法是<a class="ae kw" href="https://github.com/tornadocash/tornado-core/blob/master/src/cli.js" rel="noopener ugc nofollow" target="_blank">命令行界面</a>。它是用JavaScript写的，源代码相对简单。您可以很容易地找到参数和ZKP是在哪里生成并用于调用智能合约的。</p><p id="f2ca" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">零知识证明在密码领域相对较新。背后的数学真的很复杂，很难理解，但是像<code class="fe mr ms mt md b">snarkjs</code>和<code class="fe mr ms mt md b">circom</code>这样的工具让它很容易使用。我希望，这篇文章能帮助你理解这项“神奇”的技术，并且你能在你的下一个项目中使用ZKP。</p><p id="9d89" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">快乐编码…</p><p id="dea7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">更新:我有一篇关于这个话题的新文章:</p><div class="mu mv gq gs mw mx"><a rel="noopener  ugc nofollow" target="_blank" href="/zero-knowledge-proofs-using-snarkjs-and-circom-fac6c4d63202"><div class="my ab fp"><div class="mz ab na cl cj nb"><h2 class="bd is gz z fq nc fs ft nd fv fx iq bi translated">使用SnarkJS和Circom的零知识证明</h2><div class="ne l"><h3 class="bd b gz z fq nc fs ft nd fv fx dk translated">JavaScript教程</h3></div><div class="nf l"><p class="bd b dl z fq nc fs ft nd fv fx dk translated">better编程. pub</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl kq mx"/></div></div></a></div><p id="c3be" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">另一篇文章是关于我如何基于Tornado Cash的源代码为匿名投票构建了一个JavaScript库。这是一个包含circom、Solidity和JavaScript代码的分步教程:</p><div class="mu mv gq gs mw mx"><a href="https://thebojda.medium.com/an-introduction-of-zk-merkle-tree-a-javascript-library-for-anonymous-voting-on-ethereum-using-79caa3415d1e" rel="noopener follow" target="_blank"><div class="my ab fp"><div class="mz ab na cl cj nb"><h2 class="bd is gz z fq nc fs ft nd fv fx iq bi translated">zk-merkle-tree介绍，一个用于以太坊匿名投票的JavaScript库，使用…</h2><div class="ne l"><h3 class="bd b gz z fq nc fs ft nd fv fx dk translated">投票的匿名性是基本要求之一，但在像区块链这样的公共网络上，这不是小事…</h3></div><div class="nf l"><p class="bd b dl z fq nc fs ft nd fv fx dk translated">thebojda.medium.com</p></div></div><div class="ng l"><div class="nm l ni nj nk ng nl kq mx"/></div></div></a></div></div></div>    
</body>
</html>