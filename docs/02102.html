<html>
<head>
<title>Recursion 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归101</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/recursion-101-a5e18158c66f?source=collection_archive---------8-----------------------#2019-11-06">https://betterprogramming.pub/recursion-101-a5e18158c66f?source=collection_archive---------8-----------------------#2019-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df74" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一步一步地递归解决问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c8c0602dca49425e00155b57a5267388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WwhlV-shBmEPUK3r"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@tine999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tine ivani</a>拍摄的照片</p></figure><p id="b218" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">欢迎来到递归101。在这篇文章的结尾，你将对递归解决问题和相关的数据结构有更深的理解。这些是编程世界中一些比较沉重的话题，新程序员经常害怕这个词<em class="lv">递归</em>。虽然在一篇文章中深入解释所有这些概念几乎是不可能的，但是您将更好地理解递归，以及为什么了解一些数据结构将有助于了解全局。就像你第一次在编程中学习的许多东西一样，这似乎很难。但是如果你慢慢来，了解基本原理，你会发现这没什么可怕的。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9b84" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">堆</h1><p id="de40" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我相信栈是理解递归的基本构件。堆栈被称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Abstract_data_type" rel="noopener ugc nofollow" target="_blank">抽象数据类型</a> (ADT)。抽象数据类型意味着它是一种描绘数据的逻辑方式和操纵数据的方式，而不涉及它将如何实现的细节。记住这一点的一个简单方法是ADT回答这个问题，它做什么？ADT的实际实现被称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Data_structure" rel="noopener ugc nofollow" target="_blank">数据结构</a>，它回答了这个问题:它是如何实现的？如何将由ADT详述的方法的实际编程来表示。ADT是独立于语言的。因为它没有指定需要如何完成，所以可以用任何语言编写。</p><p id="8bec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<a class="ae ky" href="https://www.geeksforgeeks.org/stack-data-structure/" rel="noopener ugc nofollow" target="_blank">堆栈</a>模拟后进先出(LIFO)的行为。正如名字<em class="lv"> stack </em>所暗示的，想象一堆块。你把几块积木放在一起。要在不破坏堆栈的情况下安全地移除一个块，您需要移除顶部的块，这是您放置的最后一个块。stack ADT的工作方式相同。您只能按照将项目放入堆栈的相反顺序移除它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/bfe7062c3c488b2cba3e04154b4a8171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Txyu1tf-YtTXkHksJN1DKg.png"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="563b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">调用堆栈</h1><p id="f180" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">也许你甚至不知道，你已经在你所有的代码中使用了堆栈。您的程序使用堆栈来控制子例程的流程，并在执行某些过程后将控制返回到程序的正确部分。</p><p id="1aba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，考虑这一行代码<code class="fe nb nc nd ne b">print(user.getName()</code>。从左到右，首先我们遇到了<code class="fe nb nc nd ne b">print()</code>函数，所以它被放在堆栈上。在打印函数的参数中，一个方法<code class="fe nb nc nd ne b">user.getName()</code>作为一个返回字符串的参数给出。在print方法可以执行之前，它需要从用户那里获取名称。现在它将<code class="fe nb nc nd ne b">getName()</code>放入堆栈。这将停止打印的执行，直到<code class="fe nb nc nd ne b">getName()</code>完成执行。把这个想象成点击暂停。“嘿，我会让你完成，但暂停你正在做的事情，以便我可以为你得到这个名字。我会把这个名字给你，这样你就可以从你停下来的地方继续。”</p><p id="24b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nb nc nd ne b">print()</code>功能暂时暂停且<code class="fe nb nc nd ne b">user.getName()</code>被置于堆栈上的情况下，<code class="fe nb nc nd ne b">user.getName()</code>拥有控制权。它获取用户的名字，并向<code class="fe nb nc nd ne b">print()</code>函数返回一个字符串。在完成<code class="fe nb nc nd ne b">user.getName()</code>方法后，它被弹出堆栈，控制返回到<code class="fe nb nc nd ne b">print()</code>，在那里它完成打印用户名的工作。一旦完成，它也会弹出堆栈。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/18a15d512f7abcadbf7184377b37205d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*c4drBzwNkpN9SwpHQDMc2g.png"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d948" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">递归</h1><p id="87eb" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">好了，现在我们已经建立了一些基础，这将更容易理解。到底什么是递归？递归是一种独特的算法问题解决技术。这听起来可能有点吓人，但它本质上归结为创建同一问题的越来越小的版本，直到最小的解决方案被轻松解决，然后反向一点一点地解决更大的问题。</p><p id="8b97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个函数一遍又一遍地调用自己时，就会发生递归。该函数本身被称为递归函数。你可能想知道一个函数如何调用自己，这样做有什么好处。让我们看一个使用指数的简单例子。</p><p id="369b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我能想到的最简单的例子。老实说，你永远不会用这种方法求解指数，但是它可以让你确切地看到递归是如何工作的，而不会使事情变得太复杂。我们如何用递归求解3的3次方？让我们想个办法，把这个问题分解成更小的自相似的部分。</p><pre class="kj kk kl km gt ng ne nh ni aw nj bi"><span id="d1d6" class="nk me it ne b gy nl nm l nn no">3 to the 3rd power = 3*3*3<br/>3 to the 3rd power = 3 * (3 to the 2md power)</span><span id="ea53" class="nk me it ne b gy np nm l nn no">3 to the 2nd power = 3 * (3 to the 1st power)<br/>3 to the 1st power = 3 * (3 to the 0 power)<br/>3 to the 0   power = 1</span></pre><p id="a72b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看看上面例子中的前两行，你会发现它们是得到完全相同答案的两种方法。第一行是解决这个问题的传统方法。第二行是递归解决这个问题的方法。</p><p id="bc3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从第二行开始，您会注意到可以解决这个问题的模式或算法。我们使用相同的算法不断地将问题分解成越来越小的部分，直到我们得到最小的问题和最简单的解决方案:<code class="fe nb nc nd ne b">1 to the 0 power = 1</code>。让我们来看看如何编写一个使用这个算法的函数。</p><pre class="kj kk kl km gt ng ne nh ni aw nj bi"><span id="5d59" class="nk me it ne b gy nl nm l nn no">public int power(int base, int exponent) {<br/>   if(exponant == 0) {return 1;}<br/>   return base * power(base, exponent - 1);</span></pre><p id="afa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一行一行地分解这个函数。函数<code class="fe nb nc nd ne b">power</code>的定义返回一个<code class="fe nb nc nd ne b">int</code>。它有两个参数。它接受一个基数和一个指数。</p><p id="a8e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二行检查指数是否为0。如果指数是0，我们就不再需要把问题分解成小块了。这就是所谓的<em class="lv">基础案例</em>。我稍后会对此进行更多的解释。如果我们已经到达了问题需要被分解的最小值，它返回1。(记住零指数规则:任何指数为0的基数都等于1)。</p><p id="d165" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有当第二行没有返回1时，才会调用第三行。这意味着我们可以将问题分解成更小的部分，直到达到基本情况。这被称为<em class="lv">较小的调用方</em>。这个问题的缩小版，按照我们的算法是<code class="fe nb nc nd ne b">base * power(base, exponent — 1)</code>。我们将底数乘以底数的幂和(指数-1)。还记得之前我们展示的3*3*3和说3 * (3的2次方)是一样的吗？</p><p id="2502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们直观地看看发生了什么，使用调用堆栈来更好地理解正在发生的确切过程。</p><p id="25ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从调用函数power(3，3)开始，它被添加到调用堆栈中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/14e5c87f460cf450c2486cf52d288d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*n672zDmQL0oUl1WVceUU5Q.png"/></div></figure><p id="014c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在这种方法已经走到了尽头。它检查<code class="fe nb nc nd ne b">if 3(exponent) == 0</code>。那是假的，所以转到下一行，<code class="fe nb nc nd ne b">return 3 * power(3, 2)</code>。在这个函数返回值之前，我们遇到了另一个函数。所以我们将暂停这个当前函数来获取这个被调用的函数的值<code class="fe nb nc nd ne b">power(3, 2</code>。这个新函数被添加到堆栈中并获得控制权。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/8dd5aedea1acff0d28b0111ec94fa459.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*bUQwcjPYWupjN563DgFojQ.png"/></div></figure><p id="7df8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，新的通用方法已经走到了尽头。它检查<code class="fe nb nc nd ne b">if 2(exponent) == 0</code>。那是假的，所以它转到下一行，<code class="fe nb nc nd ne b">return 3 * power(3, 1)</code>。在这个函数可以返回值之前，我们又碰到了另一个函数！所以我们将暂停这个当前函数来获取这个被调用的函数的值<code class="fe nb nc nd ne b">power(3, 1)</code>。这个新函数被添加到堆栈中并获得控制权。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/1872b4738dd4dab48448368f05c94f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*DijmayZdEanbbqgB9d0spQ.png"/></div></figure><p id="be14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在栈上最新的函数拥有控制权。它运行它的代码并检查<code class="fe nb nc nd ne b">if 1(exponent) == 0</code>。那是假的，所以它转到下一行，<code class="fe nb nc nd ne b">return 3 * power(3, 0)</code>。在这个函数返回值之前，我们遇到了另一个函数！不过，不要担心，我们正在取得进展。所以我们将暂停这个当前函数，以获取这个被调用的函数的值<code class="fe nb nc nd ne b">power(3, 0)</code>。这个新函数也被添加到堆栈中并获得控制权。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/0d1cc7bb227e5461f863c82c60eb4449.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*UU0d7uJ2jalJ0In-pG-xqg.png"/></div></figure><p id="202e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">栈上最新的函数又一次获得了控制权，我们重复我们一直在做的事情。它运行它的代码并检查<code class="fe nb nc nd ne b">if 0(exponent) == 0</code>。那是真的！最后，我们将问题分解成问题的最小版本(基础案例)。既然我们已经达到了基本情况，我们可以返回1。从这里开始，我们按照后进先出的顺序返回堆栈。因为这个函数返回了1，所以它已经完成了所有的功能，我们也完成了，所以它被弹出堆栈，控制权交给了值为1的前一个函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/42940b3a89342dbd16fc36b5201ea07a.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*jeFBOKpp1gBIy3pQqWFkSQ.png"/></div></figure><p id="9fd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是事情变得有趣的地方。这基本上就像在整个堆栈中填充空白一样。函数<code class="fe nb nc nd ne b">power(3, 1)</code>就是所谓的函数<code class="fe nb nc nd ne b">power(3, 0)</code>。我们暂停执行<code class="fe nb nc nd ne b">power(3, 1)</code>来计算<code class="fe nb nc nd ne b">power(3, 0)</code>，结果是1。因此，控制权现在属于<code class="fe nb nc nd ne b">power(3,1)</code>，我们从上次停止的地方重新开始。该函数中剩下的最后一部分代码是<code class="fe nb nc nd ne b">return 3 * power(3, 0)</code>。我们现在知道了<code class="fe nb nc nd ne b">power(3, 0) = 1</code>，所以我们可以填补空白。现在变成了<code class="fe nb nc nd ne b">return 3 * 1</code>。简单的数学告诉我们3 * 1 = 3，所以我们返回3。我们现在完成了这个函数，它被弹出堆栈，控制权交给下一个函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/bc73c8f5c302858353cc5a35c6662c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*7qJHzTWeXMvi8Q20126caw.png"/></div></figure><p id="a43e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将再次填补空白。因为函数<code class="fe nb nc nd ne b">power(3, 2)</code>调用了<code class="fe nb nc nd ne b">power(3,1)</code>并且我们得到了3，我们可以在函数的剩余行中替换它。最后一行变成了<code class="fe nb nc nd ne b">return 3 * 3</code>，我们得到9。这就完成了这个函数调用，并且在将控制权返回到堆栈中下一个值为9的函数时，它被弹出堆栈。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/ff9c666bc8cde732ceaa9616345191cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*ekBBdfIRn7uvqh3ZGNCpJg.png"/></div></figure><p id="693a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们处于初始函数调用，由于递归和将问题分解成更小的问题，我们可以解决这个问题。该函数中剩下要执行的最后一行是<code class="fe nb nc nd ne b">return 3 * 9</code>。这将返回数字27，并且将是初始函数调用<code class="fe nb nc nd ne b">power(3, 3)</code>的解。既然这个函数现在已经完成了，我们就把它从栈中弹出来，剩下一个空栈。我们可以仔细检查我们的工作。3*3*3 = 27吗？是的，它是！递归地解决这个问题确实给了我们正确的结果</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7ee6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">三个问题</h1><p id="e80a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当试图递归地解决一个问题时，你需要问自己三个问题。这将使找到一个算法来解决你的问题变得更加容易。为了验证递归解决方案是否有效，我们必须能够对这三个问题都回答“是”。</p><ol class=""><li id="aeb0" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><strong class="lb iu">基础案例问题:</strong>算法中是否有非递归的方法，算法对于这个基础案例是否正确工作？<br/> <strong class="lb iu">回答:</strong>是的，当指数达到0时，我们不再需要进行递归调用，可以改为返回1。</li><li id="d8f9" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><strong class="lb iu">较小的调用者问题:</strong>对算法的每次递归调用是否都涉及原始问题的较小情况，从而不可避免地导致基本情况？<br/> <strong class="lb iu">回答:</strong>是的，较小的调用者总是涉及到将指数递减1，直接导致基本情况。</li><li id="f3c7" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><strong class="lb iu">一般情况问题:</strong>假设对较小情况的递归调用正常工作，那么算法对一般情况是否正常工作？<br/> <strong class="lb iu">答案:</strong>假设递归调用power(base，exponent-1)给出使用正确的值，那么return语句计算base * exponent。是的。</li></ol><p id="4ee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当试图将你的问题分解成更小的自相似问题来递归求解时，确保在尝试实现你的算法之前问自己这些问题。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2399" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="c2d5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">恭喜你！您现在对如何递归解决问题有了基本的了解。仍然有许多方法来扩展这个新发现的递归知识。研究一下<a class="ae ky" href="https://www.geeksforgeeks.org/difference-between-recursion-and-iteration/" rel="noopener ugc nofollow" target="_blank">递归和迭代</a>编程方式将会解释两者的优缺点。递归在许多<a class="ae ky" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>语言中使用，比如<a class="ae ky" href="https://elixir-lang.org/" rel="noopener ugc nofollow" target="_blank"> Elixer </a>。函数式编程是编程的<a class="ae ky" href="https://www.geeksforgeeks.org/functional-programming-paradigm/" rel="noopener ugc nofollow" target="_blank">范式</a>，就像面向对象编程也是<a class="ae ky" href="https://www.tutorialspoint.com/object_oriented_analysis_design/ooad_object_oriented_paradigm.htm" rel="noopener ugc nofollow" target="_blank">范式</a>一样。此外，还有<a class="ae ky" href="https://stackoverflow.com/questions/310974/what-is-tail-call-optimization" rel="noopener ugc nofollow" target="_blank">尾部调用优化</a>，它不需要保存堆栈上的所有函数。但那是另一天的话题。研究递归和迭代编程方式将会解释两者的优缺点。</p><p id="1135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望现在如果你遇到需要递归解决的问题，你不会感到害怕。只是一步一步来，把问题分解成更小的自相似问题。然后问自己三个问题。</p></div></div>    
</body>
</html>