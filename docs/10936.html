<html>
<head>
<title>Write Testable Kotlin Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写可测试的Kotlin服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-testable-services-in-kotlin-e56d0de0b82b?source=collection_archive---------12-----------------------#2022-02-04">https://betterprogramming.pub/writing-testable-services-in-kotlin-e56d0de0b82b?source=collection_archive---------12-----------------------#2022-02-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f847" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你的测试不是问题，而是你不可测试的代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c6bfd3d3c85e73ffa668810c9f852338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_X3qQBfkqPc-d5ldVT4mow.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://unsplash.com/@testalizeme" rel="noopener ugc nofollow" target="_blank"> Testalize.me </a>在<a class="ae kv" href="https://unsplash.com/photos/0jE8ynV4mis" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3efa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在某种程度上，我们都曾抱怨过编写测试。我们在制作的时候已经做了大量的测试，那么为什么我们还要浪费时间去尝试自动化测试呢？它们很难写，一旦我们做出新的改变，它们就会崩溃。我曾一度分享过这种观点，但当我意识到一些事情后，它就改变了:</p><ul class=""><li id="14fe" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">良好的测试覆盖率意味着更少的手工测试</li><li id="40ba" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">回归测试确保错误不再出现</li><li id="d468" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">只要测试仍然通过，尽可能地重构</li><li id="b009" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">失败的测试比通过的测试更有用</li></ul><p id="6c10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你让我陷入了无限重构，但是考虑一下通过投资自动化测试可以节省的时间。如果它们能够可靠地覆盖最重要的流程，那么重复的手工测试就是浪费时间！但是这并没有改变测试很难编写和维护的事实；我们如何让投资物有所值？通过让你的代码<strong class="ky ir">可测试</strong>。</p><p id="8e83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如何编写<strong class="ky ir">可测试代码</strong>？你把你的测试当作一等公民；通过设计您的服务，首先测试，然后运行。在本指南中，我将通过示例向您展示我学到的策略:实现众所周知的<a class="ae kv" href="https://petstore.swagger.io/#/" rel="noopener ugc nofollow" target="_blank"> Swagger Petstore API </a>的一部分。</p><h1 id="c0ac" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">放弃</h1><p id="4c71" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我试图让代码尽可能集中在本指南的主要目标上。我已经省略了任何对这个目标没有直接贡献的代码，因此代码可能看起来不完整或者不健壮。</p><p id="4917" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里提供的示例摘自一个示例项目。要了解它们是如何组合在一起的，你可以在这里找到它。</p><h1 id="4ce2" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">战略</h1><p id="1371" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们将使用两个主要策略来实现我们今天的目标，模拟和依赖注入。</p><p id="9c6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模拟是我们模仿真实物体的一种方式，用我们可以控制的物体来代替它的行为。当我们为应用程序构建测试时，我们用模拟版本替换外部依赖。有一些库可以使用反射来实现这一点，但是我更喜欢自己编写自己的库。</p><p id="65fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">依赖注入是一个简单的概念:它本质上归结为将我们所有的数据库和客户端类作为参数传递给我们的业务逻辑，而不是静态地访问它们。它促使我们在构建服务时更加深思熟虑，但它也将作为我们模拟的交付机制。</p><h1 id="be39" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">数据库访问</h1><p id="3454" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">出于本指南的考虑，让我们从自下而上开始:在我们的数据库访问对象(DAO)——或存储库。这是我们的<code class="fe nd ne nf ng b">Pet</code> <strong class="ky ir"> </strong>模型，我们想从MySQL数据库中检索它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6b7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可能会想出这样的刀…我这里用的是普通的JDBC，但是大多数ORM会让你注入你自己的<code class="fe nd ne nf ng b">DataSource</code>或者<code class="fe nd ne nf ng b">Connection</code>。为了使我们未来的测试简单，我们确保在我们的DAO中没有嵌入业务逻辑；它应该只关注访问。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="bf12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里需要注意的重要一点是，我们在构造函数中注入了一个<code class="fe nd ne nf ng b">DataSource</code>供DAO使用。这意味着我们可以自由地创建这个DAO，并将其连接到我们想要的任何数据库。</p><p id="ca04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在您可能认为测试数据库代码是一件非常痛苦的事情，因为它涉及到在您的CI环境中建立一个数据库，但这并不是必须的。如果我们能在一些多余的特性上妥协，我们就能写出与MySQL和<em class="nj"> </em> H2兼容的SQL:一个具有内存模式的纯java数据库。所以让我们把它加入到我们的项目中。</p><pre class="kg kh ki kj gt nk ng nl nm aw nn bi"><span id="a53a" class="no mh iq ng b gy np nq l nr ns">testImplementation("com.h2database:h2:2.1.210")</span></pre><p id="2eec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要做的第一件事是创建一些我们可以在测试中重用的工具。这个<code class="fe nd ne nf ng b">PetsDao.mock</code>扩展函数将构建一个通过依赖注入连接到测试数据库的DAO。</p><p id="811f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您愿意，甚至可以将您的数据库种子转储到一个SQL文件中并执行它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="409c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们的第一个测试。它需要做的就是创建一个连接到H2的新DAO，并运行我们的测试。由于每次测试都会创建一个新的数据库，所以我们不需要担心测试会相互影响。</p><p id="bee2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的第一次测试非常简单；它验证了我们的DAO中的代码，并为我们提供了一个稳定的构建平台。</p><h1 id="ab25" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">API客户端</h1><p id="b746" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">接下来我想介绍的是API客户端。这些都可以通过正确的HTTP客户端进行全面测试。我强烈推荐<a class="ae kv" href="https://www.http4k.org/" rel="noopener ugc nofollow" target="_blank">http4k</a>；将一个假的服务器注入到一个客户端中是非常容易的，并且可以在不使用网络的情况下运行。</p><p id="0fb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个例子，我们将集成一个第三方图片托管服务，这样我们就不必担心存储大量的猫图片。让我们做一个客户。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4565" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重要的还是我们的构造函数参数，我们在这里注入了一个<code class="fe nd ne nf ng b">HttpHandler</code>。在<code class="fe nd ne nf ng b">http4k</code>中，<code class="fe nd ne nf ng b">HttpHandler</code>字面上只是<code class="fe nd ne nf ng b">(Request) -&gt; Response</code>的<code class="fe nd ne nf ng b">typealias</code>。这是非常强大的，因为我们可以注入一个实际的http客户端——像okhttp或Java http——我们也可以注入我们自己的假服务器。</p><p id="7c2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能会注意到没有主机名或凭证，但是它们可以由一个<code class="fe nd ne nf ng b">Filter</code>注入到<code class="fe nd ne nf ng b">HttpHandler</code>中。我们的测试后端不关心主机名和凭证，所以我们的客户端不一定需要关心；尽管不同意和无视，但我们会在以后准备好真正跑步时添加这些内容。</p><p id="72cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种方法是制作一个<code class="fe nd ne nf ng b">ImageClient</code>接口，制作一个假的版本，然后不必处理一个假的http服务器。这是可以的，但这意味着我们在客户中没有任何测试覆盖，这可能隐藏一些最严重的错误。</p><p id="8f01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们写我们的假服务器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="82a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看我们的山寨怎么也是个<code class="fe nd ne nf ng b">HttpHandler</code>？我们可以将它直接注入到我们的客户机中，所有请求都将被路由到它。现在，在这一点上，我们可以做一些测试，但我通常不直接测试API客户端；再次强调，不同意也可以无视；但是当我们测试我们的业务逻辑时，它将得到检验。</p><p id="0db0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要注意的一点是，这个伪造品生成的id是连续的，这使得副作用和返回值很容易提前知道。给测试增加随机性会使它们变得脆弱，所以通常使用更可预测的东西会更安全。</p><h1 id="bd57" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">业务逻辑(服务层)</h1><p id="d5a4" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">因此，我知道我们一直在做这件事，但在这里，我们终于要写一些业务逻辑，把它们联系在一起。</p><p id="6e64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务代码本身非常简单；你应该再次注意到我们的<code class="fe nd ne nf ng b">PetsDao</code>和<code class="fe nd ne nf ng b">ThirdPartyImageClient </code>都是通过构造函数注入的。您还应该注意到，绝对没有数据库事务逻辑污染我们的业务逻辑。</p><p id="d829" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多框架会训练您将服务调用与数据库事务结合起来，但是我们在这里不打算这么做。为什么？因为我们的业务逻辑都知道，我们的<code class="fe nd ne nf ng b">PetsDao</code>可以由任何东西支持，比如DynamoDB、内存或API。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f4d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是<code class="fe nd ne nf ng b">PetsDaoTest</code>是事情开始变得真正有趣的地方。为了构建我们的<code class="fe nd ne nf ng b">PetService</code>,我们需要用假数据库构建一个<code class="fe nd ne nf ng b">PetsDao</code>,用假服务器构建一个<code class="fe nd ne nf ng b">ThirdPartyImageClient</code>。然后我们可以开始做一些非常有趣的测试。</p><p id="baf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以<code class="fe nd ne nf ng b">add image</code>测试为例:我们从现有的<code class="fe nd ne nf ng b">Pet</code>开始，所以我们通过调用<code class="fe nd ne nf ng b">petsDao.create</code>来播种测试。我们不调用<code class="fe nd ne nf ng b">PetService.create</code>,因为它可能隐藏副作用或其他我们尚未测试的逻辑。如果测试失败，我们就不知道哪个对<code class="fe nd ne nf ng b">PetService</code>的呼叫出了问题。</p><p id="764e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，如果测试失败，而我们的<code class="fe nd ne nf ng b">PetsDaoTest</code>方法通过，我们就能更好地诊断故障。或者，您可以从SQL文件中加载一个全局种子。</p><p id="1e6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们的测试调用了<code class="fe nd ne nf ng b">petsDao.uploadImage</code>,我们就进行三次验证。首先是验证由<code class="fe nd ne nf ng b">uploadImage</code>返回的<code class="fe nd ne nf ng b">Pet </code>看起来像我们期望的那样。但是我们知道应该有两个副作用，所以我们需要验证它们。为此，我们将直接在<code class="fe nd ne nf ng b">PetsDao</code>和<code class="fe nd ne nf ng b">FakeThirdPartyImageBackend</code>上执行断言。</p><h1 id="f95d" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">界面(控制器/视图模型)</h1><p id="da1a" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">既然我们的服务中已经有了业务逻辑，下一步就是为客户提供一个接口来使用它。我们已经使我们的服务足够模块化，接口可以是REST、RPC、WebSocket、流监听器，甚至是本地应用程序的视图模型。</p><p id="2dac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是对于这个例子，我们将构建一个REST服务器。再次强烈推荐<a class="ae kv" href="https://www.http4k.org/" rel="noopener ugc nofollow" target="_blank"> http4k </a>，因为不启动服务器，不使用网络就可以测试；Ktor 也有这个能力。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f468" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个REST API，我们唯一的依赖是在我们的<code class="fe nd ne nf ng b">PetService</code>上。注意它是如何返回一个<code class="fe nd ne nf ng b">HttpHandler</code>的，这和我们注入到<code class="fe nd ne nf ng b">ThirdPartyImageClient</code>中的一样。</p><p id="7aea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">客户端后端和服务器是一回事；整洁！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="482b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的测试中，我们用与在<code class="fe nd ne nf ng b">PetServiceTest</code>中相同的方式创建了一个<code class="fe nd ne nf ng b">PetService</code>，但是我们将它注入到我们的<code class="fe nd ne nf ng b">RestApi</code>中，这提供了一个<code class="fe nd ne nf ng b">HttpHandler</code>，我们可以对其发出请求。</p><p id="922b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我建议你不要过度使用你的API测试；它们更难维护，并且在某一点之后，它们不会提供我们的<code class="fe nd ne nf ng b">PetServiceTest</code>还没有提供的任何覆盖。如果您创建一个新版本的API，它可能最终会使用完全相同的<code class="fe nd ne nf ng b">PetService</code>调用，因此该API的额外测试是多余的。一个好的经验法则可能是只测试您期望收到的不同变化的状态代码。例如，200、400和404案例。</p><p id="07ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能还注意到我们还在验证一些副作用。我们不需要走得太远，但我们确实需要验证我们希望发生的事情确实发生了。完全有可能API只是返回一些样本数据，而实际上并没有做任何事情。</p><h1 id="b255" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">运行服务器</h1><p id="52f8" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">经过这么长时间，我们已经完全测试了我们的服务，但是我们还没有真正运行它。没问题。我们可以构建一个<code class="fe nd ne nf ng b">Runner</code>模块来收集我们的配置，构建我们的<code class="fe nd ne nf ng b">RestApi</code>，然后将其连接到一个真实的服务器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="ef25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以按照自己的意愿收集配置参数，但是ENV在这里完成了这项工作。本质上，这个运行程序与设置一个测试没有太大的不同，但是有一些重要的区别:</p><ul class=""><li id="aa0b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nd ne nf ng b">dataSource</code>是一个<code class="fe nd ne nf ng b">MySqlDataSource</code>，指向一个真正的MySQL服务器</li><li id="e8dd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nd ne nf ng b">ThirdPartyImageClient</code>将一个真实的客户端作为<code class="fe nd ne nf ng b">HttpHandler</code>，但是将它包装在一个<code class="fe nd ne nf ng b">Filter</code>中，后者将主机名和凭证添加到请求中</li><li id="d519" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nd ne nf ng b">RestApi</code>被转换成一个真实的服务器并启动</li></ul><p id="15f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以运行我们的新<code class="fe nd ne nf ng b">main</code>方法，我们的应用程序正在真正运行。</p><h1 id="eefb" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">人工测试</h1><p id="1bb8" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">因此，隔离测试很好，但是我们在<code class="fe nd ne nf ng b">ThirdPartyImageClient</code>和<code class="fe nd ne nf ng b">PetsDao</code>中做了几个假设。这些假设可能不正确，所以这是唯一需要手工测试的地方。</p><p id="ed00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要真正运行我们的应用程序，调用真正的MySQL数据库和第三方图像托管服务。如果我们遇到任何错误，修改我们的自动化测试或假后端来重现错误，然后修复我们的产品代码是非常重要的。这允许我们的手动测试实际上为我们的套件贡献回归测试，减少未来手动测试的需要。</p><p id="1dcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设第三方图像托管站点返回404，因为我们的路径错误。当我们将假设融入到模拟中时，这样的错误是不可避免的，但是通过将修正融入到我们的模拟和生产代码中，我们调整了不正确的假设，并强化了正确的假设。如果我们在产品代码中犯了一个被我们的mock发现的错误，那将会是一个非常强大的反馈，这是我们在手工测试中根本不会遇到的。</p><h1 id="cf8a" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">最后的想法</h1><p id="596d" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我希望本指南中展示的例子有助于提高代码的可测试性。随着测试覆盖率的增加，您将开始感受到几个优势:</p><ul class=""><li id="7d25" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">虽然自动化测试可以关注细节，但是手动测试可能仅限于简单的冒烟测试</li><li id="7697" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">更少的测试时间意味着更快的开发速度</li><li id="8b9e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">测试创建了一个安全网，使得大型重构变得可行</li><li id="b8fc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">对部署和发布更有信心</li></ul><p id="2b71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我祝你好运，让你的服务可测试；让我知道它是如何为你工作的，感谢你的阅读！</p><h1 id="f681" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">回购样本</h1><p id="ee3a" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">本指南是围绕一个样例回购编写的，这个样例回购可以在Github上找到。它可能会提供一个更完整的图片来帮助您制作自己的可测试代码。</p><div class="nt nu gp gr nv nw"><a href="https://github.com/oharaandrew314/testable-code-kotlin" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">GitHub-oharaandrew 314/testable-Code-kot Lin:我关于这个主题的中型文章的示例代码</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">github.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok kp nw"/></div></div></a></div><h1 id="3056" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">额外收获:嘲笑AWS SDK</h1><p id="a47b" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">你甚至可以嘲笑AWS SDK！有两种方法:</p><ul class=""><li id="033e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">创建客户端接口的模拟实现</li><li id="e061" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">启动一个假的AWS服务器并覆盖您的客户端的端点</li></ul><p id="970d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您总是可以创建自己的SDK客户端的模拟实现，但是由于AWS有一个众所周知和理解的API，所以有一些现成的工具可以节省您大量的时间。</p><h2 id="a1f7" class="no mh iq bd mi ol om dn mm on oo dp mq lf op oq ms lj or os mu ln ot ou mw ov bi translated"><a class="ae kv" href="https://github.com/spulec/moto" rel="noopener ugc nofollow" target="_blank"> spulec/moto </a></h2><p id="8d00" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">Moto众所周知，有两种操作模式。它可以直接集成到python应用程序中，也可以启动模拟服务器。这是我为python应用程序选择的工具。</p><h2 id="ee8f" class="no mh iq bd mi ol om dn mm on oo dp mq lf op oq ms lj or os mu ln ot ou mw ov bi translated"><a class="ae kv" href="https://github.com/http4k/http4k-connect" rel="noopener ugc nofollow" target="_blank">http4k/http4k-连接</a></h2><p id="91e7" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">AWS SDK实际上只是REST API的一个臃肿的客户端，所以http4k有一个附带项目，为一些最流行的AWS服务提供轻量级的预构建客户端。这个工具似乎主要是为了取代AWS SDK，但是它确实为一些受支持的服务提供了模拟后端。这对于无服务器环境来说非常好，因为您可以用Jackson和Apache HttpClient来代替冷启动性能不太好的适配器。</p><h2 id="023d" class="no mh iq bd mi ol om dn mm on oo dp mq lf op oq ms lj or os mu ln ot ou mw ov bi translated"><a class="ae kv" href="https://github.com/oharaandrew314/mock-aws-java-sdk" rel="noopener ugc nofollow" target="_blank">oharaandrew314/mock-AWS-Java-SDK</a></h2><p id="f8da" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我想要一个纯java的工具，可以容易地注入，并支持Dynamo DB Mapper。上面的工具都不能给我所有这些东西。</p><p id="1874" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我开始了这个项目，让我和我的同事在我们所有的服务中使用。它支持最常用的AWS服务，95%的时间都能完成工作。要使用它，您只需创建一个模拟客户端，并注入它来代替AWS SDK接口。希望你来看看！</p></div></div>    
</body>
</html>