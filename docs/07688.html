<html>
<head>
<title>Recursion in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的递归</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/recursion-in-python-32d464653984?source=collection_archive---------13-----------------------#2021-02-09">https://betterprogramming.pub/recursion-in-python-32d464653984?source=collection_archive---------13-----------------------#2021-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8574" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对令人困惑的编程范例的探究</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6500e368416606ca87dc793026b64a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BqtE7hiXAWSG6Tw-lqWlUg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="ec8e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">递归是计算机科学中的基本概念之一，对于程序员和数据科学家来说都是必不可少的。不仅许多排序和搜索算法是递归的，而且每个Python面试都会包括一些基于递归的问题。这标志着递归成为在任何编码面试之前需要修改的一个关键概念。</p><p id="aef6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天，我们将帮助您复习Python中的递归编程技巧，并通过六个练习题获得实践经验。</p><p id="5935" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是我们今天要讲的内容:</p><ul class=""><li id="58bb" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">什么是递归？</li><li id="1417" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">Python中的递归</li><li id="a4b0" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">数字的Python递归</li><li id="8a88" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">使用字符串和数组的Python递归</li><li id="7ad0" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">数据结构的Python递归</li><li id="8f3f" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">接下来学什么</li></ul></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="6ef3" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">什么是递归？</h1><p id="2950" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">递归是计算机科学中的一个概念，当一个函数调用它自己并循环直到它到达期望的结束条件。它来源于递归定义的数学概念，递归定义根据集合中的其他元素来定义集合中的元素。</p><p id="492d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个递归实现都有一个<strong class="kx ir"> <em class="nj"> </em> </strong> <em class="nj">基本情况</em>，此时已达到所需状态，还有一个<em class="nj">递归情况</em>，此时尚未达到所需状态，函数进入另一个递归步骤。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/24f4c93a12aaed4fb1732f6fc5563047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zCCb8OpH1AvUYXIq.PNG"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="db60" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">递归函数调用之前的递归情况下的行为，即内部自调用，在每一步都重复。因此，当您可以通过完成重复的子问题(递归情况)来实现更大的问题(基本情况)时，递归结构是有用的，这些子问题将程序逐步推进到基本情况。</p><p id="71af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其结果与<code class="fe nl nm nn no b">for</code>或<code class="fe nl nm nn no b">while</code>循环类似，除了递归更接近目标条件，而<code class="fe nl nm nn no b">for</code>循环运行固定次数，而<code class="fe nl nm nn no b">while</code>循环运行直到不再满足条件。</p><p id="744c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">换句话说，递归是声明性的，因为你设置了你想要达到的状态，而<code class="fe nl nm nn no b">for</code> / <code class="fe nl nm nn no b">while</code>循环是迭代的，因为你必须设置重复的次数。</p><p id="8447" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看看迭代方法和递归方法在语法上的区别:</p><p id="6438" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">递归</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9f6d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nl nm nn no b"><strong class="kx ir">for</strong></code> <strong class="kx ir">循环</strong></p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="e74b" class="nv mn iq no b gy nw nx l ny nz">arr = ["A", "B", "C"]<br/>for x in arr: #sets the number of iterations<br/>  print(x)</span></pre><p id="515d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nl nm nn no b"><strong class="kx ir">while</strong></code> <strong class="kx ir">循环</strong></p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="8558" class="nv mn iq no b gy nw nx l ny nz">i = 1<br/>while i &lt; 6: #sets number of iterations<br/>  print(i)<br/>  i += 1</span></pre><p id="7f05" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当一个问题有明确的必须重复的子问题，并且如果你不确定你需要用迭代解决方案循环多少次时，递归解决方案是最好的。</p><p id="4c1d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，如果您想创建一个阶乘函数程序来寻找一个未知数的阶乘:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="2b1b" class="nv mn iq bd mo oa ob dn ms oc od dp mw le oe of my li og oh na lm oi oj nc ok bi translated">直接递归与间接递归</h2><p id="fcc4" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">到目前为止，我们只讨论了<em class="nj">直接递归</em>，其中递归函数在其递归步骤中显式调用自身。还有<em class="nj">间接递归</em>，其中递归调用从函数中移除，但仍作为原始递归步骤的结果运行。</p><p id="4518" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，<code class="fe nl nm nn no b">functionA</code>调用<code class="fe nl nm nn no b">functionB</code>，T1再调用<code class="fe nl nm nn no b">functionA</code>。</p><p id="6c45" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">直接</strong></p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="7756" class="nv mn iq no b gy nw nx l ny nz">def function1(p1, p2, ..., pn) :<br/>  # Some code here<br/>  function1(p1, p2, ..., pn)<br/>  # Some code here</span></pre><p id="9557" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">间接</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="9668" class="nv mn iq bd mo oa ob dn ms oc od dp mw le oe of my li og oh na lm oi oj nc ok bi translated">Python中递归的利与弊</h2><p id="a979" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">所有编程语言都支持递归；然而，并不是所有的都是同等优化的。</p><p id="0d0c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Python中，迭代通常是首选，由于内置的优化，迭代被认为更“Python化”。一般来说，递归解决方案比迭代解决方案更适合大型计算，因为递归通常会产生更少的代码和更快的性能。</p><p id="46e2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">优点</strong></p><ul class=""><li id="daec" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><strong class="kx ir">优化后速度更快</strong>:如果你包括递归优化，比如尾端递归和记忆化，Python中的递归方法会更快。</li><li id="ece9" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx ir">代码更少</strong>:递归解决方案更紧凑，这意味着你可以更快地编写递归解决方案，调试时需要审查的代码更少。</li><li id="5822" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx ir">声明性</strong>:许多开发人员发现声明期望状态的逻辑比迭代更容易理解，迭代关注的是达到未声明目标所需的步骤。</li><li id="813a" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx ir">高效的排序和搜索</strong>:递归对Python数据科学特别有用，因为它是mergesort等流行排序算法的基础。</li></ul><p id="4431" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">缺点</strong></p><ul class=""><li id="1a53" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><strong class="kx ir">最大递归深度</strong> : Python的调用栈有限，仅支持1000个嵌套步骤。虽然这看起来很多，但在处理像列表和数组这样的大型结构时，这就成了一个问题。这可以用<code class="fe nl nm nn no b">sys.setrecursionlimit(1500)</code>覆盖，风险自负。</li><li id="c08b" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx ir">支持，不建议</strong> : Python允许递归调用，但是不包含很多内置优化。与迭代优化不同，开发人员必须自己编写全递归改进代码。</li><li id="cd0e" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx ir">使用更多内存</strong>:每次调用都会保存调用堆栈中的前一步，直到递归过程完成。这意味着递归解决方案比迭代解决方案使用更多的内存。</li></ul><p id="9488" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:我没有增加任何一列的可读性，因为一些开发人员发现递归更容易理解，而另一些开发人员发现嵌套行为令人困惑。最终，这取决于每个问题和开发人员的具体情况。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="e267" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">Python中的递归</h1><p id="9b9b" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">现在让我们更深入地看看Python中的递归函数。</p><p id="0906" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一个递归打印模式的示例程序:<code class="fe nl nm nn no b">10 5 0 5 10</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c972" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们要把每个数字打印两次，除了<code class="fe nl nm nn no b">0</code>，中间只打印一次。这让我们知道<code class="fe nl nm nn no b">if (targetNumber &lt;= 0)</code>是我们的基本情况。</p><p id="e45d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们的递归例子是第7–9行。</p><p id="b37b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第8行，您可以看到递归调用<code class="fe nl nm nn no b">printPattern(targetNumber - 5)</code>，它将我们的程序移动到下一个递归步骤。</p><p id="8826" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第9行打印最后的<code class="fe nl nm nn no b">10</code>，并且在递归调用后只运行一次。</p><p id="d66a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">记住，只有递归调用之前的行为才会在递归循环中重复。</p><p id="5071" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看一下这个程序流程图，看看程序步骤是如何连接的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/b91e8db0f0c5bccce6de5528c52981af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0LUGJ9QVO7Q0Jh9t.PNG"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="5d37" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经把这个递归程序拆开了，让我们看看递归的一些应用。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="12fb" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">数字的Python递归</h1><h2 id="6d82" class="nv mn iq bd mo oa ob dn ms oc od dp mw le oe of my li og oh na lm oi oj nc ok bi translated">斐波那契数列</h2><p id="4e6a" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">首先，我们来看一个经典的递归例子:斐波那契数列。这个程序接受一个给定的数字并返回它的斐波那契数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c15d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在第二行看到我们的基本情况，<code class="fe nl nm nn no b">if n &gt;= 1</code>。如果不满足这一点，我们就进入第5行的递归情况，其中有两个递归调用。</p><p id="9ea7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每次循环递归时，<code class="fe nl nm nn no b">n</code>都会降低，这意味着我们的基本情况最终会变为真。</p><h2 id="8ba9" class="nv mn iq bd mo oa ob dn ms oc od dp mw le oe of my li og oh na lm oi oj nc ok bi translated">从1到<code class="fe nl nm nn no b">n</code>的总和</h2><p id="d0ff" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">现在我们来看看如何使用递归对从1到给定数字的所有数字求和。这个程序接受一个正整数作为输入，并返回一个从1到整数之间的所有数字之和的打印输出。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="4a6a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的程序从给定的数字开始，每递归一步就把数字加1，直到它达到1。</p><p id="9cc3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基础案例在第3行，<code class="fe nl nm nn no b">if targetNumber ==1</code>。递归的情况是将<code class="fe nl nm nn no b">targetNumber</code>的当前值相加，然后用一个低1的值调用<code class="fe nl nm nn no b">sumTill()</code>。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="e3bb" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">使用字符串和数组的Python递归</h1><p id="be3f" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">递归对字符串或数组也很有帮助。许多递归面试问题会要求您转换字符串或数组，直到所有字符串或数组都符合某个标准。</p><h2 id="c0cd" class="nv mn iq bd mo oa ob dn ms oc od dp mw le oe of my li og oh na lm oi oj nc ok bi translated">从字符串中删除空格</h2><p id="ffb4" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">在这个练习中，我们将创建一个程序，它接受一个给定的字符串并返回一个没有任何空格或制表符(<code class="fe nl nm nn no b">/t</code>)的新字符串。例如，<code class="fe nl nm nn no b">Hello World</code>会变成<code class="fe nl nm nn no b">HelloWorld</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a4d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从空字符串<code class="fe nl nm nn no b">""</code>中移除制表符只会返回空字符串<code class="fe nl nm nn no b">""</code>。因此，我们的基本情况是原始字符串为空(第3行)。</p><p id="7903" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于第7–10行的递归情况，我们检查当前元素是<code class="fe nl nm nn no b">"\t"</code>还是<code class="fe nl nm nn no b">" "</code>:</p><ul class=""><li id="8904" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">如果当前元素是<code class="fe nl nm nn no b">"\t"</code>或<code class="fe nl nm nn no b">" "</code>，我们丢弃它，并在移除该元素后调用函数的另一个实例。</li><li id="ef20" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">如果当前元素不是<code class="fe nl nm nn no b">"\t"</code>或<code class="fe nl nm nn no b">" "</code>，我们将它添加到输出字符串中，并在删除该元素后调用函数的另一个实例。</li></ul><h2 id="6b63" class="nv mn iq bd mo oa ob dn ms oc od dp mw le oe of my li og oh na lm oi oj nc ok bi translated">反转数组</h2><p id="397c" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">现在我们将创建一个递归程序，它接受一个给定的数组，并以相反的顺序返回相同的数组。</p><p id="1fad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，<code class="fe nl nm nn no b">1, 2, 3, 4</code>会变成<code class="fe nl nm nn no b">4, 3, 2, 1</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="44c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于这个解决方案，我们将创建一个临时变量来保存每个递归步骤中传递的数组的最后一个元素。最后，这些值将用于以相反的顺序重新填充数组，因为嵌套的递归函数最先完成。</p><p id="22f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个问题的基本情况是当数组中有0或1个元素时，因为反转这些数组将返回相同的数组。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="f0de" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">数据结构的Python递归</h1><p id="90f2" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">最后，让我们看看递归函数是如何在链表和二叉树这样的数据结构上使用的。</p><h2 id="6f26" class="nv mn iq bd mo oa ob dn ms oc od dp mw le oe of my li og oh na lm oi oj nc ok bi translated">反转一个链表</h2><p id="e2ff" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">反转一个链表类似于反转一个数组，但是有点复杂。这个程序将接受一个链表，并返回节点顺序相反的链表。</p><p id="ca33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，链表<code class="fe nl nm nn no b">3, 4, 7, 11</code>将有一个返回值<code class="fe nl nm nn no b">11, 7, 4, 3</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="be2d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码片段中，我们将链表<code class="fe nl nm nn no b">myLinkedList</code>传递给函数<code class="fe nl nm nn no b">reverse()</code>。这个函数检查链表的头是否是<code class="fe nl nm nn no b">null</code>。如果头节点不为空，我们称之为<code class="fe nl nm nn no b">helperFunction()</code>。这个函数是递归的，也是链表反转的地方。</p><p id="51f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe nl nm nn no b">helperFunction()</code>中，使用以下语句反转节点:</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="b3ab" class="nv mn iq no b gy nw nx l ny nz">next = current.next # The original next node of the current node is saved<br/>current.next = previous # The next of the current node is updated</span></pre><p id="b88d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更改之后，我们再次递归调用该函数:</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="0247" class="nv mn iq no b gy nw nx l ny nz"># Recursive case<br/>helperFunction(myLinkedList, next, current)<br/># The current node in the next recursive call will be the "next" node that we saved.<br/># The previous node will be the parent function's current node</span></pre><p id="de9e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个问题的基本情况是我们到达链表的末尾。这是<code class="fe nl nm nn no b">current</code>节点的<code class="fe nl nm nn no b">next</code>节点将成为<code class="fe nl nm nn no b">None</code>的地方。我们将这个最后的节点作为链表的头，更新它的位置，然后<code class="fe nl nm nn no b">return</code>。</p><h2 id="497a" class="nv mn iq bd mo oa ob dn ms oc od dp mw le oe of my li og oh na lm oi oj nc ok bi translated">从左到右打印二叉树的所有叶节点</h2><p id="0424" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">这个问题有点棘手，但正是你将在Python编码面试中看到的问题类型。</p><p id="06b4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将创建一个程序，打印树形图中从左到右出现的所有叶节点。这是我们将要用的树。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/d47576750bf50652c0b0521cc7e731c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*_I1aCaRneZrcP4qUkv5FXg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="4fd8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个树的正确解是<code class="fe nl nm nn no b">4 6 7 9 10</code>。</p><p id="0900" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">提醒</strong>:叶节点是没有子节点的节点，因此结束子树分支。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="368f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个程序获取根节点并从左到右打印所有叶节点。我们的基本情况是1)没有剩余节点，或者2)没有剩余叶节点。</p><p id="8fbb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">程序跟踪每个孩子的连接，每次都向左走，直到找到一个叶节点。程序打印这个值，然后沿着不同的节点路径重复这个子问题。</p><p id="b831" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最终，函数返回，所有叶节点将从左到右打印。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="9bf8" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">接下来学什么</h1><p id="d8b7" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">递归是任何Python开发人员技能的重要组成部分。递归问题在编码面试中经常占据面试问题的很大一部分，对于动态编程问题是必不可少的。学习这些概念的最好方法是亲身体验真实的面试问题。</p><p id="0bcb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你想不断进步，可以看看下面这些问题:</p><ul class=""><li id="8e11" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">0-1背包问题</li><li id="b417" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">平衡括号问题</li><li id="60d3" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">将树转换成双向链表</li><li id="12c5" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">反转一叠</li><li id="9b60" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">最低共同祖先</li></ul><p id="9e3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">快乐学习！</p></div></div>    
</body>
</html>