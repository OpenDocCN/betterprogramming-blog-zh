<html>
<head>
<title>Exploring LaunchedEffect and InfiniteTransition in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Jetpack合成中的LaunchedEffect和InfiniteTransition</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-launchedeffect-and-infinitetransition-in-jetpack-compose-5a82ba948a15?source=collection_archive---------3-----------------------#2022-09-20">https://betterprogramming.pub/exploring-launchedeffect-and-infinitetransition-in-jetpack-compose-5a82ba948a15?source=collection_archive---------3-----------------------#2022-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6bb6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Jetpack Compose制作动画—第3部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/88e0790bb9ffb4c861b6c5e7cea4f74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*alDPIjO_szWr096S"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@claybanks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">粘土堤</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3269" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Jetpack Compose是构建Android应用程序UI的革命性更新。它利用了声明式UI的概念，并带来了用Kotlin构建UI的乐趣——这是许多Android开发人员的梦想。如果您不熟悉Jetpack Compose，我建议您阅读以下文章:</p><ul class=""><li id="8633" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/jetpack-compose-components-part-1-a80717dbfb59">喷气背包构成组件(第一部分)</a></li><li id="6494" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/build-android-layouts-in-jetpack-compose-bda2e0837f5e">在Jetpack Compose中构建Android布局</a></li></ul><p id="bb97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解有关Jetpack Compose中动画的更多信息，请阅读本动画系列中的以下文章:</p><ul class=""><li id="e3cb" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/jetpack-compose-animation-notes-1-30f130189159">“Jetpack合成—动画注释:1”——探索合成中的动画可见性</a></li><li id="3ef6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://sgkantamani.medium.com/jetpack-compose-animation-notes-2-aef3428af6a6" rel="noopener">“Jetpack Compose—Animation Notes:2”——构建Fab菜单，带有Compose AnimatedVisibility和Animatable </a></li><li id="7141" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">“Jetpack Compose-Animation Notes:3”-你现在在这里</li></ul><p id="daca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">话虽如此，我们还是开始吧。</p><h1 id="39de" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">介绍</h1><h2 id="8ec3" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">目标是什么？</h2><p id="d1f9" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们正试图实现一个按钮刷新动画，包括无休止的旋转缩放文本和图标。看一看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/cb33cc601d377caa1beaa566a3c6b682.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/1*Y8gJd8DbY6l4VeUJavc9gw.gif"/></div></figure><h2 id="f9fc" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated"><code class="fe nt nu nv nw b">LaunchedEffect</code></h2><p id="24ad" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><code class="fe nt nu nv nw b">LaunchedEffect</code>是一个有两个参数的组合函数——key 1和block。</p><ol class=""><li id="f260" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nx mb mc md bi translated"><code class="fe nt nu nv nw b">key1</code> —类型为<code class="fe nt nu nv nw b">Any</code>，每当该参数传入的值发生变化，就会触发<code class="fe nt nu nv nw b">block</code>函数。</li><li id="1422" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated"><code class="fe nt nu nv nw b">block</code> — Kotlin <code class="fe nt nu nv nw b">suspend</code>具有自己的协程作用域。每当值<code class="fe nt nu nv nw b">key1</code>更新时，运行范围被取消并重新启动。当LaunchedEffect离开组合时，协程将被取消。</li></ol><p id="1722" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看函数签名:</p><pre class="kj kk kl km gt ny nw nz oa aw ob bi"><span id="27c8" class="nb mk it nw b gy oc od l oe of">@Composable<br/>@NonRestartableComposable<br/>@OptIn(InternalComposeApi::class)<br/>fun LaunchedEffect(<br/>    key1: Any?,<br/>    block: suspend CoroutineScope.() -&gt; Unit<br/>)</span></pre><p id="b55b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的用例中，我们可以使用<code class="fe nt nu nv nw b">LaunchedEffect</code>函数在任何状态变化触发的初始合成或重组时执行动画。</p><h2 id="3055" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">无限位置</h2><p id="a82d" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><code class="fe nt nu nv nw b">InfiniteTransition</code>负责运行子动画。通过使用<code class="fe nt nu nv nw b">rememberInfiniteTransition</code>，我们可以运行无限的子动画。在我们的例子中，我们可以用它来无限旋转加载图标。</p><h1 id="bdeb" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">按钮状态</h1><p id="840c" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">让我们创建一个具有文本和图标两种状态的枚举类，在按钮中显示文本或图标。让我们也创建一个扩展函数来返回相反的状态，它可以用来更新用户动作的状态。看一看:</p><pre class="kj kk kl km gt ny nw nz oa aw ob bi"><span id="642c" class="nb mk it nw b gy oc od l oe of">enum class ButtonState{<br/>    TEXT, ICON<br/>}</span><span id="beda" class="nb mk it nw b gy og od l oe of">fun ButtonState.getOppositeState() : ButtonState = when(this){<br/>    ButtonState.TEXT -&gt; ButtonState.ICON<br/>    ButtonState.ICON -&gt; ButtonState.TEXT<br/>}</span></pre><h1 id="67ac" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">设计刷新按钮</h1><p id="d8c3" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">为了设计刷新按钮，我们使用了可组合的<code class="fe nt nu nv nw b">Box</code>作为根，因为在任何给定的点，只有<code class="fe nt nu nv nw b">Text</code>或<code class="fe nt nu nv nw b">Icon</code>会出现。看一下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="d446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将以下颜色添加到项目<code class="fe nt nu nv nw b">color.kt</code>类中:</p><pre class="kj kk kl km gt ny nw nz oa aw ob bi"><span id="8291" class="nb mk it nw b gy oc od l oe of">val GreenButton = <em class="oj">Color</em>(0xFF00914b)</span></pre><p id="d6d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/ec9f5055f1f54eae6748fc63b45ed7bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/1*K3GWrBx5LpwBzuAgYyTj3A.gif"/></div></figure><p id="fc0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在进入动画部分之前，首先，我们需要消除涟漪效应，因为它不适合我们的自定义动画。我们可以通过在<code class="fe nt nu nv nw b">Modifier</code>上创建任何扩展并处理<code class="fe nt nu nv nw b">clickable</code>函数的<code class="fe nt nu nv nw b">indication</code>和<code class="fe nt nu nv nw b">interactionSource</code>参数来实现这一点，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="4e37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以在根<code class="fe nt nu nv nw b">Box</code> composable上使用<code class="fe nt nu nv nw b">clickableNoRipple</code>函数代替<code class="fe nt nu nv nw b">clickable</code>。</p><h1 id="0ee9" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">无限旋转</h1><p id="f597" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">让我们从更简单的动画开始，当按钮的状态变为<code class="fe nt nu nv nw b">ICON</code>时，我们必须旋转刷新图标。为此，我们必须使用由图标包装的<code class="fe nt nu nv nw b">Modifer</code>的<code class="fe nt nu nv nw b">rotate</code>扩展功能。<code class="fe nt nu nv nw b">rotate</code>以<code class="fe nt nu nv nw b">float</code>为参数，表示旋转的度数。</p><p id="0b99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里棘手的部分是计算度数，<code class="fe nt nu nv nw b">rememberInfiniteTransition</code>是适合这个目的的。让我们创建一个单独的可组合组件来创建和维护这个转换。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="3661" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv nw b">animateFloat</code>是<code class="fe nt nu nv nw b">InfiniteTransition</code>的扩展功能。它有三个参数:</p><ol class=""><li id="bf1f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nx mb mc md bi translated"><code class="fe nt nu nv nw b">initialValue</code> —表示初始度数的浮点值。</li><li id="bbc2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated"><code class="fe nt nu nv nw b">targetValue</code> —一个浮点值，指示动画结束时的度数。</li><li id="9135" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated"><code class="fe nt nu nv nw b">animationSpec</code> —表示动画细节的参数。在我们的例子中是<code class="fe nt nu nv nw b">infiniteRepeatable</code>，使用<code class="fe nt nu nv nw b">tween</code>来控制持续时间和重复模式。</li></ol><p id="d464" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，我们必须将<code class="fe nt nu nv nw b">rotateComposable</code>与附加到可组合图标框的<code class="fe nt nu nv nw b">Modifier</code>一起使用。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="6d5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/6db3f08a3ea984f2be8292bac2a20649.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/1*lYBadMnk6skYSV1BuFFEjg.gif"/></div></figure><h1 id="010d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">使用LaunchedEffect缩放动画</h1><p id="0c1f" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">先说需要动画的三个方面——文字、图标缩放、文字内容变化。对于缩放部分，我们可以使用<code class="fe nt nu nv nw b">Animatable</code>和<code class="fe nt nu nv nw b">remember</code>，对于内容部分，我们可以使用<code class="fe nt nu nv nw b">mutableStateOf</code>，看看:</p><pre class="kj kk kl km gt ny nw nz oa aw ob bi"><span id="dff2" class="nb mk it nw b gy oc od l oe of">val scaleText = remember{ <em class="oj">Animatable</em>(initialValue = 1f) }<br/>val scaleIcon = <em class="oj">remember</em>{ <em class="oj">Animatable</em>(initialValue = 0f) }<br/>var displayString by remember { <em class="oj">mutableStateOf</em>("Refresh")}</span></pre><p id="e598" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初，将显示可组合的<code class="fe nt nu nv nw b">Text</code>，因此<code class="fe nt nu nv nw b">scaleText</code>的<code class="fe nt nu nv nw b">initialValue</code>是<code class="fe nt nu nv nw b">1f</code>。而<code class="fe nt nu nv nw b">scaleIcon</code>是<code class="fe nt nu nv nw b">0f</code>，因为它将被隐藏。</p><p id="09fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用<code class="fe nt nu nv nw b">refershScalingAnimation</code>创建一个简单的<code class="fe nt nu nv nw b">Composable</code>函数，它有两个参数:</p><ol class=""><li id="4911" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nx mb mc md bi translated"><code class="fe nt nu nv nw b">buttonState</code> —执行各自的缩放动画和内容变化。</li><li id="1b51" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated"><code class="fe nt nu nv nw b">isSelected</code> — <code class="fe nt nu nv nw b">Boolean</code>用作<code class="fe nt nu nv nw b">LaunchedEffect</code>键的参数。</li></ol><p id="4f84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="69cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们必须使用<code class="fe nt nu nv nw b">scaleText</code>和<code class="fe nt nu nv nw b">scaleIcon</code>上的<code class="fe nt nu nv nw b">animateTo</code>功能来触发各自块中的缩放动画。如果按钮状态是<code class="fe nt nu nv nw b">ICON</code>，那么我们必须从<code class="fe nt nu nv nw b">scaleText</code>开始，将<code class="fe nt nu nv nw b">targetValue</code>作为<code class="fe nt nu nv nw b">0f</code>，然后将<code class="fe nt nu nv nw b">displayString</code>更新为空，最后通过<code class="fe nt nu nv nw b">scaleIcon</code>将图标缩放到<code class="fe nt nu nv nw b">1f</code>。如果<code class="fe nt nu nv nw b">buttonState</code>是<code class="fe nt nu nv nw b">TEXT</code>，我们必须反转动画。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="73ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步是使用<strong class="lb iu"> </strong> <code class="fe nt nu nv nw b">scaleText</code>和<code class="fe nt nu nv nw b">scaleIcon</code>，修改器应用于<code class="fe nt nu nv nw b">Text</code>和<code class="fe nt nu nv nw b">Icon</code>可组合函数<strong class="lb iu">。</strong>由于我们已经为<code class="fe nt nu nv nw b">LaunchedEffect</code>动画创建了一个单独的函数，我们必须返回<code class="fe nt nu nv nw b">scaleText</code>、<code class="fe nt nu nv nw b">scaleIcon</code>和<code class="fe nt nu nv nw b">displayString</code>来使用它们各自的可组合函数。看看完整的功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="d465" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们从<code class="fe nt nu nv nw b">ButtonRefresh</code>触发<code class="fe nt nu nv nw b">refershScalingAnimation</code>，并将<code class="fe nt nu nv nw b">scaleText</code>、<code class="fe nt nu nv nw b">scaleIcon</code>和<code class="fe nt nu nv nw b">displayString</code>应用于各自的可组合函数。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="4ee8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/cb33cc601d377caa1beaa566a3c6b682.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/1*Y8gJd8DbY6l4VeUJavc9gw.gif"/></div></figure><h1 id="c49e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="439a" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">仅此而已。我们用<code class="fe nt nu nv nw b">LaunchedEffect</code>和<code class="fe nt nu nv nw b">InfiniteTransition</code>可组合函数实现了一个定制的刷新按钮动画。请点击此处查看完整代码。在Jetpack Compose中，动画是一个有趣的话题，可以为UI带来更流畅的自然效果。请继续关注Jetpack Compose中关于动画的更多文章。</p><h1 id="93be" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">奖金</h1><div class="ol om gp gr on oo"><a rel="noopener  ugc nofollow" target="_blank" href="/back-press-handling-in-android-jetpack-compose-42d9ed402d40"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">Android Jetpack Compose中的反压处理</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">创建一个处理函数来定制你的反压事件</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">better编程. pub</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div><p id="7a5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>