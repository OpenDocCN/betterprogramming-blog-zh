<html>
<head>
<title>Composing SwiftUI Navigation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写SwiftUI导航</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/composing-swiftui-navigation-3d67198b6acb?source=collection_archive---------6-----------------------#2021-11-10">https://betterprogramming.pub/composing-swiftui-navigation-3d67198b6acb?source=collection_archive---------6-----------------------#2021-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="edcb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将你的应用程序放在模块中，在根级别构建应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dcd304da61ee8eb58c9b8fe804e61d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*APJKyEGUYor94Ytb"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@yassine_khalfalli?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚辛·哈尔法利</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="2697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们日常使用的应用程序随着每个版本的发布变得越来越复杂。它们有更多的功能，而且更加精致。更大的应用程序意味着更长的构建时间和不容易管理的内在复杂性。</p><p id="070c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多这些问题的解决方案是一种叫做<a class="ae ky" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm" rel="noopener ugc nofollow" target="_blank"> <em class="lv">分治</em> </a>的问题解决技术。在移动应用程序领域，这是通过编写模块化应用程序来实现的。</p><p id="b0f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模块化应用程序有几个好处:</p><ul class=""><li id="1463" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><strong class="lb iu">缩短构建时间。</strong> Xcode可以缓存模块，避免重新编译那些没有改变的模块。</li><li id="6aa7" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">平行发展。不同的团队成员可以独立地处理不同的模块。这意味着冲突数量的减少。</strong></li><li id="0df4" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">孤立发展。每个模块都独立存在，因此我们可以忽略系统的其余部分。</strong></li><li id="a508" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">更好地分离关注点。</strong>每个模块体现一个单一的特征或服务。它的责任应该永远是明确的。</li></ul><p id="a09a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，编写模块化应用程序并不容易。我们需要正确地设计我们的应用程序，我们需要尽可能地分离模块。</p><p id="b219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天的文章中，我想展示我们如何在SwiftUI应用中实现这一点。模块化的主要障碍之一是导航:<code class="fe mk ml mm mn b">NavigationLink</code>和<code class="fe mk ml mm mn b">Tabbar</code>要求我们在层次结构中声明一个特定的目的地<code class="fe mk ml mm mn b">View</code>，这可能会将两个不同的模块耦合在一起。</p><p id="add2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从一个经典的SwiftUI应用程序开始，逐步将其分成多个模块。我们探索创建模块的各种备选方案以及如何连接它们。</p><h1 id="fa01" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">启动应用程序</h1><p id="05d6" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们要模块化的app是下面这个。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/d2fe4f24aae95fa887b4f6d8a6e1f87f.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*vqo7S9mKJvoCEqDwy3A_pQ.gif"/></div></figure><p id="e4e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用程序已经被组织在文件夹中，但是每个组件都知道所有其他组件的存在。目标是为每个文件夹创建一个单独的模块。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/0e85087c07ad56d0afbf1f0fd0890b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*VIHtAeWgCLUplmueVNzVmQ.png"/></div></figure><p id="c087" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查主要的SwiftUI视图，分析它们是如何连接的。让我们从<code class="fe mk ml mm mn b">Tabbar</code>开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="289e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mk ml mm mn b">Tabbar</code>的主体中有一个<code class="fe mk ml mm mn b">TabView</code>,其中包含一些视图。每个视图都有一个图像和一个名称来定制选项卡。<code class="fe mk ml mm mn b">tabbarItem</code>修改器是一个自定义修改器，以避免重复代码:它使用标准的<code class="fe mk ml mm mn b">.tabItem</code>，其中有一个<code class="fe mk ml mm mn b">VStack</code>、<code class="fe mk ml mm mn b">Image</code>和<code class="fe mk ml mm mn b">Text</code>视图。</p><p id="c2ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到<code class="fe mk ml mm mn b">Tabbar</code>有两个硬编码的视图作为选项卡内容:一个<code class="fe mk ml mm mn b">JournalView</code>和一个<code class="fe mk ml mm mn b">Text</code>。这意味着<code class="fe mk ml mm mn b">Tabbar</code>组件依赖于<code class="fe mk ml mm mn b">JournalView</code>组件。</p><p id="3b67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来探索一下<code class="fe mk ml mm mn b">JournalView</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7e0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主<code class="fe mk ml mm mn b">body</code>由三部分组成:<code class="fe mk ml mm mn b">moodSection</code>、<code class="fe mk ml mm mn b">goalSection</code>和<code class="fe mk ml mm mn b">gratitudeSection</code>。每个部分都由一个计算属性创建，以保持<code class="fe mk ml mm mn b">body</code>小且可读。每个部分的内容彼此相似:它们都有一个硬编码的<code class="fe mk ml mm mn b">content</code>(为了保持示例简单)和一个<code class="fe mk ml mm mn b">header</code>。</p><p id="8e0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mk ml mm mn b">header</code>是一个定制的SwiftUI视图，接受标题、图像和目的地作为参数。<code class="fe mk ml mm mn b">moodSection</code>与<code class="fe mk ml mm mn b">MoodView</code>相联<code class="fe mk ml mm mn b">goalsSection</code>与<code class="fe mk ml mm mn b">GoalsView</code>相联。这是另外两个硬编码的依赖关系:<code class="fe mk ml mm mn b">JournalView</code>明确地依赖于<code class="fe mk ml mm mn b">MoodView</code>和<code class="fe mk ml mm mn b">GoalsView</code>。</p><p id="1827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的依赖关系图如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/6cce685ecbefb5c81637754ac9363768.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*BvJgYYRtqdLP0eNSuuleLw.png"/></div></figure><h1 id="6ec3" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">模块化</h1><p id="b1ff" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">本文的目标是解耦所有的模块:它们中的任何一个都不应该知道其他任何一个。只有<code class="fe mk ml mm mn b">ComposableNavigationApp</code>知道所有的组件，它会把整个应用程序组合在一起。</p><p id="6f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在整篇文章中，我们将尝试使用闭包来解耦各个模块。我们将看到<code class="fe mk ml mm mn b">SwiftUI</code>的<code class="fe mk ml mm mn b">View</code>协议如何阻碍这一进程，但我们将看到如何解决它。</p><p id="7fa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们必须为每个组件创建一个单独的模块。创建模块有四种不同的方法:</p><ol class=""><li id="3973" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu nq mc md me bi translated">我们可以在Xcode中创建一个动态框架</li><li id="a685" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nq mc md me bi translated">我们可以在Xcode中创建一个静态库</li><li id="a262" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nq mc md me bi translated">我们可以使用Swift软件包创建一个动态框架</li><li id="82c1" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nq mc md me bi translated">我们可以使用Swift包创建一个静态库</li></ol><h2 id="b386" class="nr mp it bd mq ns nt dn mu nu nv dp my li nw nx na lm ny nz nc lq oa ob ne oc bi translated">静态库与动态框架</h2><p id="4d4e" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><strong class="lb iu">静态库</strong>和<strong class="lb iu">动态框架</strong>都是用来达到同样的效果:将一些逻辑封装在我们可以重用的模块中。</p><p id="ff90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种方法的主要区别在于它们在应用程序启动时的行为，而选择的方法会影响应用程序的大小或启动时间。</p><p id="68cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不涉及太底层的细节，<strong class="lb iu">动态框架</strong>被编译成一个扩展名为<code class="fe mk ml mm mn b">dylib</code>的文件:它代表动态库。当应用程序启动时，启动器将所有动态框架加载到内存中，并在运行时将它们链接到应用程序。</p><p id="a15b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">静态库</strong>被压缩到一个扩展名为<code class="fe mk ml mm mn b">.a</code>的档案中。它们是应用程序的一部分，在运行时不需要动态加载和链接。</p><p id="17a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两者之间的主要区别是<strong class="lb iu">动态库</strong>更小，但它们使应用程序的启动过程更慢；<strong class="lb iu">静态库</strong>让你的应用程序更大，但不需要更多的时间来启动应用程序。一如既往，在选择您需要什么时，请考虑这种权衡。</p><p id="dffb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网上有许多文章更详细地描述了它们的优缺点:</p><ul class=""><li id="06fa" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae ky" href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html" rel="noopener ugc nofollow" target="_blank">苹果动态库</a></li><li id="b08c" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://www.runtastic.com/blog/en/frameworks-ios/" rel="noopener ugc nofollow" target="_blank">静态和动态框架的运行概述</a></li><li id="9514" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://www.vadimbulavin.com/static-dynamic-frameworks-and-libraries/" rel="noopener ugc nofollow" target="_blank">瓦丁·布拉文在iOS中的静态和动态库和框架</a></li></ul><h2 id="a0fa" class="nr mp it bd mq ns nt dn mu nu nv dp my li nw nx na lm ny nz nc lq oa ob ne oc bi translated">使用框架创建模块</h2><p id="62f1" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">让我们首先将<code class="fe mk ml mm mn b">Goals</code>文件夹提取到一个<code class="fe mk ml mm mn b">GoalsView</code>框架中。<code class="fe mk ml mm mn b">Goals</code>不依赖于任何东西，所以我们不需要改变代码库来提取它。</p><ul class=""><li id="ef3c" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">点击<code class="fe mk ml mm mn b">File</code>菜单，然后选择<code class="fe mk ml mm mn b">New</code>和<code class="fe mk ml mm mn b">Target</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/199783f0ae4ee8fd304caf97d2c5f652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JAJvZFYGVGdIpExPO4vd5g.png"/></div></div></figure><ul class=""><li id="af92" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">选择对话框中的<code class="fe mk ml mm mn b">iOS</code>选项卡，向下滚动直到我们在<code class="fe mk ml mm mn b">Framework and Library</code>部分找到<code class="fe mk ml mm mn b">Framework</code>项目</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/d5ec2faf4a42a347a063c31d2b9bf6a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IVi5qteb4wkT5ndDdLtRfA.png"/></div></div></figure><ul class=""><li id="3dcb" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">在文本字段中键入<code class="fe mk ml mm mn b">GoalsView</code>名称，并确保将<code class="fe mk ml mm mn b">Project</code>选项和<code class="fe mk ml mm mn b">Embed in Application</code>选项设置为app值(在我的示例中为<code class="fe mk ml mm mn b">ComposableNavigation</code>)。然后点击<code class="fe mk ml mm mn b">Finish</code>。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/b3abdcac9c23420682259ba55e7eac5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LluraJJQyHZ8NvlaipLpkA.png"/></div></div></figure><p id="3882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Xcode将创建一个名为<code class="fe mk ml mm mn b">GoalsView</code>的文件夹，其中包含一个<code class="fe mk ml mm mn b">GoalsView.h</code>文件:这是Objective-C所需框架的头文件。我们可以安全地删除它。</p><p id="31a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，让我们将<code class="fe mk ml mm mn b">GoalsView.swift</code>文件从应用程序移动到模块中。如果我们现在尝试构建应用程序，它将会失败:<code class="fe mk ml mm mn b">JournalView</code>正在尝试创建一个<code class="fe mk ml mm mn b">GoalsView</code>，但是它不知道它是否存在。</p><p id="de5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们必须将新模块导入到<code class="fe mk ml mm mn b">JournalView.swift</code>文件中。我们来补充一个<code class="fe mk ml mm mn b">import GoalsView</code>语句。让我们尝试构建，我们将观察到另一个失败:仍然无法到达<code class="fe mk ml mm mn b">GoalsView</code>。我们需要使它成为<code class="fe mk ml mm mn b">public</code>:组件现在存在于一个单独的模块中，我们需要使用正确的可访问性修饰符来访问它。</p><p id="8dc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的<code class="fe mk ml mm mn b">GoalsView</code>是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="1ada" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在单独的模块中移动SwiftUI视图时，我们需要创建三个元素<code class="fe mk ml mm mn b">public</code>:</p><ol class=""><li id="fdb7" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu nq mc md me bi translated">视图类型。</li><li id="7615" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nq mc md me bi translated"><code class="fe mk ml mm mn b">body</code>计算变量。</li><li id="71e0" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nq mc md me bi translated">一个<code class="fe mk ml mm mn b">init</code>让客户端初始化组件。</li></ol><p id="820b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这些更改，应用程序将会成功构建。</p><h2 id="b8fb" class="nr mp it bd mq ns nt dn mu nu nv dp my li nw nx na lm ny nz nc lq oa ob ne oc bi translated">使用静态库创建模块</h2><p id="448a" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">现在是时候将<code class="fe mk ml mm mn b">Mood</code>组件移动到静态库中了。</p><p id="e0f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该过程与我们对框架遵循的过程完全相同，但是在这种情况下，我们应该在<strong class="lb iu">目标</strong>对话框中选择<strong class="lb iu">静态库</strong>而不是<strong class="lb iu">框架</strong>。</p><p id="7a51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<strong class="lb iu">静态库</strong>需要一个额外的步骤:我们需要手动将其嵌入到项目中。为此:</p><ul class=""><li id="8cf3" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">在<code class="fe mk ml mm mn b">Project Navigator</code>中选择项目。</li><li id="60a2" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">在中央面板中选择应用程序</li><li id="d62f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">选择<code class="fe mk ml mm mn b">General</code>标签</li><li id="5162" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">向下滚动到<code class="fe mk ml mm mn b">Frameworks, Libraries, and Embedded Content</code></li><li id="34a5" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">点击<code class="fe mk ml mm mn b">+</code>按钮，添加<code class="fe mk ml mm mn b">libMoods.a</code>静态库。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/5d7e87c96371e84c164b8656c36c03eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*toxCcYEm9br7m7zSru8Kjg.png"/></div></div></figure><p id="badf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样在这种情况下，我们需要设置一些元素为<code class="fe mk ml mm mn b">public</code>:<code class="fe mk ml mm mn b">MoodView</code>，它的<code class="fe mk ml mm mn b">body</code>属性和它的<code class="fe mk ml mm mn b">init</code>。最后，我们需要在<code class="fe mk ml mm mn b">JournalView</code>文件中导入新模块。</p><p id="1831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>确保您的应用程序始终具有相同的部署目标。您可以通过选择<code class="fe mk ml mm mn b">Moods</code>目标及其<strong class="lb iu">构建设置</strong>来更新它。然后你可以过滤掉<strong class="lb iu"> iOS部署目标</strong>并更改它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/48e5278fe6f2df39d11c0a8ddac017a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hbQrGK8nrrhQMTIi8BXCiw.png"/></div></div></figure><h2 id="7d3f" class="nr mp it bd mq ns nt dn mu nu nv dp my li nw nx na lm ny nz nc lq oa ob ne oc bi translated">使用静态包</h2><p id="ad6c" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">现在来看看我们的<code class="fe mk ml mm mn b">JournalView</code>吧。代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d09c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mk ml mm mn b">import</code>部分是最有趣的部分。它显式声明了这个模块的依赖关系。</p><p id="9d1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的目标是打破这种依赖，这样我们就可以从一个更高层次的组件定制导航，让<code class="fe mk ml mm mn b">JournalView</code>不知道它的目的地。有不同的方式来实现这一点:工厂，关闭和其他模式。为了简单起见，我们将只使用闭包。</p><p id="01d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个想法是传递一个闭包，它可以在<code class="fe mk ml mm mn b">JournalView</code>的<code class="fe mk ml mm mn b">init</code>中返回任何类型的视图。该闭包将填充<code class="fe mk ml mm mn b">destination</code>字段，因此当用户试图导航时，闭包被调用，目的地被创建。闭包封装了实际的目的地，因此<code class="fe mk ml mm mn b">JournalView</code>不必依赖于任何具体的<code class="fe mk ml mm mn b">View</code>。</p><p id="1e85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们不能简单地拥有一个返回<code class="fe mk ml mm mn b">View</code>的闭包:SwiftUI的<code class="fe mk ml mm mn b">View</code>协议有一个使用<code class="fe mk ml mm mn b">Self</code>的关联类型。我们只能把它作为约束而不能作为类型。我们甚至不能有一个返回opaque <code class="fe mk ml mm mn b">some View</code>的闭包，因为opaque类型需要在编译时已知，而我们无法确保这一点。</p><p id="81f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们可以使用泛型。我们知道在这个例子中<code class="fe mk ml mm mn b">JournalView</code>将由两个部分组成，所以泛型类型的数量是固定的。我们可以更新我们的<code class="fe mk ml mm mn b">JournalView</code>来接受两种不同的泛型类型:<code class="fe mk ml mm mn b">Goals</code>和<code class="fe mk ml mm mn b">Moods</code>。这两种类型都符合<code class="fe mk ml mm mn b">View</code>协议。</p><p id="0b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个改变，我们可以定义返回泛型<code class="fe mk ml mm mn b">View</code>的闭包。代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="eae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们能够删除<code class="fe mk ml mm mn b">import</code> s语句:<code class="fe mk ml mm mn b">JournalView</code>不再依赖于其他模块。然而，这一改变破坏了SwiftUI预览和<code class="fe mk ml mm mn b">Tabbar</code>视图，因为<code class="fe mk ml mm mn b">JournalView</code> init已经改变。我们需要为init参数提供一些合适的值。</p><p id="8395" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预览可以用一些返回虚拟视图的闭包来更新。必须通过导入<code class="fe mk ml mm mn b">Moods</code>和<code class="fe mk ml mm mn b">Goals</code>模块并创建正确的闭包来更新<code class="fe mk ml mm mn b">Tabbar</code>。代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="dba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然<code class="fe mk ml mm mn b">JournalView</code>不依赖于任何其他模块，我们可以为它创建一个包。为此:</p><ol class=""><li id="da9d" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu nq mc md me bi translated">选择<code class="fe mk ml mm mn b">File</code>菜单，然后选择<code class="fe mk ml mm mn b">New</code>和<code class="fe mk ml mm mn b">Package…</code></li><li id="5ec5" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nq mc md me bi translated">给包命名为<code class="fe mk ml mm mn b">Journal</code>,并确保将它添加到正确的项目中。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/c64a161a519c5bbbf04a63e3505d7f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vMpheCzJtv_HYVDUV1r3Qw.png"/></div></div></figure><p id="bb0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Xcode在项目中创建包。然而，我们的工作还没有完成。我们需要支持正确的iOS版本。为此，让我们打开<code class="fe mk ml mm mn b">Package.swift</code>文件并对其进行更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f290" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第5行，我们添加了<code class="fe mk ml mm mn b">platforms</code>字段来声明我们只为iOS构建。</p><p id="256f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要将包添加到我们的应用程序中。为此:</p><ul class=""><li id="ac7c" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">在<code class="fe mk ml mm mn b">Project Navigator</code>中选择项目。</li><li id="268f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">在中央面板中选择应用程序</li><li id="b636" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">选择<code class="fe mk ml mm mn b">General</code>标签</li><li id="f9e9" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">向下滚动到<code class="fe mk ml mm mn b">Frameworks, Libraries, and Embedded Content</code></li><li id="7bef" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">点击<code class="fe mk ml mm mn b">+</code>按钮，添加<code class="fe mk ml mm mn b">Journal</code>静态库。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/58aff8d80c9bdcfd7383a4d201635d5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EeWr_F5Mer_ghe-QpmilGg.png"/></div></div></figure><p id="3a00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步是将<code class="fe mk ml mm mn b">Journal</code>文件从应用程序移动到模块。确保<code class="fe mk ml mm mn b">JournalView</code>，它的<code class="fe mk ml mm mn b">init</code>，和它的<code class="fe mk ml mm mn b">body</code>属性都是<code class="fe mk ml mm mn b">public</code>。</p><p id="e085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mk ml mm mn b">init</code>必须接受我们作为参数引入的两个闭包。上面的<code class="fe mk ml mm mn b">JournalView</code>已经正确配置，并且<code class="fe mk ml mm mn b">init</code>可以在第8行和第14行之间找到。</p><p id="c653" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新的包打破了<code class="fe mk ml mm mn b">Tabbar</code>，现在必须导入<code class="fe mk ml mm mn b">Journal</code>模块才能正常工作。让我们添加<code class="fe mk ml mm mn b">import Journal</code>语句来构建我们的应用程序。</p><h2 id="5119" class="nr mp it bd mq ns nt dn mu nu nv dp my li nw nx na lm ny nz nc lq oa ob ne oc bi translated">使用动态包</h2><p id="e408" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们现在拥有了所有互不依赖的模块。<code class="fe mk ml mm mn b">Tabbar</code>是将所有东西粘合在一起的组件。我们可以将<code class="fe mk ml mm mn b">Tabbar</code>视为我们的组合根:在这种情况下，我们完成了模块化工作。</p><p id="8a31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，还有一个元素更适合作为复合根，即<code class="fe mk ml mm mn b">App</code>对象。这创造了添加另一个模块的机会:我们可以使<code class="fe mk ml mm mn b">Tabbar</code>更加灵活，并与应用程序的其余部分分离。</p><p id="de22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了对<code class="fe mk ml mm mn b">Tabbar</code>去耦，我们可以采用与<code class="fe mk ml mm mn b">JournalView</code>相似的方法。我们可以创建几个泛型类型，每个选项卡一个，我们可以使用闭包在运行时创建它们。</p><p id="174c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这对于<code class="fe mk ml mm mn b">Tabbar</code>是有限制的:使用泛型，我们需要预先指定我们将拥有多少个选项卡。标签也需要一个名字和一个图标，我们不能用一个简单的类属来指定它们。所以，一般的方法不能满足所有的需求。</p><p id="b358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以想到的另一种方法是使用协议。但是，选项卡需要是<code class="fe mk ml mm mn b">View</code>，并且<code class="fe mk ml mm mn b">View</code>协议将<code class="fe mk ml mm mn b">Self</code>作为关联类型。我们只能把它作为约束，不能作为类型。这种方法并不完全有效。</p><p id="222f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个(可行的)解决方案是使用一个<code class="fe mk ml mm mn b">struct</code>来保存我们需要的<code class="fe mk ml mm mn b">Tabbar</code>项的属性。该结构还将包含一个闭包来提供<code class="fe mk ml mm mn b">View</code>。假设我们希望将这些结构存储在一个数组中，我们不能使用泛型结构:每个结构都是不同的类型。相反，我们可以声明一个返回<code class="fe mk ml mm mn b">AnyView</code>类型的闭包。这种类型是一个不透明的盒子，可以包含任何种类的<code class="fe mk ml mm mn b">View</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c228" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般不建议在Swift中使用<code class="fe mk ml mm mn b">Any</code>。然而，在这种情况下，我们永远不需要将这些<code class="fe mk ml mm mn b">View</code>转换成它们的特定类型。我们想要的是一种以通用方式表示SwiftUI视图的方法。</p><p id="c849" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个助手，我们可以重写<code class="fe mk ml mm mn b">Tabbar</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="b14d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了这种概括，我们设法去掉了所有的<code class="fe mk ml mm mn b">import</code>。然后，我们声明了一个数组，我们的新结构。</p><p id="619e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mk ml mm mn b">body</code>中，我们使用了一个<code class="fe mk ml mm mn b">ForEach</code>来遍历提供者以创建所有的选项卡，并且我们使用了struct属性来定制<code class="fe mk ml mm mn b">Tabbar</code>项。</p><p id="77d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们终于可以为<code class="fe mk ml mm mn b">Tabbar</code>创建一个包了。该程序与我们对<code class="fe mk ml mm mn b">JournalView</code>所遵循的程序完全相同。要创建一个动态包，我们只需要更新产品部分的<code class="fe mk ml mm mn b">Package.swift</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ec60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第8行，我们指定包的<code class="fe mk ml mm mn b">type</code>是<code class="fe mk ml mm mn b">dynamic</code>。</p><p id="bb7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以将<code class="fe mk ml mm mn b">Tabbar</code>文件复制到这个新包中。记得将包添加到<code class="fe mk ml mm mn b">Frameworks, Libraries, and Embedded Content</code>列表中，并使<code class="fe mk ml mm mn b">public</code>成为<code class="fe mk ml mm mn b">struct</code> s、它们的<code class="fe mk ml mm mn b">init</code> s和<code class="fe mk ml mm mn b">body</code>属性。</p><p id="5059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一变化迫使我们更新<code class="fe mk ml mm mn b">App</code>组件和<code class="fe mk ml mm mn b">Tabbar</code>的预览。类型的变化是最有趣的:我们需要导入应用程序的所有模块，并且我们需要配置导航。</p><p id="a32c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终结果如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="962b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建一个带有两个选项卡的<code class="fe mk ml mm mn b">Tabbar</code>。每个选项卡都由它自己的提供者描述，提供者返回<code class="fe mk ml mm mn b">TabView</code>内容的特定视图。鉴于闭包必须返回一个<code class="fe mk ml mm mn b">AnyView</code>，我们创建了一个小的<code class="fe mk ml mm mn b">erased</code>实用程序来将特定视图转换为<code class="fe mk ml mm mn b">AnyView</code>。</p><p id="795c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最终可以从<code class="fe mk ml mm mn b">App</code>类型组合我们的应用程序。这是应用程序唯一知道所有模块的地方。我们最终将所有模块相互分离。</p><h1 id="d56b" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">结论</h1><p id="27a4" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在今天的文章中，我们探讨了如何模块化使用SwiftUI的现有应用程序。</p><p id="55e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过使用四种不同的技术创建四个模块来完成这个过程。我们简单讨论一下<strong class="lb iu">静态库</strong>和<strong class="lb iu">动态框架</strong>的区别。</p><p id="88a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们探索了如何使用闭包来解耦模块。闭包作为我们需要的类型的匿名工厂工作。当我们知道需要注入的视图数量时，我们可以使用泛型。否则，我们可以使用<code class="fe mk ml mm mn b">AnyView</code>擦除类型作为闭包的返回类型。</p><p id="cfb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的结果是一个模块化的应用程序，带有完全解耦的模块，我们可以从<code class="fe mk ml mm mn b">App</code>组件中组合这些模块。这是了解和使用所有模块的唯一地方。</p><p id="99c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整个代码(重构前)可以在<a class="ae ky" href="https://github.com/cipolleschi/ComposableNavigation" rel="noopener ugc nofollow" target="_blank">主分支</a>中找到。模块化后的代码可以在<code class="fe mk ml mm mn b"><a class="ae ky" href="https://github.com/cipolleschi/ComposableNavigation/tree/composableNavigation" rel="noopener ugc nofollow" target="_blank">composableNavigation</a></code> <a class="ae ky" href="https://github.com/cipolleschi/ComposableNavigation/tree/composableNavigation" rel="noopener ugc nofollow" target="_blank">分支</a>中找到。</p></div></div>    
</body>
</html>