<html>
<head>
<title>Video Stream With Node.js and HTML5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js和HTML5的视频流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/video-stream-with-node-js-and-html5-320b3191a6b6?source=collection_archive---------0-----------------------#2017-07-24">https://betterprogramming.pub/video-stream-with-node-js-and-html5-320b3191a6b6?source=collection_archive---------0-----------------------#2017-07-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fc49dc1a70878ce0343389b4d8ab817a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eu1SkzhIVtLKgGB5vvG7Jg.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@heyitsmebev" rel="noopener ugc nofollow" target="_blank">阮富仲</a></p></figure><p id="ef1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有人问我如何使用<a class="ae kf" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>进行视频流。这是我还没有尝试过的东西，所以我想，“为什么不呢！”让我与你分享我的发现。</p><p id="70db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">挑战在于创建一个将. mp4文件发送到页面并使视频可供查看的路由。</p><p id="a562" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我分解它的方式是:</p><ul class=""><li id="0ae1" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">制作一个服务器路由来传送视频。</li><li id="5e5b" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">使用HTML5和JS请求提要。</li><li id="36ae" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">让视频分部分加载，而不是从一开始就加载。</li></ul><p id="9c5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TL；DR——你可以在这里找到视频流<a class="ae kf" href="https://github.com/daspinola/video-stream-sample" rel="noopener ugc nofollow" target="_blank">的工作演示。</a></p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="8913" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak">流</strong></h1><p id="07e5" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">视频通过流式传输工作。这意味着，不是在一个包中把所有的东西都发送到前端，而是应该一次一小块一小块地发送。</p><p id="a892" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过流发送意味着，在能够观看视频之前，不必等待页面从服务器下载整个视频，而是可以向服务器请求视频的前几秒，并在视频播放时下载其余部分。</p><p id="1d80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您也可以使用这种方法发送大块文本。例如，你的客户不需要等很久就能看到文章的前几行。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="cb39" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak">一些理论</strong></h1><ul class=""><li id="061f" class="le lf it ki b kj mx kn my kr nc kv nd kz ne ld lj lk ll lm bi translated"><strong class="ki iu">获取文件大小</strong> : <code class="fe nf ng nh ni b">fs</code>在Node中有一个名为<code class="fe nf ng nh ni b">statSync</code>的方法，该方法将返回文件的统计信息。在这些统计数据中，我们需要知道当前加载的块到达文件末尾时的文件大小。你也可以使用<code class="fe nf ng nh ni b">stat</code>——在我的例子中，我试图避免同步性，以使代码更容易被新人理解。</li><li id="b709" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="ki iu">从一个文件创建一个流</strong> : <code class="fe nf ng nh ni b">fs</code>包含另一个叫做<code class="fe nf ng nh ni b">createReadStream</code>的方法，它将创建一个给定文件的流，开始和结束块。</li></ul><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="e316" class="nr ma it ni b gy ns nt l nu nv">const fileChunk = fs.createReadStream(sample.mp4, {start, end});</span></pre><ul class=""><li id="6d78" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><strong class="ki iu">块的大小:</strong>起始块将在请求中提供给你。为了计算要加载多少文件，我使用了结束块大小(如果不可用，使用完整的文件大小)和开始块大小的减法:</li></ul><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="5cb6" class="nr ma it ni b gy ns nt l nu nv">                          endChunk - startChunk</span></pre><ul class=""><li id="58ba" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><strong class="ki iu"> HTTP 206: </strong>这用于部分内容，这是我们希望我们的连接的头。我们不断地向前端提供数据块，并且希望在发出请求时，我们的起始数据块是可用的。你至少要定义:</li></ul><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="6e28" class="nr ma it ni b gy ns nt l nu nv">'Content-Range': 'bytes <strong class="ni iu">chunkStart</strong>-<strong class="ni iu">chunkEnd</strong>/<strong class="ni iu">chunkSize'</strong><br/>'Accept-Ranges': 'bytes'<br/>'Content-Length': <strong class="ni iu">chunkSize</strong><br/>'Content-Type': 'video/mp4'</span></pre></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="5d22" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak">服务器</strong></h1><p id="e00a" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">考虑到这些因素，我最终在我的路线中找到了类似的东西，命名为<code class="fe nf ng nh ni b">video</code>。(我正在使用Express创建路线。)</p><figure class="nj nk nl nm gt ju"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="67b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这相当多的代码。别担心，你随时可以用<a class="ae kf" href="https://github.com/daspinola/video-stream-sample" rel="noopener ugc nofollow" target="_blank">演示</a>进一步调试。</p><p id="d942" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我试着解释一下流程:</p><ul class=""><li id="7c08" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">当发出请求时，我们获取文件大小并在<code class="fe nf ng nh ni b">else</code>语句中发送视频的前几个块。</li><li id="82f9" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">当我们开始观看视频时(通过<code class="fe nf ng nh ni b">localhost:3000/video</code>或从前端访问路线)，会发出后续请求，这一次是在头中使用范围，以便我们知道下一个块的起点。</li><li id="6142" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">再次读取文件以创建另一个流，传递新的开始和结束值(很可能是请求头中的当前部分和视频的文件大小)。</li><li id="a210" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">通过应用我们前面讨论过的公式，我们将206头响应设置为只发送新创建的流的一部分。</li></ul></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="32fc" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak">前端</strong></h1><p id="e399" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">使用HTML5 <code class="fe nf ng nh ni b">video</code>标签，前端出奇地简单——您只需要添加一个源路由，它会为您处理剩下的工作。</p><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="872b" class="nr ma it ni b gy ns nt l nu nv">&lt;video id="videoPlayer" controls&gt;</span><span id="2d3a" class="nr ma it ni b gy ny nt l nu nv">  &lt;source src="http://localhost:3000/video" type="video/mp4"&gt;</span><span id="1192" class="nr ma it ni b gy ny nt l nu nv">&lt;/video&gt;</span></pre><p id="034c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nf ng nh ni b">controls</code>属性允许你看到玩家的控制。</p><figure class="nj nk nl nm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/97eefc01d407c877876261bbe4c7209a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bchK19b3xAbDaJegZIOe_w.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">播放器控制、音量、播放按钮和其他</p></figure><p id="3c24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果没有它，您可以通过访问player元素自己编写这些和其他属性；在本例中是id <code class="fe nf ng nh ni b">videoPlayer</code>。</p><p id="b589" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，如果你的HTML上有一个按钮，你可以像这样复制播放/停止按钮:</p><figure class="nj nk nl nm gt ju"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="c08d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在开发者工具的<code class="fe nf ng nh ni b">network</code>标签中，你可以看到成块的数据流，尤其是当你关闭连接的时候。</p><figure class="nj nk nl nm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/d8ea3f0b31f723a97481c44d731af9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mn0yaaDBGgdXaIaRvhIRKg.gif"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">30MB文件中的部分流示例</p></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="b5bd" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak">结束语</strong></h1><p id="6600" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">对于一个简单的实现来说，我没有想到会如此顺利。当然，在这个实现中有一些缺陷，比如开始的块不总是预期的那样(可能是因为连接挂起，因为我在这个例子中没有处理它)。</p><p id="8845" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管如此，我认为对于那些想要开始创建某种流应用程序的人来说，这是一个很好的起点。如果你有更好的或者更少出错的方法，请告诉我！</p></div></div>    
</body>
</html>