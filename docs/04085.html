<html>
<head>
<title>Demystifying Kubernetes Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开Kubernetes物件的神秘面纱</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/demystifying-kubernetes-objects-understanding-the-what-why-and-how-18b42c9ca9c2?source=collection_archive---------6-----------------------#2020-03-23">https://betterprogramming.pub/demystifying-kubernetes-objects-understanding-the-what-why-and-how-18b42c9ca9c2?source=collection_archive---------6-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e33e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解什么、为什么和如何</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c73a2e93ee77a2836d2f4d6e50ce0cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3mo8eobgeQgTM-HtzoOOtg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@jaredrossarango?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">贾里德·阿兰戈</a>在<a class="ae ky" href="https://unsplash.com/s/photos/future?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="aabf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes现在是容器编排事实上的标准。它受欢迎有很多原因。一个很好的理由是它自身带来的特性数量，因此有相当多的Kubernetes对象。</p><p id="c064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Kubernetes中，有多种方法可以实现一个结果，这也给DevOps专业人员带来了很多困惑。本文试图解决一些常用的Kubernetes对象的内容、方式和原因。</p><p id="c059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个面向Kubernetes从业者的高级主题。如果您想从Kubernetes开始，请查看这篇中型文章:</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/kubernetes-for-beginners-b3042e01ccff" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">初学者的Kubernetes</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">Kubernetes，面向更普通的观众</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="9760" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">了解Kubernetes如何工作</h1><p id="0e83" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Kubernetes使用一个简单的概念来管理容器。有控制和协调容器工作负载的主节点(控制平面),以及容器运行的工作节点。</p><p id="2194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes:</p><ul class=""><li id="e5f8" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">与底层容器运行时对话。Kubernetes不是一个容器平台，而是一个容器编排平台。它的kubelet组件作为服务在每个节点上运行，负责与底层容器平台通信以管理容器。例如，当您使用kubectl创建一个pod，并且您的底层容器平台是Docker时，kubelet会向所选worker节点中的Docker运行时发出一个Docker run命令。</li><li id="8ef2" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">存储预期配置的状态。当您使用kubectl create/apply命令应用kubernetes配置时，Kubernetes会将其作为预期配置存储在其<code class="fe of og oh oi b">etcd</code>数据存储中。</li><li id="7e65" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">尝试维护基于预期配置的状态。Kubernetes通过查看<code class="fe of og oh oi b">etcd</code>数据存储中的预期配置，不断尝试维护集群的预期状态。</li><li id="053b" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">提供基于软件的抽象网络编排层。Kubernetes提供的pod网络确保容器可以在容器运行时管理的覆盖或桥接网络(例如使用docker桥接网络)上通过内部或外部网络相互通信。当一个pod与另一个pod对话时，Kubernetes会修改路由表，以确保连接到位。</li><li id="3d42" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">提供内置的服务发现。Kubernetes提供开箱即用容器的服务发现。您不需要外部应用程序来管理它。Kubernetes服务在DNS上公开您的Pod，它将服务名称映射到任何可用的Pod IP，提供服务发现和多个Pod副本之间的负载平衡。正是因为这种服务发现，豆荚是短暂的。服务还可以通过在节点内创建监听器，以及通过请求云提供商提供指向您的pod的负载平衡器，将您的pod暴露给内部和外部客户端。</li><li id="4277" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">运行状况检查配置。Kubernetes确保集群中运行的容器工作负载具有预期的健康状况，如果没有，它会销毁并重新创建容器。</li><li id="abcd" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">与云提供商讨论对象。如果你在像GCP或Azure这样的云提供商中运行Kubernetes，它可以使用云API来提供负载平衡器和存储等资源。这样，您就有了一个单一的控制平面来管理在容器中运行应用程序所需的一切。</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="fb9a" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">Kubernetes对象</h1><p id="d042" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Kubernetes配置由Kubernetes对象组成，如pod、复制控制器、副本集、守护进程集、部署、状态集、服务、持久卷、持久卷声明等。我将逐一解开这些谜团。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="839e" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">豆荚</h1><p id="7c59" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">豆荚是Kubernetes的基本组成部分。它是一个或多个容器的集合。每当您需要运行一个应用程序时，您都需要创建一个Pod。通常，一个pod只运行一个容器，但是有时您可能需要在Pod中运行多个容器。典型的使用案例包括但不限于以下内容:</p><ul class=""><li id="f97b" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">初始化容器。有时，在启动容器之前，有必要满足某些先决条件，例如检查卷是否存在，如果存在，确保它具有正确的所有权和权限。</li><li id="062a" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">助手/内部容器。如果有一个辅助容器与主容器一起运行，并且满足一个共同的目标，那么在单个pod中运行它们是有意义的。在同一个Pod中运行Helper容器将确保它们在localhost中运行，因此比将它们保存在单独的Pod中更快，这可能会将它们分隔在两个worker节点中。Kubernetes在同一个worker节点中运行一个pod的所有容器。</li></ul><p id="6253" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个只有一个集装箱的pod清单示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="4f11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个带有<code class="fe of og oh oi b">InitContainers</code>的pod清单示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="6c6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的配置用一个<code class="fe of og oh oi b">busybox</code> init容器启动了一个<code class="fe of og oh oi b">nginx</code>容器。当您应用这个清单时，Kubernetes确保在它启动<code class="fe of og oh oi b">nginx</code> pod之前，<code class="fe of og oh oi b">/etc/nginx</code>持久卷中的所有文件和目录都将<code class="fe of og oh oi b">uid 101</code>和<code class="fe of og oh oi b">gid 101</code>作为所有者(<code class="fe of og oh oi b">101</code>是<code class="fe of og oh oi b">nginx</code>用户的<code class="fe of og oh oi b">uid</code>和<code class="fe of og oh oi b">gid</code>)。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="423e" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">复制控制器</h1><p id="b0f4" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">如果您单独部署一个pod，则无法复制和扩展它。它独立存在，一旦你使用<code class="fe of og oh oi b">kubectl</code>命令删除它，它就消失了。为了确保最小数量的pod始终运行，我们需要使用一个类似复制控制器的对象。复制控制器是Kubernetes中复制pods的遗留形式，现在已经被副本集所取代。然而，我仍然会展示一个例子。为了实现这一点，我们只需要将复制控制器规范包装在pod规范上:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="cecc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复制控制器通过搜索pod标签来缩放Pod。选择器标签与pod标签完全匹配。副本决定了在任何给定时间运行的Pod实例的数量。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="3c5c" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">副本集</h1><p id="76c3" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">副本集是复制控制器的较新版本。然而，需要记住的一点是，它不应该单独使用，而应该作为部署对象的后端。它们类似于复制控制器，唯一的区别是您可以使用基于集合的搜索符号来对pod进行分组，而不是使用基于命名键值对的匹配。在副本集的情况下，您有更多的动态选择器选项。例如，您可以这样编写上面的规范:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="b5f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="1b06" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">部署</h1><p id="b970" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">部署是部署Kubernetes Pods最广泛使用和推荐的方法之一。它们取代了复制控制器—您应该在大多数应用程序中使用它们。可以推出和回滚部署，这是最强大和最广泛使用的Kubernetes对象之一。采用<code class="fe of og oh oi b">ReplicaSet</code>的部署管理单元。</p><h2 id="3aed" class="ol mv it bd mw om on dn na oo op dp ne li oq or ng lm os ot ni lq ou ov nk ow bi translated"><strong class="ak">何时使用部署</strong></h2><ul class=""><li id="4f5d" class="nr ns it lb b lc nm lf nn li ox lm oy lq oz lu nw nx ny nz bi translated">如果您正在运行无状态应用程序(不需要将数据/状态保存在磁盘中的应用程序。与后端(如数据库)连接并且不在磁盘中保持状态的应用程序也属于这一类别。</li><li id="8312" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">当您需要扩展和自我修复pod时。</li><li id="e6ad" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">几乎所有没有状态的东西。</li></ul><p id="9761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是部署清单的一个示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="a7cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看一下清单，它和<code class="fe of og oh oi b">ReplicaSet</code>是一样的，唯一的区别是对象的类型。</p><h2 id="3609" class="ol mv it bd mw om on dn na oo op dp ne li oq or ng lm os ot ni lq ou ov nk ow bi translated"><strong class="ak">扩展部署</strong></h2><p id="b7cf" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">有两种方法可以做到这一点:</p><ul class=""><li id="95b8" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">修改清单文件的副本部分并运行<code class="fe of og oh oi b">kubectl apply -f &lt;manifest file&gt;</code>。</li><li id="7d12" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">跑<code class="fe of og oh oi b">kubectl scale deployment nginx-deployment --replicas=10</code>。</li></ul><p id="0437" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我建议在生产场景中修改清单文件，并将清单文件存储在源代码存储库中，以确保环境与代码的一致性。</p><h2 id="f0c2" class="ol mv it bd mw om on dn na oo op dp ne li oq or ng lm os ot ni lq ou ov nk ow bi translated"><strong class="ak">自动扩展部署</strong></h2><p id="0c26" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">如果Kubernetes可以在Pod的利用率超过限制时自动调整部署，那该有多好？Kubernetes的一个名为水平Pod Autoscaler的对象就是这个问题的答案。该对象检查pod指标，如果它违反了定义的阈值，它会启动另一个pod来吸收负载。您需要指定pod的最小和最大数量、要检查的指标，然后就可以开始了。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="57fd" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">水平吊舱自动缩放器</h1><p id="b3c3" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">水平Pod Autoscaler确保您的Kubernetes部署可以基于一些预定义的指标水平扩展，并且Kubernetes可以基于这些指标管理Pod的创建和销毁。有两种方法可以实现这一点。</p><ul class=""><li id="91b0" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">使用<code class="fe of og oh oi b">kubectl</code>命令行功能。</li><li id="a670" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">使用<code class="fe of og oh oi b">HorizontalPodAutoscaler</code>货单。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/46f153081f425ed3e17a3aab3031801c.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*F9Fv0fy7ofiQCBQrMqRl9g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">水平吊舱自动缩放器</p></figure><p id="adf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用任何方法之前，我们需要修改我们的部署清单，以便对pod应用资源限制，这样水平pod autoscaler就可以知道何时需要扩展部署:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="31ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述配置确保分配给容器的最大CPU限制是运行容器的工作节点的500毫核。</p><h2 id="bfcd" class="ol mv it bd mw om on dn na oo op dp ne li oq or ng lm os ot ni lq ou ov nk ow bi translated"><strong class="ak">使用kubectl命令行函数</strong></h2><pre class="kj kk kl km gt pb oi pc pd aw pe bi"><span id="8a21" class="ol mv it oi b gy pf pg l ph pi">kubectl autoscale deployment nginx --cpu-percent=50 --min=1 --max=10</span></pre><p id="74b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上命令确保<code class="fe of og oh oi b">nginx</code>部署运行最少一个pod，最多十个pod，基于CPU百分比度量不超过pod清单中分配的核心的50%。</p><p id="8ea7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦<code class="fe of og oh oi b">nginx</code>容器开始在worker节点中使用超过0.25个核心，这将触发水平pod自动缩放器旋转一个复制Pod，前提是我们不超过10个Pod的最大限制。相反，如果负载降低，使每个pod的利用率低于0.25个内核，则pod将被删除，直到它们达到所需的使用率或至少有一个pod正在运行。</p><h2 id="616f" class="ol mv it bd mw om on dn na oo op dp ne li oq or ng lm os ot ni lq ou ov nk ow bi translated"><strong class="ak">在自动缩放/v2beta2 apiVersion上使用HorizontalPodAutoscaler清单</strong></h2><p id="982f" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe of og oh oi b">kubectl</code>命令行只能帮助自动缩放CPU和内存利用率等指标。如果您需要扩展更高级的自定义指标，比如网络利用率，您需要创建一个<code class="fe of og oh oi b">HorizontalPodAutoscaler</code>清单。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="b116" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述规范描述了三种度量标准:</p><ul class=""><li id="6586" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">资源指标。CPU和内存等指标</li><li id="24ea" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">Pod指标。诸如每秒数据包数和Pod内其他形式的网络流量等指标</li><li id="746a" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">对象度量。其他Kubernetes对象(如Ingresses)中的度量(如每秒请求数和不同类型的网络流量)。</li></ul><p id="d863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以选择在所有三个选项中使用值和平均值。平均值带来了部署中运行的所有单元的平均值，而值只查看单个单元。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="7a77" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">管理有状态应用程序</h1><p id="5039" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">到目前为止，我们一直在讨论无状态应用程序，但是运行的应用程序中有很大一部分是有状态的。</p><p id="bd2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有状态应用程序是那些需要知道它们的现有状态以便在重启后存活的应用程序。如果状态信息丢失，应用程序将无法正常运行。应用程序可能需要将应用程序数据或元数据保存在磁盘上。一个典型的例子包括数据库。</p><p id="1c30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管业界对是否在容器中运行有状态应用程序存在争议，但是如果您正在运行Kubernetes集群作为标准，那么尽可能使用基于容器的方法来避免异构环境是有意义的。如果走这条路，您可以利用Kubernetes提供的高可用性、网络分段和其他有用的特性。</p><p id="0a21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当前形式的Kubernetes提供了许多使用<code class="fe of og oh oi b">StatefulSet</code>、<code class="fe of og oh oi b">StorageClass</code>、<code class="fe of og oh oi b">PersistentVolumeClaim</code>和<code class="fe of og oh oi b">PersistentVolume</code>对象管理有状态应用程序的方法。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="fe2e" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">有状态集合</h1><p id="4133" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">有状态集类似于部署，但有一个显著的区别，即它确保单元和卷是唯一且有序的。如果您使用动态卷供应来旋转一个<code class="fe of og oh oi b">StatefulSet</code>的两个副本，Kubernetes将确保作为卷安装到Pod的存储在被破坏时再次连接到同一个卷。有状态集中的两个pod不能互换。</p><p id="0910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">StatefulSet</code>清单包含一个Kubernetes服务，因为它需要确定它运行在什么服务上，以保持唯一性和稳定的网络身份。这就是为什么<code class="fe of og oh oi b">serviceName</code>也出现在<code class="fe of og oh oi b">StatefulSet</code>规格中的原因。</p><p id="9f88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有状态集还需要一个<code class="fe of og oh oi b">PersistentVolume</code>,可以手动提供，也可以通过存储类的自动提供程序提供。这就是为什么在一个<code class="fe of og oh oi b">StatefulSet</code>清单中有<code class="fe of og oh oi b">volumeClaimTemplates</code>特征的原因。我们稍后将讨论PVC和PV。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/916bf9607a59700476e48acc8bf02993.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*QqT18GjamSviJrUPujTh_w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kubernetes StatefulSet</p></figure><p id="e7ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个<code class="fe of og oh oi b">StatefulSet</code>清单的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="328b" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">持久卷</h1><p id="13cb" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">永久卷是存储资源，如磁盘，由管理员手动配置或使用存储类动态配置。我们可以将这些磁盘安装到在Pods上运行的容器中，以确保有状态应用程序能够持久存储数据。</p><h2 id="ba27" class="ol mv it bd mw om on dn na oo op dp ne li oq or ng lm os ot ni lq ou ov nk ow bi translated"><strong class="ak">静态配置</strong></h2><p id="d184" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">静态配置要求管理员在云提供商或内部手动创建卷，并在持久卷清单中为Kubernetes提供信息，以将卷声明为可用的Kubernetes资源。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/887d764f9ef8fcf8a88d64dc6f40d26c.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*DmhkNAiUob5Dim7jA-Jmkw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">静态供应</p></figure><p id="ad35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个使用现有Azure磁盘的静态供应的<code class="fe of og oh oi b">PersistentVolume</code>清单示例。然后，我们将永久卷包括在卷声明模板中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><h2 id="801a" class="ol mv it bd mw om on dn na oo op dp ne li oq or ng lm os ot ni lq ou ov nk ow bi translated"><strong class="ak">动态预配置</strong></h2><p id="4817" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">静态配置似乎是一个不错的选择，但是这里的问题是这个对象依赖于一个特定的云提供商，并且不可移植。如果我们需要将我们的工作负载转移到另一个云提供商，部分问题将是更改我们所有的清单，以反映新提供商中新创建的磁盘。修改一些清单似乎是一件容易的事情，但是运行数千个容器的大型组织会经历供应商锁定。</p><p id="3416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保更加动态和独立于平台的方法，我们将创建一个存储类对象，该对象将定义需要配置的对象类型(磁盘、SSD、NFS、块存储等)。)和将要供应它的云提供商。存储类名需要独立于平台—标准、快速、数据块等。然后，持久卷声明将使用存储类别来告诉云提供商要么提供现有存储，要么根据存储类别提供新的存储。然后，Kubernetes将PVC作为一个卷安装到Pod。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/2d89b9cc69caa8b343123fb53fa1eec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*MOKF-nIStLp2X5_GG955vw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">动态供应</p></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="aa2e" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">存储类</h1><p id="e37d" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">存储类对象定义了需要供应的对象类型(磁盘、SSD、NFS、块存储等)。)、云提供商(Azure、GCP等)。)哪一个将配置它、卷回收策略等等。存储类名称需要独立于平台，例如标准、快速、磁盘或SSD。</p><p id="61ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个快速存储类的示例，它提供azure premium本地冗余管理azure磁盘:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="a216" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">持续量索赔</h1><p id="7584" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">永久卷声明使用存储类根据请求动态配置磁盘。下面使用fast storage类来配置5GB的azure磁盘。然后，pod模板可以使用<code class="fe of og oh oi b">PersistentVolumeClaim</code>将磁盘安装到容器上:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="bf42" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">将所有这些与动态资源调配一起放在一个有状态的集合上</h1><p id="471b" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">下面是一个使用动态资源调配来定义使用fast存储类的有状态集的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="d2bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你仔细观察，你会发现规范中没有提到任何云提供商。这样，资源调配是可移植的，并且是最推荐的卷资源调配方法之一。</p><p id="2a2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态预配置适用于希望在开发和运营之间保持界限的组织，而对于对开发更友好的组织，动态预配置是一条可行之路。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="e9b3" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">运行守护程序</h1><p id="fec4" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">守护进程是在服务器中运行的后台进程，用于特定的管理相关活动，如收集日志、内务处理、监控等。在Kubernetes集群的情况下，可能有一些特殊的用例，比如监控节点健康状况、发送日志或启动集群存储守护进程。在这种情况下，<code class="fe of og oh oi b">DameonSets</code>是满足要求的最佳Kubernetes对象。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f979" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">达蒙塞特</h1><p id="8e4c" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe of og oh oi b">DaemonSet</code>是一个Kubernetes对象，它确保集合中定义的pod在Kubernetes集群的每个节点上运行。当我们向集群添加一个新节点时，<code class="fe of og oh oi b">DaemonSet</code>会旋转一个新的pod，当我们删除一个节点时，它会从该节点删除Pod。</p><p id="9719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是在Kubernetes集群的所有节点中运行一个<code class="fe of og oh oi b">fluentd</code>日志应用程序的<code class="fe of og oh oi b">DaemonSet</code>的示例清单文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="036d" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">公开Kubernetes应用程序</h1><p id="f672" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">到目前为止，我们已经讨论了部署和管理容器的方法。我现在想讨论通过Kubernetes服务和入口资源向内部或外部客户公开Kubernetes对象的多种方式。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="eca9" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">服务</h1><p id="61a5" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">豆荚是短暂的物体。每个pod都有其IP地址，当一个pod不正常或死亡时，Kubernetes会用一个具有不同IP地址的新Pod来替换它。这导致了一个问题，因为我们现在不能使用与旧地址相同的IP地址来访问Pod。</p><p id="070f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes提供了服务对象来解决这个问题，并通过交付其内置的服务发现机制来抽象它。当您使用Kubernetes运行容器时，您不需要依赖外部服务发现应用程序。Kubernetes拥有自己的CoreDNS，它记录了正在运行的pod的IP地址，并根据服务名称提供内部负载平衡和DNS解析。根据服务的类型，您可以用三种方式公开您的应用程序:<code class="fe of og oh oi b">ClusterIP</code>、<code class="fe of og oh oi b">NodePort</code>和<code class="fe of og oh oi b">LoadBalancers</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/73682271777ee668d26f0d6bbbc8d658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dvgbQrE44LkcjEYTwlcWKA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kubernetes服务</p></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c6ac" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">集群IP服务</h1><p id="0862" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">群集IP服务是默认的服务类型。我们用它来暴露pods作为Kubernetes前端pods的后端。</p><p id="4d36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个典型的例子包括在Kubernetes中作为容器运行的数据库。我们不需要在Kubernetes集群之外公开这些pods，集群IP服务只能在Kubernetes集群中发现。集群中运行的任何pod都可以通过使用<code class="fe of og oh oi b">serviceName:port</code>组合来调用另一个服务，这确保了无论您的pod运行在哪个IP上，请求都会通过动态服务发现被路由到正确的pod。</p><p id="0370" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一个集群IP服务的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="42b4" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">节点端口服务</h1><p id="5136" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">节点端口服务在一个称为节点端口的静态端口上向您的节点公开您的pod，并且可以从您的任何Kubernetes节点上发现它。如果您的节点可以从互联网上访问，外部客户端将能够在任何<code class="fe of og oh oi b">&lt;NodeIP&gt;:&lt;NodePort&gt;</code>上访问您的Pod。节点端口范围为30000–32767，这是非标准范围，通常不适合生产部署。</p><p id="b787" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个节点端口服务的例子，展示了节点端口31000上的<code class="fe of og oh oi b">nginx</code>部署。如果不指定节点端口，它会选择范围内的任何空闲端口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2ac8" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">负载平衡器服务</h1><p id="250d" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">负载平衡器服务本质上创建了一个<code class="fe of og oh oi b">NodePort</code>,并请求云提供商在所有节点前动态提供负载平衡器。</p><p id="e20f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解释这一点，假设您有一个主节点和三个名为<code class="fe of og oh oi b">master</code>、<code class="fe of og oh oi b">node01</code>、<code class="fe of og oh oi b">node02</code>和<code class="fe of og oh oi b">node03</code>的工作节点，并且您有一个运行在端口80上的<code class="fe of og oh oi b">NGINX</code> pod，您想要向外公开它。一个<code class="fe of og oh oi b">LoadBalancer</code>服务将首先在<code class="fe of og oh oi b">NodePort </code>范围内的任意一个端口(比如31000)上创建一个<code class="fe of og oh oi b">NodePort</code>，然后创建一个在端口80上运行的<code class="fe of og oh oi b">Load Balancer</code>作为前端，将<code class="fe of og oh oi b">master:31000</code>、<code class="fe of og oh oi b">node01:31000</code>、<code class="fe of og oh oi b">node02:31000</code>和<code class="fe of og oh oi b">node03:31000</code>作为后端。一个<code class="fe of og oh oi b">Load balancer</code>可以是内部的，也可以是外部的，并且可以有多个用例。<code class="fe of og oh oi b">Load Balancer</code>服务是在生产环境中向互联网或内部基础设施公开前端组件的方法之一。</p><p id="dd45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下示例公开了<code class="fe of og oh oi b">Load Balancer</code>上的<code class="fe of og oh oi b">NGINX</code>窗格:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="8a18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有其他服务，如<code class="fe of og oh oi b">ExternalName</code>和<code class="fe of og oh oi b">ExternalIP</code>，但它们很少被使用，不在本次讨论的范围内，如果你感兴趣，可以查看<a class="ae ky" href="https://kubernetes.io/docs/concepts/services-networking/service" rel="noopener ugc nofollow" target="_blank">在线Kubernetes文档</a>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="cfa1" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">进入</h1><p id="7c73" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">负载平衡器是昂贵的资源，为每个外部公开的应用程序提供新的负载平衡器是一种浪费。当多个应用程序在一个集群中运行时，不要运行太多的外部负载平衡器是有意义的。</p><p id="6120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，依靠反向代理，根据URI路径、完全限定的域名或HTTP报头，将来自一个负载平衡器的外部流量映射到多个资源。入口资源是用于此目的的对象。入口资源通常仅用于管理HTTP和HTTPS流量——对于任何其他情况，<code class="fe of og oh oi b">LoadBalancers</code>更合适。</p><p id="a50e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">典型的入口设置需要入口控制器。入口控制器是一个由<code class="fe of og oh oi b">Ingress</code>清单配置的容器，用于将到达它的流量路由到正确的ClusterIP服务。下面是一个运行入口的典型简单链:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/a9a2ca69025529be0636b09e92da2245.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CD0nqplcyZEKTxRjsVKgPQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kubernetes入口</p></figure><p id="4c96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在您的Kubernetes集群中设置入口控制器，请阅读<a class="ae ky" href="https://medium.com/swlh/how-to-secure-kubernetes-the-easy-way-f37052139280" rel="noopener">本指南</a>并在需要时参考其他在线文档。</p><p id="772a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个使用基于URI的路由的入口清单示例。任何触及任何FQDN上的入口控制器但具有<code class="fe of og oh oi b">/testpath</code> URI的内容都会路由到端口80上的测试服务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="83d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是使用基于主机的路由的入口示例。使用具有任何URI的完全限定域名<code class="fe of og oh oi b">test.example.com</code>的所有流量将被路由到端口80上的服务测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="b726" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面显示了同时使用基于主机和基于路径的路由的扇出。任何来自foo.bar.com的带有URI /foo的请求都会被路由到端口4200上的服务1，而带有URL /bar的请求会被路由到端口8080上的服务2。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="e4e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由此可以产生各种排列组合，您可以根据<code class="fe of og oh oi b">Ingress</code>规则创建强大的动态路由。如果您正在管理基于HTTP和HTTPS的应用程序，那么<code class="fe of og oh oi b">Ingress</code>资源是绝对必要的。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f8a0" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">进一步阅读</h1><p id="126f" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">感谢您的阅读。我希望你喜欢这个故事。如果您有兴趣了解更多信息，请查看以下文章，您可能会感兴趣:</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/@bharatmicrosystems/using-the-azure-kubernetes-provider-in-a-vm-based-k8s-cluster-fdf941b86d69" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">在基于虚拟机的K8S集群中使用Azure Kubernetes提供程序</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">建立kubernetes集群有多种方式，一些组织希望从头开始…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div></div></a></div><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/how-to-helm-with-sonatype-nexus-c49c98324a19" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">如何用Sonatype Nexus掌舵</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">使用Sonatype Nexus作为CI/CD的导航库</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="pn l mj mk ml mh mm ks ly"/></div></div></a></div></div></div>    
</body>
</html>