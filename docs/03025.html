<html>
<head>
<title>TypeScript Advanced Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript高级类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typescript-advanced-types-literal-types-and-discriminated-unions-13139196876c?source=collection_archive---------15-----------------------#2020-01-15">https://betterprogramming.pub/typescript-advanced-types-literal-types-and-discriminated-unions-13139196876c?source=collection_archive---------15-----------------------#2020-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7997" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">文字类型和有区别的联合</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/02d18ba2d1c494bfd94de56261bcd6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jlGQLO8GVBPZlVYX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@samdc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">山姆·卡特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="93d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript具有许多高级类型功能，有助于简化动态类型代码的编写。它还促进了现有JavaScript代码的采用，因为它让我们在使用TypeScript的类型检查功能的同时保留了JavaScript的动态功能。TypeScript中有许多高级类型—交集类型、联合类型、类型保护、可空类型、类型别名等等。在这一部分中，我们将看看接口和类型别名、文字类型以及有区别的联合之间的区别。</p><h1 id="851b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">接口和类型别名之间的区别</h1><p id="854d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">尽管接口和类型别名看起来很相似，但它们之间还是有细微的差别。接口创建了一种可以在任何地方使用的新类型。然而，类型别名只是已经存在的类型的新名称，包括接口。从TypeScript 2.7开始，可以通过创建新的交集类型来扩展类型别名。这意味着类似以下代码的内容在TypeScript 2.7和更高版本中是有效的:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="64ad" class="mx lw it mt b gy my mz l na nb">type Cat = string &amp; { age: number }</span></pre><p id="a454" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建新的数据类型，应该使用接口而不是类型别名。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="e3b3" class="lv lw it bd lx ly nj ma mb mc nk me mf jz nl ka mh kc nm kd mj kf nn kg ml mm bi translated">字符串文字</h1><p id="7ef4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于字符串，我们可以指定一个字符串变量可以取什么值，方法是指定它可以被赋值的可能值，每个值用管道符号(<code class="fe no np nq mt b">|</code>)分隔。这些可以组合成其他类型，如联合类型、类型保护和类型别名。</p><p id="42e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以编写类似下面的代码:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="dc53" class="mx lw it mt b gy my mz l na nb">type PersonName = 'Joe' | 'Jane' | 'Amy';<br/>let personName: PersonName = 'Joe';</span></pre><p id="1824" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们试图给<code class="fe no np nq mt b">n</code>分配一个没有在<code class="fe no np nq mt b">PersonName</code>类型别名中列出的值，就像我们在下面的代码中做的那样:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="30f6" class="mx lw it mt b gy my mz l na nb">type PersonName = 'Joe' | 'Jane' | 'Amy';<br/>let personName: PersonName = 'foo';</span></pre><p id="567b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们从TypeScript编译器得到以下错误消息:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5ca9" class="mx lw it mt b gy my mz l na nb">Type '"foo"' is not assignable to type 'PersonName'.(2322)</span></pre><p id="ada9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将管道符号用于字符串并分配给类型别名，它让我们声明一个类似于<code class="fe no np nq mt b">enum</code>的变量，但不是。我们还可以通过为字符串设置可能的字符串值来区分重载。例如，我们可以写:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1a1a" class="mx lw it mt b gy my mz l na nb">function echo(name: 'Joe'): string;<br/>function echo(name: 'Jane'): string;<br/>function echo(name: 'Amy'): string;<br/>function echo(name: string) {<br/>  return name;<br/>}</span><span id="6abe" class="mx lw it mt b gy nr mz l na nb">echo('Joe');</span></pre><p id="04e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们试图传入一个无效值，也就是重载中没有列出的任何值，那么我们会得到一个错误。例如，如果我们这样写:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d85c" class="mx lw it mt b gy my mz l na nb">function echo(name: 'Joe'): string;<br/>function echo(name: 'Jane'): string;<br/>function echo(name: 'Amy'): string;<br/>function echo(name: string) {<br/>  return name;<br/>}</span><span id="692d" class="mx lw it mt b gy nr mz l na nb">echo('foo');</span></pre><p id="c1ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们从TypeScript编译器得到这些错误消息:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="6f27" class="mx lw it mt b gy my mz l na nb">No overload matches this call.</span><span id="0f3b" class="mx lw it mt b gy nr mz l na nb">Overload 1 of 3, '(name: "Joe"): string', gave the following error.</span><span id="df27" class="mx lw it mt b gy nr mz l na nb">Argument of type '"foo"' is not assignable to parameter of type '"Joe"'.</span><span id="b09d" class="mx lw it mt b gy nr mz l na nb">Overload 2 of 3, '(name: "Jane"): string', gave the following error.</span><span id="6b5a" class="mx lw it mt b gy nr mz l na nb">Argument of type '"foo"' is not assignable to parameter of type '"Jane"'.</span><span id="ba62" class="mx lw it mt b gy nr mz l na nb">Overload 3 of 3, '(name: "Amy"): string', gave the following error.</span><span id="6f1c" class="mx lw it mt b gy nr mz l na nb">Argument of type '"foo"' is not assignable to parameter of type '"Amy"'.(2769)</span></pre></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="8ebd" class="lv lw it bd lx ly nj ma mb mc nk me mf jz nl ka mh kc nm kd mj kf nn kg ml mm bi translated">数字文字类型</h1><p id="196e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们可以用数字创建文字类型，就像我们处理字符串一样。这样做的符号是相同的，除了我们用数字代替类型的有效值。例如，我们可以编写以下代码来定义数字文字类型，并将值赋给这种类型的变量:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="221b" class="mx lw it mt b gy my mz l na nb">type Num = 1 | 2 | 3;<br/>let num: Num = 1;</span></pre><p id="39a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们试图分配一个没有在类型别名定义中列出的值，如下面的代码所示，会怎么样？：</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d8e1" class="mx lw it mt b gy my mz l na nb">type Num = 1 | 2 | 3;<br/>let num: Num = 6;</span></pre><p id="9f3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到以下错误消息:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5788" class="mx lw it mt b gy my mz l na nb">Type '6' is not assignable to type 'Num'.(2322)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/4ceb7ba53e482ef082ec0893f417d75d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QJ2tH9x_Emft_j71"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Tatiana Rodriguez 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="dfae" class="lv lw it bd lx ly nj ma mb mc nk me mf jz nl ka mh kc nm kd mj kf nn kg ml mm bi translated">受歧视的工会</h1><p id="f6ec" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们可以添加一个具有常数值的成员来区分构成联合类型的不同类型。这就是所谓的歧视性结合。其他名称包括标记联合或代数数据类型。在TypeScript中，我们可以创建一个由三部分组成的有区别的联合。首先，我们需要一个共同的，单一实例类型的属性，这是所谓的判别式。第二，我们需要一个接受这些类型的联合的类型别名，这是我们通常创建的联合类型。最后，我们需要一个类型保护。</p><p id="89c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用类似下面的代码用TypeScript创建一个有区别的联合:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ff68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们有一个在所有接口中都可用的公共<code class="fe no np nq mt b">kind</code>成员。然后我们创建联合<code class="fe no np nq mt b">Animal</code>类型，它是<code class="fe no np nq mt b">Cat</code>、<code class="fe no np nq mt b">Dog</code>和<code class="fe no np nq mt b">Bird</code>类型的联合。这意味着一个<code class="fe no np nq mt b">Animal</code>对象的<code class="fe no np nq mt b">kind</code>属性可以取值<code class="fe no np nq mt b">cat</code>、<code class="fe no np nq mt b">dog</code>或<code class="fe no np nq mt b">bird</code>。然后，在<code class="fe no np nq mt b">getSize</code>函数中，我们检查<code class="fe no np nq mt b">kind</code>属性的值。在<code class="fe no np nq mt b">switch</code>语句中，我们检查了<code class="fe no np nq mt b">kind</code>属性，我们检查了该属性的值，并从<code class="fe no np nq mt b">case</code>块内部键入了对<code class="fe no np nq mt b">animal</code>参数进行类型化的数字，这是我们的类型保护。</p><p id="3704" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该添加类型保护来检查构成联合类型的所有类型。如果我们向上面的<code class="fe no np nq mt b">Animal</code>联合类型添加另一个类型，但没有更新<code class="fe no np nq mt b">getSize</code>函数，如下面的代码所示，会怎么样？：</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="4071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从TypeScript编译器获得以下错误信息:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="fe33" class="mx lw it mt b gy my mz l na nb">Not all code paths return a value.(7030)</span></pre><p id="ddf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们应该涵盖所有情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c7b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接口和类型别名之间有细微的差别，尽管它们看起来有点像。接口创建了一种可以在任何地方使用的新类型。然而，类型别名只是已经存在的类型的新名称，包括接口。在TypeScript中，我们可以创建字符串或数字文字来限制这些类型的变量可以采用的可能值。我们还可以通过向每个接口添加一个singleton属性并为每个属性设置一个惟一的值来创建有区别的联合。然后，我们可以在代码中使用类型guards检查该属性的值，以获得我们想要的属性。</p></div></div>    
</body>
</html>