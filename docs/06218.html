<html>
<head>
<title>No More LiveData in Repositories in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林的存储库中不再有实时数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/no-more-livedata-in-repositories-in-kotlin-85f5a234a8fe?source=collection_archive---------3-----------------------#2020-09-10">https://betterprogramming.pub/no-more-livedata-in-repositories-in-kotlin-85f5a234a8fe?source=collection_archive---------3-----------------------#2020-09-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="034e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何用Kotlin流替换LiveData</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/759fe4b84a6aca9116411896ad13ae14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9NbPi_RlZ2c0JAWP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@jstrippa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">詹姆斯·哈里森</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="591f" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">什么是LiveData？</h1><p id="5aa2" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们可以将LiveData描述为一个可观察的数据持有者类，这意味着它可以保存一组可以从其他Android UI组件(如活动、片段和服务)中观察到的数据。</p><p id="0b33" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">LiveData具有生命周期意识。一旦观察数据的组件被破坏或不活动，LiveData就会停止向该观察者发布数据。这为Android开发者解决了很多常见问题。</p><p id="19a4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">大多数开发人员在MVVM架构中使用LiveData从视图模型向视图传递或传输数据。这通过减少内存泄漏来确保它们之间的生命周期感知通信。</p><p id="f296" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">但是我看到开发人员使用LiveData在存储库和视图模型之间进行通信，包括Google I/O应用程序。在这种情况下使用LiveData似乎是正确的。毕竟，它是为保存和传递数据而设计的。但是不建议这样做，您将在下面的小节中了解原因。</p><h2 id="fb8c" class="mz lh it bd li na nb dn lm nc nd dp lq mh ne nf ls ml ng nh lu mp ni nj lw nk bi translated">使用LiveData的优势:</h2><ul class=""><li id="05da" class="nl nm it ma b mb mc me mf mh nn ml no mp np mt nq nr ns nt bi translated">没有内存泄漏</li><li id="596b" class="nl nm it ma b mb nu me nv mh nw ml nx mp ny mt nq nr ns nt bi translated">没有因组件停止而导致的崩溃</li><li id="4c8f" class="nl nm it ma b mb nu me nv mh nw ml nx mp ny mt nq nr ns nt bi translated">不再需要手动处理生命周期</li><li id="cf7e" class="nl nm it ma b mb nu me nv mh nw ml nx mp ny mt nq nr ns nt bi translated">资源共享</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="4733" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">什么是科特林流？</h1><p id="db22" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在协程之前，大多数开发人员使用RxJava进行异步编程。当Kotlin提出协程时，开发人员非常喜欢。他们用比RxJava更复杂的方式解决了异步编程的所有传统问题。</p><p id="118f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在协程之前，我们必须调用一个异步函数，比如服务调用，从数据库中检索数据，读取文件，或者通过回调做任何事情。只有当我们知道操作已经完成时，我们才能继续实际的工作，就像手机从你的服务器接收数据后更新用户界面一样。</p><p id="9ee8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">协程通过<code class="fe nz oa ob oc b">suspend</code>函数提供了一个解决方案。<code class="fe nz oa ob oc b">Suspend</code>函数可以暂停当前线程的执行，直到任务完成。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="bd33" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">后来，协程程序提出了流API。异步处理顺序执行的数据流是一种更好的方法。有了Flow，协程就成了Kotlin项目中RxJava的替代品。</p><p id="6f0e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">凭借顺序执行复杂操作和连续数据流的能力，Kotlin的Flow API更加强大。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f579" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">为什么我们应该在存储库中使用Kotlin流？</h1><p id="8330" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这是一个有趣的问题。</p><p id="0c06" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我先回答一个不同的。</p><h2 id="979e" class="mz lh it bd li na nb dn lm nc nd dp lq mh ne nf ls ml ng nh lu mp ni nj lw nk bi translated">为什么不是LiveData？</h2><p id="054a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">LiveData的核心目的是保存一组可以观察到的数据。它之所以与众不同，是因为它具有生命周期意识。关键的一点是LiveData观察者总是在主线程上被调用。</p><p id="d9a1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">尽管我们在存储库中使用LiveData将数据传递给ViewModel，但是这里ViewModel应该充当观察者，所以我们需要调用主线程的执行。不建议视图模型使用主线程操作。</p><p id="e496" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在实时中，我们经常对从服务器获得的数据进行转换。通过使用LiveData，我们必须在主线程中完成，这也是不推荐的。</p><p id="2168" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">当您看到LiveData的核心目的时，观察器总是在主线程上被调用是有意义的，因为它经常用于更新UI线程。</p><p id="8ce5" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这不是LiveData第一次被滥用。在Kotlin Flow之前，开发人员要求Android团队将它做成类似RxJava的东西。相反，他们创建了协程，并解释说LiveData是一个简单的数据容器。</p><h2 id="019d" class="mz lh it bd li na nb dn lm nc nd dp lq mh ne nf ls ml ng nh lu mp ni nj lw nk bi translated">为什么是科特林流？</h2><p id="0e41" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">协程被设计成干净地、顺序地执行复杂的异步操作。协程暂停函数异步返回单个值，但是我们如何返回多个异步计算的值呢？这就是Kotlin Flows大放异彩的地方。</p><p id="fa14" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">Flow被明确设计为有效地处理复杂的异步操作，并根据需求多次发出。与通道不同，流是<em class="of">冷</em>流，就像序列一样。在流被收集之前，流构建器中的代码不会运行。</p><p id="9029" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">因此，这些能力使得<a class="ae ky" href="https://kotlinlang.org/docs/reference/coroutines/flow.html" rel="noopener ugc nofollow" target="_blank"> Kotlin Flow </a>成为存储库中LiveData的绝佳替代品。Flow提供了类似的功能:构建器、冷流和有用的助手(例如转换数据)。与LiveData不同，它们不受生命周期的约束，并提供对执行上下文的更多控制。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="147a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">用Kotlin流替换LiveData</h1><p id="160e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">现在我们知道了为什么我们需要在存储库中使用Kotlin Flow而不是LiveData，是时候学习如何做了。首先，让我们看一个现有项目的蓝图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/807bbee37113ecae7da9ba4d24b9e191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*lMzF1Hk-SKQIxMK5hR7m1A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="8a2e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们的目标是用Kotlin流替换视图模型和存储库之间的LiveData。为此，首先我们需要用Kotlin流替换存储库函数的输出，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">知识库中的Kotlin流</p></figure><p id="e393" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这里，我们需要在返回类型中用Flow替换LiveData。正如您看到的执行，Flow首先发出加载状态。然后，在Ktor服务请求完成后，Flow再次发出响应。如果有异常，我们可以在catch块中发出它。</p><p id="5eb6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">记住，当我说我们使用Flow对执行有更多的控制时，通过使用<code class="fe nz oa ob oc b">flowOn</code>，我们可以根据需求明确地改变执行线程。这是众多便捷功能之一，如<code class="fe nz oa ob oc b">debounce</code>、<code class="fe nz oa ob oc b">delayFlow</code>等等。</p><p id="c453" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">既然我们已经成功地在存储库中实现了流，那么让我们看看如何在ViewModel中观察数据。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">视图模型中的Kotlin流</p></figure><p id="f0e5" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这里，我们使用<code class="fe nz oa ob oc b">viewmodelscope</code>来限制请求的范围，然后调用流上的<code class="fe nz oa ob oc b">collect</code>函数来触发请求。在<code class="fe nz oa ob oc b">collect</code>接收器中，我们可以通过LiveData发布数据来更新UI。现在现有项目的蓝图如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/dd9239843e8bc25d46ac757b51c33f40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*HC9DuI5IfoK8VDQFAKQgPw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="e482" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在ViewModel中，我们可以使用Kotlin流上的<code class="fe nz oa ob oc b">map</code>函数来实现映射。当我们有两个不同的服务器响应和本地使用模型时，这就很方便了。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有地图功能的流程</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5736" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="2858" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>