<html>
<head>
<title>The Command Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">命令设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-command-design-pattern-2313909122b5?source=collection_archive---------1-----------------------#2019-12-05">https://betterprogramming.pub/the-command-design-pattern-2313909122b5?source=collection_archive---------1-----------------------#2019-12-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e5a1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它是什么，我们如何应用它？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e7c8c7b2a5e1260413be3b1f0c25efb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-NfgBteJ0tzuzx3WSSqW3Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae ky" href="https://unsplash.com/s/photos/java?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有23个经典的设计模式，在原书<em class="lv">设计模式:可重用面向对象软件的元素</em>中有描述。这些模式为软件开发中经常重复出现的特定问题提供解决方案。</p><p id="c92a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将描述命令模式，以及如何和何时应用它。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e0cd" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">指挥模式:基本理念</h1><blockquote class="mv mw mx"><p id="a419" class="kz la lv lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated"><em class="it">在面向对象编程中，</em> <strong class="lb iu"> <em class="it">命令模式</em> </strong> <em class="it">是一种行为设计模式，在这种模式中，一个对象被用来封装执行一个动作或在以后触发一个事件所需的所有信息。这些信息包括方法名、拥有该方法的对象以及方法参数的值</em></p><p id="7b2e" class="kz la lv lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated"><em class="it">将一个请求封装成一个对象，从而让你参数化具有不同请求的客户端，队列或日志请求，并支持可撤销的操作</em></p><p id="61a5" class="kz la lv lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated">设计模式:可重用面向对象软件的元素</p></blockquote><p id="ce5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个模式中，抽象的<code class="fe nb nc nd ne b">Command</code>类被声明为执行操作的接口。这个<code class="fe nb nc nd ne b">Command</code>类定义了一个名为<code class="fe nb nc nd ne b">execute</code>的方法，它必须在每个具体的命令中实现。这个<code class="fe nb nc nd ne b">execute </code>方法是<code class="fe nb nc nd ne b">Receiver</code>对象和动作之间的桥梁。<code class="fe nb nc nd ne b">Receiver</code>知道如何执行与请求相关的操作(任何类都可以是<code class="fe nb nc nd ne b">Receiver</code>)。该模式中的另一个相关组件是<code class="fe nb nc nd ne b">Invoker</code>类，它要求必须执行的命令。</p><p id="6277" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是这个模式的UML图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/1fa414dbab20e970a60ef3610cd752d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*whyKeG0cDMnC6thc.png"/></div></div></figure><p id="817d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以下情况下应使用命令模式:</p><ul class=""><li id="8b64" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">您需要一个具有独立于原始请求的生命周期的命令，或者如果您想要排队，在不同的时间指定和执行请求。</li><li id="12ff" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">您需要撤消/重做操作。可以存储命令的执行结果，以逆转其效果。重要的是<code class="fe nb nc nd ne b">Command</code>类实现了undo和redo方法。</li><li id="e21f" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">您需要围绕基于原始操作的高级操作来构建系统。</li></ul><p id="351d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令模式有几个优点，概括起来有以下几点:</p><ul class=""><li id="4a8e" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">它将调用操作的类从知道如何执行操作的对象中分离出来。</li><li id="075d" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">它允许您通过提供一个队列系统来创建一系列命令。</li><li id="1284" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">实现扩展来添加新命令很容易，并且不需要更改现有代码就可以完成。</li><li id="4422" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">您还可以使用命令模式定义一个回滚系统——就像在向导示例中一样，我们可以编写一个回滚方法。</li><li id="ed60" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">严格控制调用命令的方式和时间。</li><li id="d928" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">代码更容易使用、理解和测试,因为命令简化了代码。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c0e4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">问题:股票市场</h1><p id="d84a" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">我现在将向您展示如何使用JavaScript/TypeScript实现这种模式。在我们的例子中，我编了一个问题，其中有一个名为<code class="fe nb nc nd ne b">Agent</code>的类定义了属性:<code class="fe nb nc nd ne b">stockTrade</code>；还有一次行动<code class="fe nb nc nd ne b">placeOrder</code>。这个类是客户端/上下文和<code class="fe nb nc nd ne b">StockTrader</code>之间的桥梁。<code class="fe nb nc nd ne b">placeOrder</code>方法负责决定应该执行什么动作。例如，如果<code class="fe nb nc nd ne b">orderType</code>是<code class="fe nb nc nd ne b">buy</code>或<code class="fe nb nc nd ne b">sell</code>，该方法应该调用<code class="fe nb nc nd ne b">StockTrader</code>中的动作。下面的UML图显示了我刚刚描述的场景。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/0b80af47d675690a307c26d8a1da37b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vHK1Rb4XuwtLAp2z.jpg"/></div></div></figure><p id="6fc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是<code class="fe nb nc nd ne b">client</code>和<code class="fe nb nc nd ne b">Agent</code>代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/f336a3872bb68a623dedf632fab3a0fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WhSV8UxGhu1OtdqN2gaQ-w.png"/></div></div></figure><p id="7afb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最相关的代码味道是与来自<code class="fe nb nc nd ne b">StockTrade</code>的动作/命令相关联的<code class="fe nb nc nd ne b">placeOrder</code>方法。有不同的技术可以避免这种代码味道。在这种情况下，<code class="fe nb nc nd ne b">Command</code>模式是一个很好的解决方案，因为我们想要记录命令的历史。</p><p id="813a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这里是<code class="fe nb nc nd ne b">StockTrade</code>类:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/faa9bc7902a16614938dfe6b6162b80b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fRyDmFpm5m6w4HabCCFM3g.png"/></div></div></figure><p id="b70c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/ecf356c297f2f08a3a2a5a6219f04677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*doeDSU0BLE7UJK1R.png"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="084c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">股市问题:解决方案</h1><p id="0bfe" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">将命令从<code class="fe nb nc nd ne b">Agent</code>类中分离出来的想法是为每个命令创建一组类。然而，这些命令共享一个公共接口，允许我们根据每个具体的命令来执行操作。</p><p id="b93d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我们创建了<code class="fe nb nc nd ne b">Order</code>抽象类，它将有一个名为<code class="fe nb nc nd ne b">execute</code>的抽象方法。该方法将从<code class="fe nb nc nd ne b">Agent</code>类(调用者)中调用。此外，<code class="fe nb nc nd ne b">Agent</code>类将有一个命令列表来获取命令的历史。</p><p id="1c6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这种方式，代理将知道必须对其接收的对象执行哪个操作的责任委托给了其他人。主要的变化是<code class="fe nb nc nd ne b">Agent</code>类不再接收原始属性作为参数(字符串),因为它没有语义值。相反，<code class="fe nb nc nd ne b">Agent</code>类现在将接收一个命令对象作为参数，它提供语义值。</p><p id="541a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用命令模式的新UML图如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/435a5d7b88ccc60cda7aff1401bf1e03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*I86O_Ct15YukrUH4.jpg"/></div></div></figure><p id="2a63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是与<code class="fe nb nc nd ne b">client</code>相关的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/dfe59ca29bd59a618843e95b739630e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*peJVrdECbOi6eWIijzavYg.png"/></div></div></figure><p id="a70c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，每个<code class="fe nb nc nd ne b">order</code>使用DI(依赖注入)接收<code class="fe nb nc nd ne b">StockTrade</code>。<code class="fe nb nc nd ne b">Agent</code>使用<code class="fe nb nc nd ne b">placeOrder</code>方法调用命令，该命令通过<code class="fe nb nc nd ne b">execute</code>方法执行操作。</p><p id="87ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是与<code class="fe nb nc nd ne b">Agent</code>相关的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/d88b0cd04006ef59dbf8dab72e921409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*48q9wNhns-YRtvCEtJj9MQ.png"/></div></div></figure><p id="3071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能会注意到，通过使用<code class="fe nb nc nd ne b">order.execute</code>方法避免了<code class="fe nb nc nd ne b">if-elseif-else</code>控制结构，该方法将责任委托给每个命令。</p><p id="5b60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是与<code class="fe nb nc nd ne b">Order</code>和每个订单相关的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/6dac6524577db9590c543f91924f16cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbHPcbMJcl_oFZegee425A.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/85b760b14273cf05c82eb2f36fbfc2f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*URjsIe_7NW3m68_UyhtcZw.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/7f4d4b0d886d14cab2700d7b63127443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pZlRXJFVCQRanr451jXn1Q.png"/></div></div></figure><p id="4086" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在该命令中没有修改<code class="fe nb nc nd ne b">StockTrade</code>类。在程序执行过程中进行这些修改后，结果如下:</p><p id="c1a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">npm run example1-problem</code> <br/> <code class="fe nb nc nd ne b">npm run example1-command-solution1</code></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="249e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">例子:一个机器人——R2D2</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/f732c4ca3a7f16e783f9cda42ca21fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DN02Yh1E9Kf1qTEvXD2R2w.jpeg"/></div></div></figure><p id="1dd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用命令模式解决的另一个有趣的例子是当有几个命令要为机器人执行时。</p><p id="810d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，一组命令如<strong class="lb iu"> SaveSecret </strong>、<strong class="lb iu"> Clean </strong>和<strong class="lb iu"> Move </strong>是向一个著名的机器人R2D2发出的。您可以在下面的UML图中看到这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/169ae7b60bc1e0a7c61403b4e92a03dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/0*6PwzeJ_Tpi7J_eHf.jpg"/></div></figure><p id="9514" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是与客户端相关的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/32fcc0231b2c13798669570c742ebe91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sN2wHLJBfUwPV52YmY5IBQ.png"/></div></div></figure><p id="161d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，有三个命令:<code class="fe nb nc nd ne b">saveSecretCommand</code>、<code class="fe nb nc nd ne b">cleanCommand</code>和<code class="fe nb nc nd ne b">moveCommand</code>，两个服务:<code class="fe nb nc nd ne b">StoreService</code>和<code class="fe nb nc nd ne b">R2D2Service</code>以及一个代理:<code class="fe nb nc nd ne b">R2D2</code>。</p><p id="bb46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代理使用<code class="fe nb nc nd ne b">executeCommand</code>方法调用订单，该方法接收两个参数:<strong class="lb iu">命令</strong>和<strong class="lb iu">参数以执行前面的命令</strong>。</p><p id="06fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是与R2D2相关的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/64901a5e9c99c991f533b7ec87bb98a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cak_eABVREn6dy9U6ZXHHA.png"/></div></div></figure><p id="57cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">R2D2有一个命令列表，可以通过<code class="fe nb nc nd ne b">listCommands</code>方法列出，并使用<code class="fe nb nc nd ne b">commands</code>数据结构存储。最后，<code class="fe nb nc nd ne b">executeCommand</code>方法负责调用每个命令的execute方法。</p><p id="56a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，下一步是创建与命令(抽象类)和每个具体命令相关的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/f4853de6527670b8b93fcc93c0dade29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJMyGFs5kTh87PJZ4bFSFQ.png"/></div></div></figure><p id="dd18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，每个命令调用负责该动作的服务。在这种情况下，我们使用了两个不同的服务来说明不是所有的命令都将责任委托给同一个服务或类。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/5fcf9043cfaea05ba6483d904c85d738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WezAe4sDM84BnyhysLov6A.png"/></div></div></figure><p id="ed95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/75dcce727cb546f62e27abbea903920d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J64_YrQG-KW3x5g9.png"/></div></div></figure><p id="a80a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在应用命令模式之后，我创建了一个npm脚本来运行这里的示例。</p><p id="ebdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">npm run example2-command-solution-1</code></p><p id="9c60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令模式可以帮助您避免项目中的复杂性，因为您将命令封装在一个特定的类中，该类可以在任何时候添加/删除或更改，包括执行时间。</p><p id="99d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的事情不是实现我向你展示的模式，而是能够识别这个特定模式可以解决的问题，以及你何时可以或不可以实现所述模式。这一点至关重要，因为实现会因您使用的编程语言而异。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="d66e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个帖子的GitHub分支是<a class="ae ky" href="https://github.com/Caballerog/blog/tree/master/command-pattern" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Caballerog/blog/tree/master/command-pattern</a></p></div></div>    
</body>
</html>