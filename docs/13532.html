<html>
<head>
<title>Issues of Returning Arrays of Dynamic Size in Solidity Smart Contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solidity智能合约中动态大小数组的返回问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/issues-of-returning-arrays-of-dynamic-size-in-solidity-smart-contracts-dd1e54424235?source=collection_archive---------10-----------------------#2022-09-05">https://betterprogramming.pub/issues-of-returning-arrays-of-dynamic-size-in-solidity-smart-contracts-dd1e54424235?source=collection_archive---------10-----------------------#2022-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="16a1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">返回大数组的函数的局限性及其处理方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/9c6216bd63bed039f370470d99bbe202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*s4pEmXObNCnWc75jqHvtqQ.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片</p></figure><p id="6531" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">自从引入智能合约以来，基于智能合约的系统的复杂性已经增长了很多。它从简单的投票合同、<a class="ae ln" href="https://eips.ethereum.org/EIPS/eip-20" rel="noopener ugc nofollow" target="_blank"> ERC20 </a> <a class="ae ln" href="https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code" rel="noopener ugc nofollow" target="_blank">代币</a>开始，发展到复杂的架构，如<a class="ae ln" href="https://github.com/Uniswap/v3-core" rel="noopener ugc nofollow" target="_blank"> Uniswap </a>、<a class="ae ln" href="https://github.com/aragon/core" rel="noopener ugc nofollow" target="_blank"> Aragon </a>等。</p><p id="4c28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在更接近我们的故事:最近<a class="ae ln" href="https://customapp.tech/" rel="noopener ugc nofollow" target="_blank">定制应用程序(开发工作室)</a>，我工作的地方，正在开发一个<a class="ae ln" href="https://apps.apple.com/tr/app/minter-guru/id1636761609" rel="noopener ugc nofollow" target="_blank"> Minter Guru dApp </a>，我正在研究系统架构和智能合同。根据Minter Guru的哲学，我们必须将尽可能多的逻辑转移到智能合约上。</p><p id="e90a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在实现read(from CRUD pattern)函数时，我们遇到了返回动态大小数组的问题，这些数组可能包含数百甚至数千个元素。因此，我们研究了实现这些功能的局限性。</p><p id="b472" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我们将讨论这些限制、处理它们的方法，以及用“使用智能合约实现Web2后端”的方法来构建应用程序的可行性。然而，如果你是一个有经验的web3开发者，我们的结果对你来说可能是显而易见的。:)</p><p id="ab92" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了更好地理解，你应该熟悉<a class="ae ln" href="https://ethereum.org/en/developers/docs/" rel="noopener ugc nofollow" target="_blank">以太坊</a>区块链基础(或任何其他EVM兼容的区块链，如<a class="ae ln" href="https://polygon.technology/" rel="noopener ugc nofollow" target="_blank">多边形</a>或<a class="ae ln" href="https://bscscan.com/" rel="noopener ugc nofollow" target="_blank">币安智能链</a>)、<a class="ae ln" href="https://docs.soliditylang.org/en/v0.8.16/" rel="noopener ugc nofollow" target="_blank">坚固度</a>和<a class="ae ln" href="https://hardhat.org/" rel="noopener ugc nofollow" target="_blank">安全帽</a>。示例中的所有代码以及如何运行它的说明都可以在我们的<a class="ae ln" href="https://github.com/custom-app/contract-call-return-limit" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中找到。</p><h1 id="2e8d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">气体极限</h1><p id="e3a9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们首先想到的是，理论上，我们可以达到气体极限。</p><p id="36fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在EVM，每个函数调用都需要汽油。由于通话不花实气，我们可以设置任何气限，但由于EVM实施最大气限等于最大值为<code class="fe ml mm mn mo b">uint64</code>式，即等于<code class="fe ml mm mn mo b">18446744073709551615</code>。</p><p id="b205" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看在简单的契约示例中，我们将多快达到这个限制。我们将使用一个与<code class="fe ml mm mn mo b">uint256[]</code>存储变量的简单契约，将<code class="fe ml mm mn mo b">n</code>值推送到数组函数和getter方法。此外，我们需要两个脚本来部署合同，并测试所需的气体限制。我们将使用<a class="ae ln" href="https://hardhat.org/" rel="noopener ugc nofollow" target="_blank"> Hardhat </a>用于我们的本地网络和与合同的交互。</p><p id="5f56" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">气体消耗基于阵列大小，因为EVM会将阵列数据复制到内存中。因此，我们将研究气体消耗和数组大小(以字节为单位)之间的依赖关系。为了简单起见，我们使用了<code class="fe ml mm mn mo b">uint256[]</code>数组。对于其他数据类型，以字节为单位的编码数组大小的计算有所不同。根据<a class="ae ln" href="https://docs.soliditylang.org/en/v0.8.15/abi-spec.html" rel="noopener ugc nofollow" target="_blank">坚固性规格</a>、<code class="fe ml mm mn mo b">Enc(uint256[])=Enc(array.size)(Enc(array[0],…,array[array.size-1]))</code>。因此，数组的字节大小等于<code class="fe ml mm mn mo b">size(uint256)+size(uint256)*array.size=32+32*array.size</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="f626" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行这个脚本时，我们看到for循环迭代开始变得非常慢。第10次迭代花了10多秒，第50次迭代花了4多分钟。顺便说一下，让我们检查一些结果(整个表格可以在<a class="ae ln" href="https://github.com/custom-app/contract-call-return-limit/blob/main/results/result.csv" rel="noopener ugc nofollow" target="_blank">我们的GitHub库</a>中找到):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">某些阵列尺寸的估计气体值</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/032b0dddfb0f4b9107ca3be2b37c3747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*8cjY57xFCmTxP4akna0UVA.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">估计气体对阵列尺寸的依赖性</p></figure><p id="9a2b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在图表上，我们可以看到估计的气体线性地依赖于阵列大小，所以让我们建立外推来估计阵列的理论大小。我们已经使用谷歌电子表格和线性回归完成了这项工作。你可以在这里查看<a class="ae ln" href="https://docs.google.com/spreadsheets/d/1jnWNhqhUCnUP__fHJFF_Mk22Ow1SlQ2P3_m7k_ah50U/edit#gid=0" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/6bd00ae61ebc192ad9236dca8ff6cc97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rwKawowN-otrxJFoAi2yEQ.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">估计气体外推</p></figure><p id="2269" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可以看到，理论上的uint256数组大小限制大约等于以千字节为单位的<code class="fe ml mm mn mo b">1.8e+17</code>(以太字节为单位的<code class="fe ml mm mn mo b">163709</code>)，这实际上是无法实现的。然而，正如我们已经看到的，执行时间是一个大问题。</p><h1 id="7748" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">执行时间</h1><p id="1ce0" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">先提一下我们是在<a class="ae ln" href="https://hardhat.org/" rel="noopener ugc nofollow" target="_blank"> Hardhat </a>网络上做测试，用Node.js实现，所以性能会比以太坊节点用的<a class="ae ln" href="https://github.com/ethereum/go-ethereum" rel="noopener ugc nofollow" target="_blank"> Golang实现</a>差一些。然而，智能合约功能的性能受EVM设计的影响比受EVM实现语言的影响更大。</p><p id="469e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">进行测试的机器的参数:</p><ul class=""><li id="604f" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">CPU —第11代英特尔酷睿i7–1165 G7 @ 2.80 GHz×8</li><li id="b6a2" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">内存— 16 GB</li><li id="dcc9" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">操作系统— Ubuntu 22.04 LTS</li><li id="e7cd" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">磁盘— 512 GB固态硬盘</li></ul><p id="992a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们修改测试脚本来测量执行时间。我们只需要在测试脚本中修改for循环来记录执行时间。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">获取某些大小的数组的执行时间</p></figure><p id="ae9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以看到，高执行时间问题出现得很快。对于320千字节的数据来说，12秒的执行时间太长了，所以时间成为我们需要克服的主要问题。</p><h1 id="7767" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">页码</h1><p id="5290" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">不幸的是，没有神奇的方法可以在合理的时间内获得大尺寸的数组。但是如果您的应用程序不需要一个完整的数组，您可以像Web2一样使用分页模式。然而，如果是这样，这是架构问题的标志，这在智能合约系统或经典的Web2应用程序中是无法解决的。</p><p id="aa26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">开发人员通常使用分页来限制一次API调用中返回数据的大小。这种方法减少了延迟，并减少了为浏览器和移动应用程序呈现的UI元素的数量。</p><p id="6516" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">分页的实现包括以下步骤:</p><ul class=""><li id="9098" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">在我们的数组上定义排序</li><li id="89ab" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">向API方法添加页码和页面大小(在我们的例子中是契约函数)。您的新方法应该返回排序数组的一部分:<code class="fe ml mm mn mo b">array[page*size:min((page+1)*size, array.length)]</code></li><li id="8ab8" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">将一个数组中的元素总数添加到响应中，可以得到客户机上的页面数量。</li></ul><p id="4103" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们修改我们的测试智能契约，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="21e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">和测试脚本。我们还将为每个get page调用节省执行时间，以表明它对任何页面都保持不变。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d28c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们检查我们的结果。同样，完整的结果可以在我们的库中找到。此外，为了减小表的大小，我们将只显示get page调用的平均和最大执行时间:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">按页获取数组的执行时间</p></figure><p id="7d5b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以现在我们可以在合理的时间内得到数组的一部分。</p><p id="2b3f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后一个细节:如果您想遍历一个状态可能被频繁修改的数组，您可以在调用函数时使用一个固定的块号。这保证了在每次单页调用时状态保持不变。使用Hardhat契约绑定，可以按如下方式完成:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="eada" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="292a" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">所以，我们发现了两个要点:</p><ol class=""><li id="d423" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nm nd ne nf bi translated">函数返回大数组的主要问题是调用执行时间。</li><li id="cd1e" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nm nd ne nf bi translated">通过分页，我们可以使调用时间足够合理，以获取部分数据。如果应用程序的for逻辑可以同时处理数组的各个部分，那么可以使用这种模式。</li></ol><p id="58ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们已经用最简单的getter逻辑完成了所有的测试，但是在您的应用程序中，getter逻辑可能要复杂得多，所以在设计您的架构时，您应该小心地将所有东西移动到智能契约中。</p><p id="3b79" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">部署到mainnet后，您可能会面临无法解决的问题(如果您的合同不可升级)。如果你觉得你的系统太复杂，不能全部放在智能合约中，结合智能合约和经典的Web2解决方案将是一个更好的应用程序。</p><h1 id="fb59" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">参考</h1><ul class=""><li id="32c0" class="mx my iq kt b ku mg kx mh la nn le no li np lm nc nd ne nf bi translated"><a class="ae ln" href="https://github.com/custom-app/contract-call-return-limit" rel="noopener ugc nofollow" target="_blank">带有示例的GitHub库</a></li><li id="2971" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><a class="ae ln" href="https://medium.com/better-programming/is-web3-native-mobile-app-possible-b0497da964ad" rel="noopener">我的同事兼好朋友写的一篇被严重低估的关于开发Web3原生iOS应用的文章</a></li><li id="dfc4" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/how-to-integrate-your-nft-smart-contracts-with-opensea-b2925789a62f">我的另一篇关于NFT智能合同与OpenSea整合的文章</a></li><li id="e41c" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><a class="ae ln" href="https://apps.apple.com/tr/app/minter-guru/id1636761609" rel="noopener ugc nofollow" target="_blank"> Minter Guru应用</a></li><li id="5e32" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><a class="ae ln" href="https://twitter.com/MinterGuru" rel="noopener ugc nofollow" target="_blank"> Minter Guru Twitter </a></li><li id="1705" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><a class="ae ln" href="https://customapp.tech/" rel="noopener ugc nofollow" target="_blank">定制app网站</a></li></ul><pre class="kg kh ki kj gt nq mo nr ns aw nt bi"><span id="653b" class="nu lp iq mo b gy nv nw l nx ny"><strong class="mo ir">Want to Connect?</strong></span><span id="7034" class="nu lp iq mo b gy nz nw l nx ny"><a class="ae ln" href="https://twitter.com/shleshg_dev" rel="noopener ugc nofollow" target="_blank">Twitter</a> | <a class="ae ln" href="https://www.linkedin.com/in/oleg-shatniuk-5166b9234/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a></span></pre></div></div>    
</body>
</html>