<html>
<head>
<title>How To Pass Arrays Between JavaScript and WASM in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust中如何在JavaScript和WASM之间传递数组</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-pass-arrays-between-javascript-and-wasm-in-rust-9f2eeee7f2b6?source=collection_archive---------9-----------------------#2022-09-15">https://betterprogramming.pub/how-to-pass-arrays-between-javascript-and-wasm-in-rust-9f2eeee7f2b6?source=collection_archive---------9-----------------------#2022-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ec2f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索这个友好的界面</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f15cf49542766526ff8831db3dae28b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1MIcJ2HF0WDnHBm5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jakobsoeby?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jakob s by</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于WASM的内存模型，传递数组(和嵌套数组)可能是相当具有挑战性的，如果你试图做安全的事情，因为wasm内存存储其值作为标量类型的数组缓冲区。</p><p id="bd61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，幸运的是，当Javascript和WebAssembly之间交换数据时，我们拥有提供友好界面的<code class="fe lv lw lx ly b">wasm-bindgen</code>(和<code class="fe lv lw lx ly b">js-sys</code>)机箱。</p><p id="0cf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还应该提到，无论何时使用WebAssembly，如果您将性能作为开发目标之一，就应该避免在JS和WASM二进制文件之间交换数据。</p><p id="f983" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，我们希望WASM在其线性内存中处理繁重的计算、查询和数据，并且只返回少量的计算数据。</p><p id="5f10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Wasm函数以一个<code class="fe lv lw lx ly b">ArrayBuffer</code>的形式接受并返回标量值。幸运的是<code class="fe lv lw lx ly b">wasm-bindgen</code>在很多方面都有帮助，但它并不是万能的。</p><p id="22fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何使用类型传递(或返回)数组。</p><h1 id="6a0a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">设置</h1><p id="af35" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">因为我们正在使用WebAssembly，更确切地说，它是针对一个web构建的(它意味着与js一起工作)，我们能得到的最好的设置是通过使用<code class="fe lv lw lx ly b">wasm-bindgen</code>和它的程序宏。</p><p id="a3b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看看<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/get-started-with-wasm-in-rust-2347056bab4">这篇文章</a>更详细更全面地介绍设置和WASM+Rust，但这里有一个小的回顾:</p><h2 id="0680" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">添加所需的依赖项</h2><p id="9a25" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">将这两个依赖项添加到您的<code class="fe lv lw lx ly b">Cargo.toml</code>配置中(确保您使用的是最新版本):</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="713b" class="mw ma it ly b gy nm nn l no np">wasm-bindgen = "0.2.82"<br/>js-sys = "0.3.59"</span></pre><h2 id="32a3" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">WASM优化</h2><p id="e127" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">您还应该在配置中添加以下内容:</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="4277" class="mw ma it ly b gy nm nn l no np">[profile.release]<br/>opt-level = "z"<br/>overflow-checks = true<br/>debug = 0<br/>strip = "symbols"<br/>debug-assertions = false<br/>panic = "abort"<br/>codegen-units = 1<br/>lto = true</span><span id="60f9" class="mw ma it ly b gy nq nn l no np">[profile.dev]<br/>opt-level = 0<br/>panic = 'abort'</span></pre><p id="7d53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些将在编译代码时添加一些设置，这对代码大小也是有益的(例如，在惊慌收缩代码大小时中止)。</p><p id="4a32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，你需要告诉编译器编译将产生一个动态系统库(<code class="fe lv lw lx ly b">"cdylib"</code>)和统计链接的可执行文件(<code class="fe lv lw lx ly b">"rlib"</code>内容被插入到可执行文件中)。</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="cd57" class="mw ma it ly b gy nm nn l no np">[lib]<br/>crate-type = ["cdylib", "rlib"]</span></pre><h1 id="e00a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">接收阵列</h1><p id="bc52" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">正如我通过导入<code class="fe lv lw lx ly b">js_sys</code>依赖项所暗示的，我们将使用<code class="fe lv lw lx ly b">js_sys::Array</code>类型。</p><p id="003d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个Rust函数<code class="fe lv lw lx ly b">my_funct</code>，它接受一个数组作为参数。这是使用<code class="fe lv lw lx ly b">js_sys::Array</code>类型时的样子:</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="7f42" class="mw ma it ly b gy nm nn l no np">#[wasm_bindgen] <br/>pub fn my_funct(     <br/>    my_arr: Array,<br/>)</span></pre><p id="3ab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常简单的构造，几乎不需要我们付出任何努力。然而，努力在于如何对付这种<code class="fe lv lw lx ly b">Array</code>式的。比如不能有嵌套数组，值类型未知(因为JS没有强类型)。</p><h2 id="d474" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">嵌套数组</h2><p id="1c67" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">正如我提到的，<code class="fe lv lw lx ly b">Array</code>类型不支持嵌套数组。那是因为你不能将<code class="fe lv lw lx ly b">Array</code>的一个元素转换成一个向量。</p><p id="1183" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有几个选择。您可以传递<code class="fe lv lw lx ly b">[["hey"], ["tdep"]]</code>，然后将数组中的元素解析成一个字符串，使用:</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="d70d" class="mw ma it ly b gy nm nn l no np">my_arr.get(index).as_string().unwrap()</span></pre><p id="a012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后用类似<code class="fe lv lw lx ly b"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-work-with-json-in-rust-35ddc964009e">serde_json</a></code>的库反序列化字符串。</p><p id="3130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个选项是将多维数组作为一维数组传递，然后在Rust上将其构建为嵌套数组，这是我更喜欢的选项，因为它允许我在不使用额外依赖项的情况下使用嵌套数组。</p><p id="48e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你知道数组的长度，这是相当容易的。假设你知道你需要一个四个元素的数组，然后用两个数组构造一个嵌套的数组，看起来像这样<code class="fe lv lw lx ly b">[["el1", "el2"], ["el3", "el4"]]</code>。如果是这种情况，您可以使用以下方法轻松解决问题:</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="dacd" class="mw ma it ly b gy nm nn l no np">[<br/>  [     <br/>  &amp;arr.get(0).as_string().unwrap(),<br/>  &amp;arr.get(1).as_string().unwrap(),<br/>  ],<br/>  [  <br/>  &amp;arr.get(2).as_string().unwrap(),<br/>  &amp;arr.get(3).as_string().unwrap(),<br/>  ]<br/>]</span></pre><p id="9fe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，您可能正在处理向量，并让JS在编译时传递一个未知长度的数组，您仍然必须构建一个嵌套数组，其中每个元素都是包含两个元素的数组。</p><p id="61b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我决定手动实现这个算法，因为它很容易编写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a96a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码循环我们的<code class="fe lv lw lx ly b">my_arr</code>数组，并每两步将一个包含两个元素的新数组推入<code class="fe lv lw lx ly b">my_arr_vec</code>向量。</p><p id="7e41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着只要我们收到一个长度为偶数的数组，我们的循环就会工作(因为我们想要构建一个内部包含两个元素的数组的向量)。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="cc1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇简单的文章中，我们已经看到了如何使用<code class="fe lv lw lx ly b">js_sys::Array</code>类型将数组从JS安全地传递到Rust，这要感谢<code class="fe lv lw lx ly b">wasm_bindgen</code>和<code class="fe lv lw lx ly b">js_sys</code>箱子。我还应该提到，如果需要的话，<code class="fe lv lw lx ly b">Array</code>类型也可以传递回Javascript。但是，请记住，如果您需要考虑性能，您应该将js限制为在WASM代码完成必要的计算后，只接收它的简洁输出。</p><p id="91cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oa">感谢阅读！</em></p></div></div>    
</body>
</html>