<html>
<head>
<title>Jetpack DataStore: Improved Data-Storage System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">喷气背包数据存储:改进的数据存储系统</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/jetpack-datastore-improved-data-storage-system-adec129b6e48?source=collection_archive---------5-----------------------#2020-09-16">https://betterprogramming.pub/jetpack-datastore-improved-data-storage-system-adec129b6e48?source=collection_archive---------5-----------------------#2020-09-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8c37" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Jetpack数据存储替换共享首选项</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/388919666c7bdfe5e1f6ea47c972a631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IP2OR3Uks0diJO1f"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@mtimber71?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马克·汀布莱克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="7168" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是数据存储？</h1><p id="5558" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">多年来，Android开发者已经习惯于通过共享偏好来存储小块的敏感用户数据。这种方法有以下缺点:</p><ul class=""><li id="76d8" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm mu mv mw mx bi translated">共享偏好设置中的敏感数据很容易暴露</li><li id="e749" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">在UI线程上调用共享偏好操作看起来是安全的，但实际上并不安全(因为在UI线程上调用同步API看起来是安全的，没有发出错误信号的机制，缺少事务API，等等)</li></ul><p id="8ea8" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated"><a class="ae ky" href="https://developer.android.com/reference/kotlin/androidx/datastore/package-summary?hl=el" rel="noopener ugc nofollow" target="_blank"> DataStore </a>是Jetpack家族的一个库，它提供了一个新的数据存储解决方案，可能会取代共享首选项。它目前处于alpha阶段。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="1fbf" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">为什么选择数据存储？</h1><p id="8a58" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">它是使用Kotlin协同例程和Flow API构建的，这使得它比共享首选项更加安全可靠。它提供了两种不同的方法来保存数据:</p><ul class=""><li id="1850" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm mu mv mw mx bi translated"><strong class="lt iu"> Preferences DataStore: </strong>它与<code class="fe ns nt nu nv b">SharedPreferences</code>相似，因为它无法定义一个模式或确保使用正确的类型访问键</li><li id="1a98" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated"><strong class="lt iu"> Proto DataStore: </strong>允许您使用<a class="ae ky" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>创建模式。使用protobufs允许强类型数据的持久化。它们比XML和其他类似的数据格式更快、更小、更简单、更明确。</li></ul><p id="cad0" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">除此之外，当您存储键-值对时，只有键会被公开，而内容不会。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="2248" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">数据库与数据存储</h1><p id="06fa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">构建数据存储是为了存储小型数据集；如果您的需求涉及部分更新、参照完整性或对大型/复杂数据集的支持，您应该考虑使用<a class="ae ky" href="https://developer.android.com/topic/libraries/architecture/room" rel="noopener ugc nofollow" target="_blank"> Room </a>而不是DataStore。</p><p id="20d9" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">在本文的最后，您将找到学习如何使用房间数据库的链接，从它的基础到更高级的选项。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="269d" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">综合</h1><p id="808b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要使用Jetpack数据存储库，请在应用程序级<code class="fe ns nt nu nv b">build.gradle</code>文件中的dependencies节点下添加以下行。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="d7b0" class="oa la it nv b gy ob oc l od oe">implementation "androidx.datastore:datastore-preferences:1.0.0-alpha01"</span></pre></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="33a2" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">让我们开始编码吧</h1><p id="7d1b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了更好地理解如何使用数据存储，我举了一个简单的实时例子，其中我们存储了一个指示用户登录状态的整数。这里，我们有一个包含所有可能阶段的<code class="fe ns nt nu nv b">enum</code>类。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="c0fd" class="oa la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated">创建数据存储</h2><p id="d6cb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下一步是创建数据存储。为此，我们需要创建一个Kotlin类，在其中我们将使用<code class="fe ns nt nu nv b">context.createDataStore</code>扩展函数来创建DatasSore。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="5ff8" class="oa la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated">创建密钥</h2><p id="250d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将通过定义结果类型来创建<code class="fe ns nt nu nv b">preferencesKey</code>内联函数。看一看:</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="bc8a" class="oa la it nv b gy ob oc l od oe">companion object {<br/>    val USER_STATUS = <strong class="nv iu"><em class="os">preferencesKey</em></strong>&lt;Int&gt;("user_status")<br/>}</span></pre></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="d708" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">保存和检索数据</h1><p id="ccc8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们已经创建了数据存储和密钥，是时候保存用户的状态了。我们将保存一个值为1、2、3和4的整数，分别代表<code class="fe ns nt nu nv b">STARTER</code>、<code class="fe ns nt nu nv b">ONBOARDING_LEVEL_1</code>、<code class="fe ns nt nu nv b">ONBOARDING_LEVEL_2</code>和<code class="fe ns nt nu nv b">VERIFIED</code>。</p><h2 id="432e" class="oa la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated">救援</h2><p id="ce36" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了在数据存储文件中保存键值对，我们必须使用<code class="fe ns nt nu nv b">edit</code>函数来更新值。这里，我们使用<code class="fe ns nt nu nv b">suspend</code>函数来保存值。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在我们的数据存储中保存值</p></figure><h2 id="5dbb" class="oa la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated">恢复</h2><p id="15f3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了从数据存储中检索值，我们使用流API。使用Flow的一个主要优点是每次数据存储中有新值更新时，我们都会得到通知。所以我们不再需要检查更新的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从数据存储中检索数据</p></figure><p id="f887" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">我们可以使用像<code class="fe ns nt nu nv b">map</code>这样的函数将数据转换成适当的数据类型，而不是在调用点将整数交给用户状态用例。<br/>现在，让我们把这些碎片拼在一起，让它们更有意义。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">首选项管理器实现</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="d6a0" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">从Android组件访问</h1><p id="7dfb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们已经完成了首选项管理器，让我们看看如何从Android活动中调用<code class="fe ns nt nu nv b">setUserStatus</code>。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自活动的“setUserstatus”</p></figure><p id="fb7d" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">由于<code class="fe ns nt nu nv b">setUserStatus</code>是一个挂起函数，我们使用了一个<code class="fe ns nt nu nv b">lifecycleScope</code>来启动一个协程。</p><p id="acc4" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">检索数据中心的数据是类似的；这里，我们通过用一个<code class="fe ns nt nu nv b">lifecycleScope</code>扭曲它来使用来自流API的<code class="fe ns nt nu nv b">collectLatest</code>。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="9ec1" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">结论</h1><p id="c237" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读！</p><h2 id="733a" class="oa la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated">Jetpack库资源</h2><ul class=""><li id="0a38" class="mn mo it lt b lu lv lx ly ma ot me ou mi ov mm mu mv mw mx bi translated"><a class="ae ky" href="https://medium.com/swlh/workmanager-basics-how-to-use-workmanager-with-rxjava2-kotlin-coroutines-c2a317197038" rel="noopener">“工作管理器基础知识，如何将工作管理器与Rxjava2一起使用&amp; Kotlin协程”</a></li><li id="5fd6" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated"><a class="ae ky" href="https://medium.com/@sgkantamani/android-room-persistence-library-kotlin-coroutines-26d53a09d384" rel="noopener">《安卓房间暂留库科特林协同程序</a><strong class="lt iu"/></li><li id="913a" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated"><a class="ae ky" href="https://medium.com/@sgkantamani/app-startup-new-architecture-component-d115b062a701" rel="noopener">“App启动—新架构组件”</a></li></ul><h2 id="2698" class="oa la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated">房间图书馆资源</h2><ul class=""><li id="85a1" class="mn mo it lt b lu lv lx ly ma ot me ou mi ov mm mu mv mw mx bi translated"><a class="ae ky" href="https://medium.com/mindorks/android-room-persistence-library-with-rxjava2-and-lesser-known-features-of-room-database-8b968261f9f0" rel="noopener">“Android房间持久性库，具有Rxjava2和房间数据库的鲜为人知的特性</a>”</li><li id="0465" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated"><a class="ae ky" href="https://medium.com/@sgkantamani/android-room-persistence-library-kotlin-coroutines-26d53a09d384" rel="noopener">《安卓房间暂留库kot Lin Coroutines</a><strong class="lt iu"/></li></ul></div></div>    
</body>
</html>