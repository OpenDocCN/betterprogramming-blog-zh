<html>
<head>
<title>Advanced Programming With Kotlin (Part 7)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Kotlin进行高级编程(第7部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/advanced-programming-with-kotlin-part-7-cc02f321c260?source=collection_archive---------12-----------------------#2020-12-21">https://betterprogramming.pub/advanced-programming-with-kotlin-part-7-cc02f321c260?source=collection_archive---------12-----------------------#2020-12-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="62d4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从Java调用Kotlin</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/900b790f84cb812926155fd5eddf8e4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HBSg-m4yv3s6sSKH"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@levilei?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Levi Lei </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="d0b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与Java不同，在Java中我们需要编写所有内容，Kotlin编译器可以理解代码，并在幕后编写样板代码。例如，它可以推断变量声明中的类型。这提高了生产率并节省了时间。</p><p id="0491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在网上搜索，你会发现Kotlin解决了Java的许多痛点，以及Kotlin的特性如何让Android开发更有趣。</p><p id="7f34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如<a class="ae ky" href="https://opensourceforu.com/2018/07/kotlin-a-language-for-modern-multi-platform-applications/" rel="noopener ugc nofollow" target="_blank">为你开源</a>所描述的:</p><blockquote class="lv lw lx"><p id="97b7" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">“Kotlin是一种多平台编程语言，简洁、安全、可互操作且工具友好。它是一种静态类型的编程语言，运行在Java虚拟机上，也可以编译成JavaScript源代码，或者可以使用LLVM编译器基础设施。”</p></blockquote><p id="f427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毫无疑问，Kotlin有助于开发人员比使用Java更高效，但我们不能一夜之间就将多年的编码转换成Kotlin。将Java项目转换成Kotlin的最大优势之一是我们可以增量地完成，这意味着我们可以在同一个项目中同时拥有Kotlin和Java。</p><p id="84d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在理论上很棒，但在现实中，我们需要学习一些东西，帮助我们从Java中调用Kotlin代码。在本文中，我们将了解三个重要的注释，它们将有助于从Java中调用Kotlin代码。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="66db" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">@JvmStatic</h1><p id="675f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">Kotlin更像是一个函数式程序。它把功能放在第一位。与Java不同，Kotlin中的包级函数是静态函数。创建静态函数的另一种方法是在伴随对象中声明函数。</p><p id="eace" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解它，让我们创建一个简单的具有单一功能的Kotlin对象。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6b1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看如何从Kotlin和Java代码中调用<code class="fe ni nj nk nl b">readyTheBride</code> <strong class="lb iu"> </strong>函数。</p><p id="1084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用类名和函数调用直接从Kotlin中完成:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="370f" class="nq mk it nl b gy nr ns l nt nu">MarriageUtils.readyTheBride() //Kotlin</span></pre><p id="dd79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是当我们在Java代码中做同样的事情时，它会抛出一个编译器错误。我们不能从Java代码中直接访问伴随对象函数。为此，我们需要一个变通方法，就是使用<code class="fe ni nj nk nl b">Companion</code> <em class="ly"> </em>作为到达函数的桥梁:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="2872" class="nq mk it nl b gy nr ns l nt nu">MarriageUtils.<!-- -->Companion<!-- -->.readyTheBride() //Java</span></pre><p id="1d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是最常用的过程，但这个问题的真正解决方案是使用<code class="fe ni nj nk nl b">JvmStatic</code>注释，这将向编译器传达这是一个在Kotlin和Java中都可以访问的静态函数。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="7e1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以从Kotlin和Java中直接调用<code class="fe ni nj nk nl b">readyTheBride</code>函数，无需任何伴随。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="b72f" class="nq mk it nl b gy nr ns l nt nu">MarriageUtils.readyTheBride() // Kotlin<br/>MarriageUtils.readyTheBride() // Java</span></pre><p id="8671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如文档中的<a class="ae ky" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-static/" rel="noopener ugc nofollow" target="_blank">所示，<code class="fe ni nj nk nl b">JvmStatic</code>注释:</a></p><blockquote class="lv lw lx"><p id="d4b5" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">"指定如果该元素是一个函数，则需要从该元素生成一个额外的静态方法。如果此元素是一个属性，则应生成附加的静态getter/setter方法。</p></blockquote></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="6d43" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">@JvmOverloads</h1><p id="f44f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">通常，为了建模一个只保存数据的类，我们使用一个<code class="fe ni nj nk nl b">data class</code>。这种方法将自动生成所有的样板文件。我们也可以给变量赋予默认值。看一看:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="5a7d" class="nq mk it nl b gy nr ns l nt nu">data class Marriage(val place : String = "London", val bride : String, val groom : String)</span></pre><p id="cc43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">Marriage</code>是保存三个属性数据的数据类:<code class="fe ni nj nk nl b"> place</code>、<code class="fe ni nj nk nl b">bride</code>和<code class="fe ni nj nk nl b">groom</code>。<code class="fe ni nj nk nl b">bride</code>和<code class="fe ni nj nk nl b">groom</code>是正常参数，但<code class="fe ni nj nk nl b">place</code>是有默认值的参数。当我们在Kotlin代码中使用缺省值参数时，给它们赋值是可选的。看一看:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="a445" class="nq mk it nl b gy nr ns l nt nu">val a = Marriage( bride = "Monica", groom = "Chandler" )<br/>val b = Marriage( place = "USA", bride = "Monica", groom = "Chandler" )</span></pre><p id="014b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kotlin代码中有两种方法可以完美地工作。让我们看看我们能从Java代码中做些什么:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="1d4d" class="nq mk it nl b gy nr ns l nt nu">Marriage a = new Marriage( "Monica", "Chandler"); //Compiler error<strong class="nl iu"><br/></strong>Marriage b = new Marriage( "USA", "Monica", "Chandler"); </span></pre><p id="8ba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一种方法抛出一个编译器错误，因为Java没有缺省值参数。这个问题的解决方案是将<code class="fe ni nj nk nl b">JvmOverloads</code>注释与<code class="fe ni nj nk nl b">constructor</code>一起使用:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="b0d5" class="nq mk it nl b gy nr ns l nt nu">data class  Marriage @JvmOverloads constructor(val place : String =   "London", val bride : String, val groom : String)</span></pre><p id="1157" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个方法有A参数和B参数(它们有默认值)，就会生成B重载。第一个使用A-1参数(除了最后一个使用默认值)，第二个使用-2参数，依此类推。由于有多个构造函数，当我们从Java中调用这些类时，这将完美地工作。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="0d76" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">@JvmField</h1><p id="3868" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">为了理解这个注释是如何有用的，我们需要回顾一下我们用Java创建POJO类的方式。手动创建一个包含所有getters、setters和其他属性的POJO类需要做大量的工作。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8465" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当我们试图在Kotlin中实现相同的类时，它看起来如下:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="0c47" class="nq mk it nl b gy nr ns l nt nu">data class  Marriage (val place : String , val bride : String, val groom : String)</span></pre><p id="f6fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以当我们试图访问Kotlin数据类变量时，从Kotlin方法到Java方法都会有所不同。</p><p id="2cd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们从科特林代码中获取:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="0f0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们从Java代码中访问:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="333a" class="nq mk it nl b gy nr ns l nt nu">Marriage marriage = new Marriage( "USA", "Monica", "Chandler");<br/>String place = marriage.getPlace();</span></pre><p id="5a6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们需要使用getters和setters，而不是直接从变量中访问。但是有一个直接访问变量的变通方法。我们需要对您想要直接访问的变量使用<code class="fe ni nj nk nl b">JvmField</code>注释。看一看:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="6907" class="nq mk it nl b gy nr ns l nt nu">data class Marriage (@JvmField val place : String, val bride : String, val groom : String)</span></pre><p id="4acf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以从Java访问数据类中的变量，如下所示:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="5fb4" class="nq mk it nl b gy nr ns l nt nu">Marriage marraige = new Marriage( "USA", "Monica", "Chandler");<br/>String place = marraige.place; // Variable access<br/>String groom = marraige.getGroom(); // Method access</span></pre></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="e961" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="b62a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">要了解更多关于Kotlin的信息，请阅读Kotlin高级编程系列的前几部分:</p><ul class=""><li id="22d8" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated"><a class="ae ky" href="https://medium.com/better-programming/advanced-android-programming-with-kotlin-5e40b1be22bb" rel="noopener">“使用Kotlin进行高级编程</a>”</li><li id="81e4" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><a class="ae ky" href="https://medium.com/android-dev-hacks/advanced-android-programming-with-kotlin-part-2-aae2a15258b0" rel="noopener">“用Kotlin进行高级编程—第二部分</a>”</li><li id="2aba" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><a class="ae ky" href="https://medium.com/better-programming/advanced-programming-in-kotlin-2e01fbc39134" rel="noopener">“用Kotlin进行高级编程—第三部分</a>”</li><li id="db3b" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><a class="ae ky" href="https://medium.com/better-programming/advanced-android-programing-in-kotlin-part-4-187b88fea048" rel="noopener">“使用Kotlin进行高级编程—第4部分”</a></li><li id="d316" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><a class="ae ky" href="https://medium.com/better-programming/advanced-programming-in-kotlin-part-5-b674ce9e692f" rel="noopener">“使用Kotlin进行高级编程—第5部分”</a></li><li id="2f24" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><a class="ae ky" href="https://medium.com/better-programming/advanced-programming-with-kotlin-part-6-3f33290d8aad" rel="noopener">“使用Kotlin进行高级编程—第6部分”</a></li></ul><p id="dcc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解更多关于Kotlin协同例程和Kotlin的其他高级特性，请阅读以下文章:</p><ul class=""><li id="aa27" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated"><a class="ae ky" href="https://medium.com/better-programming/kotlin-coroutines-from-basics-to-advanced-ad3eb1421006" rel="noopener">“科特林协程，从基础到高级</a></li><li id="662c" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><a class="ae ky" href="https://medium.com/better-programming/how-to-use-kotlin-sealed-classes-for-state-management-c1cfb81abc6a" rel="noopener">“如何使用Kotlin密封类进行状态管理”</a></li><li id="8db9" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><a class="ae ky" href="https://medium.com/better-programming/asynchronous-data-loading-with-new-kotlin-flow-233f85ae1d8b" rel="noopener">“使用新Kotlin流异步加载数据</a></li><li id="591e" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><a class="ae ky" href="https://medium.com/better-programming/exploring-collections-and-sequences-in-kotlin-3a324ea08fb9" rel="noopener">“探索Kotlin中的集合和序列”</a></li><li id="7cb0" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><a class="ae ky" href="https://medium.com/better-programming/why-and-how-to-use-kotlins-native-serialization-library-c88c0f14f93d" rel="noopener">“为什么以及如何使用Kotlin的本地序列化库</a>”</li><li id="3cb1" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><a class="ae ky" href="https://medium.com/@sgkantamani/learn-how-to-combine-kotlin-flows-317849a71d3e" rel="noopener">“学习如何组合科特林流</a>”</li></ul><p id="bbf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>