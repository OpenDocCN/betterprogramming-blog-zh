<html>
<head>
<title>Writing Your Own JavaScript Data Structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写自己的JavaScript数据结构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-your-own-javascript-data-structures-a63eca08c1ee?source=collection_archive---------15-----------------------#2022-02-21">https://betterprogramming.pub/writing-your-own-javascript-data-structures-a63eca08c1ee?source=collection_archive---------15-----------------------#2022-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fb17" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">4 JavaScript中数据结构的实现</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8b7135a92d3e32d6e0ebef641f6468d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*87Y7vDndtJspT7UwoDm-0w.png"/></div></div></figure><p id="2c16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编码面试，解题技巧，算法题都和<strong class="kw iu">数据结构有关。</strong></p><p id="baff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">数据结构组织、管理和存储数据，从而实现高效的访问和修改。JavaScript提供了四种本地数据结构:数组、集合、映射和对象。然而，在这篇文章中，我们不涉及这些。</p><p id="e9e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望这篇文章能帮助大多数正在阅读的人。</p><h1 id="a167" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">1.堆</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/b2e41fa2d219817746edbed1c4a682ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*GdppxfjeC6Aurk3W4RO1ow.png"/></div></figure><p id="6143" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Stack是一种抽象数据类型，遵循LIFO(后进先出)或FILO(先入后出)规则。</p><p id="0adf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">现实世界的例子:</strong>你要从第一个洗到最后一个的一叠盘子。</p><p id="96fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">堆栈必须至少支持以下操作:</p><ol class=""><li id="1ef8" class="mj mk it kw b kx ky la lb ld ml lh mm ll mn lp mo mp mq mr bi translated"><code class="fe ms mt mu mv b">push</code> —将一个元素推到堆栈的顶部</li><li id="27b1" class="mj mk it kw b kx mw la mx ld my lh mz ll na lp mo mp mq mr bi translated"><code class="fe ms mt mu mv b">pop</code> —从堆栈顶部移除元素，并返回移除的元素。</li><li id="dfe3" class="mj mk it kw b kx mw la mx ld my lh mz ll na lp mo mp mq mr bi translated"><code class="fe ms mt mu mv b">peek</code> —返回顶部元素</li></ol><p id="f6cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实施:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="830f" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">2.长队</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/2768c97eec59233f61b21d4f461ea18b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*yfTLe3_Uaw4ALQi8h4ZYmg.png"/></div></figure><p id="6faf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">队列和堆栈的唯一区别是队列遵循FIFO(先进先出)规则。</p><p id="4682" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">现实世界的例子:</strong>烤面包机通知什么先进，什么先走。</p><p id="bde9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">队列必须至少支持以下操作:</p><ol class=""><li id="b39d" class="mj mk it kw b kx ky la lb ld ml lh mm ll mn lp mo mp mq mr bi translated"><code class="fe ms mt mu mv b">enqueue</code> —在队列的开头插入一个元素</li><li id="db15" class="mj mk it kw b kx mw la mx ld my lh mz ll na lp mo mp mq mr bi translated"><code class="fe ms mt mu mv b">dequeue</code> —从队列末尾删除一个元素，并返回删除的元素。</li><li id="75f8" class="mj mk it kw b kx mw la mx ld my lh mz ll na lp mo mp mq mr bi translated"><code class="fe ms mt mu mv b">front</code> —从队列中返回前面的元素</li><li id="ca2a" class="mj mk it kw b kx mw la mx ld my lh mz ll na lp mo mp mq mr bi translated"><code class="fe ms mt mu mv b">back</code> —从队列中返回返回元素</li></ol><p id="421f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实施:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="0198" class="ne lr it bd ls nf ng dn lw nh ni dp ma ld nj nk mc lh nl nm me ll nn no mg np bi translated">优先队列</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/47372bfd996f383cd8ee0f08b1be4c41.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*zSsPo-6RrC6HDQ0t3azAHQ.png"/></div></figure><p id="cc6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">优先级队列是队列的增强版本；它会根据提供的优先级进行相应的排序。如果有两个元素具有相同的优先级，则该元素将被插入到第一个元素的后面。</p><p id="55e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实施:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="ad2f" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">3.单向链表</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/100d91e0867e14284a9a8abda796eb84.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*GFeBozWLMiw5WkXVArKYZw.png"/></div></figure><p id="294f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">单向链表是一种单向的链表。一旦我们从<strong class="kw iu">头开始遍历，</strong>我们只能移动到下一个节点，直到列表的末尾(<em class="ns"> null </em>)</p><p id="c30a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">真实案例:</strong>顺畅简单的物流流程:打包- &gt;取货/卸货- &gt;送至分拣中心- &gt;发货</p><p id="58f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">链表必须至少支持以下操作:</p><ol class=""><li id="eb0d" class="mj mk it kw b kx ky la lb ld ml lh mm ll mn lp mo mp mq mr bi translated"><code class="fe ms mt mu mv b">add</code> —将节点添加到列表的末尾</li><li id="6a8b" class="mj mk it kw b kx mw la mx ld my lh mz ll na lp mo mp mq mr bi translated"><code class="fe ms mt mu mv b">addAt</code> —将节点添加到列表中的特定索引</li><li id="f912" class="mj mk it kw b kx mw la mx ld my lh mz ll na lp mo mp mq mr bi translated"><code class="fe ms mt mu mv b">removeFrom</code> —从列表中的特定索引中删除节点，并返回该元素</li><li id="cb5c" class="mj mk it kw b kx mw la mx ld my lh mz ll na lp mo mp mq mr bi translated"><code class="fe ms mt mu mv b">indexOf</code> —检查列表中节点的索引</li></ol><p id="58a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实施:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="e363" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">4.哈希表</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/4f5f715f173989785cee842d56c9a7a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*-FhtfxBGNI6rOTrb2RippA.png"/></div></figure><p id="4608" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">哈希表是一种可以将键映射到值的数据结构。哈希表相对于其他数据结构的主要优势是速度。访问一个元素的平均时间复杂度是O(1)。面临哈希冲突是很常见的，这意味着当哈希函数为多个键生成相同的索引时，就会有冲突。</p><p id="e8ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">现实世界的例子:</strong>在一个传统的(没有现代技术支持的)诊所里，接待处有一个鸽笼状的柜子，上面有从A到z标记的26个条目，接待员只需要寻找病人姓氏的第一个字母，她就可以得到病人的病历。<em class="ns">参考自</em><a class="ae nu" href="https://stackoverflow.com/a/9082597/6820538" rel="noopener ugc nofollow" target="_blank"><em class="ns">stack overflow</em></a></p><p id="cd86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">哈希表必须至少支持以下操作:</p><ol class=""><li id="4435" class="mj mk it kw b kx ky la lb ld ml lh mm ll mn lp mo mp mq mr bi translated"><code class="fe ms mt mu mv b">add</code> —将键值对添加到哈希表中</li><li id="ff5d" class="mj mk it kw b kx mw la mx ld my lh mz ll na lp mo mp mq mr bi translated"><code class="fe ms mt mu mv b">remove</code> —通过键从哈希表中删除一个值并返回该值</li><li id="f45b" class="mj mk it kw b kx mw la mx ld my lh mz ll na lp mo mp mq mr bi translated"><code class="fe ms mt mu mv b">search</code> —通过关键字搜索值</li></ol><p id="c4ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实施:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="b09b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读！</p></div></div>    
</body>
</html>