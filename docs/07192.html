<html>
<head>
<title>How to Create Telegram Bot in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python创建电报机器人</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-telegram-bot-in-python-cccc4babcc30?source=collection_archive---------2-----------------------#2020-12-16">https://betterprogramming.pub/how-to-create-telegram-bot-in-python-cccc4babcc30?source=collection_archive---------2-----------------------#2020-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="43f7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本地部署处理私有和组消息的bot的分步指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5520791f232acd5b87754a1bcdb932e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TJMlSskm4YqOhY2WDz5UkA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@christianw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Christian Wiediger </a>在<a class="ae ky" href="https://unsplash.com/s/photos/telegram?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天的主题是在Telegram中设置您自己的bot，并通过一种称为轮询的方法在本地部署它。这意味着你可以在你的服务器上开发和测试你的机器人，只要它连接到互联网。<code class="fe lv lw lx ly b">https</code>不是必需的，它允许你立即启动你的项目。通过用<code class="fe lv lw lx ly b">https</code>配置您的服务器并通过webhook将它链接到Telegram，您可以随时扩展您的项目。</p><p id="ba81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，您将学习:</p><ul class=""><li id="160f" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">处理来自用户的不同类型的传入消息</li><li id="433c" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">直接向用户发送消息</li><li id="40a0" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">处理私人和群组消息</li></ul><p id="8425" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在撰写本文时，Telegram Bot API有几个不同的Python包和接口。在本教程中，我将使用一个名为<a class="ae ky" href="https://github.com/eternnoir/pyTelegramBotAPI" rel="noopener ugc nofollow" target="_blank"> pyTelegramBotAPI </a>的Python包。根据官方文件，它是:</p><blockquote class="mn mo mp"><p id="b2d1" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">“…电报机器人API的简单但可扩展的Python实现。”</p></blockquote><p id="be30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们进入第一部分，开始安装必要的模块。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="20a3" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">1.设置</h1><p id="a9c0" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">确保你已经在手机上安装了Telegram。我们将通过与<code class="fe lv lw lx ly b">BotFather</code>机器人交互，直接在Telegram中创建我们的机器人。这是Telegram为方便bot创建而创建的官方bot。</p><h2 id="e9ba" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">搜索僵尸父亲</h2><p id="216b" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">在手机上打开Telegram，点击主界面右上方的搜索按钮。然后，在搜索栏中输入<code class="fe lv lw lx ly b">botfather</code>。您应该会看到下面的用户界面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/ddc37191cd00283cfb6113cdbb116dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*CsDfNqpU4VIHKlcWrkGEPw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单击旁边有蓝色勾号图标的第一个选项。图标代表<code class="fe lv lw lx ly b">VerifiedBadge</code>，表示经过电报认可的机器人或信誉良好的公司或个人。您应该会看到以下用户界面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/a9ff0dd78d97ee66a002a6f6bd1ab2b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*d-d_9no_ftfBjFrfRNpTcA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="f00f" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">与僵尸父亲互动</h2><p id="69ae" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">点击<code class="fe lv lw lx ly b">Start</code>按钮，您应该会看到一个可以用来与<code class="fe lv lw lx ly b">BotFather</code>交互的命令列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/7e70343b668b1f5065c1bb6706874bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*bg-VtbvURRV6oNHuVwoKPA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="37bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向<code class="fe lv lw lx ly b">BotFather</code>发送以下消息。</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="c468" class="ny nc it ly b gy oq or l os ot">/newbot</span></pre><p id="02ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会看到以下提示，询问您的机器人的名称和用户名。</p><ul class=""><li id="a2d9" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">name</code>:你的机器人的显示名称。</li><li id="319e" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">username</code>:电报中所有机器人的唯一标识符。您不能使用系统中已经存在的名称。另外，它必须以bot post-fix结束。比如<code class="fe lv lw lx ly b">TetrisBot</code>，或者<code class="fe lv lw lx ly b">tetris_bot</code>。</li></ul><p id="d39f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我通常对<code class="fe lv lw lx ly b">name</code>和<code class="fe lv lw lx ly b">username</code>使用相同的字符串。将为您生成一个新的令牌来访问HTTP API。确保它的安全，以防止其他人使用它来控制你的机器人。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/f85575637cd50e520ddfa289eff16a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*_6pZkvqrCIX0q-Zahm_xNA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="acb4" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">群聊中的隐私</h2><p id="08cf" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">如果你打算在一个电报组中使用你的机器人，你需要了解隐私在电报中是如何工作的。默认情况下，机器人不会接收群聊中的所有消息。根据官方文件，它将只收到:</p><ul class=""><li id="4c9e" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">以斜杠<code class="fe lv lw lx ly b">/</code>符号开始的命令消息(如<code class="fe lv lw lx ly b">/help</code>)。</li><li id="0cd5" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">回复您的机器人发送的消息。</li><li id="d659" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">服务信息(从群组中添加或删除人员)。</li><li id="36ce" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">来自bot所属频道的消息。</li></ul><p id="46da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，Telegram建议使用命令来与机器人交互。在同一个组中有多个机器人的情况下，您可以在每个命令后面添加用户名以防止混淆。请注意，您需要在您的服务器中自己处理和处理它:</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="31b0" class="ny nc it ly b gy oq or l os ot">/help@your_bot_username</span></pre><p id="ccb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最新版本中，创建<a class="ae ky" href="https://core.telegram.org/bots/inline" rel="noopener ugc nofollow" target="_blank">内嵌机器人</a>时可以使用<code class="fe lv lw lx ly b">@</code>符号——用户可以通过内嵌查询与你的机器人进行交互，而无需发送消息。然而，一个主要的缺点是您将失去提供任何动态输入的灵活性，就像这样:</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="8e32" class="ny nc it ly b gy oq or l os ot">@your_bot_username check_phone_status 012345678</span></pre><h2 id="09be" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">配置bot以访问群聊中的所有消息</h2><p id="bcd2" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">您可能更喜欢使用旧的约定，即机器人只有在标记了<code class="fe lv lw lx ly b">@</code>符号时才会做出响应:</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="cd12" class="ny nc it ly b gy oq or l os ot">@your_bot_username hello there</span></pre><p id="a293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果是这样，您需要关闭群组隐私设置或将其设为管理员(不推荐)以允许其访问所有邮件。</p><p id="3954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，向<code class="fe lv lw lx ly b">BotFather</code>发送以下信息:</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="1565" class="ny nc it ly b gy oq or l os ot">/mybots</span></pre><p id="0cba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它会列出你所有的机器人。因为我只创建了一个机器人，所以只有一个选项可用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/56f7921a5a8f9b61c96c7dd057878ed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*2Q6lA5J8ZedGMY8n6itmzA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d0ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击想要的机器人，显示更多选项如下。点击<code class="fe lv lw lx ly b">Bot Settings</code>继续。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/6cdb9a2de69fcf42a37202cfe899d79f.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*Juhmzg6iD4jbyvld-jSZEA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="569f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会看到一些与该组相关的选项。点击<code class="fe lv lw lx ly b">Group Privacy</code>按钮。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/a9672d3f4ea528eb230ad316c1b1e496.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*dnEqZMib6C7ax2QF-IF1kw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c764" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击<code class="fe lv lw lx ly b">Turn off</code>按钮，禁用群组隐私设置。您的机器人现在可以访问群聊中发送的消息。如果您的bot已经在一个组中，新的更改可能不会被反映或传播。如果您遇到问题，只需将其从群中删除，然后重新添加到群中。</p><h2 id="9f5d" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">将机器人添加到群聊</h2><p id="4cbe" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">有很多方法可以将机器人添加到群聊中。最简单的方法是直接从电报上做。搜索你的机器人，点击<code class="fe lv lw lx ly b">Start</code>按钮开始与它对话。接下来，单击位于顶部栏的bot的名称。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/6d1d46f4ad8578e6df30a294eaa776b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*pqO3Ojf4arVToeMmfPQBfA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="27e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会看到下面的界面。点击界面右上角的三点继续。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/1e34a34d6fbbc4e67c4acb37729b5911.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*1DoasPDc4khZQ2yCaopkOg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="463a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将出现一个弹出窗口，包含以下选项。轻触<code class="fe lv lw lx ly b">Add to group </code>选项。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/42d4e9ef8e9b86cdb647e36c818b63da.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*25lnMory2glcaAGEVQncwg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择所需的组并确认添加。回到群组并检查设置，以确保您的机器人可以访问群组消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/81a945cf992fda1ce78e5e821d66300b.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*uT5SQpbWTOdXrGACT1h-kg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="3c85" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">安装Python包</h2><p id="7f05" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">我们已经完成了电报设置，现在让我们安装本教程所需的Python包。在此之前，请确保您已经创建了一个虚拟环境。激活它，并在您的终端中运行以下命令。</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="64b1" class="ny nc it ly b gy oq or l os ot">pip install <!-- -->pyTelegramBotAPI</span></pre><p id="480b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过运行以下命令，您可以轻松验证是否已经安装了该软件包:</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="47c3" class="ny nc it ly b gy oq or l os ot">pip show pytelegrambotapi</span></pre><p id="6e13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下文本将输出到控制台:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/3db7f9d1754e6f0423bbc259f573250e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QuQ3Y-w5skWaFAdGS0jkYA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="aef8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成安装后，进入下一节，开始编写Python代码。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="1828" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">2.履行</h1><p id="ad12" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">在工作目录中创建新的Python文件。为简单起见，我准备将其命名为<code class="fe lv lw lx ly b">testbot.py</code>(相应修改名称)。</p><h2 id="7170" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">导入模块</h2><p id="072a" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">在文件顶部添加以下导入语句:</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="6a35" class="ny nc it ly b gy oq or l os ot">import telebot</span></pre><h2 id="02bd" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">实例化新实例</h2><p id="8406" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">通过传入我们之前创建的电报令牌来实例化一个新的<code class="fe lv lw lx ly b">TeleBot</code>实例:</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="3f39" class="ny nc it ly b gy oq or l os ot">bot = telebot.TeleBot("YOUR_TOKEN_HERE")</span></pre><h2 id="5063" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">格式化文本</h2><p id="a6ce" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">默认情况下，<code class="fe lv lw lx ly b">parse_mode</code>设置为<code class="fe lv lw lx ly b">None</code>，因此文本将按原样发送。如果您喜欢基本的格式特性——比如粗体、斜体和下划线——您可以在创建<code class="fe lv lw lx ly b">TeleBot</code>实例时指定。</p><ul class=""><li id="be92" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">HTML</code>:基于HTML的格式。</li><li id="de41" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">MarkdownV2</code>:基于降价的格式。</li></ul><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="ae84" class="ny nc it ly b gy oq or l os ot">bot = telebot.TeleBot("YOUR_TOKEN_HERE", parse_mode="MarkdownV2")</span></pre><p id="3e02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，您不能在邮件中同时使用这两种格式。在实例创建期间设置<code class="fe lv lw lx ly b">parse_mode</code>会将格式传播给所有返回的响应。如果需要发送不同格式的消息，建议在创建实例时将其设置为<code class="fe lv lw lx ly b">None</code>,并在发送单个消息时传递<code class="fe lv lw lx ly b">parse_mode</code>参数。</p><p id="927f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我使用默认的<code class="fe lv lw lx ly b">parse_mode</code> <code class="fe lv lw lx ly b">None</code>。请随意尝试。</p><h2 id="73a4" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">处理传入消息</h2><p id="c8a2" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">让我们创建一个新的消息处理程序，它代表一组传入消息的过滤器。如果消息通过了过滤器，它将使用原始消息作为参数调用修饰函数。在撰写本文时，它附带了以下过滤器:</p><ul class=""><li id="9a3b" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">commands</code>:如果<code class="fe lv lw lx ly b">message.content_type</code>为<code class="fe lv lw lx ly b">text</code>则返回<code class="fe lv lw lx ly b">True</code>，而<code class="fe lv lw lx ly b">message.text</code>:从预定义列表中出现的任何字符串开始。</li><li id="4c09" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">func</code>:基于<code class="fe lv lw lx ly b">lambda</code>函数返回的结果。</li><li id="82f3" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">content_types</code>:如果<code class="fe lv lw lx ly b">message.content_type</code>在预定义列表中，返回<code class="fe lv lw lx ly b">True</code>。</li><li id="0564" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">regexp</code>:如果<code class="fe lv lw lx ly b">message.content_type</code>为<code class="fe lv lw lx ly b">text</code>且<code class="fe lv lw lx ly b">re.search(regexp_args)</code>为<code class="fe lv lw lx ly b">True</code>则返回<code class="fe lv lw lx ly b">True</code>。</li></ul><p id="8657" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个简单的消息处理程序来处理<code class="fe lv lw lx ly b">/start</code>命令。当用户点击<code class="fe lv lw lx ly b">Start</code>按钮后第一次与机器人交互时，会自动调用<code class="fe lv lw lx ly b">/start</code>。命令是指以<code class="fe lv lw lx ly b">/</code>符号开头的消息。</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="e011" class="ny nc it ly b gy oq or l os ot">@bot.message_handler(commands=['start'])<br/>def handle_command(message):<br/>    bot.reply_to(message, "Hello, welcome to Telegram Bot!")</span></pre><p id="30c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续添加另一个消息处理程序，它使用代码下面的<code class="fe lv lw lx ly b">func</code>过滤器。您可以定义自己的lambda函数，在该函数中，当消息被传递给标准时，该修饰函数将处理消息。我将把return设置为<code class="fe lv lw lx ly b">True</code>,因为我想处理所有传入的消息。</p><p id="05f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，调用接受两个参数的<code class="fe lv lw lx ly b">reply_to</code>函数:</p><ul class=""><li id="85d5" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">一个代表消息的<code class="fe lv lw lx ly b">Message</code>对象。它包含了相当多的<a class="ae ky" href="https://core.telegram.org/bots/api#message" rel="noopener ugc nofollow" target="_blank">信息</a>，如<code class="fe lv lw lx ly b">message_id</code>、<code class="fe lv lw lx ly b">date</code>、<code class="fe lv lw lx ly b">text</code>等。您可以简单地传递输入消息变量。</li><li id="ab3d" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">一个字符串表示从bot返回的消息。</li></ul><p id="04de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将它设置为<code class="fe lv lw lx ly b">message.text</code>,将相同的文本回显给用户。</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="268f" class="ny nc it ly b gy oq or l os ot">@bot.message_handler(func=lambda message: True)<br/>def handle_all_message(message):<br/>    bot.reply_to(message, message.text)</span></pre><p id="0b4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，消息处理程序是根据它们的声明顺序进行测试的。机器人将从第一个匹配的消息处理程序返回响应。确保将具有高优先级的消息处理程序(如命令)放在最前面。</p><h2 id="5d0e" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">投票</h2><p id="ed4b" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">现在，让我们用下面的代码对我们的文件进行最后的润色:</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="8285" class="ny nc it ly b gy oq or l os ot">bot.polling()</span></pre><p id="36d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">polling</code>创建一个新线程，该线程调用一个内部函数来自动获取更新并将消息传递给消息处理程序。</p><p id="7181" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个阻塞函数，意味着它下面的代码不会被执行。确保将它放在文件的末尾。此外，不要多次调用它，否则会发生错误。如果你想扩展你的项目，用一个webhook代替。运行多个轮询服务器将不起作用！</p><p id="abb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">polling</code>函数接受以下参数:</p><ul class=""><li id="95d1" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">none_stop</code>:一个布尔值，确定发生错误时是否应该停止轮询。默认值为False。</li><li id="000a" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">interval</code>:整数表示轮询请求之间的间隔。默认情况下，它设置为0。将其设置为高于0的任何其他值都会影响响应时间</li><li id="4cd4" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">timeout</code>:长轮询超时，以秒为单位。默认值为20。</li></ul><p id="5fe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在下面的G <a class="ae ky" href="https://gist.github.com/wfng92/70ea1c307d67056fa1cf91335fe3fbb0" rel="noopener ugc nofollow" target="_blank"> ist </a>中找到完整的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pc pd l"/></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="9967" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">运行您的服务器</h1><p id="1726" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">确保终端现在指向Python文件所在的工作目录。确保您的机器已连接到互联网。运行以下命令启动轮询，根据需要修改名称:</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="dc35" class="ny nc it ly b gy oq or l os ot">python testbot.py</span></pre><p id="d5bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到Telegram，开始和你的机器人聊天。无论您何时私下发送消息，或者在您的机器人所属的群组中发送消息，您都应该会收到回复:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/a712d38551190ed713152806743114d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*9Wz9o8Xfduj6icJpM62G3g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="e874" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">区分私人信息和群组信息</h1><p id="5116" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">通过检查<code class="fe lv lw lx ly b">message.chat.type</code>变量，你可以很容易地区分私人信息和群组信息。可用选项如下:</p><ul class=""><li id="372f" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">私人的</li><li id="b605" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">组</li><li id="b179" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">超群</li><li id="2075" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">频道</li></ul><p id="633f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用以下控制流程修改<code class="fe lv lw lx ly b">handle_all_message</code>功能:</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="c4b1" class="ny nc it ly b gy oq or l os ot">@bot.message_handler(func=lambda message: True)<br/>def handle_all_message(message):<br/>    if message.chat.type == "private":<br/>        bot.reply_to(message, message.text)<br/>    elif message.chat.type == "group":<br/>        bot.reply_to(message, "Hello to all!")</span></pre><p id="5b1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次重新运行您的轮询服务，当向群组发送消息时，您应该会得到不同的响应。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="307c" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">仅在被标记时回复</h1><p id="5dc0" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">现在，我们有了一个新问题:如果你将它设置为管理员或者禁用了隐私设置，我们的机器人将对聊天中的每一条消息做出响应。为了解决这个问题，设置另一个条件来限制回复，如果<em class="mq">且仅当</em>消息中的机器人被标记。用您设置的用户名替换<code class="fe lv lw lx ly b">username_of_your_bot</code>:</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="9f5e" class="ny nc it ly b gy oq or l os ot">@bot.message_handler(func=lambda message: True)<br/>def handle_all_message(message):<br/>    if message.chat.type == "private":<br/>        bot.reply_to(message, message.text)<br/>    elif message.chat.type == "group":<br/>        if('@username_of_your_bot' in message.text):<br/>            bot.reply_to(message, "Hello to all!")</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="7410" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">处理其他内容类型</h1><p id="99e0" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">目前，我们的机器人只能回复短信。当用户发送文件或标签时，它将无法正常工作。您可以创建一个新的消息处理程序，并在列表中指定接受的<code class="fe lv lw lx ly b">content_types</code>。以下代码说明了如何将相同的标签回显给用户:</p><pre class="kj kk kl km gt om ly on oo aw op bi"><span id="0618" class="ny nc it ly b gy oq or l os ot">@bot.message_handler(content_types=['sticker'])<br/>def handle_sticker(message):<br/>    bot.send_sticker(message.chat.id, message.sticker.file_id)</span></pre><p id="46c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我使用的是<code class="fe lv lw lx ly b">send_sticker</code>功能，而不是<code class="fe lv lw lx ly b">reply_to</code>。这仅仅是因为<code class="fe lv lw lx ly b">reply_to</code>只是一个方便的内部调用<code class="fe lv lw lx ly b">send_message</code>的函数。查看<a class="ae ky" href="https://github.com/eternnoir/pyTelegramBotAPI#telebot" rel="noopener ugc nofollow" target="_blank">官方文档</a>中所有可用<code class="fe lv lw lx ly b">content_types</code>及其相应功能的完整列表。</p><p id="8ecb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重新运行您的服务器，当您向您的机器人发送标签时，您应该会看到类似这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/24ee18645664eed34a32f3f31cf33f6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*mihYd4Ug3lKf_Br-Im9Tqw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="d560" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">结论</h1><p id="88e3" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">祝贺您完成本教程！让我们回顾一下今天所学的内容。</p><p id="9fbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过与<code class="fe lv lw lx ly b">BotFather</code>互动，开始在Telegram中创建我们的机器人。我们还创建了一个新的虚拟环境，并在其中安装了<code class="fe lv lw lx ly b">pyTelegramBotAPI</code>包。</p><p id="e92d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在那之后，我们继续实例化一个新的<code class="fe lv lw lx ly b">TeleBot</code>实例，这个实例基于我们早期从bot创建中获得的令牌。我们实现了一些消息处理程序来处理命令和所有传入的消息。</p><p id="e599" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，我们还学会了区分私人信息和群组信息。我们可以通过在消息处理程序中指定accepted <code class="fe lv lw lx ly b">content_types</code>来轻松处理标签。</p><p id="b851" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，你应该能够在你的机器上本地创建你自己的电报机器人，只要它连接到互联网。</p><p id="af5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你阅读这篇文章——我希望在下一篇文章中再次见到你！</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="0c9e" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">参考</h1><ul class=""><li id="05e5" class="lz ma it lb b lc nt lf nu li pf lm pg lq ph lu me mf mg mh bi translated"><a class="ae ky" href="https://github.com/eternnoir/pyTelegramBotAPI" rel="noopener ugc nofollow" target="_blank">Github—pyTelegramBotAPI</a></li><li id="0cd4" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><a class="ae ky" href="https://core.telegram.org/bots/api" rel="noopener ugc nofollow" target="_blank">电报机器人API </a></li><li id="1436" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/37338101/how-to-add-a-bot-to-a-telegram-group" rel="noopener ugc nofollow" target="_blank"> StackOverflow —如何将机器人添加到电报组</a></li><li id="dad8" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/50204633/allow-bot-to-access-telegram-group-messages" rel="noopener ugc nofollow" target="_blank"> StackOverflow —允许bot访问电报组消息</a></li></ul></div></div>    
</body>
</html>