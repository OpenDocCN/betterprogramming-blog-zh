<html>
<head>
<title>How To Use Enums in Rails 6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Rails 6中使用枚举</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-enums-in-rails-6-87600e292476?source=collection_archive---------2-----------------------#2021-03-18">https://betterprogramming.pub/how-to-use-enums-in-rails-6-87600e292476?source=collection_archive---------2-----------------------#2021-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fb97" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">枚举是由一组命名值组成的数据类型。让我们利用它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6d76dbb37c6f58d90db962adf4256dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EM-rn8gybwWXKXehCFS_OA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如何在Ruby on Rails中使用枚举？作者照片。</p></figure><p id="57e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Ruby on Rails中，enum是一个属性，其中的值映射到数据库中的整数，并且可以通过名称进行查询。</p><p id="8145" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，我们可以为<code class="fe lu lv lw lx b">status</code>属性定义一个枚举，其中可能的值是<code class="fe lu lv lw lx b">pending</code>、<code class="fe lu lv lw lx b">active</code>或<code class="fe lu lv lw lx b">archived</code>。</p><p id="e421" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Ruby on Rails在Rails 4.1中增加了对枚举的支持。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="4dd9" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">Rails中枚举的基本用法</h1><p id="4419" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">向现有模型中添加一个枚举就像向该表中添加一个整数列一样简单。您可以使用以下bash命令生成新的迁移:</p><pre class="kj kk kl km gt nc lx nd ne aw nf bi"><span id="db54" class="ng mg it lx b gy nh ni l nj nk">$ bundle exec rails g migration AddStatusToUsers status:integers</span></pre><p id="903b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将生成以下迁移:</p><pre class="kj kk kl km gt nc lx nd ne aw nf bi"><span id="ecd2" class="ng mg it lx b gy nh ni l nj nk">class <!-- -->AddStatusToUsers<!-- --> &lt; <!-- -->ActiveRecord::Migration[6.0]<br/>  <!-- -->def change<br/>    add_column :users, :status, :integer, default: 0<br/>  end<br/>end</span></pre><p id="3bdd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe lu lv lw lx b">bundle exec rails db:migrate</code>运行迁移。在您的<code class="fe lu lv lw lx b">User</code> <strong class="la iu"> </strong>模型中，您需要将枚举定义为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c3b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想知道模型文件顶部的<em class="nn">模式信息</em>注释是怎么回事，那就是<code class="fe lu lv lw lx b">annotate</code> gem。看看这篇关于如何将<code class="fe lu lv lw lx b">annotate</code>与你的Rails应用集成的文章<a class="ae no" href="https://medium.com/the-side-hustler/how-to-use-the-annotate-gem-c44bfec97d03" rel="noopener">。</a></p><p id="5e0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，您可以使用所有提供的枚举助手了。让我们来看看其中的一些。</p><h2 id="644a" class="ng mg it bd mh np nq dn ml nr ns dp mp lh nt nu mr ll nv nw mt lp nx ny mv nz bi translated">平等检查</h2><p id="dd32" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">我们可以通过使用<code class="fe lu lv lw lx b">user.status == 'active'</code>或enum助手来检查用户是否“活跃”:</p><pre class="kj kk kl km gt nc lx nd ne aw nf bi"><span id="4d47" class="ng mg it lx b gy nh ni l nj nk">user.active? # Returns true if user.status == 'active'</span></pre><h2 id="8605" class="ng mg it bd mh np nq dn ml nr ns dp mp lh nt nu mr ll nv nw mt lp nx ny mv nz bi translated">更新枚举</h2><p id="28c3" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">Ruby on Rails还提供了一个助手来更新枚举值。代替<code class="fe lu lv lw lx b">user.update(status: :archived)</code>，我们可以使用:</p><pre class="kj kk kl km gt nc lx nd ne aw nf bi"><span id="2832" class="ng mg it lx b gy nh ni l nj nk">user.archived! # same as user.update(status: :archived)</span></pre><h2 id="530a" class="ng mg it bd mh np nq dn ml nr ns dp mp lh nt nu mr ll nv nw mt lp nx ny mv nz bi translated">领域</h2><p id="3f4c" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">我想谈的最后一个枚举助手是作用域的自动生成。常规的方法是使用一个<code class="fe lu lv lw lx b">where</code> <em class="nn"> </em>查询，就像<code class="fe lu lv lw lx b">User.where(status: 'active')</code>一样。使用enum助手，可以将该查询转换为:</p><pre class="kj kk kl km gt nc lx nd ne aw nf bi"><span id="db66" class="ng mg it lx b gy nh ni l nj nk">User.active</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="a14a" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">逮到你了</h1><h2 id="d481" class="ng mg it bd mh np nq dn ml nr ns dp mp lh nt nu mr ll nv nw mt lp nx ny mv nz bi translated">1.定义枚举时使用哈希而不是数组</h2><p id="d9ac" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">如果您决定使用数组定义(<code class="fe lu lv lw lx b">enum status: [:pending, :active, :archived]</code>)，那么更改枚举值的顺序将会破坏映射，因为您可能已经在<code class="fe lu lv lw lx b">user.status is 0</code>处存储了数据，这些数据曾经被映射到<code class="fe lu lv lw lx b">pending</code> <em class="nn"> </em>，但是现在可能映射到其他地方。</p><p id="9c69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了避免这个缺点，请将枚举声明为哈希。</p><h2 id="aa85" class="ng mg it bd mh np nq dn ml nr ns dp mp lh nt nu mr ll nv nw mt lp nx ny mv nz bi translated">2.在枚举定义中使用前缀或后缀</h2><p id="c3d9" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">默认的枚举行为可能导致不直观的范围(考虑<code class="fe lu lv lw lx b">User.active</code>)。建议定义<code class="fe lu lv lw lx b">_prefix</code>选项或<code class="fe lu lv lw lx b">_suffix</code>。我发现以下设置是最直观的:</p><pre class="kj kk kl km gt nc lx nd ne aw nf bi"><span id="344b" class="ng mg it lx b gy nh ni l nj nk">enum status: {<br/>    pending: 0,<br/>    active: 1,<br/>    archived: 2<br/>}, _prefix: true</span></pre><p id="607d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着所有的助手都将带有前缀<code class="fe lu lv lw lx b">status</code>:</p><pre class="kj kk kl km gt nc lx nd ne aw nf bi"><span id="dc7a" class="ng mg it lx b gy nh ni l nj nk">user.status_pending? # status == 'pending'</span><span id="2a94" class="ng mg it lx b gy oa ni l nj nk">user.status_active! # update(status: :active)</span><span id="213a" class="ng mg it lx b gy oa ni l nj nk">User.status_archived # User.where(status: :archived)</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="3a2b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Catalin ( <a class="ae no" href="https://twitter.com/cionescu1" rel="noopener ugc nofollow" target="_blank"> @cionescu1 </a>)是Ruby on Rails的顾问，是免费约会管理软件organisally<a class="ae no" href="https://www.organisely.app/" rel="noopener ugc nofollow" target="_blank">的创始人，也是</a><a class="ae no" href="https://medium.com/modern-rails/building-a-modern-crm-in-ruby-on-rails-part-1-3b62f7b4dc7d" rel="noopener">Modern Rails——在Ruby on Rails </a>中构建CRM的作者。</p></div></div>    
</body>
</html>