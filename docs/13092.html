<html>
<head>
<title>How to Use Pattern Matching in Elixir</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在仙丹中使用模式匹配</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-pattern-matching-in-elixir-426709bb179a?source=collection_archive---------9-----------------------#2022-07-27">https://betterprogramming.pub/how-to-use-pattern-matching-in-elixir-426709bb179a?source=collection_archive---------9-----------------------#2022-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b557" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解等号运算符实际上是如何工作的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/b3db9bc5aec013d612f6122956fe24c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uil8uJI8e47VOB2mHhU_RQ.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">摘自<a class="ae ku" href="https://elixir-lang.org/" rel="noopener ugc nofollow" target="_blank">https://elixir-lang.org/</a></p></figure><p id="d682" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是我喜欢长生不老药的原因之一；这是我每天都在使用的非常强大的特性之一，但当我使用Python或其他编程语言时，我却怀念它。</p><p id="ec9d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">赋值运算符“=”是一个等价运算符。在Elixir中，我们让一个变量等于一个值，反之亦然。让我们看一个例子:给变量x赋值“hello”</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="3bac" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因此，我们可以对变量的值进行评估，使其返回原始值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="cc8e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当我们用“hello”之外的值对变量求值时，它会给我们一个MatchError错误。唯一可行的方法是变量在操作的左边。然而，这覆盖了我们的原始变量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/107739c2e592242c46bf74aa252680ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*rqKA4E6HDKqHctxkusN4tg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">MatchError错误。</p></figure><h1 id="7fda" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">通过模式匹配解构数据结构</h1><p id="85e1" class="pw-post-body-paragraph kv kw it kx b ky mm ju la lb mn jx ld le mo lg lh li mp lk ll lm mq lo lp lq im bi translated">之前我们讨论了几种数据结构，元组。我们说过它们类似于列表，但是它们在内存中的存储方式不同。结构的类型是非常重要的谈论数据分解与模式匹配。我们很快就会看到。首先，让我们看一个元组析构的例子。</p><p id="bb92" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们的元组中有三个元素，我们可以用一种非常简单的方式为每个元素初始化一个变量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="0d6b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因此，在<code class="fe mr ms mt mu b">x</code>中，我们有<code class="fe mr ms mt mu b">atom :hello</code>，在<code class="fe mr ms mt mu b">y</code>中有<code class="fe mr ms mt mu b">atom :world</code>，以此类推。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/424f70cb8decebd628355456d4bff632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gyPf6mreBi1WCODCJ17fyw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">模式匹配的结果</p></figure><p id="8885" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是通过将变量的数量与值的数量相匹配来实现的。如果我们的值比变量少，我们将得到一个MatchError错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi na"><img src="../Images/e0220c96840220761fb085fb79835bae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTphe37sB8mzJlAvKSiyUQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">由于模式匹配不匹配而导致的匹配错误</p></figure><p id="4ee4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当结构的类型不同时，我们不能以这种方式分配变量，例如，比较元组和列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nb"><img src="../Images/ca257cc710a16860689ee3f56069a082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nb0EvQUSat1NFBDXRNVPpA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">由于模式匹配不匹配而导致的匹配错误</p></figure><p id="3a25" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">很多时候，在Phoenix中，作为操作的结果，我们有一个元组，其中第一个值是一个原子<code class="fe mr ms mt mu b">type :ok</code>(或<code class="fe mr ms mt mu b">:error</code>)，第二个值是结果(或错误的原因)，这些原子必须在<code class="fe mr ms mt mu b">=</code>操作符的两边匹配。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nc"><img src="../Images/03713c4c3b50c31c8975ec6aaf281d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_BfZPC64_g_fLVih_xK7A.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">MatchError由于模式匹配和评估结果不匹配而导致的错误。</p></figure><p id="9484" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于列表的析构，我们可以用一种类似的非常简单的方式提取第一个元素(或最后一个元素):将一个名为<code class="fe mr ms mt mu b">head</code>的变量赋给第一个元素，然后放置操作符<code class="fe mr ms mt mu b">|</code>，并将一个变量放在列表其余元素所在的位置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nd"><img src="../Images/4a61e67b174e0b3eeacdac04e5ecb497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UVfDYv_gD1jSJpg3j61HBQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">评估结果</p></figure><p id="f0c7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以析构几个元素，不仅仅是第一个。让我们看一个提取前两个元素的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi ne"><img src="../Images/d6b39ed249b4b55329f86c74025d6d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KomEw4vrilIh1b1OouwEgw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">评估结果</p></figure><p id="ee18" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">不能将空列表赋给两个变量，因为没有匹配的元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nf"><img src="../Images/0ec7175c1168c70207623703ec4109f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yP_Dadm-W3DoXDZXCSIawQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">MatchError错误。</p></figure><p id="f747" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这也是函数<code class="fe mr ms mt mu b">hd/1</code>(或<code class="fe mr ms mt mu b">tl/1</code>)不能处理空列表的原因。在函数的情况下返回一个类型为<code class="fe mr ms mt mu b">ArgumentError</code>的错误，或者像前面的情况一样返回一个匹配错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi ng"><img src="../Images/ae560a87d74c1bfb8acdf0cc40186b19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwcD_m5jR60InNbK7tgBtw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">ArgumentError消息</p></figure><h1 id="5fce" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">带有模式匹配的列表连接</h1><p id="6ca3" class="pw-post-body-paragraph kv kw it kx b ky mm ju la lb mn jx ld le mo lg lh li mp lk ll lm mq lo lp lq im bi translated">假设我们有一个列表，我们想在它的开头添加一个元素。我们可以做的是在列表之间使用<code class="fe mr ms mt mu b">++</code>操作符。但是，我们也可以为此使用模式匹配。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="c12e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">或者，如我所说，使用<code class="fe mr ms mt mu b">++</code>操作符。然而，我们必须把我们的元素放到一个新的列表中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><h1 id="5806" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">Pin ^算子</h1><p id="5404" class="pw-post-body-paragraph kv kw it kx b ky mm ju la lb mn jx ld le mo lg lh li mp lk ll lm mq lo lp lq im bi translated">可以重新分配或覆盖Elixir中的变量。有时候，这不是我们想要的；有时候，我们想要的是做一个模式匹配。让我们用本帖开头的例子看得更清楚。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="5086" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们想知道<code class="fe mr ms mt mu b">x</code>是否等同于另一个值，我们将不得不使用pin操作符。这样就可以匹配而不是重新分配。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nh"><img src="../Images/8ff55db26fabe068cd512b7bcd872da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xMwu0o8GAnr2t9KwbbXdTA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">MatchError错误。</p></figure><p id="a2b9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当我们已经有了一个初始化的变量，并且我们想知道一个操作的结果是否有那个值来给操作的其余部分分配一个新的变量时，这是非常有用的。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="64e4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因为有一个匹配，现在我们在变量<code class="fe mr ms mt mu b">x</code>中有了字符串“这是另一个操作的结果。”如果没有匹配，我们得到一个MatchError类型的错误，并且我们的变量<code class="fe mr ms mt mu b">x</code>没有被赋值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi ni"><img src="../Images/7da37d0724e791e788aa0bf846c2ce6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hrutNrhazx4TpGhk4VAYnw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">MatchError错误。</p></figure><p id="77df" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是因为我们在比较<code class="fe mr ms mt mu b">:yes_it_is</code>和<code class="fe mr ms mt mu b">:nope</code>原子，但它们并不相同。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/45fd4c52d33edd18c5ca6eec1b3f142a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*voc3ewj7kOWaMbQGQQwQ1A.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">MatchError错误。</p></figure><h1 id="d3f5" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">未使用的变量</h1><p id="47f2" class="pw-post-body-paragraph kv kw it kx b ky mm ju la lb mn jx ld le mo lg lh li mp lk ll lm mq lo lp lq im bi translated">我们通常对将运算结果保存在变量中不感兴趣。然而，由于结果返回的元素数量，我们必须放置一个变量，以便模式匹配正确工作。</p><p id="8b45" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为此，我们使用<code class="fe mr ms mt mu b">_</code>来表示一个在模式中被忽略的值。让我们看一个前面代码的例子。</p><p id="c8f3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们不想使用给我们赋值的右边的字符串，我们仍然必须放置一个变量来使模式匹配工作。以下内容不起作用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nj"><img src="../Images/b3981b1b03faee58bcc1fdb84da94a3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x4UKisNcTZBlQLOJZ9wqEA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">MatchError错误。</p></figure><p id="128a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因此，我们决定将其放置如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nk"><img src="../Images/227a1daea652c5d87558b5ef863dfc4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jxBngBGRFGWbz6vqzVnhiw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">评估结果</p></figure><h1 id="a9ce" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="30fe" class="pw-post-body-paragraph kv kw it kx b ky mm ju la lb mn jx ld le mo lg lh li mp lk ll lm mq lo lp lq im bi translated">正如您所看到的，模式匹配是提取信息的一个非常好的工具。它提供了多功能性，在我看来，这样工作要快得多。如果你懂JS，你肯定会熟悉这种声明变量的方式。</p><p id="9af1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在下一篇文章中，我们将看到Elixir中不同的控制结构以及它们与模式匹配的关系。</p><p id="185d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这里是这个系列的第一部分的链接。</p><h1 id="c4d5" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">参考</h1><div class="nl nm gp gr nn no"><a href="https://elixir-lang.org/getting-started/pattern-matching.html" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">模式匹配</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">从本章开始，我们将展示Elixir中的=操作符实际上是一个匹配操作符，以及如何使用…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">elixir-lang.org</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ko no"/></div></div></a></div></div></div>    
</body>
</html>