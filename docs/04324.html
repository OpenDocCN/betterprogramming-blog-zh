<html>
<head>
<title>Lambda SQS Triggers and Concurrency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">λSQS触发器和并发</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lambda-sqs-trigger-and-concurrency-87131dad9a12?source=collection_archive---------8-----------------------#2020-04-06">https://betterprogramming.pub/lambda-sqs-trigger-and-concurrency-87131dad9a12?source=collection_archive---------8-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1c2a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">重温λSQS触发器的极限</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3c6e54cd2b2a18b6601796e3efe2255a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1el5PKmZB2z5kX8S"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿诺·弗朗西斯卡在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="04c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AWS提供了用SQS队列中的传入事件触发lambda函数的能力。Lambda轮询消息队列，并同步调用您的函数。Lambda成批地挑选这些消息，并将它们作为输入传递给一个函数。当函数成功处理批处理时，它会从队列中删除事件。</p><p id="28aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在处理消息时出现错误，消息在<a class="ae ky" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html" rel="noopener ugc nofollow" target="_blank">可见性超时</a>后再次出现在队列中，并且如果错误继续出现，最终可以落在<a class="ae ky" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html" rel="noopener ugc nofollow" target="_blank">死信队列</a>中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3505" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">问题出在哪里？</h1><p id="3a2b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当启用SQS触发器时，Lambda开始对五个并行连接进行长轮询。每个连接从SQS队列中挑选一批消息，并将其传递给lambda函数。如果队列中还有消息，Lambda每分钟会增加60个以上的轮询过程。实例的最大数量可以达到1000个。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/a7d289b99fab3f0c252f42063557b82e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*yJu8nJzUP6g1lSq75NzeNA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">与<a class="ae ky" href="http://draw.io/" rel="noopener ugc nofollow" target="_blank">http://draw.io/</a>合影。</p></figure><p id="b9ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是这种轮询实例的扩展与您的lambda函数并发性没有直接联系。因此，如果您的lambda函数随着轮询实例的增加而达到其并发限制，并且无法处理传入的请求，它将节流消息。在可见性超时之后，被抑制的消息将返回到队列中，并最终在<a class="ae ky" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html" rel="noopener ugc nofollow" target="_blank">死信队列</a>中结束。当Lambda的并发性设置为1到30这样的低值时，很可能会出现这个问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eefc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">重现问题</h1><p id="e203" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了更好地理解它，我做了一个小的概念验证，其中我创建了一个并发设置为5的lambda。我的lambda的任务是接受一个输入，然后休眠五秒钟。下面是lambda函数的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="1a8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在Lambda上启用了事件源映射，SQS的批处理大小为1，重驱动限制为3。因此，如果一条消息被扼制三次以上，它将到达DLQ。</p><p id="5899" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在SQS添加大约2000条消息的流量突发时，我观察了性能。死信队列中大约有52条信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/5810e8b59bd8cc11ab2a2332abb3b819.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCsrC5wPYwagNhKor2LfEQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自AWS控制台的照片。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bfbc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">你该怎么办？</h1><p id="520f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">不幸的是，这没有直接的配置。然而，AWS的以下<a class="ae ky" href="https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-queueconfig" rel="noopener ugc nofollow" target="_blank">建议</a>可以帮助降低这种情况发生的可能性:</p><ol class=""><li id="8399" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">将SQS的可见性超时设置为至少是lambda函数执行时间的六倍。额外的时间允许Lambda重试，如果你的函数在处理前一个批处理时执行受阻。</li><li id="b0ae" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">将队列的重新驱动策略上的<code class="fe nr ns nt nu b">maxReceiveCount</code>至少设置为5。<br/>这将使消息在发送到死信队列之前有更好的处理机会。</li><li id="e882" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">配置死信队列以保留失败的消息，以便您可以在以后重新驱动这些消息。</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ece0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="da5f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>