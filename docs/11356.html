<html>
<head>
<title>Using Serializer With Your Ruby on Rails API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Ruby on Rails API中使用序列化程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-serializer-with-your-ruby-on-rails-api-e76795f4b3ad?source=collection_archive---------8-----------------------#2022-03-11">https://betterprogramming.pub/using-serializer-with-your-ruby-on-rails-api-e76795f4b3ad?source=collection_archive---------8-----------------------#2022-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3801" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">定制您的JSON</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d71b6e31ff730fccba04692eec5df189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0wTPCyT-Oq2bT_2RX0C_Q.jpeg"/></div></div></figure><p id="44d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在过去的三周里，我一直在直接使用Ruby on Rails学习创建全栈应用程序的过程。今天我要写关于主动模型序列化器(AMS)的文章。</p><p id="e78d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Serializers本质上提供了一种简单的方法来定制控制器呈现JSON的方式。</p><p id="0780" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用AMS要做的第一件事就是把宝石加到<code class="fe ln lo lp lq b">gemfile</code>里。</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="4ba6" class="lv lw iq lq b gy lx ly l lz ma"># Gemfile<br/>#...<br/>gem 'active_model_serializers'</span></pre><p id="344f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之后，运行bundle install。该过程的下一步是添加活动模型序列化程序。在终端中，运行…</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="0030" class="lv lw iq lq b gy lx ly l lz ma">rails g serializer {serializer-name}</span></pre><p id="ad3f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将打开并创建另一个序列化程序。</p><p id="0e36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这之后，导航到app文件夹下的serializer文件夹将引导我们准确地到达我们需要的位置。</p><p id="0ece" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在假设我们创建了一个名为<code class="fe ln lo lp lq b">UserSerializer</code>的序列化器。</p><p id="bbbe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这可以在我们的用户控制器上使用，以获取特定的数据，而不是必须在以后组织它，我们现在就可以这样做。</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="bb23" class="lv lw iq lq b gy lx ly l lz ma">class UserSerializer &lt; ActiveModel::Serializer</span><span id="bba8" class="lv lw iq lq b gy mb ly l lz ma">attributes :id, :username, :password_digest, :is_admin<br/>belongs_to :profile<br/>has_many :comments</span><span id="45d9" class="lv lw iq lq b gy mb ly l lz ma">end</span></pre><p id="324b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它看起来会像这样。这里的属性本质上是我们想要包含的JSON的一部分。</p><p id="aaae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，Rails实际上足够聪明，能够认识到运行用户序列化程序和用户控制器将一起工作，所以没有必要将它们联系起来。多牛逼啊！？但是，当我们想要定制自己的序列化程序时，会发生什么呢？</p><p id="e30e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我来回答你这个问题。我们只需再次运行那个<code class="fe ln lo lp lq b">rails g serializer {custom-serializer-name}</code>，收集我们的属性，然后<em class="mc">然后</em>将序列化程序的名称添加到我们的控制器中，如下所示:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="d34d" class="lv lw iq lq b gy lx ly l lz ma"># app/controllers/movies_controller.rb</span><span id="7dbd" class="lv lw iq lq b gy mb ly l lz ma">def summary<br/>  movie = Movie.find(params[:id])<br/>  render json: movie, serializer: MovieSummarySerializer<br/>end</span></pre><p id="f75c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们试图组织数据时，这个小而简单的功能可以成为游戏规则的改变者。就在你认为这再有趣不过的时候，等着听关于嵌套序列化器的所有内容吧。</p><p id="83dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我的新兵训练营告诉我的那样，</p><blockquote class="md me mf"><p id="46cf" class="kr ks mc kt b ku kv jr kw kx ky ju kz mg lb lc ld mh lf lg lh mi lj lk ll lm ij bi translated">…我们了解到<code class="fe ln lo lp lq b">ActiveModel::Serializer</code> gem使我们能够定制我们想要的JSON呈现方式，而不会牺牲Rails的“约定优于配置”和关注点分离原则。</p></blockquote></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="6a11" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我真诚地希望你喜欢这篇技术博客，它详细介绍了我在Ruby on Rails中的更多努力。</p><p id="d00e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我的下一篇博文中，我将详细介绍我的下一个项目，一个基于新Elden Ring的视频游戏wiki。敬请期待，下次见！这里有一个简单的问题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/13607e44409c20753f7056573b7af581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cbvPp79jHklhVj3pgC4HFg.png"/></div></div></figure></div></div>    
</body>
</html>