<html>
<head>
<title>A Complete Guide to Generated Columns in MySQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MySQL中生成列的完整指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-complete-guide-to-generated-columns-in-mysql-90cfbdbeac64?source=collection_archive---------17-----------------------#2022-06-29">https://betterprogramming.pub/a-complete-guide-to-generated-columns-in-mysql-90cfbdbeac64?source=collection_archive---------17-----------------------#2022-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1a76" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让你的后端更快更简单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/039ead40d44f68c24ae72064dfb7913c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YNDW_S5RzHIONm--.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="fdcb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">MySQL生成的列是一个功能强大、易于使用的高级工具，适合任何想要向表中添加自动生成的数据的人——在本文中，我们将学习掌握它们所需的一切知识。</p><p id="d3fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生成的列允许您在不使用<code class="fe lu lv lw lx b">INSERT</code>和<code class="fe lu lv lw lx b">UPDATE</code>子句的情况下在表中存储自动生成的数据。这个有用的特性从版本5.7 开始就是MySQL <a class="ae ly" href="https://dev.mysql.com/doc/refman/5.7/en/mysql-nutshell.html" rel="noopener ugc nofollow" target="_blank">的一部分，它代表了触发器生成数据的另一种方法。此外，生成的列可以帮助您使查询更容易、更有效。</a></p><p id="917e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们学习掌握MySQL中生成的列所需要知道的一切。</p><h1 id="7cb7" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">什么是MySQL生成的列？</h1><p id="e34b" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">生成的列类似于普通列，但您不能手动更改其值。这是因为表达式定义了如何根据从同一行的其他列中读取的其他值来生成生成列的值。</p><p id="6e76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，生成的列在表的域内工作，它的定义不能包含<code class="fe lu lv lw lx b">JOIN</code>语句。</p><p id="be44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换句话说，您可以将生成的列视为一种视图，但仅限于列。注意，生成的列不同于SQL触发器，只有在使用语法如下的<code class="fe lu lv lw lx b"><a class="ae ly" href="https://dev.mysql.com/doc/refman/8.0/en/create-table-generated-columns.html" rel="noopener ugc nofollow" target="_blank">CREATE TABLE</a></code>或<a class="ae ly" href="https://dev.mysql.com/doc/refman/8.0/en/alter-table-generated-columns.html" rel="noopener ugc nofollow" target="_blank"> </a> <code class="fe lu lv lw lx b"><a class="ae ly" href="https://dev.mysql.com/doc/refman/8.0/en/alter-table-generated-columns.html" rel="noopener ugc nofollow" target="_blank">ALTER TABLE</a></code>语句时才能定义它们:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="71bd" class="na ma it lx b gy nb nc l nd ne">generate_column_name column_type [GENERATED ALWAYS] AS (generation_expression)<br/>[VIRTUAL | STORED] [NOT NULL | NULL]<br/>[UNIQUE [KEY]] [[PRIMARY] KEY][COMMENT '<em class="nf">string</em>']</span></pre><p id="5ce8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">AS (generated_column_expression)</code>子句指定您添加或更新到表中的列是一个生成的列。<code class="fe lu lv lw lx b">generation_expression</code>定义了MySQL将用来计算列值的表达式，它不能引用另一个生成的列或除当前表的列之外的任何内容。另外，请注意，生成表达式只能包含不可变的函数。</p><p id="5415" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，不能使用在生成的列表达式定义中返回当前日期的<code class="fe lu lv lw lx b"><a class="ae ly" href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_curdate" rel="noopener ugc nofollow" target="_blank">CURDATE()</a></code>函数，因为它是可变函数。</p><p id="bfbc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以在<code class="fe lu lv lw lx b">AS</code>前面加上<code class="fe lu lv lw lx b">GENERATED ALWAYS</code>关键字，以使生成的列更加明确，但这是可选的。然后，您可以指明生成的列的类型是<code class="fe lu lv lw lx b">VIRTUAL</code>还是<code class="fe lu lv lw lx b">STORED</code>。你将在下一章了解这两种类型的区别。默认情况下，如果查询中没有明确指定，MySQL会将生成的列标记为<code class="fe lu lv lw lx b">VIRTUAL</code>。</p><p id="48e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们看看在一个<code class="fe lu lv lw lx b">CREATE TABLE</code>查询中生成的列语法:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="9d6d" class="na ma it lx b gy nb nc l nd ne">CREATE TABLE users (<br/>id INT AUTO_INCREMENT PRIMARY KEY,<br/>email VARCHAR(100) NOT NULL,<br/>first_name VARCHAR(60) NOT NULL,<br/>last_name VARCHAR(60) NOT NULL,<br/>full_name varchar(120) GENERATED ALWAYS AS (CONCAT(first_name, ' ', last_name))<br/>);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ng"><img src="../Images/2cf118aa9848c937b298a0f917165143.png" data-original-src="https://miro.medium.com/v2/0*S8hg0r9z_8uQvYs2"/></div></figure><p id="31da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，<code class="fe lu lv lw lx b">full_name</code>列将自动存储<code class="fe lu lv lw lx b">first_name</code>和<code class="fe lu lv lw lx b">last_name</code>列的连接。</p><h1 id="2bdf" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">MySQL中存在哪些类型的生成列？</h1><p id="aac4" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">如前所述，您可以将生成的列定义为虚拟列或存储列。现在让我们仔细看看这两种类型。</p><h2 id="cfab" class="na ma it bd mb nh ni dn mf nj nk dp mj lh nl nm ml ll nn no mn lp np nq mp nr bi translated">虚拟生成的列</h2><p id="42d9" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">MySQL不存储标记为虚拟的生成列。这意味着MySQL会在需要时动态评估其价值。这通常在任何<code class="fe lu lv lw lx b">BEFORE</code>查询被触发后立即发生。换句话说，虚拟生成的列不占用存储空间。</p><h2 id="9b3c" class="na ma it bd mb nh ni dn mf nj nk dp mj lh nl nm ml ll nn no mn lp np nq mp nr bi translated">存储生成的列</h2><p id="2ec4" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">MySQL存储任何标记为已存储的生成列。这意味着每当您插入或更新一行时，MySQL负责评估它的值并将其存储在磁盘上。换句话说，存储列需要存储空间，就像普通列一样。</p><h1 id="3142" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">虚拟生成的列与存储生成的列</h1><p id="24d1" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">现在让我们进一步了解虚拟列和存储生成列的优缺点。</p><h2 id="5097" class="na ma it bd mb nh ni dn mf nj nk dp mj lh nl nm ml ll nn no mn lp np nq mp nr bi translated">虚拟生成的列</h2><p id="df6b" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">赞成的意见</p><ul class=""><li id="34a9" class="ns nt it la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated">它们的创建是即时的，因为MySQL只需改变<a class="ae ly" href="https://dev.mysql.com/doc/refman/8.0/en/information-schema.html" rel="noopener ugc nofollow" target="_blank">表元数据。</a></li><li id="9f91" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">它们不需要磁盘空间。</li><li id="00f1" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated"><code class="fe lu lv lw lx b">INSERT</code>和<code class="fe lu lv lw lx b">UPDATE</code>查询没有开销，因为MySQL不需要生成它们。</li></ul><p id="d5c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">骗局</p><ul class=""><li id="1a27" class="ns nt it la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated">MySQL在读表时必须评估它们，这使得涉及它们的<code class="fe lu lv lw lx b">SELECT</code>查询变得更慢。</li></ul><h2 id="3456" class="na ma it bd mb nh ni dn mf nj nk dp mj lh nl nm ml ll nn no mn lp np nq mp nr bi translated">存储生成的列</h2><p id="397b" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">赞成的意见</p><ul class=""><li id="da2f" class="ns nt it la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated">MySQL可以读取它们，就像它们是普通的列一样，这保证了快速检索而没有开销。</li></ul><p id="7da0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">骗局</p><ul class=""><li id="ce93" class="ns nt it la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated">当添加到一个新表中时，MySQL必须重建整个表。</li><li id="1f1f" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated"><code class="fe lu lv lw lx b">INSERT</code>或<code class="fe lu lv lw lx b">UPDATE</code>会带来开销，因为MySQL必须生成它们。</li><li id="7aa7" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">它们需要磁盘空间。<br/>另外，请注意，您可以在一个表中混合虚拟列和存储列，它们都支持<a class="ae ly" href="https://arctype.com/blog/mysql-index-performance/" rel="noopener ugc nofollow" target="_blank"> MySQL索引</a>和二级索引。但是正如官方文档中的<a class="ae ly" href="https://dev.mysql.com/doc/refman/8.0/en/create-table-secondary-indexes.html#create-table-secondary-indexes" rel="noopener ugc nofollow" target="_blank">所解释的，虚拟列上的二级索引比存储生成的列占用更少的空间和内存。因此，对于二级索引，虚拟生成的列更有效。</a></li></ul><h1 id="4903" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">为什么采用生成的列？</h1><p id="77dd" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">采用生成列有几个原因，但下面三个是最重要的原因。</p><ul class=""><li id="281c" class="ns nt it la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated">它们为您提供了缓存功能，使您的查询速度更快:生成的列使您有可能定义包含有用数据的列，这样您就可以在需要时高效地检索它。</li><li id="31d5" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">它们允许您简化查询表达式:您可以将复杂性分散到生成的列中，然后在简单的过滤操作中使用它们，而不是使查询变得复杂。</li><li id="0681" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">它们使您能够定义函数索引:MySQL将<a class="ae ly" href="https://dev.mysql.com/doc/refman/8.0/en/create-index.html#create-index-functional-key-parts" rel="noopener ugc nofollow" target="_blank">函数索引</a>实现为隐藏的虚拟生成列。换句话说，生成的列使您有可能定义涉及MySQL函数的高效和高级索引。</li></ul><h1 id="cafe" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">MySQL生成的实际例子中的列</h1><p id="e92b" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">现在让我们看看一些例子中生成的列，这些例子来自我作为一个与数据驱动的初创公司合作的后端开发人员的经历。</p><h2 id="643d" class="na ma it bd mb nh ni dn mf nj nk dp mj lh nl nm ml ll nn no mn lp np nq mp nr bi translated">出于一致性原因，使用生成的列来连接列</h2><p id="973b" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">在开发应用程序的前端时，您可能会注意到数据表示中的某些模式。例如，在体育运动中，一个队中的运动员通常用以下格式来标识:</p><p id="4f2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nf">名[名_名_中间名。]姓氏[(球衣号码)] </em></p><p id="40a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，您可以通过将这四列与以下生成的列聚合来轻松生成该数据字段:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="bfd8" class="na ma it lx b gy nb nc l nd ne">string_identifier VARCHAR(255) GENERATED ALWAYS AS<br/>(CONCAT(first_name, ' ', IF(middle_name IS NULL, '', CONCAT(LEFT(middle_name, 1), '. ')), last_name, IF(jersey_number IS NULL, '', CONCAT(' (', jersey_number, ')'))))<br/>STORED</span></pre><p id="d0c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将产生:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="b276" class="na ma it lx b gy nb nc l nd ne">Cristiano Ronaldo (7)<br/>Lionel A. Messi (10)</span></pre><p id="627b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，生成的列使您能够直接在数据库级别标准化数据字段格式。此外，存储生成的列避免了每次需要时构建该字段的不可避免的开销。</p><h1 id="38b2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">使用生成的列来自动生成哈希id</h1><p id="8730" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">通常，您使用网站URL中的资源id或<a class="ae ly" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank">REST API</a>来检索您需要的数据。但是公开暴露你的身份会带来安全问题。当您发现自己使用自动增量id时尤其如此，自动增量id很容易预测，并使抓取或bot攻击更容易。</p><p id="76bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了避免这种情况，您可以考虑通过使用自动生成的、随机的、更安全的公共id来隐藏您的原始id。您可以通过散列您的id，使用虚拟生成的列来实现这一点，如下所示:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="be7f" class="na ma it lx b gy nb nc l nd ne">public_id VARCHAR(40) GENERATED ALWAYS AS  SHA1(CONCAT("PLAYER", id)) VIRTUAL</span></pre><p id="17c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，为了避免生成已知的哈希值，您可以用一个特殊的关键字连接您的id。点击了解更多关于MySQL加密和压缩功能的信息<a class="ae ly" href="https://dev.mysql.com/doc/refman/8.0/en/encryption-functions.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="b645" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">定义生成的列以简化数据筛选</h1><p id="f7d5" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">筛选数据时，有些列比其他列更有用。此外，您经常需要更改存储在列中的值的表示形式，以使筛选更简单或更直观。您可以定义一个有用的生成列，以所需的格式存储执行筛选所需的信息，而不是在每个筛选查询中都这样做。</p><p id="ad9b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，您可以定义一个生成的列，以便更容易地找到篮球队的队员，如下所示:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="de8b" class="na ma it lx b gy nb nc l nd ne">filter_string VARCHAR(255) GENERATED ALWAYS AS<br/>(CONCAT(first_name, ' ', last_name, IF(birthdate IS NULL, '', CONCAT(' ', DATE_FORMAT(birthdate, "%m-%d-%Y"))))<br/>STORED</span></pre><p id="8d1e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样的列将产生以下内容:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="66da" class="na ma it lx b gy nb nc l nd ne">LeBron James 12-30-1984<br/>Stephen Curry 03-14-1988</span></pre><p id="0e2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这包含数据有用的过滤和球员的出生日期在美国的格式。</p><h1 id="bd0e" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">生成的列与触发器</h1><p id="d941" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">如前所述，您只能在表中使用生成的列。此外，它们只能涉及不可变的函数，MySQL生成它们的值以响应<code class="fe lu lv lw lx b">INSERT</code>或<code class="fe lu lv lw lx b">UPDATE</code>查询。另一方面，<a class="ae ly" href="https://dev.mysql.com/doc/refman/8.0/en/trigger-syntax.html" rel="noopener ugc nofollow" target="_blank">触发器</a>是一个存储程序，每当与特定表相关的<code class="fe lu lv lw lx b">INSERT</code>、<code class="fe lu lv lw lx b">UPDATE</code>或<code class="fe lu lv lw lx b">DELETE</code>事件发生时，MySQL就会自动执行该程序。</p><p id="8348" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换句话说，触发器可以涉及几个表和所有MySQL函数。与生成的列相比，这使它们成为更完整的解决方案。同时，MySQL触发器本质上使用和定义起来更复杂，并且比生成的列更慢。</p><h1 id="1d14" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">最后的想法</h1><p id="32ef" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">MySQL生成的列无疑是一个很好的工具，可以服务于多种用途并带来多种好处。采用它们既简单又有效，尽管没有多少数据库开发人员使用它们。无论哪种方式，知道如何利用它们对于使你的后端应用程序更快、更干净、更简单来说都是必不可少的。</p><p id="9626" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望通过真实世界的例子解释生成列的用例，能够帮助您获得更多数据库领域的知识，直到下一次。</p></div></div>    
</body>
</html>