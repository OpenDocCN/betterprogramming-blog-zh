<html>
<head>
<title>Drag To Reorder Android RecyclerView Items Using Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin拖移以重新排序Android RecyclerView项目</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/drag-to-reorder-android-recyclerview-items-using-kotlin-afcaee1b7fb5?source=collection_archive---------3-----------------------#2021-02-01">https://betterprogramming.pub/drag-to-reorder-android-recyclerview-items-using-kotlin-afcaee1b7fb5?source=collection_archive---------3-----------------------#2021-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="87ee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在你的Android应用中创建漂亮的可定制列表</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/463e0832c8856bfc204ed284faa33119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pBc2uX-_cl0_60Rv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="433d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，您将学习如何实现<code class="fe lv lw lx ly b">RecyclerView</code>，它为您提供了重新排序项目的能力。我们将在不使用任何第三方库的情况下做到这一点。我们将使用<code class="fe lv lw lx ly b">RecyclerView</code>默认装饰器和一些接口来实现这一点。如果您感兴趣，底部嵌入了一个带有实现的GitHub repo链接。</p><p id="ca8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要再拖延了，让我们开始吧！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8be5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">介绍</h1><p id="bf4a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在Android中显示巨大列表的最好方式之一是通过<code class="fe lv lw lx ly b">RecyclerView</code>。如果你是一名Android开发者，你肯定用过它。我们有许多先进的功能，如视图持有人模式，丰富的动画，<code class="fe lv lw lx ly b">DiffUtil.Callback</code>以提高性能，等等。像WhatsApp和Gmail这样的应用程序使用<code class="fe lv lw lx ly b">RecyclerView</code>来显示无休止的对话。</p><p id="da1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多开发人员觉得实现起来很困难的一个特性是重新排序列表项。在过去，我们必须手动完成所有事情，从检测触摸到更新列表项。但是随着Android开发的改进，我们已经有了一些方便的实用程序，比如<code class="fe lv lw lx ly b">ItemTouchHelper</code>来帮助我们实现复杂的功能，比如在几个步骤中重新排序。</p><p id="bd56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">ItemTouchHelper</code>不过是从<code class="fe lv lw lx ly b">RecyclerView.ItemDecoration</code>扩展而来的简单类。这提供了多个回调，例如<code class="fe lv lw lx ly b">onMove</code>、<code class="fe lv lw lx ly b">onSwiped</code>、<code class="fe lv lw lx ly b">onSelectedChanged</code>、<code class="fe lv lw lx ly b">Clearview</code>等等。随着所有这些回调的及时使用，我们将在<code class="fe lv lw lx ly b">RecyclerView</code>中实现重新排序。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="39f1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">实现ItemTouchHelper</h1><p id="cac6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先，我们需要创建一个Kotlin类并用<code class="fe lv lw lx ly b">ItemTouchHelper.Callback</code>扩展它。然后我们覆盖<code class="fe lv lw lx ly b">getMovementFlags</code>、<code class="fe lv lw lx ly b">onMove</code>和<code class="fe lv lw lx ly b">onSwiped</code>功能，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2e10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">onSwipe</code>功能用于检测<code class="fe lv lw lx ly b">RecyclerView</code>项目滑动，现在不需要。</p><p id="dfca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们来看看另外两个函数:<code class="fe lv lw lx ly b">getMovementFlags</code>和<code class="fe lv lw lx ly b">onMove</code>。</p><p id="5e8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">getMovementFlags</code>是一个功能，通过它我们可以注册运动标志<em class="nf">到</em>到<code class="fe lv lw lx ly b">RecyclerView</code>项目。我们可以使用<code class="fe lv lw lx ly b">makeMovementFlags</code>功能注册<code class="fe lv lw lx ly b">swipe</code>和<code class="fe lv lw lx ly b">drag</code>标志。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1cb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我已经注册了<code class="fe lv lw lx ly b">swipe</code>和<code class="fe lv lw lx ly b">drag</code>。如果不想包含<code class="fe lv lw lx ly b">swipe</code>功能，那么将<code class="fe lv lw lx ly b">0</code>作为第二个参数传递。我们的目标是在垂直的<code class="fe lv lw lx ly b">RecyclerView</code>上实现一个重新排序的特性，所以我包含了<code class="fe lv lw lx ly b">UP</code>和<code class="fe lv lw lx ly b">DOWN</code> <code class="fe lv lw lx ly b">drag</code>标志。使用哪一个将根据列表的方向而改变。</p><p id="4da1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来是<code class="fe lv lw lx ly b">onMove</code>功能。当<code class="fe lv lw lx ly b">ItemTouchHelper</code>想要将拖动的项目从原来的位置移动到新的位置时执行。它有三个参数:</p><ul class=""><li id="22d4" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">@param recyclerView</code>—<code class="fe lv lw lx ly b">ItemTouchHelper</code>所连接的<code class="fe lv lw lx ly b">RecyclerView</code>。</li><li id="9363" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">@param viewHolder</code> —用户正在拖动的<code class="fe lv lw lx ly b">ViewHolder</code>。</li><li id="86c3" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">@param target </code>—<code class="fe lv lw lx ly b">ViewHolder</code>当前活动项目被拖动到其上。</li></ul><p id="6b02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">布尔型是函数的返回类型。如果你想让再订购发生，那么你需要通过<code class="fe lv lw lx ly b">true</code>。如果需要，我们可以通过传递<code class="fe lv lw lx ly b">false</code>将重新排序限制到特定的位置或视图类型。</p><p id="bffb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有需要在适配器中更新的源和目标<code class="fe lv lw lx ly b">ViewHolders</code>。现在我们需要在适配器和重新订购项目助手之间建立一个桥梁。为此，我们必须创建一个接口，并从适配器将它传递到item helper的构造函数中，以触发重新排序更新。看一下界面:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d04c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要将这个接口作为构造函数中的一个参数，如下所示:</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="92bf" class="ny mh it ly b gy nz oa l ob oc">class ReorderHelperCallback(<strong class="ly iu">val adapter : ItemTouchHelperAdapter</strong>) <br/>    : ItemTouchHelper.Callback() {</span></pre><p id="d767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用<code class="fe lv lw lx ly b">onMove</code>函数中的<code class="fe lv lw lx ly b">adapter</code>接口与实际的<code class="fe lv lw lx ly b">recyclerView</code>适配器进行通信:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5e30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我们已经基本完成了核心逻辑。默认情况下，长按<code class="fe lv lw lx ly b">RecyclerView</code>项将触发重新订购。但是如果您希望提供一个重新排序按钮来方便用户呢？我们能做到！</p><p id="d7c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要创建另一个接口，并将其命名为<code class="fe lv lw lx ly b">OnStartDragListener</code>。当一个视图被请求开始拖动时，它只有一个执行的函数。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="199a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个接口在<code class="fe lv lw lx ly b">ViewHolder</code>中用来触发移动，这将在本文的下一节中看到。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a58c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">再循环视图固定器</h1><p id="2d9e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先，我们需要实现一个通用的<code class="fe lv lw lx ly b">RecyclerView</code> holder。这里，我将使用<code class="fe lv lw lx ly b">ViewBinding</code>来引用布局中的视图。如果你是这方面的新手，请在继续之前阅读本文。</p><p id="b0a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看一个简单的<code class="fe lv lw lx ly b">ViewHolder</code>和<code class="fe lv lw lx ly b">ViewBinding</code>以及一个数据类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b43b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，但是如果您想从一个特定的视图中触发重新订购，我们需要从<code class="fe lv lw lx ly b">ViewHolder</code>中完成。为了调用<code class="fe lv lw lx ly b">drag</code>，我们创建了<code class="fe lv lw lx ly b">OnStartDragListener</code>接口。这里，我们需要通过一个<code class="fe lv lw lx ly b">ViewHolder</code>构造函数传递它的实例，并在该视图的触摸监听器内部调用<code class="fe lv lw lx ly b">onStartDrag</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="480c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">RecyclerView适配器</h1><p id="5f51" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">同样，我们需要实现一个简单的具有必要功能的<code class="fe lv lw lx ly b">RecyclerView</code>适配器(例如<code class="fe lv lw lx ly b">onCreateViewHolder</code>、<code class="fe lv lw lx ly b">onBindViewHolder</code>等等)。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="de74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经完成了基本功能，是时候实现重新排序功能了。我们已经创建了<code class="fe lv lw lx ly b">ItemTouchHelperAdapter</code>接口来监听一个项目何时被拖动足够远来触发移动。这将覆盖<code class="fe lv lw lx ly b">onItemMove</code>函数，其中我们将交换数组项并使用<code class="fe lv lw lx ly b">notifyItemMoved</code>函数更新UI。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9c5e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">实施重新排序</h1><p id="4ae3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最后，我们完成了<code class="fe lv lw lx ly b">ItemTouchHelper</code>、适配器、<code class="fe lv lw lx ly b">ViewHolder</code>和接口。是时候给<code class="fe lv lw lx ly b">RecyclerView</code>分配适配器了。为了创建重排序适配器的实例，我们需要<code class="fe lv lw lx ly b">OnStartDragListener</code>实例。我们只需要用<code class="fe lv lw lx ly b">OnStartDragListener</code>扩展Android组件(在本例中是<code class="fe lv lw lx ly b">activity</code>)并传递<code class="fe lv lw lx ly b">activity</code>上下文。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1dcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要创建一个<code class="fe lv lw lx ly b">ReorderHelperCallback</code>实例，并将其用作<code class="fe lv lw lx ly b">ItemTouchHelper</code>的回调，我们将把它附加到实际的<code class="fe lv lw lx ly b">RecyclerView</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f772" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已！你已经成功地实现了<code class="fe lv lw lx ly b">RecyclerView</code>在没有任何第三方库的情况下重新排序项目！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5702" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">奖金</h1><p id="7c48" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">要了解有关Android中的<code class="fe lv lw lx ly b">RecyclerView</code>适配器的更多信息，请阅读以下文章:</p><ul class=""><li id="d4f6" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><a class="ae ky" href="https://medium.com/android-dev-hacks/building-a-reactive-heterogeneous-adapter-in-kotlin-eed9487df29b" rel="noopener">在Kotlin中构建反应式&amp;异构适配器</a></li><li id="e0bf" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://medium.com/better-programming/evolution-of-adapters-in-android-2e2ff58c0f98" rel="noopener">Android中适配器的演变</a></li><li id="abbe" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://medium.com/better-programming/how-to-merge-adapters-sequentially-in-android-11914eac53d" rel="noopener">如何在Android中顺序合并适配器</a></li><li id="fa11" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://medium.com/better-programming/android-recyclerview-with-kotlin-sealed-classes-6d2985aac3e5" rel="noopener">Android recycler查看Kotlin密封类</a></li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="dfa6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">GitHub回购</h1><div class="od oe gp gr of og"><a href="https://github.com/SG-K/RecyclerviewWithBenefits#drag-and-reorder-recyclerview-items" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">SG-K/recyclerviewithsbenefits</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">这是一个演示应用程序，旨在为开发人员展示如何实现复杂的功能，如重新排序、滑动等…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><p id="d8b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读！</p></div></div>    
</body>
</html>