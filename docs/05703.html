<html>
<head>
<title>How to Create a Draggable Card in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在SwiftUI中创建可拖动卡</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-draggable-card-in-swiftui-86387397071d?source=collection_archive---------6-----------------------#2020-07-29">https://betterprogramming.pub/how-to-create-a-draggable-card-in-swiftui-86387397071d?source=collection_archive---------6-----------------------#2020-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="30e9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用拖动手势构建底部卡片视图</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4b43fad5ce1edb84907eb9e8cadd16ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tMa_0mpjq-VHrc--blbD-Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SwiftUI中的可拖动卡(作者拍摄)</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="7be0" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">卡片视图</h1><p id="cc46" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">首先，让我们开始我们的<code class="fe mt mu mv mw b">CardView</code>。对于教程，我只有一个带颜色和一些文字的<code class="fe mt mu mv mw b">ZStack</code>。要获得圆角边缘，您可以使用<code class="fe mt mu mv mw b">.cornerRadius(radius: CGFloat)</code>或<code class="fe mt mu mv mw b">.clipShape(shape: Shape)</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/3a9607dbab9bf0c14d9f5fbb705dab89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NAL3usKQKxy4jd0zC6OQ6Q.png"/></div></div></figure><p id="ec80" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">在我们的主视图中，我们将要显示我们的卡片，我们需要一个变量来偏移卡片的位置。下面，我把可变高度作为屏幕高度乘以0.9。这将使我们的视角偏移到屏幕底部的10%。你可以尝试其他值，因为10%在像iPhone 11 Pro Max这样的长屏幕中可能很小。</p><pre class="kj kk kl km gt nd mw ne nf aw ng bi"><span id="f018" class="nh lg it mw b gy ni nj l nk nl">@State <strong class="mw iu">private</strong> <strong class="mw iu">var</strong> offset = CGSize(width: 0, height: UIScreen.main.bounds.height * 0.9)</span></pre><p id="5a63" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">将我们的<code class="fe mt mu mv mw b">CardView</code>添加到主视图(<code class="fe mt mu mv mw b">ContentView</code>)，然后添加偏移和弹簧动画:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/a1617d23dc0615a7e007bd13180a84c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0byjIqHHrJznKC9sYcZdlg.png"/></div></div></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="4425" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated"><strong class="ak">拖拽手势</strong></h1><p id="f185" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">因为我们想要利用<code class="fe mt mu mv mw b">GeometryReader</code>值，所以避免在<code class="fe mt mu mv mw b">GeometryReader</code>之前声明<code class="fe mt mu mv mw b">DragGesture</code>的变量，如下面的代码所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="594e" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">取而代之的是下面的手势:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/8656a1102148ea6b5c0f37e8ba1af19c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xkRTjTc2gfeZaAHupKPbWg.png"/></div></div></figure><p id="a304" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">在<code class="fe mt mu mv mw b">.onChanged</code>，<em class="no"> </em>内，将偏移高度分配给手势平移高度。这将允许我们的卡上下拖动，而不是向两侧拖动:</p><pre class="kj kk kl km gt nd mw ne nf aw ng bi"><span id="f280" class="nh lg it mw b gy ni nj l nk nl"><strong class="mw iu">self</strong>.offset.height = gesture.translation.height</span></pre><p id="6a3d" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">在<code class="fe mt mu mv mw b">.onEnd</code>内部，使用<code class="fe mt mu mv mw b">GeometryReader</code>代理值检查手势平移是在视图的底部50%还是在视图的顶部50%。如果手势在底部50%，则通过将几何尺寸高度乘以0.15来偏移卡片以覆盖视图的85%。否则，通过将几何尺寸高度乘以0.9，使视图再次只覆盖10%，从而将视图返回到底部。</p><pre class="kj kk kl km gt nd mw ne nf aw ng bi"><span id="ba47" class="nh lg it mw b gy ni nj l nk nl"><strong class="mw iu">if</strong> $0.translation.height &lt; geometry.size.height * 0.5 {</span><span id="fa0e" class="nh lg it mw b gy np nj l nk nl"><strong class="mw iu">self</strong>.offset.height = geometry.size.height * 0.15</span><span id="672e" class="nh lg it mw b gy np nj l nk nl">} <strong class="mw iu">else</strong> {</span><span id="3f90" class="nh lg it mw b gy np nj l nk nl"><strong class="mw iu">self</strong>.offset.height = geometry.size.height * 0.9</span><span id="f02d" class="nh lg it mw b gy np nj l nk nl">}</span></pre><p id="4eae" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated"><code class="fe mt mu mv mw b">ContentView</code>的最终代码如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/d6af454331481564f0ea913e9a3b889f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-kHOSpX45HEZDwJPANUKQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/b5a6919befca38107271659ca9b6310e.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/1*lDvpSQYwDEwW33BnvGrvwg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡片起始位置在底部20%的代码示例</p></figure><p id="c034" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">您可以调整我们正在使用的偏移和平移高度值，以适合不同的形状。</p><p id="79d1" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">要将我们的<code class="fe mt mu mv mw b">CardView</code>改为圆形，我们可以使用<code class="fe mt mu mv mw b">.clipShape(Circle())</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/b634444caf9abaf8cefe30456f390e37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MTntM_pgH1JQLIPJKdrcrQ.png"/></div></div></figure><p id="bc16" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">这会让我们的<code class="fe mt mu mv mw b">CardView</code>因为我们的偏移而消失。调整偏移变量高度，使视图在底部40%而不是10%:</p><pre class="kj kk kl km gt nd mw ne nf aw ng bi"><span id="fa54" class="nh lg it mw b gy ni nj l nk nl">@State <strong class="mw iu">private</strong> <strong class="mw iu">var</strong> offset = CGSize(width: 0, height: UIScreen.main.bounds.height * 0.6)</span></pre><p id="ca44" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">现在，我们需要调整<code class="fe mt mu mv mw b">.onEnd</code>中的条件，将我们的卡片放在视图的底部。你可以使用我下面的值，让这个视图达到我们视图的前50%。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/95348d51aa1f9fa66875a048f6bff35e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0CyJb2bUXrB7m2CddEFK6A.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/82c204c04159fd29fb2b4e5329bf3ba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/1*bFBaji-4T9jVsY6CyYMR_A.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码示例—圆形卡片</p></figure><p id="d67b" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">全部完成！感谢阅读！</p></div></div>    
</body>
</html>