<html>
<head>
<title>Becoming Root With Wildcard Injections on Linux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Linux上通过通配符注入成为Root</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/becoming-root-with-wildcard-injections-on-linux-2dc94032abeb?source=collection_archive---------8-----------------------#2020-11-18">https://betterprogramming.pub/becoming-root-with-wildcard-injections-on-linux-2dc94032abeb?source=collection_archive---------8-----------------------#2020-11-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6652" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用通配符注入提升Linux权限</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f0aaaf0bb44ec8c21fccab5ab9ec77c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T1jSHphsnsJ5YPvm"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@_imkiran?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sai Kiran Anagani </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e5d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">欢迎回到Linux安全系列！在本系列中，我们将讨论影响Linux系统的安全问题以及导致这些问题的常见错误配置。我们开始吧！</p><p id="b919" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">权限提升是攻击者提升系统权限的一种方式。例如，假设一个攻击者已经获得了对您的web服务器的访问权，但只是作为一个低特权用户。他们不能读写敏感文件、执行脚本或更改系统配置。他们如何危害您的服务器并保持对服务器的访问？</p><p id="a14c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果他们可以找到一种方法来欺骗系统，使其认为自己是根用户，攻击者就可以进行更强大的攻击，如读写敏感文件和在系统中插入永久性后门。这就是特权升级的由来。今天，我们来谈谈攻击者如何利用通配符注入来提升他们的权限。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0afb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">通配符</strong></h1><p id="a0e3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通配符是一种特殊字符，在许多编程语言中代表所有的。在Linux命令行中，您可以使用通配符来引用目录中的所有文件。例如，该命令将删除当前目录中的所有文件。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c9ed" class="nf md it nb b gy ng nh l ni nj">$ rm *</span></pre><p id="9531" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您使用通配符执行命令时，它将扩展为包含该目录中所有匹配文件的命令。例如，如果当前目录包含三个名为<code class="fe nk nl nm nb b">file1</code>、<code class="fe nk nl nm nb b">file2</code>和<code class="fe nk nl nm nb b">file3</code>的文件，上述命令将展开为:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="348f" class="nf md it nb b gy ng nh l ni nj">$ rm file1 file2 file3</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fe37" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">通配符注入</strong></h1><p id="be64" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">那么，为什么这个功能会帮助攻击者实现权限提升呢？</p><p id="f950" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令通常有标志，提供关于程序应该如何运行的附加信息。例如，当执行<code class="fe nk nl nm nb b">ls</code>命令来列出目录内容时，可以指定<code class="fe nk nl nm nb b">-l</code>标志来指定程序应该以长格式显示文件信息。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="a971" class="nf md it nb b gy ng nh l ni nj">$ ls (This will display all filenames in the directory.)</span><span id="125a" class="nf md it nb b gy nn nh l ni nj">$ ls -l (This will display all filenames in the directory and additional information about each file.)</span></pre><p id="4ded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的问题是，如果使用通配符运行命令，并且目录中有一个文件的名称类似于标志名，则该命令可能会将该文件名误解为命令标志。例如，如果我们在一个名为<code class="fe nk nl nm nb b">-rf</code>的目录中运行<code class="fe nk nl nm nb b">rm</code>命令，该命令将扩展为这个命令，这将删除所有文件和子目录，而不仅仅是当前目录中的文件。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0d95" class="nf md it nb b gy ng nh l ni nj">$ rm -rf file1 file2 directory3</span></pre><p id="c3af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着，如果攻击者可以创建以命令标志命名的文件，他们就可以操纵其他用户命令的行为。当特权用户运行带有通配符的命令时，攻击者可以在他们的命令中插入危险的标志，从而导致意想不到的后果。例如，如果攻击者能够插入一个将执行系统命令的标志，他就可能以根用户的身份执行任意系统命令！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aeb7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Rsync通配符注入</h1><p id="8555" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们看看当根用户使用<code class="fe nk nl nm nb b">rsync</code>工具时，攻击者如何利用通配符注入。</p><p id="393a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nb b">rsync</code>是一个用于创建备份的Linux工具。它在机器和外部硬盘驱动器之间或通过网络传输和同步文件。这是<code class="fe nk nl nm nb b">rsync</code>最简单的用法，其中SRC是文件的源目录，DEST是您想要复制到的目的地。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4bad" class="nf md it nb b gy ng nh l ni nj"> $ rsync SRC DEST</span></pre><p id="4bdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nk nl nm nb b">rsync</code>命令行工具中，您可以使用<code class="fe nk nl nm nb b">-e</code>标志通过shell脚本运行任意命令。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9b78" class="nf md it nb b gy ng nh l ni nj">$ rsync -e sh PATH_TO_SCRIPT SRC DEST</span></pre><p id="f273" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着如果攻击者可以创建一个名为<code class="fe nk nl nm nb b">-e sh PATH_TO_SCRIPT</code>的文件，他们就可以注入另一个用户的<code class="fe nk nl nm nb b">rsync</code>命令，并让<code class="fe nk nl nm nb b">rsync</code>执行任何恶意脚本！例如，攻击者可以创建一个shell脚本，让我们成为根用户。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e354" class="nf md it nb b gy ng nh l ni nj">echo “vickie::0:0:System Administrator:/root/root:/bin/bash” &gt;&gt; /etc/passwd</span></pre><p id="8462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个脚本向<code class="fe nk nl nm nb b">/etc/passwd</code>文件添加了一个新的根用户。因为<code class="fe nk nl nm nb b">0</code>是root用户的UID，所以添加一个UID为<code class="fe nk nl nm nb b">0</code>的用户将赋予该用户root权限。该用户将拥有用户名“vickie”和一个空密码。</p><p id="27f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">普通用户通常不可能使用该命令，因为只有特权用户才能修改<code class="fe nk nl nm nb b">/etc/password</code>文件。但是让我们将shell脚本命名为<code class="fe nk nl nm nb b">script.sh</code>并保存它。然后我们可以创建一个文件名，将一个<code class="fe nk nl nm nb b">-e</code>标志注入到<code class="fe nk nl nm nb b">rsync</code>命令中。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ca38" class="nf md it nb b gy ng nh l ni nj">touch -- “-e sh shell.sh”</span></pre><p id="90ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果root用户在这个目录中使用通配符运行Rsync命令:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="78aa" class="nf md it nb b gy ng nh l ni nj">$ rsync * DEST</span></pre><p id="3777" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通配符将导致标志被注入到命令中，根用户将执行恶意的shell脚本并将我们添加为根用户。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="757e" class="nf md it nb b gy ng nh l ni nj">$ rsync -e sh shell.sh file1 file2 directory3 DEST</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3536" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">注意安全！</h1><p id="2ae9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在命令中使用通配符之前，您可以三思而行，以防止这种类型的攻击。而当需要使用通配符时，可以在通配符前面加上目录的完整路径，避免注入。例如，为了防止上面的<code class="fe nk nl nm nb b">rsync</code>攻击，您可以改为执行这个命令。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="16ef" class="nf md it nb b gy ng nh l ni nj">$ rsync /file/path/* DEST</span></pre><p id="a998" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将导致命令扩展到这个命令，破坏注入标志的语法。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="6728" class="nf md it nb b gy ng nh l ni nj">$ rsync /file/path/-e sh shell.sh /file/path/file1 /file/path/file2 /file/path/directory3</span></pre><p id="6a8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！下一次，我们将深入探讨攻击者可以用来危害您的系统的更多特权提升技术。</p></div></div>    
</body>
</html>