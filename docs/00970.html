<html>
<head>
<title>WebGL Enhanced Drag Slider Tutorial With curtains.js — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebGL增强的Drag Slider Tutorial With curtains . js—第3部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/webgl-enhanced-drag-slider-tutorial-with-curtains-js-part-3-4ea0791b4a54?source=collection_archive---------7-----------------------#2019-08-01">https://betterprogramming.pub/webgl-enhanced-drag-slider-tutorial-with-curtains-js-part-3-4ea0791b4a54?source=collection_archive---------7-----------------------#2019-08-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="607a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过移除任何布局重画调用来提高滑块的整体性能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/4be96d471e3ede5017613e07afbfe95d.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*Z_N7JlI5O4CZyeDJh-2O7A.gif"/></div></figure><p id="f383" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这篇文章是我们教程的第三部分，也是最后一部分。在第一部分中，我们创建了一个JavaScript拖动滑块。在<a class="ae lj" href="https://medium.com/better-programming/webgl-enhanced-drag-slider-tutorial-with-curtains-js-part-2-bf32aa5a15c0" rel="noopener">第二部</a>中，我们添加了<a class="ae lj" href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API" rel="noopener ugc nofollow" target="_blank"> WebGL </a>和<a class="ae lj" href="https://www.curtainsjs.com/" rel="noopener ugc nofollow" target="_blank"> curtains.js </a>来改善动画效果。如果你还没有这样做，请检查它们。</p><p id="3cb8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这最后一部分，我们将看到如何通过移除任何布局重画调用来提高滑块的整体性能。</p><p id="88fd" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是最后一支笔:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="56ad" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">作为提醒，我们使用了curtains.js来添加与WebGL相关的所有内容。</p><p id="ba53" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">curtains.js是一个开源的普通JavaScript库。它在这里特别有用，因为它的主要目的是用WebGL效果增强DOM元素。</p><p id="3d5e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">通过几行JavaScript，您能够创建WebGL纹理平面，绑定到我们的滑块项目的HTML元素，然后对整个场景进行后期处理。</p><p id="f976" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这样我们就可以看到使用窗帘的好处了。</p><ul class=""><li id="6170" class="lm ln iq kp b kq kr kt ku kw lo la lp le lq li lr ls lt lu bi translated">干净和搜索引擎友好的HTML代码。</li><li id="d2ae" class="lm ln iq kp b kq lv kt lw kw lx la ly le lz li lr ls lt lu bi translated">你不必担心你的WebGL对象的大小和位置，因为大多数东西(比如调整大小)将由库在幕后处理。</li><li id="d7d2" class="lm ln iq kp b kq lv kt lw kw lx la ly le lz li lr ls lt lu bi translated">在任何情况下，如果在WebGL初始化期间或在您的着色器中出现错误，滑块仍将工作！</li></ul></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="8fa9" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">布局重画调用/回流</h1><h2 id="bf69" class="mz mi iq bd mj na nb dn mn nc nd dp mr kw ne nf mt la ng nh mv le ni nj mx nk bi translated">总体概念</h2><p id="8c36" class="pw-post-body-paragraph kn ko iq kp b kq nl jr ks kt nm ju kv kw nn ky kz la no lc ld le np lg lh li ij bi translated">首先，你需要理解什么是布局重绘和回流，以及它们的原因。GitHub 上有一篇Paul Irish写的简洁的文章解释了这一点。</p><p id="72fb" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">基本上，每次你使用JavaScript方法获取HTML元素的样式或位置(比如<code class="fe nq nr ns nt b">element.getComputedStyle()</code>或<code class="fe nq nr ns nt b">element.getBoundingClientRect()</code>，或者每次你试图通过<code class="fe nq nr ns nt b">window.scrollY</code>访问窗口滚动值，浏览器都需要重新绘制整个网页来计算这些值。</p><p id="b694" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这可能导致性能瓶颈，并可能导致jank问题。</p><h2 id="629b" class="mz mi iq bd mj na nb dn mn nc nd dp mr kw ne nf mt la ng nh mv le ni nj mx nk bi translated">使用窗帘. js</h2><p id="9fcb" class="pw-post-body-paragraph kn ko iq kp b kq nl jr ks kt nm ju kv kw nn ky kz la no lc ld le np lg lh li ij bi translated">事实上，每次你添加一个平面，或者每次你调整窗口的大小来复制平面的HTML大小和位置，并将其应用到相关联的WebGL平面对象时，currents . js都会在内部使用<code class="fe nq nr ns nt b">getBoundingClientRect</code>。</p><p id="aaca" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是无法避免的，但是，幸运的是，这并不经常发生，所以这并不是什么大不了的事情。</p><p id="3d9f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是，我们在滑块的<code class="fe nq nr ns nt b">onTranslation</code>钩子中使用了<code class="fe nq nr ns nt b">updatePosition</code>方法，这个函数也调用了<code class="fe nq nr ns nt b">getBoundingClientRect</code>，因此触发了一个回流调用。</p><p id="6927" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们现在将看到如何改进我们的滑块，以摆脱那些布局重画计算。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="8c8b" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">另一种方法来翻译我们的飞机</h1><h2 id="2752" class="mz mi iq bd mj na nb dn mn nc nd dp mr kw ne nf mt la ng nh mv le ni nj mx nk bi translated">使用setRelativePosition方法</h2><p id="1490" class="pw-post-body-paragraph kn ko iq kp b kq nl jr ks kt nm ju kv kw nn ky kz la no lc ld le np lg lh li ij bi translated">本库提供了另一种翻译平面的方法:<a class="ae lj" href="https://www.curtainsjs.com/plane-class.html#set-relative-position" rel="noopener ugc nofollow" target="_blank"/><code class="fe nq nr ns nt b"><a class="ae lj" href="https://www.curtainsjs.com/plane-class.html#set-relative-position" rel="noopener ugc nofollow" target="_blank">setRelativePosition</a></code><a class="ae lj" href="https://www.curtainsjs.com/plane-class.html#set-relative-position" rel="noopener ugc nofollow" target="_blank">函数</a>。</p><p id="f32d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">它以像素为单位获取X和Y值作为参数，并通过更新其模型视图矩阵将其应用到您的平面。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="79b8" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">用例</h1><p id="af37" class="pw-post-body-paragraph kn ko iq kp b kq nl jr ks kt nm ju kv kw nn ky kz la no lc ld le np lg lh li ij bi translated">通常，当您使用currents . js时，您将使用滚动事件监听器中的<code class="fe nq nr ns nt b">updatePosition</code>来根据窗口滚动值更新您的平面的位置。</p><p id="eba9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因为没有办法在不触发reflow调用的情况下获取滚动或HTML元素的位置，所以这仍然是在使用原生滚动时处理平面位置的最佳方式。</p><p id="dff5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是，如果你正在使用一个虚拟的滚动库，例如，你将能够访问滚动值的计算，而不会引起回流调用，你将能够相应地更新你的飞机的位置，用我们的<code class="fe nq nr ns nt b">setRelativePosition</code>方法！</p><p id="7ba5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，回到我们的滑块。在任何给定的时间，我们都可以访问它的当前翻译(它是在不触发回流的情况下计算的)，那么为什么不用它来更新我们的位置呢？这正是我们要做的。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="9d4a" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">这个想法</h1><p id="1864" class="pw-post-body-paragraph kn ko iq kp b kq nl jr ks kt nm ju kv kw nn ky kz la no lc ld le np lg lh li ij bi translated">总体概念相当简单:我们将使用<code class="fe nq nr ns nt b">setRelativePosition</code>函数将我们的翻译应用于平面。</p><p id="34c0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因为每次我们调整浏览器窗口大小时，我们的飞机位置会自动更新，所以我们必须在那里重置它们的相对位置。</p><p id="dfb3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">通过这样做，我们将打破滑块的当前平移和我们的相对位置值之间的同步。然后，我们必须跟踪滑块先前的平移，并将这些值减去我们的相对位置。</p><p id="dbeb" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">滑块和WebGL现在再次同步！</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="d564" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">更新代码</h1><p id="a3ad" class="pw-post-body-paragraph kn ko iq kp b kq nl jr ks kt nm ju kv kw nn ky kz la no lc ld le np lg lh li ij bi translated">首先，我们将向WebGL slider类添加一个<code class="fe nq nr ns nt b">previousTranslation</code>属性。</p><p id="28c2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们更新我们的<code class="fe nq nr ns nt b">WebGLSlider</code>类构造函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu ll l"/></div></figure><p id="e267" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来，我们必须更新我们的<code class="fe nq nr ns nt b">onTranslation</code>钩子来使用<code class="fe nq nr ns nt b">setRelativePosition</code>函数，而不是之前的<code class="fe nq nr ns nt b">updatePosition</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu ll l"/></div></figure><p id="5869" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们需要做的最后一件事是重写我们的<code class="fe nq nr ns nt b">onSliderResized</code>钩子来更新我们的<code class="fe nq nr ns nt b">previousTranslation</code>属性值，重置我们的平面的相对位置，我们就完成了！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu ll l"/></div></figure><p id="0f6d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这就是所有的人！</p><p id="9b63" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，您已经准备好在您的网站上使用curtains.js，并且对性能的影响最小。</p><p id="bc83" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">您可以尝试更改着色器过程片段着色器中的一些值，以稍微调整效果。你也可以尝试使用不同的位移图像(记住，你必须使用一种模式来获得无缝效果)。</p><p id="ec51" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下面是一个额外的示例，其中包含不同的置换图像和着色器中的一些变化:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lk ll l"/></div></figure></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="6689" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">结论</h1><p id="a747" class="pw-post-body-paragraph kn ko iq kp b kq nl jr ks kt nm ju kv kw nn ky kz la no lc ld le np lg lh li ij bi translated">我希望你喜欢这篇文章，并发现它很有用。我还希望您看到了使用currents . js通过整洁的WebGL效果来增强您的UI是多么容易。</p><p id="a4d6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">看看<a class="ae lj" href="https://www.curtainsjs.com/documentation.html" rel="noopener ugc nofollow" target="_blank">库的文档</a>和<a class="ae lj" href="https://www.curtainsjs.com/#examples" rel="noopener ugc nofollow" target="_blank">例子</a>或者查看它的<a class="ae lj" href="https://github.com/martinlaxenaire/curtainsjs" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>如果你想知道更多。</p><p id="e3e0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要有创意！</p></div></div>    
</body>
</html>