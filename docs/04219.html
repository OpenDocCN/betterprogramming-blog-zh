<html>
<head>
<title>Golang Concurrency: Goroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang并发:Goroutines</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/golang-concurrency-goroutine-46f0009bcd7c?source=collection_archive---------20-----------------------#2020-03-30">https://betterprogramming.pub/golang-concurrency-goroutine-46f0009bcd7c?source=collection_archive---------20-----------------------#2020-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bfb7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用并发的小程序构建更大的程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/677b818503c2691d8f6792adb56b1e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSgxM0asXjvpC3GWyf69ag.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼尔·麦卡洛在<a class="ae ky" href="https://unsplash.com/s/photos/parallel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d3f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，大型程序是由许多其他较小的子程序组成的。例如，web服务器处理来自web浏览器的请求并提供HTML网页作为响应，而API服务器同时处理请求并返回响应。每个请求都像小程序一样被处理。</p><p id="7fb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理想情况下，像这样的程序同时运行这些小组件。这个同时在多个任务上取得进展的过程被称为<em class="lv">并发</em>。Go使用goroutines和通道对并发性提供了丰富的支持。</p><p id="3835" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">goroutine基本上是一个能够与其他函数同时运行的函数。我们使用关键字<code class="fe lw lx ly lz b">go</code>后跟一个函数调用来创建一个goroutine，例如<code class="fe lw lx ly lz b">doSomething(0)</code>:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="a6ac" class="me mf it lz b gy mg mh l mi mj">package main<br/><br/>import "fmt"<br/><br/>func doSomething(n int) {<br/>  for i := 0; i &lt; 10; i++ {<br/>    fmt.Println(n, ":", i)<br/>  }<br/>}<br/><br/>func main() {<br/>  go doSomething(0)<br/>  var input string<br/>  fmt.Scanln(&amp;input)<br/>}</span></pre><p id="1f78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个程序由两个程序组成。第一个goroutine是隐式的，它本身就是主函数。第二个goroutine是在我们调用<code class="fe lw lx ly lz b">go doSomething(0)</code>时创建的。通常当我们调用一个函数时，我们的程序会执行函数中的所有语句，然后返回到调用后的下一行。</p><p id="34b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用goroutine，<strong class="lb iu"> </strong>我们立即返回到下一行，不要等待函数完成。这就是为什么包含了对<code class="fe lw lx ly lz b">Scanln</code>函数的调用；如果没有它，程序将在有机会打印所有数字之前退出。</p><p id="6036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Goroutines <strong class="lb iu"> </strong>是轻量级的，我们可以轻松地创建数千个。我们可以这样修改我们的程序来运行十个goroutines:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="bcce" class="me mf it lz b gy mg mh l mi mj">func main() {<br/>  for i := 0; i &lt; 10; i++ {<br/>    go doSomething(i)<br/>  }<br/>  var input string<br/>  fmt.Scanln(&amp;input)<br/>}</span></pre><p id="c045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到，当您运行这个程序时，它似乎是按顺序运行goroutines，而不是同时运行。让我们使用<code class="fe lw lx ly lz b">time.Sleep</code>和<code class="fe lw lx ly lz b">rand.Intn</code>给函数添加一些延迟:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="a72a" class="me mf it lz b gy mg mh l mi mj">package main</span><span id="cf70" class="me mf it lz b gy mk mh l mi mj">import (<br/>  "fmt"<br/>  "time"<br/>  "math/rand"<br/>)</span><span id="e668" class="me mf it lz b gy mk mh l mi mj">func doSomething(n int) {<br/>  for i := 0; i &lt; 10; i++ {<br/>    fmt.Println(n, ":", i)<br/>    amt := time.Duration(rand.Intn(250))<br/>    time.Sleep(time.Millisecond * amt)<br/>  }<br/>}</span><span id="4d84" class="me mf it lz b gy mk mh l mi mj">func main() {<br/>  for i := 0; i &lt; 10; i++ {<br/>    go doSomething(i)<br/>  }<br/>  var input string<br/>  fmt.Scanln(&amp;input)<br/>}</span></pre><p id="8266" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">doSomething</code>打印从0到10的数字，每打印一个数字后等待0到250毫秒。goroutines现在应该同时运行。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="671e" class="ms mf it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">频道</h1><p id="8ada" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">通道允许两个goroutines之间和内部的通信，并同步它们的执行。下面是一个使用通道的示例程序:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="a076" class="me mf it lz b gy mg mh l mi mj">package main</span><span id="3463" class="me mf it lz b gy mk mh l mi mj">import (<br/>  "fmt"<br/>  "time"<br/>)</span><span id="f11c" class="me mf it lz b gy mk mh l mi mj">func pinger(c chan string) {<br/>  for i := 0; ; i++ {<br/>    c &lt;- "ping"<br/>  }<br/>}</span><span id="3af5" class="me mf it lz b gy mk mh l mi mj">func printer(c chan string) {<br/>  for {<br/>    msg := &lt;- c<br/>    fmt.Println(msg)<br/>    time.Sleep(time.Second * 1)<br/>  }<br/>}</span><span id="623f" class="me mf it lz b gy mk mh l mi mj">func main() {<br/>  var c chan string = make(chan string)</span><span id="b39b" class="me mf it lz b gy mk mh l mi mj">  go pinger(c)<br/>  go printer(c)</span><span id="526f" class="me mf it lz b gy mk mh l mi mj">  var input string<br/>  fmt.Scanln(&amp;input)<br/>}</span></pre><p id="0d44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个程序将永远打印“ping”(按回车键停止)。通道类型用关键字<code class="fe lw lx ly lz b">chan</code>表示，后跟在通道上传递的事物的类型(在本例中，我们传递的是字符串)。</p><p id="74a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">&lt;-</code>(左箭头)操作符用于在通道上发送和接收消息。<code class="fe lw lx ly lz b">c &lt;- "ping"</code>意为派遣<code class="fe lw lx ly lz b">"ping"</code>。<code class="fe lw lx ly lz b">msg := &lt;- c</code>表示接收一条信息并存储在<code class="fe lw lx ly lz b">msg</code>中。<code class="fe lw lx ly lz b">fmt</code>行也可以写成这样:<code class="fe lw lx ly lz b">fmt.Println(&lt;-c)</code>，在这种情况下，我们可以删除前一行。</p><p id="1658" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这样的通道可以同步两个goroutines。当<code class="fe lw lx ly lz b">pinger</code>试图在信道上发送消息时，它将等待，直到<code class="fe lw lx ly lz b">printer</code>准备好接收消息。(这就是所谓的阻塞)</p><p id="203f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在程序中添加另一个发送者，看看会发生什么。添加此功能:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="5fdd" class="me mf it lz b gy mg mh l mi mj">func ponger(c chan string) {<br/>  for i := 0; ; i++ {<br/>    c &lt;- "pong"<br/>  }<br/>}</span></pre><p id="926a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并修改<code class="fe lw lx ly lz b">main</code>:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="a9c9" class="me mf it lz b gy mg mh l mi mj">func main() {<br/>  var c chan string = make(chan string)</span><span id="0cd8" class="me mf it lz b gy mk mh l mi mj">  go pinger(c)<br/>  go ponger(c)<br/>  go printer(c)</span><span id="bc88" class="me mf it lz b gy mk mh l mi mj">  var input string<br/>  fmt.Scanln(&amp;input)<br/>}</span></pre><p id="4425" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">程序现在将轮流打印“ping”和“pong”。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="b1e2" class="ms mf it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">渠道方向</h1><p id="1f2d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们可以在一个通道类型上指定一个方向，从而将它限制为发送或接收。例如，pinger的函数签名可以更改为:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="ce4b" class="me mf it lz b gy mg mh l mi mj">func pinger(c chan&lt;- string)</span></pre><p id="f86c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在<code class="fe lw lx ly lz b">c</code>只能送到。试图从<code class="fe lw lx ly lz b">c</code>接收将导致编译器错误。类似地，我们可以将打印机更改为:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="80f6" class="me mf it lz b gy mg mh l mi mj">func printer(c &lt;-chan string)</span></pre><p id="5a12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有这些限制的信道被称为双向信道。双向通道可以传递给只接受发送通道或只接受接收通道的函数，但反之则不然。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="133f" class="ms mf it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">挑选</h1><p id="0d8e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">Go有一个名为<code class="fe lw lx ly lz b">select</code>的特殊语句，其工作方式类似于<code class="fe lw lx ly lz b">switch</code>，但是对于通道:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="1d29" class="me mf it lz b gy mg mh l mi mj">func main() {<br/>  c1 := make(chan string)<br/>  c2 := make(chan string)</span><span id="c5b0" class="me mf it lz b gy mk mh l mi mj">  go func() {<br/>    for {<br/>      c1 &lt;- "from 1"<br/>      time.Sleep(time.Second * 2)<br/>    }<br/>  }()</span><span id="ffbf" class="me mf it lz b gy mk mh l mi mj">  go func() {<br/>    for {<br/>      c2 &lt;- "from 2"<br/>      time.Sleep(time.Second * 3)<br/>    }<br/>  }()</span><span id="fa6a" class="me mf it lz b gy mk mh l mi mj">  go func() {<br/>    for {<br/>      select {<br/>      case msg1 := &lt;- c1:<br/>        fmt.Println(msg1)<br/>      case msg2 := &lt;- c2:<br/>        fmt.Println(msg2)<br/>      }<br/>    }<br/>  }()</span><span id="dca8" class="me mf it lz b gy mk mh l mi mj">  var input string<br/>  fmt.Scanln(&amp;input)<br/>}</span></pre><p id="4fe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个程序每两秒钟打印一次“从1开始”，每三秒钟打印一次“从2开始”。<code class="fe lw lx ly lz b">select</code>选择第一个准备好的通道，并从该通道接收(或向其发送)。如果不止一个通道准备好了，那么它会随机选择从哪个通道接收。如果没有准备好的通道，语句将阻塞，直到有一个通道可用。</p><p id="aab8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">select</code>语句通常用于实现超时:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="b11f" class="me mf it lz b gy mg mh l mi mj">select {<br/>case msg1 := &lt;- c1:<br/>  fmt.Println("Message 1", msg1)<br/>case msg2 := &lt;- c2:<br/>  fmt.Println("Message 2", msg2)<br/>case &lt;- time.After(time.Second):<br/>  fmt.Println("timeout")<br/>}</span></pre><p id="9bf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">time.After</code>创建一个频道，并在给定的持续时间后发送当前时间。(我们对时间不感兴趣，所以没有存储在变量中。)我们还可以指定一个<code class="fe lw lx ly lz b">default</code>案例:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="a960" class="me mf it lz b gy mg mh l mi mj">select {<br/>case msg1 := &lt;- c1:<br/>  fmt.Println("Message 1", msg1)<br/>case msg2 := &lt;- c2:<br/>  fmt.Println("Message 2", msg2)<br/>case &lt;- time.After(time.Second):<br/>  fmt.Println("timeout")<br/>default:<br/>  fmt.Println("nothing ready")<br/>}</span></pre><p id="a02e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有通道准备好，默认情况会立即发生。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="3852" class="ms mf it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">缓冲通道</h1><p id="4801" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">创建通道时，也可以向<code class="fe lw lx ly lz b">make</code>函数传递第二个参数:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="96be" class="me mf it lz b gy mg mh l mi mj">c := make(chan int, 1)</span></pre><p id="fd5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建一个容量为1的缓冲通道。通常通道是同步的；通道两边都要等到对方准备好了。缓冲通道是异步的；除非通道已满，否则发送或接收消息不会等待。</p></div></div>    
</body>
</html>