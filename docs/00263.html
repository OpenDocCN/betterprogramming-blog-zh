<html>
<head>
<title>Node.js — Some Concepts Before You Start Coding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js —开始编码前的一些概念</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/node-js-some-concepts-before-you-start-coding-ed613effe4a0?source=collection_archive---------1-----------------------#2019-01-09">https://betterprogramming.pub/node-js-some-concepts-before-you-start-coding-ed613effe4a0?source=collection_archive---------1-----------------------#2019-01-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0c9d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">节点中的高阶函数、回调和事件循环</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8d2e78d903719147a8a90b207f48b51d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HzfPSCm84bS_7YSLbwvJtA.png"/></div></div></figure><p id="7c17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章将帮助您理解<a class="ae lq" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>背后的不同概念，并让您能够创建生产就绪的应用程序。</p><p id="d1c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Node.js使用事件驱动的非阻塞I/O模型，这使它变得轻量级和高效。</p><p id="ea28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们都看过上面的声明，但它真正的意思是什么？让我们了解一下传统服务器模型过去是如何工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lr"><img src="../Images/665317b65e975451c256020df99f4b55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eOh1w8DQDsMlDypxYt_E7Q.png"/></div></div></figure><p id="df15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在传统的服务器模型中，对于服务器的每个请求，都会产生一个线程来处理相同的请求。这种类型的实现规模不大，因为您的服务器可以处理的多个请求的数量与您的机器可以产生的线程数量成正比。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ls"><img src="../Images/5165819c11a6823c6ac50f63a1509c8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UlfcLxpfrAm3HnSWiNdvCQ.png"/></div></div></figure><p id="e6b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Node中，一个进程由一个主执行线程和无数个后台线程(通常执行I/O工作)组成。使用队列来执行后台线程和主线程之间的协调。主线程从队列中取出任务(按照接收顺序排队)并执行它们。</p><p id="1eb9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简而言之，下面列出了使用Node.js的一些好处:</p><ul class=""><li id="b213" class="lt lu it kw b kx ky la lb ld lv lh lw ll lx lp ly lz ma mb bi translated">减少开发时间。</li><li id="cb93" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated">减少所需的服务器数量/服务器成本。</li><li id="00ce" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated">减少API响应时间/页面加载时间。</li></ul><p id="c76e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是有些情况下你不应该使用Node.js，一个例子可以在<a class="ae lq" href="https://eng.uber.com/go-geofence/" rel="noopener ugc nofollow" target="_blank">优步工程</a>的这篇文章中找到。</p><p id="0e3b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在实际使用Node.js编码之前，我想提一下Javascript的一些核心概念，这些概念使得Node.js能够以这种方式工作。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="d108" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated"><strong class="ak"> 1。高阶函数</strong></h1><p id="3c4e" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">对于任何JS开发人员来说，这可能是一件很平常的事情，但是对于JS新手来说，可能会觉得这很奇怪。在JS中，可以将一个函数作为参数传递给另一个函数。让我们用一个简单的例子来理解这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="832e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只要在Jsbin 这里输入这个代码<a class="ae lq" href="https://jsbin.com" rel="noopener ugc nofollow" target="_blank">就能看到神奇之处！在上面的例子中，函数<code class="fe nn no np nq b">sayWhat</code>被传递给了<code class="fe nn no np nq b">speak</code>函数。</a></p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="5acc" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">2.所有后卫</h1><p id="0a57" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">在上面的例子中，我们已经看到了<code class="fe nn no np nq b">callback</code>的使用。下面的语句停止代码执行。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="f878" class="nv mp it nq b gy nw nx l ny nz"><em class="oa">alert(`${name} threw a boomerang few years ago`);</em></span></pre><p id="f32a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦关闭警报，传递的方法将被调用。这被称为回调。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="bfa2" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">3.事件循环</h1><p id="0c2e" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">所有的函数调用都放在一个基于后进先出的调用堆栈中。事件循环不断检查调用堆栈，看是否有任何函数需要运行。这样做的时候，它会将找到的任何函数调用添加到调用堆栈中，并按顺序执行每个函数调用。</p><p id="988b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我推荐<a class="ae lq" href="https://youtu.be/8aGhZQkoFbQ" rel="noopener ugc nofollow" target="_blank">菲利普·罗伯茨的这个解说视频</a></p><p id="5667" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们用实际的方法来理解事件循环。首先运行下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a8c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上述代码将按预期工作。3 → 1 → 2 → 4</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2a32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最小值<code class="fe nn no np nq b">setTimeout</code>的结果调用在第二个参数中提到的时间之后作为参数传递的函数。由于时间被称为0，您可能会认为输出是3 → 1 → 2 → 4。但由于事件循环的工作方式，实际上是3 → 2→ 4 → 1。</p><p id="99a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经理解了这篇文章的一些基本概念。在下一篇文章中，我们将学习如何安装Node.js并编写一些基本代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/0bf5df4c347f4b7878add00ed9d2eeef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RIUq42rf1bjVzLSt"/></div></div><p class="oc od gj gh gi oe of bd b be z dk translated">今天到此为止。</p></figure></div></div>    
</body>
</html>