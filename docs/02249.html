<html>
<head>
<title>How To Make Your Swift App Work With NFC Tags in iOS 13</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在iOS 13中让您的Swift应用程序与NFC标签配合使用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/working-with-nfc-tags-in-ios-13-d08c7d183981?source=collection_archive---------3-----------------------#2019-11-17">https://betterprogramming.pub/working-with-nfc-tags-in-ios-13-d08c7d183981?source=collection_archive---------3-----------------------#2019-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2d15" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Swift中读写NFC标签</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ce63f5e6646192b6727eeabe35a6543f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E59tqbHK9mk5UJpY5EzY0g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="6ab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NFC是一种易于使用的技术，具有多种应用。它是苹果和谷歌移动支付的基础，<a class="ae ky" href="https://www.nintendo.com/amiibo/what-is-amiibo/" rel="noopener ugc nofollow" target="_blank">任天堂</a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Lego_Dimensions" rel="noopener ugc nofollow" target="_blank">乐高</a>用它来增强游戏体验，NFC标签甚至<a class="ae ky" href="https://www.youtube.com/watch?time_continue=11&amp;v=vCvqFf08Fhs&amp;feature=emb_logo" rel="noopener ugc nofollow" target="_blank">被添加到衣服上</a>。</p><p id="6073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在iOS 13中，苹果扩展了对NFC的支持。以前，应用程序只能从标签中读取，但现在，iOS设备也可以向标签中写入。</p><p id="c0ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们将进一步了解如何使用苹果公司用于与NFC设备交互的框架<code class="fe lv lw lx ly b">CoreNFC</code>，来读取和写入NFC标签。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2dd9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">项目设置</h1><p id="6254" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在我们开始扫描NFC标签之前，我们需要添加功能<em class="nd">近场通信标签读取</em>。这可以在<em class="nd">标签下的&amp;功能</em>项目设置中完成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/6a7d9de2ab68f93cff5d94d91a0d0b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A7PomyyqZOcgDhRFNB89wA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为应用添加NFC功能。</p></figure><p id="cb3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要给我们的<code class="fe lv lw lx ly b">info.plist</code>文件添加一个<code class="fe lv lw lx ly b">NFCReaderUsageDescription</code>，它告诉用户为什么应用程序需要使用NFC。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/523178f6bbea81b3e73355107059184d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l318mywd-fT1bykSM8wTXg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">info.plist中NFCReaderUsageDescription的示例</p></figure><p id="f138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在一切都设置好了，我们可以开始编写代码了！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0d00" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">准备</h1><p id="b775" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在我们开始扫描标签之前，我们应该确保用户的设备能够这样做。我们可以这样检查<code class="fe lv lw lx ly b">NFCReaderSession</code>的属性<code class="fe lv lw lx ly b">readingAvailable</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">检查NFC扫描仪的可用性。</p></figure><p id="eeb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，如果不支持扫描NFC标签，我们什么也不做，但你可能应该在一个真正的应用程序中做更多的事情，例如，显示警告以通知用户。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1340" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">从NFC标签读取数据</h1><p id="15d0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我们需要初始化、准备并开始一个新的<code class="fe lv lw lx ly b">NFCNDEFReaderSession</code>。</p><p id="c45f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇，这个会话类有很多字母！当然，你一开始就认识到了NFC，后来又认识到了<code class="fe lv lw lx ly b">ReaderSession</code>，但是NDEF代表什么呢？</p><p id="acef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NDEF是<em class="nd"> NFC数据交换格式</em>，它定义了在NFC标签上存储数据以及从一个NFC设备向另一个设备发送数据的数据格式。如果你想进一步了解这种格式，你可以访问<a class="ae ky" href="https://learn.adafruit.com/adafruit-pn532-rfid-nfc/ndef" rel="noopener ugc nofollow" target="_blank">这个网站</a>。</p><p id="3588" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是不要担心，你不需要了解更多关于NFC标签的知识。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">初始化NFCNDEFReaderSession以与NFC标签通信。</p></figure><p id="decd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —创建新的会话对象时，需要三个参数:<code class="fe lv lw lx ly b">delegate</code>、<code class="fe lv lw lx ly b">queue</code>和<code class="fe lv lw lx ly b">invalidAfterFirstRead</code>。</p><p id="347a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个参数是实现<code class="fe lv lw lx ly b">NFCNDEFReaderSessionDelegate</code>协议的对象。该协议定义了处理与读取会话相关的事件的方法，例如，查找标签或接收错误。我们将在几秒钟内对其进行仔细观察。</p><p id="06f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参数<code class="fe lv lw lx ly b">queue</code>是一个调度队列，在调用代理时使用。如果您不想显式地使用一个现有的队列，您可以使用<code class="fe lv lw lx ly b">nil</code>,并且为会话创建一个新的调度队列。</p><p id="87c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe lv lw lx ly b">invalidAfterFirstRead</code>是一个布尔标志，在第一个标记被读取后，它会使会话无效。如果您只想扫描一个标签，则将其设置为<code class="fe lv lw lx ly b">true</code>，如果您想继续扫描，则将其设置为<code class="fe lv lw lx ly b">false</code>。</p><p id="e667" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code>—此外，我们设置属性<code class="fe lv lw lx ly b">alertMessage</code>，这是每当我们开始扫描时显示给用户的文本。</p><p id="18f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 3</code>—最后一步是在会话中调用方法<code class="fe lv lw lx ly b">begin</code>，设备将在附近寻找NFC标签。会话启动后，您可以看到以下警报:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/694f9ea53f45cab1e7e6137a9bddf741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*_PLVjYgK_MqVtZ6En9Dmvw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">提醒您的用户您正在扫描NFC标签。</p></figure><p id="de31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们知道了如何开始一个会话，让我们研究一下<code class="fe lv lw lx ly b">NFCNDEFReaderSessionDelegate</code>来看看如何处理一个检测到的标签。</p><p id="f08b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该协议定义了四种方法，其中三种可以在下面的代码中看到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从NFC标签读取数据。</p></figure><p id="9a55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —第一种方法是<code class="fe lv lw lx ly b">readerSessionDidBecomeActive(_:)</code>。顾名思义，它在会话开始时被调用。此方法是可选的，可以省略。</p><p id="43eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code>—从NFC标签读取数据的重要方法是<code class="fe lv lw lx ly b">readerSession(_:didDetectNDEFs:)</code>。一旦发现带有NDEF消息的标签，读取器会话就调用该方法。</p><p id="ba62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们遍历从标签接收到的每条消息。这些消息中的每一条都包含一个记录数组，我们也在这个数组上进行循环。我们从每个记录中访问标识符、类型和有效负载，将它们转换成字符串并打印到控制台。</p><p id="0d9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:虽然这个方法是必需的，但是只有当可选方法<code class="fe lv lw lx ly b">readerSession(_:didDetact:)</code>没有被委托实现的时候才会被调用！我们将在关于写入标签的章节中详细讨论这个方法。</p><p id="ef22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 3</code>—最后一种方法是<code class="fe lv lw lx ly b">readerSession(_:didInvalidateWithError:)</code>。</p><p id="5f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当我们的会话变得不活动时，就会调用这个函数，例如，当我们将<code class="fe lv lw lx ly b">invalidAfterFirstRead</code>设置为true并且已经扫描了一个标签时，会话就会超时，或者通过调用<code class="fe lv lw lx ly b">.invalidate()</code>使会话失效。</p><p id="a273" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们将错误打印到控制台。这种方法也是必需的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a418" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">将数据写入NFC标签</h1><p id="84a2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在我们继续之前，我们必须创建一个新的读取会话，它不会在检测到第一个标签后失效。因为我们需要初始化一个连接并将数据写入标签，这可能需要一些时间，所以我们将<code class="fe lv lw lx ly b">invalidAfterFirstRead</code>设置为false。</p><p id="3944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以通过使用之前没有使用的第四种方法<code class="fe lv lw lx ly b">NFCNDEFReaderSessionDelegate</code>向NFC标签写入数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">向NFC标签写入数据。</p></figure><p id="dad3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code>—首先，我们检查是否检测到一个以上的标签。这是可能的，因为我们不再使会话无效。</p><p id="199b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在当前会话中使用方法<code class="fe lv lw lx ly b">invalidate(errorMessage:)</code>来改变显示给用户的警告消息。使用此方法，将显示以下警报:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/d2c24465e38a48fe616fb2c18c1d782e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*_2hfGEXrdFhxwrnvbbD5tQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用<code class="fe lv lw lx ly b">invalidate(errorMessage:).</code>提醒用户出现错误</p></figure><p id="cb83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code>—接下来，我们开始一个到扫描标签的新连接。由于此操作可能会失败，我们需要处理可能的错误。在本例中，我们在扫描警报上显示了一个新文本。</p><p id="da29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 3</code>—我们连接到标签后，需要查询它的NDEF状态，可以是<code class="fe lv lw lx ly b">.notSupported</code>、<code class="fe lv lw lx ly b">.readOnly</code>或<code class="fe lv lw lx ly b">.readWrite</code>。</p><p id="1d13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 4</code>—如果标签是可写的，我们可以给它写一条NDEF消息。我们将看看如何在几秒钟内创建这样的消息。一旦这个方法完成，我们可以检查写操作是否成功，并结束我们的会话。</p><p id="51ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，将数据写入标签需要很多步骤。这张图表直观地显示了正在发生的事情:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/373b07f51b44bd8166d3d67d2537a90b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b5cYiGlvghtwRTSAyCWjtw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将数据写入NFC标签需要多个步骤。</p></figure><p id="770e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们写入标签的消息是一个<code class="fe lv lw lx ly b">NFCNDEFMessage</code>，它只是一个简单的包装器，包装了一组<code class="fe lv lw lx ly b">NFCNDEFPayload</code>实例。在下面的代码示例中，您可以看到如何创建这样的有效负载:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建NFCNDEFMessage以写入NFC标签。</p></figure><p id="cf82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code>—两个类方法<code class="fe lv lw lx ly b">wellKnownTypeURIPayload(string:)</code>和<code class="fe lv lw lx ly b">wellKnownTypeURIPayload(url:)</code>创建包含URL的有效负载。</p><p id="1ca9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code>—<code class="fe lv lw lx ly b">wellKnownTypeTextPayload(string:locale:)</code>我们可以创建一个包含简单字符串的有效载荷。</p><p id="3ab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:由于接收到的有效载荷始终是<code class="fe lv lw lx ly b">nil</code>，该功能目前似乎已被破坏。如果你想写文本到一个标签，你需要使用自定义初始化器。</p><p id="2573" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 3</code>—此外，我们可以通过使用<code class="fe lv lw lx ly b">NFCNDEFPayload</code>的初始化器创建一个定制的有效负载对象，并传递格式、类型、标识符和有效负载。</p><p id="7b0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 4</code>—最后，我们可以创建一个包含有效负载实例的<code class="fe lv lw lx ly b">NFCNDEFMessage</code>。</p><p id="9f5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你知道了iOS 13中NFC标签入门的一切。您了解了如何读取数据以及如何创建消息并将其写入NFC标签。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0f06" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">资源</strong></h1><div class="nk nl gp gr nm nn"><a href="https://developer.apple.com/documentation/corenfc/building_an_nfc_tag-reader_app" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">构建NFC标签阅读器应用程序</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">该示例代码项目展示了如何在应用程序中使用核心NFC来读取第1类近场通信(NFC)标签…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">developer.apple.com</p></div></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://learn.adafruit.com/adafruit-pn532-rfid-nfc/ndef" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">Adafruit PN532 RFID/NFC分线点和屏蔽</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">这不是一个完整的教程，只是在我们对RFID/NFC做更多研究时的一个快速入门指南。有很多…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">learn.adafruit.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob ks nn"/></div></div></a></div></div></div>    
</body>
</html>