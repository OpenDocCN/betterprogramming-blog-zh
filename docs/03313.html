<html>
<head>
<title>The Shape Protocol and Custom Shapes in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中的形状协议和自定义形状</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-shape-protocol-and-custom-shapes-in-swiftui-1e562efd0e79?source=collection_archive---------13-----------------------#2020-02-03">https://betterprogramming.pub/the-shape-protocol-and-custom-shapes-in-swiftui-1e562efd0e79?source=collection_archive---------13-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f32c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解什么是形状协议以及如何在SwiftUI中创建自己的形状</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/90c5e1c31ea4a63f0e840641d03c3ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lHyQZw51RMbcdFbiqt-ZuA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@pawel_czerwinski?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">paweczerwiński</a>在<a class="ae ky" href="https://unsplash.com/s/photos/shape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="b92d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍</h1><p id="9105" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">多年来，在许多应用程序中，用户的缩略图显示为圆形图像或圆角矩形图像是一种趋势。在UIKit框架中，当我们使用<code class="fe mu mv mw mx b">UIImageView</code>时，我们可以设置图像视图底层的<code class="fe mu mv mw mx b">cornerRadius</code>来产生所需的缩略图。</p><p id="3257" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">然而，随着SwiftUI框架的流行，我们发现<code class="fe mu mv mw mx b">UIImageView</code>不是SwiftUI框架的一部分。我们可能会想，如果没有<code class="fe mu mv mw mx b">UIImageView</code>，我们如何能把我们的图像做成想要的形状。</p><p id="0d6f" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在这篇文章中，我将向您展示如何在SwiftUI中创建自定义形状，这些形状可用于设置图像的轮廓形状。在我们深入研究之前，让我们先回顾一下SwiftUI的<code class="fe mu mv mw mx b">Shape</code>协议是什么。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ee0d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">形状协议</h1><p id="a4ad" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe mu mv mw mx b">Shape</code>协议是作为SwiftUI框架的一部分引入的。在<a class="ae ky" href="https://developer.apple.com/documentation/swiftui/shape" rel="noopener ugc nofollow" target="_blank">官方文件</a>中是这样定义的:</p><blockquote class="nd"><p id="791f" class="ne nf it bd ng nh ni nj nk nl nm mt dk translated">"绘制视图时可以使用的2D形状."</p></blockquote><p id="385d" class="pw-post-body-paragraph ly lz it ma b mb nn ju md me no jx mg mh np mj mk ml nq mn mo mp nr mr ms mt im bi translated"><code class="fe mu mv mw mx b">Shape</code>协议提供了创建各种二维图形所需的一系列功能，这些图形可用于配置视图。</p><p id="ae1a" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">上面的定义和简要的解释可能过于概念性，难以理解。不要担心，因为我敢打赌，通过阅读本文的剩余部分，您将对这个协议及其用法有更好的理解。</p><h2 id="3722" class="ns lh it bd li nt nu dn lm nv nw dp lq mh nx ny ls ml nz oa lu mp ob oc lw od bi translated">内置形状</h2><p id="1b4d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们先来看看SwiftUI框架中的内置形状。如下图所示，SwiftUI框架有<code class="fe mu mv mw mx b">Circle</code>、<code class="fe mu mv mw mx b">RoundedRectangle</code>、<code class="fe mu mv mw mx b">Rectangle</code>、<code class="fe mu mv mw mx b">Capsule</code>和<code class="fe mu mv mw mx b">Ellipse</code>形状。这些形状的名称清楚地表明了它们是什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/a0d54d2e8864d002c9ac159be0b92ec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uSnHKmxUvSnheUKdQMxETQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SwiftUI中的基本形状</p></figure><p id="03a1" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">除了这些形状之外，通过应用各种变换函数(例如，偏移、旋转)，可以生成一些也符合<code class="fe mu mv mw mx b">Shape</code>协议的变换形状。以一个<code class="fe mu mv mw mx b">Ellipse</code>形状为起点，下图显示了<code class="fe mu mv mw mx b">OffsetShape</code>、<code class="fe mu mv mw mx b">RotatedShape</code>、<code class="fe mu mv mw mx b">ScaledShape</code>和<code class="fe mu mv mw mx b">TransformedShape</code>的例子。值得注意的是，这些形状是通用类型，其具体形状类型基于原始形状。比如一个<code class="fe mu mv mw mx b">Ellipse</code>形状会产生一个<code class="fe mu mv mw mx b">OffsetShape&lt;Ellipse&gt;</code>，而一个<code class="fe mu mv mw mx b">Rectangle</code>形状会产生一个<code class="fe mu mv mw mx b">OffsetShape&lt;Rectganle&gt;</code>。</p><p id="a21e" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">每行的第二行显示了相应的函数，该函数修改原始椭圆以生成右侧显示的变换后的形状。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/c8ac6c04ba9d258adfa45f51c4d961e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bhNy6CO49u4GcgwcomCxrg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SwiftUI中的变形形状</p></figure><h2 id="eb1f" class="ns lh it bd li nt nu dn lm nv nw dp lq mh nx ny ls ml nz oa lu mp ob oc lw od bi translated">常用功能</h2><p id="74c4" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">对于给定的形状，有几个函数可用于进一步设置形状的外观。本节总结了常用的函数。对于显示的形状，显示边框是为了锚定。</p><p id="e985" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><strong class="ma iu">大小、比例和位置</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/83584b10aec4ab2780be5907d8456281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*geg6pyhybN69qUEbBu5k7w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">大小、比例和位置</p></figure><p id="eb27" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><strong class="ma iu">要设置形状</strong>的大小，我们可以使用<code class="fe mu mv mw mx b">size(CGSize) -&gt; Shape</code>或<code class="fe mu mv mw mx b">size(width: CGFloat, height: CGFloat) -&gt; Shape</code>功能。这两个函数都非常简单，可以达到相同的效果。</p><p id="4634" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><strong class="ma iu">要设置形状的比例而不改变其边框</strong>，我们可以使用<code class="fe mu mv mw mx b">scale(CGFloat, anchor: UnitPoint) -&gt; ScaledShape&lt;Self&gt;</code>或<code class="fe mu mv mw mx b">scale(x: CGFloat, y: CGFloat, anchor: UnitPoint) -&gt; ScaledShape&lt;Self&gt;</code>功能。如上所述，这些函数生成了泛型<code class="fe mu mv mw mx b">ScaledShape</code>，使得返回的类型是与泛型类型<code class="fe mu mv mw mx b">ScaledShape</code>形状相同的具体类型，如<code class="fe mu mv mw mx b">Circle</code>到<code class="fe mu mv mw mx b">ScaledShape&lt;Circle&gt;</code>和<code class="fe mu mv mw mx b">Rectangle</code>到<code class="fe mu mv mw mx b">ScaledShape&lt;Rectangle&gt;</code>。</p><p id="cd42" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">对于第一个函数，您将<code class="fe mu mv mw mx b">scale</code>指定为用于调整形状大小的倍增因子。例如，比例0.5是水平和垂直尺寸的一半，而比例2是两个尺寸的两倍。</p><p id="32c8" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">对于第二个函数，<code class="fe mu mv mw mx b">x</code>和<code class="fe mu mv mw mx b">y</code>参数分别用于设置水平和垂直尺寸的倍增系数，它们的默认值都是1，表示没有缩放。<code class="fe mu mv mw mx b">anchor</code>参数是指定缩放的起点，默认值是中心。</p><p id="6731" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><strong class="ma iu">设置形状</strong>的相对位置，可以使用<code class="fe mu mv mw mx b">offset(CGSize) -&gt; OffsetShape&lt;Self&gt;</code>、<code class="fe mu mv mw mx b">offset(CGPoint) -&gt; OffsetShape&lt;Self&gt;</code>或<code class="fe mu mv mw mx b">offset(x: CGFloat, y: CGFloat) -&gt; OffsetShape&lt;Self&gt;</code>功能。这些函数生成通用的<code class="fe mu mv mw mx b">OffsetShape</code>。</p><p id="b639" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">对于第一个函数，我们以磅为单位指定形状的偏移量。就像我们在自动布局中使用坐标一样，正数表示向右下方，负数表示向左上方。</p><p id="a823" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">第二个和第三个函数可以通过设置水平和垂直偏移来改变形状的位置，从而执行相同的任务。对于第三个函数，<code class="fe mu mv mw mx b">x</code>和<code class="fe mu mv mw mx b">y</code>的默认值都是0，意味着两个维度都没有偏移。</p><p id="08ec" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><strong class="ma iu">填充并勾画轮廓</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/25460ede09509c785cb305853b5051d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tL0VgcpK0i0Y8nvnjINyag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">填充和轮廓</p></figure><p id="1cc8" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><strong class="ma iu">用某种颜色或渐变</strong>填充形状，我们可以使用<code class="fe mu mv mw mx b">fill&lt;S&gt;(S, style: FillStyle) -&gt; View</code>或<code class="fe mu mv mw mx b">fill(style: FillStyle) -&gt; View</code>函数。前者是一个通用的实例方法，其中<code class="fe mu mv mw mx b">S</code>符合<code class="fe mu mv mw mx b"><a class="ae ky" href="https://developer.apple.com/documentation/swiftui/shapestyle" rel="noopener ugc nofollow" target="_blank">ShapeStyle</a></code>协议——一种将形状转化为视图的方法。两个函数中的<code class="fe mu mv mw mx b">style</code>参数都是<code class="fe mu mv mw mx b">FillStyle</code>的一个实例，它指定了用于栅格化矢量形状的样式(如颜色或渐变)。</p><p id="7ae7" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><strong class="ma iu">要设置形状的轮廓</strong>，我们可以使用<code class="fe mu mv mw mx b">stroke&lt;S&gt;(S, lineWidth: CGFloat) -&gt; View</code>、<code class="fe mu mv mw mx b">stroke&lt;S&gt;(S, style: StrokeStyle) -&gt; View</code>、<code class="fe mu mv mw mx b">stroke(lineWidth: CGFloat) -&gt; Shape</code>或<code class="fe mu mv mw mx b">stroke(style: StrokeStyle) -&gt; Shape</code>功能。前两个函数是通用实例方法，其中<code class="fe mu mv mw mx b">S</code>符合<code class="fe mu mv mw mx b">ShapeStyle</code>协议。</p><p id="7995" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><strong class="ma iu">旋转、变换和修剪</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/3215ce1b6bac94d2edc830ccecedb19c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E_tr0lhZukAPp-kX-6wnFg.png"/></div></div></figure><p id="8a50" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><strong class="ma iu">要围绕锚点</strong>旋转形状，我们可以使用<code class="fe mu mv mw mx b">rotation(Angle, anchor: UnitPoint) -&gt; RotatedShape&lt;Self&gt;</code>功能。如前所述，这个函数将创建一个泛型<code class="fe mu mv mw mx b">RotatedShape</code>。我们可以为旋转指定<code class="fe mu mv mw mx b">Angle</code>。正负角度分别是顺时针和逆时针旋转。<code class="fe mu mv mw mx b">anchor</code>是旋转形状的点，默认值是中心。</p><p id="ece3" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><strong class="ma iu">要对形状</strong>应用仿射变换，我们可以使用<code class="fe mu mv mw mx b">tranform(CGAffineTransform) -&gt; TransformedShape&lt;Self&gt;</code>函数。参数是要应用于形状的仿射变换矩阵。这是一个非常健壮的函数，因为我们可以在这个函数中为形状提供旋转、缩放、平移和倾斜的组合。</p><p id="c551" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><strong class="ma iu">要修剪形状</strong>，我们可以使用<code class="fe mu mv mw mx b">trim(from: CGFloat, to: CGFloat) -&gt; Shape</code>功能。具体来说，我们为<code class="fe mu mv mw mx b">from</code>参数指定开始分数，为<code class="fe mu mv mw mx b">to</code>参数指定结束分数。这两个参数的默认值分别为0和1，表示绘图的起点和终点。当使用默认值时，不会发生修剪。</p><p id="e5a7" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><strong class="ma iu">路径</strong></p><p id="2121" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><strong class="ma iu">要将形状描述为矩形参照系</strong>内的路径，可以使用<code class="fe mu mv mw mx b">path(in: CGRect) -&gt; Path</code>功能。<strong class="ma iu">这是符合</strong> <code class="fe mu mv mw mx b"><strong class="ma iu">Shape</strong></code> <strong class="ma iu">协议所需的功能。</strong>因此，我们将实现这个函数来创建一个符合<code class="fe mu mv mw mx b">Shape</code>协议的自定义形状。我们将在下一节看到这个函数是如何实现的。</p><h2 id="fc8c" class="ns lh it bd li nt nu dn lm nv nw dp lq mh nx ny ls ml nz oa lu mp ob oc lw od bi translated">缩略图创建</h2><p id="1181" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如前所述，应用程序开发中的一个常见功能是将用户的缩略图绑定到一个圆形或圆角矩形。这可以通过利用SwiftUI中的内置形状来实现。</p><p id="1bae" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">下图向您展示了我们如何使用接受shape实例的<code class="fe mu mv mw mx b">clipShape(_:style:)</code>函数将图像裁剪成所需的形状。要给裁剪后的图像添加边框，我们可以简单地使用<code class="fe mu mv mw mx b">overlay(_:alignment:)</code>功能用边框集覆盖另一个形状。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/532407612d852981ea70085ea54dab8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dj_7Dn3-UQbKAUaeGFcZEw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">缩略图(图片来源:由<a class="ae ky" href="https://unsplash.com/@robmulally?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Rob Mulally </a>在<a class="ae ky" href="https://unsplash.com/s/photos/landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="0ebd" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">创建自定义形状</h1><p id="9c14" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在回顾了<code class="fe mu mv mw mx b">Shape</code>协议之后，我们对这个协议有了一个大概的了解。现在，真正的乐趣开始了，因为我们正在学习如何创建自定义形状！出于这个简单教程的目的，我们将创建一个<code class="fe mu mv mw mx b">IceCream</code>形状，向您展示一些关于遵守<code class="fe mu mv mw mx b">Shape</code>协议的一般想法。</p><p id="ab6d" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">符合该协议要求实施<code class="fe mu mv mw mx b">path(in: CGRect) -&gt; Path</code>功能。此函数将形状描述为矩形参照系内的路径。下面的代码片段向您展示了如何通过在<code class="fe mu mv mw mx b">IceCream</code>结构中实现<code class="fe mu mv mw mx b">path(in:)</code>函数来非常容易地绘制<code class="fe mu mv mw mx b">IceCream</code>形状。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="0bd4" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">具体来说，<code class="fe mu mv mw mx b">heightRadiusRatio</code>是圆锥体的高度与其半径之比。为了画出形状，我们只需要确定三个定位点:圆锥体的底部、左侧和右侧。使用了以下三个函数。请注意，所有这些函数都是<code class="fe mu mv mw mx b">mutating</code>，这意味着它们将改变调用它们的路径，这在我们打算操纵路径时是有意义的。</p><ul class=""><li id="2754" class="oi oj it ma b mb my me mz mh ok ml ol mp om mt on oo op oq bi translated"><code class="fe mu mv mw mx b">move(to:)</code>该功能在我们可以继续绘图的指定点开始一个新子路径。</li><li id="3422" class="oi oj it ma b mb or me os mh ot ml ou mp ov mt on oo op oq bi translated"><code class="fe mu mv mw mx b">addLine(to:)</code>该功能从当前点到指定点追加一条直线段。</li><li id="e1dc" class="oi oj it ma b mb or me os mh ot ml ou mp ov mt on oo op oq bi translated"><code class="fe mu mv mw mx b">addArc(center:radius:startAngle:endAngle:clockwise:transform:)</code>该功能通过指定圆心、半径和角度向路径添加一段圆弧。</li></ul><p id="1e98" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">这个<code class="fe mu mv mw mx b">IceCream</code>形状的实现非常简单。这里有几个我们如何使用它们的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/b713720a311399bab2a4133ce39f9adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*inOu1D2Pb0RJGejGOsqTNw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">定制冰淇淋形状</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="1fca" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="5acc" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">本教程回顾了<code class="fe mu mv mw mx b">Shape</code>协议，以及我们如何通过简单地实现<code class="fe mu mv mw mx b">path(in:)</code>来指定形状的路径来定制形状。</p><p id="96cb" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">对于一些没有做过自定义绘图的开发人员来说，这听起来很难。我希望这个关于<code class="fe mu mv mw mx b">Shape</code>协议的简单教程可以成为他们的第一个学习工具。最终，除了定制的形状，我们可以学习一起画一些更复杂的东西。</p></div></div>    
</body>
</html>