<html>
<head>
<title>5 Tips for Composing Event Handler Functions in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中编写事件处理函数的5个技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-tips-for-composing-event-handler-functions-in-react-479553968585?source=collection_archive---------5-----------------------#2020-05-20">https://betterprogramming.pub/5-tips-for-composing-event-handler-functions-in-react-479553968585?source=collection_archive---------5-----------------------#2020-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9623" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更好的构图</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/733202c4b926115014150c98fffda51d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PMIflq-SMWcVBDPlBPJ87Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">卢卡·布拉沃在Unsplash上拍摄的照片</em></p></figure><p id="f16e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript因其独特的组合和创建函数的能力而受到称赞。这是因为在JavaScript中，函数是一等公民，这意味着它们可以被视为值，并且具有其他函数所具有的所有操作属性(比如能够被赋给变量、作为函数参数传递、或者从函数返回等等。).</p><p id="2829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将讨论在React中编写事件处理程序的五个关键技巧。本文不会涵盖所有可能的事情，但会涵盖每个React开发人员至少应该知道的编写事件处理程序的重要方法。</p><p id="b7a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从一个输入元素开始，并附加一个<code class="fe lv lw lx ly b">value</code>和<code class="fe lv lw lx ly b">onChange</code>道具开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="fe12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的事件处理程序是<code class="fe lv lw lx ly b">onChange</code>，第一个参数是来自处理程序所附加的元素的事件对象。</p><p id="7104" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里我们可以改进什么？嗯，编写可重用的组件通常是一个好的实践，我们可以使其可重用。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="84e4" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">1.将设置器移动到更高的级别</h1><p id="579e" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">一种方法是将设置<code class="fe lv lw lx ly b">value</code>状态的责任交给<code class="fe lv lw lx ly b">props</code>，这样其他组件就可以重用这个输入:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="b6c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们还必须将对事件处理程序(包含状态设置器)的控制权交给父类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="178e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们所做的只是将状态和事件处理程序移动到父组件，最终我们的<code class="fe lv lw lx ly b">App</code>组件与我们的<code class="fe lv lw lx ly b">MyInput</code>完全相同，只是名称不同。那么这有什么意义呢？</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="446c" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">2.如果出于可扩展性目的需要更多信息，请包装您的事件处理程序</h1><p id="b585" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">当我们开始作曲时，事情开始改变。看一下<code class="fe lv lw lx ly b">MyInput</code>组件。与其直接将<code class="fe lv lw lx ly b">onChange</code>分配给它的<code class="fe lv lw lx ly b">input</code>元素，我们不如赋予这个可重用组件一些额外的功能，让它更有用。</p><p id="c21f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过在另一个<code class="fe lv lw lx ly b">onChange</code>中组合<code class="fe lv lw lx ly b">onChange</code>并将新的<code class="fe lv lw lx ly b">onChange</code>附加到元素上来操作<code class="fe lv lw lx ly b">onChange</code>。在新的<code class="fe lv lw lx ly b">onChange</code>中，它将从props中调用原来的<code class="fe lv lw lx ly b">onChange</code>,因此功能仍然可以正常运行——就像什么都没改变一样。</p><p id="49b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="1874" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这带来了当<code class="fe lv lw lx ly b">input</code>的<code class="fe lv lw lx ly b">value</code>改变时注入额外逻辑的惊人能力。它的行为很正常，因为它仍然在它的块中调用原来的<code class="fe lv lw lx ly b">onChange</code>。</p><p id="0f62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们现在可以强制input元素只接受数字值，并且最多只接受六个字符的长度，如果我们想用它来验证通过用户电话的登录，这是很有用的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="d318" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，实际上，到目前为止，这一切都可以在父<code class="fe lv lw lx ly b">App</code>中实现，没有任何问题。但是如果父进程中的<code class="fe lv lw lx ly b">onChange</code>处理程序需要的不仅仅是来自<code class="fe lv lw lx ly b">MyInput</code>的事件对象呢？那里的<code class="fe lv lw lx ly b">onChange</code>处理程序不再有用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="b6a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是除了事件对象和知道元素的值正在改变之外，<code class="fe lv lw lx ly b">App</code>还需要什么呢，这是它已经知道的(因此在<code class="fe lv lw lx ly b">onChange</code>处理程序的执行上下文中)？</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="04ed" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">3.利用通过参数组成的原始处理程序</h1><p id="3302" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">直接访问<code class="fe lv lw lx ly b">input</code>元素本身非常有用。这意味着让一些<code class="fe lv lw lx ly b">ref</code>对象和事件对象一起传入是有用的。这很容易做到，因为<code class="fe lv lw lx ly b">onChange</code>处理程序是在这里编写的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="c593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们所要做的就是声明React钩子<code class="fe lv lw lx ly b">useRef</code>，将它附加到<code class="fe lv lw lx ly b">input</code>，并在一个对象内部将其作为第二个参数传递给<code class="fe lv lw lx ly b">onChangeProp</code>，这样调用者就可以访问它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="9c87" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">4.保持高阶函数处理程序和组合处理程序的签名相同</h1><p id="6cbf" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">通常，保持组合函数的签名与原始函数的签名相同是一个非常重要的实践。我的意思是在我们的例子中，两个<code class="fe lv lw lx ly b">onChange</code>处理程序的第一个参数都是为事件对象保留的。</p><p id="f2ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在组合函数时保持签名一致有助于避免不必要的错误和混淆。</p><p id="d630" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们交换参数的位置，就像这样…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/a09646195d17f3527aabf3c2dd5f023f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*E-OYyj4RDK2h2Yt1.jpg"/></div></div></figure><p id="7705" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…然后，当我们重用组件时，很容易忘记和弄糟这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="2fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们避免这种混乱时，您和其他开发人员的压力也会更小。</p><p id="e083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个很好的例子是，当您希望允许调用者提供尽可能多的事件处理程序，同时使应用程序能够正常运行时:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="0042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果其中至少有一个试图做一些特定于字符串的方法，比如<code class="fe lv lw lx ly b">.concat</code>，就会发生错误，因为签名是<code class="fe lv lw lx ly b">function(event, ...args)</code>而不是<code class="fe lv lw lx ly b">function(str, ...args)</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/a26b2effbc9b6764cd098beadf9562c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0IC1xczzxs7BEJPY.jpg"/></div></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="076c" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">5.避免引用和依赖事件处理程序(闭包)内部的状态</h1><p id="6603" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">这是一件非常危险的事情。</p><p id="90e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果做得好，在回调处理程序中处理状态应该没有问题。但是，如果你在某一点上犯了错误，并且引入了难以调试的无声错误，那么后果就开始吞噬你一天中额外的时间。</p><p id="46b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你正在做这样的事情…</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="f7b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…您可能应该重新访问这些处理程序，并检查您是否真的得到了正确的结果。</p><p id="898f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的<code class="fe lv lw lx ly b">input</code>的值为<code class="fe lv lw lx ly b">23</code>，我们在键盘上键入另一个<code class="fe lv lw lx ly b">3</code>，结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/c5ea9535c8025bf15a789a6dff157dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l_2I3Lmtnv2Gk1TZ.jpg"/></div></div></figure><p id="c1b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您理解JavaScript中的执行上下文，这是没有意义的，因为对<code class="fe lv lw lx ly b">setValue</code>的调用在移动到下一行之前已经执行完毕。</p><p id="506b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，实际上还是对的。JavaScript现在没有做错什么。它实际上是在做自己的事情。</p><p id="e8f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于渲染过程的完整解释，你可以阅读他们的文档。</p><p id="bfc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，简而言之，每当React进入一个新的渲染阶段时，它会对该渲染阶段的所有内容进行快照。在这个阶段，React本质上创建了一个React元素树，它代表了该时间点的树。</p><p id="82ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据定义，对<code class="fe lv lw lx ly b">setValue</code>的调用确实会导致重新渲染，但是这个渲染阶段是在未来的某个时间点。这就是为什么在<code class="fe lv lw lx ly b">setValue</code>完成执行后状态<code class="fe lv lw lx ly b">value</code>仍然是<code class="fe lv lw lx ly b">23</code>的原因，因为那个时间点的执行是特定于那个渲染的，有点像拥有他们自己生活的小世界。</p><p id="9210" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript中执行上下文的概念是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/701130eecb2cddc5190bb37b224431a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fNZgZ921kG2PbgwG.jpg"/></div></div></figure><p id="b9ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的示例中，这是React的渲染阶段(您可以将此视为React拥有自己的执行上下文):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/f92aedfc1f9365dfe02edee09759ed9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*leQ8OMwT_KRVfrI_.jpg"/></div></div></figure><p id="6d9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说完这些，我们再来看看我们对<code class="fe lv lw lx ly b">setCollapsed</code>的调用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/cbd76e0559b03c4de0cfbef34512a44f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/0*50n1lBrg8ZE1QOSp.jpg"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/25667f1d2fe8c059a9ce522ef9ad7540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/0*1pvcM_LkiQuZjQLy.jpg"/></div></figure><p id="893c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这都发生在同一个渲染阶段，所以这就是为什么<code class="fe lv lw lx ly b">collapsed</code>仍然是<code class="fe lv lw lx ly b">true</code>而<code class="fe lv lw lx ly b">person</code>被作为<code class="fe lv lw lx ly b">null</code>传递。当整个组件重新呈现时，下一个呈现阶段的值将代表上一个阶段的值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/27bb9d3dd0cefd660440adbf00d0237b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_N8aID4h8SI9KTsYAx73MQ.jpeg"/></div></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="b423" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结论</h1><p id="c948" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">本文到此结束。我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>