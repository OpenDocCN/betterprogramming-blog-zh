<html>
<head>
<title>The Future of Date and Time in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中日期和时间的未来</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-future-of-date-and-time-in-javascript-e1772c7976c?source=collection_archive---------11-----------------------#2020-08-05">https://betterprogramming.pub/the-future-of-date-and-time-in-javascript-e1772c7976c?source=collection_archive---------11-----------------------#2020-08-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7c28" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">新的时态API可以在不久的将来消除对第三方库的需求</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ed28c8e62dfbc8ab4ae06bdeb01d5192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8vG1lMkv7rhIAQ0K"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">凯文·Ku在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="b6cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数JavaScript开发人员都遇到过一个长期的棘手问题，那就是<code class="fe ls lt lu lv b">Date</code>对象。尝试做除了最简单的日期操作之外的任何事情都会让你很快接触到第三方库，比如<a class="ae kv" href="https://momentjs.com/" rel="noopener ugc nofollow" target="_blank"> Moment.js </a>或一长串为减轻这种痛苦而开发的其他库。</p><p id="2a07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Maggie Pint的博客文章中，她概述了T1物体的历史以及它是如何形成的。早在1995年，Brendan Eich有十天的时间来创建JavaScript并将其放入Netscape。有人可能会说十天时间足够了——毕竟，有人说上帝在六天内创造了天地，但在编程领域，在十天内创造一门新语言确实是一项艰巨的任务。</p><p id="e35a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据命令，布兰登被告知要“让它像Java一样”，因此复制了现有的<code class="fe ls lt lu lv b">java.Util.Date</code>实现。不幸的是，对于JavaScript社区来说，这种实现非常糟糕，早在1997年的Java 1.1中，它的大部分就被弃用和替换了。然而，20多年后，JavaScript社区仍然与API共存。</p><p id="6cac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多年来，我在需要的时候求助于Moment.js(双关语)，从npm的统计数据来看，它的周下载量超过了1200万，和以前一样受欢迎。有一段时间，我切换到<a class="ae kv" href="https://day.js.org/en/" rel="noopener ugc nofollow" target="_blank"> Day.js </a>以获得不可变API的好处，但是缺乏对时区的内置支持迫使我再次切换，现在<a class="ae kv" href="https://moment.github.io/luxon/" rel="noopener ugc nofollow" target="_blank"> Luxon </a>是城里的新库。有了可链接的、不可变的、方便的API和对时区的适当支持，在JavaScript中处理日期和时间不再像过去那样痛苦。</p><p id="651d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在过去的几年中，我们已经看到JavaScript为以前需要外部库的东西添加了本地支持——例如，使用以前需要像<a class="ae kv" href="http://bluebirdjs.com/" rel="noopener ugc nofollow" target="_blank"> bluebird </a>这样的库的承诺。现在看来，在不太遥远的将来，可能也会有一个日期和时间的无图书馆体验。</p><p id="9a61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在一份新的<a class="ae kv" href="https://tc39.es/proposal-temporal/" rel="noopener ugc nofollow" target="_blank">规范草案</a>中，技术委员会TC39已经将重点放在解决<code class="fe ls lt lu lv b">Date</code>对象的许多问题上。新提案旨在解决时区支持、不可靠的解析器、可变的日期、笨拙的API以及当今存在的一系列其他问题。有些问题，比如时区支持，可以通过用新方法扩展<code class="fe ls lt lu lv b">Date</code>对象来解决。</p><p id="417a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，如果不在JavaScript中引入突破性的变化，可变性和解析就无法修复，这是TC39努力避免的，因为它可能会破坏现有的网站。他们没有修复现有的<code class="fe ls lt lu lv b">Date</code>对象，而是提出了一个全新的<code class="fe ls lt lu lv b">Temporal</code> API，旨在解决<code class="fe ls lt lu lv b">Date</code>的许多缺陷，同时也引入了许多新的便捷功能。</p><p id="0b4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该提案目前处于第二阶段，根据<a class="ae kv" href="https://tc39.es/process-document/" rel="noopener ugc nofollow" target="_blank"> TC39流程</a>，这意味着:“委员会期望该特性得到开发并最终包含在标准中。”</p><p id="2710" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，该提案仍然是一个草案，突破性的变化可能会被引入作为正在进行的审查过程的一部分。本文将着眼于截至今天(2020年7月)提案中定义的API，您应该意识到，从现在到这个API最终应用到浏览器之间，事情可能会发生变化。</p><p id="4a96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">废话少说，让我们看看代码吧！</p><p id="e20d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章仅仅触及了新提议的表面，并强调了<code class="fe ls lt lu lv b">Date</code>的一些缺陷是如何被解决的。这个提议增加了一堆额外的特性，我强烈建议您看一下<a class="ae kv" href="https://tc39.es/proposal-temporal/docs/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>以获得所有类和方法的详尽列表。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="38a6" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">日期时间与绝对时间</h1><p id="90e9" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">旧的<code class="fe ls lt lu lv b">Date</code>对象表示时间上的单个时刻，并在内部存储为一个<code class="fe ls lt lu lv b">Number</code>，表示从UTC的1970年1月1日开始的毫秒数，也称为<a class="ae kv" href="https://en.wikipedia.org/wiki/Unix_time" rel="noopener ugc nofollow" target="_blank"> Unix纪元</a>。在新的提议中，一个单独的时刻被称为<code class="fe ls lt lu lv b">Temporal.Absolute</code>。根据<a class="ae kv" href="https://tc39.es/proposal-temporal/docs/absolute.html" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="na nb nc"><p id="d61b" class="kw kx nd ky b kz la jr lb lc ld ju le ne lg lh li nf lk ll lm ng lo lp lq lr ij bi translated">“A <code class="fe ls lt lu lv b">Temporal.Absolute</code>是绝对时间点，精度以纳秒为单位。没有时区或日历信息。因此<code class="fe ls lt lu lv b">Temporal.Absolute</code>没有日、月甚至小时的概念。”</p></blockquote><p id="ae90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">伴随<code class="fe ls lt lu lv b">Temporal.Absolute</code>的是<code class="fe ls lt lu lv b">Temporal.DateTime</code>，其在<a class="ae kv" href="https://tc39.es/proposal-temporal/docs/datetime.html" rel="noopener ugc nofollow" target="_blank">文档</a>中定义为:</p><blockquote class="na nb nc"><p id="1a67" class="kw kx nd ky b kz la jr lb lc ld ju le ne lg lh li nf lk ll lm ng lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Temporal.DateTime</code>代表日历日期和挂钟时间，精确到纳秒，没有任何时区。</p></blockquote><p id="f0c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，新的API区分了日常使用中时间概念的表达方式和绝对时间点。<code class="fe ls lt lu lv b">Temporal.DateTime</code>描述日历中的日期和时钟上显示的时间，但是，根据您所处的位置，完全相同的日历日期和时钟时间可能指不同的时间点<code class="fe ls lt lu lv b">Temporal.Absolute</code>(基于您所在的时区)。这让我们想到了提案中的另一个新概念，即<code class="fe ls lt lu lv b">Temporal.TimeZone</code>，在<a class="ae kv" href="https://tc39.es/proposal-temporal/docs/timezone.html" rel="noopener ugc nofollow" target="_blank">文档</a>中描述为:</p><blockquote class="na nb nc"><p id="3dda" class="kw kx nd ky b kz la jr lb lc ld ju le ne lg lh li nf lk ll lm ng lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Temporal.TimeZone</code>是时区的表示:或者是<a class="ae kv" href="https://www.iana.org/time-zones" rel="noopener ugc nofollow" target="_blank"> IANA时区</a>，包括关于时区的信息，例如在特定时间本地时间和UTC之间的偏差，以及夏令时(DST)的变化；或者只是没有夏令时的特定UTC时差。</p></blockquote><p id="f8ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于<code class="fe ls lt lu lv b">Temporal.DateTime</code>和<code class="fe ls lt lu lv b">Temporal.Absolute</code>都不包含任何时区信息，因此需要一个<code class="fe ls lt lu lv b">Temporal.TimeZone</code>对象在两者之间进行转换。</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="7e42" class="nl me iq lv b gy nm nn l no np">// Create a DateTime<br/>const datetime = Temporal.DateTime.from('2020-07-20T13:37')</span><span id="d7fe" class="nl me iq lv b gy nq nn l no np">// Create a TimeZone to use for convertion<br/>const tz = new Temporal.TimeZone('Europe/Stockholm')</span><span id="6ffe" class="nl me iq lv b gy nq nn l no np">// Convert to Absolute<br/>datetime.toAbsolute(tz) // =&gt; Temporal.Absolute &lt;2020-07-20T11:37Z&gt;</span></pre><p id="0bc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显式定义时区，而不是像<code class="fe ls lt lu lv b">Date</code>那样隐式使用主机系统的本地时区，应该可以消除<code class="fe ls lt lu lv b">Date</code>对象的一些不确定性和混乱。将<code class="fe ls lt lu lv b">DateTime</code>和<code class="fe ls lt lu lv b">Absolute</code>分开也会使日期的处理和操作变得更加容易，稍后我们会看到更多。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="6476" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">日期和时间</h1><p id="f8f9" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在提议中，<code class="fe ls lt lu lv b">Temporal.DateTime</code>是携带人类可读时间信息的类中最通用和最完整的，因为它包含了精确的日期和时间。然而，当不需要完整信息时，还有一些只携带部分信息的类是有用的。<code class="fe ls lt lu lv b">Temporal.Date</code>、<code class="fe ls lt lu lv b">Temporal.Time</code>、<code class="fe ls lt lu lv b">Temporal.YearMonth</code>和<code class="fe ls lt lu lv b">Temporal.MonthDay</code>都比<code class="fe ls lt lu lv b">Temporal.DateTime</code>携带的信息少。</p><p id="193c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，<code class="fe ls lt lu lv b">Temporal.MonthDay</code>可以用来表示每年重复发生的事件。然后可以通过添加年份部分将其转换为<code class="fe ls lt lu lv b">Temporal.Date</code>。</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="81ca" class="nl me iq lv b gy nm nn l no np">const christmasEve = new Temporal.MonthDay(12, 24)</span><span id="c9d9" class="nl me iq lv b gy nq nn l no np">christmasEve.toDateInYear(2020) // =&gt; Temporal.Date &lt;2020-12-24&gt;<br/>christmasEve.toDateInYear(2030) // =&gt; Temporal.Date &lt;2030-12-24&gt;</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="c7cb" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">不变</h1><p id="97bf" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">如果不小心使用，<code class="fe ls lt lu lv b">Date</code>对象的可变性很容易造成意想不到的意外:</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="ff44" class="nl me iq lv b gy nm nn l no np">const christmas = new Date(’2020–12–24’)<br/>const nextChristmas = new Date(christmas.setYear(2021))</span><span id="45dc" class="nl me iq lv b gy nq nn l no np">// We've modified the initial object by accident<br/>christmas.toISOString() // =&gt; 2021-12-24T00:00:00Z</span></pre><p id="6bdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们想通过简单地改变年份来创建一个新的带有next Christmas的<code class="fe ls lt lu lv b">Date</code>对象，但是同时，我们修改了初始实例，因为<code class="fe ls lt lu lv b">Date</code>对象是可变的。此外，JavaScript中的对象是通过引用传递的，而作为一个对象，<code class="fe ls lt lu lv b">Date</code>当您开始将<code class="fe ls lt lu lv b">Date</code>实例作为参数传递给其他函数时，您可能会非常痛苦。你传递给你的<code class="fe ls lt lu lv b">Date</code>的任何函数都有可能在你不知道的情况下改变你的日期，这反过来会引入讨厌的难以发现的错误。</p><p id="7c8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">新的<code class="fe ls lt lu lv b">Temporal</code> API是不可变的，这意味着所有方法都返回一个新的对象，而不是改变现有的对象。使用新的API执行上述示例的等效操作是安全的。</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="e879" class="nl me iq lv b gy nm nn l no np">const christmas = Temporal.DateTime.from('2020–12–24')<br/>const nextChristmas = christmas.with({ year: 2021 })</span><span id="dec6" class="nl me iq lv b gy nq nn l no np">christmas.toString() // =&gt; 2020-12-24T00:00:00Z<br/>nextChristmas.toString() // =&gt; 2021-12-24T00:00:00Z</span></pre><p id="d9f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使我们使用<code class="fe ls lt lu lv b">christmas</code>变量作为起点，<code class="fe ls lt lu lv b">.with()</code>方法也将返回一个新的<code class="fe ls lt lu lv b">DateTime</code>对象，保持原来的<code class="fe ls lt lu lv b">christmas</code>变量不变。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="7001" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">计算</h1><p id="7a6f" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">试图修改一个<code class="fe ls lt lu lv b">Date</code>对象一直是一个丑陋而繁琐的操作。在今天的日期上增加一天会迫使你这样做:</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="b663" class="nl me iq lv b gy nm nn l no np">// Create Date<br/>const date = new Date()<br/><br/>// Add a day by setting the date to the current date + 1<br/>date.setDate(date.getDate() + 1)<!-- --> </span></pre><p id="320a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不太优雅。幸运的是，<code class="fe ls lt lu lv b">Temporal</code> API使这变得更容易，可读性更强:</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="e6aa" class="nl me iq lv b gy nm nn l no np">const tomorrow = Temporal.now.dateTime().plus({ days: 1 })</span></pre><p id="c1f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<code class="fe ls lt lu lv b">Date</code>对象的方法相比，新的<code class="fe ls lt lu lv b">.plus()</code>和<code class="fe ls lt lu lv b">.minus()</code>方法使得日期和时间的计算更加一致。</p><p id="49f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">.plus()</code>和<code class="fe ls lt lu lv b">.minus()</code>方法都接受一个<code class="fe ls lt lu lv b">Temporal.Duration</code>对象，这是<code class="fe ls lt lu lv b">Temporal</code>引入的另一个新概念。<a class="ae kv" href="https://tc39.es/proposal-temporal/docs/duration.html" rel="noopener ugc nofollow" target="_blank">文档</a>对<code class="fe ls lt lu lv b">Temporal.Duration</code>的描述如下:</p><blockquote class="na nb nc"><p id="b0f0" class="kw kx nd ky b kz la jr lb lc ld ju le ne lg lh li nf lk ll lm ng lo lp lq lr ij bi translated">"一个<code class="fe ls lt lu lv b">Temporal.Duration</code>代表一个不可变的持续时间，可以用在日期/时间算法中."</p></blockquote><p id="3a14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个<code class="fe ls lt lu lv b">Temporal.Duration</code>可以被声明为一个对象，因此可以包含多个键。在前一个示例的基础上，向今天的日期添加一年零一天也同样简单:</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="6021" class="nl me iq lv b gy nm nn l no np">const future = Temporal.now.dateTime().plus({ years: 1, days: 1 })</span></pre><p id="5bd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">新的API还提供了一个<code class="fe ls lt lu lv b">.with()</code>方法，可用于覆盖日期时间的某些部分，而不是加减:</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="a5fc" class="nl me iq lv b gy nm nn l no np">const future = Temporal.now.dateTime().with({ year: 2050 })</span></pre><p id="89e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这三种方法，日期和时间的计算就方便多了。这个API既可读又好记，很像Moment.js等流行库的API。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="9fc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想试验一下<code class="fe ls lt lu lv b">Temporal</code> API，你现在可以通过npm使用官方的<a class="ae kv" href="https://github.com/tc39/proposal-temporal/tree/main/polyfill" rel="noopener ugc nofollow" target="_blank"> polyfill </a>。请注意，它不稳定，不建议用于生产。</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="bd57" class="nl me iq lv b gy nm nn l no np">npm install proposal-temporal</span></pre><p id="398b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并在您的代码中使用它:</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="a7e6" class="nl me iq lv b gy nm nn l no np">const { Temporal } = require('proposal-temporal')</span><span id="5a12" class="nl me iq lv b gy nq nn l no np">const now = Temporal.now.dateTime()</span></pre><p id="1ebc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不想开始一个新项目只是为了试验一下，那么<a class="ae kv" href="https://tc39.es/proposal-temporal/docs/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>默认情况下也会加载polyfill，所以直接从你的浏览器的devtools控制台尝试代码。</p><p id="1789" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你和<code class="fe ls lt lu lv b">Temporal</code>一起玩，TC39想要你对提议的反馈，并且有一个<a class="ae kv" href="https://docs.google.com/forms/d/e/1FAIpQLSeYdvnDZZS6tKn18jiomfN7u_rq-_-_BqOevTzAcfgE3J4kHA/viewform" rel="noopener ugc nofollow" target="_blank">调查</a>给你。你也可以在GitHub 上为你遇到的任何bug打开新的<a class="ae kv" href="https://github.com/tc39/proposal-temporal/issues" rel="noopener ugc nofollow" target="_blank">问题。提案越早进入第3阶段，浏览器就能越早开始实现本地支持。</a></p><p id="3792" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对这篇文章有想法或者想讨论一下<code class="fe ls lt lu lv b">Temporal</code> API，我很乐意在评论中听到你的意见。</p><p id="b2d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>