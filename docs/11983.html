<html>
<head>
<title>A Frameworkless Store In TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的无框架存储</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-frameworkless-store-in-typescript-84baaa00b901?source=collection_archive---------12-----------------------#2022-05-02">https://betterprogramming.pub/a-frameworkless-store-in-typescript-84baaa00b901?source=collection_archive---------12-----------------------#2022-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="76cf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你曾经开发过API、服务和状态管理与核心完全分离的应用吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a31296a2ed15833bfe89cb68a9154959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A0PjJsRUHd82_1jD"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@pinewatt?utm_source=Papyrs&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">派恩瓦特</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="e830" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">使用框架有不可否认的优势(React、Angular、Svelte等。)进行前端开发，但也有不可否认的缺点。</p><p id="501a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">跨各种技术的项目之间的互操作性和兼容性通常是一个问题，对于长期应用程序和在团队之间共享资源的公司来说，这是一个必须要考虑的问题。</p><p id="274f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> Web组件</a>——一套允许你创建可重用的不可知定制元素的不同技术——是挑战的一个常见关键。然而，它们的使用通常仅限于设计系统或富UI组件的创建。</p><p id="59cb" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">根据我的经验，很少有公司在其前端应用程序中明确地将表示层与业务层分离。</p><p id="eb3c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">老实说，您是否经常开发API和服务层与项目完全分离的应用程序？您曾经将应用程序的状态管理提取到可重用的库中吗？​</p><p id="6c5b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这就是我在开发<a class="ae ky" href="https://papy.rs/" rel="noopener ugc nofollow" target="_blank"> Papyrs </a>时寻求解决的问题——一个开源、隐私优先、去中心化的博客平台，100%生活在链上。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="1889" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="b963" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">在这篇博文中，我展示了一个架构，它将两个应用程序的业务和状态管理逻辑分开，这两个应用程序是用两种不同的技术开发的(<a class="ae ky" href="https://kit.svelte.dev/" rel="noopener ugc nofollow" target="_blank"> Sveltekit </a>和<a class="ae ky" href="https://stenciljs.com/" rel="noopener ugc nofollow" target="_blank"> Stencil </a>)。<strong class="li iu">T13】</strong></p><p id="031e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">之后，我展示了我在TypeScript中开发的商店的有效框架代码，以及它如何集成到这两个应用程序中。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="1446" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">体系结构</h1><p id="e8f2" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">Papyrs是<a class="ae ky" href="https://deckdeckgo.com/" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>的衍生项目。两者都是web编辑器，应该在<a class="ae ky" href="https://dfinity.org/" rel="noopener ugc nofollow" target="_blank"> DFINITY </a>的互联网计算机上保存和发布数据——也就是说，他们的目标不同，但他们的架构应该相同。​</p><p id="3c77" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">因为DeckDeckGo是去年移植到互联网计算机上的——当时还没有上线——同时保持向后兼容Google Firebase。API层已经在独特的库中实现。</p><p id="39b7" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">然而，当我开始实现Papyrs时，业务逻辑和状态管理仍然是在DeckDeckGo的应用程序中实现的。</p><p id="19f4" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">因此，我不得不问自己是否渴望从头开始重新实现这些特性(😅)或者其他解决方案——比如重用和共享库——是否是一个可靠的选择。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/66974a0909e3ab3b3cfda4859151828b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qPciH4OzgYOGtCfR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">纸莎草发展初期的建筑</p></figure><p id="fadf" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当您阅读本文时，我假设您知道结果是什么:我提取并分离了特性，以便在两个项目中重用完全相同的代码。</p><p id="ddd8" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">虽然提取业务逻辑是一个相对简单的操作——大部分是无状态的函数——但是提取商店就有点复杂了。幸运的是，我最终找到了一个解决方案——我将在下一章分享——它混合了不可知的可写状态管理和可读存储。</p><p id="34ba" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">基本上，当应用程序复制这些值来更新UI时，库的存储负责保存状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/e87f6e96d25fb73b6f06bb9acc49ed0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jnTyjqh5-cIDiFPb"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">DeckDeckGo和Papyrs共享的结果架构</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="078a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">无框架代码</h1><p id="8c32" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">这个商店就是一个普通的<code class="fe nb nc nd ne b">class</code>，它包含一个值并公开<code class="fe nb nc nd ne b">set</code>和<code class="fe nb nc nd ne b">get</code>函数。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="2d13" class="nj md it ne b gy nk nl l nm nn">export class Store&lt;T&gt; {<br/>  constructor(private value: T) {<br/>  }<br/><br/>  set(value: T) {<br/>    this.value = value;<br/>  }<br/><br/>  get(): T {<br/>    return this.value;<br/>  }<br/>}</span></pre><p id="f025" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">商店还应该传播这些更改——当值被修改时，应该让消费者知道。因此，它应该提供一种注册回调的方法。</p><p id="4b15" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">此外，当使用者注册一个侦听器时，它还应该能够停止侦听更改——即取消注册回调。</p><p id="5a31" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这就是为什么商店为每个注册的回调分配一个惟一的ID。由于有了这些标识符，就有可能返回一个可以取消侦听器订阅的函数。</p><p id="53ad" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为了生成一个惟一的标识符，我使用了<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" rel="noopener ugc nofollow" target="_blank">符号</a>——一个浏览器的内置对象，它的构造函数返回一个保证惟一的<code class="fe nb nc nd ne b">symbol</code>。</p><p id="c74e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><code class="fe nb nc nd ne b">subscribe</code>函数还调用被注册的回调函数。这样，消费者就可以立即收到当前值，而不必等待下一次更新。</p><p id="554c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">最后，setter <code class="fe nb nc nd ne b">propagate</code>将新值传递给所有注册的回调。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="ac94" class="nj md it ne b gy nk nl l nm nn">interface StoreCallback&lt;T&gt; {<br/>  id: Symbol;<br/>  callback: (data: T) =&gt; void;<br/>}<br/><br/>export class Store&lt;T&gt; {<br/>  private callbacks: StoreCallback&lt;T&gt;[] = [];<br/><br/>  constructor(private value: T) {<br/>  }<br/><br/>  set(value: T) {<br/>    this.value = value;<br/><br/>    this.propagate(value);<br/>  }<br/><br/>  get(): T {<br/>    return this.value;<br/>  }<br/><br/>  private propagate(data: T) {<br/>    this.callbacks.forEach(({callback}: StoreCallback&lt;T&gt;) =&gt;<br/>      callback(data)<br/>    );<br/>  }<br/><br/>  subscribe(<br/>    callback: (data: T) =&gt; void<br/>  ): () =&gt; void {<br/>    const callbackId: Symbol = Symbol();<br/><br/>    this.callbacks.push({id: callbackId, callback});<br/><br/>    callback(this.value);<br/><br/>    return () =&gt;<br/>      (this.callbacks = this.callbacks.filter(<br/>        ({id}: StoreCallback&lt;T&gt;) =&gt; id !== callbackId<br/>      ));<br/>  }<br/>}</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="bd07" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">演示</h1><p id="a4e6" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">为了尝试上述通用状态管理，我们可以创建一个虚拟商店和一个消费者。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="689e" class="nj md it bd me no np dn mi nq nr dp mm lp ns nt mo lt nu nv mq lx nw nx ms ny bi translated">商店</h2><p id="9b1c" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">下面的存储包含一个用<code class="fe nb nc nd ne b">null</code>初始化的对象<code class="fe nb nc nd ne b">Doc</code>。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="3233" class="nj md it ne b gy nk nl l nm nn">import {Store} from './store';<br/><br/>export interface Doc {<br/>  title: string;<br/>}<br/><br/>export const docStore: Store&lt;Doc | null&gt; = new Store&lt;Doc | null&gt;(null);</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="a842" class="nj md it bd me no np dn mi nq nr dp mm lp ns nt mo lt nu nv mq lx nw nx ms ny bi translated">消费者</h2><p id="92f7" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">消费者——一个测试脚本——创建两个订阅者，设置第一个值“hello ”,取消订阅第一个侦听器，并设置一个新值“world”。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="afc3" class="nj md it ne b gy nk nl l nm nn">import {type Doc, docStore} from './doc.store';<br/><br/>const print = ({<br/>  subscriber,<br/>  value<br/>}: {<br/>  subscriber: string;<br/>  value: Doc | null;<br/>}) =&gt; console.log(`${subscriber}:`, value);<br/><br/>const unsubscribe1 = docStore.subscribe(<br/>  (value: Doc | null) =&gt; print({subscriber: 'Subscribe #1', value})<br/>);<br/>const unsubscribe2 = docStore.subscribe(<br/>  (value: Doc | null) =&gt; print({subscriber: 'Subscribe #2', value})<br/>);<br/><br/>docStore.set({title: 'hello'});<br/>console.log('Get:', docStore.get());<br/><br/>unsubscribe1();<br/><br/>docStore.set({title: 'world'});<br/>console.log('Get:', docStore.get());</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="638f" class="nj md it bd me no np dn mi nq nr dp mm lp ns nt mo lt nu nv mq lx nw nx ms ny bi translated">试验</h2><p id="e638" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">如果我们在终端中运行上述脚本，我们将注意到以下内容:</p><ul class=""><li id="b975" class="nz oa it li b lj lk lm ln lp ob lt oc lx od mb oe of og oh bi translated">订户立即获得当前值</li><li id="d720" class="nz oa it li b lj oi lm oj lp ok lt ol lx om mb oe of og oh bi translated">第一个订户已成功注销</li><li id="98d4" class="nz oa it li b lj oi lm oj lp ok lt ol lx om mb oe of og oh bi translated">商店保留该值并触发已注册的订户</li></ul><p id="b39e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们可以断定一切都如预期的那样工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/0e0dbb50c8558fed730462acd4cd9141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_RQ94cuu0YA1rYsg"/></div></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="b4eb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">包装</h1><p id="2b52" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">我试图将业务逻辑从我的应用程序中完全分离出来。如果包含这些存储的库能够完全访问这些存储，那么应用程序就能够写入值。</p><p id="8556" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为了解决这个需求，我的库只公开了存储的接口和订户。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="f82b" class="nj md it ne b gy nk nl l nm nn">export {type Doc} from './doc.store';<br/><br/>export const docSubscribe = (<br/>  callback: (doc: Doc<strong class="ne iu"><em class="oo"> </em></strong>| null) =&gt; void<br/>): (() =&gt; void) =&gt; docStore.subscribe(callback);</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7ef1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">用法</strong></h1><p id="c750" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">上述解决方案是不可知的。它是用TypeScript编写的，编译成JavaScript。这就是为什么它可以集成到任何现代框架中，甚至可以不集成。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="dc21" class="nj md it bd me no np dn mi nq nr dp mm lp ns nt mo lt nu nv mq lx nw nx ms ny bi translated">苗条的</h2><p id="3c16" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated"><a class="ae ky" href="https://svelte.dev/tutorial/readable-stores" rel="noopener ugc nofollow" target="_blank">可读商店</a>是一个有趣的模式，是由苗条开箱提供的。在前几章中介绍的库的存储可以在一个函数中进行，这个函数可以写入应用程序的存储，但是不能在其他地方调用。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="749c" class="nj md it ne b gy nk nl l nm nn">import { readable } from 'svelte/store';<br/>import { type Doc, docSubscribe } from 'state-mgmt';<br/><br/>const start = (set: (value: Doc | null) =&gt; void) =&gt; {<br/>  const unsubscriber: () =&gt; void = docSubscribe(<br/>    (doc: Doc | null) =&gt; set(doc)<br/>  );<br/><br/>  return function stop() {<br/>    unsubscriber();<br/>  };<br/>};<br/><br/>export const doc = readable&lt;Doc | null&gt;(null, start);</span></pre><p id="c57f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">每当库在状态管理中设置一个值时，订户被调用，当前值被复制到Svelte存储中。最终，用户界面被更新。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="56a9" class="nj md it bd me no np dn mi nq nr dp mm lp ns nt mo lt nu nv mq lx nw nx ms ny bi translated">模板</h2><p id="ea3b" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">开箱即用的<a class="ae ky" href="https://github.com/ionic-team/stencil-store" rel="noopener ugc nofollow" target="_blank"> @stencil/store </a>是可写的。幸运的是——多亏了Philipp Mudra在模板的slack channel上分享的解决方案——可以用TypeScript <a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlytype" rel="noopener ugc nofollow" target="_blank">实用程序</a>将模板设为只读。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="a341" class="nj md it ne b gy nk nl l nm nn">import {createStore} from '@stencil/store';<br/>import { type Doc, docSubscribe } from 'state-mgmt';<br/><br/>interface DocStore {<br/>  doc: Doc | null;<br/>}<br/><br/>const {state} = createStore&lt;DocStore&gt;({doc: null});<br/><br/>docSubscribe((doc: Doc | null) =&gt; {<br/>  state.doc = doc;<br/>});<br/><br/>const readonlyState: Readonly&lt;typeof state&gt; = state;<br/><br/>export default {state: readonlyState};</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="0c0d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="50bc" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">在我看来，将所有业务逻辑和状态管理与应用程序完全分离是一件很酷的事情。</p><p id="a6c9" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果有一天我想为<a class="ae ky" href="https://papy.rs/" rel="noopener ugc nofollow" target="_blank">纸莎草纸</a>开发一个新的UI，我将能够快速完成，而不用担心任何逻辑。​</p><p id="c4cf" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">此外，该解决方案是可扩展的。我可以一遍又一遍地重复使用和复制同样的方法，直到我不再想在web3上开发新的应用程序。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="386f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">更多冒险，请在推特上关注我</p></div></div>    
</body>
</html>