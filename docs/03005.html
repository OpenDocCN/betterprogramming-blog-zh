<html>
<head>
<title>Functional Patterns to Carve Side-Effects Away From Logic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从逻辑中去除副作用的功能模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-patterns-to-carve-side-effects-away-from-logic-42158d9ef889?source=collection_archive---------14-----------------------#2020-01-14">https://betterprogramming.pub/functional-patterns-to-carve-side-effects-away-from-logic-42158d9ef889?source=collection_archive---------14-----------------------#2020-01-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c332" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用函数式编程提高代码的可测试性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bbeab94c7faad8882046e239f4bb50e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2RjNxLZloej2yTz6JtwkKQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@drew_beamer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">德鲁·比默</a>在<a class="ae kv" href="https://unsplash.com/s/photos/split?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9bfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能听说过单子，效果系统，或最终无标签，并反弹到上一页，认为这只是学术废话，几乎没有实用性。</p><p id="eb5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">公平地说，它们当然属于学习曲线更陡的概念，但它们仍然广泛适用。</p><p id="4776" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些背后都有一个共同的、非常简单的想法。这是贯穿函数式编程的一个反复出现的主题，尤其是在纯函数式编程语言中，如<a class="ae kv" href="https://www.haskell.org/" rel="noopener ugc nofollow" target="_blank"> Haskell </a>。</p><p id="1ebe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关键的概念是把你的程序分开，一边是逻辑，另一边是带有副作用的执行。</p><p id="01e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于JavaScript已经成为编程的通用语言，我想保持这种语言不可知，所以我们将通过一些例子来了解它。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="69d7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">使用依赖注入</h1><p id="df97" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在面向对象的世界中，可以用来消除某些代码副作用的一种广泛使用的技术是<a class="ae kv" href="https://www.freecodecamp.org/news/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f/" rel="noopener ugc nofollow" target="_blank">依赖注入</a>。</p><p id="5bbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有有副作用的代码都可以替换为对对象的函数或方法的调用，这些调用作为参数接收或在初始化时传递。</p><p id="ecef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它相当简单易懂，应该比后来的技术更受欢迎。虽然没有它们强大，但是依赖注入消耗了更少的花哨点，并且有助于控制复杂性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">dependencyInjection.js</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4503" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">将程序编码为一个值</h1><p id="192f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">一旦程序被编码成一个值，事情就变得有趣了。的确，价值观是可以分析和转化的。</p><p id="0316" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它打开了优化的大门，自动生成文档，或者在不直接修改程序的情况下为程序添加功能。例如，您可以向程序添加访问控制，同时让程序完全不知道它的存在。</p><p id="2a88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用程序代码因此是纯净的，因为它只返回一个没有任何副作用的值。解释器的作用是执行程序。我们本质上将代码分成两个(或更多)部分:</p><ul class=""><li id="f298" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated">一些将有效程序的描述作为一个值返回的纯代码。</li><li id="fe0e" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">可选地，一些函数转换程序。</li><li id="05fb" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">运行编码为值的程序的解释程序。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="273b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">顺序程序</h1><p id="d6b7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">下面是一个简单的例子，用户试图猜测一个数字。该程序由更简单的程序(<code class="fe nm nn no np b">print</code>、<code class="fe nm nn no np b">read</code>和<code class="fe nm nn no np b">pure</code>)组成，这些程序被编码为数值。</p><p id="5603" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们中的每一个都是带有一个<code class="fe nm nn no np b">action</code>的对象，一些特定于该动作的值以及在这个动作之后要采取的<code class="fe nm nn no np b">next</code>动作。注意<code class="fe nm nn no np b">next</code>是一个函数，它接受当前动作的结果并返回一个新程序。</p><p id="6490" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也可以定义这些程序的操作。例如，<code class="fe nm nn no np b">bind</code>获取一个程序和一个函数，该函数获取其结果并返回一个新的程序，然后将这两个程序组合成第三个程序。</p><p id="fc7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nm nn no np b">bind</code>遍历动作链，并通过调用给定的函数替换最后一个动作(a <code class="fe nm nn no np b">pure</code>)。注意递归发生在<code class="fe nm nn no np b">next</code>内部，这意味着它直到被调用才会发生，也就是说<code class="fe nm nn no np b">bind</code>是懒惰的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">sequentialActions.js</p></figure><p id="de03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于其顺序性，下一步只有在执行完当前步骤后才能知道。</p><p id="3069" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，根据用户输入，程序可以分支成不同的子程序。这限制了我们用这些价值观做什么。</p><p id="1e50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，在解释当前动作并将结果反馈给它的<code class="fe nm nn no np b">next</code>函数之前，我们无法分析下一个动作。这并不意味着我们不能用它做有趣的事情，我们将会看到更多。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0664" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">非顺序程序</h1><p id="9476" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果我们不需要一个接一个地执行动作，我们可以用一种仍然允许对程序进行静态分析的方式对程序进行编码，这种分析是在不运行代码的情况下进行的。</p><p id="ace8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个JSON解析器的简单例子。和以前一样，有一个名为<code class="fe nm nn no np b">pure</code>的基本程序，它只是返回一个常数。不同的是功能<code class="fe nm nn no np b">apply</code>而不是<code class="fe nm nn no np b">bind</code>。</p><p id="42a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nm nn no np b">apply</code>接受两个程序——前者返回一个函数，后者返回一个值——并返回一个运行这两个程序并将值应用于函数的新程序。</p><p id="e171" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过以这种方式组合程序，我们无需运行任何东西就可以访问子程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">nonSequentialActions.js</p></figure><p id="e293" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和前面的例子一样，有很多样板文件，用起来不太实用。当然还有改进的空间，但目标只是将程序的基本思想作为价值观来传达。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="fa13" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">测试</h1><p id="6b3c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这种结构的一个用例是使测试更容易。唯一需要的是另一个没有副作用的解释器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">testing.js</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f6d1" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">生成文档</h1><p id="1d15" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在非顺序程序的情况下，我们不必执行代码来分析它。这意味着我们可以做一些有趣的事情，比如自动生成文档。</p><p id="f304" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以我们之前的解析示例为例，我们可以为解析器生成JSON对象形式的文档。对于我们的例子，它将返回<code class="fe nm nn no np b">{ "database": { "port": "number", "username": "string" } }</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">生成文档. js</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6afe" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">与概念的关系</h1><p id="2744" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在函数世界中，在顺序程序的情况下，将使用<em class="nq">单子</em>——更具体地说是<em class="nq">自由单子</em>。</p><p id="34d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这非常接近我们的小游戏所做的，尽管Haskell中的<a class="ae kv" href="https://hackage.haskell.org/package/free" rel="noopener ugc nofollow" target="_blank"> free </a>等库提供的抽象会减轻许多样板文件。</p><p id="6a6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于像解析器这样的非顺序程序，一个非常类似的抽象是<em class="nq">应用函子</em>(或者仅仅是<em class="nq">应用</em>)和它的表亲<em class="nq">自由应用</em>。</p><p id="ed11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，依赖注入更接近于<em class="nq">最终无标签</em>方法。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1a06" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="af47" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">考虑到样板文件的数量和它们引入的复杂性，这里的示例在大多数实际情况下几乎没有实际用途，但是希望它们在不太混乱的情况下展示了这些构造背后的关键思想。</p><p id="6e0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将程序的定义从它们的解释中分离出来，允许我们在中间添加步骤，在解释之前转换程序。我们也可以有不同的解释器用于测试或静态分析(比如生成文档)。</p><p id="9e4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像Haskell这样的语言有语法糖和操作符，例如，利用单子和自由应用程序，非常方便(事实上，无处不在)。)</p><p id="46da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论你使用哪种语言，总有一种比这里介绍的更方便的方式来编码程序。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="ebca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢这样的故事，可以考虑成为媒体会员或者订阅。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7a4f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">进一步阅读</h1><ul class=""><li id="5508" class="my mz iq ky b kz mr lc ms lf nr lj ns ln nt lr nd ne nf ng bi translated"><a class="ae kv" href="https://www.freecodecamp.org/news/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f/" rel="noopener ugc nofollow" target="_blank">依赖注入的快速介绍</a>，Bhavya Karia在freeCodeCamp上。</li><li id="fe0c" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated"><a class="ae kv" href="https://curiosity-driven.org/monads-in-javascript" rel="noopener ugc nofollow" target="_blank">Javascript中的单子</a>，好奇心驱动。</li><li id="2492" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">Haskell库<a class="ae kv" href="https://hackage.haskell.org/package/free" rel="noopener ugc nofollow" target="_blank">免费</a>，Hackage。</li><li id="1615" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated"><a class="ae kv" href="https://gist.github.com/thoferon/a4e1ee37fc85c6237d3c4cf3826b7390" rel="noopener ugc nofollow" target="_blank">GitHub gist上这篇文章的代码</a>。</li></ul></div></div>    
</body>
</html>