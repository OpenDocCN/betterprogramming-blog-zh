<html>
<head>
<title>iOS 13 Applying Diffable Data Sources</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS 13应用不同的数据源</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/applying-diffable-data-sources-70ce65b368e4?source=collection_archive---------14-----------------------#2019-11-25">https://betterprogramming.pub/applying-diffable-data-sources-70ce65b368e4?source=collection_archive---------14-----------------------#2019-11-25</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="1930" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">再见reloadData()和performBatchUpdates()</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/6da668ce9c3408026fcbcebfec8bc727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aUiCUNjlvpJY05oF"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Robbie Noble 在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c9e6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">声明式编程在苹果2019年WWDC活动期间得到了苹果的全力支持。</p><p id="33b1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">无论是通过引入新的UI框架<a class="ae kz" href="https://developer.apple.com/xcode/swiftui/" rel="noopener ugc nofollow" target="_blank"> SwiftUI </a>，还是通过升级现有的UIKit框架，苹果都展示了声明式编程在推动iOS和macOS开发方面的力量。</p><p id="56d7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在UIKit的最新增强中，<a class="ae kz" href="https://medium.com/better-programming/ios-13-compositional-layouts-in-collectionview-90a574b410b8" rel="noopener">组合布局</a>和不同的数据源不仅看起来很有前途，而且也强烈表明UIKit框架不会很快消失。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="efb9" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">我们的目标</h1><ul class=""><li id="ac1b" class="mv mw iu lc b ld mx lg my lj mz ln na lr nb lv nc nd ne nf bi translated">理解对不同数据源的需求。</li><li id="906f" class="mv mw iu lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated">了解不同数据源和快照的工作原理。</li><li id="b4ca" class="mv mw iu lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated">在索引路径API中访问不同的数据源。</li></ul><p id="dd07" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我们将在iOS应用程序中使用<code class="fe nl nm nn no b">UITableView</code>实现不同的数据源。</p><p id="c957" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是，在我们深入研究不同数据源的复杂性之前，让我们先来看看设置表和集合视图的传统方式。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="5a4d" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">传统方法</h1><p id="deef" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">传统的插入数据源的方法需要符合<code class="fe nl nm nn no b">UITableViewDataSource</code>协议，并实现<code class="fe nl nm nn no b">numberOfItemsInSection</code>、<code class="fe nl nm nn no b">numberOfSections</code>、<code class="fe nl nm nn no b">cellForItemAt</code>方法。</p><p id="170b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这对于简单的<code class="fe nl nm nn no b">TableViews</code>和<code class="fe nl nm nn no b">CollectionViews</code>都很好，直到我们需要开始更新行。对于更新，两种方法<code class="fe nl nm nn no b">reloadData()</code>和<code class="fe nl nm nn no b">performBatchUpdates()</code>都有自己的问题。</p><p id="32b4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然<code class="fe nl nm nn no b">reloadData()</code>会破坏我们展示好的动画的机会，但是<code class="fe nl nm nn no b">performBatchUpdates()</code>如果不小心处理，很容易导致错误。</p><p id="edb7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">类似下面所示的错误在<code class="fe nl nm nn no b">performBatchUpdates()</code>中很常见:</p><pre class="kk kl km kn gu ns no nt nu aw nv bi"><span id="fbdf" class="nw me iu no b gz nx ny l nz oa">Terminating app due to uncaught exception ‘NSInternalInconsistencyException’,<br/>reason: ‘Invalid update: invalid number of items in section 0.<br/>The number of items contained in an existing section after the update <br/>must be equal to the number of items contained in that section before.</span></pre><p id="66a4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">很高兴，苹果带来了不同的数据源来代表我们解决这些错误。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="8c4c" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">不同的数据源——一个无错误的世界</h1><p id="3144" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">可区分的数据源通过处理类似同步的机制标志着向声明性范式的转变，自动更新更改，从而通过新的状态驱动方法使事情更不容易出错。</p><p id="9097" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过使用diffing工具，不同的数据源负责更新状态(当前和新)之间的<code class="fe nl nm nn no b">TableView</code>和收集视图行。</p><p id="ad51" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">类别<code class="fe nl nm nn no b">NSDiffableDataSourceSnapshot</code>代表用户界面的状态。要更新一个<code class="fe nl nm nn no b">TableView</code>或<code class="fe nl nm nn no b">CollectionView</code>，我们只需要在<code class="fe nl nm nn no b">UITableViewDiffableDataSource</code>上点击<code class="fe nl nm nn no b">apply(snapshot)</code>，它会为你处理更新和动画。</p><p id="bf1c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">也可以从后台线程执行<code class="fe nl nm nn no b">apply</code>方法。这样做，需要O(n)时间的差异发生在后台，之后更改被更新到主线程。这加快了更新过程。</p><p id="1613" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">苹果建议在调用<code class="fe nl nm nn no b">apply</code>方法时坚持使用后台或主线程。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ob"><img src="../Images/e6bc570af923238e47a2e9ff752a50ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ddls6Nr1rg6aTDiCzfwLwA.png"/></div></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="b05f" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">设置不同的数据源</h1><p id="cf76" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">为了让动画和更新工作，我们首先需要在<code class="fe nl nm nn no b">UITableView</code>上设置我们的<code class="fe nl nm nn no b">UITableViewDiffableDataSource</code>。</p><p id="5fe1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下代码创建一个数据源，并将其设置在<code class="fe nl nm nn no b">UITableView</code>实例上:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oc od l"/></div></figure><p id="0737" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">快照不依赖索引路径来更新项目。相反，它依赖于类型安全的唯一标识符来唯一地标识其节和项。</p><p id="28e6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要生成这些唯一标识符，切片和项目必须符合<code class="fe nl nm nn no b">Hashable</code>协议。</p><p id="4c97" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然上面代码中的<code class="fe nl nm nn no b">Sections</code>是隐式符合<code class="fe nl nm nn no b">Hashable</code>的枚举，但是<code class="fe nl nm nn no b">Movies</code>结构需要实现<code class="fe nl nm nn no b">Hashable</code>协议，如下面代码所示</p><pre class="kk kl km kn gu ns no nt nu aw nv bi"><span id="814e" class="nw me iu no b gz nx ny l nz oa">struct Movies: Hashable {</span><span id="3886" class="nw me iu no b gz oe ny l nz oa">let identifier: UUID = UUID()<br/>let name: String</span><span id="1586" class="nw me iu no b gz oe ny l nz oa">func hash(into hasher: inout Hasher) {<br/>return hasher.combine(identifier)<br/>}</span><span id="10c7" class="nw me iu no b gz oe ny l nz oa">static func == (lhs: Movies, rhs: Movies) -&gt; Bool {<br/>return lhs.identifier == rhs.identifier<br/>}</span><span id="91d7" class="nw me iu no b gz oe ny l nz oa">}</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="72ff" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">填充不同的数据源</h1><p id="27f3" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">要更新或填充数据源，我们只需在快照实例上添加必要的部分及其项目，然后<code class="fe nl nm nn no b">apply</code>它。下面的代码展示了如何做到这一点。</p><pre class="kk kl km kn gu ns no nt nu aw nv bi"><span id="9b65" class="nw me iu no b gz nx ny l nz oa">func updateDataSource(animated: Bool) {</span><span id="b461" class="nw me iu no b gz oe ny l nz oa">var snapshot = NSDiffableDataSourceSnapshot&lt;Section, Movies&gt;()</span><span id="51ec" class="nw me iu no b gz oe ny l nz oa">snapshot.appendSections(Section.allCases)</span><span id="91cf" class="nw me iu no b gz oe ny l nz oa">snapshot.appendItems([Movies(name: "Inception")], toSection: .one)<br/>snapshot.appendItems([Movies(name: "War")], toSection: .one)<br/>snapshot.appendItems([Movies(name: "Departed")], toSection: .one)</span><span id="9279" class="nw me iu no b gz oe ny l nz oa">snapshot.appendItems([Movies(name: "Departed")], toSection: .two)</span><span id="fb56" class="nw me iu no b gz oe ny l nz oa">dataSource.apply(snapshot, animatingDifferences: animated)</span><span id="129d" class="nw me iu no b gz oe ny l nz oa">}</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="cde8" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">访问数据</h1><p id="40ae" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">为了更新或删除<code class="fe nl nm nn no b">TableView</code>中的数据，我们需要获取当前快照，这是通过调用<code class="fe nl nm nn no b">dataSource.snapshot()</code>完成的。</p><p id="fb48" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要访问不同数据源中具有基于索引路径的API的项目，我们需要以下列方式将索引路径转换为项目标识符:</p><pre class="kk kl km kn gu ns no nt nu aw nv bi"><span id="59d2" class="nw me iu no b gz nx ny l nz oa">dataSource.itemIdentifier(for: indexPath)</span></pre><p id="9582" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下代码片段删除了从<code class="fe nl nm nn no b">UITableView</code>中选择的元素:</p><pre class="kk kl km kn gu ns no nt nu aw nv bi"><span id="17de" class="nw me iu no b gz nx ny l nz oa">func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {<br/>        if let movie = dataSource.itemIdentifier(for: indexPath) {<br/>            <br/>            var currentSnapshot = dataSource.snapshot()<br/>            currentSnapshot.deleteItems([movie])<br/>            dataSource.apply(currentSnapshot)<br/>        }<br/>}</span></pre><p id="bcd6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">作为回报，我们得到应用程序的以下结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/4c16c22fe5a8af4739056289fe33b0a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/1*ArW2N8llycjli4eTZZDd8g.gif"/></div></figure><p id="d594" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意,“离开的”项目行虽然出现了两次，但由于使用了<code class="fe nl nm nn no b">Hashable</code>协议，所以是唯一标识的。</p><p id="e1cc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在另一个场景中，项目是不可哈希的，可区分的数据源将无法识别彼此具有相同内容的项目，并最终覆盖前一个项目。</p><p id="aaee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，在上面的例子中，对于一个不可散列的条目(比如说字符串)，" Departed "将只显示一次。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="924d" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="db88" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">我们已经看到diffable数据源如何为我们的<code class="fe nl nm nn no b">CollectionView</code>和<code class="fe nl nm nn no b">TableViews</code>引入了一种全新的构建数据源的方式。</p><p id="4362" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它使用条目标识符而不是索引路径，并且能够从后台调用<code class="fe nl nm nn no b">apply()</code>函数。</p><p id="1308" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以，是时候对<code class="fe nl nm nn no b">reloadData()</code>和<code class="fe nl nm nn no b">performBatchUpdates()</code>说<em class="og">不</em>了。完整的源代码可以在<a class="ae kz" href="https://github.com/anupamchugh/iowncode/tree/master/DiffableDataSources" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中找到。</p><p id="9f57" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一次到此为止。我希望你喜欢读它。</p></div></div>    
</body>
</html>