<html>
<head>
<title>A Few Gotchas To Consider When Working With Firestore’s Offline Mode and React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Firestore的离线模式和React Native时需要考虑的几个问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-few-gotchas-to-consider-when-working-with-firestores-offline-mode-and-react-native-97fec1604209?source=collection_archive---------5-----------------------#2021-04-27">https://betterprogramming.pub/a-few-gotchas-to-consider-when-working-with-firestores-offline-mode-and-react-native-97fec1604209?source=collection_archive---------5-----------------------#2021-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5e5f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Firestore的离线持久化是如何工作的？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/76cbc024b85cdb76db7804e0786f56ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fgwNX9UhXl-MEOxAecwKow.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="1b23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我最近参与的一个React Native项目使用了<a class="ae lu" href="https://firebase.google.com/docs/firestore" rel="noopener ugc nofollow" target="_blank"> Cloud Firestore </a>的力量。该应用程序的核心思想是允许用户执行在线和离线任务，并为用户提供透明的同步过程。</p><p id="4552" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这正是云Firestore提供的强大功能，但我想提到一些关于离线模式的问题和发现。他们可能会节省你的时间和头痛。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fe21" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Firestore的离线模式是如何运作的？</h1><p id="b107" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">让我们概述一个假设的场景，以便更好地理解。</p><p id="02f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们假设Blarz(用户)正在使用<em class="mz"> MyFavouritesOfflineApp </em>，它处理他最喜欢的电影和书籍。所以我们有两个主要的Firebase/Firestore收藏:书籍和电影。</p><p id="fe88" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">布拉兹登录，一旦他在主页上，应用程序将开始获取他最喜欢的书籍和电影。</p><h2 id="6ff5" class="na md it bd me nb nc dn mi nd ne dp mm lh nf ng mo ll nh ni mq lp nj nk ms nl bi translated">阅读动作</h2><p id="45c6" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">基本上，Blarz在与应用程序交互时下载各种文档。</p><p id="52bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些文档的下载通过查询或单独的文档获取来进行。一旦发生这种情况，所有这些文件都缓存在布拉兹的手机上。</p><p id="9cbe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mz">注意:请记住，如果您没有以编程方式设置检索这些集合，或者如果用户没有与任何查询或文档交互，那么这些数据在脱机模式下也是不可用的。</em></p><h2 id="caba" class="na md it bd me nb nc dn mi nd ne dp mm lh nf ng mo ll nh ni mq lp nj nk ms nl bi translated">书写动作</h2><p id="16ee" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">让我们继续前面的场景，以便更好地理解。</p><p id="30df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设布拉兹想要更新他最喜欢的电影之一。这是一个对<code class="fe nm nn no np b">movie</code>集合和与Blarz想要更新的电影相关联的文档进行更改的请求。</p><p id="2523" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请记住，数据保留在缓存中，因此即使数据没有进入服务器，您也可以立即看到变化。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="33bd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">脱机工作时的陷阱</h1><p id="1686" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我不得不承认:我是在调试了一段时间后才发现这些问题的，当时我正着手解决吉拉上的一个报告错误。当然，没有足够的离线测试，所以我没有意识到所有这些。</p><p id="9a49" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当使用Firestore的离线模式时，我们需要避免在某些事情上使用<code class="fe nm nn no np b">await</code>,比如在Firebase上创建或更新东西。</p><p id="b0a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在服务器上成功写入文档之前，由<code class="fe nm nn no np b">await</code>表达式生成的承诺不会完成。这将阻止您的UI，即使在缓存中进行了更改。</p><p id="8d2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有两种方法可以解决这个问题。</p><h2 id="6291" class="na md it bd me nb nc dn mi nd ne dp mm lh nf ng mo ll nh ni mq lp nj nk ms nl bi translated">1.避免等待，而是使用回调或承诺(推荐)</h2><p id="2540" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">如果你想确定一个写服务器已经发生了，使用回调或者承诺都可以。但是你不需要通过使用<code class="fe nm nn no np b">await</code>表达式来阻塞线程。</p><p id="67c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以代替这个的是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="3be1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换成承诺的用法。类似于以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="376f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过这样做，你将解锁你的用户界面，应用程序将在离线模式下正常工作。</p><h2 id="c0f0" class="na md it bd me nb nc dn mi nd ne dp mm lh nf ng mo ll nh ni mq lp nj nk ms nl bi translated">2.检查连接状态</h2><p id="afa6" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">这可能不是一个奇特的解决方案，但是如果您仍然想要使用<code class="fe nm nn no np b">await</code>表达式的糖语法，您可以只检查连接状态并依赖它来决定做什么。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8904" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在添加之前获取id</h1><p id="9552" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">这是另一场战斗。我需要归还用户文档。</p><p id="38a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于<code class="fe nm nn no np b">await</code>表达式的问题，我需要找到一种方法在添加文档之前返回它的ID。</p><p id="3254" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我有过这样的经历:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ad20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我删除了<code class="fe nm nn no np b">await</code>表达式之后，代码看起来如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f16e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个代码片段基本上是创建一个用户引用—一个文档引用。然后你甚至不用在云Firestore上创建就可以获得用户的ID。请记住，我们仍在离线模式下工作。</p><p id="f951" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后几行代码使用一个承诺添加用户。我们不等待服务器的响应，所以我们返回刚刚创建的新用户。</p><p id="ea48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">仅此而已。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b67d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="d1c3" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">云Firestore以一种奇特的方式为我们提供了在线和离线工作的能力。在离线模式下工作时，我们不需要担心任何事情，因为对于iOS和Android，离线持久性是默认启用的。</p><p id="195f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也就是说，在离线工作时，你需要记住一些问题。其中最重要的是避免使用<code class="fe nm nn no np b">await</code>表达。</p><p id="58c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一点很重要，因为如果您不这样做，UI将被锁定，因为您将等待响应，即使这些更改已经完成并在缓存中。</p><p id="1016" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解决方法是使用回电或承诺。</p><p id="a86d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这篇文章是有帮助的。下一集再见！</p></div></div>    
</body>
</html>