<html>
<head>
<title>Why Batching Your Apollo SQL DataSources Is Invaluable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么批处理您的Apollo SQL数据源是非常宝贵的</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/batching-your-apollo-sql-datasources-is-invaluable-2d264a17df20?source=collection_archive---------11-----------------------#2022-09-30">https://betterprogramming.pub/batching-your-apollo-sql-datasources-is-invaluable-2d264a17df20?source=collection_archive---------11-----------------------#2022-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a93d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这一惊人功能的深入指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bc873cd3cc8f58fc5c200c39a549b52c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MOYJZ07npQzv4HhHBzDPcA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/photos/6sAl6aQ4OWI" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="b90c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将探讨为什么通过<a class="ae kv" href="https://github.com/graphql/dataloader" rel="noopener ugc nofollow" target="_blank">数据加载器</a>批处理数据库查询对于快速获得<a class="ae kv" href="https://www.apollographql.com" rel="noopener ugc nofollow" target="_blank"> Apollo服务器</a>解析器至关重要。</p><p id="1062" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您使用带有数据源的SQL(或直接在您的解析器中),那么您很可能会遇到N+1问题或未解决的性能问题，尽管Apollo和社区提供了一些不同的数据源(如下所示),但是没有一个SQL <code class="fe ls lt lu lv b">DataSource</code>选项能够解决您的批量请求。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/acca1f3e49a377d02d0e2b4f47f2d252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MmXhpW41yZSD5ZqayF7WgQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.apollographql.com/docs/apollo-server/data/data-sources/" rel="noopener ugc nofollow" target="_blank">截图来源</a></p></figure><p id="1d15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我创建了一个新的数据源，可以在这里看到:<br/><a class="ae kv" href="https://www.npmjs.com/package/@nic-jennings/batched-sql-datasource" rel="noopener ugc nofollow" target="_blank">https://www . npmjs . com/package/@ NIC-Jennings/batched-SQL-data source</a></p><p id="1d95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个数据源允许您在需要的地方轻松地向数据源添加批处理，而不必在整个类中添加DataLoader初始化，这将使它变得混乱。</p><p id="c58a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将演示如何实现这一点，然后展示使用数据加载器作为数据源的一部分在性能上的差异。</p><h1 id="d85b" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">设置批处理SQL数据加载器</h1><p id="2789" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">我假设你安装了一个Apollo GraphQL服务器，但是如果没有，在这个GitHub仓库中有一个完整的例子。</p><p id="d58e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用数据源，首先安装软件包:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="c350" class="my ly iq lv b gy mz na l nb nc">npm i @nic-jennings/batched-sql-datasource</span><span id="bd03" class="my ly iq lv b gy nd na l nb nc">// or <br/>// yarn add @nic-jennings/batched-sql-datasource</span></pre><p id="7b76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后创建一个名为<code class="fe ls lt lu lv b">loader.js</code>的新文件，并创建您的扩展BatchedSQLDataSource的数据源，并将其导入到您的Apollo服务器中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="db2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的解析器中，您现在可以使用我们为bar创建的数据加载器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="249a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所看到的，设置是干净和快速的。</p><h1 id="311b" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">设置示例服务器</h1><p id="7015" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">我在这里创建了下面的例子:<a class="ae kv" href="https://github.com/nic-jennings/batched-sql-datasource/tree/main/example" rel="noopener ugc nofollow" target="_blank">https://github . com/NIC-Jennings/batched-SQL-data source/tree/main/example</a></p><p id="88bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<a class="ae kv" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> docker-compose </a>来运行这个带有种子<a class="ae kv" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> Postgresql </a>数据库的查询，我得到了以下结果:</p><h2 id="c619" class="my ly iq bd lz ng nh dn md ni nj dp mh lf nk nl mj lj nm nn ml ln no np mn nq bi translated">事件</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/44c46c626c17d1fb725d9e1345c2f943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eqx0ZMDfk0khaZPIOry55w.png"/></div></div></figure><h2 id="0762" class="my ly iq bd lz ng nh dn md ni nj dp mh lf nk nl mj lj nm nn ml ln no np mn nq bi translated">批量事件</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/309ccf121e68e2409ade809c249c0514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ad-wtr3Flx458aKlCpGqCw.png"/></div></div></figure><p id="cd48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，批处理查询只需要57.9毫秒，而标准数据源需要567毫秒，快了9.79倍！然而，您可能会想，仅仅在Apollo Studio中进行这个查询并不是真实的情况。因此，我使用<a class="ae kv" href="https://k6.io/" rel="noopener ugc nofollow" target="_blank"> K6 </a>编写了一些负载测试，并在我的本地docker compose构建上运行它们。你可以在下面看到它们:</p><h1 id="5682" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">负载测试—批量测试与标准测试</h1><p id="6778" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">设置我认为相当宽松的以下阈值，并考虑到我是针对本地docker编写堆栈运行它们的。</p><ul class=""><li id="2d27" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated">HTTP错误应该少于1%</li><li id="75cb" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">95%的请求应低于250毫秒</li></ul><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="ea75" class="my ly iq lv b gy mz na l nb nc">thresholds: {<br/>    http_req_failed: ["rate&lt;0.01"], <br/>    http_req_duration: ["p(95)&lt;250"], <br/>},</span></pre><p id="6387" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行这里可以看到的测试。提供以下结果:</p><h2 id="625d" class="my ly iq bd lz ng nh dn md ni nj dp mh lf nk nl mj lj nm nn ml ln no np mn nq bi translated">标准数据源</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/c3d78e3e2d2fd18293efe64bb9e069e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CKjo07usTpvHnLgfgZg04Q.png"/></div></div></figure><h2 id="2614" class="my ly iq bd lz ng nh dn md ni nj dp mh lf nk nl mj lj nm nn ml ln no np mn nq bi translated">批量数据源</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/3630112ff8adb1ac3d1947a4b84dfa2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6o07uMnq7L1bHuYPOwKBfA.png"/></div></div></figure><h1 id="e74d" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">结果</h1><p id="86da" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">首先要注意的是，标准数据源没有通过负载测试。超过95%的测试耗时超过250毫秒——平均请求持续时间为1.15秒，最长耗时不到三秒，对于一个小数据集来说，这是一个令人震惊的响应时间。我认为这真实地展示了N+1问题以及数据加载器如何解决这个问题。例如，批处理数据源完成一个请求平均需要22.31毫秒，最长需要132.98毫秒</p><h1 id="fc3c" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">结论</h1><p id="ed83" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">我个人认为以上不可否认地显示了使用数据加载器对GraphQL请求时间的影响。我希望您同意我创建的包有助于轻松地在Apollo中制作和使用数据加载器，并保持您的代码整洁。</p></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><p id="4de0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您花时间阅读我的文章。我希望你已经发现它的知识性和趣味性。我将围绕TypeScript、Node、React、Vue、GraphQL、Performance、Go等写更多文章。</p></div></div>    
</body>
</html>