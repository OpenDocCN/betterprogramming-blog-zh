<html>
<head>
<title>Benchmarking Generics in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的泛型基准测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/benchmarking-generics-in-go-7db40d274b89?source=collection_archive---------4-----------------------#2022-02-21">https://betterprogramming.pub/benchmarking-generics-in-go-7db40d274b89?source=collection_archive---------4-----------------------#2022-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4021" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">泛型将如何影响性能？让我们通过对几个用例进行基准测试来找出答案。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2c5dc179a44484813bc7710fa7359612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DalM279o-w-04afcJ1VsBA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由珀西·博尔梅尔提供。Gopher由拓也·上田提供，原始Go Gopher由勒内·弗伦奇提供(CC BY 3.0)</p></figure><p id="58ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上周我写了我们将在Go 1.18中看到的新功能。如果你没有，你应该读一读。</p><div class="lu lv gp gr lw lx"><a href="https://towardsdatascience.com/go-1-18-comes-with-many-amazing-changes-d33ac0afd6ee" rel="noopener follow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iu gy z fp mc fr fs md fu fw is bi translated">Go 1.18带来了许多惊人的变化</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">Go 1.18将于二月发布，它包含了多项改进语言的变化</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">towardsdatascience.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml ks lx"/></div></div></a></div><p id="8598" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那篇文章的许多读者在各种社交媒体平台上联系我，我想对那些读者说谢谢。我喜欢它带来的参与和讨论。</p><p id="3450" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中一个讨论是我想写的主题，我们将在泛型介绍中看到的<em class="mm">性能影响</em>。许多读者担心泛型会降低性能，然而我的论点是泛型会提高性能。我的论点背后的理由是，泛型将允许我们在运行时跳过类型转换、断言和反射，而是依靠编译器在编译时解决这个问题。</p><p id="ffd2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我关于<a class="ae mn" href="https://towardsdatascience.com/learning-generics-in-go-318f53752ccd" rel="noopener" target="_blank">学习泛型</a>的文章中，我解释了泛型的用法，两个主要的好处是减少了基于数据类型的重复函数和避免了<code class="fe mo mp mq mr b">interface{}</code>。这些是我们将在本文中进行基准测试的用例，以发现变化的性能。</p><blockquote class="ms mt mu"><p id="aed9" class="ky kz mm la b lb lc ju ld le lf jx lg mv li lj lk mw lm ln lo mx lq lr ls lt im bi translated">让我在这里做一个小的概念，我不是一个标杆向导。我只是一个卑微的标杆noob。对我来说，标杆管理非常困难。</p></blockquote><p id="bae4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了制定一个公平的基准，我们将为每个用例建立一个测试用例。这将意味着我们将</p><ol class=""><li id="58c4" class="my mz it la b lb lc le lf lh na ll nb lp nc lt nd ne nf ng bi translated">使用重复函数进行基准测试</li><li id="4bcd" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">使用泛型进行基准测试</li><li id="71da" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">基准测试使用<code class="fe mo mp mq mr b">interface{}</code></li></ol><h2 id="ca9e" class="nm nn it bd no np nq dn nr ns nt dp nu lh nv nw nx ll ny nz oa lp ob oc od oe bi translated">准备要进行基准测试的功能</h2><p id="4b94" class="pw-post-body-paragraph ky kz it la b lb of ju ld le og jx lg lh oh lj lk ll oi ln lo lp oj lr ls lt im bi translated">我们将重用来自<a class="ae mn" href="https://towardsdatascience.com/learning-generics-in-go-318f53752ccd" rel="noopener" target="_blank">学习泛型</a>的一些代码，在其中，我们有一个<code class="fe mo mp mq mr b">Subtract</code>函数，它减去三个<code class="fe mo mp mq mr b">Subtractable</code>数据类型之间的值。</p><p id="cc50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要确定哪种减法效果最好。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们将进行基准测试的减法。在<a class="ae mn" href="https://gotipplay.golang.org/p/BLU8pHOzmvS" rel="noopener ugc nofollow" target="_blank">游乐场</a>试试吧。</p></figure><p id="73e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们将开始对函数进行基准测试。它们应该很容易理解，我们涵盖了减法、基于数据类型、类型切换和泛型的可能解决方案。</p><h2 id="2996" class="nm nn it bd no np nq dn nr ns nt dp nu lh nv nw nx ll ny nz oa lp ob oc od oe bi translated">准备基准</h2><p id="8f0c" class="pw-post-body-paragraph ky kz it la b lb of ju ld le og jx lg lh oh lj lk ll oi ln lo lp oj lr ls lt im bi translated">创建一个常规的测试文件，我们可以在其中存储基准，如果你不熟悉Go中的基准，你可以阅读我的教程。</p><div class="lu lv gp gr lw lx"><a rel="noopener  ugc nofollow" target="_blank" href="/we-measure-the-power-of-cars-computers-and-cellphones-but-what-about-code-91ed5583f298"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iu gy z fp mc fr fs md fu fw is bi translated">我们测量汽车、电脑和手机的功率。但是代码呢？</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">深入了解Golang的基准测试</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">better编程. pub</p></div></div><div class="mg l"><div class="om l mi mj mk mg ml ks lx"/></div></div></a></div><p id="6d6c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在基准测试的顶部，我将生成两个切片，一个是随机整数切片，一个是随机浮点数32s切片。这些随机切片将被用作减法方法的输入参数。</p><p id="2489" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们创建一个<code class="fe mo mp mq mr b">b.Run</code>,它将一次触发一个函数，触发的次数与我们设置为benchmarker运行<code class="fe mo mp mq mr b">-benchtime</code>标志的次数一样多。对于这个基准测试，我将强制基准测试者运行每个函数1000000000次。如果不指定运行函数的次数，基准测试程序会在特定时间内尽可能多地运行函数。这将导致他们不再运行相同数量的操作，我希望他们这样做。</p><p id="5d77" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是我的最终基准看起来的样子。我希望我能提供一个基准的操场链接，但操场上只允许常规的<code class="fe mo mp mq mr b">testing.T</code>。所以如果你想自己尝试，你必须复制要点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于执行基准测试以确定一般性能影响的测试文件。</p></figure><p id="0993" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基准测试将在所有用例中测试<code class="fe mo mp mq mr b">int</code>和<code class="fe mo mp mq mr b">float32</code>的减法函数。在通用基准中，我添加了第三个选项，推断数据类型。我还想确定如果我们让泛型函数将数据类型推断为<code class="fe mo mp mq mr b">int</code>，我们会损失多少性能。</p><p id="3f44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要运行基准测试，请使用以下命令。请注意，<code class="fe mo mp mq mr b">-count 5</code>参数用于运行每个基准5次。这是因为如果您运行每个基准一次，您可能会得到不公平的结果。在其中一次基准测试中，可能有其他处理器窃取了计算机的功率。</p><pre class="kj kk kl km gt on mr oo op aw oq bi"><span id="15f1" class="nm nn it mr b gy or os l ot ou">go test -v -bench=Benchmark -benchtime=1000000000x -count 5</span></pre><h2 id="a92a" class="nm nn it bd no np nq dn nr ns nt dp nu lh nv nw nx ll ny nz oa lp ob oc od oe bi translated">分析结果</h2><p id="1395" class="pw-post-body-paragraph ky kz it la b lb of ju ld le og jx lg lh oh lj lk ll oi ln lo lp oj lr ls lt im bi translated">基准测试将输出正在运行的函数的名称，我们可以用它来识别不同的函数。第二个值是运行的操作数，在我们的例子中，我们将其设置为一个固定的数字，因此所有的行应该显示相同的内容。</p><p id="e641" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第三个输出是有趣的，它是每个操作的纳秒数(ns/op)。这是显示函数平均速度的指标。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自go测试工具的基准测试结果。</p></figure><p id="56b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从结果中，我们可以确定类型断言函数要慢得多。大约慢了50-90%。在这个测试案例中，这可能看起来很荒谬，因为我们谈论的是半纳秒。</p><p id="ef1b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通用函数的性能与特定于数据类型的函数差不多，只是速度稍有提高。这种速度上的小小提高可能是由于我电脑上运行的其他软件的推断。在我的思想状态中，我认为在编译器完成它的工作后，通用函数调用应该和常规函数调用一样。</p><p id="7b08" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以在结果中看到的另一个要点是<code class="fe mo mp mq mr b">int</code>减法比<code class="fe mo mp mq mr b">float32</code>减法更耗时。常规<code class="fe mo mp mq mr b">int</code>减法的平均速度是<em class="mm"> 0，85478 ns/op </em>，常规<code class="fe mo mp mq mr b">float32</code>减法的平均速度是<em class="mm"> 0，8188 ns/op. </em>这意味着<code class="fe mo mp mq mr b">float32</code>减法在我的基准测试中大约快<em class="mm"> 5% </em>。</p><p id="5f04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，从该基准测试中得出的关键结论是:</p><ul class=""><li id="393e" class="my mz it la b lb lc le lf lh na ll nb lp nc lt ov ne nf ng bi translated">根据我的论文，类型断言/类型转换解决方案是最慢的</li><li id="ad0f" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt ov ne nf ng bi translated">泛型和常规数据类型函数具有同等的性能</li><li id="419f" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt ov ne nf ng bi translated"><code class="fe mo mp mq mr b">Float32</code>减法比<code class="fe mo mp mq mr b">int</code>快</li></ul><h2 id="af53" class="nm nn it bd no np nq dn nr ns nt dp nu lh nv nw nx ll ny nz oa lp ob oc od oe bi translated">基准测试的真实场景</h2><p id="0ae4" class="pw-post-body-paragraph ky kz it la b lb of ju ld le og jx lg lh oh lj lk ll oi ln lo lp oj lr ls lt im bi translated">让我们也来比较一下现实生活中的场景。在用例中，我们有两个结构<code class="fe mo mp mq mr b">Person</code>和<code class="fe mo mp mq mr b">Car</code>，它们都可以<code class="fe mo mp mq mr b">Move</code>。这两种结构都有一个接受距离的<code class="fe mo mp mq mr b">Move</code>函数，但是，人的距离作为<code class="fe mo mp mq mr b">float32</code>传递，而汽车接受一个<code class="fe mo mp mq mr b">int</code>。</p><p id="2bc3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两种结构都在同一个工作流中处理，所以我们希望在同一个函数中处理它们。</p><p id="1b6c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通用的解决方案是创建通用的结构，在这个结构中我们可以定义创建时要使用的数据类型。接口解决方案是接受结构作为输入，类型断言它们，并转换正确的数据类型。由于数据类型不同，我们无法为它们提供共享接口。</p><p id="c9e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不会详细解释泛型解决方案是如何工作的，如果你想理解的话，你可以看看我关于泛型的文章。</p><div class="lu lv gp gr lw lx"><a href="https://towardsdatascience.com/learning-generics-in-go-318f53752ccd" rel="noopener follow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iu gy z fp mc fr fs md fu fw is bi translated">在围棋中学习泛型</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">泛型在Go 1.18中发布，是时候学习如何利用这个新特性了</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">towardsdatascience.com</p></div></div><div class="mg l"><div class="ow l mi mj mk mg ml ks lx"/></div></div></a></div><p id="546a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在代码示例中，泛型和旧的类型断言解决方案都有一个实现，类型断言以<code class="fe mo mp mq mr b">Regular</code>为后缀，因此我们可以更容易地知道什么与什么解决方案相关。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对不同数据类型的汽车和人员执行移动的通用解决方案。在<a class="ae mn" href="https://gotipplay.golang.org/p/P6XR8TtDSJf" rel="noopener ugc nofollow" target="_blank">游乐场</a>试用。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">键入切换的解决方案移动，尝试在<a class="ae mn" href="https://gotipplay.golang.org/p/QQKH1jmJT2K" rel="noopener ugc nofollow" target="_blank">操场</a>它。</p></figure><p id="dfab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经有了解决方案，是时候建立基准了。我将在基准测试之前创建人和车，我们将测量<code class="fe mo mp mq mr b">Move</code>和<code class="fe mo mp mq mr b">MoveRegular</code>的性能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将运行Move和MoveRegular函数的基准</p></figure><p id="2acf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用以下命令运行测试</p><pre class="kj kk kl km gt on mr oo op aw oq bi"><span id="2b56" class="nm nn it mr b gy or os l ot ou">go test -v -bench=Benchmark_Structures -benchtime=1000000000x -count 5</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行基准测试的结果</p></figure><p id="f70d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看到类型断言解决方案比通用解决方案快，我有点惊讶。我确保多次运行基准测试，所以它不是临时的。</p><p id="0cfb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以从基准测试中看到，基于Cars、<code class="fe mo mp mq mr b">Int</code>的解决方案比基于Person、<code class="fe mo mp mq mr b">float32</code>的数据类型更快。</p><p id="c8cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mo mp mq mr b">Person</code>移动功能具有相同的性能，无论是通用的还是常规的解决方案。然而，你可以看到不同的汽车，与类型断言汽车是最快的。这种型号的汽车运行速度比普通汽车快20%。</p><p id="7656" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，从该基准中获得的关键信息如下。</p><ul class=""><li id="ec4c" class="my mz it la b lb lc le lf lh na ll nb lp nc lt ov ne nf ng bi translated">基于浮点的类型共享相同的性能，而类型断言的整数cars更快，正如我的论文所言</li><li id="200f" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt ov ne nf ng bi translated"><code class="fe mo mp mq mr b">Float32</code>加法比<code class="fe mo mp mq mr b">int</code>慢</li></ul><h2 id="4805" class="nm nn it bd no np nq dn nr ns nt dp nu lh nv nw nx ll ny nz oa lp ob oc od oe bi translated">结论</h2><p id="cfae" class="pw-post-body-paragraph ky kz it la b lb of ju ld le og jx lg lh oh lj lk ll oi ln lo lp oj lr ls lt im bi translated">所以，我们现在已经测试了一些用例，在这些用例中我可以看到泛型是有帮助的。</p><p id="4c2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">老实说，我确实希望第二个基准测试也能证明泛型更快。这将加强我的主张，即泛型更具性能，因为它是在编译时而不是运行时决定的。</p><p id="0e58" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过使用泛型或特定于数据类型的函数，我们可以在第一个用例中看到相当大的性能提升。我知道几纳秒可能看起来很荒谬，但在一些用例中，这种类型的极端优化非常重要。我曾经做过一个高性能的网络嗅探器，它必须实时处理大量的网络数据。编写这样的软件需要所有的优化。</p><p id="b830" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经看到，选择正确的数据类型对性能有很大的影响。然而，我认为我们可以说，那些表达了对泛型使软件变慢的恐惧的读者可以冷静了。从好的方面来看，我看到通用解决方案允许我们更容易地交换数据类型，从而提高性能。</p><p id="c3c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，Go中的类型断言和类型转换似乎具有超强的性能。</p><p id="ecb0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们所看到的，许多因素都会对结果产生影响，比如使用的<a class="ae mn" href="https://www.techopedia.com/definition/25582/arithmetic-operator" rel="noopener ugc nofollow" target="_blank">算术运算符</a>，数据类型等等。我的基准中可能有我不知道的错误。</p><p id="ba9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您对如何改进基准有任何想法或者想要讨论它们，请随时联系我们。你可以在<a class="ae mn" href="https://github.com/percybolmer/benchmarkinggenerics" rel="noopener ugc nofollow" target="_blank"> GitHub </a>找到完整的代码。</p></div></div>    
</body>
</html>