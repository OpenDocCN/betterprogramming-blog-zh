<html>
<head>
<title>iOS Dependency Injection With Cleanse: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有清理的iOS依赖注入:第1部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ios-dependency-injection-with-cleanse-1ef495e390a2?source=collection_archive---------11-----------------------#2020-02-13">https://betterprogramming.pub/ios-dependency-injection-with-cleanse-1ef495e390a2?source=collection_archive---------11-----------------------#2020-02-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b0b4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">向您的类和结构注入它们需要的功能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4f1005a7e9861e1674ce34ec10d5f204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ro9ZOiD6yRCsNfB9"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@mahesh_ranaweera?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马赫什·拉纳韦拉</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="eb57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你好！</p><p id="07fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我们将谈论当今软件开发中的一个热门话题。我很确定你们大多数人都听说过依赖注入。</p><p id="67e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个对象为另一个对象提供依赖关系。这在我们的代码中经常发生。例如，当我显示用户资料屏幕时，我的<code class="fe ls lt lu lv b">UserRepository</code>类提供了所有用户的详细信息。但是repository类需要一个HTTP客户端(<code class="fe ls lt lu lv b">URLSession</code>)来获取数据，会话需要一个配置，等等。这为所有这些对象实例化提供了依赖注入。</p><p id="3edd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">什么？这是一种模式吗？嗯，确实是。</p><p id="aa63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们是否在被动地使用这种模式，甚至有时不自知？嗯，是的。我们不断地使用对象为其他对象提供数据，当我们处理一个小的代码库并且一个开发人员必须做所有的事情时，这是非常简单的。但是，随着团队变大，代码库随之而来，这就成了一个问题。久而久之，我们必须处理混乱。</p><p id="54a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">DI是软件工程中一个非常古老的问题。大多数web框架很久以前就已经解决了这个问题，并提供了内置的机制来解决这个问题。这在一开始似乎不是一个移动问题，因为我们开发的应用很小，没有太多的功能。因此代码更少。现在，它变得比以往任何时候都更加突出，很明显需要这样的工具。</p><p id="8424" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">DI框架分为两类:服务定位器和构造器注入。</p><p id="c935" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一种工作方式类似于一个桶，在桶中注册依赖项或实例化它们的方式，然后从桶中请求它们。以下是使用服务定位器的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">服务定位器示例— Swinject。</p></figure><p id="d38c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你在网上搜索iOS DI框架，你会碰到很多很棒的库，比如<a class="ae kv" href="https://github.com/Swinject/Swinject" rel="noopener ugc nofollow" target="_blank"> Swinject </a>、<a class="ae kv" href="https://github.com/devxoul/Pure" rel="noopener ugc nofollow" target="_blank"> Pure </a>、<a class="ae kv" href="https://github.com/AliSoftware/Dip" rel="noopener ugc nofollow" target="_blank"> Dip </a>等。你也可以查看一下<a class="ae kv" href="https://github.com/appsquickly/Typhoon" rel="noopener ugc nofollow" target="_blank"> Typhoon </a>，它曾经是Objective-C的事实上的DI框架，还有一个是我故意留在最后的:<a class="ae kv" href="https://github.com/square/Cleanse" rel="noopener ugc nofollow" target="_blank">clean</a>。</p><p id="cd5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Cleanse是一个库，灵感来自最著名的Android DI库，<a class="ae kv" href="https://github.com/google/dagger" rel="noopener ugc nofollow" target="_blank"> dagger </a>。有趣的事实:dagger 2已经被Google重写了，但是版本1原本是square 写的<a class="ae kv" href="https://github.com/square/dagger" rel="noopener ugc nofollow" target="_blank">。清流也是square写的。用过匕首的人会发现净化很熟悉。尽管它是为完全不同的框架和完全不同的语言编写的，但它在提供dagger的大多数功能方面做得非常好。</a></p><p id="fa2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">匕首无论如何都不是简单的工具。这同样适用于清洗。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="912e" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">术语</h1><h2 id="0ac2" class="mx mg iq bd mh my mz dn ml na nb dp mp lf nc nd mr lj ne nf mt ln ng nh mv ni bi translated">组件和子组件</h2><p id="d180" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">组件是在需要时注入适当对象的粘合剂。你的图表以一个<code class="fe ls lt lu lv b">RootComponent</code>开始，这是你的图表将要存在的地方。</p><p id="7788" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">组件相当于dagger的组件。</p><h2 id="1543" class="mx mg iq bd mh my mz dn ml na nb dp mp lf nc nd mr lj ne nf mt ln ng nh mv ni bi translated"><strong class="ak">模块</strong></h2><p id="3f49" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">模块是组件的构建块。它们是您定义如何实例化您的依赖项的方式。</p><p id="fb60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模块相当于dagger的模块。</p><h2 id="d8b2" class="mx mg iq bd mh my mz dn ml na nb dp mp lf nc nd mr lj ne nf mt ln ng nh mv ni bi translated">领域</h2><p id="d616" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">范围是定义依赖关系生命周期的方式。目前，Cleanse提供了两种作用域:singleton和unscoped。通过使用单例作用域，您告诉绑定器，您希望它在提供依赖关系时使用同一个实例。使用unscoped意味着每次都会实例化一个新的实例。</p><p id="9a8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">瞄准镜相当于匕首的瞄准镜。</p><h2 id="552d" class="mx mg iq bd mh my mz dn ml na nb dp mp lf nc nd mr lj ne nf mt ln ng nh mv ni bi translated"><strong class="ak">类型标签</strong></h2><p id="3e93" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">标签是为我们的对象提供命名参数的一种方式。假设您有两个相同类的对象，您想为它们分配不同的用途:一个字符串是您的服务URL，另一个字符串是API令牌。模块只知道类型，你的两个对象都是字符串。标签<strong class="ky ir"> </strong>将区分这两个对象，您将能够使用您的依赖实例化所需要的那个。</p><p id="e1ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">标签相当于dagger的命名提供者。</p><h2 id="29dd" class="mx mg iq bd mh my mz dn ml na nb dp mp lf nc nd mr lj ne nf mt ln ng nh mv ni bi translated"><strong class="ak">房产注入</strong></h2><p id="1de6" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">顾名思义，属性注入是在对象实例化后为其提供依赖关系的方法。这在系统实例化对象时特别有用，比如用<code class="fe ls lt lu lv b">AppDelegate</code>、<code class="fe ls lt lu lv b">SceneDelegate</code>等。</p><h2 id="f637" class="mx mg iq bd mh my mz dn ml na nb dp mp lf nc nd mr lj ne nf mt ln ng nh mv ni bi translated"><strong class="ak">辅助注射</strong></h2><p id="c2b5" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">辅助注入是一种向对象实例化提供额外对象的技术，这些对象不是图的一部分。例如，用户选择了一个项目，您将使用该项目的详细信息来推送详细视图控制器。这可以通过辅助注射来实现。</p><h2 id="ee78" class="mx mg iq bd mh my mz dn ml na nb dp mp lf nc nd mr lj ne nf mt ln ng nh mv ni bi translated"><strong class="ak">多绑定</strong></h2><p id="cd23" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">多绑定是一个简单的概念，您提供的对象被放入一个数组中。正如在文档中提到的，字典和集合也是可能的，但是还不支持。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="6ab8" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">例子</h1><p id="908e" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">你可以在GitHub 上找到下面这个例子<a class="ae kv" href="https://github.com/g20ready/CleansePlayground" rel="noopener ugc nofollow" target="_blank">的源代码。</a></p><p id="498d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个项目使用Xcode 11的新<code class="fe ls lt lu lv b">SceneDelegate</code>作为起点，没有故事板，但它适用于<code class="fe ls lt lu lv b">AppDelegate</code>做了一些改变。<a class="ae kv" href="https://learnappmaking.com/scene-delegate-app-delegate-xcode-11-ios-13/" rel="noopener ugc nofollow" target="_blank">阅读更多关于场景代表</a>的信息。</p><p id="a9af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个新项目并将<code class="fe ls lt lu lv b">pod 'Cleanse'</code>添加到你的Podfile中。这就是我们目前所需要的。现在，在您的项目中添加一个名为<code class="fe ls lt lu lv b">MainComponent</code>的新文件，它继承了Cleanse的<code class="fe ls lt lu lv b">RootComponent</code>，并将下面的代码粘贴到其中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">主组件。</p></figure><ul class=""><li id="3199" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated"><code class="fe ls lt lu lv b">Root</code> <strong class="ky ir"> </strong>将是该组件构建的对象。</li><li id="f092" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><code class="fe ls lt lu lv b">Scope</code> <strong class="ky ir"> </strong>是该组件的图形对象的生命周期范围。</li><li id="494c" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><code class="fe ls lt lu lv b">Seed</code> <strong class="ky ir"> </strong>是我们将提供给组件的初始对象，以便组件构建其图形。</li><li id="0796" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><code class="fe ls lt lu lv b">Configure</code> <strong class="ky ir"> </strong>用于将<strong class="ky ir"> </strong>模块包含到我们的组件中。</li><li id="4788" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><code class="fe ls lt lu lv b">ConfigureRoot</code> <strong class="ky ir"> </strong>是打造我们根的切入点。在我们的例子中，它是<code class="fe ls lt lu lv b">SceneDelegate</code>的属性注入器。</li><li id="ab96" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><code class="fe ls lt lu lv b">ConfigureAppSceneInjector</code>是一个帮助器方法，它将<code class="fe ls lt lu lv b">BindingReceipt</code>返回给我们的属性注入器。</li></ul><p id="472a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在组件的配置步骤中，我们看到两个模块。这些将为我们的组件提供它所需要的依赖。添加一个新文件，最好命名为<code class="fe ls lt lu lv b">UIKitModule</code>，并添加以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="3d13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如这里所看到的，<code class="fe ls lt lu lv b">UIKitModule</code>是一个通用模块，除了包含其他UIKit模块之外什么也不做，比如<code class="fe ls lt lu lv b">UIWindow.Module</code>。一般来说，通过扩展现有的类或结构并在其中包含模块来为它们提供模块是一个很好的做法。<code class="fe ls lt lu lv b">UIWindow</code>模块将一个<code class="fe ls lt lu lv b">UIWindow</code>对象绑定到我们的依赖图，只要该图能够为我们定义的绑定函数提供依赖关系。所以这个绑定需要一个<code class="fe ls lt lu lv b">UIViewController</code>类型的类型标签和一个<code class="fe ls lt lu lv b">UIWindowScene</code>。如前所述，<code class="fe ls lt lu lv b">UIWindowScene</code>是作为种子提供给我们的主组件的，所以我们只缺少一个<code class="fe ls lt lu lv b">UIViewController</code>。</p><p id="caaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在来添加我们的<code class="fe ls lt lu lv b">CoreAppModule</code>吧。它应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="888c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个类将包括我们应用中定义的其他模块，但暂时只包括一个<code class="fe ls lt lu lv b">UIViewController.Module</code>。它应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="0f4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这部分提供了我们需要的<code class="fe ls lt lu lv b">UIWindow.Module</code><strong class="ky ir"/><code class="fe ls lt lu lv b">ViewController</code>以便绑定代码可以运行。我们的依赖图需求现在已经完成了。我们现在缺少的是我们<code class="fe ls lt lu lv b">SceneDelegate</code>的成员注入部分。</p><p id="13e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们的主要组件还有两个功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c344" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">把<code class="fe ls lt lu lv b">configureRoot</code>看作是我们构建函数的助手。它接受一个根类型的<code class="fe ls lt lu lv b">ReceiptBinder</code>并返回一个根类型的<code class="fe ls lt lu lv b">BindingReceipt</code>。在方法体中，我们使用了<code class="fe ls lt lu lv b">ReceiptBinder</code>的<code class="fe ls lt lu lv b">propertyInjector</code>函数，它将我们的绑定转换为<code class="fe ls lt lu lv b">PropertyInjectionReceiptBinder</code>。这个特殊的绑定器将查看作为注入器提供的函数的签名，并确保它具有构建我们的<code class="fe ls lt lu lv b">ComponentFactory</code>所指定的类型。否则，它将失败，并显示一条错误消息，指明发生了什么问题。现在转到我们的<code class="fe ls lt lu lv b">SceneDelegate</code>并添加以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="7c6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们这里只有两件事值得一提。首先是<code class="fe ls lt lu lv b">injectProperties</code>函数。记住，我们用这个来告诉我们的组件<code class="fe ls lt lu lv b">PropertyInjector</code>需要什么属性。该房产是由<code class="fe ls lt lu lv b">UIWindow.Module</code>提供的<code class="fe ls lt lu lv b">UIWindow</code>。其次是<code class="fe ls lt lu lv b">setupApplication</code>。这个函数需要一个<code class="fe ls lt lu lv b">UIWindowScene</code>对象，它是我们组件的种子。接下来，我们从要求我们的主要组件的<code class="fe ls lt lu lv b">ComponentFactory</code>开始。如果我们的依赖项设置不正确，这将会失败，错误将会提供表单中出错的信息。</p><pre class="kg kh ki kj gt oc lv od oe aw of bi"><span id="03db" class="mx mg iq lv b gy og oh l oi oj">error building the component factory: *** HNStory *** binding missing<br/>   -&gt; required by PropertyInjector&lt;SceneDelegate&gt; at DI/MainComponent.swift:28</span></pre></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="fba2" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">结论</h1><p id="3a12" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">我知道这很难理解，尤其是如果您以前从未使用过依赖注入框架，所以我将在这里停下来，带着第2部分的清理回来。我们将附加我们的网络层，使用实际的视图控制器而不是一个空的视图控制器，并向您展示辅助注入——一个尚未发布到CocoaPods的特性，但是您可以在branch <code class="fe ls lt lu lv b">4.2.5-stable</code>中找到它。我也将表达我对是否值得在一个新的、中等的和大的代码库中使用Cleanse的想法。</p><p id="69c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你发现任何不清楚的地方，请在下面的部分随意评论。我会试着给你一个解释。</p><p id="efc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您花时间阅读本文。一旦你觉得准备好了，继续这个系列的第二部分。</p></div></div>    
</body>
</html>