<html>
<head>
<title>Designing Developer-Friendly React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计开发人员友好的React组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/designing-developer-friendly-react-components-8638e017d728?source=collection_archive---------13-----------------------#2019-11-04">https://betterprogramming.pub/designing-developer-friendly-react-components-8638e017d728?source=collection_archive---------13-----------------------#2019-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3dc9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">设计开发人员友好的React组件的原则和实践</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4da345eaff802ef373e5f34e561ce520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tBDLvoZ6WtaTrXCw"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@codestorm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">萨法尔·萨法罗夫</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="30c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设计一个可重用的React组件绝对是一个挑战，因为我们经常在一个团队中工作，我们组件的用户不仅仅是我们，还有其他开发人员。</p><p id="e3da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，如果不妥善处理，糟糕的抽象有一天肯定会反咬我们一口。我喜欢在这里使用word <em class="ls"> design </em> <strong class="ky ir"> </strong>因为设计过程是在我们进行实际编码<strong class="ky ir"> </strong>部分之前发生的思考和思考阶段。</p><p id="560d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理想情况下，我们希望在实际编码之前花时间进行设计。</p><p id="2469" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文将讨论我们可以应用于设计可维护和开发人员友好的React组件的常见实践和原则。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="4712" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">上下文无关组件</h1><p id="ffef" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">设计一个可重用的组件意味着我们需要确保这个组件尽可能的与上下文无关。</p><p id="3edc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如选择<code class="fe mx my mz na b">Button</code>而不是<code class="fe mx my mz na b">ReportPageConfirmationButton</code>。<code class="fe mx my mz na b">Card</code>而不是<code class="fe mx my mz na b">UserCard</code>。<code class="fe mx my mz na b">Avatar</code>而不是<code class="fe mx my mz na b">ProfileAvatar</code><em class="ls"/>等等。这样，我们可以在项目中扩展组件的使用。此外，当组件在不同的上下文中使用时，它可以避免混淆。</p><p id="89a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，在<code class="fe mx my mz na b">SettingPage</code> <em class="ls"> </em>中使用<code class="fe mx my mz na b">ReportPageConfirmationButton</code> <em class="ls"> </em>可能在功能和UI方面是正确的，但在语义上是不正确的。</p><p id="1ac8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个优点是抽象出与特定用例相关的实现。看看下面的<code class="fe mx my mz na b">Button</code>组件。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="6a7c" class="nf mb iq na b gy ng nh l ni nj">function Button ({ children }) {<br/> return &lt;button data-testid="login-button"&gt;{children}&lt;button/&gt;<br/>}</span></pre><p id="7eb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使<code class="fe mx my mz na b">data-testid</code> <strong class="ky ir"> </strong>属性只在登录按钮中使用，这个<code class="fe mx my mz na b">Button</code>组件也可以在任何地方使用，并且是正确的UI方式。</p><p id="8bb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，不知何故，它与登录按钮的实现联系在一起。所以，我们提取<code class="fe mx my mz na b">data-testid</code>属性作为道具。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="f60d" class="nf mb iq na b gy ng nh l ni nj">function Button ({ children, dataTestId }) {<br/> return &lt;button data-testid={dataTestId}&gt;{children}&lt;button/&gt;<br/>}</span><span id="954f" class="nf mb iq na b gy nk nh l ni nj">// Usage<br/>&lt;Button dataTestId="login-button"&gt;Login&lt;/Button&gt;</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="b849" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">简单和语义的组件道具</h1><h2 id="5593" class="nf mb iq bd mc nl nm dn mg nn no dp mk lf np nq mm lj nr ns mo ln nt nu mq nv bi translated">使用JSX的默认值和JavaScript强制</h2><p id="f14b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">考虑下面的<code class="fe mx my mz na b">Button</code>组件。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="ba43" class="nf mb iq na b gy ng nh l ni nj">import React from 'react';<br/>import Loader from '../Loader';</span><span id="abb0" class="nf mb iq na b gy nk nh l ni nj">function Button ({  loading }) {<br/> return &lt;button&gt;{ loading ? &lt;Loader /&gt; : 'Click me!'}&lt;button/&gt;<br/>}</span></pre><p id="7c24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你提供没有值的道具时，它将默认为<code class="fe mx my mz na b">true</code>。这两个JSX表达式是等价的。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="a127" class="nf mb iq na b gy ng nh l ni nj">&lt;Button loading={true} /&gt;</span><span id="5c58" class="nf mb iq na b gy nk nh l ni nj">&lt;Button loading /&gt;</span></pre><p id="212d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我们可以使用JavaScript强制性质。这两个JSX表达式也是等价的。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="0bba" class="nf mb iq na b gy ng nh l ni nj">&lt;Button loading={false}/&gt;</span><span id="a04b" class="nf mb iq na b gy nk nh l ni nj">&lt;Button /&gt;</span></pre><p id="871a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些可能看起来很明显，但是如果您在React项目中有类型检查，这可能会有所帮助。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="10e1" class="nf mb iq na b gy ng nh l ni nj">type TButtonProps = {<br/> loading?: Boolean<br/>}</span><span id="c71f" class="nf mb iq na b gy nk nh l ni nj">// So if you do this the type checking won't complain<br/>&lt;Button /&gt;</span></pre><p id="7ecc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，让我们考虑一下为什么我在这里使用名称<code class="fe mx my mz na b">loading</code>，而不是<code class="fe mx my mz na b">isLoading</code>。<code class="fe mx my mz na b">isLoading</code>如果我们每次都要提供价值，道具是有意义的。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="e59a" class="nf mb iq na b gy ng nh l ni nj">&lt;Button isLoading={true} /&gt;</span><span id="a7e5" class="nf mb iq na b gy nk nh l ni nj">&lt;Button isLoading={false} /&gt;</span></pre><p id="c733" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但事实并非如此。我们利用了JSX和JavaScript强制的默认值，因此我们最终会得到:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="addb" class="nf mb iq na b gy ng nh l ni nj">&lt;Button isLoading/&gt;</span></pre><p id="600f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能看起来模糊不清，因为没有明确说明按钮是否显示加载程序。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="b697" class="nf mb iq na b gy ng nh l ni nj">// This is much better<br/>&lt;Button loading /&gt;</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="4b03" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">考虑组件用例</h1><p id="66f0" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我发现一个有用的思维过程是基于组件的用例来设计组件道具。</p><p id="4f12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们与团队中的设计师进行了讨论，我们决定我们需要一个具有显示加载状态功能的<code class="fe mx my mz na b">Button</code>。</p><p id="7818" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总的来说，我们有两种选择。我们可以实现<code class="fe mx my mz na b">loading</code>道具或者<code class="fe mx my mz na b">notLoading</code>道具。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="b3ef" class="nf mb iq na b gy ng nh l ni nj">// WITH LOADING PROPS</span><span id="8904" class="nf mb iq na b gy nk nh l ni nj">// Button in normal state<br/>&lt;Button /&gt;</span><span id="27d5" class="nf mb iq na b gy nk nh l ni nj">// Button in loading state<br/>&lt;Button loading/&gt;</span><span id="0eb0" class="nf mb iq na b gy nk nh l ni nj">// WITH NOTLOADING PROPS</span><span id="d93d" class="nf mb iq na b gy nk nh l ni nj">// Button in normal state<br/>&lt;Button notLoading={false} /&gt;</span><span id="9b1a" class="nf mb iq na b gy nk nh l ni nj">// Button in loading state<br/>&lt;Button /&gt;</span></pre><p id="4385" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，这里的<code class="fe mx my mz na b">Button</code>的大多数用例不会使用加载状态。这种情况下，最好是用<code class="fe mx my mz na b">loading</code> <strong class="ky ir"> </strong>道具，而不是<code class="fe mx my mz na b">notLoading</code> <strong class="ky ir">。</strong></p><p id="02b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">否则，我们的代码库中将会有很多这样的实现:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="380b" class="nf mb iq na b gy ng nh l ni nj">&lt;Button notLoading={false} /&gt;</span></pre><p id="4bb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了一个思维练习，如果我们有<code class="fe mx my mz na b">Button</code> <em class="ls"> </em>组件的相反行为呢？</p><p id="ec41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在与你的设计师交谈后，你发现我们需要另一个按钮，这个按钮大部分时间都处于加载状态。我们姑且称这个组件为<code class="fe mx my mz na b">LoadingButton</code>。</p><p id="f7f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用与<code class="fe mx my mz na b">Button</code>组件相同的API，我们将不得不在大多数时候这样做:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="82ae" class="nf mb iq na b gy ng nh l ni nj">&lt;LoadingButton loading /&gt;</span></pre><p id="9ed5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们确信大多数用例将显示加载状态，所以我们可以改变实现，以便当我们想要显示带有<code class="fe mx my mz na b">Loading</code>状态的<code class="fe mx my mz na b">LoadingButton</code>时:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="85c8" class="nf mb iq na b gy ng nh l ni nj">// Displaying the loader<br/>&lt;LoadingButton /&gt;</span><span id="2455" class="nf mb iq na b gy nk nh l ni nj">// Not displaying the loader<br/>&lt;LoadingButton notLoading /&gt;</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ad00" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">样式属性名称与CSS属性名称相同</h1><p id="0aa5" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">有时，我们希望添加功能来修改组件的CSS属性。最好使用与CSS属性相同的属性名。</p><p id="773e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原因是让它尽可能直观，因为作为前端开发人员，我们经常使用CSS。</p><p id="ac61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们想改进我们的<code class="fe mx my mz na b">Button</code>组件，这样它就可以接收道具来使用十六进制修改它的颜色和文本颜色。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="9bc1" class="nf mb iq na b gy ng nh l ni nj">&lt;Button color=”#000” textColor=”#fff” /&gt;</span></pre><p id="d1a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以更新组件的道具名称，因此我们有这样的名称:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="9064" class="nf mb iq na b gy ng nh l ni nj">&lt;Button backgroundColor=”#000” color=”#fff” /&gt;</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="17f3" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">事件处理程序属性</h1><p id="3024" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们想给按钮添加点击功能。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="bbd6" class="nf mb iq na b gy ng nh l ni nj">function onClickHandler = () =&gt; console.log('Clicked!')</span><span id="e912" class="nf mb iq na b gy nk nh l ni nj">&lt;Button onClickButton={onClickHandler}/&gt;<br/>// vs<br/>&lt;Button onClick={onClickHandler}/&gt;</span></pre><p id="cd49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，使用<code class="fe mx my mz na b">onClick</code>道具而不是<code class="fe mx my mz na b">onClickButton</code> <strong class="ky ir"> </strong>会更好，因为最好让<code class="fe mx my mz na b">eventHandler</code>道具名称尽可能接近事件名称本身，除非我们需要将事件与特定的上下文联系起来，或者我们有多个类似的事件。</p><p id="fad3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们考虑一个有取消和确认按钮的模态组件。</p><p id="57b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在这里实现<code class="fe mx my mz na b">onCancel</code>和<code class="fe mx my mz na b">onConfirm</code>，或者<code class="fe mx my mz na b">onClickCancelButton</code>和<code class="fe mx my mz na b">onClickConfirmButton</code> <strong class="ky ir">。</strong></p><p id="9a8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我更喜欢<code class="fe mx my mz na b">onCancel</code> <strong class="ky ir"> </strong>和<code class="fe mx my mz na b">onConfirm</code> <strong class="ky ir">，</strong>，因为<code class="fe mx my mz na b">onClick</code>部分附属于<code class="fe mx my mz na b">Button</code>组件，它们在字符上更短，并且仍然不失从用户角度取消或确认的上下文。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="f02b" class="nf mb iq na b gy ng nh l ni nj">// Modal Component<br/>function Modal ({ children, onCancel, onConfirm }) {<br/> return (<br/>  &lt;div&gt;<br/>   {children}<br/>   &lt;Button onClick={onCancel}&gt;Cancel&lt;/Button&gt;<br/>   &lt;Button onClick={onConfirm}&gt;Confirm&lt;/Button&gt;<br/>  &lt;/div&gt;<br/> )<br/>}</span><span id="000d" class="nf mb iq na b gy nk nh l ni nj">// Usage<br/>&lt;Modal <br/> onCancel={() =&gt; console.log('Cancelled!')} <br/> onConfirm={() =&gt; console.log('Confirmed!')} <br/>&gt;<br/> Are you sure you want to delete this item?<br/>&lt;/Modal&gt;</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="13de" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">尽可能地抽象化</h1><p id="82a1" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">例如，我们想要实现一个<code class="fe mx my mz na b">MultiSelect</code> <em class="ls"> </em>组件，它基本上是一个由可搜索的复选框选项列表组成的组件。显示的选项只是与搜索相关的选项。</p><p id="292f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们有两个选项，在组件内部实现搜索功能(选项A)或者将搜索的责任转移到父组件(选项B)。</p><p id="3cf8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简单起见，让我们假设我们已经实现了<code class="fe mx my mz na b">Option</code>组件。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="1f2a" class="nf mb iq na b gy ng nh l ni nj">// Option A<br/>function MultiSelect ({ options, onSelectOption, searchInputValue, onSearch }) {<br/> return (<br/>  &lt;div&gt;<br/>   &lt;input value={searchInputValue} onChange={onSearch} placeholder="Search here" /&gt;<br/>   &lt;ul&gt;<br/>    {<br/>     options.map((option) =&gt; &lt;Option value={option.value} label={option.label} onClick={onSelectOption} /&gt;)}<br/>   &lt;/ul&gt;<br/>  &lt;/div&gt;<br/> )<br/>}</span><span id="8aba" class="nf mb iq na b gy nk nh l ni nj">// Option A Usage<br/>function ParentComponent () {<br/> const options = ['Cat', 'Dog', 'Mouse', 'Elephant']</span><span id="7950" class="nf mb iq na b gy nk nh l ni nj"> const [ searchInputValue, setSearchInputValue ] = useState('');<br/> const onSearchHandler = ({ target }) =&gt; {<br/>  setSearchInputValue(target.value)<br/> }</span><span id="97d1" class="nf mb iq na b gy nk nh l ni nj"> const [ selectedOptions, setSelectedOptions ] = useState([])<br/> // Implement the filter<br/> const filteredOptions = options.filter((option) =&gt; option.includes(searchInputValue))</span><span id="b702" class="nf mb iq na b gy nk nh l ni nj"> return (<br/>  &lt;MultiSelect <br/>   options={filteredOptions} <br/>   searchInputValue={searchInputValue}<br/>   onSearch={setSearchInputValue}<br/>   onSelectOptions={setSelectedOptions}<br/>  &gt;<br/> )<br/>}</span></pre><p id="e00e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同时，考虑选项B的实现:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="c325" class="nf mb iq na b gy ng nh l ni nj">// Option B <br/>function MultiSelect ({ options, onSelectOption }) {<br/> const [ search, setSearch ] = useState('');<br/> onChangeSearchHandler = ({ target }) =&gt; {<br/>  setSearch(target.value);<br/> }</span><span id="2047" class="nf mb iq na b gy nk nh l ni nj">const filteredOptions = options.filter((option) =&gt; option.includes(search))</span><span id="3a42" class="nf mb iq na b gy nk nh l ni nj">return (<br/>  &lt;div&gt;<br/>   &lt;input value={searchInputValue} onChange={onChangeSearchHandler} placeholder="Search here" /&gt;<br/>   &lt;ul&gt;<br/>    {<br/>     filteredOptions.map((option) =&gt; &lt;Option value={option.value} label={option.label} onClick={onSelectOption} /&gt;)}<br/>   &lt;/ul&gt;<br/>  &lt;/div&gt;<br/> )<br/>}</span><span id="8133" class="nf mb iq na b gy nk nh l ni nj">// Option B Usage<br/>function ParentComponent () {<br/> const options = ['Cat', 'Dog', 'Mouse', 'Elephant']</span><span id="6759" class="nf mb iq na b gy nk nh l ni nj">const [ selectedOptions, setSelectedOptions ] = useState([])</span><span id="4fa5" class="nf mb iq na b gy nk nh l ni nj">return (<br/>  &lt;MultiSelect <br/>   options={options} <br/>   searchInputValue={searchInputValue}<br/>   onSearch={setSearchInputValue}<br/>   onSelectOptions={setSelectedOptions}<br/>  &gt;<br/> )<br/>}</span></pre><p id="8d3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中在<code class="fe mx my mz na b">ParentComponent</code> <em class="ls"> </em>端会有较少的实现。</p><p id="29d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们将在多个地方使用这个组件，我们需要在这些地方实现搜索功能。<code class="fe mx my mz na b">ParentComponent</code> <em class="ls"> </em>不需要知道任何关于搜索功能的实现。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="7962" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">抽象但可定制的组件</h1><p id="b335" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">将实现从用户和定制能力中抽象出来听起来是矛盾的，但这是可以做到的。</p><h2 id="99bc" class="nf mb iq bd mc nl nm dn mg nn no dp mk lf np nq mm lj nr ns mo ln nt nu mq nv bi translated">使用修饰符函数修改组件的内部功能</h2><p id="60cf" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">对用户隐藏实现和定制能力听起来是矛盾的。</p><p id="8586" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们回到我们的<code class="fe mx my mz na b">MultiSelect</code>组件，让我们添加另一个功能来使用自定义算法进行搜索。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="0a91" class="nf mb iq na b gy ng nh l ni nj">function MultiSelect ({ options, onSelectOption, searchModifier }) {<br/> const [ search, setSearch ] = useState('');<br/> onChangeSearchHandler = ({ target }) =&gt; {<br/>  setSearch(target.value);<br/> }</span><span id="bdeb" class="nf mb iq na b gy nk nh l ni nj">const filteredOptions = options.filter((option) =&gt; searchModifier instanceOf Function ? searchModifier(option, search) : option.includes(search))</span><span id="39bd" class="nf mb iq na b gy nk nh l ni nj">return (<br/>  &lt;div&gt;<br/>   &lt;input value={searchInputValue} onChange={onChangeSearchHandler} placeholder="Search here" /&gt;<br/>   &lt;ul&gt;<br/>    {<br/>     filteredOptions.map((option) =&gt; &lt;Option value={option.value} label={option.label} onClick={onSelectOption} /&gt;)}<br/>   &lt;/ul&gt;<br/>  &lt;/div&gt;<br/> )<br/>}</span></pre><h2 id="10e9" class="nf mb iq bd mc nl nm dn mg nn no dp mk lf np nq mm lj nr ns mo ln nt nu mq nv bi translated">使用渲染道具模式的自定义渲染器</h2><p id="e969" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在让组件的用户完全控制如何显示组件的情况下，我们可以使用render props模式。考虑这个实现:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="ef7c" class="nf mb iq na b gy ng nh l ni nj">function MultiSelect ({ options, onSelectOption, searchModifier, children }) {<br/> const [ search, setSearch ] = useState('');<br/> onChangeSearchHandler = ({ target }) =&gt; {<br/>  setSearch(target.value);<br/> }</span><span id="91d5" class="nf mb iq na b gy nk nh l ni nj"> const filteredOptions = options.filter((option) =&gt; searchModifier instanceOf Function ? searchModifier(option, search) :     option.includes(search))</span><span id="fafb" class="nf mb iq na b gy nk nh l ni nj"> if (children instanceOf Function) {<br/>  return children(filteredOptions, search, onChangeSearchHandler)<br/> }</span><span id="8461" class="nf mb iq na b gy nk nh l ni nj">return (<br/>  &lt;div&gt;<br/>   &lt;input value={searchInputValue} onChange={onChangeSearchHandler} placeholder="Search here" /&gt;<br/>   &lt;ul&gt;<br/>    {<br/>     filteredOptions.map((option) =&gt; &lt;Option value={option.value} label={option.label} onClick={onSelectOption} /&gt;)}<br/>   &lt;/ul&gt;<br/>  &lt;/div&gt;<br/> )<br/>}</span><span id="e6bb" class="nf mb iq na b gy nk nh l ni nj">// Usage<br/>function ParentComponent() {<br/> return (<br/>  &lt;MultiSelect&gt;<br/>   {<br/>    (options, searchValue, onChangeSearchHandler) =&gt; {<br/>    return <br/>     &lt;div&gt;<br/>      &lt;input value={searchValue} onChange={onChangeSearchHandler}/&gt;             <br/>      &lt;span&gt;Here are the option list!&lt;/span&gt;<br/>      {<br/>       options.map(option =&gt; &lt;span&gt;{option}&lt;/span)<br/>      }<br/>     &lt;/div&gt;</span><span id="f1f2" class="nf mb iq na b gy nk nh l ni nj"> }<br/>  &lt;/MultiSelect&gt;</span><span id="1ac3" class="nf mb iq na b gy nk nh l ni nj"> )<br/>}</span></pre><p id="3863" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们的目标更具体，我们可以为<code class="fe mx my mz na b">MultiSelect</code>组件<em class="ls">的某些部分实现一个特定的呈现器。</em>例如，我们可以传递<code class="fe mx my mz na b">searchInputRenderer</code> <em class="ls"> </em>，这样用户就可以控制如何显示搜索输入。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="ba4e" class="nf mb iq na b gy ng nh l ni nj">function MultiSelect ({ options, onSelectOption, searchModifier, children, searchInputRenderer }) {<br/>...</span><span id="11a2" class="nf mb iq na b gy nk nh l ni nj">return (<br/>  &lt;div&gt;<br/>   {<br/>    searchInputRenderer instanceOf Function ? <br/>    searchInputRenderer(searchInputValue, onChangeSearchHandler):<br/>    &lt;input value={searchInputValue} onChange={setSearch} placeholder="Search here" /&gt;<br/>   }<br/>   &lt;ul&gt;<br/>    {<br/>     filteredOptions.map((option) =&gt; &lt;Option value={option.value} label={option.label} onClick={onSelectOption} /&gt;)}<br/>   &lt;/ul&gt;<br/>  &lt;/div&gt;<br/> )</span><span id="5bdd" class="nf mb iq na b gy nk nh l ni nj">}</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ef48" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">关闭</h1><p id="d544" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">感谢阅读我的文章！请留下评论，分享你对设计一个合适的React组件的想法。</p></div></div>    
</body>
</html>