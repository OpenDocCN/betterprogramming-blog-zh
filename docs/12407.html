<html>
<head>
<title>6 Recommendations to Improve Your Rust Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改进Rust代码的6条建议</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rust-beginner-tips-8ecc2503517e?source=collection_archive---------4-----------------------#2022-06-03">https://betterprogramming.pub/rust-beginner-tips-8ecc2503517e?source=collection_archive---------4-----------------------#2022-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="819b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Rust初学者提示</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2f9c56bbd7f2ac8ecf29c95f9acaadae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GpgSUkKArU-T0j7X"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">罗曼·辛克维奇·🇺🇦在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d391" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一次，我想发布一个非常简单的帖子，为刚接触Rust的人提供六个非常基本的提示和建议。</p><h1 id="e293" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">如果让</h1><p id="0108" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您可能已经用一个匹配的分支和一个空块编写了一些<code class="fe mp mq mr ms b">match</code>,对剩下的选项不做任何事情。例如，当你得到<code class="fe mp mq mr ms b">Some(foo)</code>、<code class="fe mp mq mr ms b">Err(error)</code>或<code class="fe mp mq mr ms b">Ok(bar)</code>时，才执行一个动作。对于那些病例，我们有<code class="fe mp mq mr ms b">if let</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">如果let清晰并节省无用代码</p></figure><h1 id="256a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为结果取别名以保存错误声明</h1><p id="cba7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这个选项带有个人偏好，但是如果您在同一个文件或模块中一遍又一遍地声明相同的结果，它会非常有用。正如你在<code class="fe mp mq mr ms b"><a class="ae kv" href="https://doc.rust-lang.org/stable/std/io/type.Result.html" rel="noopener ugc nofollow" target="_blank">std::io::Result</a></code>中看到的，它甚至用在了<code class="fe mp mq mr ms b">std</code>库中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">为结果创建新的别名允许您使用“默认错误”</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/80f69ea416e1d35f294311cdeff44f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g5XUGV1hbvYslAwnluCDEw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">IDE仍然会给我们一个返回错误的链接</p></figure><h1 id="ccc8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">include_str！并且包含_字节！</h1><p id="418a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这两个宏对于一些项目非常有用，特别是在基于文本输入的原型或小程序的时候，比如代码 的<a class="ae kv" href="https://adventofcode.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">到来的挑战。</strong></a></p><p id="3d5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们的使用非常简单，它们读取指定路径中的文件，并在文件初始化时将内容保存在一个常量中。这将允许您不硬编码一些有问题的或大的字符串常量，您甚至可以将它们从版本控制中取出。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在我们的代码中，令牌被完美地加载为常量</p></figure><h1 id="395b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用enumerate获取集合索引</h1><p id="c724" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果您来自其他语言，并且希望迭代一个集合并同时获取索引，那么您可能会默认编写一个for循环来迭代零和集合长度之间的数字，然后访问索引中的项。在Rust中你可以使用<a class="ae kv" href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.enumerate" rel="noopener ugc nofollow" target="_blank">枚举</a>。</p><p id="6c1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">enumerate</code>是来自令人敬畏的<strong class="ky ir">迭代器特征</strong>的方法之一。在迭代器调用的末尾添加这个方法会将每个循环的内容变成一个包含索引和值的元组。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">它更加清晰，我们甚至可以保存打印的参数(vec[i]不能在文字字符串中使用)</p></figure><h1 id="9cb3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">自己</h1><p id="9004" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Self是一个强大的关键字，可以有自己完整的帖子，尤其是当你使用<strong class="ky ir">定义特征</strong>时，但是它最基本的用途是在你实现structs时作为一个好的推荐。</p><p id="6826" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它将允许你用一个固定的词来引用块的所有者，例如，如果你决定重命名这个结构，这样可以节省你一些时间。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">如果我把Foo改为BetterName，我就不必修改第二个方法</p></figure><h1 id="4cb1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">阅读&amp;[T]而不是&amp;Vec <t/></h1><p id="5e60" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">很多时候，我们必须实现读取元素集合的函数。在这些情况下，我们可以请求<code class="fe mp mq mr ms b">&amp;[T]</code>而不是借用的向量。这将为我们提供相同的功能(如果我们只是想读的话)和更多的灵活性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">同一功能处理更多类型和功能</p></figure><p id="8e1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天到此为止。将来，我可能会制作第二版，增加一些额外的小技巧，比如块的使用或者一些有用的宏。在此之前，您可以一如既往地查看一下<a class="ae kv" href="https://github.com/kriogenia/medium/tree/main/beginning_tips/src" rel="noopener ugc nofollow" target="_blank">范例库</a>。</p><div class="mw mx gp gr my mz"><a href="https://github.com/kriogenia/medium/tree/main/beginning_tips" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">中等/开始_主要克里金属的提示/中等</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">存放我在Medium帖子中使用的示例的存储库- medium/beginning_tips位于main kriogenia/medium</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn kp mz"/></div></div></a></div></div></div>    
</body>
</html>