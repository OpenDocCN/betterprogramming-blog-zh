<html>
<head>
<title>Exploring Strings in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索生锈的琴弦</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/strings-in-rust-28c08a2d3130?source=collection_archive---------0-----------------------#2022-01-30">https://betterprogramming.pub/strings-in-rust-28c08a2d3130?source=collection_archive---------0-----------------------#2022-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="829c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">新人概述</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2de52c38b9ac343435524c74f4a46b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QSGqF71DU2cEqJ7lFgaGlQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">感谢<a class="ae kv" href="https://basakunal.design/" rel="noopener ugc nofollow" target="_blank"><em class="kw"/></a></p></figure><p id="64d4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个主题通常会让Rust初学者感到困惑，今天我想写点东西。我试着继续创作一首老歌，但不知何故却无法进入状态。做点有成效的事总比什么都不做好。</p><p id="d01b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">也许最好从问计算机如何存储和解释字符序列这个问题开始。我们来刷新一些基本面。</p><ul class=""><li id="5652" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">计算机内存的布局是按顺序存储字节(8位字节)，在今天的普通计算机中是一个接一个的。</li><li id="9619" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">字节可以代表任何东西。我们是那些碰巧在某些领域达成共识并赋予它们意义的人。有了这种力量，我们也可以把他们解读为人物。人们制作表格来商定历史上哪些字节应该映射到哪些字符。参见<a class="ae kv" href="https://ascii.cl/" rel="noopener ugc nofollow" target="_blank"> ASCII </a>或<a class="ae kv" href="https://unicode-table.com/en/" rel="noopener ugc nofollow" target="_blank"> Unicode </a>表格。第一个是最小表，其中每个不同的字符可以用一个字节表示，但在后者中，甚至可能需要4个字节来定义一个字符。检查<a class="ae kv" href="https://stackoverflow.com/questions/5290182/how-many-bytes-does-one-unicode-character-take" rel="noopener ugc nofollow" target="_blank">该</a>螺纹是否脱落。Unicode是一个非常大的表，包含了大量的字符，并且仍然有空余的空间。</li><li id="57b6" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">字符串是我们承诺按照字符表解释的字节序列。我们通过使用我们所使用的编程语言的类型系统来做出这个承诺。在Rust中，我们简单地将一块内存称为<code class="fe mh mi mj mk b">String</code>或<code class="fe mh mi mj mk b">str</code>或<code class="fe mh mi mj mk b">&amp;str</code>或<code class="fe mh mi mj mk b">&amp;String</code>或<code class="fe mh mi mj mk b">Box&lt;str&gt;</code>或<code class="fe mh mi mj mk b">Box&lt;&amp;str&gt;</code>或..</li></ul><p id="e9e9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我想你已经理解了这篇文章想要阐明的内容。</p><h1 id="09e9" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">一点C和JS</h1><p id="7d69" class="pw-post-body-paragraph kx ky iq kz b la nd jr lc ld ne ju lf lg nf li lj lk ng lm ln lo nh lq lr ls ij bi translated">在我看来，大多数开始学习Rust的人要么来自Java Script，要么来自C或C++背景。在深入研究Rust类型之前，值得一提的是我们如何处理这些语言中的字符串。</p><p id="bfd2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在C #中，可以用以下方式定义字符串。它们有时也被称为字符数组。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="47c5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">注意第三个例子末尾的<code class="fe mh mi mj mk b">'\0'</code>字符。</p><p id="035e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是在事先不知道序列长度的情况下，理解计算机内存中一个字符序列何时结束的一种方式。那个角色叫做终结者。以该字符(一个空字节)结束的字符串类型称为<a class="ae kv" href="https://en.wikipedia.org/wiki/Null-terminated_string" rel="noopener ugc nofollow" target="_blank">空终止字符串。</a></p><p id="c3a2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在下面的例子中它们会派上用场，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0661" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe mh mi mj mk b"><a class="ae kv" href="https://github.com/bminor/glibc/blob/master/string/strcpy.c" rel="noopener ugc nofollow" target="_blank">strcpy</a></code>在<a class="ae kv" href="https://github.com/bminor/glibc" rel="noopener ugc nofollow" target="_blank"> glibc </a>实现中使用<code class="fe mh mi mj mk b"><a class="ae kv" href="https://github.com/bminor/glibc/blob/master/string/strlen.c" rel="noopener ugc nofollow" target="_blank">strlen</a></code>。看看在<a class="ae kv" href="https://github.com/bminor/glibc/blob/master/string/strlen.c" rel="noopener ugc nofollow" target="_blank"> strlen </a>的实现中，实现者是如何试图捕捉空字节来导出字符串的长度的？</p><p id="4404" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是所有的字符串都是空终止的吗？或者它们需要空终止吗？这是导出字符串边界的唯一方法吗？</p><p id="9239" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们来看看JavaScript。</p><pre class="kg kh ki kj gt nk mk nl nm aw nn bi"><span id="003c" class="no mm iq mk b gy np nq l nr ns">let string = "banAna".toLowerCase();<br/>let concatinatedString = "I want a cherry " + string;<br/>let shout = concatinatedString.toUpperCase() + "!!";</span></pre><p id="ad30" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Java Script引擎在哪里存储这个字符串，我们如何在这个自由度上使用它？</p><p id="a26d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">字符串文字在JavaScript中是基本类型，但是有一个问题。你注意到我们可以在字符串上使用<code class="fe mh mi mj mk b">toLowerCase</code>方法了吗？</p><p id="d2bd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们能够做到这一点的原因是，底层JavaScript引擎创建了一个<code class="fe mh mi mj mk b">String</code>对象，一旦它理解了我们在其上调用的方法，该对象就会在一小段时间内包装文字。</p><p id="9573" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当方法返回时，实例化的临时对象没有任何用途并被释放。</p><p id="2376" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您也可以明确地告诉引擎创建这个对象。</p><pre class="kg kh ki kj gt nk mk nl nm aw nn bi"><span id="9150" class="no mm iq mk b gy np nq l nr ns">let string = new String("banana");</span></pre><p id="510d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你想深入研究，这里是一个叫做<a class="ae kv" href="https://v8.dev/" rel="noopener ugc nofollow" target="_blank"> V8 </a>的流行引擎的<a class="ae kv" href="https://v8docs.nodesource.com/node-0.8/d2/db3/classv8_1_1_string.html" rel="noopener ugc nofollow" target="_blank">字符串类</a>。该类有许多有用的方法，其中之一是<code class="fe mh mi mj mk b">length</code>，它返回该字符串中的字符数。</p><p id="f134" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">由于引擎负责解释JS代码并在必要时在运行时包装文字，它还在包装它的类的实例中存储和更新字符串的长度。</p><p id="93e9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这样就不需要空终止符了，构造类型时长度是已知的。我没有检查它到底是如何做到的，但这个概念应该是有效的。</p><p id="b8c4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">正如您可能已经猜到的那样，以null结尾的字符串并不是编码字符串长度信息的唯一方式，JS也没有使用它们。</p><p id="9894" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">V8或另一个JS引擎的实现细节非常复杂。主要是因为性能优化和快速解释动态类型语言的必要性。如果你有兴趣，这里有中的兔子洞可以跳<a class="ae kv" href="https://github.com/v8/v8" rel="noopener ugc nofollow" target="_blank">！</a></p><p id="39f2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Rust也不使用以null结尾的字符串，但是可以根据需要使用它们。在这篇文章的结尾，我将给出一个例子。</p><h1 id="6e05" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">回到铁锈</h1><p id="ab0f" class="pw-post-body-paragraph kx ky iq kz b la nd jr lc ld ne ju lf lg nf li lj lk ng lm ln lo nh lq lr ls ij bi translated">我们已经学习了前面的部分，将一些基本原理内化了。</p><ul class=""><li id="5f16" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">字符串只是一个字节序列，根据我们选择遵循哪种共识(编码)，可以有不同的解释方式。</li><li id="c96c" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">为了对字符串做一些有用的事情，我们需要知道字节序列在计算机内存中的开始和结束位置。</li><li id="fd2c" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">简单或复杂的数据结构可以建立在该字节序列上，以存储或导出关于它们的属性，并添加功能来使用它们做有用的事情。</li></ul><p id="cb68" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当我们试图理解文章中的生锈部分时，这种理解会帮助我们。</p><h2 id="12e3" class="no mm iq bd mn nt nu dn mr nv nw dp mv lg nx ny mx lk nz oa mz lo ob oc nb od bi translated">潜艇用热中子反应堆（submarine thermal reactor的缩写）</h2><p id="010b" class="pw-post-body-paragraph kx ky iq kz b la nd jr lc ld ne ju lf lg nf li lj lk ng lm ln lo nh lq lr ls ij bi translated">c #字符串不在内部强制任何编码。它们只是一个等待解释的普通字节序列，有一个空终止符。<br/> Java Script字符串使用<a class="ae kv" href="https://en.wikipedia.org/wiki/UTF-16" rel="noopener ugc nofollow" target="_blank"> UTF-16 </a>编码。<br/>锈串是用<a class="ae kv" href="https://en.wikipedia.org/wiki/UTF-8" rel="noopener ugc nofollow" target="_blank"> UTF-8 </a>编码的。</p><p id="13e7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们要看的第一种类型叫做Rust中的字符串切片。大多数时候，你会看到它以<code class="fe mh mi mj mk b">&amp;str</code>的形式出现，或者伴随一生。<code class="fe mh mi mj mk b">&amp;'static str</code>或<code class="fe mh mi mj mk b">&amp;'a str</code>但稍后会有更多。</p><p id="d45a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们试着分配一个:</p><pre class="kg kh ki kj gt nk mk nl nm aw nn bi"><span id="760c" class="no mm iq mk b gy np nq l nr ns">let string: str = "banana";</span></pre><p id="b6c4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您将看到这段代码在编写时无法编译！<br/>错误如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/c24357ebd79f3f26fdf801b250903476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d7vmUg8SSJEn6NtGa0qnsA.png"/></div></div></figure><blockquote class="of og oh"><p id="9313" class="kx ky oi kz b la lb jr lc ld le ju lf oj lh li lj ok ll lm ln ol lp lq lr ls ij bi translated">目前有一个不稳定的功能，可能会使这段代码编译。<br/>如果你感兴趣，你可以在这里追踪那个<a class="ae kv" href="https://doc.rust-lang.org/beta/unstable-book/language-features/unsized-locals.html" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><p id="c936" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Rust中的所有切片都属于我们称之为动态大小类型的范畴。(<a class="ae kv" href="https://doc.rust-lang.org/reference/dynamically-sized-types.html" rel="noopener ugc nofollow" target="_blank">夏令时</a>)。在Rust行话中，那些有<code class="fe mh mi mj mk b">!Sized</code>自动特征实现的或者没有<code class="fe mh mi mj mk b">Sized</code>特征实现的。</p><p id="c869" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">编译器无法知道这个片在编译时应该有多长。它无法进行分配，因为它不知道要分配多少字节！</p><p id="ac21" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一个<code class="fe mh mi mj mk b"><a class="ae kv" href="https://doc.rust-lang.org/std/primitive.str.html" rel="noopener ugc nofollow" target="_blank">str</a></code>定义了内存中一个数据块的一个<em class="oi">片</em>，它被解释为一个字符序列，如此而已。不确定它存储在哪里，也不确定该切片会有多长。这就是为什么我们在写作的时候不能简单地使用这种类型。(铁锈1.58)</p><p id="39f9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们试着更明确一点。</p><h2 id="9bb9" class="no mm iq bd mn nt nu dn mr nv nw dp mv lg nx ny mx lk nz oa mz lo ob oc nb od bi translated">方框<str/></h2><p id="66aa" class="pw-post-body-paragraph kx ky iq kz b la nd jr lc ld ne ju lf lg nf li lj lk ng lm ln lo nh lq lr ls ij bi translated">有人可能会认为明确这些数据存储在哪里可以解决这个问题。为什么不是<a class="ae kv" href="https://doc.rust-lang.org/std/boxed/struct.Box.html" rel="noopener ugc nofollow" target="_blank">框</a>呢？换句话说，在堆上分配它，并获取一个指向它的指针。</p><pre class="kg kh ki kj gt nk mk nl nm aw nn bi"><span id="974f" class="no mm iq mk b gy np nq l nr ns">let string: Box&lt;str&gt; = Box::new(“banana”);</span></pre><p id="4353" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">不..</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/27638c0de58b69fe0f405d5bd2d2c05b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e3kf93sSOy3qIxWsUlACgw.png"/></div></div></figure><p id="eaaf" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">似乎<code class="fe mh mi mj mk b">Box::new("banana")</code>返回一个<code class="fe mh mi mj mk b">Box&lt;&amp;str&gt;</code>而不是一个<code class="fe mh mi mj mk b">Box&lt;str&gt;</code>。</p><p id="4055" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">也许我们可以取消对字面意思的引用，让它变成一个<code class="fe mh mi mj mk b">Box&lt;str&gt;</code>？</p><pre class="kg kh ki kj gt nk mk nl nm aw nn bi"><span id="42aa" class="no mm iq mk b gy np nq l nr ns">let string: Box&lt;str&gt; = Box::new(*"banana");</span></pre><p id="d9b7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后我们会得到，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/87df183dc7c26738afe0a6dd9f49b3fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b6L1pWEe16KsiWEPSGDQ6g.png"/></div></div></figure><p id="0a67" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">给你。我们不能拥有动态大小的类型，因为我们不了解它的界限。取消引用是获取引用所指向的数据的所有权的请求。</p><p id="8863" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">还有另一种方法来构造这种类型。我们将在最后回到这个问题，并阐明它为什么存在。</p><h2 id="0808" class="no mm iq bd mn nt nu dn mr nv nw dp mv lg nx ny mx lk nz oa mz lo ob oc nb od bi translated">&amp;str</h2><p id="4ee7" class="pw-post-body-paragraph kx ky iq kz b la nd jr lc ld ne ju lf lg nf li lj lk ng lm ln lo nh lq lr ls ij bi translated">这就把我们带到了<code class="fe mh mi mj mk b">&amp;str</code>。一种更常见的类型，你可能会遇到并更频繁地使用它。</p><p id="a1b2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这种类型在Rust中也称为字符串切片。将<code class="fe mh mi mj mk b"><a class="ae kv" href="https://doc.rust-lang.org/std/primitive.str.html" rel="noopener ugc nofollow" target="_blank">str</a></code>和<code class="fe mh mi mj mk b">&amp;str</code>都称为字符串片段可能会带来一些混乱。因为<code class="fe mh mi mj mk b"><a class="ae kv" href="https://doc.rust-lang.org/std/primitive.str.html" rel="noopener ugc nofollow" target="_blank">str</a></code>是一个<a class="ae kv" href="https://doc.rust-lang.org/reference/dynamically-sized-types.html" rel="noopener ugc nofollow" target="_blank"> DST </a>，所以不能简单地使用，所以当人们使用短语“字符串片段”时，人们几乎总是想要表示<code class="fe mh mi mj mk b">&amp;str</code>。因为在对话中使用更长的类似短语的字符串片段引用或指向字符串片段的指针是不方便的。</p><p id="ea67" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，这种类型对于编译器来说更容易处理，因为引用的大小在编译时总是已知的。共享引用(<code class="fe mh mi mj mk b"><a class="ae kv" href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html" rel="noopener ugc nofollow" target="_blank">&amp;</a></code>)是一个具有特殊承诺的指针。它总是指向有效数据，并且数据在它下面保持不变。</p><p id="54f1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在写的时候，指针(<code class="fe mh mi mj mk b">usize</code>)的常用长度是8字节，因为市面上大多是64位处理器。你可以在你的机器上自己检查一下。</p><pre class="kg kh ki kj gt nk mk nl nm aw nn bi"><span id="c644" class="no mm iq mk b gy np nq l nr ns">dbg!(std::mem::size_of::&lt;&amp;str&gt;());</span></pre><p id="73f9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">呜呜，这是指针的两倍大！16字节..</p><p id="6e78" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">原因是，包括字符串片在内的任何片实际上都是一个叫做<a class="ae kv" href="https://www.quora.com/What-is-a-fat-pointer" rel="noopener ugc nofollow" target="_blank">胖指针</a>的东西，它使用它的前8个字节存储它所指向的片的第一个字节的内存地址，并使用后半部分存储该片的长度！</p><p id="bad8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">长度信息随后可以在运行时使用。</p><pre class="kg kh ki kj gt nk mk nl nm aw nn bi"><span id="e08f" class="no mm iq mk b gy np nq l nr ns">let string: &amp;str = "banana";<br/>dbg!(string.len()) </span><span id="a694" class="no mm iq mk b gy ov nq l nr ns">// Outputs: string.len() = 6</span></pre><p id="846f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">很公平，但是那个胖指针指向内存的哪个区域呢？堆、栈、静态存储？</p><p id="8ae8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们不需要知道，在使用切片的情况下，我们不在乎！当我们得到一个切片时，我们只关心其中数据的属性和切片类型提供给我们的方法。切片只是底层数据的视图，存储在任何地方。</p><p id="a417" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在字符串文字的情况下，编译器实际上将它硬编码成二进制！这样做是因为在这种情况下，我们获取的数据切片是不可变的，它的值在编译时是已知的。</p><p id="75b1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">用<code class="fe mh mi mj mk b">cargo build</code>编译二进制文件，并在你选择的十六进制编辑器中打开你的二进制文件来检查内容。</p><p id="fd42" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是我们的权利:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/571cb327f1cae3dc7830d1706afd7a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ph_VZTZORBY6biViLZzO7Q.png"/></div></div></figure><p id="bf69" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了说明一个片所指向的数据可以被分配到任何地方，这里有一个分配在堆栈上，一个分配在堆上。</p><pre class="kg kh ki kj gt nk mk nl nm aw nn bi"><span id="d25d" class="no mm iq mk b gy np nq l nr ns">let banana_bytes: &amp;[u8] = &amp;[0x62,0x61,0x6e,0x61,0x6e,0x61];<br/>let heap_string: String = String::from("banana");</span><span id="ba6e" class="no mm iq mk b gy ov nq l nr ns">// Points to the stack<br/>// Unwrapping is safe here because we feed the data directly.<br/>// We know that it is valid data.<br/>let string: &amp;str = std::str::from_utf8(banana_bytes).unwrap();</span><span id="6c6d" class="no mm iq mk b gy ov nq l nr ns">// Points to the heap<br/>let string: &amp;str = &amp;heap_string;</span></pre><h2 id="9788" class="no mm iq bd mn nt nu dn mr nv nw dp mv lg nx ny mx lk nz oa mz lo ob oc nb od bi translated">线</h2><p id="5313" class="pw-post-body-paragraph kx ky iq kz b la nd jr lc ld ne ju lf lg nf li lj lk ng lm ln lo nh lq lr ls ij bi translated">到目前为止，我们见过的最有用的字符串类型是<code class="fe mh mi mj mk b">&amp;str</code>。除了前面的部分，如果一个字符串片指向堆，我们也可以通过把它写成<code class="fe mh mi mj mk b">&amp;mut str</code>来引用它。</p><p id="ada1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是一个可能有用的常见示例。<br/> <code class="fe mh mi mj mk b">make_ascii_uppercase</code>功能将<strong class="kz ir"> </strong>切片的内容修改到位。</p><pre class="kg kh ki kj gt nk mk nl nm aw nn bi"><span id="5eb1" class="no mm iq mk b gy np nq l nr ns">let mut string: String = "banana".to_owned();         <br/>let string_slice: &amp;mut str = &amp;mut string;         s.make_ascii_uppercase(); </span></pre><p id="c3a9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe mh mi mj mk b">&amp;str</code>类型本质上是不可变的。即使在少数情况下，我们可以对它进行可变引用，并可能改变底层数据的内容，但我们无法扩展为它分配的内存块。换句话说，它不能变大或变小。此外，有时我们可能不会选择使用参考资料。</p><p id="bafd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">出于这个目的以及这里没有列出的其他可能的目的，我们将使用类型<code class="fe mh mi mj mk b"><a class="ae kv" href="https://doc.rust-lang.org/stable/std/string/struct.String.html" rel="noopener ugc nofollow" target="_blank">String</a></code>。</p><p id="4c51" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">例如，它使以下操作成为可能，并且使用起来更加灵活:</p><pre class="kg kh ki kj gt nk mk nl nm aw nn bi"><span id="5f38" class="no mm iq mk b gy np nq l nr ns">let mut banana_string: String = String::from("banana");<br/>let mut cherry_string: String = String::from("I want a cherry");</span><span id="7555" class="no mm iq mk b gy ov nq l nr ns">banana_string += " ";<br/>cherry_string += &amp;banana_string;</span></pre><p id="30f8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">还有大量的<a class="ae kv" href="https://doc.rust-lang.org/stable/std/string/struct.String.html" rel="noopener ugc nofollow" target="_blank">方法</a>可以用于这种类型。</p><p id="3dd3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这种灵活性源于<code class="fe mh mi mj mk b"><a class="ae kv" href="https://doc.rust-lang.org/stable/std/string/struct.String.html" rel="noopener ugc nofollow" target="_blank">String</a></code>的大小增长或收缩的能力，以及它的堆分配特性。它与<code class="fe mh mi mj mk b"><a class="ae kv" href="https://doc.rust-lang.org/std/vec/struct.Vec.html" rel="noopener ugc nofollow" target="_blank">Vector</a></code>非常相似。</p><p id="18cc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果您执行:</p><pre class="kg kh ki kj gt nk mk nl nm aw nn bi"><span id="c0a5" class="no mm iq mk b gy np nq l nr ns">dbg!(std::mem::size_of::&lt;String&gt;());</span></pre><p id="364d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你会发现它比胖指针多一个字节。(ง︡'-'︠)</p><p id="3a8d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe mh mi mj mk b"><a class="ae kv" href="https://doc.rust-lang.org/stable/std/string/struct.String.html" rel="noopener ugc nofollow" target="_blank">String</a></code>不是指针，但它是一个结构。类型的大小增加了，因为它在里面多保存了一条有用的信息，这是它的容量大小。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d349" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">看看它是如何生长的。当我们超过它的容量时，<code class="fe mh mi mj mk b"><a class="ae kv" href="https://doc.rust-lang.org/stable/std/string/struct.String.html" rel="noopener ugc nofollow" target="_blank">String</a></code>的大小会翻倍，给我们更多的空间来存放更多的数据。</p><p id="54ce" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">其实<code class="fe mh mi mj mk b"><a class="ae kv" href="https://doc.rust-lang.org/stable/std/string/struct.String.html" rel="noopener ugc nofollow" target="_blank">String</a></code>型在锈源里是这样的。</p><pre class="kg kh ki kj gt nk mk nl nm aw nn bi"><span id="d96a" class="no mm iq mk b gy np nq l nr ns">pub struct String {<br/>    vec: Vec&lt;u8&gt;,<br/>}</span></pre><p id="ac92" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们也可以手工组装它，并将其分解成原始部件。尽管在大多数情况下这不是必需的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="e18e" class="no mm iq bd mn nt nu dn mr nv nw dp mv lg nx ny mx lk nz oa mz lo ob oc nb od bi translated">&amp;字符串</h2><p id="ab52" class="pw-post-body-paragraph kx ky iq kz b la nd jr lc ld ne ju lf lg nf li lj lk ng lm ln lo nh lq lr ls ij bi translated">在我们掌握了所有知识之后，这个应该很容易理解。它只是一个指向<code class="fe mh mi mj mk b"><a class="ae kv" href="https://doc.rust-lang.org/stable/std/string/struct.String.html" rel="noopener ugc nofollow" target="_blank">String</a></code>的指针。</p><p id="6a2e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">像任何瘦指针(<code class="fe mh mi mj mk b">usize</code>)一样，这种类型的大小在64位机器中是8字节长。</p><pre class="kg kh ki kj gt nk mk nl nm aw nn bi"><span id="473c" class="no mm iq mk b gy np nq l nr ns">dbg!(std::mem::size_of::&lt;String&gt;());<br/>// 24 bytes</span><span id="64dd" class="no mm iq mk b gy ov nq l nr ns">dbg!(std::mem::size_of::&lt;&amp;String&gt;());<br/>// 8 bytes</span></pre><h1 id="339e" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">回到装箱字符串</h1><h2 id="05ec" class="no mm iq bd mn nt nu dn mr nv nw dp mv lg nx ny mx lk nz oa mz lo ob oc nb od bi translated">方框<str/></h2><p id="a90e" class="pw-post-body-paragraph kx ky iq kz b la nd jr lc ld ne ju lf lg nf li lj lk ng lm ln lo nh lq lr ls ij bi translated">我们最后一次无法分配这一个。有了我们知道的新类型，我们可以像下面这样在堆上分配它:</p><pre class="kg kh ki kj gt nk mk nl nm aw nn bi"><span id="017c" class="no mm iq mk b gy np nq l nr ns">let string: Box&lt;str&gt; = String::from("banana").<a class="ae kv" href="https://doc.rust-lang.org/stable/src/alloc/string.rs.html#1757" rel="noopener ugc nofollow" target="_blank">into_boxed_str</a>();<br/>// or<br/>let string: Box&lt;str&gt; = Box::from("banana");<br/>// from implementation will yield the same result.</span></pre><p id="561a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你可能有理由对这种类型存在的原因感到好奇。我们不是已经有了一个更强大的堆分配结构叫做<code class="fe mh mi mj mk b"><a class="ae kv" href="https://doc.rust-lang.org/stable/std/string/struct.String.html" rel="noopener ugc nofollow" target="_blank">String</a></code>吗？</p><p id="6922" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们比较两者的大小:</p><pre class="kg kh ki kj gt nk mk nl nm aw nn bi"><span id="7f72" class="no mm iq mk b gy np nq l nr ns">dbg!(std::mem::size_of::&lt;Box&lt;str&gt;&gt;());<br/>// 16 bytes</span><span id="6354" class="no mm iq mk b gy ov nq l nr ns">dbg!(std::mem::size_of::&lt;String&gt;());<br/>// 24 bytes</span></pre><p id="7277" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">前者比后者短一个字节，而是一个胖指针。在极少数情况下，它可能有一些优势。我认为很少一部分读者会需要这种类型。</p><p id="a9a1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">关于合法使用的例子，请查看Rust source中的<a class="ae kv" href="https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src/libsyntax/symbol.rs#L82-L85" rel="noopener ugc nofollow" target="_blank"> Interner </a>结构。</p><h1 id="8136" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">Rust和空终止字符串</h1><p id="b55d" class="pw-post-body-paragraph kx ky iq kz b la nd jr lc ld ne ju lf lg nf li lj lk ng lm ln lo nh lq lr ls ij bi translated">如前所述，Rust默认不使用空终止字符串。<br/>相反，它使用胖指针或堆分配的结构来直接存储长度信息。虽然如果我们愿意，我们可以使用空终止的字符串。当在FFI上下文中使用C库时，这些特别有用。</p><p id="48e4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为此有两种类型。<code class="fe mh mi mj mk b">std::ffi::CStr</code>和<code class="fe mh mi mj mk b">std::ffi::CString</code>。<br/>如果你想了解更多，Rust文档非常简洁。<br/> <a class="ae kv" href="https://doc.rust-lang.org/std/ffi/struct.CStr.html" rel="noopener ugc nofollow" target="_blank"> CStr </a>，<a class="ae kv" href="https://doc.rust-lang.org/std/ffi/struct.CString.html" rel="noopener ugc nofollow" target="_blank"> CString </a>。</p><h1 id="b596" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">临终遗言</h1><p id="5c26" class="pw-post-body-paragraph kx ky iq kz b la nd jr lc ld ne ju lf lg nf li lj lk ng lm ln lo nh lq lr ls ij bi translated">本文并不声称是Rust中所有可能的字符串拼写错误和用法的详尽列表。</p><p id="48a2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">希望通过文章中的澄清，您可以对Rust如何看待字符串有一个大致的直觉和感觉，并希望这将在您将来遇到更多Rust类型时缓解您的理解过程。</p><p id="5309" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我在发表前回顾这篇文章时再次确认自己的知识时，在Stack Overflow中发现了一个优秀的<a class="ae kv" href="https://stackoverflow.com/questions/24158114/what-are-the-differences-between-rusts-string-and-str" rel="noopener ugc nofollow" target="_blank">线程</a>。如果你对这个主题感兴趣，你一定要去看看。</p></div></div>    
</body>
</html>