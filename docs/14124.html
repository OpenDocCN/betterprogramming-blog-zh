<html>
<head>
<title>Should You Multithread? An Experiment-Driven Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应该多线程吗？实验驱动的方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/should-you-multithread-an-experiment-driven-approach-92c09db6a1f?source=collection_archive---------14-----------------------#2022-11-08">https://betterprogramming.pub/should-you-multithread-an-experiment-driven-approach-92c09db6a1f?source=collection_archive---------14-----------------------#2022-11-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e0d6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">实现矩阵乘法，并从pThreads中了解开销</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ea4605247ac8787ee896c84027c17d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oeIvfvX1urUqXFja"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@metriics?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">夏羽·加尼翁</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="68a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名大学生，我一直想写一个多线程程序，但是在开始写之前，我从计算机科学转到了数学。今年夏天，我一直在重温一些我想做的旧项目，我终于找到了多线程。</p><p id="e932" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我一直认为多线程程序优于单线程程序，但是片刻的思考表明事实并非如此。产生和处理线程肯定会有一些计算开销；因此，像两个数相加这样的简单任务在多线程的情况下一定会花费更长的时间。</p><p id="4e71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将实现一个矩阵乘法例程，并尝试回答这个问题:我们甚至应该多线程吗？在这个过程中，我们检查代码执行需要多少时间，并使用一些简单的数学方法来构建一个“智能”矩阵乘法器，它将决定是否并行运行矩阵乘法例程。</p><p id="e15d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我假设读者熟悉C语言编程，具有相当于标准本科课程前几周的线性代数基础，有一台能够运行这些代码示例的计算机，并且对他们的编译器有足够的了解，能够为自己编译链接的代码。</p><h1 id="d4d4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">实现矩阵乘法</h1><p id="1c94" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在我们编写多线程矩阵乘法例程之前，我们应该有一个简单的矩阵库，它可以在单线程上运行。</p><p id="d0c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将矩阵实现为一个简单的结构，它跟踪行数、列数和条目数。我们将数据存储为<code class="fe mp mq mr ms b">double</code>类型，因为在大多数机器上，这对于涉及矩阵的标准计算任务来说已经足够精确了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="fae6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我更喜欢用一个<code class="fe mp mq mr ms b">double*</code>来存储数据，而不是一个<code class="fe mp mq mr ms b">double**</code>。后者允许我们以熟悉的<code class="fe mp mq mr ms b">data[i][j]</code>符号访问第<code class="fe mp mq mr ms b">i</code>行和第<code class="fe mp mq mr ms b">j</code>列的数据。然而，使用一个<code class="fe mp mq mr ms b">double**</code>会占用更多的内存空间，更重要的是，不能推广到处理张量。</p><p id="3980" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要创造和摧毁新矩阵的方法。下面代码中的错误处理充其量是微不足道的，但对于我们这里的目的来说应该足够了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5708" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果不能获取和设置数据，我们就无法有效地使用矩阵。因为我们使用线性数组来存储数据，所以我们必须实现自己的索引器，并首先存储数据。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="94f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们终于谈到了矩阵乘法。回想一下，给定两个矩阵<code class="fe mp mq mr ms b">A = [a_{ij}]</code>和<code class="fe mp mq mr ms b">B = [b_{ij}],</code>，当<code class="fe mp mq mr ms b">A</code>的行数等于<code class="fe mp mq mr ms b">B</code>的列数时，定义矩阵乘积<code class="fe mp mq mr ms b">AB</code>，在这种情况下，乘积由<code class="fe mp mq mr ms b">c_{ij} = \sum_{k=1}^N a_{ik}b_{kj}</code>给出。</p><p id="ad1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在代码中实现矩阵乘法，在最坏的情况下是<code class="fe mp mq mr ms b">O(N³)</code>，因此我们必须迭代结果<code class="fe mp mq mr ms b">( O(N²) )</code>的所有行和列，并且在乘积中的每个条目处，我们必须计算<code class="fe mp mq mr ms b">A</code>的第<code class="fe mp mq mr ms b">k</code>行和<code class="fe mp mq mr ms b">B</code> <code class="fe mp mq mr ms b">( O(N) )</code>的第<code class="fe mp mq mr ms b">k</code>列的点积。</p><p id="59b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一种算法叫做Strassen算法，可以把这个降到<code class="fe mp mq mr ms b">O(N^{~2.807})</code>，但是实现起来不切实际。我们的单线程矩阵乘法函数提取内点积，这将使向多线程实施的过渡更加平稳:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1dbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于测试来说，为我们的矩阵提供一个“漂亮的打印”例程是很好的。我们添加了最后一块:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4ab7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在有一个工作的矩阵乘法程序。我们可以通过做一些标准的测试矩阵乘法来试验新代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="6313" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">天真的多线程:大量的线程</h1><p id="9651" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先要尝试的是为N个点积中的每一个运行一个线程。对于小型矩阵来说，这可能接近核心的数量，但是对于大型矩阵来说，我们将很快产生数千个线程。</p><p id="3481" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们创建了一个名为<code class="fe mp mq mr ms b">thread_params</code>的新结构，它允许我们将必要的参数传递给<code class="fe mp mq mr ms b">matmul_subroutine</code>的包装代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f3bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">pthread</code>实现允许我们调用一个线程来运行带有<code class="fe mp mq mr ms b">void* (*)(void *)</code>签名的函数。<code class="fe mp mq mr ms b">void *</code>参数允许我们通过将<code class="fe mp mq mr ms b">void</code>指针转换为<code class="fe mp mq mr ms b">thread_params</code>指针来传递参数结构函数和子参数。</p><p id="c976" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们用下面的线程包装器代码替换对<code class="fe mp mq mr ms b">matmul_subroutine</code>的调用，该代码将前面的<code class="fe mp mq mr ms b">matmul_subroutine</code>包装在所需的<code class="fe mp mq mr ms b">void* (*)(void*)</code>调用签名中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="17e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们必须做一些<code class="fe mp mq mr ms b">pthread_t</code>管理来将参数传递给<code class="fe mp mq mr ms b">matmul_subroutine_thread</code>，但是除此之外，矩阵乘法的实现是相同的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9818" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，我们为乘积矩阵中的每个条目创建了一个新线程，并在每个线程中计算行列点积。最后，在返回指向产品的指针之前，我们等待所有线程返回。</p><p id="a058" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在主循环中运行以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a080" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以上代码的完整版本可以在<a class="ae kv" href="https://gist.github.com/KyroChi/6820ba6be6b652ff166bc0a08b12cb6f" rel="noopener ugc nofollow" target="_blank">这里</a>找到，在我的机器上，我得到了以下令人沮丧的结果:</p><pre class="kg kh ki kj gt mv ms mw bn mx my bi"><span id="5712" class="mz lt iq ms b be na nb l nc nd">Linear took     0.00017200 seconds<br/>Parallel took   0.00313400 seconds</span></pre><p id="ea1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并行乘法的执行时间大约是线性乘法的30倍！坏消息:多线程不是万能的。</p><h1 id="d6f3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><code class="fe mp mq mr ms b">pthread</code>管理费用</h1><p id="18c8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我想改进我的日常工作。我知道，在某个地方，使用所有可用的内核会有一些优势。我们需要找出如何找到这种优势。</p><p id="ba6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以很快猜测出是<code class="fe mp mq mr ms b">pthread_create</code>还是<code class="fe mp mq mr ms b">pthread_join</code>导致并行乘法运行得更慢，因为指针分配和数组索引不应该花费太多时间(不足以解释30倍的速度降低)，并且与线性例程相比，对<code class="fe mp mq mr ms b">pthread_create</code>和<code class="fe mp mq mr ms b">pthread_join</code>的调用是唯一的实质性差异。</p><p id="1890" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我很快发现对<code class="fe mp mq mr ms b">pthread_create</code>的调用花费了最多的时间。下面的代码量化了这些调用有多慢:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2423" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用<code class="fe mp mq mr ms b">clock_gettime</code>来测量时间，以获得墙时间而不是CPU时间，因为当测量多线程程序的性能时，CPU时间将总是高于相同程序的线性版本。这是因为CPU时间衡量执行了多少操作，调用线程管理函数会增加额外的CPU操作。请记住，多线程的最终目标是减少墙时间。</p><p id="35ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当运行时，上面的程序给我</p><pre class="kg kh ki kj gt mv ms mw bn mx my bi"><span id="080f" class="mz lt iq ms b be na nb l nc nd">Average amortized overhead:    0.00010 seconds <br/>Total elapsed overhead:         0.97482 seconds</span></pre><p id="18f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们创建的每一个线程，我们最终会为每个线程额外增加1万分之一秒。在一个已经有10，000个条目的矩阵中(例如，带有<code class="fe mp mq mr ms b">shape (100, 100))</code>的乘积)，我们在线性实现上增加了额外的一秒(这不太正确，我们稍后会解决这个问题)。</p><p id="2dcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将两个<code class="fe mp mq mr ms b">(1000, 1000)</code>矩阵相乘增加了100倍的额外开销:我们的程序仅创建线程就要花费大约一分半钟！这让我们猜测我们想要最小化我们创建的线程的数量。我们通过发现在多线程有意义之前矩阵必须有多大来解决这个问题。</p><h2 id="e602" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">最佳穿线条件</h2><p id="c5ec" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">设<code class="fe mp mq mr ms b">S</code>为<code class="fe mp mq mr ms b">A-&gt;n_rows * B-&gt;</code>，<code class="fe mp mq mr ms b">T</code>为<code class="fe mp mq mr ms b">matmul_subroutine</code>执行所花费的时间，<code class="fe mp mq mr ms b">C</code>为内核数量，<code class="fe mp mq mr ms b">h</code>为使用pthreads所花费的时间。那么(理论上)线性实现花费的时间量是<code class="fe mp mq mr ms b">ST</code>，而并行实现花费的时间量是<code class="fe mp mq mr ms b">ST/C + Sh</code>。将这些设置为彼此相等并求解<code class="fe mp mq mr ms b">T</code>，我们发现无论何时<code class="fe mp mq mr ms b">T = hC/(C-1)</code>，并行实现都应该优于线性实现。</p><p id="0ed4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的机器上，我有四个内核，所以理论上，当执行<code class="fe mp mq mr ms b">matmul_subroutine</code>的时间大约是<code class="fe mp mq mr ms b">4*h/3</code>时，并行实现应该开始胜过线性实现。</p><p id="4cc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe mp mq mr ms b">S</code>从计算中分出；也就是说，乘积数组的大小在计算中并不重要，唯一重要的是(从并行实现优于串行实现的角度来看)内部点积有多大。随着我们增加这个内部维度，<code class="fe mp mq mr ms b">T</code>增加(线性)。</p><p id="29a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经(大概)计算过<code class="fe mp mq mr ms b">h</code>。在我的机器上，我运行下面的代码来计算我的<code class="fe mp mq mr ms b">T</code>(再次，大约):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="fd50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哪些输出:</p><pre class="kg kh ki kj gt mv ms mw bn mx my bi"><span id="19db" class="mz lt iq ms b be na nb l nc nd">$ ./ht.o <br/> 100       took: 0.0000010<br/> 1000      took: 0.0000040<br/> 10000     took: 0.0000350<br/> 100000    took: 0.0004900<br/> 1000000   took: 0.0038400<br/> 10000000  took: 0.0313800<br/> 100000000 took: 0.3031080</span></pre><p id="88af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意这里明显的<code class="fe mp mq mr ms b">O(N)</code>行为是matmul子例程线性的结果。回想一下上面的内容，创建pthreads的开销是<code class="fe mp mq mr ms b">0.00010 seconds</code>，因此(大约)我们应该在<code class="fe mp mq mr ms b">T(n) = 4/3 * 0.00010</code>时并行运行该例程。这大约是<code class="fe mp mq mr ms b">n = 27000</code>。</p><h1 id="4f0a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">“更智能”的矩阵乘法</h1><p id="775e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们现在可以编写一个“更智能”的矩阵乘法例程，考虑主机的具体情况以获得最佳性能。对于具有“小”内部维度的矩阵乘法，我们应该使用并行实现，对于较大的内部维度，我们应该切换到并行实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="72b1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">标杆管理</h1><p id="91f2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">也许我们的理论分析没有击中要害，我们没有看到智能矩阵乘法带来的任何性能提升。为了测试这一点，我们将在42组内部维数增加的矩阵上运行乘法例程，并将每个乘法运行30次，以获得平均执行时间。我们的目标是展示当我们从串行实施切换到多线程实施时，斜率会降低:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="397b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用最佳拟合线来可视化改进。下面绘制的结果显示，与外推的非多线程实现(蓝色)相比，性能有了明显的提高:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/a4f144506b1d464e5d0a989d23c4ced4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q6SZkNY4BgqUekycwXcZyQ.png"/></div></div></figure><p id="50d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还注意到，近似值27，000太高，再做一点工作，我们就可以找到一个更优的截止值。这可能是由于我们在上面所做的简单计算中积累的误差造成的。</p><p id="2f21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的图是使用以下Python脚本生成的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="2f54" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">外卖食品</h1><p id="10ac" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">多线程并不总是正确的做法。使用多线程会带来额外的开销，根据应用程序的不同，应该找到多线程给定例程带来性能提升的临界点。</p></div></div>    
</body>
</html>