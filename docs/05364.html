<html>
<head>
<title>It’s Time to Abandon SwiftyJSON</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是时候抛弃SwiftyJSON了</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/time-to-abandon-swiftyjson-switch-jsondecoder-codable-407f9988daec?source=collection_archive---------5-----------------------#2020-07-02">https://betterprogramming.pub/time-to-abandon-swiftyjson-switch-jsondecoder-codable-407f9988daec?source=collection_archive---------5-----------------------#2020-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aa50" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JSON serialization vs . JSONDecoder vs . Swift yjson—使用Swift原生JSON decoder解析JSON以获得更好的性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0dad627841bbc4bfb3582ecb406a002a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7Cx9uSxjcWc3cLZb"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼尔·冯·阿彭在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="1b72" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">1.JSON解析是基础的一部分</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ly"><img src="../Images/fc9232347ffb73662d89e44fb4a1729c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dimasCJZK4A_X2_6"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@mirkoblicke?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mirko Blicke </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="4e8b" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">有很多著名的项目采用不同的方法和理念来处理JSON解析。<code class="fe mv mw mx my b">SwiftyJSON</code>大概是其中最早也是最受欢迎的一个。它不那么冗长且容易出错，并利用Swift强大的类型系统来处理所有细节。</p><p id="ab50" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated"><code class="fe mv mw mx my b">JSONSerialization</code>是大多数JSON解析项目的核心。它来自Swift的<a class="ae ky" href="https://developer.apple.com/documentation/foundation" rel="noopener ugc nofollow" target="_blank">基础</a>框架，将JSON转换成不同的Swift数据类型。在像<code class="fe mv mw mx my b">SwiftyJSON</code>这样的项目出现之前，人们使用原始的<code class="fe mv mw mx my b">JSONSerialization</code>来解析JSON对象。但是这可能很痛苦，因为值类型和JSON结构可能会有所不同。您需要手动处理错误，并将类型<code class="fe mv mw mx my b">Any</code>转换为Swift基础类型。更容易出错。</p><p id="98a0" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated"><code class="fe mv mw mx my b">JSONDecoder</code>与Swift 4一同发布，具有更先进、更有前途的功能。它将JSON对象解码成Swift对象，并采用<code class="fe mv mw mx my b">Decodable</code>协议。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="76ea" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">2.绩效基准</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/7299bdc2a0c7b4e10d8f34ab739d18b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8tWVrqLe7yQwjeMc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@hypefilms?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> David Guliciuc </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="3572" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">回顾过去几年，<code class="fe mv mw mx my b">SwiftyJSON</code>一直在我们的项目中扮演着重要的角色，将我们从原始的<code class="fe mv mw mx my b">JSONSerialization</code>痛苦中拯救出来。</p><p id="3f10" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">但是现在还兼容吗？让我们开始我们的基准测试来比较这三种方法:原始的<code class="fe mv mw mx my b">JSONSerialization</code>、<code class="fe mv mw mx my b">SwiftyJSON</code>和<code class="fe mv mw mx my b">JSONDecoder</code>。</p><p id="c61b" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">下面这个简单的<code class="fe mv mw mx my b">Tweet</code> JSON包含一个<code class="fe mv mw mx my b">Comments</code>数组和一个<code class="fe mv mw mx my b">Replies</code>嵌套数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="783a" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated"><code class="fe mv mw mx my b">Tweet</code>和<code class="fe mv mw mx my b">Comment</code>对象是被反序列化并映射到的JSON，它们采用<code class="fe mv mw mx my b">Codable</code>协议支持<code class="fe mv mw mx my b">JSONDecoder</code>。它们还有两个初始化器，一个用于来自<code class="fe mv mw mx my b">JSONSerialization</code>的<code class="fe mv mw mx my b">Dictionary</code>，另一个用于来自<code class="fe mv mw mx my b">SwiftyJSON</code>的<code class="fe mv mw mx my b">JSON</code>对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c4e9" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">这三种方法将在Xcode的单元测试中的<code class="fe mv mw mx my b">measure</code>块内运行<code class="fe mv mw mx my b">10</code>、<code class="fe mv mw mx my b">100</code>、<code class="fe mv mw mx my b">1000</code>、<code class="fe mv mw mx my b">10,000</code>和<code class="fe mv mw mx my b">100,000</code>次，以比较耗时:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3131" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">3.结果和分析</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/478fdc20df0f27b28cb7cd2cbda1c635.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3qMQW0PGSMbBge2mhCeC3Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片(用VISME制作)。</p></figure><p id="d824" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated"><code class="fe mv mw mx my b">SwiftyJSON</code>循环累加时耗时曲线最陡。数据显示，当循环进行到<code class="fe mv mw mx my b">100,000</code>时，它比<code class="fe mv mw mx my b">JSONDecoder</code>慢三倍，比<code class="fe mv mw mx my b">JSONSerialization</code>几乎慢六倍。</p><p id="7c68" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">是什么让它如此缓慢？</p><p id="7afc" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated"><code class="fe mv mw mx my b">SwiftyJSON</code>使用<code class="fe mv mw mx my b">JSONSerialization</code>反序列化JSON对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="1724" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">瓶颈显然在对象映射和检索过程中。当我查看这行代码时，发现了部分原因:</p><pre class="kj kk kl km gt nd my ne nf aw ng bi"><span id="6269" class="nh lh it my b gy ni nj l nk nl">return type == .array ? rawArray.map { JSON($0)} : nil</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5a46" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">当检索值时，它循环并映射每个对象到<code class="fe mv mw mx my b">JSON</code>对象。当我们处理嵌套数组时，时间复杂度和空间复杂度呈指数级增长。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="0278" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">4.结论</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5b71663c09559964a9b6f13eeb981828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d_-w3kz8u4yDTAkp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@brina_blum?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Brina Blum </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="cfd5" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">原始的<code class="fe mv mw mx my b">JSONSerialization</code>方法具有出色的性能，但是在处理真实世界的JSON时并不理想。没有人喜欢连锁的可选的、容易出错的、冗长的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b7d3" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated"><code class="fe mv mw mx my b">JSONDecoder</code>在我看来，这是因为它完美地平衡了性能和可用性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9aa3" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated"><code class="fe mv mw mx my b">SwiftyJSON</code>性能最差，相对于<code class="fe mv mw mx my b">JSONDecoder</code>比较啰嗦。这样的代码比原始的<code class="fe mv mw mx my b">JSONSerialization</code>要好，但不如<code class="fe mv mw mx my b">JSONDecoder</code>干净:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="95cd" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">在本文中，我们对这三种方法进行了基准测试。性能和代码可用性都证明是时候抛弃<code class="fe mv mw mx my b">SwiftyJSON</code>移民<code class="fe mv mw mx my b">JSONDecoder</code>了！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="d2d0" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">5.资源</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/2e55b779d13a5dd9b9edb8bc880d7225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LrLb4J5Bo7RXR7vp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@olav_ahrens?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Olav Ahrens rtne</a>拍摄。</p></figure><p id="094f" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">文中提到的所有<a class="ae ky" href="https://github.com/SwiftyJSON/SwiftyJSON" rel="noopener ugc nofollow" target="_blank">回购和代码</a>都可以在GitHub 上找到<a class="ae ky" href="https://github.com/ericleiyang/JSONExample" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>