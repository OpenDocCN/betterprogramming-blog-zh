<html>
<head>
<title>All About Solidity Data Locations — Storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">所有关于可靠性的数据位置—存储</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/all-about-solidity-data-locations-part-i-storage-e50604bfc1ad?source=collection_archive---------1-----------------------#2022-07-20">https://betterprogramming.pub/all-about-solidity-data-locations-part-i-storage-e50604bfc1ad?source=collection_archive---------1-----------------------#2022-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="804f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入了解存储参考和智能合同存储布局。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f761078eed4e0d85b3f78912f2945991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wQ8qcu_JCpelHtf9"/></div></div></figure><blockquote class="ku kv kw"><p id="55c9" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/solidity-tutorial-all-about-data-locations-dabd33212471">“所有关于数据位置”</a>子系列的第一部分。</p></blockquote><p id="5ae6" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">在今天的文章中，我们将更详细地介绍EVM中的一个重要数据位置:智能契约存储。</p><p id="ec51" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">我们将看到合同仓库的布局是如何工作的。如何写入程序集中的约定存储区？我们还将使用来自<a class="ae lu" href="https://docs.openzeppelin.com/" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin </a>和<a class="ae lu" href="https://compound.finance/docs" rel="noopener ugc nofollow" target="_blank"> Compound </a>的一些契约来学习<code class="fe ly lz ma mb b">storage</code>引用在实践中是如何工作的，同时学习这些流行契约和协议背后的可靠性代码。</p><h1 id="2507" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">目录</strong></h1><ul class=""><li id="2d4a" class="mu mv it la b lb mw le mx lv my lw mz lx na lt nb nc nd ne bi translated">介绍</li><li id="1b8d" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">存储布局</li><li id="222d" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">存储基础</li><li id="c685" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">与存储交互</li><li id="ab35" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">函数参数中的存储指针</li><li id="b414" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">函数体中的存储指针</li><li id="67d7" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">读取存储的成本。</li><li id="c366" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">结论</li></ul></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="67b0" class="mc md it bd me mf nr mh mi mj ns ml mm jz nt ka mo kc nu kd mq kf nv kg ms mt bi translated">介绍</h1><p id="e2a9" class="pw-post-body-paragraph kx ky it la b lb mw ju ld le mx jx lg lv nw lj lk lw nx ln lo lx ny lr ls lt im bi translated">理解以太坊和EVM连锁店的存储模式对于良好的智能合同开发是必不可少的。</p><p id="fd4b" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">您可以在智能合约上永久存储数据以便将来执行时可以访问的唯一位置是它的存储区。每个智能合约都在自己的永久存储中维护其状态。它的作用类似于<em class="kz">“智能合同的迷你数据库”</em>，但与其他数据库不同，该数据库是公开可访问的。存储在智能合约存储中的所有值都可供外部免费读取(通过静态调用)，而无需向区块链发送交易。</p><p id="c0ed" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">然而，写入存储是非常昂贵的。事实上，就汽油成本而言，这是EVM最昂贵的作业。存储器的内容可以通过<code class="fe ly lz ma mb b">sendTransaction</code>调用来改变。这种呼叫会改变状态。这就是契约级变量被称为状态变量的原因。</p><p id="3ff2" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">需要记住的一件重要事情是，根据以太坊和EVM的设计，一个契约既不能读取也不能写入它自己以外的任何存储。协定A可以从另一个协定B的存储中读取或写入的唯一方式是当协定B公开使其能够这样做的函数时。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="d270" class="mc md it bd me mf nr mh mi mj ns ml mm jz nt ka mo kc nu kd mq kf nv kg ms mt bi translated">存储基础</h1><p id="39b6" class="pw-post-body-paragraph kx ky it la b lb mw ju ld le mx jx lg lv nw lj lk lw nx ln lo lx ny lr ls lt im bi translated">智能协定的存储是一个持久的读写数据位置。这意味着，如果在一个事务中将数据写入协定存储中，那么一旦事务完成，数据就会持久保存。在该事务之后读取合同存储将检索由该先前事务写入/更新的数据。</p><p id="4f5e" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">每个合同都有自己的存储，可以对其进行描述并将其绑定到以下规则:</p><ul class=""><li id="890a" class="mu mv it la b lb lc le lf lv nz lw oa lx ob lt nb nc nd ne bi translated">保持状态变量</li><li id="3311" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">事务和函数调用之间的持久性</li><li id="9c0f" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">阅读是免费的，但写作是昂贵的</li><li id="668a" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">合同存储是在合同构建期间预先分配的。</li></ul><p id="6bef" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">驻留在存储器中的变量在固态中被称为状态变量。</p><p id="0e37" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">关于合同存储，您唯一应该记住的是:</p><blockquote class="oc"><p id="3771" class="od oe it bd of og oh oi oj ok ol lt dk translated">存储是长期的，昂贵的！</p></blockquote><p id="93e1" class="pw-post-body-paragraph kx ky it la b lb om ju ld le on jx lg lv oo lj lk lw op ln lo lx oq lr ls lt im bi translated">将数据保存到存储器中是EVM中需要最大量气体的操作之一。</p><p id="3736" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">写入存储的实际成本是多少？</p><p id="85e0" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">成本并不总是一样的，计算写入存储的气体是相当复杂的公式，尤其是最新的以太坊2.0升级以来)。</p><p id="b677" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">简单总结一下，写入存储的成本如下:</p><ul class=""><li id="d78d" class="mu mv it la b lb lc le lf lv nz lw oa lx ob lt nb nc nd ne bi translated">将存储槽(第一次，或者如果该槽不包含任何值)从零值初始化为非零值需要20，000 gas</li><li id="8b2d" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">编辑存储槽的值需要5000汽油</li><li id="9298" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">删除存储槽中的值可获得15，000汽油的退款</li></ul><p id="957b" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">阅读合约存储真的免费吗？</p><p id="d12c" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">智能合约的存储可以从外部(从EOA)自由读取。在这种情况下，不必支付汽油费。</p><p id="9528" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">但是，如果读取操作是修改合同、另一个合同或区块链上的状态的事务的一部分，则必须支付汽油费。</p><p id="b4c6" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">一个合同可以读取其他合同的存储吗？</p><p id="191c" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">默认情况下，在执行环境中，smart只能读取它自己的存储(我们稍后将通过<code class="fe ly lz ma mb b">SLOAD</code>)。但是，如果智能协定在其公共接口(ABI)中公开了允许从特定状态变量或存储槽读取数据的函数，则智能协定也可以读取其他智能协定的存储。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="2205" class="mc md it bd me mf nr mh mi mj ns ml mm jz nt ka mo kc nu kd mq kf nv kg ms mt bi translated">存储布局</h1><p id="61e0" class="pw-post-body-paragraph kx ky it la b lb mw ju ld le mx jx lg lv nw lj lk lw nx ln lo lx ny lr ls lt im bi translated">正如<a class="ae lu" href="https://blog.openzeppelin.com/ethereum-in-depth-part-2-6339cf6bddb9/" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin在他们的EVM深度第2部分文章</a>中所解释的，智能合约的存储是一个字寻址空间。这与内存或调用数据相反，内存或调用数据是线性数据位置(增长字节数组)，通过偏移量(字节数组中的索引)访问数据。</p><p id="d7d0" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">相反，智能合约存储是键-值映射(=数据库)，其中键对应于存储中的槽号，值是存储在该存储槽中的实际值。</p><p id="994c" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">智能合约的存储由槽组成，其中:</p><ul class=""><li id="1cda" class="mu mv it la b lb lc le lf lv nz lw oa lx ob lt nb nc nd ne bi translated">每个存储槽可以包含长达32字节的字。</li><li id="d5b8" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">存储槽从位置0开始(类似于数组索引)</li><li id="af45" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">总共有2个⁵⁶存储插槽可用(用于读/写)</li></ul><p id="c193" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">总而言之:</p><blockquote class="oc"><p id="030a" class="od oe it bd of og oh oi oj ok ol lt dk translated">智能合约的存储由2个⁵⁶槽组成，其中每个槽可以包含最大32字节的值。</p></blockquote><p id="4f3f" class="pw-post-body-paragraph kx ky it la b lb om ju ld le on jx lg lv oo lj lk lw op ln lo lx oq lr ls lt im bi translated">在幕后，契约存储是一个键值存储，其中256位的键映射到256位的值。每个存储槽中的所有值最初都设置为零，但也可以在契约部署期间初始化为非零值或某个特定值<code class="fe ly lz ma mb b">constructor</code>。</p><h2 id="77a4" class="or md it bd me os ot dn mi ou ov dp mm lv ow ox mo lw oy oz mq lx pa pb ms pc bi translated">作为机库货架的合同仓库</h2><p id="6238" class="pw-post-body-paragraph kx ky it la b lb mw ju ld le mx jx lg lv nw lj lk lw nx ln lo lx ny lr ls lt im bi translated"><a class="ae lu" href="https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/" rel="noopener ugc nofollow" target="_blank">在他的文章中，Steve Marx </a>将智能合约的存储描述为“<em class="kz">一个天文数字般大的数组，最初充满零，数组中的条目(索引)是合约的存储槽。”。</em></p><p id="004d" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">在现实世界中会是什么样子呢？我们如何用我们可能最熟悉的东西来表示智能契约的存储呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0d67a4c122177b5ad69f731abfcb2ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iErxLWW0CJjKHU8X"/></div></div><p class="pd pe gj gh gi pf pg bd b be z dk translated">合同仓库的布局与建筑供应商的机库非常相似。</p></figure><p id="1977" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">我邀请你去拜访你当地的建筑供应商！您将很好地了解智能合约的存储情况。</p><p id="d2e9" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">如果你特别去户外(卡车和货车去那里购买袋装水泥、砖块或钢轨)，你会注意到相当多的活动。克拉耶丝到处开车，速度非常快，从货架上拿东西。这相当于EVM在读取状态变量时所做的事情:</p><pre class="kj kk kl km gt ph mb pi pj aw pk bi"><span id="0b84" class="or md it mb b gy pl pm l pn po">contract<em class="kz"> Owner {<br/>    <br/>    </em>address<em class="kz"> _owner;</em></span><span id="23ac" class="or md it mb b gy pp pm l pn po">    function owner() public returns (address) {<br/>        return _owner;<br/>    }</span><span id="94f5" class="or md it mb b gy pp pm l pn po">}</span></pre><p id="4056" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">在上面的合同中，只有一个货架。EVM从“shelve 0”加载变量，然后卸载(到堆栈上)呈现给你。</p><h2 id="164d" class="or md it bd me os ot dn mi ou ov dp mm lv ow ox mo lw oy oz mq lx pa pb ms pc bi translated">状态变量的布局</h2><p id="c006" class="pw-post-body-paragraph kx ky it la b lb mw ju ld le mx jx lg lv nw lj lk lw nx ln lo lx ny lr ls lt im bi translated">首席Solidity开发人员<code class="fe ly lz ma mb b">chriseth</code>对合同的存储描述如下:</p><blockquote class="oc"><p id="2003" class="od oe it bd of og oh oi oj ok ol lt dk translated">“您可以将存储视为一个具有虚拟结构的大型阵列，这种结构在运行时无法更改，它是由合同中的状态变量决定的”。</p></blockquote><p id="317d" class="pw-post-body-paragraph kx ky it la b lb om ju ld le on jx lg lv oo lj lk lw op ln lo lx oq lr ls lt im bi translated">从上面的例子中，我们可以看到Solidity为你的契约的每个定义的状态变量分配了一个存储槽。对于静态大小的状态变量，从槽0开始，按照定义状态变量的顺序连续分配存储槽(规则不同</p><p id="3cfa" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">Chriseth在这里的意思是“不能在函数调用中创建存储”。<em class="kz">事实上，如果函数必须是持久的，那么通过函数在新的存储槽创建新的存储变量是没有意义的(然而</em> <code class="fe ly lz ma mb b"><em class="kz">mapping</em></code> <em class="kz">的情况略有不同)。</em></p><p id="23cf" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">智能协定的存储是在协定构造期间(在部署协定时)安排的。这意味着合同存储的布局在合同创建时就已经确定了。布局是基于您的契约级变量声明而“成形”的，并且这种布局不能被将来的方法调用所改变。</p><p id="186b" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">让我们使用<code class="fe ly lz ma mb b">solc</code>命令行工具来看看之前合同的实际存储布局。如果您运行以下命令:</p><pre class="kj kk kl km gt ph mb pi pj aw pk bi"><span id="7971" class="or md it mb b gy pl pm l pn po">solc contracts/Owner.sol --storage-layout --pretty-json</span></pre><p id="96c7" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">您将获得以下JSON输出:</p><pre class="kj kk kl km gt ph mb pi pj aw pk bi"><span id="d3b9" class="or md it mb b gy pl pm l pn po">======= contracts/Owner.sol:Owner =======<br/>Contract Storage Layout:<br/>{<br/>  "storage":<br/>  [<br/>    {<br/>      "astId": 3,<br/>      "contract": "contracts/Owner.sol:Owner",<br/>      "label": "_owner",<br/>      "offset": 0,<br/>      "slot": "0",<br/>      "type": "t_address"<br/>    }<br/>  ],<br/>  "types":<br/>  {<br/>    "t_address":<br/>    {<br/>      "encoding": "inplace",<br/>      "label": "address",<br/>      "numberOfBytes": "20"<br/>    }<br/>  }<br/>}</span></pre><p id="5b4e" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">从上面的JSON输出中，我们可以看到一个包含对象数组的<code class="fe ly lz ma mb b">storage</code>字段。该数组中每个对象引用一个状态变量名。我们还可以看到，每个变量都被映射到一个<code class="fe ly lz ma mb b">slot</code>，并且有一个底层的<code class="fe ly lz ma mb b">type</code>。</p><p id="75c5" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">这意味着变量<code class="fe ly lz ma mb b">_owner</code> <em class="kz"> </em>可以被更改为同一类型的任何有效值(在我们的例子中是<code class="fe ly lz ma mb b">address</code>)。然而，槽<code class="fe ly lz ma mb b">0</code>是为这个变量保留的，并且将一直存在。</p><p id="e31e" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">现在让我们来看看状态变量是如何在存储器中布局的(参见Solidity文档以获得进一步的理解)。</p><p id="fb32" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">考虑以下坚固性代码:</p><pre class="kj kk kl km gt ph mb pi pj aw pk bi"><span id="3eb3" class="or md it mb b gy pl pm l pn po">pragma solidity ^0.8.0;</span><span id="c747" class="or md it mb b gy pp pm l pn po">contract StorageContract {<br/>    <br/>    uint256 a = 10;<br/>    uint256 b = 20;</span><span id="ec02" class="or md it mb b gy pp pm l pn po">}</span></pre><p id="543e" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">所有静态大小的变量都按照它们被定义的顺序依次放入存储槽中。</p><p id="a79b" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">记住:存储器中的每个槽最多可以容纳32字节长的值。</p><p id="c40e" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">在我们上面的例子中，<code class="fe ly lz ma mb b">a</code>和<code class="fe ly lz ma mb b">b</code>是32字节长(因为它们的类型是<code class="fe ly lz ma mb b">uin256</code>)。因此，<strong class="la iu">它们被分配了自己的存储槽。</strong></p><h2 id="29ef" class="or md it bd me os ot dn mi ou ov dp mm lv ow ox mo lw oy oz mq lx pa pb ms pc bi translated">将状态变量打包在一个存储槽中。</h2><p id="b45f" class="pw-post-body-paragraph kx ky it la b lb mw ju ld le mx jx lg lv nw lj lk lw nx ln lo lx ny lr ls lt im bi translated">在我们之前的例子中没有什么特别的。但是现在让我们考虑这样一个场景，其中有几个不同大小的uint变量，如下所示:</p><pre class="kj kk kl km gt ph mb pi pj aw pk bi"><span id="d4f8" class="or md it mb b gy pl pm l pn po">pragma solidity ^0.8.0;</span><span id="09d8" class="or md it mb b gy pp pm l pn po">contract StorageContract {<br/><br/>    uint256 a = 10;<br/>    uint64 b = 20;<br/>    uint64 c = 30;<br/>    uint128 d = 40;</span><span id="6489" class="or md it mb b gy pp pm l pn po">    function readStorageSlot0() public view returns (bytes32 result) {</span><span id="984c" class="or md it mb b gy pp pm l pn po">        assembly {<br/>            result := sload(0)<br/>        }</span><span id="02ae" class="or md it mb b gy pp pm l pn po">    }</span><span id="51f3" class="or md it mb b gy pp pm l pn po">    function readStorageSlot1() public view returns (bytes32 result) {</span><span id="4be8" class="or md it mb b gy pp pm l pn po">        assembly {<br/>            result := sload(1)<br/>        }<br/>    <br/>    }</span><span id="7a00" class="or md it mb b gy pp pm l pn po">}</span></pre><p id="8b20" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">我们已经编写了两个基本函数来读取底层的契约存储槽。查看输出，我们得到以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/5094ac32f4aeb133ea698b68bcf40619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9RwKZ8Ho4TiJzyAZ27N9Zw.png"/></div></div></figure><p id="95e3" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">坚固性文件说明:</p><blockquote class="oc"><p id="2cfd" class="od oe it bd of og oh oi oj ok ol lt dk translated">“如果可能，需要少于32个字节的多个连续项目被打包到单个存储槽中…</p><p id="3ba7" class="od oe it bd of og oh oi oj ok ol lt dk translated">存储槽中的第一项按低位对齐存储。"</p></blockquote><p id="6ca3" class="pw-post-body-paragraph kx ky it la b lb om ju ld le on jx lg lv oo lj lk lw op ln lo lx oq lr ls lt im bi translated">因此，当变量少于32字节时，Solidity会尝试将多个变量打包到一个存储槽中，如果它们能够容纳的话。因此，一个存储槽可以保存多个状态变量。</p><p id="93ee" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">如果基本类型不适合存储槽中的剩余可用空间，它将被移动到下一个存储槽。对于以下担保合同:</p><pre class="kj kk kl km gt ph mb pi pj aw pk bi"><span id="d53d" class="or md it mb b gy pl pm l pn po">pragma solidity ^0.8.0;</span><span id="a17e" class="or md it mb b gy pp pm l pn po">contract StorageContract {<br/><br/>    uint256 a = 10;<br/>    uint64 b = 20;<br/>    uint128 c = 30;<br/>    uint128 d = 40;<br/><br/>}</span></pre><p id="cab6" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">其存储布局如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/1e03f3e57b2f38141fed7ff30dc220e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gkgR4uA9GlPhI7IVARMoXg.png"/></div></div><p class="pd pe gj gh gi pf pg bd b be z dk translated">1读取存储插槽0中的值</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/5858f228dc8b516d18775f851db4ca5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7zJTVrQzr3odEfg1XpWlug.png"/></div></div><p class="pd pe gj gh gi pf pg bd b be z dk translated">读取存储插槽1中的值</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/c48dbe66c83f99afeca23601a67b1bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XsIrGeWo_RP97CPQ_0Nfxg.png"/></div></div><p class="pd pe gj gh gi pf pg bd b be z dk translated">读取存储插槽2中的值</p></figure><p id="25d6" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">让我们看一个更具体的例子一个流行的Defi协议:Aave。</p><p id="4d80" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated"><strong class="la iu">举例:Aave </strong> <code class="fe ly lz ma mb b"><strong class="la iu">Pool.sol</strong></code> <strong class="la iu">合约</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/3d77870d89ed88e43660ae731216ade7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_yUOPqFWPyRCbI5k"/></div></div><p class="pd pe gj gh gi pf pg bd b be z dk translated"><a class="ae lu" href="https://invezz.com/news/2021/01/23/aave-aave-is-the-latest-defi-protocol-to-implement-layer-2/" rel="noopener ugc nofollow" target="_blank">图片来源:文章“invezz.com Aave(AAVE)是实现第二层的最新DeFi协议”</a></p></figure><p id="986a" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">Aave协议使用<a class="ae lu" href="https://docs.aave.com/developers/core-contracts/pool" rel="noopener ugc nofollow" target="_blank">池</a>作为管理流动性的主要智能合约。这些是主要的“面向用户的合同”。用户直接与Aave pools合约交互，以提供或借入流动性(从Solidity中的其他合约，或使用web3/ethers库)。</p><p id="3cc7" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">在<code class="fe ly lz ma mb b">Pool.sol</code>中定义的主Aave <code class="fe ly lz ma mb b">Pool</code>契约继承了一个与本文主题相关的有趣名称:<code class="fe ly lz ma mb b">PoolStorage</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/377c9f575c00f651ca219db67b73fd9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLkfZrT_7fR_M7miNqeDFQ.png"/></div></div><p class="pd pe gj gh gi pf pg bd b be z dk translated"><a class="ae lu" href="https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/pool/Pool.sol" rel="noopener ugc nofollow" target="_blank">来源:Aave v3协议，Pool.sol </a></p></figure><p id="13ad" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">如协议Aave v3的Natspec注释中所述，<code class="fe ly lz ma mb b">PoolStorage</code>契约服务于一个目的:<em class="kz">它</em> <em class="kz">定义了池契约的存储布局。</em></p><p id="6d29" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">如果我们查看<code class="fe ly lz ma mb b">PoolStorage</code>契约的可靠性代码，我们可以看到一些状态变量由于它们的类型而被打包到同一个存储槽中:</p><ul class=""><li id="5374" class="mu mv it la b lb lc le lf lv nz lw oa lx ob lt nb nc nd ne bi translated"><strong class="la iu">下面绿色:</strong>闪贷相关的状态变量(<code class="fe ly lz ma mb b">_flashLoanPremiumTotal</code>和<code class="fe ly lz ma mb b">_flashLoanPremiumToProtocol</code>)都是<code class="fe ly lz ma mb b">uint128</code>。将它们打包在一起会占用整个存储插槽(插槽nb 6)。</li><li id="f046" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated"><strong class="la iu">下面蓝色部分:</strong>最后两个状态变量<code class="fe ly lz ma mb b">_maxStableRateBorrowSizePercent</code>和<code class="fe ly lz ma mb b">_flashLoanPremiumToProtocol</code>属于<code class="fe ly lz ma mb b">uint64</code>和<code class="fe ly lz ma mb b">uint16</code>类型。它们也被打包在存储槽(槽nb 7)中，并且在存储槽中一起占据10个字节。这为潜在的其他状态变量留下了一些空间(剩余22个字节)。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pw"><img src="../Images/371e3a4462780fa4d154b2c4b60c932e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gMu2qH8BXS1eh8Iyl6dbIw.png"/></div></div><p class="pd pe gj gh gi pf pg bd b be z dk translated"><a class="ae lu" href="https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/pool/PoolStorage.sol" rel="noopener ugc nofollow" target="_blank">来源:Aave v3，PoolStorage.sol </a></p></figure><h2 id="3f71" class="or md it bd me os ot dn mi ou ov dp mm lv ow ox mo lw oy oz mq lx pa pb ms pc bi translated">具有继承性的存储布局</h2><p id="1ef0" class="pw-post-body-paragraph kx ky it la b lb mw ju ld le mx jx lg lv nw lj lk lw nx ln lo lx ny lr ls lt im bi translated">契约存储的布局也是基于继承的。如果一个协定继承自其他协定，则其存储布局遵循继承顺序。</p><ul class=""><li id="ba97" class="mu mv it la b lb lc le lf lv nz lw oa lx ob lt nb nc nd ne bi translated">在most基础契约中定义的状态变量从槽0开始。</li><li id="034e" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">在下面的派生契约中定义的状态变量被放置在子顺序槽(槽1、2、3等)中。</li></ul><p id="ef00" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">另外，请注意，将状态变量打包到一个存储槽中的规则同样适用。如果可能的话，通过继承，来自不同父契约和子契约的状态变量共享同一个存储槽。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="0edb" class="mc md it bd me mf nr mh mi mj ns ml mm jz nt ka mo kc nu kd mq kf nv kg ms mt bi translated">与存储的交互</h1><p id="b84e" class="pw-post-body-paragraph kx ky it la b lb mw ju ld le mx jx lg lv nw lj lk lw nx ln lo lx ny lr ls lt im bi translated">EVM提供了两个操作码来与存储交互:<code class="fe ly lz ma mb b">SLOAD</code>读取，和<code class="fe ly lz ma mb b">SSTORE</code>写入存储。这两个操作码只在内嵌汇编中可用。Solidity在编译后将写状态变量转换成这些操作码。</p><h2 id="0e27" class="or md it bd me os ot dn mi ou ov dp mm lv ow ox mo lw oy oz mq lx pa pb ms pc bi translated">从存储器中读取</h2><p id="d3d2" class="pw-post-body-paragraph kx ky it la b lb mw ju ld le mx jx lg lv nw lj lk lw nx ln lo lx ny lr ls lt im bi translated">EVM可以使用<code class="fe ly lz ma mb b">SLOAD</code>操作码读取智能合约的存储。<code class="fe ly lz ma mb b">SLOAD</code>将一个字从存储器载入堆栈。</p><p id="6efc" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated"><code class="fe ly lz ma mb b">SLOAD</code>操作码在内嵌汇编中可用。它可用于轻松检索存储在特定存储槽中的整个字值。</p><pre class="kj kk kl km gt ph mb pi pj aw pk bi"><span id="a5f6" class="or md it mb b gy pl pm l pn po">function readStorageNb(uint256 slotNb) <br/>    public <br/>    view <br/>    returns (bytes32 result) <br/>{<br/>    assembly {<br/>        result := sload(slotNb)<br/>    }</span><span id="cf16" class="or md it mb b gy pp pm l pn po">}</span></pre><p id="e82f" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">这就是坚固在引擎盖下的作用。当通过getter函数读取状态变量时，它会自动使用<code class="fe ly lz ma mb b">SLOAD</code>操作码。例如ERC20中流行的<code class="fe ly lz ma mb b">name()</code>或<code class="fe ly lz ma mb b">symbol()</code>功能。这些函数除了返回状态变量之外什么也不做。请看下面来自OpenZeppelin的截图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/ef7e90796bcb656e867d084dbfc94715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPdhX_wRplZzW1EhmSHVAg.png"/></div></div><p class="pd pe gj gh gi pf pg bd b be z dk translated"><a class="ae lu" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol" rel="noopener ugc nofollow" target="_blank">来源:OpenZeppelin Github知识库，ERC20.sol </a></p></figure><p id="3471" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">如果您在Remix中查询<code class="fe ly lz ma mb b">name()</code>函数并调试getter，您将获得下面的操作码。</p><pre class="kj kk kl km gt ph mb pi pj aw pk bi"><span id="af5b" class="or md it mb b gy pl pm l pn po">; name()<br/>JUMPDEST<br/>PUSH1 60<br/>PUSH1 03     ; step 1 - push the number 3 on the stack (= slot nb 3)<br/>DUP1<strong class="mb iu"><br/>SLOAD        ; step 2 - pass the number 3 as argument to SLOAD to<br/>             ; load the value stored in the storage slot nb 3 <br/>             ; (where the `_name` variable is stored)</strong></span><span id="ec2a" class="or md it mb b gy pp pm l pn po">; rest of the opcodes are emitted for brevity</span></pre><h2 id="aa85" class="or md it bd me os ot dn mi ou ov dp mm lv ow ox mo lw oy oz mq lx pa pb ms pc bi translated">写入存储</h2><p id="8e19" class="pw-post-body-paragraph kx ky it la b lb mw ju ld le mx jx lg lv nw lj lk lw nx ln lo lx ny lr ls lt im bi translated">EVM可以使用<code class="fe ly lz ma mb b">SSTORE</code>操作码写入智能合约的存储。<code class="fe ly lz ma mb b">SSTORE</code>保存一个字到存储器。</p><p id="1e84" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">使用内联汇编，看起来像这样:</p><pre class="kj kk kl km gt ph mb pi pj aw pk bi"><span id="2b4b" class="or md it mb b gy pl pm l pn po">function writeToStorageSlot(uint256 slotNb) public {</span><span id="f626" class="or md it mb b gy pp pm l pn po">    string memory value = "All About Solidity";    </span><span id="f397" class="or md it mb b gy pp pm l pn po">    assembly {<br/>        sstore(slotNb, value)<br/>    }</span><span id="92cb" class="or md it mb b gy pp pm l pn po">}</span></pre><p id="4cf2" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">让我们继续前面来自OpenZeppelin的ERC20令牌的例子。如果我们部署ERC20令牌契约并使用Remix调试<code class="fe ly lz ma mb b">constructor</code>，我们将获得以下操作码。</p><pre class="kj kk kl km gt ph mb pi pj aw pk bi"><span id="44b8" class="or md it mb b gy pl pm l pn po">MLOAD  ; 1. load the token name from memory<br/>PUSH1 ff<br/>NOT<br/>AND<br/>DUP4<br/>DUP1<br/>ADD<br/>OR<br/>DUP6   ; 2. put back 3 (= slot nb for `name`) on top of the stack <br/>SSTORE ; 3. store at storage slot 3 the token `name` parameter<br/>PUSH3 0003ee<br/>JUMP   </span></pre><blockquote class="ku kv kw"><p id="75a0" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://remix.ethereum.org/?#code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVApwcmFnbWEgc29saWRpdHkgXjAuOC40OwoKaW1wb3J0ICJAb3BlbnplcHBlbGluL2NvbnRyYWN0c0A0LjcuMC90b2tlbi9FUkMyMC9FUkMyMC5zb2wiOwppbXBvcnQgIkBvcGVuemVwcGVsaW4vY29udHJhY3RzQDQuNy4wL2FjY2Vzcy9Pd25hYmxlLnNvbCI7Cgpjb250cmFjdCBNeVRva2VuIGlzIEVSQzIwLCBPd25hYmxlIHsKICAgIGNvbnN0cnVjdG9yKCkgRVJDMjAoIk15VG9rZW4iLCAiTVRLIikgewogICAgICAgIF9taW50KG1zZy5zZW5kZXIsIDEwMDAwICogMTAgKiogZGVjaW1hbHMoKSk7CiAgICB9CgogICAgZnVuY3Rpb24gbWludChhZGRyZXNzIHRvLCB1aW50MjU2IGFtb3VudCkgcHVibGljIG9ubHlPd25lciB7CiAgICAgICAgX21pbnQodG8sIGFtb3VudCk7CiAgICB9Cn0K&amp;optimize=false&amp;runs=200&amp;evmVersion=null&amp;version=soljson-v0.8.7+commit.e28d00a7.js" rel="noopener ugc nofollow" target="_blank">在Remix上试用</a>并在部署ERC20令牌后调试事务。</p></blockquote><p id="5605" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">这条推文很好地描述了操作码<code class="fe ly lz ma mb b">SSTORE</code>如何在geth客户端中工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="px py l"/></div></figure><p id="f3df" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">我们可以从geth客户端的源代码中看到，<code class="fe ly lz ma mb b">SSTORE</code>从堆栈中弹出两个值，第一个最上面的<code class="fe ly lz ma mb b">loc</code>是存储位置，第二个最上面的<code class="fe ly lz ma mb b">val</code>是存储在存储中的值。</p><p id="f00d" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">我们还可以看到，这两个值在通过<code class="fe ly lz ma mb b">interpreter.evm.StateDB.SetState(...)</code>写入合同存储器时，将从堆栈中取出的两个项目都转换为<code class="fe ly lz ma mb b">bytes32</code>值。</p><p id="a86e" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">因此，我们可以从geth客户端的源代码中直接看到我们在<strong class="la iu">存储布局</strong>一节中解释的内容:智能合约存储将bytes32键映射到bytes32值，因此EVM将所有内容都视为bytes32字。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="px py l"/></div></figure><p id="c0d0" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">这里还有来自同一位tweet作者的最终图表，详细解释了<code class="fe ly lz ma mb b">SSTORE</code>操作码的流程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/f50425162d908db29ceae3763e52cddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/0*Uq3u5Zpy0LEbz4pL"/></div><p class="pd pe gj gh gi pf pg bd b be z dk translated">来源:<a class="ae lu" href="https://twitter.com/721Orbit/status/1511961744238948356?s=20&amp;t=KDGCQ4OwQ47e2NACgQ8WWg" rel="noopener ugc nofollow" target="_blank">发自推特的法希尔。</a></p></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="02ef" class="mc md it bd me mf nr mh mi mj ns ml mm jz nt ka mo kc nu kd mq kf nv kg ms mt bi translated">函数参数中的存储指针</h1><p id="5da1" class="pw-post-body-paragraph kx ky it la b lb mw ju ld le mx jx lg lv nw lj lk lw nx ln lo lx ny lr ls lt im bi translated"><code class="fe ly lz ma mb b">storage</code>关键字可以作为参数传递给函数的复杂变量。但是这是如何工作的呢？</p><p id="5e77" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">当在函数参数中指定了<code class="fe ly lz ma mb b">storage</code>时，这意味着传递给函数的参数必须是状态变量。</p><p id="5124" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">让我们用一个非常简单的例子，继续讨论OpenZeppelin库。这也将帮助我们更好地理解他们包中的契约和库部分。</p><p id="c5c4" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">OpenZeppelin提供了一个<code class="fe ly lz ma mb b"><a class="ae lu" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Timers.sol" rel="noopener ugc nofollow" target="_blank">Timers</a></code>库，可以用来构建和处理Solidity契约中的计时器和时间点。查看下面的功能<code class="fe ly lz ma mb b">setDeadline(...)</code>和<code class="fe ly lz ma mb b">reset(...)</code>及其参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/d993930092e2135c528f4365098c44d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SUb5no_GqGHm6lfo6QX-og.png"/></div></div><p class="pd pe gj gh gi pf pg bd b be z dk translated"><a class="ae lu" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Timers.sol" rel="noopener ugc nofollow" target="_blank">来源:来自OpenZeppelin Github库的Timers.sol。</a></p></figure><p id="ae72" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">这两个函数只接受存储指针。那是什么意思？</p><p id="a83e" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">让我们创建一个时间表合同来理解！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="qb py l"/></div></figure><p id="73c1" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">如果你试图在Remix上编译这个契约，Solidity编译器会报错如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/1bd9ac868bf4b3fa8752a9978eff44fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mqMXtKZXYjLwEQ7eY6_1IQ.png"/></div></div><p class="pd pe gj gh gi pf pg bd b be z dk translated">调试存储指针错误101</p></figure><p id="9b9c" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">这个错误是有道理的。<code class="fe ly lz ma mb b">Timers</code>库中的<code class="fe ly lz ma mb b">setDeadline(...)</code>函数只接受存储指针。这意味着该函数将接受以下参数:</p><ul class=""><li id="bcee" class="mu mv it la b lb lc le lf lv nz lw oa lx ob lt nb nc nd ne bi translated">直接任一状态变量</li><li id="58f0" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">或者对状态变量的引用(另一个<code class="fe ly lz ma mb b">storage</code>引用，或者我喜欢称之为存储指针)。</li></ul><p id="82b9" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">然后让我们重写我们的时间表，让它工作。我们还可以添加一个重置按钮来使它工作</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="qb py l"/></div></figure><p id="df07" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">我们已经看到了一个函数参数存储指针的基本例子。让我们更深入地看一个更复杂的例子，以便更好地理解函数参数中的存储指针。</p><p id="0aaf" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">当一个函数的参数是一个<code class="fe ly lz ma mb b">storage</code>引用时，该函数可以直接接受一个状态变量或者一个对状态变量的引用。</p><p id="1753" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">让我们继续以<code class="fe ly lz ma mb b">TimeWatch</code>为例。我们可以使用<code class="fe ly lz ma mb b">Timers</code>库来建立一个比赛合同。使用合同会降低对比赛组织者或任何第三方的信任度，因为他们可能不信任欺骗计时器和规则的人。</p><p id="c1b9" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">下面是一个原型。该合同通过地图跟踪参与的参赛者及其时间。注意下面的<code class="fe ly lz ma mb b">startRacerTime(…)</code>功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="qb py l"/></div></figure><p id="ceb5" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">这可以很好地编译，因为<code class="fe ly lz ma mb b">racerTimer</code>指向了<code class="fe ly lz ma mb b">racers</code>(约定存储)的映射中的某个条目。因此，由于这个变量是对契约存储的引用，来自<code class="fe ly lz ma mb b">Timers</code>库的<code class="fe ly lz ma mb b">setDeadline(...)</code>函数将把它作为有效的函数参数接受。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="ecf3" class="mc md it bd me mf nr mh mi mj ns ml mm jz nt ka mo kc nu kd mq kf nv kg ms mt bi translated">函数体中的存储指针</h1><p id="58c5" class="pw-post-body-paragraph kx ky it la b lb mw ju ld le mx jx lg lv nw lj lk lw nx ln lo lx ny lr ls lt im bi translated">当变量是基本类型时，将存储变量赋给局部变量(在函数体中定义)总是会复制。</p><p id="8324" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">然而，对于复杂或动态类型，规则是不同的。你可以把关键字<code class="fe ly lz ma mb b">storage</code>传递给一个值，你不想被克隆。</p><p id="656a" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">我们将这些变量描述为存储指针或存储引用类型的局部变量。</p><p id="23e1" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">函数中的任何存储引用变量总是引用在协定的存储上预先分配的一段数据。换句话说，存储引用总是引用状态变量。</p><p id="81f9" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">让我们使用一个非常流行的智能契约治理协议的可靠性代码，它被用作许多其他治理协议的基础:<strong class="la iu"> Compound。</strong></p><h2 id="d4af" class="or md it bd me os ot dn mi ou ov dp mm lv ow ox mo lw oy oz mq lx pa pb ms pc bi translated">真实世界示例—复合</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qd"><img src="../Images/5b76f0aec961b4676fe0048b1a231506.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q6vpbn--ULKfenw7"/></div></div></figure><p id="2d1c" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated"><code class="fe ly lz ma mb b"><a class="ae lu" href="https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol" rel="noopener ugc nofollow" target="_blank">GovernorAlpha</a></code>智能合同对构建治理协议产生了影响。该合同不仅用作复合公司治理的准系统，还用作<a class="ae lu" href="https://github.com/Uniswap/governance/blob/master/contracts/GovernorAlpha.sol" rel="noopener ugc nofollow" target="_blank"> Uniswap </a>或<a class="ae lu" href="https://github.com/indexed-finance/governance/blob/master/contracts/governance/GovernorAlpha.sol" rel="noopener ugc nofollow" target="_blank">指数化金融</a>的治理准系统。</p><p id="17a8" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">我们来看一下<code class="fe ly lz ma mb b">GovernorAlpha</code>的核心功能之一。顾名思义，<code class="fe ly lz ma mb b"><a class="ae lu" href="https://compound.finance/docs/governance#propose" rel="noopener ugc nofollow" target="_blank">propose(...)</a></code>功能可以创建新的建议(例如:改变<code class="fe ly lz ma mb b">cToken</code>的利率)。如果你看下面，你会看到我们之前解释的两个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qe"><img src="../Images/0d2888881487e02703ec96d8b73bc9c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZQEFZ4wxY7bFLK64dbngDw.png"/></div></div></figure><p id="7391" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">在<strong class="la iu">行153 </strong>中，局部变量<code class="fe ly lz ma mb b">proposalId</code>被赋予状态变量<code class="fe ly lz ma mb b">proposalCount</code>的值。因为这个局部变量是基本类型(a <code class="fe ly lz ma mb b">uint</code>)，所以该值被从契约存储器(从状态变量<code class="fe ly lz ma mb b">proposalCount</code>)复制/克隆到局部变量(在堆栈上)。对局部变量的任何更改都不会传播到协定存储。</p><p id="1b9f" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">在Compound中，这一行用于在本地保存新的提议id(通过递增<code class="fe ly lz ma mb b">proposalCount</code>行152生成)。这也节省了一些汽油。看看第154行和第157行。如果变量是<code class="fe ly lz ma mb b">proposalCount</code>(实际状态变量)而不是<code class="fe ly lz ma mb b">proposalId</code>，这将读取合同存储两次。</p><p id="6561" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated"><strong class="la iu">第154行:</strong>使用新的<code class="fe ly lz ma mb b">proposalId</code>，创建一个<code class="fe ly lz ma mb b">newProposal</code>。由于<code class="fe ly lz ma mb b">newProposal</code>变量是一个<code class="fe ly lz ma mb b">struct</code>(复杂类型)，我们必须指定我们希望EVM操作的数据位置，当我们以后操作和编辑这个变量时。</p><p id="3f55" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">这个例子使用了一个<code class="fe ly lz ma mb b">storage</code>参考。</p><ul class=""><li id="730f" class="mu mv it la b lb lc le lf lv nz lw oa lx ob lt nb nc nd ne bi translated">那是什么意思？<code class="fe ly lz ma mb b">newProposal</code>指合同中的某处存储。</li><li id="eb1e" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">它指的是合同仓库中的哪个位置？它引用了<code class="fe ly lz ma mb b">proposals</code>映射中的一个<code class="fe ly lz ma mb b">Proposal</code>。</li><li id="4011" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">哪个<code class="fe ly lz ma mb b">Proposal</code>？该建议由映射中的<code class="fe ly lz ma mb b">proposalId</code>引用。</li></ul><p id="e8a4" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">这个<code class="fe ly lz ma mb b">storage</code>关键词又意味着什么呢？这将意味着对<code class="fe ly lz ma mb b">newProposal</code>变量所做的每一个改变都将导致数据写入合同存储器。从第157行开始，您可以看到新提议的所有细节都是通过<code class="fe ly lz ma mb b">Proposal</code>结构成员一个接一个地编写的。这些行中的每一行都写入约定存储。</p><p id="0ea7" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">一旦执行了该功能，新的建议将被保存在合同存储中，并且更改将持续。</p><h2 id="bec1" class="or md it bd me os ot dn mi ou ov dp mm lv ow ox mo lw oy oz mq lx pa pb ms pc bi translated">存储引用的幕后发生了什么？</h2><p id="0aff" class="pw-post-body-paragraph kx ky it la b lb mw ju ld le mx jx lg lv nw lj lk lw nx ln lo lx ny lr ls lt im bi translated">看看下面的例子。基于同样的治理主题。它详细说明了使用存储器引用从存储器<em class="kz">与</em>复制时使用的EVM操作码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="qb py l"/></div></figure><p id="d8fb" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">第一个函数<code class="fe ly lz ma mb b">getVotesCount()</code>从堆栈中复制值，然后返回它。我们可以看到，值是通过<code class="fe ly lz ma mb b">SLOAD</code>从存储器加载到堆栈的。对变量<code class="fe ly lz ma mb b">currentVotesCount</code>的任何更改都不会传播回存储器。</p><p id="0424" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">相反的第二个例子包含一个<code class="fe ly lz ma mb b">storage</code>引用。只要我们给<code class="fe ly lz ma mb b">Vote</code>结构中的成员<code class="fe ly lz ma mb b">hasVoted</code>赋值，存储就会更新，我们就可以看穿操作码<code class="fe ly lz ma mb b">SSTORE</code>。</p><p id="4c23" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">该示例显示了为<code class="fe ly lz ma mb b">storage</code>引用变量分配新值会更新合同存储。EVM将此理解为执行<code class="fe ly lz ma mb b">SSTORE</code>指令的“触发器”。</p><p id="9649" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">相反，如前面的示例所示，从存储变量中为其赋值的elementary变量不会创建引用，而只是将值从存储中复制到堆栈中。EVM把这理解为一个简单地执行<code class="fe ly lz ma mb b">SLOAD</code>指令的触发器。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="5608" class="mc md it bd me mf nr mh mi mj ns ml mm jz nt ka mo kc nu kd mq kf nv kg ms mt bi translated">从程序集和Yul访问存储</h1><p id="d6b1" class="pw-post-body-paragraph kx ky it la b lb mw ju ld le mx jx lg lv nw lj lk lw nx ln lo lx ny lr ls lt im bi translated">通过指定存储槽和存储偏移量，可以对内联程序集中的协定存储进行读写。</p><p id="c9f0" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">我们之前看到，存储中的一些变量不一定占用一个完整的存储槽，但有时会打包在一起。</p><p id="441b" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">我们还看到作为操作码的<code class="fe ly lz ma mb b">SLOAD</code>只接受存储槽号作为参数，并返回存储在该槽下的完整的<code class="fe ly lz ma mb b">bytes32</code>值。</p><p id="89e0" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">但是如何在同一个存储槽中读取一个和其他状态变量打包在一起的状态变量呢？</p><p id="3d12" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">以下面的合同为例:</p><pre class="kj kk kl km gt ph mb pi pj aw pk bi"><span id="9351" class="or md it mb b gy pl pm l pn po">contract Storage {</span><span id="a35d" class="or md it mb b gy pp pm l pn po">    uint64 a;<br/>    uint64 b;<br/>    uint128 c;</span><span id="37db" class="or md it mb b gy pp pm l pn po">}</span></pre><p id="57c3" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">坚固性文件解释了以下内容:</p><blockquote class="oc"><p id="1740" class="od oe it bd of og oh oi oj ok ol lt dk translated">对于本地<strong class="ak">存储</strong>变量或状态变量，单个Yul标识符是不够的，因为它们不一定占据单个完整的<strong class="ak">存储</strong>槽。</p><p id="2be6" class="od oe it bd of og oh oi oj ok ol lt dk translated">因此，它们的“地址”由一个槽和该槽内的字节偏移量组成。</p></blockquote><p id="5203" class="pw-post-body-paragraph kx ky it la b lb om ju ld le on jx lg lv oo lj lk lw op ln lo lx oq lr ls lt im bi translated">因此，变量的“地址”由两部分组成:</p><ul class=""><li id="9cd7" class="mu mv it la b lb lc le lf lv nz lw oa lx ob lt nb nc nd ne bi translated">插槽号:变量所在的位置。</li><li id="76cd" class="mu mv it la b lb nf le ng lv nh lw ni lx nj lt nb nc nd ne bi translated">变量开始的字节偏移量(在该槽内)。</li></ul><p id="0d79" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">让我们继续看一些基本的汇编代码，以便更好地理解。看看下面的合同及其功能:</p><pre class="kj kk kl km gt ph mb pi pj aw pk bi"><span id="2e04" class="or md it mb b gy pl pm l pn po">contract Storage {</span><span id="0e86" class="or md it mb b gy pp pm l pn po">    uint64 a = 1;<br/>    uint64 b = 2;<br/>    uint128 c = 3;</span><span id="6a46" class="or md it mb b gy pp pm l pn po">    function getSlotNumbers() public view returns(uint256 slotA, uint256 slotB, uint256 slotC) {</span><span id="6539" class="or md it mb b gy pp pm l pn po">        assembly {</span><span id="c856" class="or md it mb b gy pp pm l pn po">            slotA := a.slot<br/>            slotB := b.slot<br/>            slotC := c.slot<br/>    <br/>        }</span><span id="c7ba" class="or md it mb b gy pp pm l pn po">    }</span><span id="5da7" class="or md it mb b gy pp pm l pn po">    function getVariableOffsets() public view returns(uint256 offsetA, uint256 offsetB, uint256 offsetC) {</span><span id="e9c2" class="or md it mb b gy pp pm l pn po">        assembly {</span><span id="4a70" class="or md it mb b gy pp pm l pn po">            offsetA := a.offset<br/>            offsetB := b.offset<br/>            offsetC := c.offset<br/>    <br/>        }</span><span id="4f3d" class="or md it mb b gy pp pm l pn po">    }</span><span id="33b9" class="or md it mb b gy pp pm l pn po">}</span></pre><p id="7746" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">通过Remix运行这两个函数会产生以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/1140dd4934a9d4725bbda9541c66390d.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*Dd7ttwSlwPcRidAqUxcKpA.png"/></div></figure><p id="781c" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">使用内嵌装配和Yul，</p><p id="233e" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">要检索变量<code class="fe ly lz ma mb b">c</code>指向的槽，可以使用<code class="fe ly lz ma mb b">c.slot</code>，要检索字节偏移量，可以使用<code class="fe ly lz ma mb b">c.offset</code>。使用<code class="fe ly lz ma mb b">c</code>本身会导致错误。</p><pre class="kj kk kl km gt ph mb pi pj aw pk bi"><span id="4e6c" class="or md it mb b gy pl pm l pn po">function ReadVariableC() public view returns (uint64 value) {</span><span id="9a7a" class="or md it mb b gy pp pm l pn po">    assembly {<br/>        value := sload(c)<br/>    }</span><span id="7484" class="or md it mb b gy pp pm l pn po">}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qg"><img src="../Images/81ebeb01d41d1fabca5fd4d401912158.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G2b5QfqRhT2Wd97uhjgtaQ.png"/></div></div><p class="pd pe gj gh gi pf pg bd b be z dk translated">上面的代码将无法编译，并会抛出以下错误</p></figure><p id="ff49" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">还有一点要提的是，在内联汇编中，你不能给存储变量的<code class="fe ly lz ma mb b">.slot</code>或<code class="fe ly lz ma mb b">.offset</code>部分赋值。</p><pre class="kj kk kl km gt ph mb pi pj aw pk bi"><span id="74d3" class="or md it mb b gy pl pm l pn po">function doesNotCompile() public {</span><span id="d479" class="or md it mb b gy pp pm l pn po">    assembly {<br/>        a.slot := 8<br/>        a.offset := 9<br/>    }</span><span id="53a8" class="or md it mb b gy pp pm l pn po">}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qh"><img src="../Images/5b041e92658578762c6ecc90eca3eee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CyQQR5wRO0OuxbZRqKIvkA.png"/></div></div><p class="pd pe gj gh gi pf pg bd b be z dk translated">solc编译器报告的错误(截图来自Remix)</p></figure><p id="ea73" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated"><strong class="la iu">Yul中存储指针的偏移量是多少？</strong></p><p id="980e" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">在函数体中，一些变量可以是存储指针/存储引用。例如，这包括<code class="fe ly lz ma mb b">struct</code>、<code class="fe ly lz ma mb b">array</code>和<code class="fe ly lz ma mb b">mapping</code>。对于这样的变量，<code class="fe ly lz ma mb b">.offset</code>在Yul中总是为零，因为这样的变量总是占据一个完整的存储槽，并且不能与其他变量一起紧密地打包在存储器中。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="d4a0" class="mc md it bd me mf nr mh mi mj ns ml mm jz nt ka mo kc nu kd mq kf nv kg ms mt bi translated">结论</h1><p id="cc1d" class="pw-post-body-paragraph kx ky it la b lb mw ju ld le mx jx lg lv nw lj lk lw nx ln lo lx ny lr ls lt im bi translated">无论是初始化还是修改智能合约中的数据，写入智能合约的存储成本都很高。尽管从协定存储中读取数据是免费的，但如果这些读取操作是更改状态的事务的一部分，您仍应考虑与读取智能协定的存储相关联的gas成本。</p><p id="7ddb" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">由于储存操作的高气体成本，固体文件规定了一个重要的考虑因素:</p><blockquote class="oc"><p id="d5c2" class="od oe it bd of og oh oi oj ok ol lt dk translated"><a class="ae lu" href="https://docs.soliditylang.org/en/v0.8.13/introduction-to-smart-contracts.html#storage-memory-and-the-stack" rel="noopener ugc nofollow" target="_blank">您应该将存储在持久存储中的内容最小化到契约运行所需的内容。</a></p></blockquote><p id="576c" class="pw-post-body-paragraph kx ky it la b lb om ju ld le on jx lg lv oo lj lk lw op ln lo lx oq lr ls lt im bi translated">建议尽可能将某些数据存储在合同存储区之外，以最大限度地降低相关的天然气成本。</p><h1 id="1d78" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><div class="qi qj gp gr qk ql"><a href="https://blog.openzeppelin.com/ethereum-in-depth-part-2-6339cf6bddb9/" rel="noopener  ugc nofollow" target="_blank"><div class="qm ab fo"><div class="qn ab qo cl cj qp"><h2 class="bd iu gy z fp qq fr fs qr fu fw is bi translated">以太坊深度，第2部分- OpenZeppelin博客</h2><div class="qs l"><h3 class="bd b gy z fp qq fr fs qr fu fw dk translated">感谢你对这篇文章感兴趣！我们正在进行品牌重塑，所以如果有些名字…</h3></div><div class="qt l"><p class="bd b dl z fp qq fr fs qr fu fw dk translated">blog.openzeppelin.com</p></div></div><div class="qu l"><div class="qv l qw qx qy qu qz ks ql"/></div></div></a></div><div class="qi qj gp gr qk ql"><a href="https://docs.soliditylang.org/en/v0.8.15/internals/layout_in_storage.html" rel="noopener  ugc nofollow" target="_blank"><div class="qm ab fo"><div class="qn ab qo cl cj qp"><h2 class="bd iu gy z fp qq fr fs qr fu fw is bi translated">存储可靠性0.8.15文档中状态变量的布局</h2><div class="qs l"><h3 class="bd b gy z fp qq fr fs qr fu fw dk translated">契约的状态变量以紧凑的方式存储在存储器中，因此多个值有时使用相同的…</h3></div><div class="qt l"><p class="bd b dl z fp qq fr fs qr fu fw dk translated">docs.soliditylang.org</p></div></div></div></a></div><div class="qi qj gp gr qk ql"><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/StorageSlot.sol" rel="noopener  ugc nofollow" target="_blank"><div class="qm ab fo"><div class="qn ab qo cl cj qp"><h2 class="bd iu gy z fp qq fr fs qr fu fw is bi translated">open zeppelin-contracts/storage slot . sol at master open zeppelin/open zeppelin-contracts</h2><div class="qs l"><h3 class="bd b gy z fp qq fr fs qr fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="qt l"><p class="bd b dl z fp qq fr fs qr fu fw dk translated">github.com</p></div></div><div class="qu l"><div class="ra l qw qx qy qu qz ks ql"/></div></div></a></div><div class="qi qj gp gr qk ql"><a href="https://ethdebug.github.io/solidity-data-representation/#user-content-locations-in-detail-storage-in-detail" rel="noopener  ugc nofollow" target="_blank"><div class="qm ab fo"><div class="qn ab qo cl cj qp"><h2 class="bd iu gy z fp qq fr fs qr fu fw is bi translated">固体中的数据表示</h2><div class="qs l"><h3 class="bd b gy z fp qq fr fs qr fu fw dk translated">适用于代码调试器和其他调试相关实用程序的编写人员。作者哈里·奥特曼[@haltman-at]发表…</h3></div><div class="qt l"><p class="bd b dl z fp qq fr fs qr fu fw dk translated">ethdebug.github.io</p></div></div></div></a></div><div class="qi qj gp gr qk ql"><a href="https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/" rel="noopener  ugc nofollow" target="_blank"><div class="qm ab fo"><div class="qn ab qo cl cj qp"><h2 class="bd iu gy z fp qq fr fs qr fu fw is bi translated">了解以太坊智能合约存储</h2><div class="qs l"><h3 class="bd b gy z fp qq fr fs qr fu fw dk translated">以太坊智能合约使用一种不常见的存储模型，这种模型经常让新开发人员感到困惑。在这篇文章中，我将描述…</h3></div><div class="qt l"><p class="bd b dl z fp qq fr fs qr fu fw dk translated">programtheblockchain.com</p></div></div><div class="qu l"><div class="rb l qw qx qy qu qz ks ql"/></div></div></a></div><div class="qi qj gp gr qk ql"><a href="https://ethereum.org/en/developers/docs/smart-contracts/anatomy/" rel="noopener  ugc nofollow" target="_blank"><div class="qm ab fo"><div class="qn ab qo cl cj qp"><h2 class="bd iu gy z fp qq fr fs qr fu fw is bi translated">智能合约剖析| ethereum.org</h2><div class="qs l"><h3 class="bd b gy z fp qq fr fs qr fu fw dk translated">深入剖析智能联系人的结构——功能、数据和变量。</h3></div><div class="qt l"><p class="bd b dl z fp qq fr fs qr fu fw dk translated">ethereum.org</p></div></div><div class="qu l"><div class="rc l qw qx qy qu qz ks ql"/></div></div></a></div></div></div>    
</body>
</html>