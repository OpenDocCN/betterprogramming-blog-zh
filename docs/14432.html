<html>
<head>
<title>Getting Started With Swift — C++ Interoperability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift-c++互操作性入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-swift-c-interoperability-a361ed617184?source=collection_archive---------7-----------------------#2022-12-14">https://betterprogramming.pub/getting-started-with-swift-c-interoperability-a361ed617184?source=collection_archive---------7-----------------------#2022-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4ef7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">试验性的Swift-C++互操作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0bebde09fa615d1b74157f6c54c34304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8QhPYcISgdZPil573qLMzg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">巴勃罗·加西亚·萨尔达尼亚在<a class="ae kv" href="https://unsplash.com/s/photos/two-way?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="706e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Swift是一种非常舒适的语言。它有一些怪癖和一个学习曲线，但最终你可以用它非常快地发布生产就绪的代码。<br/>然而，有时您会遇到性能关键的部分，而Swift无法满足您的需求。在这种情况下，一个流行的选择是使用C++。</p><p id="055b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题就来了“我如何从Swift调用这个C++ <code class="fe ls lt lu lv b">func</code>”?</p><p id="3a36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，你必须写一个Objective-C包装器作为你的C++代码的公共接口。Swift toolchain可以将Objective-C声明导入Swift。主要的限制是不能在Objective-C中使用C++类，只能使用简单的POD结构。</p><p id="7efe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将用C++和Swift编写一个厄拉多塞算法的<a class="ae kv" href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" rel="noopener ugc nofollow" target="_blank">筛子。然后学习如何启用C++互操作，从Swift调用C++代码，比较实现性能。</a></p><p id="9d0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，该功能是实验性的，可能会有变化。本出版物在Xcode版本14.2上编译</p><h1 id="f3e7" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">算法</h1><p id="9df7" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">厄拉多塞的筛子能找出所有小于或等于n的质数。质数是只能被自身和1整除的整数。该算法创建一个布尔数组来指示每个数字是否是质数。并逐步迭代它们，将所有倍数标记为非素数。</p><p id="1000" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是Swift的实现。</p><pre class="kg kh ki kj gt mt lv mu bn mv mw bi"><span id="055e" class="mx lx iq lv b be my mz l na nb">// primes.swift<br/><br/>func primes(n: Int) -&gt; [Int] {<br/>    var isPrime = [Bool](repeating: true, count: n + 1)<br/><br/>    for value in stride(from: 2, to: n + 1, by: 1) where isPrime[value] {<br/>        if value * value &gt; n { break }<br/><br/>        for multiple in stride(from: value * 2, to: n + 1, by: value) {<br/>            isPrime[multiple] = false<br/>        }<br/>    }<br/><br/>    var result = [Int]()<br/><br/>    for value in stride(from: 2, to: n + 1, by: 1) where isPrime[value] {<br/>        result.append(value)<br/>    }<br/><br/>    return result<br/>}</span></pre><p id="4d8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于C++我们需要一个头文件和一个源文件。注意，我们<code class="fe ls lt lu lv b">typedef</code>有一个更清晰的名字来指代<code class="fe ls lt lu lv b">std::vector&lt;long&gt;</code>。</p><pre class="kg kh ki kj gt mt lv mu bn mv mw bi"><span id="5ef3" class="mx lx iq lv b be my mz l na nb">// primes.hpp<br/><br/>#include &lt;vector&gt;<br/>typedef std::vector&lt;long&gt; VectorLong;<br/>VectorLong primes(const long &amp;n);</span></pre><pre class="nc mt lv mu bn mv mw bi"><span id="e6a8" class="mx lx iq lv b be my mz l na nb">// primes.cpp<br/>#include &lt;algorithm&gt;<br/><br/>#include "primes.hpp"<br/>VectorLong primes(const long &amp;n) {<br/>    std::vector&lt;char&gt; isPrime(n + 1); // faster than std::vector&lt;bool&gt;<br/>    std::fill(isPrime.begin(), isPrime.end(), true);<br/><br/>    for (long value = 2; value * value &lt;= n; ++value) {<br/>        if (!isPrime[value]) { continue; }<br/>        for (long multiple = value * 2; multiple &lt;= n; multiple += value) {<br/>            isPrime[multiple] = false;<br/>        }<br/>    }<br/><br/>    VectorLong result;<br/><br/>    for (long value = 2; value &lt;= n; ++value) {<br/>        if (!isPrime[value]) { continue; }<br/>        result.push_back(value);<br/>    }<br/><br/>    return result;<br/>}</span></pre><h1 id="aef2" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">项目结构</h1><p id="a86b" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们将使用两个单独的目标来实现Swift包，以保存我们的Swift和C++代码。要从Swift导入C++代码，我们需要一个modulemap。</p><pre class="kg kh ki kj gt mt lv mu bn mv mw bi"><span id="6ea4" class="mx lx iq lv b be my mz l na nb">// module.modulemap<br/><br/>module CXX {<br/>    header "CXX.hpp"<br/>    requires cplusplus<br/>}<br/><br/>// CXX.hpp<br/><br/>#include "primes.hpp"</span></pre><p id="1f12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并且不要忘记将<code class="fe ls lt lu lv b">-enable-experimental-cxx-interop</code>传给<code class="fe ls lt lu lv b">Package.swift</code>中的迅捷目标。</p><pre class="kg kh ki kj gt mt lv mu bn mv mw bi"><span id="95c0" class="mx lx iq lv b be my mz l na nb">// swift-tools-version: 5.7<br/><br/>import PackageDescription<br/><br/>let package = Package(<br/>    name: "SwiftCXXInteropExample",<br/>    platforms: [<br/>        .macOS(.v12),<br/>    ],<br/>    products: [<br/>        .library(name: "CXX", targets: ["CXX"]),<br/>        .executable(name: "CLI", targets: ["CLI"])<br/>    ],<br/>    dependencies: [],<br/>    targets: [<br/>        .target(name: "CXX"),<br/>        .executableTarget(<br/>            name: "CLI",<br/>            dependencies: ["CXX"],<br/>            swiftSettings: [.unsafeFlags(["-enable-experimental-cxx-interop"])]<br/>        )<br/>    ]<br/>)</span></pre><p id="1742" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多关于如何启用C++互操作的信息请参见Apple的文档。</p><h1 id="b243" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">炼脂</h1><p id="6a12" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">使用我们Swift的<code class="fe ls lt lu lv b">VectorLong</code>与<code class="fe ls lt lu lv b">RandomAccessCollection</code>保持一致要容易得多，令人高兴的是，这真的很容易做到。</p><pre class="kg kh ki kj gt mt lv mu bn mv mw bi"><span id="f84d" class="mx lx iq lv b be my mz l na nb">import CXX<br/><br/>extension VectorLong: RandomAccessCollection {<br/>    public var startIndex: Int { 0 }<br/>    public var endIndex: Int { size() }<br/>}</span></pre><p id="2f55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以从Swift调用我们的C++函数，并将结果打印到控制台。</p><pre class="kg kh ki kj gt mt lv mu bn mv mw bi"><span id="4fc4" class="mx lx iq lv b be my mz l na nb">let cxxVector = primes(100)<br/>let swiftArray = [Int](cxxVector)<br/>print(swiftArray)</span></pre><p id="1fc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看我们的C++实现是否真的执行得更快。</p><pre class="kg kh ki kj gt mt lv mu bn mv mw bi"><span id="f3a1" class="mx lx iq lv b be my mz l na nb">let signposter = OSSignposter()<br/><br/>let count = 100<br/>let n = 10_000_000<br/><br/>for _ in 0..&lt;count {<br/>    let state = signposter.beginInterval("C++")<br/>    let _ = primes(n)<br/>    signposter.endInterval("C++", state)<br/>}<br/><br/>for _ in 0..&lt;count {<br/>    let state = signposter.beginInterval("Swift")<br/>    let _ = primes(n: n)<br/>    signposter.endInterval("Swift", state)<br/>}</span></pre><p id="079e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">稍快，平均持续时间为26毫秒，而Swift为28毫秒。</p><h1 id="fccf" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">最后的想法</h1><p id="2674" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们能够在Swift中直接使用<code class="fe ls lt lu lv b">std::vector</code>。我个人还没有找到雨燕<code class="fe ls lt lu lv b">Map</code>和<code class="fe ls lt lu lv b">std::map</code>、<code class="fe ls lt lu lv b">Set</code>和<code class="fe ls lt lu lv b">std::set</code>之间往返的便捷方式。尽管如此，C++ interop正在迅速发展，前途似乎一片光明。</p><p id="fef7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/apple/swift/tree/main/docs/CppInteroperability" rel="noopener ugc nofollow" target="_blank">CppInteroperability</a></code>Swift repo中的文件夹包含有关互操作功能、限制和计划的更多信息。</p><p id="c8be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看完整代码<a class="ae kv" href="https://github.com/ksemianov/SwiftCXXInteropExample" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="c15d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nk">原载于</em><a class="ae kv" href="https://ksemianov.github.io/articles/cpp-interop/" rel="noopener ugc nofollow" target="_blank"><em class="nk">https://ksemianov.github.io/articles/cpp-interop/</em></a></p></div></div>    
</body>
</html>