<html>
<head>
<title>Promise Methods You May Have Missed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你可能错过的承诺方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-promise-methods-you-may-have-missed-fcf16bedc7b6?source=collection_archive---------2-----------------------#2020-04-25">https://betterprogramming.pub/javascript-promise-methods-you-may-have-missed-fcf16bedc7b6?source=collection_archive---------2-----------------------#2020-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="51cb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">组合承诺和处理竞争条件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/72fc536b9f070c9c05e36e0ab61478b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jU8ZEX4gPZTUx6cl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@matthewhenry?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马太·亨利</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e2a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">承诺是开发JavaScript应用的核心。因此，有许多承诺方法可用，允许我们组合多个承诺并从中获得各种结果。</p><p id="acc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将看看其中的一些以及如何使用它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0231" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">通过<code class="fe mu mv mw mx b">'Promise.all()'</code>进行分叉和合并计算</h1><p id="81d0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以使用<code class="fe mu mv mw mx b">Promise.all</code>并行运行多个承诺。它接受一个包含一个或多个承诺的iterable对象，并使用所有承诺结果的数组进行解析。它返回一个承诺，该承诺解析为一个数组，其中包含每个承诺的解析结果。</p><p id="ee1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果拒绝任何承诺，则拒绝返回的承诺，同时拒绝第一个承诺的原因。</p><p id="f5d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以如下使用它:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="e8ee" class="nh md it mx b gy ni nj l nk nl">(async () =&gt; {<br/>  const [res1, res2] = await Promise.all([<br/>    Promise.resolve(1),<br/>    Promise.resolve(2),<br/>  ])<br/>  console.log(res1, res2);<br/>})()</span></pre><p id="c8b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码有一个包含两个承诺的数组作为<code class="fe mu mv mw mx b">Promise.all</code>的参数。</p><p id="d263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以使用析构赋值语法从数组中获取解析后的值。</p><p id="d081" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们从控制台日志中记录了<code class="fe mu mv mw mx b">1 2</code>。</p><p id="7c4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在运行<code class="fe mu mv mw mx b">Promise.all</code>之前，我们还可以将数组数据映射到承诺，如下所示:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="b421" class="nh md it mx b gy ni nj l nk nl">(async () =&gt; {<br/>  const promises = [1, 2].map(n =&gt; Promise.resolve(n));<br/>  const [res1, res2] = await Promise.all(promises)<br/>  console.log(res1, res2);<br/>})()</span></pre><p id="6f6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这为我们从零开始创建promise数组节省了一些输入。</p><p id="978e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用<code class="fe mu mv mw mx b">try...catch</code>捕捉错误，如下所示:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="b1a3" class="nh md it mx b gy ni nj l nk nl">(async () =&gt; {<br/>  try {<br/>    const promises = [1, 2].map(n =&gt; Promise.resolve(n));<br/>    const [res1, res2] = await Promise.all(promises)<br/>    console.log(res1, res2);<br/>  } catch (ex) {<br/>    console.log(ex);<br/>  }<br/>})()</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3dc4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">通过<code class="fe mu mv mw mx b">'Promise.race()'</code>暂停</h1><p id="adf5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe mu mv mw mx b">Promise.race</code>也接受一个数组，但是它返回一个承诺，这个承诺是用承诺组中第一个承诺的解析值来解析的。</p><p id="fab8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果承诺数组为空，那么<code class="fe mu mv mw mx b">Promise.race()</code>永远不会解决。</p><p id="a1af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以如下使用它:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="5f91" class="nh md it mx b gy ni nj l nk nl">(async () =&gt; {<br/>  const promises = [1, 2].map(n =&gt; Promise.resolve(n));<br/>  const res = await Promise.race(promises)<br/>  console.log(res);<br/>})()</span></pre><p id="849d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe mu mv mw mx b">Promise.resolve(1)</code>首先解析，因此<code class="fe mu mv mw mx b">res</code>为<code class="fe mu mv mw mx b">1</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f8bb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">' Promise.allSettled()'</h1><p id="e975" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe mu mv mw mx b">Promise.all()</code>如果任何承诺在此之前被拒绝，则不会运行其他承诺。为了等待它们全部运行并获得所有承诺的结果，不管它们是被解决还是被拒绝，我们必须使用<code class="fe mu mv mw mx b">allSettled</code>方法。</p><p id="973e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以如下使用它:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="3e31" class="nh md it mx b gy ni nj l nk nl">(async () =&gt; {<br/>  const res = await Promise.allSettled([<br/>    Promise.resolve(1),<br/>    Promise.reject(2),<br/>  ])<br/>})()</span></pre><p id="70fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mu mv mw mx b">res</code>是:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="fe24" class="nh md it mx b gy ni nj l nk nl">[<br/>  {<br/>    "status": "fulfilled",<br/>    "value": 1<br/>  },<br/>  {<br/>    "status": "rejected",<br/>    "reason": 2<br/>  }<br/>]</span></pre><p id="7395" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到了每一个承诺的<code class="fe mu mv mw mx b">status</code>——不管是实现了还是被拒绝了。</p><p id="ed5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也看到承诺的价值，以及承诺被拒绝的原因。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d0af" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="233b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有多个承诺，让我们在组中运行承诺。我们可以运行<code class="fe mu mv mw mx b">Promise.all</code>和<code class="fe mu mv mw mx b">Promise.allSettled</code>。<code class="fe mu mv mw mx b">allSettled</code>等待返回所有承诺结果。</p><p id="3817" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mu mv mw mx b">Promise.race</code>以已解决的第一个承诺的已解决值进行解决。</p></div></div>    
</body>
</html>