<html>
<head>
<title>How To Use Interfaces To Make the Code More Testable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用接口使代码更易测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-interfaces-to-make-the-code-more-testable-c68c04a9e7f5?source=collection_archive---------5-----------------------#2022-11-18">https://betterprogramming.pub/how-to-use-interfaces-to-make-the-code-more-testable-c68c04a9e7f5?source=collection_archive---------5-----------------------#2022-11-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f32f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">伟大的界面——第3部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/ad0715d5abcfc7dd1010d8aea763d037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*uwF7oqqczojyHFs4pY2Nyg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://pixabay.com/vectors/checklist-check-marketing-project-154274/" rel="noopener ugc nofollow" target="_blank">图片来自Pixabay </a></p></figure><h1 id="9ef3" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">介绍</h1><p id="2eba" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">编程到接口而不是实现。这一条规则可以给编程带来很多好处。本文将展示该接口如何通过重构来提高代码的可测试性。当我们使用接口时，我们可以在测试过程中用一个模拟对象替换实际对象，并且我们可以用任何我们想要的方式来模拟它，以达到软件测试的目的。</p><blockquote class="mj mk ml"><p id="2251" class="ln lo mm lp b lq mn ju ls lt mo jx lv mp mq ly lz mr ms mc md mt mu mg mh mi im bi translated">这是我关于伟大界面文章的最后一部分。请在下面找到前两篇文章的链接:</p><p id="e094" class="ln lo mm lp b lq mn ju ls lt mo jx lv mp mq ly lz mr ms mc md mt mu mg mh mi im bi translated">第1部分:它涵盖了界面的基础知识。<br/> <a class="ae ku" href="https://cullensun.medium.com/the-great-interface-part-2-84e0ee73ceb2" rel="noopener">第二部分</a>:主要讲利用接口实现一些常见的设计原则和设计模式。</p></blockquote><h1 id="2eb0" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">重构前</h1><p id="1e17" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">请看下面一个小小的订房app。它允许用户通过他们的电子邮件和预期日期来预订房间。如果预订成功，系统将更新数据库并向用户发送电子邮件。</p><h2 id="3926" class="mv kw it bd kx mw mx dn lb my mz dp lf lw na nb lh ma nc nd lj me ne nf ll ng bi translated"><code class="fe nh ni nj nk b"><strong class="ak">DataStoreService.java</strong></code></h2><p id="9965" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">这是一个连接到数据库并更新数据的类。真实世界的数据库访问将更加复杂，并且可能是异步的。然而，我简化了它来演示接口的概念。</p><pre class="kj kk kl km gt nl nk nm bn nn no bi"><span id="dce4" class="np kw it nk b be nq nr l ns nt">package com.great.refactor.before;<br/><br/>public class DataStoreService {<br/>    public DataStoreService() {<br/>        System.out.println("set up database connection");<br/>    }<br/><br/>    public boolean markDateAsBooked(String date) {<br/>        System.out.printf("write into database to book the date %s\n", date);<br/>        return true;<br/>    }<br/>}</span></pre><h2 id="5c11" class="mv kw it bd kx mw mx dn lb my mz dp lf lw na nb lh ma nc nd lj me ne nf ll ng bi translated"><strong class="ak">EmailService.java</strong></h2><p id="b748" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">该电子邮件服务将帮助我们向用户发送具有给定主题和内容的电子邮件。</p><pre class="kj kk kl km gt nl nk nm bn nn no bi"><span id="2d9c" class="np kw it nk b be nq nr l ns nt">package com.great.refactor.before;<br/><br/>public class EmailService {<br/>    public EmailService() {<br/>        System.out.println("configure and setup up email connection");<br/>    }<br/><br/>    public boolean sendEmail(String receiver, String subject, String content) {<br/>        System.out.printf("send email to %s \nsubject: %s \ncontent: %s\n", receiver, subject, content);<br/>        return true;<br/>    }<br/>}</span></pre><h2 id="f042" class="mv kw it bd kx mw mx dn lb my mz dp lf lw na nb lh ma nc nd lj me ne nf ll ng bi translated"><strong class="ak">Booking.java</strong></h2><p id="e525" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">这才是真正的预订应用本身。它有一个名为<code class="fe nh ni nj nk b">processBooking</code>的主要方法，依靠一个<code class="fe nh ni nj nk b">DataStoreService</code>实例和一个<code class="fe nh ni nj nk b">EmailService</code>实例来完成部分工作。</p><pre class="kj kk kl km gt nl nk nm bn nn no bi"><span id="afd4" class="np kw it nk b be nq nr l ns nt">package com.great.refactor.before;<br/>import java.time.LocalDate;<br/><br/>public class Booking {<br/>    public enum Result {<br/>        FAILURE,<br/>        PARTIAL_SUCCESS,<br/>        SUCCESS<br/>    }<br/><br/>    private DataStoreService dataStore = new DataStoreService();<br/>    private EmailService emailService = new EmailService();<br/><br/>    private String getEmailSubject() {<br/>        return "You have successfully booked the function room";<br/>    }<br/><br/>    private String getEmailContent() {<br/>        return "Thank you. See you soon.";<br/>    }<br/><br/>    public Result processBooking(String userEmail, LocalDate date) {<br/>        String dateStr = date.toString();<br/>        boolean bookingSuccess = dataStore.markDateAsBooked(dateStr);<br/>        if (!bookingSuccess) {<br/>            return Result.FAILURE;<br/>        }<br/><br/>        // Just simple illustration here. It might be some complicated logics in real application.<br/>        String emailSubject = getEmailSubject();<br/>        String emailContent = getEmailContent();<br/>        boolean sendingEmailSuccess = emailService.sendEmail(userEmail, emailSubject, emailContent);<br/>        if (!sendingEmailSuccess) {<br/>            System.out.println("Email server down. Need to alert user.");<br/>            return Result.PARTIAL_SUCCESS;<br/>        } <br/>       <br/>        return Result.SUCCESS;<br/>    }<br/><br/>    public static void main(String[] args) {<br/>        Booking booking = new Booking();<br/>        booking.processBooking("xyz@abc.com", LocalDate.now());<br/>    }<br/>}</span></pre><h2 id="2f6a" class="mv kw it bd kx mw mx dn lb my mz dp lf lw na nb lh ma nc nd lj me ne nf ll ng bi translated"><strong class="ak">测试</strong></h2><p id="bc67" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">我们打算对<code class="fe nh ni nj nk b">Booking</code>类进行单元测试。不幸的是，当前的实现使得测试变得不可能，因为依赖关系是如此紧密地耦合在一起。另一方面，在测试环境中，真实的数据库通常是不可访问的，在单元测试中它不应该发送真实的电子邮件。让我们继续看看如何重构代码，使其可测试。</p><h1 id="c78b" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">重构后</h1><h2 id="e64e" class="mv kw it bd kx mw mx dn lb my mz dp lf lw na nb lh ma nc nd lj me ne nf ll ng bi translated"><strong class="ak">DataStoreService.java</strong></h2><p id="35ac" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">现在我们有了<code class="fe nh ni nj nk b">DataStoreService</code>作为接口，我们有了一个叫做<code class="fe nh ni nj nk b">DataStoreImplementation</code>的类。</p><pre class="kj kk kl km gt nl nk nm bn nn no bi"><span id="b2d5" class="np kw it nk b be nq nr l ns nt">package com.great.refactor.after;<br/><br/>public interface DataStoreService {<br/>    public boolean markDateAsBooked(String date);<br/>}<br/><br/>class DataStoreImplementation implements DataStoreService {<br/>    public DataStoreImplementation() {<br/>        System.out.println("set up database connection");<br/>    }<br/><br/>    @Override<br/>    public boolean markDateAsBooked(String date) {<br/>        System.out.printf("write into database to book the date %s\n", date);<br/>        return true;<br/>    }<br/>}</span></pre><h2 id="cbd7" class="mv kw it bd kx mw mx dn lb my mz dp lf lw na nb lh ma nc nd lj me ne nf ll ng bi translated"><strong class="ak">EmailService.java</strong></h2><p id="2e0b" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">类似地，我们也有一个接口和一个对<code class="fe nh ni nj nk b">EmailService</code>的实现。</p><pre class="kj kk kl km gt nl nk nm bn nn no bi"><span id="8631" class="np kw it nk b be nq nr l ns nt">package com.great.refactor.after;<br/><br/>public interface EmailService {<br/>    public boolean sendEmail(String receiver, String subject, String content);<br/>}<br/><br/>class EmailImplementation implements EmailService {<br/>    public EmailImplementation() {<br/>        System.out.println("configure and setup up email connection");<br/>    }<br/><br/>    @Override<br/>    public boolean sendEmail(String receiver, String subject, String content) {<br/>        System.out.printf("send email to %s \nsubject: %s \ncontent: %s\n", receiver, subject, content);<br/>        return true;<br/>    }<br/>}</span></pre><h2 id="5329" class="mv kw it bd kx mw mx dn lb my mz dp lf lw na nb lh ma nc nd lj me ne nf ll ng bi translated"><strong class="ak">Booking.java</strong></h2><p id="3f15" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">“预订”现在依赖于接口而不是具体的类，依赖关系可以用构造函数提供(注入)。</p><pre class="kj kk kl km gt nl nk nm bn nn no bi"><span id="d29a" class="np kw it nk b be nq nr l ns nt">package com.great.refactor.after;<br/>import java.time.LocalDate;<br/><br/>public class Booking {<br/>    public enum Result {<br/>        FAILURE,<br/>        PARTIAL_SUCCESS,<br/>        SUCCESS<br/>    }<br/>    <br/>    private DataStoreService dataStore;<br/>    private EmailService emailService;<br/><br/>    public Booking(DataStoreService dataStore, EmailService emailService) {<br/>        this.dataStore = dataStore;<br/>        this.emailService = emailService;<br/>    }<br/><br/>    private String getEmailSubject() {<br/>        return "You have successfully booked the function room";<br/>    }<br/><br/>    private String getEmailContent() {<br/>        return "Thank you. See you soon.";<br/>    }<br/><br/>    public Result processBooking(String userEmail, LocalDate date) {<br/>        String dateStr = date.toString();<br/>        boolean bookingSuccess = dataStore.markDateAsBooked(dateStr);<br/>        if (!bookingSuccess) {<br/>            return Result.FAILURE;<br/>        }<br/><br/>        // Just simple illustration here. It might be some complicated logics in real application.<br/>        String emailSubject = getEmailSubject();<br/>        String emailContent = getEmailContent();<br/>        boolean sendingEmailSuccess = emailService.sendEmail(userEmail, emailSubject, emailContent);<br/>        if (!sendingEmailSuccess) {<br/>            System.out.println("Email server down. Need to alert user.");<br/>            return Result.PARTIAL_SUCCESS;<br/>        } <br/>       <br/>        return Result.SUCCESS;<br/>    }<br/><br/>    public static void main(String[] args) {<br/>        Booking booking = new Booking(new DataStoreImplementation(), new EmailImplementation());<br/>        booking.processBooking("xyz@abc.com", LocalDate.now());<br/>    }<br/>}</span></pre><h1 id="02e8" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated"><strong class="ak">模仿</strong></h1><p id="3bba" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">现在测试变得容易多了。我们可以创建如下所示的模拟类。请注意，我们可以任意操纵模拟类的行为，只要它们实现了接口。看看模拟类中的变量名。以“shall”为前缀的布尔变量(如<code class="fe nh ni nj nk b">shallBookSuccess</code>)将用于操纵模仿行为。而前缀为“updated”的变量将用于捕获调用参数以进行验证。</p><pre class="kj kk kl km gt nl nk nm bn nn no bi"><span id="6f8c" class="np kw it nk b be nq nr l ns nt">class MockDataStoreImplementation implements DataStoreService {<br/>    String updatedDate;<br/><br/>    boolean shallBookSucceed;<br/><br/>    @Override<br/>    public boolean markDateAsBooked(String date) {<br/>        updatedDate = date;<br/>        return shallBookSucceed;<br/>    }<br/>}<br/><br/>class MockEmailImplementation implements EmailService {<br/>    String updatedReceiver;<br/>    String updatedSubject;<br/>    String updatedContent;<br/><br/>    boolean shallEmailSucceed;<br/><br/>    @Override<br/>    public boolean sendEmail(String receiver, String subject, String content) {<br/>        updatedReceiver = receiver;<br/>        updatedSubject = subject;<br/>        updatedContent = content;<br/>        return shallEmailSucceed;<br/>    }<br/>}</span></pre><h1 id="08d0" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated"><strong class="ak">测试</strong></h1><p id="ecf2" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">请看看下面的测试。我们测试程序的每一条逻辑路径，以确保行为符合预期。</p><p id="3560" class="pw-post-body-paragraph ln lo it lp b lq mn ju ls lt mo jx lv lw mq ly lz ma ms mc md me mu mg mh mi im bi translated">例如，在第一个测试<code class="fe nh ni nj nk b">booking_dataStoreFail</code>中，我们设置数据存储失败。我们通过检查<code class="fe nh ni nj nk b">updatedDate</code>来检查<code class="fe nh ni nj nk b">dataStoreService</code>是否被调用，并且通过检查那些更新的变量是否为空来验证<code class="fe nh ni nj nk b">emailService</code>是否从未被调用。最后，我们还检查结果应该是<code class="fe nh ni nj nk b">FAILURE</code>。</p><pre class="kj kk kl km gt nl nk nm bn nn no bi"><span id="cf18" class="np kw it nk b be nq nr l ns nt">class MockEmailImplementation implements EmailService {<br/>    String updatedReceiver;<br/>    String updatedSubject;<br/>    String updatedContent;<br/><br/>    boolean shallEmailSucceed;<br/><br/>    @Override<br/>    public boolean sendEmail(String receiver, String subject, String content) {<br/>        updatedReceiver = receiver;<br/>        updatedSubject = subject;<br/>        updatedContent = content;<br/>        return shallEmailSucceed;<br/>    }<br/>}<br/><br/>public class BookingTest {<br/>    LocalDate getTestingDate() {<br/>        return LocalDate.of(2022, 11, 14);<br/>    }<br/><br/>    @Test<br/>    public void booking_dataStoreFail() {<br/>        // Given<br/>        MockDataStoreImplementation dataStoreService = new MockDataStoreImplementation();<br/>        dataStoreService.shallBookSucceed = false;<br/>        MockEmailImplementation emailService = new MockEmailImplementation();<br/>        emailService.shallEmailSucceed = true;<br/>        Booking booking = new Booking(dataStoreService, emailService);<br/><br/>        // When<br/>        Booking.Result bookingResult = booking.processBooking("xyz@abc.com", getTestingDate());<br/><br/>        // Then<br/>        assertEquals(dataStoreService.updatedDate, "2022-11-14");<br/>        assertEquals(emailService.updatedReceiver, null);<br/>        assertEquals(emailService.updatedSubject, null);<br/>        assertEquals(emailService.updatedContent, null);<br/>        assertEquals(bookingResult, Booking.Result.FAILURE);<br/>    }<br/><br/>    @Test<br/>    public void booking_dataStoreSuccess_emailFail() {<br/>        // Given<br/>        MockDataStoreImplementation dataStoreService = new MockDataStoreImplementation();<br/>        dataStoreService.shallBookSucceed = true;<br/>        MockEmailImplementation emailService = new MockEmailImplementation();<br/>        emailService.shallEmailSucceed = false;<br/>        Booking booking = new Booking(dataStoreService, emailService);<br/><br/>        // When<br/>        Booking.Result bookingResult = booking.processBooking("xyz@abc.com", getTestingDate());<br/><br/>        // Then<br/>        assertEquals(dataStoreService.updatedDate, "2022-11-14");<br/>        assertEquals(emailService.updatedReceiver, "xyz@abc.com");<br/>        assertEquals(emailService.updatedSubject, "You have successfully booked the function room");<br/>        assertEquals(emailService.updatedContent, "Thank you. See you soon.");<br/>        assertEquals(bookingResult, Booking.Result.PARTIAL_SUCCESS);<br/>    }<br/><br/>    @Test<br/>    public void booking_dataStoreSuccess_emailSuccess() {<br/>        // Given<br/>        MockDataStoreImplementation dataStoreService = new MockDataStoreImplementation();<br/>        dataStoreService.shallBookSucceed = true;<br/>        MockEmailImplementation emailService = new MockEmailImplementation();<br/>        emailService.shallEmailSucceed = true;<br/>        Booking booking = new Booking(dataStoreService, emailService);<br/><br/>        // When<br/>        Booking.Result bookingResult = booking.processBooking("xyz@abc.com", getTestingDate());<br/><br/>        // Then<br/>        assertEquals(dataStoreService.updatedDate, "2022-11-14");<br/>        assertEquals(emailService.updatedReceiver, "xyz@abc.com");<br/>        assertEquals(emailService.updatedSubject, "You have successfully booked the function room");<br/>        assertEquals(emailService.updatedContent, "Thank you. See you soon.");<br/>        assertEquals(bookingResult, Booking.Result.SUCCESS);<br/>    }<br/>}</span></pre><h1 id="2786" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">摘要</h1><p id="93bf" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">如果我们对接口编程，测试就变得容易多了。上面显示的重构过程将不可测试的软件变成了完全可测试的。我还提到了像模仿和依赖注入这样的概念，它们对于测试是必不可少的。</p><p id="6686" class="pw-post-body-paragraph ln lo it lp b lq mn ju ls lt mo jx lv lw mq ly lz ma ms mc md me mu mg mh mi im bi translated">希望对你有用。你可以在GitHub上找到这个<a class="ae ku" href="https://github.com/CullenSUN/great_interface/tree/master/src/main/java/com/great/refactor" rel="noopener ugc nofollow" target="_blank">项目</a>的完整源代码。</p></div></div>    
</body>
</html>