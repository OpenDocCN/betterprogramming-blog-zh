<html>
<head>
<title>A Look at Recursion in JavaScript with Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用例子看看JavaScript中的递归</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-look-at-recursion-in-javascript-with-examples-e5d27ebacf1e?source=collection_archive---------12-----------------------#2020-01-07">https://betterprogramming.pub/a-look-at-recursion-in-javascript-with-examples-e5d27ebacf1e?source=collection_archive---------12-----------------------#2020-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="45e0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">递归在调用堆栈中是什么样子的？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/12c61f27e7d545df3a7d1ecfc2496924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlK4QGY4DWp8nTALfdrfsA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">普里西拉·杜·普里兹在<a class="ae ky" href="https://unsplash.com/s/photos/loops?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ea30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着ECMA6脚本和ES2020的广泛支持，曾经经常在JavaScript中作为参考或编码面试练习示例的递归现在变得越来越普遍。</p><p id="c816" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一些实用有效的递归例子，包括:</p><ul class=""><li id="9fe5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在JavaScript中定义递归</li><li id="63cf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">调用栈</li><li id="0abe" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">迭代与递归解决方案</li><li id="6cd3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">利弊</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ba65" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">什么是递归？</h1><p id="8116" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">递归是一种编程技术，它通过优雅地将重复执行简化为具有相似性质的较小执行来解决复杂问题。</p><p id="1601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更进一步的研究表明，通过利用JavaScript中的调用栈，递归卷起嵌套函数，然后展开它们。在许多情况下，实现递归解决方案可以帮助提供可读性，并减少调试代码所需的时间。</p><p id="6558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们不要想太多。首先，让我们先定义递归。递归是一个调用自身的函数。</p><p id="82e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，下面的一些伪代码展示了递归是如何工作的:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="1de9" class="ns mr it no b gy nt nu l nv nw">function recursion() {<br/>return recursion()<br/>}<br/>recursion()</span></pre><p id="abf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nx">注意我们执行了两次递归函数，一次在函数范围内，另一次在全局范围外。</em></p><p id="3371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先在全局范围内执行递归函数，然后运行<em class="nx">递归函数脚本</em>，然后从我们的递归函数中调用递归函数<em class="nx">。这又会再次运行函数，再次调用递归——不断地将递归添加到我们的调用堆栈中，从而创建一个循环。</em></p><p id="aaf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照代码的原样，嵌套函数的无限循环被添加到调用堆栈中。</p><p id="4794" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用栈<strong class="lb iu"> </strong>是一个提供连续内存的区域，允许本地上下文并跟踪多个函数。然后，事件循环<strong class="lb iu"> </strong>监控调用堆栈，并在调用堆栈为空时发送事件或<em class="nx">函数回调</em>。</p><p id="6a2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在开发控制台中运行上面的递归函数，我们会收到以下错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/f7a50b69c6757c35230282615bf33a8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0fcDhhgXZfMKc9pONyubsA.png"/></div></div></figure><p id="acc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我们知道如何在函数中建立递归模式。</p><p id="ec02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过为我们的递归函数提供一个<strong class="lb iu">基础用例</strong>，我们可以调整嵌套函数的调用栈。基本情况是我们可以编写的条件，它将调用堆栈从递归缠绕切换到展开。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0c73" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">递归模式函数</h1><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="34a4" class="ns mr it no b gy nt nu l nv nw">function recursionPattern(num) {<br/><strong class="no iu">// base case</strong><br/>if(num &lt;= 0) {<br/>return 0 <br/>} else {<br/><strong class="no iu">// recursion execution</strong><br/>return recursionPattern(num  - 1)<br/>}}<br/>recursionPattern(5)</span></pre><p id="cedc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的递归将不再超出并中断调用堆栈，因为我们已经提供了一个<strong class="lb iu">基础用例:</strong> <code class="fe nz oa ob no b">if(num &lt;= 0). </code>。现在，一旦参数<code class="fe nz oa ob no b">num </code>小于或等于零，我们的函数将返回零。</p><p id="ce8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过调用参数为<code class="fe nz oa ob no b">num</code>减1的递归函数来进一步修改我们的递归执行。<code class="fe nz oa ob no b">recursionPattern</code>函数现在将总是返回零，调用栈将不再折叠。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9875" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">阶乘和与递归</h1><p id="7d5c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们用阶乘和一些代数刷新器更深入地探究递归的预备知识。</p><p id="bf65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编程中，一个数的<a class="ae ky" href="https://en.wikipedia.org/wiki/Factorial" rel="noopener ugc nofollow" target="_blank">阶乘</a>求和是一个<code class="fe nz oa ob no b">number</code>加上一个<code class="fe nz oa ob no b">number minus one</code>，直到<code class="fe nz oa ob no b">number </code>达到其条件完成。</p><p id="878b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">观察下面的二项式系数公式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/2e43881ca4fe2e05b151c6953bc497ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*r6mDTsSDh2XCKxj0qdmwqw.png"/></div></div></figure><p id="a150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能看起来像一个很长的数字链，但我们不要关注每个转换。相反，我们可以从简单公式的摘录中抓住我们需要的东西:<code class="fe nz oa ob no b">(n^n + n) / 2</code>。</p><p id="7716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定这个等式，让我们通过稍微修改函数来求解带有求和的阶乘，从而为上面的<code class="fe nz oa ob no b">recursionPattern</code>函数提供一个实际的上下文。</p><p id="0b35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过简单地返回函数的参数<code class="fe nz oa ob no b">num </code> +带有参数<code class="fe nz oa ob no b">num — 1</code>的递归执行来做到这一点:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="88ba" class="ns mr it no b gy nt nu l nv nw">function factorialSum(num) {<br/>if(num &lt;= 0) {<br/>return 0 <br/>} else {<br/>return num + factorialSum(num  - 1)<br/>}}<br/>factorialSum(5)<br/>// returns 15</span></pre><p id="3787" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在上面的函数中分解递归模式的执行。</p><p id="9202" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们的函数接受一个参数<code class="fe nz oa ob no b">num.</code>,然后我们设置我们的基本情况，这是条件<code class="fe nz oa ob no b">if</code>代码块。<code class="fe nz oa ob no b">if(num &lt;= 0) {<br/>return 0</code>。</p><p id="3a59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的参数小于或等于零，我们返回<code class="fe nz oa ob no b">0</code>并结束，向调用堆栈添加一个新的嵌套函数。</p><p id="932e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe nz oa ob no b">else</code>语句通过将我们的num(参数)连接到我们的递归执行<code class="fe nz oa ob no b">factorialSum(num — 1</code>来执行阶乘求和等式。我们在函数调用中从参数中减去<code class="fe nz oa ob no b">1</code>，这样每次我们再次调用函数时，num参数都会丢失一个值<code class="fe nz oa ob no b">1</code>。</p><p id="c1a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用堆栈从<code class="fe nz oa ob no b">5 </code>开始——初始参数:<code class="fe nz oa ob no b">factorialSum(5).</code>，然后JavaScript会将内存中的<code class="fe nz oa ob no b">5</code>添加到调用堆栈中，并从我们的参数中减去1，因此我们的新参数号现在是<code class="fe nz oa ob no b">4</code>。接下来，<code class="fe nz oa ob no b">ot</code>会将内存中的<code class="fe nz oa ob no b">4</code>添加到调用堆栈中，并再次执行该函数。我们现在的新论点是<code class="fe nz oa ob no b">3</code>。这一直持续到我们到达我们的基本情况，<code class="fe nz oa ob no b">0</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/09b39353567dff44f4613103b444de1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*66r4k-s5lUXYdE-r5roECQ.jpeg"/></div></figure><p id="f706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们到达我们的基本情况，调用栈已经结束了所有的递归嵌套函数，然后它以第一顺序(调用的最后一个函数)返回到最后一个函数(调用的第一个函数)。</p><p id="6caf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，这似乎有悖常理。然而，在下面的例子中，我们将对其进行分解，以便更清楚地查看。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="be61" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">迭代解决方案与递归解决方案</h1><p id="1542" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">对于每一个递归解，都有一个相等的迭代解。从这个意义上说，递归充当了自身的循环机制，并利用调用堆栈来完成其任务。同一问题的迭代解决方案依赖于迭代循环结构。</p><p id="d568" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们在编码挑战或面试问题中被要求寻找递归解决方案，这样做的技术将是首先写出迭代解决方案，然后使用它来绘制递归解决方案。</p><p id="1b37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查下面的问题，写出一个迭代解，然后是一个递归解。通过浏览这个过程，我们可以检查这一切是如何工作的。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4f38" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">迭代求解示例</h1><p id="c17b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">看一下下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="cb57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们看到一个函数有两个参数，<code class="fe nz oa ob no b">startVal</code>和<code class="fe nz oa ob no b">endVal.</code>，顾名思义，<code class="fe nz oa ob no b">startVal</code>是数组参数的起始编号，<code class="fe nz oa ob no b">endVal</code>是数组的结束编号。</p><p id="6440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数的目的是通过在调用该函数时提供这两个参数，我们返回一个数组，该数组包含了在<code class="fe nz oa ob no b">startVal </code>和<code class="fe nz oa ob no b">endVal.</code>之间按顺序排列的所有数字</p><p id="5ab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们的起始号码<code class="fe nz oa ob no b">startVal</code>是<code class="fe nz oa ob no b">1</code>并且我们的结束号码<code class="fe nz oa ob no b">endVal </code>是<code class="fe nz oa ob no b">5</code>，那么函数将返回:<code class="fe nz oa ob no b">[1,2,3,4,5]</code></p><p id="c784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这在上面的迭代解决方案中是如何工作的。首先，我们创建一个空数组。然后我们用三个条件设置我们的<code class="fe nz oa ob no b">for...loop</code>。我们将<code class="fe nz oa ob no b">i</code>(索引)初始化为我们的<code class="fe nz oa ob no b">startVal</code>的起始数。然后我们设置我们的循环，设置<code class="fe nz oa ob no b">i</code>(索引)运行，直到我们到达<code class="fe nz oa ob no b">endVal</code>。</p><p id="3ea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的最终条件是在每次运行到<code class="fe nz oa ob no b">i</code>后增加一个。最后，我们将结果放入数组<code class="fe nz oa ob no b">arr.push(i)</code>。这一切都很合理，布局也很好。</p><p id="f288" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经完成了在两个数字之间创建包含数组的迭代解决方案，那么让我们按照循环模式的类似基本逻辑构建一个递归解决方案，但是应用于调用堆栈而不是循环结构。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a210" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">递归解比较</h1><p id="83e2" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">首先，让我们用同样的两个参数创建函数:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="1f87" class="ns mr it no b gy nt nu l nv nw">function inclusiveArrayParamRecursive(startVal, endVal) {</span><span id="40de" class="ns mr it no b gy og nu l nv nw">}</span></pre><p id="04a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们创建一个基本案例，它遵循我们应用于<code class="fe nz oa ob no b">for…loop </code>条件的类似逻辑条件。</p><p id="6eb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们之前函数的<code class="fe nz oa ob no b">for…loop</code>中，我们写道:</p><p id="7aa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob no b">for(let i = startVal; i &lt;= endVal; i++)</code></p><p id="1c7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将<code class="fe nz oa ob no b">i</code>设置为<code class="fe nz oa ob no b">startVal</code>，然后运行<code class="fe nz oa ob no b">i </code>的循环，现在是<code class="fe nz oa ob no b">startVal </code>，直到它小于或等于<code class="fe nz oa ob no b">endVal</code>。</p><p id="fd43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于递归解决方案中的基础案例,我们可以应用类似的方法。通过设置一个<code class="fe nz oa ob no b">if else</code>条件块，一旦<code class="fe nz oa ob no b"> startVal</code>大于或等于<code class="fe nz oa ob no b">endVal</code>，我们返回起始值并结束递归。否则，我们运行递归执行。</p><p id="6377" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe nz oa ob no b">inclusiveArrayParamRecursive </code>现在看起来是这样的:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="8329" class="ns mr it no b gy nt nu l nv nw">if(startVal &gt;= endVal) {</span><span id="20b0" class="ns mr it no b gy og nu l nv nw">return [startVal]</span><span id="2623" class="ns mr it no b gy og nu l nv nw">} else {<br/>}}</span></pre><p id="9571" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以简单地创建一个变量，并将其设置为我们的递归执行，用我们的开始值和结束值减一，以在调用堆栈中创建wind结束点。在新变量中，我们将每个<code class="fe nz oa ob no b">endVal</code>的结果推入数组，然后调用堆栈在我们遇到基本情况时返回所有嵌套的函数。</p><p id="2e27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最终的递归解决方案如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="617c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们从每个<code class="fe nz oa ob no b">endVal </code>中减去1，并且从<code class="fe nz oa ob no b">6</code>的<code class="fe nz oa ob no b">endVal </code>参数开始，将每个新的<code class="fe nz oa ob no b">endVal</code>推入数组，但是我们从<code class="fe nz oa ob no b">2</code>的<code class="fe nz oa ob no b">startVal</code>开始收到一个增量订单。</p><p id="e330" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能看起来违反直觉，但希望注意到调用堆栈现在是如何工作的，这现在更有意义。调用堆栈将这些数字打包并存储嵌套的函数，然后在满足基本情况时返回它们。因此，我们接收的是一个增量数组，而不是减量数组。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="fff6" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="d522" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">现在我们已经讨论了迭代和递归，一个很好的练习是创建一个递归函数，它产生一个从<code class="fe nz oa ob no b">0</code>到<code class="fe nz oa ob no b">n</code>开始的增量数组。从写迭代解开始，然后转向递归解。</p><p id="f005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过分解和观察递归的实际例子，以及它们是如何作为更常见的JavaScript问题的有效解决方案形成的，我们可以提供一个更好的上下文，来说明递归模式如何成为我们编程的有益实现。</p><p id="e2a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然递归有助于提高代码的时间复杂度和清晰度，并有助于更好地调试代码，但警惕它的缺点也很重要。这些包括这样一个事实，即它会占用更多的内存，并且比某些迭代解决方案要慢。</p><p id="44e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多已经在这个行业工作了至少几年的web开发人员都会同意JavaScript在过去十年中经历了相当大的发展。</p><p id="0c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">密切关注JavaScript中递归的实现进度和模式，是了解该语言现状和未来发展方向的一个好方法。</p><p id="85eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。感谢您的阅读，我希望您能从中受益。</p><p id="e938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请在下面找到关于递归的完整视频教程，可以添加或检查的递归与迭代解决方案库，以及下面的一些其他资源。</p><p id="d828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://youtu.be/j0TlQf_tUjU" rel="noopener ugc nofollow" target="_blank">视频教程</a></p><p id="345a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/01Clarian/RecursionExamples" rel="noopener ugc nofollow" target="_blank">源代码</a></p><div class="oh oi gp gr oj ok"><a href="https://www.geeksforgeeks.org/recursion/" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">递归-极客forGeeks</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">什么是递归？函数直接或间接调用自己的过程称为递归，而函数调用自己的过程称为递归</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://softwareengineering.stackexchange.com/questions/242889/are-there-advantages-for-using-recursion-over-iteration-other-than-sometimes-r" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">使用递归比迭代有优势吗——除了有时可读性和…</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">首先，尽管确实总是存在与任何递归算法等价的迭代算法，但它…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">softwareengineering.stackexchange.com</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy ks ok"/></div></div></a></div></div></div>    
</body>
</html>