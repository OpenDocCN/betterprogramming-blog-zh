<html>
<head>
<title>Diving Into Clean Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">走进干净的建筑</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/diving-into-clean-architecture-2769ced23802?source=collection_archive---------2-----------------------#2022-09-02">https://betterprogramming.pub/diving-into-clean-architecture-2769ced23802?source=collection_archive---------2-----------------------#2022-09-02</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="e0ea" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">事件驱动应用的架构设计</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/52a0ffaa7a23807ef5711cf6d911d6fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*APkgqpbvIaFk3zD4"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@adrienconverse?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿德里安·匡威</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="1bfc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">随着从共享代码的单一应用程序向更基于消息的方法的转变，架构范式发生了巨大的变化。虽然<a class="ae kz" href="https://en.wikipedia.org/wiki/Multitier_architecture" rel="noopener ugc nofollow" target="_blank">的三层架构</a>是单片应用的虚拟架构，但事实证明它不太适合事件驱动的应用。</p><p id="6871" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">从单一应用程序的转变已经持续了好几年，行业领导者如<a class="ae kz" href="https://engineering.atspotify.com/2016/02/spotifys-event-delivery-the-road-to-the-cloud-part-i/" rel="noopener ugc nofollow" target="_blank"> Spotify已经概述了他们向云原生的转变</a>，以及他们如何在不中断的情况下处理每天数十亿个事件。</p><p id="a067" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当你想到事件驱动的架构时，也许一个将音乐流式传输到你的设备的应用程序并不是第一个跃入脑海的——这正是它如此强大的原因。</p><p id="fbac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你几乎可以将任何事情定义为一个事件。发邮件？转账？授权进入某个超级机密的电脑系统？实现什么并不重要；它只是应用程序核心的一个事件和处理程序。</p><p id="3962" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在过去的几年中，出现了几种以不同方式处理这种复杂性的架构模式。三个值得注意的是洋葱建筑，六边形建筑和干净的建筑。</p><p id="7055" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">三者都有相似的不同之处。它们都专注于将基础设施移动到外层，非常适合事件驱动的应用程序。</p><p id="2314" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它们都值得拥有自己的文章，但是在这一篇中，我们将专门深入到干净的架构中。</p><h1 id="387d" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">建筑</h1><p id="ee49" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">Clean architecture最初是由Robert c . Martin定义的，像洋葱和六角形架构一样，它非常注重基础设施细节的外部化，如数据库、消息传递等。</p><p id="ffc9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">识别基础设施组件并将它们移动到应用程序的外层，确保它们不会意外地与业务规则或其他应用程序代码混淆，从而产生依赖性。</p><p id="664d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在一个干净的架构中，依赖关系总是指向内部。如果我们看下面的图表，这意味着<code class="fe mt mu mv mw b">Web</code>组件可以引用<code class="fe mt mu mv mw b">Controllers</code>组件，而不是相反。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj mx"><img src="../Images/2d4473a21acc9cded935ea428c39a8c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*blk9w-Xg0YNZbHjX.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">干净的建筑，罗伯特·c·马丁的作品</p></figure><p id="c8df" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为内层永远不会知道外层的任何细节(或者它们的存在)，所以接口被用来跨边界公开功能。数据传输对象(d to)通常用于跨层传输数据。</p><h2 id="dea1" class="my lx iu bd ly mz na dn mc nb nc dp mg lj nd ne mi ln nf ng mk lr nh ni mm nj bi translated">理解分层</h2><p id="abe1" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">假设您有一个实体，该实体需要一个存储库来管理其存储需求。我们可以在上图中的实体级别声明存储库的接口，因为它处理实体，它不知道我们最终将使用的特定存储机制，也不关心。</p><p id="de89" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它只是从一些存储中检索实体，稍后再放回去。它就知道这么多。接口代表功能。这个接口可以被任何外层使用。</p><p id="db10" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当实现接口时，我们必须决定我们的存储介质。让我们假设我们使用一个SQL数据库来存储我们的实体。</p><p id="5c18" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们不可能将存储库的实现添加到实体层，因为这将意味着实体层现在完全偏向于SQL数据库，这是我们希望避免的全部事情。</p><p id="90ee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们使用的存储在某种程度上是为了支持应用程序。它不为业务提供直接价值，也不是应用程序特性或用例。这是一个强有力的指标，表明它可能是应用程序基础结构的一部分。</p><p id="e881" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，实现在实体层声明的存储库接口应该在最外面的基础设施层。这确保了实体如何存储的实现细节不会污染实体或应用程序本身。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nk"><img src="../Images/d22d18019ee396d076cd18ee7ce56b42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cu2i6eqx9FlbkpEf"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> CHUTTERSNAP </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="2a23" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">应用程序业务规则</h1><p id="774d" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">在上一节中，我们谈到了实体和基础设施层。实体表示业务对象、客户及其相关数据、准备发货的订单等。他们更有可能因内部变化而改变，而不是外部变化。</p><p id="23c1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的基础设施层处理实现细节。我们如何存储对象，我们使用什么服务来发送电子邮件，等等。？</p><p id="5fd4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">应用层，或用例层，处理业务逻辑并指导实体的流程。如果您正在设计一个航班预订系统，并且有一个业务规则规定您可以超额预订航班，那么应用层就是您定义该规则的地方。</p><p id="25d9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是众所周知的神奇发生的一层。如果日常操作发生变化，或者必须向系统添加新功能，这很可能意味着应用层的变化。</p><p id="785d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然架构没有明确指定，但这一层通常使用<a class="ae kz" href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation" rel="noopener ugc nofollow" target="_blank">命令——查询分离</a>来构建，它与事件紧密联系在一起。每个事件要么是命令，要么是查询，由命令或事件处理程序处理。这些消息交互中的每一个都可以代表一个用例或特性。</p><h2 id="016f" class="my lx iu bd ly mz na dn mc nb nc dp mg lj nd ne mi ln nf ng mk lr nh ni mm nj bi translated">尖叫的建筑</h2><p id="826b" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">定义干净架构的另一个有趣的方面是它鼓励所谓的<a class="ae kz" href="https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html" rel="noopener ugc nofollow" target="_blank">尖叫架构</a>。</p><p id="fc00" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">尖叫架构的基本前提很简单:每个应用程序都应该尖叫它做什么。不是用什么语言写的，不是用什么框架，而是应用程序支持什么功能？</p><p id="7004" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">根据您的编程语言，这可能会以不同的方式实现。但是它通常以非常容易识别的代码组织形式出现，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nl"><img src="../Images/07adb76038b1bccfc4e949dfeac80a93.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*uHnvB1lFVbgVukdfmn0LPA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">不会错的。</p></figure><p id="c567" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">甚至不用查看项目中的任何其他内容，您就可以看出您正在查看某种活动预订系统。</p><h1 id="ca1b" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">易测性</h1><p id="9eb2" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">由于分层方法，实现干净架构的应用程序很容易测试。您可以确信您的测试不会被模糊的实现细节所阻碍，比如特定的数据库或一些迟钝的邮件服务。</p><p id="b743" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这意味着测试可以实现内存中的数据库，而不是依赖于SQL数据库。不需要邮寄服务？嘲笑他们，然后忘掉它。</p><p id="4ae7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我经常看到clean architecture应用程序专注于测试它们的用例，而不是更传统的单元测试。在端到端测试应用层时，您可以确保应用程序的核心功能按预期运行，而不必单独测试每一行。</p><h1 id="bdaf" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">结论</h1><p id="103b" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">我们只接触了干净的建筑和它所提供的东西。如果要我总结的话，clean architecture是一个可测试的、以事件为中心的、分层的架构，如果你不清楚你在构建什么，这是一个非常好的架构。</p><p id="00bf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由于分层和缺乏依赖性，您拥有了各种各样的灵活性。例如，您可以以整体方式启动您的应用程序。当您对外部世界有了更好的了解后，您可以毫不费力地将事件、处理程序和实体拆分到微服务中。如果你愿意，你甚至可以把它提升一个档次，进入领域驱动。</p><p id="cf44" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你对这个话题感兴趣，我推荐罗伯特·c·马丁的《<a class="ae kz" href="https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164" rel="noopener ugc nofollow" target="_blank">干净的建筑》(我所链接的博文就是他写的)。</a></p><p id="cda5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你也可以看看我写的一个例子项目，叫做<a class="ae kz" href="https://github.com/aevitas/CleanTickets" rel="noopener ugc nofollow" target="_blank"> Clean Tickets </a>。这是实现clean架构的事件票务系统的一个相对较小的实现。</p><p id="3854" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢你的阅读，我希望我已经设法激起你的兴趣！</p></div></div>    
</body>
</html>