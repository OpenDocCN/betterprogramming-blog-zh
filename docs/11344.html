<html>
<head>
<title>Managing and Analyzing WebSockets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">管理和分析WebSockets</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/managing-and-analyzing-websockets-c0a051a3dec1?source=collection_archive---------5-----------------------#2022-03-10">https://betterprogramming.pub/managing-and-analyzing-websockets-c0a051a3dec1?source=collection_archive---------5-----------------------#2022-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="853e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Socket的动手教程。IO和WebSocket</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ef8e11f7a4ab642b38c7355912fcf987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CFuEMUvLjRDbh_mG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@srosinger3997?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">萨曼莎·加德斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="61f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WebSocket 是一种计算机通信协议，通过单一TCP连接提供全双工通信通道。WebSocket协议由IETF在2011年12月标准化为<a class="ae ky" href="https://datatracker.ietf.org/doc/html/rfc6455" rel="noopener ugc nofollow" target="_blank"> RFC 6455 </a>，而<a class="ae ky" href="https://www.w3.org/TR/2009/WD-websockets-20091222/" rel="noopener ugc nofollow" target="_blank"> WebSocket API </a>由W3C在2009年12月指定。截至目前，所有主流浏览器都支持WebSocket API。</p><p id="5280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发WebSocket是为了克服基于HTTP的技术的局限性。与单向协议HTTP相比，它提供双向通信。大多数浏览器将<code class="fe lv lw lx ly b">HTTP/1.0</code>或<code class="fe lv lw lx ly b">HTTP/1.1</code>限制为每个原点6–8个TCP连接。幸运的是，WebSocket只需要一个连接。</p><p id="6cef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WebSocket发送和接收数据的速度比HTTP快得多。它甚至比AJAX更快。WebSocket请求不受同源策略的限制。它更加灵活，同时也容易受到跨站点的WebSocket劫持攻击。</p><p id="84c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/socketio/socket.io" rel="noopener ugc nofollow" target="_blank">插座。IO </a>是一个支持客户端和服务器之间实时、双向和基于事件的通信的库。它是WebSocket API的一个“微小”包装器。虽然WebSocket是最低标准。IO提供企业级WebSocket。</p><p id="8131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将了解如何使用WebSocket/Socket。IO，以及如何使用网络面板分析它们。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="50aa" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">关于插座。超正析象管(Image Orthicon)</h1><p id="b240" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们将看一看Socket。IO优先。</p><p id="c854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么？</p><p id="5c69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为插座。IO提供了企业级的WebSocket，其中已经处理了很多实现细节。</p><h2 id="99b3" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">建立工作环境</h2><p id="6245" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">正如我们在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/exploring-socket-io-in-react-working-environment-e505bf1c857c">探索插座中所描述的。IO处于React工作环境</a>，Socket。IO示例构建在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/10-fun-facts-about-create-react-app-eb7124aa3785"> Create React App </a>环境中。</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="3bb2" class="nd mh it ly b gy nt nu l nv nw">npx create-react-app react-socket<br/>cd react-socket</span></pre><p id="4d05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在工作环境中，我们需要一台客户机和一台服务器相互通信。为了简化任务，我们将客户机和服务器设置在同一个存储库中。</p><p id="48fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装服务器包:<code class="fe lv lw lx ly b">npm i socket.io</code>。</p><p id="e0aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装客户端包:<code class="fe lv lw lx ly b">npm i socket.io-client</code>。</p><p id="e5a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，<code class="fe lv lw lx ly b">package.json</code>在<code class="fe lv lw lx ly b"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/package-jsons-dependencies-in-depth-a1f0637a3129">dependencies</a></code>中包含了两个额外的包:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="27c9" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">设置客户端</h2><p id="dcb5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们创建了一个只有一个按钮的用户界面，<code class="fe lv lw lx ly b">Click to request date from server</code>。点击按钮发送一个套接字。对服务器的IO请求。收到请求后，服务器会用当前日期进行响应。客户端接收服务器日期并将其显示在屏幕上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/37a5fb43cf88a4fcebf562977aae07dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*M4SpPaj0RKBQxguA4IbBZQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下<code class="fe lv lw lx ly b">src/App.js</code>修改为客户端:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="1232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2号线从<code class="fe lv lw lx ly b">'socket.io-client'</code>导入<code class="fe lv lw lx ly b">io</code>。</p><p id="e442" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过调用<code class="fe lv lw lx ly b">io('http://localhost:5000')</code>(第9行)来初始化套接字，其中服务器在<code class="fe lv lw lx ly b">'http://localhost:5000'</code>上运行。如果客户端和服务器位于同一原点，则不需要指定URL。</p><p id="6fc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有3个特殊事件需要收听:<code class="fe lv lw lx ly b">'connect'</code>、<code class="fe lv lw lx ly b">'disconnect'</code>和<code class="fe lv lw lx ly b">'connect_error'</code>，分别在11号线、13号线和17号线收听。</p><p id="ba34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第21行监听自定义事件，<code class="fe lv lw lx ly b">'responseDate'</code>。</p><p id="dc00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们调用<code class="fe lv lw lx ly b">useRef</code>(第6行)来生成一个引用以保持套接字的持久性(第23行)。客户端请求由按钮的<code class="fe lv lw lx ly b">onClick</code>方法调用(第30行)。</p><p id="831d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务器响应被保存到第21行的状态<code class="fe lv lw lx ly b">serverData</code>。然后，由第34行呈现。</p><p id="14b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">socket.on(eventName, listener)</code>是套接字中的一个方法。IO库。套接字连接侦听指定的事件，并调用回调侦听器。</p><h2 id="0b10" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">设置服务器</h2><p id="c68e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们需要为客户端建立一个服务器来进行对话。在<code class="fe lv lw lx ly b">server/index.mjs</code>中设置一个快递服务器。在下面的代码中，使用了一个HTTP包装器，因为当调用<code class="fe lv lw lx ly b">app.listen</code>时，pure Express服务器会创建一个新的HTTP服务器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="28ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第8行创建了一个Express服务器。</p><p id="84ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第9行用HTTP包装了服务器。</p><p id="d452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第10行用HTTP包装器初始化<code class="fe lv lw lx ly b">io</code>。</p><p id="7891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第11行从环境变量中读取端口。如果未设置，默认值为5000。</p><p id="c74a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第13–15行服务于由<code class="fe lv lw lx ly b">npm run build</code>生成的产品网页。</p><p id="c1fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第17行监听内置事件<code class="fe lv lw lx ly b">'connection'</code>，并设置其他监听器。</p><p id="bcde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第20–26行监听自定义事件，<code class="fe lv lw lx ly b">'requestDate'</code>。收到事件后，它调用服务器日期(第21行)。它发出事件的日期，<code class="fe lv lw lx ly b">'responseDate'</code>。不需要对要发送的内容运行<code class="fe lv lw lx ly b">JSON.stringify()</code>，因为它会自动完成。对于不可序列化的对象，如Map和Set，必须手动序列化。</p><p id="9adf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第28行监听内置事件<code class="fe lv lw lx ly b">'disconnect'</code>，并输出消息。</p><p id="edc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第31行在指定的端口启动HTTP服务器。</p><p id="74da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe lv lw lx ly b">node server/index.mjs</code>运行服务器。单击用户界面上的按钮显示服务器日期。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/37a5fb43cf88a4fcebf562977aae07dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*M4SpPaj0RKBQxguA4IbBZQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="daad" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">分析套接字。超正析象管(Image Orthicon)</h2><p id="2672" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在插座里。例如，我们打印出了许多调试信息。其实没必要。我们可以使用<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/analyzing-javascript-ui-performance-using-network-panel-and-har-files-bff526df60b2">网络面板</a>来检查套接字通信。该示例在Chrome上运行，但在其他浏览器上也类似。</p><p id="6e63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开网络面板。以下是建议的分析过程:</p><ul class=""><li id="e550" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated">选中<code class="fe lv lw lx ly b">Preserve log</code>复选框，保存跨页面加载的请求。</li><li id="bb94" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">选中<code class="fe lv lw lx ly b">Disable cache</code>复选框，模拟首次用户体验。</li><li id="607e" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">单击“清除”按钮，清除“请求”表中的所有请求。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/1cc34135f2144f40ff1582cc83b16691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mAkjBlYMjAblUCgo.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="631e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点按该按钮几次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/1f8d8dc5d52c06eaad8afcaf42525400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kiWpc7VVGjziiO-CJAMiYw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4522" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求表中有一些请求，但是只有一个<code class="fe lv lw lx ly b">websocket</code>连接。除了查看<code class="fe lv lw lx ly b">All</code>请求，我们还可以按下按钮，仅使用<code class="fe lv lw lx ly b">WS</code> (WebSocket)进行过滤。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/134f7cb3ec547f25290be4412a5ec953.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bvx7FWvQhZGrnJFWJOWxXQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5c34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击WebSocket请求，我们可以查看所有的Socket通信。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/24daecb35dfed8941c72a26a555c3205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rqb_PFuaRbGp6e8zjhhxHA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8fa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是插座。IO的消息定义:</p><ul class=""><li id="bd63" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated">0打开:当新传输打开时从服务器发送(重新检查)。</li><li id="e7e4" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">1 close:请求关闭此传输，但不关闭连接本身。</li><li id="56bf" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">2 ping:发送探测请求。</li><li id="fc67" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">3 pong:响应探测请求。</li><li id="1ad1" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">4消息:发送实际的消息。</li><li id="2724" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">5升级:插座。IO测试浏览器是否支持WebSocket。如果是，则升级为WebSocket。否则，它保持HTTP长轮询。</li><li id="b44d" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">6 noop:主要用于在接收到传入的WebSocket连接时强制轮询周期。</li></ul><p id="4c23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的截图显示了流程:客户端发送<code class="fe lv lw lx ly b">2probe</code>，服务器响应<code class="fe lv lw lx ly b">3probe</code>。然后客户端发送一堆<code class="fe lv lw lx ly b">42[]</code>消息，其中自定义事件是<code class="fe lv lw lx ly b">'requestDate'</code>，消息是<code class="fe lv lw lx ly b">'need date'</code>。在接收到每个定制事件时，服务器用一个<code class="fe lv lw lx ly b">42[]</code>消息响应，其中定制事件是<code class="fe lv lw lx ly b">'responseDate'</code>，消息是服务器日期。当客户端空闲时，服务器用【pings，客户端返回<code class="fe lv lw lx ly b">3</code>。</p><p id="c8ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些详细的信息，分析套接字通信就变得简单了。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f64e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">关于WebSocket</h1><p id="0da4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们用WebSocket实现同一个例子。不需要安装任何包，因为WebSocket是JavaScript的一部分。</p><h2 id="fce4" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">设置客户端</h2><p id="a168" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">src/App.js</code>修改为WebSocket客户端。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="0ebf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过调用WebSocket连接所在的<code class="fe lv lw lx ly b">'ws://localhost:8080'</code>来初始化一个套接字(第8行)。</p><p id="238c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第9行，<code class="fe lv lw lx ly b">socket</code>监听内置的<code class="fe lv lw lx ly b">open</code>事件。根据类型定义，套接字对象具有方法<code class="fe lv lw lx ly b">onopen</code>。相反，我们使用了不寻常的方法<code class="fe lv lw lx ly b">addEventListener</code>。</p><p id="0373" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么？</p><p id="49bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为socket对象在socket打开之前没有<code class="fe lv lw lx ly b">onopen</code>、<code class="fe lv lw lx ly b">onclose</code>、<code class="fe lv lw lx ly b">onmessage</code>和<code class="fe lv lw lx ly b">onmessage</code>的方法。对<code class="fe lv lw lx ly b">onmessage</code>(第11行)、<code class="fe lv lw lx ly b">onclose</code>(第24行)和<code class="fe lv lw lx ly b">onerror</code>(第26行)的调用是在<code class="fe lv lw lx ly b">addEventListener</code>回调(第9-27行)中调用的。否则，这些监听器中的每一个都需要连接到<code class="fe lv lw lx ly b">addEventListener</code>。</p><p id="3791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">open</code>之后没有可用的插座id。消息更简单，没有自定义事件、频道或房间。</p><p id="f521" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于字符串消息，可以直接显示(第20行)。</p><p id="b4d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于对象消息，客户端接收一个<code class="fe lv lw lx ly b">Blob</code>(第13行)。如果我们试图<code class="fe lv lw lx ly b">JSON.stringify</code>这个Blob，它会抛出一个错误:<code class="fe lv lw lx ly b">Uncaught TypeError: Converting circular structure to JSON</code>。我们必须用<code class="fe lv lw lx ly b">FileReader</code>来解释<code class="fe lv lw lx ly b">Blob</code>(第14-18行)。</p><p id="c465" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与套接字进行比较。IO，很明显WebSocket是一个光秃秃的最低标准。</p><h2 id="064d" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">为字符串消息设置服务器</h2><p id="af32" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们在<code class="fe lv lw lx ly b">server/index.mjs</code>用的是同一个Express服务器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="9b66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第10行通过<code class="fe lv lw lx ly b">new WebSocketServer.Server({ port: 8080 })</code>初始化<code class="fe lv lw lx ly b">io</code>。</p><p id="3808" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第17行监听内置事件<code class="fe lv lw lx ly b">'connection'</code>，并在回调中设置其他监听器(第18–26行)。</p><p id="ea07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第20–24行监听内置事件<code class="fe lv lw lx ly b">'message'</code>。收到消息后，它调用服务器日期并将其转换为字符串(第21行)。字符串消息被发送回客户端(第22行)。</p><p id="d55c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第26行监听内置事件<code class="fe lv lw lx ly b">'close'</code>，并记录消息。</p><p id="a222" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe lv lw lx ly b">node server/index.mjs</code>运行服务器。单击用户界面上的按钮显示服务器日期。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/9a3856fcb3dd7f526ca758cb98eefb8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*BZg-cOwOMH--IvGfeYPEbQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2abc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，日期是引用的。</p><h2 id="9443" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">分析字符串消息的WebSocket</h2><p id="a048" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">打开检查器并选取“网络”面板。点按该按钮几次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/0b051c982c25dccdd2ee5e8be23478cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ZEVrXVlPibyhOJS54gA4g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0360" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求表中有一些请求，但是只有一个<code class="fe lv lw lx ly b">websocket</code>连接。除了查看<code class="fe lv lw lx ly b">All</code>请求，我们还可以按下按钮，仅使用<code class="fe lv lw lx ly b">WS</code> (WebSocket)进行过滤。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/e97a54d1dd03ccad357e16f8ec82803c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o9nUir0UKdl_n1J0OjwHcQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e9de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击WebSocket请求，我们可以查看所有的Socket通信。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/f2f06be79b185c70090afb9113790f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R7SS5jou5UZIpMNEMx-4sA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6ef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">消息流更简单:客户端发送一堆<code class="fe lv lw lx ly b">'requestDate</code>。收到每条消息后，服务器都以服务器日期作为响应。</p><p id="b8bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">socket communicate可以用来分析WebSocket实现。</p><h2 id="0c2a" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">为对象消息设置服务器</h2><p id="bde7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们已经设置了客户端来处理字符串和对象(Blob)消息。下面的<code class="fe lv lw lx ly b">server/index.mjs</code>发送一个<code class="fe lv lw lx ly b">date</code>对象(第22行):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="0d88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe lv lw lx ly b">node server/index.mjs</code>运行服务器。单击用户界面上的按钮显示服务器日期。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/6d48c052117cf26d1e12abbc9c2f07e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*CHiDzqMNVKdtx8eOHWTuag.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3908" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，日期格式是不同的。</p><h2 id="0e8a" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">分析对象消息的WebSocket</h2><p id="85eb" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在网络面板上做同样的分析。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/d893d05f8e3cadda08a4ad02943698ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oaaqXtjKZgs0AJA9ZQ_eEw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="60b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端发一堆<code class="fe lv lw lx ly b">'requestDate</code>。在接收到每个消息时，服务器用<code class="fe lv lw lx ly b">Binary Message</code>进行响应。</p><p id="99d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击每个<code class="fe lv lw lx ly b">Binary Message</code>，显示二进制值和解释值用于分析。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/6a111b41af6a91488c14e40e65d74b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KK99Af1y-FcDmprWyGL55w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="fc97" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="2bb1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们已经给出了一个关于如何使用Socket的实践教程。IO和WebSocket工作。DevTools的网络面板是分析套接字通信的有效工具。它允许我们利用WebSocket，而不用担心调试的难度。</p><p id="84bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。如果你有兴趣，可以看看<a class="ae ky" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener">我的其他媒体文章</a>。</p></div></div>    
</body>
</html>