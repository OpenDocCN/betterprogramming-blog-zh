<html>
<head>
<title>How To Safely Work With Nested Objects in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中安全地使用嵌套对象</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-safely-work-with-nested-objects-in-javascript-aed39fb8bad2?source=collection_archive---------11-----------------------#2021-07-22">https://betterprogramming.pub/how-to-safely-work-with-nested-objects-in-javascript-aed39fb8bad2?source=collection_archive---------11-----------------------#2021-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c0fe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用嵌套对象时要小心</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7f0ee312eb55a7c1590943914e7c027c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nTYUrnYSb7Zulxcv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">菲利普·姆罗兹在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="5e00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您以前使用过API，那么您很可能使用过深度嵌套的对象。考虑以下对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="73ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试访问一些值:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="bca3" class="mc md it ly b gy me mf l mg mh">console.log(<br/>    someObject.data[0].attributes.color<br/>)<br/>// red</span></pre><p id="7ca9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，但是如果我们试图访问数据中第二个元素的<code class="fe mi mj mk ly b">color</code>属性呢？</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="1498" class="mc md it ly b gy me mf l mg mh">console.log(<br/>    someObject.data[1].attributes.color<br/>)<br/>// undefined</span></pre><p id="5b16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它打印出<code class="fe mi mj mk ly b">undefined</code>,因为<code class="fe mi mj mk ly b">attributes</code>属性是空的。让我们尝试访问<code class="fe mi mj mk ly b">arr</code>属性中的第二个元素:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="6f6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一种情况下，<code class="fe mi mj mk ly b">2</code>被打印在控制台上。然而，在第二种情况下，我们得到一个错误。</p><p id="2445" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为<code class="fe mi mj mk ly b">someObject.data[1].attributes</code>为空，因此<code class="fe mi mj mk ly b">attributes.arr</code>为<code class="fe mi mj mk ly b">undefined</code>。当我们试图访问<code class="fe mi mj mk ly b">arr[1]</code>时，我们实际上是试图索引<code class="fe mi mj mk ly b">undefined</code>，这导致了一个错误。</p><p id="5f7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将代码放在一个<code class="fe mi mj mk ly b">try..catch</code>块中来优雅地处理错误，但是如果您有很多需要访问深度嵌套值的情况，您的代码看起来会很冗长。</p><p id="660b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看另一个场景。这一次，我们想要更新<code class="fe mi mj mk ly b">arr</code>中索引<code class="fe mi mj mk ly b">0</code>处元素的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="1dbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再次得到类似的类型错误。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="db3f" class="ms md it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">安全访问深度嵌套的值</h1><p id="e78b" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在本文中，我们将讨论三种方法。</p><h2 id="def1" class="mc md it bd mt no np dn mx nq nr dp nb li ns nt nd lm nu nv nf lq nw nx nh ny bi translated">使用普通JS</h2><p id="0c61" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们可以使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank">可选链接(？。)</a>操作员:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="c5a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这次它不会导致错误。而是打印<code class="fe mi mj mk ly b">undefined</code>。<code class="fe mi mj mk ly b">?.</code>导致表达式短路(即，如果<code class="fe mi mj mk ly b">?.</code>左侧的数据是<code class="fe mi mj mk ly b">undefined</code>或<code class="fe mi mj mk ly b">null</code>，则返回<code class="fe mi mj mk ly b">undefined</code>，不再对表达式求值)。</p><p id="2f5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，大多数浏览器都支持可选链接。但是，如果您对使用Lodash/Rambda感兴趣，可以查看下面的部分。</p><h2 id="6be2" class="mc md it bd mt no np dn mx nq nr dp nb li ns nt nd lm nu nv nf lq nw nx nh ny bi translated">使用Lodash</h2><p id="d18c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">如果你不想在你的代码中看到一堆问号，你可以使用Lodash的<code class="fe mi mj mk ly b">get</code>函数。下面是语法:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="ebe3" class="mc md it ly b gy me mf l mg mh">get(object, path, [defaultValue])</span></pre><p id="3bc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要安装Lodash:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="111d" class="mc md it ly b gy me mf l mg mh">npm install lodash</span></pre><p id="cad5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是使用<code class="fe mi mj mk ly b">get</code>函数的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="cbc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认值是可选的。如果不指定默认值，它将简单地返回undefined。</p><h2 id="bc5c" class="mc md it bd mt no np dn mx nq nr dp nb li ns nt nd lm nu nv nf lq nw nx nh ny bi translated">使用Rambda</h2><p id="615b" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们可以使用<code class="fe mi mj mk ly b">path</code>或<code class="fe mi mj mk ly b">pathOr</code>功能。不同之处在于，使用<code class="fe mi mj mk ly b">pathOr</code>函数，我们可以指定一个默认值。</p><p id="1008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要安装Rambda:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="9944" class="mc md it ly b gy me mf l mg mh">npm install rambda</span></pre><p id="954e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是访问这些值的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="46a6" class="ms md it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">安全设置深度嵌套对象的值</h1><h2 id="cd63" class="mc md it bd mt no np dn mx nq nr dp nb li ns nt nd lm nu nv nf lq nw nx nh ny bi translated">使用Lodash</h2><p id="a423" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们可以使用洛达什的<code class="fe mi mj mk ly b">set</code>函数。下面是语法:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="6112" class="mc md it ly b gy me mf l mg mh">set(object, path, value)</span></pre><p id="479b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们提供一个不存在的路径，它将创建路径:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="f91a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初，<code class="fe mi mj mk ly b">attributes</code>属性是空的，但是当我们试图为<code class="fe mi mj mk ly b">attributes.arr[1]</code>设置一个值时，一个<code class="fe mi mj mk ly b">arr</code>属性被添加到<code class="fe mi mj mk ly b">attributes</code>，一个空元素被添加，然后<code class="fe mi mj mk ly b">200</code>被添加。</p><p id="0dbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，如果我们指定的路径不存在，它将创建该路径并设置值。</p><h2 id="5ff9" class="mc md it bd mt no np dn mx nq nr dp nb li ns nt nd lm nu nv nf lq nw nx nh ny bi translated">使用Rambda</h2><p id="ff87" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们可以使用Rambda中的<code class="fe mi mj mk ly b">assocPath</code>函数做一些类似于Lodash的<code class="fe mi mj mk ly b">set</code>函数的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="73b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mi mj mk ly b">assocPath</code>不是就地函数(即不更新对象)。它返回一个新的对象。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="b401" class="ms md it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">资源</h1><p id="2dc2" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/4-ways-to-safely-access-nested-objects-in-vanilla-javascript-8671d09348a8">本文</a>作者<a class="nz oa ep" href="https://medium.com/u/2290b8c53ff8?source=post_page-----aed39fb8bad2--------------------------------" rel="noopener" target="_blank">曾厚林</a>讲述了使用普通JavaScript访问深度嵌套值的四种不同方法。</p><p id="0834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/javascript-inside/safely-accessing-deeply-nested-values-in-javascript-99bf72a0855a" rel="noopener">本文</a>作者<a class="nz oa ep" href="https://medium.com/u/52e7bcc5db67?source=post_page-----aed39fb8bad2--------------------------------" rel="noopener" target="_blank"> A. Sharif </a>也谈到了安全访问深度嵌套对象和一些更多的Rambda函数。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="26c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">【https://www.realpythonproject.com】原载于<a class="ae ky" href="https://www.realpythonproject.com/how-to-safely-work-with-nested-objects-in-javascript/" rel="noopener ugc nofollow" target="_blank"><em class="ob"/></a></p></div></div>    
</body>
</html>