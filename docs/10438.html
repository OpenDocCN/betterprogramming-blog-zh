<html>
<head>
<title>How to Use the Magical @staticmethod, @classmethod, and @property Decorators in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中使用神奇的@staticmethod、@classmethod和@property装饰器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-the-magical-staticmethod-classmethod-and-property-decorators-in-python-e42dd74e51e7?source=collection_archive---------0-----------------------#2022-01-07">https://betterprogramming.pub/how-to-use-the-magical-staticmethod-classmethod-and-property-decorators-in-python-e42dd74e51e7?source=collection_archive---------0-----------------------#2022-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3460" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习Python中的特殊装饰器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b2aa8711108fe692d3b4a7a468b9da1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yPOoejcL-9OBL6sl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@almosbech?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿尔莫斯·贝托尔德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="fa9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">装饰器是一个函数，它接受另一个函数作为输入，扩展它的行为，并返回一个新函数作为输出。这是可能的，因为在Python中，函数是<a class="ae ky" href="https://en.wikipedia.org/wiki/First-class_citizen" rel="noopener ugc nofollow" target="_blank">一级对象</a>，这意味着它们可以作为参数传递给函数，也可以从函数返回，就像string、int或float等其他类型的对象一样。装饰器可以用来装饰一个<a class="ae ky" href="https://medium.com/codex/understand-and-master-the-decorator-in-python-481aa444933f" rel="noopener">函数</a>或者一个<a class="ae ky" href="https://medium.com/me/stats/post/edf826196fbf" rel="noopener">类</a>。</p><p id="c981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，将介绍三个特殊的装饰者，即<code class="fe lv lw lx ly b">@staticmethod,</code> <code class="fe lv lw lx ly b">@classmethod</code>和<code class="fe lv lw lx ly b">@property</code>。这些“神奇的”装饰器可以让我们的开发工作变得非常方便，并使您的代码更加整洁。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b352" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">@静态方法</strong></h1><p id="26b0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在Python和其他编程语言中，静态方法是一种不需要创建类实例的方法。对于Python来说，意味着静态方法的第一个参数不是<code class="fe lv lw lx ly b">self</code>，而是常规的位置或关键字参数。此外，静态方法可以没有任何参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f6d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，<code class="fe lv lw lx ly b">__init__</code>是Python的一个保留方法，作为类的构造函数。<code class="fe lv lw lx ly b">get_number</code>是类的常规实例方法，需要创建一个实例。尤其是<code class="fe lv lw lx ly b">get_emergency_number</code>是一个静态方法，因为它是用<code class="fe lv lw lx ly b">@staticmethod</code>装饰器装饰的。此外，它没有将<code class="fe lv lw lx ly b">self</code>作为第一个参数，这意味着它不需要创建<code class="fe lv lw lx ly b">Cellphone</code>类的实例。实际上，<code class="fe lv lw lx ly b">get_emergency_number</code>可以作为一个独立的函数工作。然而，把它放在<code class="fe lv lw lx ly b">Cellphone</code>类中是有意义的，也是直观的，因为手机应该能够提供紧急号码。</p><p id="a185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个超级简单的例子。实际上，在实践中，如果<code class="fe lv lw lx ly b">Cellphone</code>类有一个<code class="fe lv lw lx ly b">country</code>属性，<code class="fe lv lw lx ly b">get_emergency_number</code>方法将成为一个实例方法，因为它需要访问<code class="fe lv lw lx ly b">country</code>属性来提供正确的紧急号码。然而，这个例子应该清楚什么是静态方法。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0a2e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak"> @classmethod </strong></h1><p id="78b6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在Python中，一个类方法是用<code class="fe lv lw lx ly b">@classmethod</code>装饰器创建的，并且需要类本身作为第一个参数，写为<code class="fe lv lw lx ly b">cls</code>。类方法通常作为工厂方法工作，并使用提供的参数返回类的实例。然而，它并不总是必须作为工厂类工作并返回一个实例。您可以在类方法中创建一个实例，做您需要的任何事情，而不必返回它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6ff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，<code class="fe lv lw lx ly b">iphone</code>是一个类方法，因为它是用<code class="fe lv lw lx ly b">@classmethod</code>装饰器装饰的，并且将<code class="fe lv lw lx ly b">cls </code>作为第一个参数。这里它是一个工厂方法，返回一个<code class="fe lv lw lx ly b">Cellphone</code>类的实例，并将<code class="fe lv lw lx ly b">brand </code>预设为“Apple”。</p><p id="4b93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类方法在第三方库中非常常用，例如在<em class="nf"> Scrapy </em>网络抓取框架中，它被用来<a class="ae ky" href="https://github.com/scrapy/scrapy/blob/06f3d12c1208c380f9f1a16cb36ba2dfa3c244c5/scrapy/spiders/crawl.py#L135-L139" rel="noopener ugc nofollow" target="_blank">定制一个爬虫</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="847b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<em class="nf">刺儿头</em>的情况下更复杂，但本质是一样的。在实际工作中，如果恰当地使用类方法，可以大大减少代码冗余，使代码更具可读性和专业性。要记住的关键点是，您可以基于类方法中的一些特定参数来创建类的实例。这样，您就不需要在代码的其他地方重复创建实例，从而使您的代码更加简洁。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4ac7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">@房产</strong></h1><p id="f4b4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在上面的代码片段中，有一个名为<code class="fe lv lw lx ly b">get_number</code>的函数，它返回一个<code class="fe lv lw lx ly b">Cellphone</code>实例的编号。我们可以稍微优化一下这个方法，返回一个格式化的电话号码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5404" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如我们所见，在这个例子中，当我们试图获取一个手机号码时，我们不直接返回它，而是在返回它之前做一些格式化。这是使用<code class="fe lv lw lx ly b">@property</code>装饰器的完美例子。在Python中，使用<code class="fe lv lw lx ly b">@property</code>装饰器，你可以使用<em class="nf"> getter </em>和<em class="nf"> setter </em>非常方便地管理你的类实例的属性。上面的代码可以用<code class="fe lv lw lx ly b">@propery</code>重新写成这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="efb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果我们像上面这样运行代码，就会遇到一个<code class="fe lv lw lx ly b"><strong class="lb iu">AttributeError</strong></code>，无法设置属性。原因是，如果我们已经使用<code class="fe lv lw lx ly b">@property</code>来获取属性，我们需要使用<em class="nf">设置器</em>来设置属性。让我们创建一个<em class="nf"> setter </em>，语法乍一看可能很奇怪:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e94c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这一次，我们有一个<code class="fe lv lw lx ly b"><strong class="lb iu">RecursionError</strong></code>错误。这是因为<code class="fe lv lw lx ly b">number</code> <em class="nf"> </em>属性<em class="nf"> </em>由于装饰不再是常规属性。注意，我们有两个同名的<code class="fe lv lw lx ly b">number</code>方法。<code class="fe lv lw lx ly b">self.number</code>现在是一个带有<em class="nf"> getter </em>和<em class="nf"> setter </em>的<a class="ae ky" href="https://docs.python.org/3/library/functions.html#property" rel="noopener ugc nofollow" target="_blank"> <em class="nf"> property </em> </a>对象，而不再是一个带有字符串值的实例属性。</p><p id="f1bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们需要为<em class="nf"> getter </em>和<em class="nf"> setter </em>中的“实数”使用不同的属性名。让我们引入一个下划线前缀，使其成为私有属性，避免名称冲突。实际上，使用<em class="nf"> getter </em>和<em class="nf"> setter </em>的全部意义在于，不应该直接获取和更改类实例的属性，而是通过一些逻辑来完成。在这个例子中，在<em class="nf"> getter </em>中，我们在返回数字之前对其进行格式化。在<em class="nf">设置器</em>中，我们在将数字设置为属性之前检查它是否是有效数字。让我们看看它是否适用于此更新:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">万岁，成功了！让我们试着给手机设置一个无效号码，看看会发生什么:</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="5eb7" class="nk mh it ly b gy nl nm l nn no">cellphone.number = "123"<br/># ValueError: Invalid phone number.</span></pre><p id="ec41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太棒了，它像预期的那样工作。无效号码将被拒绝。</p><p id="d05b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想知道为什么<em class="nf"> getter </em>和<em class="nf"> setter </em>的语法如此怪异，您可以通过弄清楚decorator是如何工作的来理解它。<a class="ae ky" href="https://medium.com/codex/understand-and-master-the-decorator-in-python-481aa444933f" rel="noopener">装饰器是一个特殊的函数，它返回一个装饰过的函数</a>。在这个例子中，使用了内置的<a class="ae ky" href="https://docs.python.org/3/library/functions.html#property" rel="noopener ugc nofollow" target="_blank"> <em class="nf">属性</em> </a>类。属性是一个类，尽管它是小写的。很奇怪，不是吗。但这还不是最奇怪的部分。属性类的第一个参数是一个getter。当您试图访问创建的<em class="nf">属性</em>对象时，将触发<em class="nf"> getter </em>函数，例如(<code class="fe lv lw lx ly b">cellphone.number</code>)。</p><p id="ce3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，对于本例中的<em class="nf"> getter </em>方法、<em class="nf">T37】即第一个修饰过的<code class="fe lv lw lx ly b">number</code>方法，我们将得到类似于:</em></p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="32f5" class="nk mh it ly b gy nl nm l nn no">number = property(number)</span></pre><ul class=""><li id="0a03" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">圆括号中的<code class="fe lv lw lx ly b">number</code>是被修饰的<code class="fe lv lw lx ly b">number</code>方法(<em class="nf"> getter </em>函数)。</li><li id="709b" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">左边的<code class="fe lv lw lx ly b">number</code>是由<em class="nf">属性</em>类返回的<em class="nf">属性</em>对象。</li></ul><p id="77c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<em class="nf">属性</em>对象有一个<em class="nf"> setter </em>方法，可以为<em class="nf">属性</em>对象设置<em class="nf"> setter </em>方法。因此，对于<em class="nf"> setter </em>函数，即第二个修饰过的<code class="fe lv lw lx ly b">number</code>方法，你会得到类似于:</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="5ce3" class="nk mh it ly b gy nl nm l nn no">number = number.setter(number) </span></pre><ul class=""><li id="d989" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">右边的<code class="fe lv lw lx ly b">number</code>是正在装饰的<em class="nf">设定器</em>方法<code class="fe lv lw lx ly b">number</code>。</li><li id="f622" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">中间的<code class="fe lv lw lx ly b">number</code>就是上面返回的<code class="fe lv lw lx ly b">number</code>(一个<code class="fe lv lw lx ly b">property</code>对象)，用<code class="fe lv lw lx ly b">@propery</code>装饰的那个。</li><li id="3c32" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">左边的<code class="fe lv lw lx ly b">number</code>是最终的<em class="nf">属性</em>对象，同时分配了<em class="nf"> getter </em>和<em class="nf"> setter </em>。</li></ul><p id="40bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它相当于以下形式:</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="9e4d" class="nk mh it ly b gy nl nm l nn no">number = property(number).setter(number)</span></pre><p id="9b8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看你能否弄清楚每个<code class="fe lv lw lx ly b"><strong class="lb iu">number</strong></code>是什么意思。</p><p id="1c7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">@property </code>装饰器和<em class="nf">获取器</em>和<em class="nf">设置器</em>的技术细节相当复杂，并且与Python中的<a class="ae ky" href="https://docs.python.org/3/howto/descriptor.html" rel="noopener ugc nofollow" target="_blank">描述符概念</a>相关。不要灰心，在使用之前，你不需要了解<code class="fe lv lw lx ly b">@property</code>装饰器的所有技术细节。你可以像在<code class="fe lv lw lx ly b">Cellphone</code>类中演示的那样使用它。非常简单的语法。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="15d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文用简单的例子介绍了Python中三个神奇的装饰器，即<code class="fe lv lw lx ly b">@staticmethod</code>、<code class="fe lv lw lx ly b">@classmethod</code>和<code class="fe lv lw lx ly b">@propery</code>。您现在可以开始使用它来优化您的代码，使您的代码更加专业。</p><p id="1062" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码放在这里供您参考:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div></div>    
</body>
</html>