<html>
<head>
<title>TypeORM Entity Listeners — Exploring Best Practices and Caveats</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型实体侦听器—探索最佳实践和注意事项</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typeorm-listeners-exploring-best-practices-and-caveats-5397f4bb8c11?source=collection_archive---------5-----------------------#2022-04-22">https://betterprogramming.pub/typeorm-listeners-exploring-best-practices-and-caveats-5397f4bb8c11?source=collection_archive---------5-----------------------#2022-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b232" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用钩子监听TypeORM实体中的事件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8befd520952ff4746a6cc3b48e601841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INfjPtQvb9etMGLVuS0YMw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@6heinz3r?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">加布里埃尔·海因策</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2679" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TypeORM(以及许多其他ORM)中的一个基本概念是<a class="ae kv" href="https://typeorm.io/entities" rel="noopener ugc nofollow" target="_blank">实体</a>。一个<code class="fe ls lt lu lv b">Entity</code>代表你的数据模型，它是“一个映射到数据库表(或者使用MongoDB时的集合)的类”。</p><p id="4208" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，一切都围绕着它，我们以许多不同的方式与实体互动:我们创建、更新、编辑、删除它们。通常，在我们执行其中一个操作之后(或之前)，我们需要执行一些其他操作，添加一些自定义逻辑。</p><p id="74cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它可以是像记录日志或设置一些默认值这样简单的事情，也可以是像以某种方式更新其他实体这样的事情。我们可以在我们的类(存储库、服务等)中手工编写。)这可能有点乏味。为了帮助我们完成这项任务，TypeORM为我们提供了一个非常有用的工具——实体监听器(或者我们可以称之为钩子)。</p><h1 id="0742" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">TypeORM中的实体侦听器</h1><p id="f297" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">正如TypeORM文档所述，“实体侦听器是带有定制逻辑的方法，用于侦听特定的实体事件。”实现这些监听器最简单、最直接的方法是给在<code class="fe ls lt lu lv b">Entity</code>上定义的方法添加一个特殊的装饰器。这里有一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4360" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个装饰器，每次在我们创建一个新的<code class="fe ls lt lu lv b">Author</code>之前，我们都会在上面生成一个电子邮件字段，以防没有提供</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="6d33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果需要添加比这更复杂的东西呢？例如，添加一些其他数据库调用。当我们刚刚开始使用这些钩子时(之前没有使用TypeORM的经验)，我们只是像这样在钩子内部添加了这个逻辑(不要介意实体和属性名称，它们与本文并不相关):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b96a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，这是一种错误的方法。</p><p id="ec09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们注意到，只有当我们试图在事务中使用这个实体并不断得到错误时(TypeORM文档告诉我们，我们不应该在侦听器中进行任何数据库调用，但是谁会读取文档呢，对吗？).</p><p id="a31b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近写了一篇关于在TypeORM 中使用事务的文章，其中最重要的一点是——当你在事务内部做一些事情时，你需要使用<code class="fe ls lt lu lv b">Transactional Manager</code>。</p><p id="ca7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在上面的例子中看到的，那些侦听器不知道任何关于我们的事务及其事务管理器的事情，所以所有的<code class="fe ls lt lu lv b">Insert</code>和<code class="fe ls lt lu lv b">Update</code>操作都失败了。在这一点上，我们意识到我们做错了什么，并且发现了另一种当涉及到数据库时使用实体监听器的正确方法— <code class="fe ls lt lu lv b">Subscribers</code>。</p><h1 id="3947" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">实体订户</h1><blockquote class="nc nd ne"><p id="dc0c" class="kw kx nf ky b kz la jr lb lc ld ju le ng lg lh li nh lk ll lm ni lo lp lq lr ij bi translated">订户是用@EventSubscriber() decorator标记为事件订户的类，它可以侦听特定的实体事件或任何实体事件。使用<code class="fe ls lt lu lv b">QueryBuilder</code>和存储库/管理器方法触发事件。</p></blockquote><p id="f500" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要创建一个<code class="fe ls lt lu lv b">Subscriber</code>，您需要:</p><ol class=""><li id="1a69" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated">用<code class="fe ls lt lu lv b">@EventSubscriber</code>装饰器标记这个类。</li><li id="0cd5" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">让您的类实现将您的<code class="fe ls lt lu lv b">Entity</code>类作为其类型参数的<code class="fe ls lt lu lv b">EntitySubscriberInterface&lt;T&gt;</code>。</li><li id="a64a" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">添加<code class="fe ls lt lu lv b">listenTo()</code>方法，该方法应该简单地返回您的实体类，以指定该订阅者将只监听您的实体的事件。</li><li id="1bef" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">实现您需要的事件方法。</li><li id="eb40" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">在<code class="fe ls lt lu lv b">ConnectionOptions</code>(或从TypeORM v 0.3.0开始的<code class="fe ls lt lu lv b">DataSourceOptions</code>)选项中指定您的订户，如下所示:<code class="fe ls lt lu lv b">subscribers: [ MyEntitySubscriber ]</code>。</li><li id="5c77" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">如果你需要实现一个订阅者来监听所有实体的事件，不要添加<code class="fe ls lt lu lv b">listenTo()</code>方法，也不要在<code class="fe ls lt lu lv b">EntitySubscriberInterface</code>中指定类型参数。</li></ol><p id="9d4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里阅读关于订户和事件的信息(包括他们的完整列表)。所以，让我们修正我们的代码，看看这个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d147" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，事件方法中的大部分代码保持不变，只有一个关键的区别——我们使用了<code class="fe ls lt lu lv b">event</code>对象的<code class="fe ls lt lu lv b">entity</code>和<code class="fe ls lt lu lv b">manager</code>属性。<code class="fe ls lt lu lv b">entity</code>将拥有包含我们数据的实体对象，而<code class="fe ls lt lu lv b">manager</code>(或者<code class="fe ls lt lu lv b">queryRunner</code>如果需要的话)为我们提供了一种与数据库交互的方式。</p><p id="586e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事件监听器中的所有数据库操作都是使用事件对象的<code class="fe ls lt lu lv b">queryRunner</code>或<code class="fe ls lt lu lv b">manager</code>实例来执行的，这一点非常重要。这消除了前面提到的事务问题，因为这里我们接收到了事务管理器的一个实例，并且我们没有超出事务的范围。</p><p id="7423" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇文章对您有所帮助，让您更好地理解如何使用TypeORM实体钩子(侦听器)。一如既往，我感谢您的反馈。编码快乐！</p><h2 id="1a93" class="nx lx iq bd ly ny nz dn mc oa ob dp mg lf oc od mi lj oe of mk ln og oh mm oi bi translated">更多阅读</h2><ol class=""><li id="a783" class="nj nk iq ky b kz mo lc mp lf oj lj ok ln ol lr no np nq nr bi translated"><a class="ae kv" href="https://typeorm.io/entities" rel="noopener ugc nofollow" target="_blank">实体类型文件</a></li><li id="7f96" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><a class="ae kv" href="https://typeorm.io/listeners-and-subscribers" rel="noopener ugc nofollow" target="_blank">实体监听器和订阅者的类型文档</a></li><li id="e2f6" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/handling-transactions-in-typeorm-and-nest-js-with-ease-3a417e6ab5">如何处理类型表单中的事务</a></li></ol></div></div>    
</body>
</html>