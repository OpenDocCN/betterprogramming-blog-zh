<html>
<head>
<title>Accessible UICollectionViews With Dynamic Type and Self-Sizing Cells</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有动态类型和自调整单元格大小的可访问UICollectionViews</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/accessible-uicollectionviews-with-dynamic-type-and-self-sizing-cells-b06330c14c4c?source=collection_archive---------4-----------------------#2019-08-19">https://betterprogramming.pub/accessible-uicollectionviews-with-dynamic-type-and-self-sizing-cells-b06330c14c4c?source=collection_archive---------4-----------------------#2019-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8d1e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过确保UICollectionViews随着用户文本大小首选项的更改而调整大小，使您的应用程序具有可访问性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2049ebc8d712eed7e61b0f33204d7553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VQMCprqN5OTfmSaNVleyOw.jpeg"/></div></div></figure><p id="ce18" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">动态字体是iOS 7中引入的一项功能，允许用户更改iOS中使用的默认字体大小。它主要是为了支持视障用户，但在实践中，有许多iOS用户出于各种原因只喜欢较小/较大的阅读尺寸。</em></p><p id="8e64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在iOS的后续版本中，苹果进行了大量改进，以帮助开发人员实现辅助功能。每年在<a class="ae lo" href="https://developer.apple.com/wwdc19/" rel="noopener ugc nofollow" target="_blank"> WWDC </a>上，苹果都会举办关于无障碍改进的会议，并推动开发者通过实施辅助技术来开发更具包容性的体验。例如，为VoiceOver用户提供出色体验的应用程序经常成为<a class="ae lo" href="https://developer.apple.com/design/awards/" rel="noopener ugc nofollow" target="_blank">苹果设计奖</a>的一部分。在iOS提供的所有辅助技术中，动态类型无疑是最重要的技术之一，它允许用户通过设置中的滑块来增加或减少设备上的文本大小。</p><p id="deea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管苹果推动开发包容性和可访问的体验，尽管动态类型早在iOS 7中就已经引入，但许多知名应用程序仍然缺乏对它的支持。这有许多原因:</p><ul class=""><li id="53f0" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated">缺乏对自定义字体的支持。大型组织开发的应用程序通常使用自定义字体来支持组织的视觉标识。在iOS 11中引入<code class="fe ly lz ma mb b">UIFontMetrics</code>之前，根据<code class="fe ly lz ma mb b">UIContentSizeCategory</code>中的变化缩放自定义字体是一项不小的工作量。大型组织开发的应用程序经常需要支持旧版本的iOS，这意味着他们可能无法使用<code class="fe ly lz ma mb b">UIFontMetrics</code>。</li><li id="580d" class="lp lq iq kt b ku mc kx md la me le mf li mg lm lu lv lw lx bi translated">监听文本大小的变化限制了定制。自从引入<code class="fe ly lz ma mb b">UIContentSizeCategoryAdjusting</code>协议以来，从iOS 10开始，使用<code class="fe ly lz ma mb b">UILabel</code>、<code class="fe ly lz ma mb b">UITextField</code>和<code class="fe ly lz ma mb b">UITextView</code>观察文本大小的变化变得更加容易。在这些UIKit元素上实现的协议声明了一个<code class="fe ly lz ma mb b">Bool</code>属性<code class="fe ly lz ma mb b">adjustsFontForContentSizeCategory</code>，当设置为true时，允许这些UIKit元素根据用户在设置应用程序中的文本大小偏好自动调整其文本大小。然而，缺点是该协议仅在这三个UIKit元素上实现，它不支持属性文本，并且为了使用它，您必须从11个预定义的UIFontTextStyles中选择一个，这意味着您必须使用系统字体(当前为San Francisco)和与这些样式相关联的预定字体大小。尽管人们通常对实现动态类型抱有很大的善意，但相关的约束条件(只能使用预先确定的字体和字号)往往是导致它从未被实现的因素。</li><li id="cb26" class="lp lq iq kt b ku mc kx md la me le mf li mg lm lu lv lw lx bi translated">在iOS上实现动态类型的最大挑战是确保当UIKit元素的文本大小增加时，其父视图的内容大小也增加，并且兄弟视图以一种不会使设计感觉破碎和不可用的方式布置在调整大小的视图周围。自动布局提供了实现这一点的方法，但是在选择约束时需要仔细考虑，以确保界面在更大的内容尺寸下仍然看起来很好。很容易出现自动布局需要打破约束以满足布局的情况，导致一个或多个元素以错误的大小结束，甚至出现在错误的位置。</li></ul><p id="a3b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当在UITableView或UICollectionView中显示文本内容时，我们可以使用自调整大小的单元格(在iOS 8中引入),以确保内容正确匹配，不会被挤压或截断。当单元格文本是动态的，或者当本地化一个应用程序以适应不同的语言，可能会占用不同的空间来表达相同的情感时，这也很方便。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="2830" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">自行调整大小的UITableViewCells</h1><p id="284d" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">当谈到UITableViews时，实现自调整单元格相对简单——事实上，从iOS 11开始，只要您以自动布局可以确定单元格高度的方式设置约束，那么这就是您需要做的全部工作。通常，这意味着在实现灵活的单元格高度时，通过显式设置宽度约束或设置前沿和后沿约束来确保视图具有受约束的宽度，因为如果单元格子视图可以具有无限的宽度，那么就没有办法计算单元格的高度。相反，当实现灵活的单元格宽度时，您会希望确保可以使用约束来具体确定单元格的高度。实现自调整单元格最困难的部分是确定要添加的约束条件，以便可以计算单元格的高度(或宽度)而不会产生歧义。</p><p id="ce8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您的单元格包含任何UILabel元素，那么您需要将Interface Builder中的<code class="fe ly lz ma mb b">Lines</code>属性设置为<code class="fe ly lz ma mb b">0</code>，这表示标签可以根据需要使用任意多的行来适应文本内容。您还需要将<code class="fe ly lz ma mb b">Line Break</code>属性设置为<code class="fe ly lz ma mb b">Word Wrap</code>，这样就不会截断内容，内容会换行到下一行。当以编程方式配置一个<code class="fe ly lz ma mb b">UILabel</code>时，同样的事情可以如下实现:</p><p id="93f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ly lz ma mb b">label.<a class="ae lo" href="https://developer.apple.com/documentation/uikit/uilabel/1620525-linebreakmode" rel="noopener ugc nofollow" target="_blank">lineBreakMode</a> = .byWordWrapping</code></p><p id="8306" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ly lz ma mb b">label.<a class="ae lo" href="https://developer.apple.com/documentation/uikit/uilabel/1620539-numberoflines" rel="noopener ugc nofollow" target="_blank">numberOfLines</a> = 0</code></p><p id="4d12" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您需要支持11之前的iOS版本，那么您需要将<code class="fe ly lz ma mb b">estimatedRowHeight</code>属性设置为一个值，以便启用单元格自调整。通常将该属性的值设置为<code class="fe ly lz ma mb b">44.0</code>，因为这是UITableViewCell的默认高度。苹果人机界面指南还指出，您应该尝试<a class="ae lo" href="https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/adaptivity-and-layout/#general-layout-considerations" rel="noopener ugc nofollow" target="_blank">为所有控件保持44pt x 44pt的最小可点击区域</a>。大多数教程都会建议将<code class="fe ly lz ma mb b">estimatedRowHeight</code>属性和<code class="fe ly lz ma mb b">rowHeight</code>属性设置为<code class="fe ly lz ma mb b">UITableView.automaticDimension</code>，这表示UITableView应该尝试根据单元格的约束来确定它们的高度。</p><p id="fd77" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ly lz ma mb b">tableView.estimatedRowHeight = 44.0</code></p><p id="8cee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ly lz ma mb b">tableView.rowHeight = .automaticDimension</code></p><p id="981c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实际上，应该只需要设置<code class="fe ly lz ma mb b">estimatedRowHeight</code>(在iOS 11之前),因为<code class="fe ly lz ma mb b">rowHeight</code>属性的默认值已经是<code class="fe ly lz ma mb b">automaticDimension.</code>。从<a class="ae lo" href="https://developer.apple.com/documentation/uikit/uitableview/1614925-estimatedrowheight" rel="noopener ugc nofollow" target="_blank">苹果开发者文档</a>中还可以注意到以下关于<code class="fe ly lz ma mb b">estimatedRowHeight</code>的内容:</p><blockquote class="nl nm nn"><p id="c23f" class="kr ks ln kt b ku kv jr kw kx ky ju kz no lb lc ld np lf lg lh nq lj lk ll lm ij bi translated">默认值是<code class="fe ly lz ma mb b"><a class="ae lo" href="https://developer.apple.com/documentation/uikit/uitableview/1614961-automaticdimension" rel="noopener ugc nofollow" target="_blank">automaticDimension</a></code>，这意味着表格视图选择一个代表您的估计高度。将该值设置为<code class="fe ly lz ma mb b">0</code>会禁用估计高度，这会导致表格视图请求每个单元格的实际高度。如果您的表格使用自行调整大小的单元格，则该属性的值不得为<code class="fe ly lz ma mb b">0</code>。</p></blockquote><p id="6ba0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您只需要调整某些单元格的大小，那么您可以在<code class="fe ly lz ma mb b">UITableViewDelegate</code>中实现<code class="fe ly lz ma mb b"><a class="ae lo" href="https://developer.apple.com/documentation/uikit/uitableviewdelegate/1614998-tableview" rel="noopener ugc nofollow" target="_blank">tableView(_:heightForRowAt:)</a></code>，只为您希望调整大小的单元格返回<code class="fe ly lz ma mb b">automaticDimension</code>。您还可以为<code class="fe ly lz ma mb b"><a class="ae lo" href="https://developer.apple.com/documentation/uikit/uitableviewdelegate/1614926-tableview" rel="noopener ugc nofollow" target="_blank">tableView(_:estimatedHeightForRowAt:)</a></code>提供一个实现，以便为每个单元格返回不同的估计行高。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="51af" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">自行调整UICollectionView单元格的大小</h1><p id="2f93" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">实现自调整大小的UICollectionViewCells稍微复杂一些，但遵循的模式基本相同。我们需要配置单元格的约束，以便UICollectionView布局可以代表我们确定单元格的高度。提供的<code class="fe ly lz ma mb b">UICollectionViewLayout</code>是在网格中布局单元格的<code class="fe ly lz ma mb b"><a class="ae lo" href="https://developer.apple.com/documentation/uikit/uicollectionviewflowlayout" rel="noopener ugc nofollow" target="_blank">UICollectionViewFlowLayout</a></code>，具有<code class="fe ly lz ma mb b">itemSize</code>属性和<code class="fe ly lz ma mb b">estimatedItemSize</code>属性。我们可以将<code class="fe ly lz ma mb b">itemSize</code>属性设置为一个CGSize值(默认值为<code class="fe ly lz ma mb b">(50.0, 50.0)</code>)，但是这将导致所有单元格具有相同的尺寸。为布局提供项目大小的另一种方法是实现可选的委托方法<code class="fe ly lz ma mb b"><a class="ae lo" href="https://developer.apple.com/documentation/uikit/uicollectionviewdelegateflowlayout/1617708-collectionview" rel="noopener ugc nofollow" target="_blank">collectionView(_:layout:sizeForItemAt:)</a></code>。</p><p id="6555" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在此方法的实现中，您可以基于每个单元格计算所提供的IndexPath的单元格的CGSize，这意味着单元格可以具有不同的大小。这包括计算UIKit子视图(标签、图像等)的宽度和高度。)在细胞内。使用NSString方法<code class="fe ly lz ma mb b"><a class="ae lo" href="https://developer.apple.com/documentation/foundation/nsstring/1524729-boundingrect" rel="noopener ugc nofollow" target="_blank">boundingRect(with:options:attributes:context:)</a>.</code>可以计算UILabel中文本的高度</p><p id="0e21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe ly lz ma mb b">intrinsicContentSize</code>属性可以获得图像的高度。如果你的视图以水平或垂直的方式排列在一个堆栈中，那么UIStackView可以让你的工作变得更加轻松。通过将视图添加为UIStackView的排列子视图，您可以访问堆栈视图的<code class="fe ly lz ma mb b">intrinsicContentSize</code>属性，以确定其高度。</p><p id="a66d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您的UICollectionViewCell包含任何UILabel元素，请记住设置<code class="fe ly lz ma mb b">numberOfLines</code>属性和<code class="fe ly lz ma mb b">lineBreakMode</code>作为表格视图单元格，以确保文本换行和标签能够随着文本内容的增加而增加高度。</p><p id="bfbc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用前面提到的方法，我们可以通过允许我们的单元格具有单独的大小并根据其内容改变高度来支持动态类型，但是单元格还不能自我调整大小。要启用自调整单元格大小，我们需要通过设置UICollectionViewFlowLayout上的<code class="fe ly lz ma mb b">estimatedItemSize</code>属性来提供一个非零的单元格大小估计值。</p><blockquote class="nl nm nn"><p id="6d45" class="kr ks ln kt b ku kv jr kw kx ky ju kz no lb lc ld np lf lg lh nq lj lk ll lm ij bi translated">该属性的默认值是<code class="fe ly lz ma mb b"><a class="ae lo" href="https://developer.apple.com/documentation/coregraphics/cgsizezero" rel="noopener ugc nofollow" target="_blank">CGSizeZero</a></code>。将它设置为任何其他值都会导致集合视图使用单元格的<code class="fe ly lz ma mb b"><a class="ae lo" href="https://developer.apple.com/documentation/uikit/uicollectionreusableview/1620132-preferredlayoutattributesfitting" rel="noopener ugc nofollow" target="_blank">preferredLayoutAttributesFitting(_:)</a></code>方法查询每个单元格的实际大小。</p></blockquote><p id="297a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在iOS 10之前，需要将<code class="fe ly lz ma mb b">itemSize</code>属性设置为<code class="fe ly lz ma mb b">UICollectionViewFlowLayout.automaticSize</code>并将<code class="fe ly lz ma mb b">estimatedItemSize</code>设置为一个估计值，以尽可能精确地确定小区的大小。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c261" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从iOS 10开始，我们只需要将<code class="fe ly lz ma mb b">estimatedItemSize</code>属性设置为<code class="fe ly lz ma mb b">UICollectionViewFlowLayout.automaticSize</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="94cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果在nib或故事板中定义您的集合视图，您可能希望为您的UICollectionViewLayout创建一个出口，然后利用<code class="fe ly lz ma mb b">didSet</code>观察器来设置<code class="fe ly lz ma mb b">estimatedItemSize</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3629" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦布局意识到它应该尝试根据单元格的约束自动调整单元格的大小，接下来我们需要做的就是在单元格的内容视图中禁用自动调整大小的掩码。</p><p id="3389" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在引入Auto Layout之前，iOS使用了一个名为<em class="ln"> springs和struts </em>的系统来确定UIView的框架如何根据其superview的框架变化进行更新。弹簧代表UIView的宽度和高度如何拉伸或压缩，而支柱代表UIView从其超级视图和相邻视图的插入。本质上，springs允许子视图随着其超级视图的增大而增大，而struts允许从兄弟视图和父视图定义一致的边距。</p><p id="bba0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个<a class="ae lo" href="https://developer.apple.com/documentation/uikit/uiview/1622559-autoresizingmask" rel="noopener ugc nofollow" target="_blank">自动调整大小掩码</a>是一个整数位掩码，代表一个视图的弹簧和支柱。当引入自动布局时，为了保持与旧的springs和struts系统的向后兼容性，默认情况下，UIView的自动调整大小掩码被转换为约束。不幸的是，视图的弹簧和支柱到约束的自动转换并不总是给出想要的结果，因此一种禁用自动转换的方法以名为<code class="fe ly lz ma mb b">translatesAutoresizingMaskIntoConstraints</code>的属性的形式存在。如果设置为<code class="fe ly lz ma mb b">false</code>，那么视图的自动调整大小遮罩将不再被转换为自动布局约束。</p><p id="9a41" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据<code class="fe ly lz ma mb b"><a class="ae lo" href="https://developer.apple.com/documentation/uikit/uiview/1622572-translatesautoresizingmaskintoco" rel="noopener ugc nofollow" target="_blank">translatesAutoresizingMaskIntoConstraints</a>:</code>的文档</p><blockquote class="nl nm nn"><p id="c1e0" class="kr ks ln kt b ku kv jr kw kx ky ju kz no lb lc ld np lf lg lh nq lj lk ll lm ij bi translated">请注意，自动调整大小掩码约束完全指定了视图的大小和位置；因此，如果不引入冲突，就无法添加额外的约束来修改此大小或位置。如果您想使用自动布局来动态计算视图的大小和位置，您必须将该属性设置为<code class="fe ly lz ma mb b">false</code>，然后为视图提供一组明确、无冲突的约束。</p></blockquote><p id="2dbd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所有集合视图单元格都有一个名为内容视图的子视图，您的标签、图像视图等都显示在内容视图中。已添加。不幸的是，默认情况下，内容视图的自动调整大小掩码被转换为约束，并且当这种情况发生时，由于作为具体指定视图大小的转换的一部分而添加的约束，内容视图的尺寸可能不再调整大小。因此，为了允许我们的单元格自行调整大小，我们需要禁用自动调整大小掩码的转换，并添加我们自己的约束，以便指定单元格内容视图在单元格内的大小和位置，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7d4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以上将禁用约束转换，并添加新的约束，以在从故事板或nib展开单元时将内容视图的每个边缘固定到父单元的相应边缘。如果你以编程方式实例化一个单元，那么你可能希望在单元的初始化器中这样做。</p><p id="2fbe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只要您在单元格的内容视图及其子视图中提供了足够的约束，以允许AutoLayout系统确定单元格的高度(或宽度，如果您正在水平调整大小)，那么您的单元格现在应该会自动调整大小。</p><p id="72d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果布局不尽如人意，UICollectionViewCell子类可以通过提供方法<code class="fe ly lz ma mb b">preferredLayoutAttributesFitting(_:)</code>的实现来修改其布局属性。</p><blockquote class="nl nm nn"><p id="8778" class="kr ks ln kt b ku kv jr kw kx ky ju kz no lb lc ld np lf lg lh nq lj lk ll lm ij bi translated">此方法的默认实现调整大小值，以适应自调整大小单元格所做的更改。子类可以覆盖这个方法，并使用它来调整其他布局属性。如果您覆盖这个方法并想要调整单元格大小，首先调用<code class="fe ly lz ma mb b">super</code>并对返回的属性进行自己的修改。</p></blockquote><p id="6cf0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，通过将实现作为UICollectionViewCell子类的一部分提供，您可以在UICollectionView将布局属性用于布局单元格之前，调整由集合视图布局创建的布局属性，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f5cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的例子中，我们指出需要通过调用<code class="fe ly lz ma mb b">setNeedsLayout()</code>然后调用<code class="fe ly lz ma mb b">layoutIfNeeded()</code>来布局单元格，以便根据对它们定义的约束来定位内容视图的子视图。</p><p id="0806" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">单元格布局正确后，我们调用<code class="fe ly lz ma mb b">systemLayoutSizeFitting(_:)</code>来确定单元格的最佳大小，它尽可能接近我们作为参数传递给该方法的大小(在本例中，我们传递的大小是由布局返回的大小— UICollectionViewFlowLayout ),同时仍然满足单元格子视图的所有约束。值得注意的是，也可以分别使用<code class="fe ly lz ma mb b"><a class="ae lo" href="https://developer.apple.com/documentation/uikit/uiview/1622568-layoutfittingcompressedsize" rel="noopener ugc nofollow" target="_blank">layoutFittingCompressedSize</a></code>或<code class="fe ly lz ma mb b"><a class="ae lo" href="https://developer.apple.com/documentation/uikit/uiview/1622532-layoutfittingexpandedsize" rel="noopener ugc nofollow" target="_blank">layoutFittingExpandedSize</a></code>获得满足单元格约束的最小尺寸或最大尺寸，例如</p><pre class="kg kh ki kj gt nt mb nu nv aw nw bi"><span id="af6f" class="nx mp iq mb b gy ny nz l oa ob">let size = contentView.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize)</span></pre><p id="d4a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只有在单元格内定义的约束没有提供足够的信息来允许AutoLayout明确计算单元格的高度/宽度时，才需要调整单元格的布局属性。有时候，为那些支持旧版本的iOS的用户提供一个<code class="fe ly lz ma mb b">preferredLayoutAttributesFitting(_:)</code>的实现可能会很有用，因为旧版本的iOS可能会有布局上的问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/16f5481a3451a83bc3899cea8349d3b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*9Kt8stBsqsP5am-t-OHVyg.png"/></div><p class="od oe gj gh gi of og bd b be z dk translated">UICollectionViewFlowLayout中的自调整单元格大小导致同一行中的单元格大小不同。</p></figure><p id="c2f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">单元格现在应该根据其内容的大小自动调整大小。在上面的截图中，我为每个单元格的内容视图添加了背景色，这样就可以看到每个单元格的高度根据其中包含的文本量进行了调整。</p><p id="8ecf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每个单元格都有背景色或边框，但是你可能会注意到事情看起来有点奇怪。尽管每个单元格都根据其内容自行调整大小，但这些单元格与其同一行中的相邻单元格大小不同，这看起来很不协调。</p><p id="6bed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决这个问题，我们可以使用名为<a class="ae lo" href="https://github.com/rwbutler/FlexibleRowHeightGridLayout" rel="noopener ugc nofollow" target="_blank">FlexibleRowHeightGridLayout</a>的开源UICollectionViewLayout。它的目的很大程度上像一个流布局，除了每一行的大小适合该行中最高的单元格，以便您最终得到适合其内容的真正的网格，而不是上面显示的不和谐的表示。使用FlexibleRowHeightGridLayout，我们可以获得更好看的网格，如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/60fd5dcac448cf650dd614e54c134abc.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*lQdilTDES-COHsovoHOp4A.png"/></div><p class="od oe gj gh gi of og bd b be z dk translated">FlexibleRowHeightGridLayout中的单元格，其中所有行都适合其内容。</p></figure><p id="1053" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种布局也是专门为支持动态类型而创建的，因此当用户在设置应用程序中调整他们的文本大小偏好时，这种布局会自动重新布局其内容，以适应新的文本大小偏好，这与UICollectionViewFlowLayout不同。</p><h2 id="86bc" class="nx mp iq bd mq oh oi dn mu oj ok dp my la ol om na le on oo nc li op oq ne or bi translated">FlexibleRowHeightGridLayout</h2><p id="d624" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">就像UICollectionViewFlowLayout一样，FlexibleRowHeightGridLayout设计用于在网格中布局单元格，也像UICollectionViewFlowLayout一样，它支持节页眉和页脚。利用它相对简单，包括两个步骤:</p><ul class=""><li id="817e" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated">实例化布局并将其分配给UICollectionView的<code class="fe ly lz ma mb b">collectionViewLayout</code>属性。</li><li id="a825" class="lp lq iq kt b ku mc kx md la me le mf li mg lm lu lv lw lx bi translated">实现布局的委托flexiblerowheightgridlayout . delegate。</li></ul><p id="264c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果以编程方式创建UICollectionView，则可以同时实例化布局，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d3da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">否则，如果您的UICollectionView是从故事板或XIB实例化的，那么只需将布局分配给UICollectionView的<code class="fe ly lz ma mb b">collectionViewLayout</code>属性:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="130b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果上面的代码被添加到你的UIViewController的<code class="fe ly lz ma mb b">viewDidLoad</code>实现中，那么这就是你所需要的。但是，如果您在数据加载后将布局分配给UICollectionView，那么您可能需要调用UICollectionView上的<code class="fe ly lz ma mb b">invalidateLayout</code>,以确保布局被UICollectionView查询到新的布局属性。如果底层数据也发生了变化，那么您可能需要调用<code class="fe ly lz ma mb b">reloadData</code>。</p><p id="960a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二步涉及实现布局的delegate-flexiblerowheightgridlayout . delegate。如果您对UICollectionView中的页眉或页脚不感兴趣，那么只需要实现两个方法:</p><ul class=""><li id="7c39" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated"><code class="fe ly lz ma mb b">func collectionView(_ collectionView: UICollectionView, layout: FlexibleRowHeightGridLayout, heightForItemAt indexPath: IndexPath) -&gt; CGFloat</code></li><li id="a085" class="lp lq iq kt b ku mc kx md la me le mf li mg lm lu lv lw lx bi translated"><code class="fe ly lz ma mb b">func numberOfColumns(for size: CGSize) -&gt; Int</code></li></ul><p id="519f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了正确布局UICollectionViewCells，布局需要两条信息。首先，它需要知道每个单元格中的内容有多高——使用这些信息，布局就能够确定每行的高度。其次，布局需要知道您的网格应该有多少列——允许布局确定每个单元格的可用宽度。当设备方向是横向而不是纵向时，您可能希望您的布局具有不同的列数，因此，每当设备方向发生变化时，都会调用此委托方法。</p><p id="33a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了帮助您确定内容的高度，FlexibleRowHeightGridLayout提供了一些有用的方法，比如<code class="fe ly lz ma mb b">textHeight(_ text: String, font: UIFont)</code>，来帮助您计算显示使用指定字体呈现的<code class="fe ly lz ma mb b">String </code>所需的高度。如果您的单元格包含一个固定到单元格的内容视图的每个边缘的标签，则单元格内容的高度可以很容易地计算如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="af8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些助手方法对于已经在使用<a class="ae lo" href="https://github.com/rwbutler/typographykit" rel="noopener ugc nofollow" target="_blank">排版工具</a>的开发人员特别有用。如果您对它不熟悉的话，那么TypographyKit是一个框架，它也支持动态类型，当用户在他们的设备上更改文本大小首选项时，它会自动更新UIKit元素(UILabel、UIButton等)上的文本大小，并且允许开发人员在可以远程更新的JSON配置文件中定义他们的应用程序所需的所有文本和颜色样式。更多信息见我之前的帖子<a class="ae lo" href="https://medium.com/@rwbutler/dynamic-type-in-ios-with-typographykit-9ed0ac5dbf64" rel="noopener"><em class="ln">iOS上的动态类型带排版字体</em> </a>。对于那些已经熟悉字体大小的人来说，计算包含单个标签的单元格的高度可以按如下方式实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4a8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">或者，如果您的单元格是在nib中定义的，则可以膨胀单元格以计算单元格高度，尽管这是一个开销更大的操作，因为它涉及到从文件中读取:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9872" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您还希望在您的<code class="fe ly lz ma mb b">UICollectionView</code>中包含页眉和/或页脚，那么还有两个委托方法需要根据需要实现:</p><ul class=""><li id="838a" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated"><code class="fe ly lz ma mb b">@objc optional func collectionView(_ collectionView: UICollectionView, layout: FlexibleRowHeightGridLayout, referenceHeightForHeaderInSection section: Int) -&gt; CGFloat</code></li><li id="6f39" class="lp lq iq kt b ku mc kx md la me le mf li mg lm lu lv lw lx bi translated"><code class="fe ly lz ma mb b">@objc optional func collectionView(_ collectionView: UICollectionView, layout: FlexibleRowHeightGridLayout, referenceHeightForFooterInSection section: Int) -&gt; CGFloat</code></li></ul><p id="ef62" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些方法查询您的布局中<code class="fe ly lz ma mb b">UICollectionView</code>每一部分的页眉/页脚的高度。如果您从这些方法中的任何一个返回一个高度<code class="fe ly lz ma mb b">0</code>，那么将不会添加页眉/页脚。</p><p id="eb02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完整的演示可以在项目的<a class="ae lo" href="https://github.com/rwbutler/flexiblerowheightgridlayout" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中作为示例应用的一部分找到。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="4380" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">摘要</h1><p id="2199" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">使用自调整大小的单元格有助于我们适应内容大小的变化，特别是支持动态类型的文本大小的变化。这有助于我们开发对所有人都更容易访问和包容的应用程序。虽然用UITableView实现自调整单元格总体上要容易一些，但是对于UITableViews和UICollectionViews来说，这个过程基本上是相同的——特别是在iOS的最新版本上。无论使用哪种方法，实现单元格自动调整大小都需要一些技巧，例如选择约束来明确地布局单元格内容，以便自动布局能够确定单元格的高度。</p><p id="e8c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为UICollectionView提供的默认UICollectionViewLayout是UICollectionViewFlowLayout，它使用可选的节页眉和页脚在网格中布局内容，但是这可能会导致行中的内容不对齐，因为每个单元格可能具有不同的高度。</p><p id="ca82" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">FlexibleRowHeightGridLayout 是一个开源的UICollectionViewLayout，它被设计用来在一个带有页眉和页脚的网格中布局内容，就像UICollectionViewFlowLayout一样，并且支持动态类型。在这种布局中，行高是灵活的，即每一行可以具有不同的高度，由此行高由该行中最高的单元格确定，从而行高将总是适合该行中的内容。该布局还设计为随着设备上文本大小的变化(UIContentSizeCategory)或设备方向的变化而自动重新布局。</p><p id="076e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过根据文本大小的变化自动调整UIKit元素的大小，以及允许开发人员在可远程更新的配置文件中定义文本样式，排版工具支持动态类型。FlexibleRowHeightGridLayout通过提供助手方法来帮助开发人员计算特定排版样式的文本高度，对于已经在使用排版工具的开发人员特别有用。</p><p id="8432" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如需更多指导，请查看<a class="ae lo" href="https://github.com/rwbutler/FlexibleRowHeightGridLayout#exampleapp" rel="noopener ugc nofollow" target="_blank"> GitHub </a>资源库中随FlexibleRowHeightGridLayout提供的示例应用程序。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="037b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae lo" href="https://github.com/rwbutler/flexiblerowheightgridlayout" rel="noopener ugc nofollow" target="_blank"><em class="ln">FlexibleRowHeightGridLayout</em></a><em class="ln">和</em> <a class="ae lo" href="https://github.com/rwbutler/TypographyKit" rel="noopener ugc nofollow" target="_blank"> <em class="ln">印刷体Kit </em> </a> <em class="ln">都可以在MIT许可下的</em><a class="ae lo" href="https://github.com/rwbutler/flexiblerowheightgridlayout" rel="noopener ugc nofollow" target="_blank"><em class="ln">GitHub</em></a><em class="ln">上找到，并且都兼容</em><a class="ae lo" href="https://cocoapods.org/pods/FlexibleRowHeighgtGridLayout" rel="noopener ugc nofollow" target="_blank"><em class="ln">Cocoapods</em></a><em class="ln">和Carthage。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/054487a2df2e6d8dc0ba6c4bce6175f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*CyLL3_p34GO5YkIQj_ltHA.png"/></div></figure></div></div>    
</body>
</html>