<html>
<head>
<title>Model Separation: Parsing With Codable and Persisting With Core Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模型分离:用可编码数据解析，用核心数据持久化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/model-separation-parsing-with-codable-and-persisting-with-core-data-3803c0614176?source=collection_archive---------5-----------------------#2022-01-03">https://betterprogramming.pub/model-separation-parsing-with-codable-and-persisting-with-core-data-3803c0614176?source=collection_archive---------5-----------------------#2022-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7cc4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将核心数据中的<em class="kf">域模型</em>与<em class="kf">持久性模型</em>分开，以获得更好的可测试性</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/f9734433e97cb428a5b74c7e84788cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PA-GlouKeMf5j8vIF-Qntw.jpeg"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">迈克·肯尼利在<a class="ae kw" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="cab6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">距离我上一篇关于核心数据的文章已经有一段时间了。而且，正如经常发生的那样，我解决问题的方法也发生了变化(希望是更好的变化)。所以，我决定写下我改变了什么，为什么。</p><h1 id="0649" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">将领域模型与持久性模型分离开来</h1><p id="c33d" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">在过去两年中，我所做的主要改变是将<em class="mq">领域模型</em>与<em class="mq">持久性模型</em>分开。这一选择背后有几个原因。</p><p id="4b0f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">首先，这有助于更好地分离关注点。<em class="mq">领域模型</em>由API定义，用JSON表示。这意味着我们可以只使用准系统结构来表示API返回的实体。相反，<em class="mq">持久模型</em>严重依赖于所选择的特定持久存储。在我们的例子中，选择的持久存储是核心数据，出于本文的目的，我们可以将其视为SQLite数据库之上的一个<a class="ae kw" href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" rel="noopener ugc nofollow" target="_blank"> ORM </a>层。当然，我们希望确保在代表同一个实体的<em class="mq">域模型</em>和<em class="mq">持久性模型</em>之间有1:1的关系。</p><p id="da65" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">此外，这种分离允许我们在某种程度上独立地改变每种表示。例如，我们可以改变核心数据中持久化的实体的细节，而不必触及相应的<em class="mq">域模型</em>表示。这可能是有用的，例如，如果我们想为我们的<em class="mq">持久性模型</em>使用除JSON中的原始类型(<code class="fe mr ms mt mu b">bool</code>、<code class="fe mr ms mt mu b">number</code>、<code class="fe mr ms mt mu b">string</code>)之外的特殊类型。然而，另一方面，由于需要遵循一些API更新，模型表示通常会发生变化。</p><p id="f732" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">模型分离的第二个重要优势是更好的可测试性。保持<em class="mq">域模型</em>与<em class="mq">持久性模型</em>的分离允许我们独立于持久性逻辑测试解析逻辑。</p><p id="7bfc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们看看如何将模型分离应用到我之前的<a class="ae kw" href="https://andrea-prearo.github.io/ios/mobile%20app%20development/swift/core%20data/codable/2018/05/07/Working-with-Codable-and-Core-Data.html" rel="noopener ugc nofollow" target="_blank">帖子</a>中的<code class="fe mr ms mt mu b"><a class="ae kw" href="https://gist.github.com/andrea-prearo/5d9aa5c59ed80ef454d121825f4e17d0#file-coredatacodable-9-swift" rel="noopener ugc nofollow" target="_blank">User</a></code> <a class="ae kw" href="https://gist.github.com/andrea-prearo/5d9aa5c59ed80ef454d121825f4e17d0#file-coredatacodable-9-swift" rel="noopener ugc nofollow" target="_blank">类</a>。</p><h1 id="d2db" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">域模型处理:用户和代码</h1><p id="46d6" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">由于<em class="mq">域模型</em>将仅用于表示API实体，我们可以将其实现为一个简单的<code class="fe mr ms mt mu b">Codable struct</code>:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="ac28" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">持久性模型处理:UserManagedObject和核心数据</h1><p id="8371" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">因为我们将使用核心数据，所以<em class="mq">持久性模型</em>需要从<code class="fe mr ms mt mu b">NSManagedObject</code>继承:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="91d6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，由于只有几个有效的角色，我们可以通过将它们封装到一个<code class="fe mr ms mt mu b">UserRole</code> enum中来更容易地处理它们:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="35c8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">注意:使用核心数据特定功能可能有不同的方法来实现这一点。但我个人更喜欢用更程序化的方法来转变价值观。</p><h1 id="cbc8" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">跨域和持久性模型的转换</h1><p id="71ef" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">主要有两种情况需要我们跨<em class="mq">域</em>和<em class="mq">持久化</em>模型进行转换:</p><ul class=""><li id="5909" class="mx my iq kz b la lb ld le lg mz lk na lo nb ls nc nd ne nf bi translated"><strong class="kz ir">从API中检索数据并将其持久化到核心数据中</strong>:在这种情况下，我们将在解析JSON响应内容时创建<em class="mq">域</em>对象，然后将它们转换成相应的<em class="mq">持久化</em>对象(<code class="fe mr ms mt mu b">User</code> - &gt; <code class="fe mr ms mt mu b">UserManagedObject</code>)</li><li id="ea66" class="mx my iq kz b la ng ld nh lg ni lk nj lo nk ls nc nd ne nf bi translated"><strong class="kz ir">上传核心数据更新到后端</strong>:如果我们已经更新了<em class="mq">持久性</em>对象，我们可能需要通过API(通常通过<code class="fe mr ms mt mu b">PUT</code>调用)将这些更新传递到后端。这需要将一个或多个现有的<em class="mq">持久性</em>对象转换成它们对应的<em class="mq">域</em>对象，这些对象可以由API ( <code class="fe mr ms mt mu b">UserManagedObject</code> - &gt; <code class="fe mr ms mt mu b">User</code>)处理。</li></ul><p id="7687" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因为我总是发现通过一个接口来表达需求是很有用的，所以我决定创建一些协议来实现这个目的。</p><h1 id="8223" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">从域转换到持久性模型:ManagedObjectConvertible</h1><p id="17dc" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">为了表达能够从<em class="mq">域模型</em>转换到<code class="fe mr ms mt mu b"><em class="mq">persistence</em></code> <em class="mq">模型</em>的需求，我们可以依赖于<code class="fe mr ms mt mu b">ManagedObjectConvertible</code>协议:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6028" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，要将一个<code class="fe mr ms mt mu b">User</code>对象转换成它对应的<code class="fe mr ms mt mu b">UserManagedObject</code>对象，我们只需要遵守<code class="fe mr ms mt mu b">ManagedObjectConvertible</code>协议:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b39c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">上面的代码只是创建适当类型的核心数据实体，并从当前的<code class="fe mr ms mt mu b">User</code>对象中分配它的属性值。</p><p id="d5ea" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">关于<code class="fe mr ms mt mu b">context</code> ( <code class="fe mr ms mt mu b">NSManagedObjectContext</code>)参数有一个简单的说明:由于该方法正在创建一个新的核心数据对象，我们在调用它时使用的<code class="fe mr ms mt mu b">context</code>应该是能够写入核心数据的适当上下文。</p><p id="8e9e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">特别是，它必须支持从后台线程写入核心数据的主上下文。</p><h1 id="f42c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">从持久性到域模型的转换:ModelConvertible</h1><p id="a019" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">与我们在前面的转换中看到的类似，为了表达能够从<em class="mq">持久性模型</em>转换到<em class="mq">域模型</em>的需求，我们可以依赖<code class="fe mr ms mt mu b">ModelConvertible</code>协议:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="657d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要将一个<code class="fe mr ms mt mu b">UserManagedObject</code>对象转换成其对应的<code class="fe mr ms mt mu b">User</code>对象，我们只需要遵守<code class="fe mr ms mt mu b">ModelConvertible</code>协议:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="0f1a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">解析JSON响应并将用户存储在核心数据中</h1><p id="e91c" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">既然我们已经将<em class="mq">域模型</em>与<em class="mq">持久模型</em>完全分离，那么让我们看看如何重构现有的<code class="fe mr ms mt mu b"><a class="ae kw" href="https://gist.github.com/andrea-prearo/c5bfc26cb927f0e7ad8c46e1cd7bda7b#file-coredatacodable-2-swift" rel="noopener ugc nofollow" target="_blank">UserController</a></code>(它负责从API中检索用户的数据，并将其持久化到核心数据中)。所需的更改相当简单:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d62b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如前所述，我们只需要确保在调用<code class="fe mr ms mt mu b">toManagedObject</code>方法时使用合适的上下文(支持从后台线程写入核心数据主上下文的上下文)。</p><h1 id="0059" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="71f2" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">在这篇文章中，我展示了我最近在处理核心数据时将<em class="mq">域模型</em>与<em class="mq">持久性模型</em>分离的方法。这应该允许更好地分离关注点并增强可测试性。</p><p id="2e3e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">更新后的代码可在<a class="ae kw" href="https://github.com/andrea-prearo/SwiftExamples/tree/master/CoreDataCodable" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="7c54" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">正如这篇文章中简要提到的，处理核心数据可能很棘手。尤其是当试图利用后台线程或队列与之交互时。在下一篇文章中，我将描述一些我发现对处理核心数据粗糙边缘有用的方法。</p></div></div>    
</body>
</html>