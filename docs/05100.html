<html>
<head>
<title>Element vs. ReactElement vs. HTMLElement vs. Node Confusion in TypeScript and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript和React中的元素与ReactElement和html元素与节点混淆</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typescript-reactjs-the-element-vs-reactelement-vs-htmlelement-vs-node-confusion-6cda21315ddd?source=collection_archive---------1-----------------------#2020-06-09">https://betterprogramming.pub/typescript-reactjs-the-element-vs-reactelement-vs-htmlelement-vs-node-confusion-6cda21315ddd?source=collection_archive---------1-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bb6a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它可能在过去发生在你身上，不太明白你应该使用哪一个</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8b8c7c6e1bdd3108695e8374d36887ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*APn_H3l9mvJJ_OYp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@amit_lahav?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿米特·拉哈夫</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript的一个重要特性是在键入变量时可以达到的特异性水平。您可以将数组定义为字符串、数字或它们的组合的集合，但是您也可以将元素定义为<code class="fe lv lw lx ly b">HTMLInputElement </code>或<code class="fe lv lw lx ly b">HTMLSelectElement</code>。然而，在开始时，指定变量类型粒度的容易程度会导致很多混乱。</p><p id="279e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我见过程序员更不一致的一个领域是在输入HTML元素时，尤其是在使用React时。公平地说，当您考虑您拥有的大量可能性时，尤其是当您开始使用TypeScript时，这有点令人不安。</p><p id="47b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，让我们试着去揭开何时使用它们的神秘面纱。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="457c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">定义</h1><p id="4fca" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先，让我们来定义这些术语:</p><h2 id="1024" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">节点类型</h2><p id="2539" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">节点类型由<a class="ae ky" href="https://github.com/microsoft/TypeScript/blob/master/lib/lib.dom.d.ts" rel="noopener ugc nofollow" target="_blank">本库定义</a>中的TypeScript定义。这个接口是大多数DOM元素的基本祖先。Select Options、div或HTML表单等元素继承自节点<strong class="lb iu">。</strong></p><p id="57f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从源代码文档中:</p><blockquote class="np nq nr"><p id="fc3e" class="kz la ns lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated">节点是一个接口，许多<strong class="lb iu"> DOM </strong> API对象类型从该接口继承。它允许那些<strong class="lb iu">类型被类似地对待</strong>；比如继承同一套方法，或者用同样的方式测试。”</p></blockquote><p id="64d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Node中的其他实现中，您将看到<code class="fe lv lw lx ly b">nodeName</code>(一个只读字符串)、<code class="fe lv lw lx ly b">childNodes</code>(一个ChildNode类型元素的只读列表)，以及许多其他用于操作节点的常用属性和方法。</p><h2 id="b855" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">元素类型</h2><p id="27a3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">元素类型继承了节点类型。这是在TypeScript的标准DOM类型集中定义的(你可以<a class="ae ky" href="https://github.com/microsoft/TypeScript/blob/master/lib/lib.dom.d.ts" rel="noopener ugc nofollow" target="_blank">在这里</a>查看)。根据源代码中的文档:</p><blockquote class="np nq nr"><p id="b368" class="kz la ns lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated">"元素是最通用的<strong class="lb iu">基类</strong>，文档<strong class="lb iu">中的所有对象都从它继承。"</strong></p></blockquote><p id="bdfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个亮点是我自己的，我认为它们说明了这种类型是关于什么的:最终将出现在文档对象模型中的对象的基类。</p><p id="4263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，元素类型源代码的文档说明如下:</p><blockquote class="np nq nr"><p id="b8f7" class="kz la ns lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated">“它只有各种元素共有的方法和属性。更多特定的类继承自元素。</p></blockquote><p id="79f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是最通用的类型，仅次于节点类型。其他类型将从它继承。在这里，您会发现有用的方法，比如<code class="fe lv lw lx ly b">getElementsByClassName</code>方法(它返回元素的集合)，或者属性，比如<code class="fe lv lw lx ly b">className</code>(字符串)。</p><h2 id="c805" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">html元素类型</h2><p id="eea2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这个接口实际上定义并继承了任何以HTML标签结束的元素。这不包括React的自定义标签。因此，例如，如果您有一个<code class="fe lv lw lx ly b">&lt;MainHeader /&gt;</code> React组件，它将不会从<code class="fe lv lw lx ly b">HTMLElement</code>继承。根据TypeScriptLang.org的说法，<code class="fe lv lw lx ly b">HTMLElement</code>是“打字稿中DOM操作的中坚力量”。</p><p id="c71c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直接来自TypeScript源代码:</p><blockquote class="np nq nr"><p id="f542" class="kz la ns lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated">“任何HTML元素。有些元素直接实现这个接口，有些则通过继承它的接口实现。</p></blockquote><p id="d2f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">HTMLElement</code>将直接从元素类型中继承。</p><p id="7294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">HTMLElement</code>类型中，你会看到常见的有用方法，如<code class="fe lv lw lx ly b">addEventListener</code>或<code class="fe lv lw lx ly b">removeEventListener</code>(显然与<code class="fe lv lw lx ly b">Events</code>)、<code class="fe lv lw lx ly b">offsetHeight</code>属性，以及其他。</p><p id="9ae9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HTML元素将从这个接口继承，并用它们自己的专用实现进行扩展。例如，<code class="fe lv lw lx ly b">HTMLInputElemen</code> t将从<code class="fe lv lw lx ly b">HTMLElement</code>扩展而来，并创建自己的一些属性和方法，如<code class="fe lv lw lx ly b">value</code>、<code class="fe lv lw lx ly b">name</code>和<code class="fe lv lw lx ly b">placeholder</code>。但是，<code class="fe lv lw lx ly b">HTMLSelectElement</code>实现了<code class="fe lv lw lx ly b">HTMLInputElement</code>中不存在的属性，比如<code class="fe lv lw lx ly b">selectedIndex</code>，或者<code class="fe lv lw lx ly b">multiple</code>。</p><p id="1b9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一下，这些类型也可以覆盖继承的任何属性或方法，当然遵循一组已建立的规则，例如超属性或方法不是静态的，保留签名或原始方法等。</p><h2 id="b724" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">遥控类型</h2><p id="a6db" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这个在<code class="fe lv lw lx ly b">@types/react</code>套餐中有定义，可以在<a class="ae ky" href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts" rel="noopener ugc nofollow" target="_blank">这里</a>查看。<code class="fe lv lw lx ly b">ReactElement</code>也是一个接口。需要注意的一点是，这不是一个实际的DOM元素，也不是从TypeScript之前讨论的类型继承的。React的功能部件返回一个<code class="fe lv lw lx ly b">ReactElement</code>或<code class="fe lv lw lx ly b">null</code>。</p><p id="44ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">ReactElement</code>类型可以被认为是其他类型的原始定义，如<code class="fe lv lw lx ly b"><strong class="lb iu"> </strong>JSX.Element</code>或<code class="fe lv lw lx ly b">JSX.IntrinsicElements</code>。</p><p id="1cda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了其他类型之外，一个<code class="fe lv lw lx ly b">ReactNode</code>类型可以是一个<code class="fe lv lw lx ly b">ReactElement</code>、一个<code class="fe lv lw lx ly b">string</code>、一个<code class="fe lv lw lx ly b">number</code>，甚至是<code class="fe lv lw lx ly b">null</code>。顺便说一下，React的类组件呈现方法返回类型是<code class="fe lv lw lx ly b">ReactNode</code>。</p><p id="01e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，一个<code class="fe lv lw lx ly b">JSX.Element</code>也可以是一个<code class="fe lv lw lx ly b">ReactElement</code>；然而，这个明确地将其<em class="ns"> </em> <code class="fe lv lw lx ly b">type</code>和<code class="fe lv lw lx ly b">props</code>都定义为<code class="fe lv lw lx ly b">any</code>，所以这个更加通用和松散。</p><p id="1ad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的接口定义如下:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="04ac" class="nd mh it ly b gy oa ob l oc od">interface <strong class="ly iu">ReactElement</strong><em class="ns">&lt;</em>P = any, T extends string | JSXElementConstructor<em class="ns">&lt;</em>any<em class="ns">&gt; </em>= string | JSXElementConstructor<em class="ns">&lt;</em>any<em class="ns">&gt;&gt; {<br/>    </em><strong class="ly iu">type</strong>: T;<br/>    <strong class="ly iu">props</strong>: P;<br/>    <strong class="ly iu">key</strong>: Key | null;<br/><em class="ns">}</em></span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="748a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">让我们看看一些代码</h1><p id="758d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">考虑以下代码段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">HTML元素一直继承自<strong class="ak">节点</strong>、<strong class="ak">元素</strong>和<strong class="ak">HTML元素</strong>。</p></figure><p id="83a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几件事将在这里变得显而易见。首先，当您调用<code class="fe lv lw lx ly b">document.createElement</code>时，得到的是TypeScript对您要创建的内容的最佳猜测。所以如果你打电话给<code class="fe lv lw lx ly b">document.createElement(‘div’)</code>，你会得到一个<code class="fe lv lw lx ly b">HTMLDivElement</code>。如果你试图创建一个未知的标签，你会得到一个<code class="fe lv lw lx ly b">HTMLUnknownElement</code>。</p><p id="fd93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该<code class="fe lv lw lx ly b">HTMLDivElement</code>将直接继承自<code class="fe lv lw lx ly b">HTMLElement</code>，而<code class="fe lv lw lx ly b">HTMLElement</code>又直接继承自Element类型等。最后，元素从Node继承签名。</p><p id="937d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个祖先层次结构将为我们提供传递给实例的方法和属性的全部范围，并且是多态性的基本特征之一。</p><p id="f395" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并非所有可以通过DOM放入页面的元素在TypeScript中都有其特定的元素类型。请考虑以下事项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="2196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，<code class="fe lv lw lx ly b">&lt;header&gt;&lt;/header&gt;</code>元素将具有普通的<code class="fe lv lw lx ly b">HTMLElement</code>类型。至少在这个时间点上，没有<code class="fe lv lw lx ly b">HTMLHeaderElement</code>。这个header实例将接收从Node和Element继承的每个成员，同时还接收来自<code class="fe lv lw lx ly b">HTMLElement</code>的所有内容，这是它自己的类型。</p><p id="6e91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，除非通过TypeScript以编程方式声明，否则一些用于查询DOM的标准文档方法将返回通用HTMLElement，即使它们在TypeScript <strong class="lb iu">中定义了特定的类型。</strong>这可能发生在运行时，例如，<code class="fe lv lw lx ly b">getElementById</code>无法知道它将找到哪种元素。在这些情况下，根据您实际知道您将得到的内容进行铸造是很好的，例如:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="ca80" class="nd mh it ly b gy oa ob l oc od">// casting the return value from getElementById<br/>const div:HTMLDivElement = document.getElementById('div_id') <strong class="ly iu">as HTMLDivElement</strong>;</span></pre><p id="3c42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样的类型转换元素对于具有独占属性的元素或者像本文前面提到的<code class="fe lv lw lx ly b">HTMLSelectElement</code>这样的方法尤为重要。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c52f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">让我们检查React组件类型</h1><p id="8420" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对于React功能组件，您需要返回<code class="fe lv lw lx ly b">ReactElement</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="6092" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前一个例子的第13行声明这个约会组件将返回一个<code class="fe lv lw lx ly b">ReactElement</code>。</p><p id="56e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，React类型的工作方式与<code class="fe lv lw lx ly b">HTMLElements</code>在TypeScript上的工作方式非常相似。在金字塔的顶端，你会发现扩展了我们之前例子的接口:<code class="fe lv lw lx ly b">React.FC</code>。它专门为功能组件工作，并且是所有React功能组件的基础。</p><p id="aa54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">React.FC</code>有兄弟，<code class="fe lv lw lx ly b">React.Component</code>型。根据源代码，这是“普通JS类的基本组件”</p><p id="9e60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这一个你将用于类组件，像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">React类组件将从<strong class="ak"> </strong> React.Component扩展而来。</p></figure><p id="9727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，React类组件的<code class="fe lv lw lx ly b">render</code>函数将返回一个<code class="fe lv lw lx ly b">React.ReactNode</code>类型。</p><p id="b722" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">React.Component</code>和<code class="fe lv lw lx ly b">React.FC</code>接口之后，你会发现许多其他的接口，但是其中三个是我特别感兴趣的。第一个是<code class="fe lv lw lx ly b">ReactElement</code>。如上所述，这是<code class="fe lv lw lx ly b">React.FC</code>将返回的类型，但更有趣的是，<code class="fe lv lw lx ly b">ReactElement</code>直接继承到<code class="fe lv lw lx ly b">JSX.Element</code>接口，而<code class="fe lv lw lx ly b">JSX.Element</code>接口又继承到<code class="fe lv lw lx ly b">JSX.IntrinsicElements</code>。最后一个非常有趣，因为它定义了将从JSX代码转换过来的HTML(类似于TypeScript对<code class="fe lv lw lx ly b">HTMLElements</code>、<code class="fe lv lw lx ly b">HTMLInputElement</code>等的处理)。</p><p id="ba6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是JSX源代码的截图。<strong class="lb iu"> IntrinsicElements </strong>接口源代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/ad144fb800c9c37d1cdd2f9eddfb2d72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F2NG4VL3P-rMMZ2x1oHr8Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JSX。IntrinsicElements定义了要从JSX传输的HTML元素。</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d20e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="892a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">通常，在TypeScript中创建React组件时，不应该过多地摆弄返回类型。然而，有一些有效的用例，比如当你的linter被设置为指定一个返回类型，而不是被设置为让transpiler推断类型。参见<code class="fe lv lw lx ly b">tsconfig.ts</code>中的<code class="fe lv lw lx ly b">— noImplicitAny</code>和<code class="fe lv lw lx ly b">strict: true</code>设置。</p><p id="41fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据经验，当linter报错时，您应该在代码中指定类型，这通常意味着TypeScript的引擎无法推断您试图使用的变量类型。</p><p id="5b59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理想情况下，你应该明白你在用什么。如果有的话，你欠你自己去学习和欣赏你正在实现的东西，以及你正在使用的工具是否是完成任务的正确工具。</p><blockquote class="oh"><p id="4d28" class="oi oj it bd ok ol om on oo op oq lu dk translated">“在我们理解它之前，我们什么也看不见。”—约翰·康斯太勃尔，十九世纪英国画家</p></blockquote><p id="ec46" class="pw-post-body-paragraph kz la it lb b lc or ju le lf os jx lh li ot lk ll lm ou lo lp lq ov ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cbd2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">进一步阅读</h1><ul class=""><li id="85ad" class="ow ox it lb b lc my lf mz li oy lm oz lq pa lu pb pc pd pe bi translated"><a class="ae ky" href="https://www.typescriptlang.org/docs/" rel="noopener ugc nofollow" target="_blank">打印正式文件</a></li></ul></div></div>    
</body>
</html>