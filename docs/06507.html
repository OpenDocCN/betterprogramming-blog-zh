<html>
<head>
<title>A Continuous Integration Setup for Monorepo Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Monorepo项目的持续集成设置</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-continuous-integration-setup-for-monorepo-projects-c5cf31866c9c?source=collection_archive---------15-----------------------#2020-10-07">https://betterprogramming.pub/a-continuous-integration-setup-for-monorepo-projects-c5cf31866c9c?source=collection_archive---------15-----------------------#2020-10-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ae3e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更高的生产率和更少的等待时间</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2e56a270888a9a86322abf8e7f8cf0e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*maurjo94aWjtzeoMZKkncA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·施诺布里奇在<a class="ae ky" href="https://unsplash.com/s/photos/group?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="bfce" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">直到2020年，建立Monorepo都很困难</h1><p id="84c2" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Monorepo指的是将所有子项目放在一个存储库中的策略。相比之下，使用polyrepo，每个子项目都有自己的存储库。</p><p id="ef4a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">Monorepo带来了许多好处，包括更好的协作和分担责任。有许多有趣的文章讨论了monorepo的利弊。我最喜欢的一个是<a class="ae ky" href="https://medium.com/@adamhjk/monorepo-please-do-3657e08a4b70" rel="noopener"> Monorepo:请吧！</a>作者<a class="mz na ep" href="https://medium.com/u/9978525af468?source=post_page-----c5cf31866c9c--------------------------------" rel="noopener" target="_blank">亚当雅各布</a>。</p><p id="bc91" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">就在几年前，由于框架的不兼容，建立一个monorepo项目非常复杂。例如，像NPM这样的许多包管理器对monorepo并不友好，像Heroku这样的基础设施对项目的根做出了假设，而这些假设并不适用于monorepo项目。</p><p id="8721" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">幸运的是，工具和平台已经发展得如此之快，以至于建立monorepo项目已经变得简单得多。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7e5e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">Monorepo的CI仍然不理想</h1><p id="94a9" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">然而，为monorepo项目启动易于使用的CI基础设施仍然需要一些技巧。</p><p id="6819" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">更具体地说，在polyrepo项目中，不管变更是什么，整个配置项都会运行，而在monorepo项目中，不管修改哪个子项目，总是运行整个配置项是非常耗时的，而且会影响生产效率。</p><p id="f12e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">例如，monorepo项目可能包含一个服务器和多个客户端(例如，一个移动应用程序、一个网站和一个CLI)，它们都有自己的CI任务。为了维护代码健康，项目通常在合并变更之前强制CI检查通过，但是当开发人员不得不等待所有这些测试完成，仅仅是为了修复文档中的一个打字错误时，这很快就变成了一个负担。</p><p id="1955" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><em class="nb">注意:有可能以个案的方式批准微小的改变，但是那将需要人的注意。</em></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3d97" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">有可能用DIY解决方案来修复它</h1><p id="f473" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">对于上面的例子，如果我们能够动态地定义(基于受影响的子项目)一组CI任务，这些任务是验证代码变更所必需的，并且只运行和检查它们的拉请求，那就太好了。</p><p id="5c4e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们可以将上面提出的解决方案抽象为两个部分:有选择地运行和检查CI任务。</p><h2 id="6b09" class="nc lh it bd li nd ne dn lm nf ng dp lq mh nh ni ls ml nj nk lu mp nl nm lw nn bi translated">有选择地运行配置项任务</h2><p id="b2a8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">为了有选择地触发CI任务，我们可以使用GitHub Actions的路径触发(更多详细信息，请参见<a class="ae ky" href="https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpaths" rel="noopener ugc nofollow" target="_blank">GitHub Actions的工作流语法</a>)。</p><p id="c85f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">GitHub动作有一个独特的特性，让我们指定触发条件，包括文件路径。</p><p id="a0f9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">例如，只有在推或拉请求中修改了<code class="fe no np nq nr b">clients/app</code>目录中的任何文件时，才会执行以下工作流配置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="6faf" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们还可以定义多个触发路径，以防需要检查几个子项目是否兼容。</p><p id="7052" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">以下是实现这一目的的工作流配置示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="a5af" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">应用程序、web或服务器目录中的任何更改都会触发上面的工作流，以确保这三者兼容。</p><h2 id="6070" class="nc lh it bd li nd ne dn lm nf ng dp lq mh nh ni ls ml nj nk lu mp nl nm lw nn bi translated">有选择地检查CI结果</h2><p id="0cc1" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在GitHub上有选择地验证CI结果证明是一个不小的问题，因为QA流程本身并不支持它。</p><p id="29aa" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">GitHub的原生QA方法是“受保护的分支”,它让存储库所有者为合并拉请求定义静态需求(对所有拉请求都一样),包括CI检查、代码审查等等。</p><p id="6aa9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">它对polyrepo项目很有效，因为polyrepo项目中的所有事情都与项目本身有关，所以不管变更是什么，检查所有CI结果都是有意义的。</p><p id="5cea" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">然而，对于包含多个相对独立的子项目的monorepo项目，总是检查完整的CI结果集是多余的。</p><p id="ea8d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">要将动态组合的配置项结果列表转换为静态的配置项结果集，我们需要一个“填补”层来收集所需配置项的列表，并将它们组合成单个配置项结果(静态的)。</p><p id="78c4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">为了实现这一点，我们需要GitHub integration、<a class="ae ky" href="https://github.com/marketplace/check-group" rel="noopener ugc nofollow" target="_blank"> Check Group </a>的一点帮助，它让我们在子项目级别定义CI需求，并将它们组合成一个针对拉请求的CI检查。</p><p id="328f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">将所有的需求整合成一个(有点像一个垫层)，然后我们可以配置“受保护的分支”规则，只依赖这个单一的组合CI检查。</p><p id="6fb6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">要定义每个子项目的配置项要求，我们可以使用如下所示的配置文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="f86d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">有了这个配置，Check Group现在将把所有的子项目需求合并成一个，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/f0fae2d08b3024d6cf6d50c169f965e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZGUIgkpECBFwQR8XOdnKfg.png"/></div></div></figure><p id="d47a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在我们有了一个CI设置，它可以基于子项目识别CI需求。</p><p id="856d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">感谢您的阅读，祝您在下一个monorepo项目中愉快！</p></div></div>    
</body>
</html>