<html>
<head>
<title>How to Use Functional Programming to Create Powerful Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用函数式编程创建强大的应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-functional-programming-to-create-powerful-applications-aadfd83ad74c?source=collection_archive---------8-----------------------#2022-01-14">https://betterprogramming.pub/how-to-use-functional-programming-to-create-powerful-applications-aadfd83ad74c?source=collection_archive---------8-----------------------#2022-01-14</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="cbb8" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">用Swift中的例子解释</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/ee1025134312f78b707f9b0576582327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MPCHr6x_FhYm_1Cp"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">达里奥在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3e5e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">OOPS在大企业中曾经风光一时。由于自身的缺陷，它带来了巨大的成功，也失败了。</p><p id="b25d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">尽管如此，由于所有关于继承的花哨功能和不良副作用，它在每个程序员心中都有一席之地，原因有二:</p><ul class=""><li id="2d62" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">没有对象的概念(基本上是包装)，很难想象封装</li><li id="6bfd" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">更深层次的原因来了:作为人类，在计算机发明之前，我们已经不断地将世界分类为物种(进一步:种族、民族、国籍)、学科和类型。整个现代科学和社会的起源就在于这些分类。计算也不能例外。</li></ul><p id="b734" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">即使在函数式编程范例中，语言也是从陈述开始的:</p><blockquote class="mk ml mm"><p id="dcfe" class="la lb mn lc b ld le jv lf lg lh jy li mo lk ll lm mp lo lp lq mq ls lt lu lv in bi translated">(这里，在这种语言中:)函数是一级<em class="iu">对象</em>。</p></blockquote><p id="008c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">FP带来了这些免责声明，不是作为OOPS的完全替代，而是作为一个通过程序员的客观镜头分类的世界之巅的智能层。</p><h1 id="c0f5" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">范围</h1><p id="e3ea" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">一段时间以前，FP对我来说只是一些在技术面试中脱口而出的样板定义。</p><p id="e5e2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我没有计算机学位，我也从来没有觉得有必要学习FP作为范例。我使用过它，但只是作为一种实用工具，从未把它当作一个概念。</p><p id="3bfb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">直到我开始使用Rx Observables和JS Promise等概念，(具体来说:当我开始遇到它们的问题时)我才完全意识到FP的神奇世界。</p><p id="67f2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">即便如此，我的挖掘也没有超出常规:</p><ul class=""><li id="5f28" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">纯函数没有副作用</li><li id="ee37" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">OOP太糟糕了，以至于每个人都开始厌恶它(更多的是因为他们的命运一辈子都与它联系在一起)。</li><li id="f24e" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">函数是函数式语言中的一级对象(并不是说我知道它真正的意思)</li></ul><p id="4a56" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我从未问过自己真正重要的问题:</p><ul class=""><li id="c2f9" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">如何根据函数而不是对象来考虑你的项目</li><li id="cbf5" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">如何把基于OOP的项目变成基于函数的项目？</li></ul><p id="40c3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我试图用尽可能简单的术语来解释这些问题。</p><p id="5aa3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这篇文章不是学术性的。它不是来自对函数式语言的大量研究。如果你正在寻找这样的内容，我建议你谷歌一下最受欢迎的函数式编程书籍，跳过这篇文章。</p><p id="461b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们通过清除定义部分来深入研究。</p><h1 id="cdb1" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">作为对象的功能:</h1><p id="9cd1" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">函数<a class="ae kz" href="https://en.wikipedia.org/wiki/First-class_function" rel="noopener ugc nofollow" target="_blank">是一级对象</a>是什么意思？</p><h2 id="24d1" class="no ms iu bd mt np nq dn mx nr ns dp nb lj nt nu nd ln nv nw nf lr nx ny nh nz bi translated">三种症状</h2><ul class=""><li id="46a0" class="lw lx iu lc b ld nj lg nk lj oa ln ob lr oc lv mb mc md me bi translated">它们可以作为参数传递给其他函数。示例:</li></ul><pre class="kk kl km kn gu od oe of og aw oh bi"><span id="333a" class="no ms iu oe b gz oi oj l ok ol">let value = otherFunction(myFunction("Hello"))</span></pre><ul class=""><li id="279f" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">函数可以作为其他函数的值返回。示例:</li></ul><pre class="kk kl km kn gu od oe of og aw oh bi"><span id="a414" class="no ms iu oe b gz oi oj l ok ol">myFunction() -&gt; (Integer -&gt; Integer) {<br/>    return {<br/>        i in <br/>        return i*2<br/>    }<br/>}</span></pre><ul class=""><li id="a3a6" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">可以将函数分配给变量，并存储在数据结构中(例如函数数组)。示例:</li></ul><pre class="kk kl km kn gu od oe of og aw oh bi"><span id="c088" class="no ms iu oe b gz oi oj l ok ol">let myVariable1 = myFunction(5)<br/>let myVariable2 = myFunction(5)<br/>let myVariable3 = myFunction(5)<br/>let functionArray = [myVariable1, myVariable2, myVariable3]</span></pre><p id="ce2d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">说完这些，让我们深入研究两个案例，在这两个案例中，FP可以成为改变你的编程能力的极其强大的工具。</p><h1 id="6002" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">#1:何时使用函数作为参数</h1><p id="5fab" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">这里有个秘密:我刚才举的那些例子，从我开始编程到现在，我至少遇到过1000次。我从没想过这有什么特别的。</p><p id="8e3e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">直到我遇到一个真实世界的用例。</p><p id="746b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们来看看利息计算器组件:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="om on l"/></div></figure><p id="6f6d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，您突然觉得需要对输入执行一些验证，但是您不想弄乱初始化。因为财务规则是不稳定的，所以每个利息计算器都是有效的对象。你能做的就是改变利息的计算方式。</p><p id="5ea8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，如果参数变得无效，您将从<code class="fe oo op oq oe b">interestCalculator</code>返回一个错误。</p><p id="7e82" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是，如果您希望错误以字符串形式报告，但又希望利息以双倍形式返回，该怎么办呢？</p><blockquote class="or"><p id="bee3" class="os ot iu bd ou ov ow ox oy oz pa lv dk translated">每当蛋糕准备好了，面包师<em class="pb">就会叫你</em>。</p></blockquote><p id="cb32" class="pw-post-body-paragraph la lb iu lc b ld pc jv lf lg pd jy li lj pe ll lm ln pf lp lq lr pg lt lu lv in bi translated">此外，如果一些异步处理可能会中断利息计算器怎么办？你显然不希望客户无限期地等待。</p><p id="8d98" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这和你为你的兄弟姐妹的生日从你最喜欢的面包师那里预定一个蛋糕没什么不同。每当蛋糕准备好了，面包师<em class="mn">就会叫你</em>。</p><p id="1d8f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">考虑下面的代码，其中有一个额外的函数用于<code class="fe oo op oq oe b">interactiveInterestCalculation()</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="om on l"/></div></figure><p id="f141" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe oo op oq oe b">interactiveInterestCalculation()</code> <strong class="lc iv"> </strong>做你最喜欢的面包师做的事情:只要你预定的结果准备好了，它就会叫你。如果丢弃所有return语句，也可能需要多次报告中间状态。</p><h2 id="650a" class="no ms iu bd mt np nq dn mx nr ns dp nb lj nt nu nd ln nv nw nf lr nx ny nh nz bi translated">使用案例:</h2><ul class=""><li id="d602" class="lw lx iu lc b ld nj lg nk lj oa ln ob lr oc lv mb mc md me bi translated"><strong class="lc iv">高阶函数</strong> : <em class="mn">映射</em>，<em class="mn">过滤器</em>和<em class="mn"> Reduce </em>使用输入回调转换数据</li><li id="c838" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><strong class="lc iv">进度指示器:</strong>数据下载/处理进度回调</li><li id="fced" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><strong class="lc iv">定时事件</strong>(每x秒触发一次回调的计时器，调用一次回调)</li><li id="dcb5" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><strong class="lc iv">结果/错误报告者</strong>:承诺(<code class="fe oo op oq oe b">interactiveInterestCalculation()</code>也是简化的)</li></ul><h1 id="5a51" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">#2:何时使用函数作为返回值</h1><p id="7cea" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">这个用例就是我在标题中写下“强大的<em class="mn">”</em>这个词的原因。这是因为返回函数会将函数调用的权力转移给客户端。</p><p id="f658" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">换句话说，当您从一个函数返回一个函数时，您提供了(返回函数的)定义，但是客户端拥有调用返回函数的所有权力。</p><blockquote class="or"><p id="0148" class="os ot iu bd ou ov ow ox oy oz pa lv dk translated">无论你什么时候打电话给帮助热线，它都会给你菜谱。你想什么时候做蛋糕就什么时候做蛋糕，或者干脆不做蛋糕。</p></blockquote><p id="f53c" class="pw-post-body-paragraph la lb iu lc b ld pc jv lf lg pd jy li lj pe ll lm ln pf lp lq lr pg lt lu lv in bi translated">不像上面第一条中的蛋糕烘焙师，在这里，你只需拨打食谱制作热线。语音问你想做什么菜，你一说就把菜谱叙述出来了。你什么时候觉得舒服就做这道菜。或者你可以简单地选择跳过制作部分。</p><p id="4402" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">从函数开发人员的角度:创建逻辑并返回它；客户端调用该函数。这种权力属于客户，而责任和调用的资源也必须属于他。</p><blockquote class="mk ml mm"><p id="68bf" class="la lb mn lc b ld le jv lf lg lh jy li mo lk ll lm mp lo lp lq mq ls lt lu lv in bi translated">“如果你给一个人一条鱼，你可以喂他一天。如果你教一个人钓鱼，你就喂了他一辈子。”</p></blockquote><p id="9db3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你对这句谚语很熟悉，那么这个用例就是小菜一碟。</p></div><div class="ab cl ph pi hy pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="in io ip iq ir"><p id="0845" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们再来看看利息计算器组件，其中包含一些更有用的定制:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="om on l"/></div></figure><p id="4dfc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里，<code class="fe oo op oq oe b">specialInterestCalculation()</code>根据在<code class="fe oo op oq oe b">InterestCalculator()</code>对象创建时传递的值返回一个适当的函数。返回的函数(<code class="fe oo op oq oe b">lowRateInterestFunction</code>、<code class="fe oo op oq oe b">highReturnInterestFunction</code>、<code class="fe oo op oq oe b">lowTenurePenaltyFunction</code>或最后一个未命名的罚息计算函数)。</p><p id="65f6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">每当客户想要计算利息时，他只需调用返回的函数:</p><pre class="kk kl km kn gu od oe of og aw oh bi"><span id="7dc6" class="no ms iu oe b gz oi oj l ok ol">let f = specialInterestCalculation()</span><span id="7f34" class="no ms iu oe b gz po oj l ok ol">// Long, long afterward, in a module far far away<br/>let interest = f()</span></pre><h2 id="e6aa" class="no ms iu bd mt np nq dn mx nr ns dp nb lj nt nu nd ln nv nw nf lr nx ny nh nz bi translated"><strong class="ak">总结一下</strong></h2><p id="bb3f" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">使用函数作为返回值，您可以将执行逻辑(稍后调用的客户端:<code class="fe oo op oq oe b">f()</code>)与处理逻辑(之前调用的客户端:<code class="fe oo op oq oe b">specialInterestCalculation()</code>)完全分离。</p><h1 id="6a59" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">奖励:函数式编程的真正力量</h1><p id="705e" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">让我们再举一个函数返回函数的例子，来体会函数式编程的真正威力。</p><p id="1758" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们想象一下，银行决定增加它的储蓄客户群。为了成为新闻头条，该公司决定奖励其现有客户一笔可观的彩票奖金。</p><ul class=""><li id="de66" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">彩票功能必须完全随机化。</li><li id="bda3" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">为了透明起见，彩票功能必须基于客户端输入(事先通过web表单提交的随机数，就像彩票一样)运行。</li><li id="061c" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">结果出来后，银行会公布大家提交的抽奖功能码和随机数，这样就没人能叫屈了。</li><li id="1174" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">彩票功能必须足够强大。因此，在预先确定的时间(同一时间)在所有客户端的机器(台式机/移动设备)上运行彩票功能将是一个明智的选择。</li></ul><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="om on l"/></div></figure><p id="3993" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如您所见，<code class="fe oo op oq oe b">calculateLotteryReward()</code>满足了所有需求。它返回一个函数并快速退出。这个返回的函数通过随机数在客户端和服务器端都足够随机化。</p><pre class="kk kl km kn gu od oe of og aw oh bi"><span id="3be5" class="no ms iu oe b gz oi oj l ok ol">//Submit your random number by 31st March 2022<br/>let f = calculateLotteryReward(57)</span><span id="fcb9" class="no ms iu oe b gz po oj l ok ol">// On 1 April, 2022<br/>let paymentAmount = f(); // I won $1M+ interest from the bank!</span></pre><p id="aa9d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如上所述，在提交日期之前的任何时候，<em class="mn"> f </em>都将被<em class="mn">解析并返回</em>。但是要到愚人节才会执行。当它出现时，它将在客户机上，所以这个巨大的循环不会永远阻塞服务器。</p><p id="a04b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">安全性(如何在4月1日之前将函数返回值传输到客户机而不让客户机看到)和随机化(获胜的几率等)不在本次讨论的范围之内。也可以是客户机和服务器都驻留在安全网络上，或者在不同的进程中驻留在同一台机器上。见鬼，我甚至还没有测试我的随机化逻辑。</p><p id="65bc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我只是用它来演示函数式编程如何以高度灵活和分离的方式分配工作负载。</p><h1 id="dfdc" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">结论</h1><p id="ffca" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">通常，你的基于OOP的项目充斥着糟糕的、不直观的代码，除了要求太多和让步太少之外，没有任何用处。如果使用得当，函数式编程会给他们带来巨大的力量。</p><p id="8bb9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">唯一要记住的是，永远不要从第一天起就担心自己的功能性——这只会让学习曲线变得更陡，你会很快发现自己陷入了理论的深渊。</p><p id="ca34" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以基于OOP的类设计的自然进程来看待事物。有了这些小步，总有一天你可以移山。</p></div></div>    
</body>
</html>