<html>
<head>
<title>A Practical Guide to Understanding Currying in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中Currying的实用指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-currying-in-javascript-8e7f76e08904?source=collection_archive---------6-----------------------#2020-02-16">https://betterprogramming.pub/understanding-currying-in-javascript-8e7f76e08904?source=collection_archive---------6-----------------------#2020-02-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="68f4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">奉承会让人困惑。我们来分解一下</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a4193eec4eeeded19e6778646cec9e32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2gXgAC7JAnChZBLH"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我听说我们在谈论咖喱！😋——图片由<a class="ae ky" href="https://unsplash.com/@marius_dragne?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Dragne Marius </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a52b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你是一个听说过“咖喱”这个词的程序员。也许你已经使用了部分应用，并假设它们是同一个东西。他们不是。</p><p id="2559" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">读完这本理解和启发的指南后，你也会加入那些知道区别的精英程序员群体。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2639" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">准确的Currying资源</h1><p id="ef7b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">抛开所有的笑话和乐趣，我创建了这篇信息性文章，作为对所有关于JavaScript欺骗的可怕资源的回应。当我在谷歌上搜索“JavaScript curry”时，我震惊地看到结果顶部有这么多错误信息，即来自<a class="ae ky" href="https://blog.bitsrc.io/understanding-currying-in-javascript-ceb2188c339" rel="noopener ugc nofollow" target="_blank">这篇文章</a>和<a class="ae ky" href="https://medium.com/@kbrainwave/currying-in-javascript-ce6da2d324fe" rel="noopener">这篇文章</a>。</p><p id="4800" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得庆幸的是，从<a class="ae ky" href="https://javascript.info/currying-partials" rel="noopener ugc nofollow" target="_blank"> javascript.info </a>、<a class="ae ky" href="https://medium.com/javascript-scene/curry-and-function-composition-2c208d774983" rel="noopener"> Eric Elliot </a>和<a class="ae ky" href="https://blog.benestudio.co/currying-in-javascript-es6-540d2ad09400" rel="noopener ugc nofollow" target="_blank"> Adam Bene </a>那里获得了一些有用的信息，然而除了javascript.info之外，即使是这些有用的资源也无法提供一个可靠的、通用的curry函数。</p><p id="7746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正是由于这种可怕的认识，我觉得我有责任向程序员传播这种困境的知识和意识，并提供一篇理智、准确和有用的文章。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4929" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">条款</h1><p id="cd1d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">也就是说，在我们开始学习如何使用currying之前，理解一些术语是至关重要的:</p><h2 id="d8c6" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><strong class="ak">一级功能</strong></h2><p id="8e24" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果函数可以存储在变量中，并像常规对象一样对待，比如被其他函数传入和返回，那么就说一种语言支持一级函数。</p><h2 id="4491" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><strong class="ak">高阶函数</strong></h2><p id="2223" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一种对其他函数进行操作的函数，要么接受一个函数作为输入，要么返回一个函数作为输出，或者两者都接受。</p><p id="1086" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一种语言没有对一级函数的支持，更高阶的函数就不能存在于那种语言中。</p><h2 id="004e" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><strong class="ak">关闭</strong></h2><blockquote class="nl"><p id="2811" class="nm nn it bd no np nq nr ns nt nu lu dk translated">“一种在具有一级函数的语言中实现词汇范围<a class="ae ky" href="https://en.wikipedia.org/wiki/Name_binding" rel="noopener ugc nofollow" target="_blank">名称绑定</a>的技术”——<a class="ae ky" href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="5718" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">这意味着函数保留了对定义时在作用域内的变量的访问权，即使在没有这些变量的作用域内调用该函数。</p><h2 id="56cd" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><strong class="ak">部分应用</strong></h2><blockquote class="nl"><p id="146e" class="nm nn it bd no np nq nr ns nt nu lu dk translated">"将一个函数的多个变元固定下来，产生另一个更小变元的函数的过程."— <a class="ae ky" href="https://en.wikipedia.org/wiki/Partial_application" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><h2 id="4633" class="mz md it bd me na oa dn mi nc ob dp mm li oc nf mo lm od nh mq lq oe nj ms nk bi translated"><strong class="ak">阿谀奉承</strong></h2><blockquote class="nl"><p id="7e2d" class="nm nn it bd no np nq nr ns nt nu lu dk translated">将带有多个参数的函数的计算转换为带有单个参数的函数序列的计算— <a class="ae ky" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><h2 id="356d" class="mz md it bd me na oa dn mi nc ob dp mm li oc nf mo lm od nh mq lq oe nj ms nk bi translated"><strong class="ak"> Arity </strong></h2><p id="247d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">函数接受的参数数量。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="98f3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">部分应用</h1><p id="d53c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">部分函数应用是一种预定义一些参数的方法，这些参数将在任何后续参数之前首先应用。</p><p id="3747" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一位好心的作者在<a class="ae ky" href="https://en.wikipedia.org/wiki/Partial_application" rel="noopener ugc nofollow" target="_blank">的这篇维基百科</a>文章中写道:</p><blockquote class="nl"><p id="6dac" class="nm nn it bd no np nq nr ns nt nu lu dk translated">"如果您确定了函数的前几个参数，您将得到一个包含其余参数的函数."</p></blockquote><p id="6d01" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">在JavaScript中，将参数部分应用于不同函数的函数示例如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">注意，这个例子并不完全符合部分应用的定义——从技术上讲，它返回的是一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Variadic_function" rel="noopener ugc nofollow" target="_blank">变量函数</a>，而不是一个更小arity的函数。</p></figure><p id="cf87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个代码示例中，函数<code class="fe oh oi oj ok b">partiallyApply</code>接受一个函数<code class="fe oh oi oj ok b">func</code>和一些预定义的参数(<code class="fe oh oi oj ok b">argsToApply</code>)作为输入，并返回一个包装了<code class="fe oh oi oj ok b">func</code>的新函数。</p><p id="127b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">神奇的事情就发生在这个包装函数中。当我们创建匿名包装函数时，一个<em class="ol">闭包</em>被创建，它保留了对<code class="fe oh oi oj ok b">argsToApply</code>变量的访问。</p><p id="cf58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着即使包装函数被返回并且<code class="fe oh oi oj ok b">argsToApply</code>不再在作用域内，包装函数仍然保留对<code class="fe oh oi oj ok b">argsToApply</code>的访问。</p><p id="f9d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一些部分应用的功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="6607" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，在<code class="fe oh oi oj ok b">concat5</code>的例子中，我们能够预定义五个参数中的三个，然后用剩下的两个调用函数，即使这些预定义的参数不再在作用域中。</p><p id="cd64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在某种程度上与currying有关，我们现在将探讨这一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ad8d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Currying</h1><p id="aa2c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">虽然与局部应用相关，但是<em class="ol">与</em>不是同一个<em class="ol">。</em>curry函数就是取一个函数，将其转化为一系列函数，每个函数取一个自变量。</p><p id="c09c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子来说明:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="380f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生了一些有趣的事情:</p><ol class=""><li id="2a47" class="om on it lb b lc ld lf lg li oo lm op lq oq lu or os ot ou bi translated"><code class="fe oh oi oj ok b">curry</code>函数将一个函数作为参数，并返回一个新函数。</li><li id="e07b" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu or os ot ou bi translated">返回的函数返回一个函数，以此类推(这是函数的序列)。如果您要检查每个curried函数调用的返回值，您会看到除了最后一个返回值之外，它们都是函数，这就引出了这个问题:</li><li id="f63c" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu or os ot ou bi translated">函数序列确切地知道最后一个参数是什么时候提供的，它不是返回一个新函数，而是返回最终结果。</li></ol><p id="b2ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，currying与部分应用程序的区别在于，与部分应用程序的单个函数相比，currying返回一系列函数，这些函数知道何时结束并返回最终结果。这是因为currying关心函数的<em class="ol"> arity </em>。</p><p id="2129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们还记得本文顶部术语的定义，<em class="ol"> arity </em>是函数接受的参数个数。<code class="fe oh oi oj ok b">curry</code>函数能够检测所需数量的参数何时被传入，并相应地采取行动。</p><p id="af64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，我们可以用<code class="fe oh oi oj ok b">Function.prototype.length</code>方法获得arity，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">即使默认参数和rest参数接受额外的参数，它们也不计入函数的长度。</p></figure><p id="ab20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，默认参数和rest参数不计入函数的<code class="fe oh oi oj ok b">length</code>。在currying的上下文中，这是有意义的。如果参数是可选的，我们如何知道何时返回最终值而不是另一个函数？</p><p id="59b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解<code class="fe oh oi oj ok b">argsAfterDefault</code>有一个为0的<code class="fe oh oi oj ok b">length</code>也很重要，即使在默认参数之后有两个“常规”参数。当JavaScript计算一个函数的<code class="fe oh oi oj ok b">length</code>时，它只关心在任何默认或rest参数之前的参数<em class="ol">。</em></p><p id="62d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些信息，我们现在对我们想要的<code class="fe oh oi oj ok b">curry</code>函数的行为有了更多的了解。它应该只在传入了<code class="fe oh oi oj ok b">length</code>个参数后返回最终值——一次一个。</p><p id="db06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们想一次传递多个呢？或者什么都不通过？</p><p id="9655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="f79f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想要两个curry函数的哪个实现？</p><p id="a8d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oh oi oj ok b">currySingleArgs</code>严格遵循阿谀奉承的定义，但<code class="fe oh oi oj ok b">curryMultipleArgs</code>灵活得多。这实际上取决于您的具体情况需要什么，所以让我们继续深入研究这两个问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1f73" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">玩弄多种论点</h1><p id="22b8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们来分析一下这两个库里功能的实现，从<code class="fe oh oi oj ok b">curryMultipleArgs</code>开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="df19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能看起来有点复杂，但是一旦我们把它分解，它就变得简单了。让我们来看看返回的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="5d42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们传入函数的简化版本。</p><p id="690c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意的是，像部分应用程序一样，这个内部(或“包装”)函数创建了一个<em class="ol">闭包</em>，它仍然可以访问最初传入的函数来获取它的<code class="fe oh oi oj ok b">length</code>并最终调用它，即使在函数超出范围之后。</p><p id="fcea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该功能有两个主要部分:</p><ol class=""><li id="ef07" class="om on it lb b lc ld lf lg li oo lm op lq oq lu or os ot ou bi translated">如果传入了适当数量的参数，就用这些参数调用原始函数。</li><li id="ff0e" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu or os ot ou bi translated">否则，返回一个接受更多参数的匿名函数。</li></ol><p id="33df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一部分更容易理解。如果我们处理我们的函数，然后用正确数量的参数立即调用处理过的函数(<code class="fe oh oi oj ok b">curry</code>)，那么原始函数(<code class="fe oh oi oj ok b">func</code>)将使用这些参数执行。</p><p id="f6c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二部分是有趣的地方。让我们分析一下返回的匿名函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这个函数表达式用括号括起来，在语法上是合法的。</p></figure><p id="e9de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个接受任意数量参数的函数，类似于<code class="fe oh oi oj ok b">curried</code>函数，当使用这些参数调用时，调用<code class="fe oh oi oj ok b">curried</code>函数。</p><p id="661f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，与部分应用程序示例和<code class="fe oh oi oj ok b">curried</code>一样，需要注意的是这个匿名函数创建了一个闭包，它保留了对重要引用的访问，即传递给<code class="fe oh oi oj ok b">curried</code> ( <code class="fe oh oi oj ok b">args1</code>)和<code class="fe oh oi oj ok b">curried</code>本身的参数。</p><p id="3d11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这还有点不清楚，但是当我们一步一步地，了解程序是如何执行的时候，这就更有意义了。</p><p id="46f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我创建了一个修改版的<code class="fe oh oi oj ok b">curryMultipleArgs</code>，它在每次执行函数序列中的一个函数时记录<code class="fe oh oi oj ok b">args1</code>和<code class="fe oh oi oj ok b">args2</code>的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">当匿名函数被执行时，它也会立即调用curried。</p></figure><p id="5b2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案的工作方式是以迂回的方式递归调用<code class="fe oh oi oj ok b">curried</code>，使用一个接受更多参数的匿名函数。</p><p id="6de8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这不是100%有意义，不要担心。这很好，也在意料之中。奉承是一个具有挑战性的话题，有很多东西需要你去思考。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e371" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">玩弄一个论点</h1><p id="fef4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们来分析一下<code class="fe oh oi oj ok b">currySingleArgs</code>的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这比另一个实现稍微复杂一点，因为需要对外部数组进行变异，以便只强制使用单个参数。</p></figure><p id="6026" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个实现跟踪所有的参数，不是通过传入数组并与每个函数调用连接，而是通过首先初始化一个数组来保存所有的参数，然后在每次调用<code class="fe oh oi oj ok b">intermediate</code>时向该数组推送一个新的参数。</p><p id="80f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该算法有两个主要步骤:</p><ol class=""><li id="7eff" class="om on it lb b lc ld lf lg li oo lm op lq oq lu or os ot ou bi translated">在函数序列中的第一次函数调用时(当调用<code class="fe oh oi oj ok b">curried</code>时)，初始化参数数组并立即用传入的参数调用<code class="fe oh oi oj ok b">intermediate</code>。</li><li id="e5fc" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu or os ot ou bi translated">如果最终传入了正确数量的参数，则调用<code class="fe oh oi oj ok b">func</code>。如果还没有传入正确数量的参数，返回<code class="fe oh oi oj ok b">intermediate</code>接受另一个参数。</li></ol><p id="319f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从第二步开始，采用由内向外的方法来剖析这个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作为逻辑的核心，这出奇的简单。</p></figure><p id="72b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这张快照中没有太多内容。该函数接受一个参数<code class="fe oh oi oj ok b">arg</code>，并立即将其推送到<code class="fe oh oi oj ok b">args</code>数组。</p><p id="c230" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，如果<code class="fe oh oi oj ok b">args</code>的长度等于<code class="fe oh oi oj ok b">func</code>的长度，这只有在最后一个参数被传入时才成立，我们用参数调用<code class="fe oh oi oj ok b">func</code>并返回结果。</p><p id="1ba8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，我们返回<code class="fe oh oi oj ok b">intermediate</code>，允许程序继续链接函数调用。</p><p id="a82a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二步没有太多的内容，让我们仔细看看第一步。这可能有点令人困惑，但一旦我们将其分解，我们就可以开始理解到底发生了什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="349e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，参数数组是在我们调用函数序列中的第一个函数时初始化的，而不是在我们调用函数时初始化的。</p><p id="3b2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以这个简单的curry解决方案为例，它在函数被curry化时初始化参数数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是非常不可取的行为。</p></figure><p id="5912" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这种行为，我们需要在开始调用curried函数后初始化<code class="fe oh oi oj ok b">args</code>。</p><p id="e8d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种方法是将整个事情包装在一个函数中，我们将其命名为<code class="fe oh oi oj ok b">curried</code>，然后在初始化<code class="fe oh oi oj ok b">args</code>后立即调用<code class="fe oh oi oj ok b">intermediate</code>。</p><p id="64d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，<code class="fe oh oi oj ok b">intermediate</code>的任何后续调用仍然能够访问<code class="fe oh oi oj ok b">args</code>数组，但是<code class="fe oh oi oj ok b">curried</code>函数的任何新调用都将拥有自己的<code class="fe oh oi oj ok b">args</code>副本。</p><p id="4224" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让<code class="fe oh oi oj ok b">intermediate</code>函数向<code class="fe oh oi oj ok b">args</code>添加另一个参数的唯一方法是让<code class="fe oh oi oj ok b">curried</code>或另一个<code class="fe oh oi oj ok b">intermediate</code>返回它，这迫使我们链接我们的函数调用，而不依赖于状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正是我们想要的行为。</p></figure><p id="475d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，这就是让函数正常运行的全部内容。</p><p id="273e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生了很多事情，但是当我们分解并分析解决方案时，它开始变得有意义。在发生的许多事情中，最需要理解的是:</p><ol class=""><li id="0be1" class="om on it lb b lc ld lf lg li oo lm op lq oq lu or os ot ou bi translated">通过在函数签名中只接受一个参数，我们一次只处理一个参数。</li><li id="ac9c" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu or os ot ou bi translated">这个参数，无论是否存在，都被放入我们的<code class="fe oh oi oj ok b">args</code>数组中。这是当具有正确数量的参数时将应用于<code class="fe oh oi oj ok b">func</code>的数组。</li><li id="a367" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu or os ot ou bi translated"><code class="fe oh oi oj ok b">args</code>仅在我们开始调用curried函数后初始化，而不是在此之前。这给了我们简单、可预测的行为。我们通过生活和大量使用闭包来实现这个目标。</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b32c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="d15a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript中的通用curry函数有两种实现方式，一种是一次只能接受一个参数，另一种是一次可以接受任意数量的参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一般柯里函数的两种实现。</p></figure><p id="d333" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一次性的文章/指南。我希望你喜欢它，并发现它是有益的和有趣的。</p></div></div>    
</body>
</html>