<html>
<head>
<title>Kubernetes From Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零开始</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kubernetes-from-scratch-4691283e3995?source=collection_archive---------6-----------------------#2020-04-13">https://betterprogramming.pub/kubernetes-from-scratch-4691283e3995?source=collection_archive---------6-----------------------#2020-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2f1c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不含Minikube或Microk8s的Kubernetes</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bf1860c18539402b3bace5b67c44644e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ez6o_w-KIAGWnoYM-kPqg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@marcello54?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马塞罗·根纳里</a>在<a class="ae ky" href="https://unsplash.com/s/photos/lego?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e6ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经安装了几个预配置的Kubernetes版本，比如Minikube和Microk8s，它们在创建Kubernetes沙盒方面表现很好。今天，我将尝试从头安装，以深入了解幕后情况。</p><p id="e57e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes不是一个整体，它是许多组件一起工作，其中许多现在看起来像魔术。但我总是想知道魔术师的戏法，所以我要看看是什么样的戏法让一切都变得可行。</p><p id="f5ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了跟进，您将必须有一个虚拟机供应(我将在后面详细讨论)。您还需要掌握关于Linux、Linux命令行和网络的中等程度的高级知识。你也需要极大的耐心，就像任何使用计算机的努力一样。</p><p id="11aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我将为一台安装了Ubuntu 18.04的虚拟机配置两个虚拟CPU、4G内存和50G硬盘。我在裸机上使用KVM。下面是我在主机上设置它的步骤模板:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="2408" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将我的虚拟机命名为“kube1”(假设以后会有更多)，并将RAM更改为4096，将磁盘大小更改为50，将vCPUs更改为2。用默认值或合理值回答提示。当OpenSSH服务器询问您想要预装什么软件时，请确保您安装的是OpenSSH服务器，而不是其他任何东西。完成后，您就有了IP地址，您可以将它添加到您的<code class="fe lx ly lz ma b">/etc/hosts</code>文件中，这样您就可以通过名称来引用它。如果你想了解更多关于KVM的知识以及如何安装，可以参考我的文章<a class="ae ky" href="https://medium.com/better-programming/playing-with-vms-and-kubernetes-26ef93019c22" rel="noopener">玩VMs和Kubernetes </a>。</p><p id="a1a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我将运行KVM的主机称为<em class="mb">主主机</em>，将您的开发主机(很可能是您正在阅读本文的笔记本电脑或台式机)称为<em class="mb">本地计算机</em>。如果您使用的是云调配的虚拟机，您将没有主机。你将不得不弄清楚在你的云控制面板或者作为主要主机的本地计算机上的命令行中需要发生什么(比如用于谷歌云平台的<code class="fe lx ly lz ma b">gcloud</code>命令)。</p><p id="a3e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先需要的是<code class="fe lx ly lz ma b">kubeadm/kubectl/kubelet</code>命令。我将继续关注<a class="ae ky" href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" rel="noopener ugc nofollow" target="_blank">官方安装</a>，但特别是针对Ubuntu 18.04 VM，并添加任何需要澄清或不太适用的内容。</p><p id="8291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要准备新虚拟机进行安装，首先要确保swap处于关闭状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="c100" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果要创建多个节点，您必须确保创建的虚拟机具有唯一的MAC地址和产品UUIDs。KVM为您做到了这一点。可能大多数虚拟机都是唯一的，除非您克隆现有的虚拟机。然后通过在您的<code class="fe lx ly lz ma b">/etc/modules-load.d/modules.conf</code>文件中添加几行来启用桥接和覆盖:</p><pre class="kj kk kl km gt mc ma md me aw mf bi"><span id="206b" class="mg mh it ma b gy mi mj l mk ml">overlay<br/>br_netfilter</span></pre><p id="c276" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并在您的<code class="fe lx ly lz ma b">/etc/sysctl.conf</code>文件中添加几行:</p><pre class="kj kk kl km gt mc ma md me aw mf bi"><span id="fc2f" class="mg mh it ma b gy mi mj l mk ml"># added for kubernetes bridge<br/>net.bridge.bridge-nf-call-ip6tables = 1<br/>net.ipv4.ip_forward                 = 1<br/>net.bridge.bridge-nf-call-iptables  = 1</span></pre><p id="57b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后重新启动你的虚拟机，使其生效。</p><p id="6bce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的新虚拟机应该没有<code class="fe lx ly lz ma b">iptables</code>规则，您可以使用<code class="fe lx ly lz ma b">sudo iptables -L</code>命令来验证这一点，该命令应该列出一个空的规则集:</p><pre class="kj kk kl km gt mc ma md me aw mf bi"><span id="e686" class="mg mh it ma b gy mi mj l mk ml">Chain INPUT (policy ACCEPT)<br/>target     prot opt source               destination</span><span id="f3d3" class="mg mh it ma b gy mm mj l mk ml">Chain FORWARD (policy ACCEPT)<br/>target     prot opt source               destination</span><span id="0697" class="mg mh it ma b gy mm mj l mk ml">Chain OUTPUT (policy ACCEPT)<br/>target     prot opt source               destination</span></pre><p id="4124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有妄想症，你可以将端口限制在官方安装中列出的端口，但这是一个地雷，我不会踩在上面。</p><p id="ad11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为Kubernetes是一个容器编排系统，我们需要一个它可以编排的容器系统。您可以使用许多容器系统，但是我们将使用<a class="ae ky" href="https://containerd.io/" rel="noopener ugc nofollow" target="_blank"> containerd </a>。这是Ubuntu 18.04的两行安装:</p><pre class="kj kk kl km gt mc ma md me aw mf bi"><span id="8547" class="mg mh it ma b gy mi mj l mk ml">sudo apt-get update <br/>sudo apt-get install containerd</span></pre><p id="c0e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这应该会产生<code class="fe lx ly lz ma b">/var/run/containerd/containerd.sock</code>。</p><p id="af78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在可以安装<code class="fe lx ly lz ma b">kubeadm/kubectl/kubelet</code>了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="9b07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lx ly lz ma b">kubeadm</code>包是Kubernetes的主要API。<code class="fe lx ly lz ma b">kubectl</code>包是Kubernetes API的命令行接口。并且<code class="fe lx ly lz ma b">kubelet</code>包与容器系统接口以运行pod。</p><p id="d08d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于术语的几句话。Kubernetes中的整个实体被称为<em class="mb">集群</em>。每个集群可以有一个或多个<em class="mb">节点</em>。有两种类型的节点，<em class="mb">控制平面，</em>和<em class="mb">工作者</em>。必须有且只有一个控制平面节点。(实际上，在一个HA设置中，负载均衡器前面可以有多个控制平面。)控制平面节点就是我们现在正在研究的。如果我们稍后添加工作节点，所有这些步骤都必须重复。</p><p id="e7f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试<code class="fe lx ly lz ma b">kubeadm</code>可以访问我们之前安装的<code class="fe lx ly lz ma b">containerd</code>，我们可以运行<code class="fe lx ly lz ma b">sudo kubeadm config images pull</code>。它会花一些时间提取一些它需要的图像，我们知道它可以和<code class="fe lx ly lz ma b">containerd</code>对话。</p><p id="1466" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要提前考虑一下。Kubernetes需要一个容器网络接口，或<code class="fe lx ly lz ma b">CNI</code>，这样所有的pod就可以互相通信。但是为了初始化集群，我们需要传递一些关于它将如何利用<code class="fe lx ly lz ma b">CNI</code>的信息。所以我们需要决定使用哪一个<code class="fe lx ly lz ma b">CNI</code>，因为有好几个。我打算选法兰绒，因为我住在西雅图。默认情况下，法兰绒使用CIDR 10 . 244 . 0 . 0/16，所以我们必须将它传递到<code class="fe lx ly lz ma b">init</code>命令中。让我们试一试，看看会发生什么。</p><pre class="kj kk kl km gt mc ma md me aw mf bi"><span id="d607" class="mg mh it ma b gy mi mj l mk ml">sudo kubeadm init --pod-network-cidr=10.244.0.0/16</span></pre><p id="3f9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功！但现在不是沾沾自喜的时候。对于一个节点，我们还有一些步骤要做。在<code class="fe lx ly lz ma b">init</code>命令的末尾有一些重要的步骤。如果您计划稍后创建worker节点，请务必复制打印的<code class="fe lx ly lz ma b">join</code>命令，以便稍后参考。列出的令牌仅持续24小时，因此如果您想在此之后创建一个新节点，您必须使用命令<code class="fe lx ly lz ma b">kubeadm token create</code>获得一个新令牌。</p><p id="ef32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把配置放在一个公开的地方供<code class="fe lx ly lz ma b">kubectl</code>使用。</p><pre class="kj kk kl km gt mc ma md me aw mf bi"><span id="bd90" class="mg mh it ma b gy mi mj l mk ml">mkdir -p $HOME/.kube<br/>sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<br/>sudo chown $(id -u):$(id -g) $HOME/.kube/config</span></pre><p id="5e9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建<code class="fe lx ly lz ma b">kubectl</code>使用的默认配置文件。要进行验证，运行<code class="fe lx ly lz ma b">kubectl config view</code>。</p><p id="9c77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自<code class="fe lx ly lz ma b">init</code>命令的输出还指示您部署您的<code class="fe lx ly lz ma b">CNI</code>，我们已经决定它将是法兰绒。它们有你在GitHub上需要的配置，所以现在就应用它们:</p><pre class="kj kk kl km gt mc ma md me aw mf bi"><span id="98fa" class="mg mh it ma b gy mi mj l mk ml">kubectl apply -f <a class="ae ky" href="https://raw.githubusercontent.com/coreos/flannel/2140ac876ef134e0ed5af15c65e414cf26827915/Documentation/kube-flannel.yml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/coreos/flannel/2140ac876ef134e0ed5af15c65e414cf26827915/Documentation/kube-flannel.yml</a></span></pre><p id="4c2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，看看您能否列出使用<code class="fe lx ly lz ma b">kubectl get all --all-namespaces</code>运行的所有内容。你应该得到一份通常嫌疑人的名单。将配置文件复制到主要主机，您应该能够在那里访问您的新集群。我将把它复制到<code class="fe lx ly lz ma b">~/.kube/kube1config</code>文件并设置<code class="fe lx ly lz ma b">KUBECONFIG</code>环境变量，这样我就不必与现有的配置文件合并。现在在主机上运行<code class="fe lx ly lz ma b">kubectl get all --all-namespaces</code>应该会给出相同的清单。</p><p id="2229" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我将重复本文中的所有步骤，直到<code class="fe lx ly lz ma b">kubeadm init</code>。我做的时候你可以喝杯咖啡。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/9d0840848df313d1308ce23b257451a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gj6LuayDEy15gIhRynPhIA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">香榭丽舍大街上的浓咖啡，作者</p></figure><p id="dffb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我回来了。我创建了一个名为“kube2”的新虚拟机，并安装了<code class="fe lx ly lz ma b">contianerd</code>、<code class="fe lx ly lz ma b">kubeadm</code>、<code class="fe lx ly lz ma b">kubectl</code>和<code class="fe lx ly lz ma b">kubelet</code>，和以前一样。现在我们不用<code class="fe lx ly lz ma b">kubeadm init</code>命令，而是使用之前<code class="fe lx ly lz ma b">kubeadm init</code>中保存的<code class="fe lx ly lz ma b">kubeadm join</code>命令。</p><p id="d3f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们检查一下，用<code class="fe lx ly lz ma b">kubectl get nodes</code>列出主机上的节点。</p><pre class="kj kk kl km gt mc ma md me aw mf bi"><span id="8386" class="mg mh it ma b gy mi mj l mk ml">NAME    STATUS   ROLES    AGE   VERSION<br/>kube1   Ready    master   73m   v1.18.1<br/>kube2   Ready    &lt;none&gt;   65s   v1.18.1</span></pre><p id="6584" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次成功！</p><p id="bc71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还有几块拼图需要添加。当你通过像Minikube这样的一体化安装程序安装时，所有这些组件都包括在内，但我们必须手动完成。我们需要一些存储、容器注册表和某种形式的入口或负载平衡器。我将在下一篇文章中解决这些问题。</p></div></div>    
</body>
</html>