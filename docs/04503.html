<html>
<head>
<title>JavaScript Best Practices — Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—类</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-best-practices-classes-1f1e8b453c8?source=collection_archive---------3-----------------------#2020-04-17">https://betterprogramming.pub/javascript-best-practices-classes-1f1e8b453c8?source=collection_archive---------3-----------------------#2020-04-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bca0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用默认参数和属性快捷键，清理JavaScript代码很容易</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eabd0f7a1738a4620570d45e7855af40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yK47-iBMN6zlL_Gj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">金伯利农民在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="1de0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用默认参数和属性缩写，清理我们的JavaScript代码很容易。</p><p id="1073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究创建类的最佳实践。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0b19" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">ES6课程基础</h1><p id="1f30" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了使JavaScript的原型继承模型不那么混乱，ES6中引入了类语法。</p><p id="dd2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它有<code class="fe mz na nb nc b">constructor</code>、实例变量和方法，就像Java等语言中的类一样，但是它们的行为不同。</p><p id="0256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以通过编写以下代码来创建一个类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5eab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有了<code class="fe mz na nb nc b">name</code>实例变量和<code class="fe mz na nb nc b">speak</code>方法。<code class="fe mz na nb nc b">this</code>是类本身的实例。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1803" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Getters和Setters</h1><p id="1c22" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Getters是只返回值的方法，而setters是让我们为实例变量设置值的方法。</p><p id="f575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们让我们以一种受控的方式来做，而不是直接访问实例变量。</p><p id="b0c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以向类中添加getters和setters，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a149" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些getters和setters，我们可以编写下面的代码来获取<code class="fe mz na nb nc b">name</code>:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="ef75" class="nj md it nc b gy nk nl l nm nn">const person = new Person('joe');<br/>console.log(person.name);</span></pre><p id="e68b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并设置<code class="fe mz na nb nc b">name</code>:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="fc37" class="nj md it nc b gy nk nl l nm nn">const person = new Person('joe');<br/>person.name = 'jane';<br/>console.log(person.name);</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f061" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">子或子类</h1><p id="fc59" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们也可以用关键字<code class="fe mz na nb nc b">extends</code>创建子类。例如，我们可以写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="50c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了一个<code class="fe mz na nb nc b">Dog</code>类，它覆盖了<code class="fe mz na nb nc b">Animal</code>类的<code class="fe mz na nb nc b">speak</code>方法。</p><p id="8139" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们调用<code class="fe mz na nb nc b">Dog</code>的<code class="fe mz na nb nc b">constructor</code>中带有<code class="fe mz na nb nc b">super</code>的父构造函数，调用<code class="fe mz na nb nc b">super.speak</code>来调用<code class="fe mz na nb nc b">Animal</code>的<code class="fe mz na nb nc b">speak</code>方法。</p><p id="8f5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这比旧的继承构造函数语法要干净得多。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ec0b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">静态方法和属性</h1><p id="8857" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以通过使用<code class="fe mz na nb nc b">static</code>关键字给一个类添加静态属性。</p><p id="8994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做将有助于我们向它添加一个由所有实例共享的属性。</p><p id="741d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="f783" class="nj md it nc b gy nk nl l nm nn">class Dog {<br/>  static type() {<br/>    return 'dog';<br/>  }<br/>}</span></pre><p id="04de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们可以把它作为静态方法调用如下:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="7fdd" class="nj md it nc b gy nk nl l nm nn">console.log(Dog.type())</span></pre><p id="cd70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建静态属性，我们编写以下代码:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="506b" class="nj md it nc b gy nk nl l nm nn">class Dog {}<br/>Dog.type = 'dog';</span><span id="43af" class="nj md it nc b gy no nl l nm nn">console.log(Dog.type);</span></pre><p id="22d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将<code class="fe mz na nb nc b">type</code>属性设置为<code class="fe mz na nb nc b">'dog'</code>，它在所有实例中共享。</p><p id="a74b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种语法是有效的，因为类只是函数，函数和JavaScript中的其他对象一样。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7c17" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">私有字段</h1><p id="dc94" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript的未来版本也可以让我们定义私有类字段。在构造函数中没有类似的东西。</p><p id="6713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们由字段名前的<code class="fe mz na nb nc b">#</code>符号表示。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="251c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="5357" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以用类语法定义构造函数，使它们看起来比构造函数更容易理解。</p><p id="14e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些类看起来类似于Java类，但本质上行为非常不同。在我们使用它之前，我们必须理解其潜在的行为。这意味着我们应该在使用JavaScript类之前理解原型继承。</p></div></div>    
</body>
</html>