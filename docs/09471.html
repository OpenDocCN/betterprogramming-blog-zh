<html>
<head>
<title>Unit Testing in Go Language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go语言中的单元测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unit-testing-in-go-language-using-mocks-3b873ce1348d?source=collection_archive---------3-----------------------#2021-08-30">https://betterprogramming.pub/unit-testing-in-go-language-using-mocks-3b873ce1348d?source=collection_archive---------3-----------------------#2021-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="91fb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及如何使用模拟</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2f28a2faa2e2d41ca976cb5181274fa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*enw5VCrZM4fPDsF7"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="8c95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单元测试在软件开发中起着至关重要的作用。对程序中的每个代码块进行单元测试总是更好。在这里，我们将讨论以下主题:</p><ol class=""><li id="62cd" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">单元测试的几个优点</li><li id="fa18" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">编写单元测试的示例程序</li><li id="3238" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">编写单元测试之前要记住的几点</li><li id="9d96" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">编写单元测试</li></ol><h1 id="c68a" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">单元测试的几个优点</h1><p id="aacc" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">由于单元测试有很多优点，让我们列举其中的几个:</p><ol class=""><li id="ebd8" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">在软件开发中，变化是不变的。单元测试有助于在添加新功能时及早发现现有功能的缺陷。</li><li id="c6ff" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">单元测试有助于开发人员尽早解决任何bug，因为他们可以更好地了解正在开发的内容和已经破坏的内容，而不是等到测试团队在后期阶段报告bug。</li></ol><p id="5888" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个介绍，让我们转向用Go语言实现单元测试用例。</p><h1 id="147e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">示例程序</strong></h1><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="f046" class="ni mh iq ne b gy nj nk l nl nm"><br/>type Client interface {<br/>   GetSum(int, int) (int, error)<br/>}</span><span id="3309" class="ni mh iq ne b gy nn nk l nl nm">type myStruct struct {<br/>}</span><span id="73fd" class="ni mh iq ne b gy nn nk l nl nm">func (input myStruct) GetSum( num1, num2 int) (int, error) {<br/>   return num1+num2, nil<br/>}</span></pre><p id="14fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们定义了一个接口<code class="fe no np nq ne b">Client</code>，其中只定义了一个<code class="fe no np nq ne b">GetSum</code>函数，我们还定义了一个名为<code class="fe no np nq ne b">myStruct</code>的结构，它实现了<code class="fe no np nq ne b">Client</code>接口。</p><p id="3cab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们说一个结构实现了一个接口时，意思是这个结构应该实现接口中定义的所有方法，在我们的例子中是<code class="fe no np nq ne b">GetSum</code>函数。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="ee4f" class="ni mh iq ne b gy nj nk l nl nm">func processInput(input Client, num1, num2 int) (int, error){<br/>   res, err := input.GetSum(num1, num2)<br/>   if err != nil{<br/>      return 0, err<br/>   }<br/>   return res, nil<br/>}</span></pre><p id="2d52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们定义了一个名为<code class="fe no np nq ne b">processInput</code>的函数，它将一个<code class="fe no np nq ne b">Client</code>接口和两个数字作为输入，并调用与输入接口相关联的<code class="fe no np nq ne b">GetSum</code>方法。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="cc83" class="ni mh iq ne b gy nj nk l nl nm">func main() {<br/>   myVariable := myStruct{}<br/>   num1 := 1<br/>   num2 := 2<br/>   res, err := processInput(myVariable, num1,num2)<br/>   if err != nil{<br/>      panic(err)<br/>   }else {<br/>      fmt.Printf("Sum of %d and %d is  %d\n", num1, num2, res)<br/>   }<br/>}</span></pre><p id="5615" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后从<code class="fe no np nq ne b">main</code>函数我们调用<code class="fe no np nq ne b">processInput</code>函数我们适当的参数。完整的程序可以在我的GitHub上找到。</p><h1 id="50a0" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">编写单元测试时要记住的几点</h1><p id="5224" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在进入单元测试的实际实现之前，我们应该非常清楚以下几点:</p><h2 id="0859" class="ni mh iq bd mi nr ns dn mm nt nu dp mq lf nv nw ms lj nx ny mu ln nz oa mw ob bi translated"><strong class="ak"> 1。定义一个单位的范围</strong></h2><p id="d374" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">有时确定一个单元的范围变得更加困难，导致它一次测试多个单元。</p><p id="6a8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要遵循的简单规则是，任何结果不在我们控制范围内的代码工作流都不要包含在单元测试中。</p><p id="1b13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，函数<code class="fe no np nq ne b">processInput</code>通过<a class="ae kv" href="https://github.com/Karthik-K-N/goUT/blob/07a5961ba7a65ceccc4e5eb4ce9de9497bbcd368/main.go#L24" rel="noopener ugc nofollow" target="_blank">调用</a>到<code class="fe no np nq ne b">GetSum</code>方法来计算总和，我们不应该为总和是如何计算的而烦恼，我们应该关注方法<code class="fe no np nq ne b">GetSum</code>返回的结果。</p><h2 id="72cb" class="ni mh iq bd mi nr ns dn mm nt nu dp mq lf nv nw ms lj nx ny mu ln nz oa mw ob bi translated"><strong class="ak"> 2 </strong>。<strong class="ak">照顾依赖性</strong></h2><p id="95b9" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">如前所述，我们应该只关心外部API返回的结果，我们需要根据外部API所有可能的返回值来测试我们的程序，这就需要我们用我们想要的返回值来模拟外部API的行为。</p><p id="f339" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在go语言中，这可以通过手工覆盖接口方法或使用模拟来轻松实现。当接口很大，并且提供各种内置方法来改变行为时，模拟是最适合的。</p><h2 id="534a" class="ni mh iq bd mi nr ns dn mm nt nu dp mq lf nv nw ms lj nx ny mu ln nz oa mw ob bi translated"><strong class="ak"> 3。定义简单测试功能或方法</strong></h2><p id="d5a7" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在编写程序时，有时我们需要预见未来，以使代码易于测试</p><p id="f235" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，函数<code class="fe no np nq ne b"><a class="ae kv" href="https://github.com/Karthik-K-N/goUT/blob/07a5961ba7a65ceccc4e5eb4ce9de9497bbcd368/main.go#L23" rel="noopener ugc nofollow" target="_blank">processInput</a></code> <strong class="ky ir"> </strong>我们将<code class="fe no np nq ne b">Client</code>接口作为第一个参数传递，这允许我们在后面的例子中传递任何自定义接口，该接口具有适合我们要求的方法:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="5f48" class="ni mh iq ne b gy nj nk l nl nm">func main() {<br/>   myVariable := myStruct{}<br/>   num1 := 1<br/>   num2 := 2<br/>   myVariable.GetSum(num1, num2)<br/>   res, err := myVariable.GetSum(num1, num2)<br/>   if err != nil{<br/>      panic(err)<br/>   }else {<br/>      fmt.Printf("Sum of %d and %d is  %d\n", num1, num2, res)<br/>   }<br/>}</span></pre><p id="d28e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们直接调用<code class="fe no np nq ne b">GetSum</code>方法，而不是通过<code class="fe no np nq ne b">processInput</code>计算结果。但是这种方法可以工作，但是不能提供额外的灵活性来测试我们的程序。</p><h1 id="3b5a" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">编写单元测试</h1><p id="11d0" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在Go语言中，为了开始测试，我们只需要一个名为<code class="fe no np nq ne b">testing</code>的包，尽管有许多其他包可以用来丰富测试，但是为了简单起见，让我们考虑使用<code class="fe no np nq ne b">testing</code>包的例子。</p><h2 id="f684" class="ni mh iq bd mi nr ns dn mm nt nu dp mq lf nv nw ms lj nx ny mu ln nz oa mw ob bi translated">简单的单元测试</h2><p id="18c4" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">首先，让我们编写一个简单的单元测试。</p><p id="69b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们用1和2个输入调用<code class="fe no np nq ne b">processInput</code>方法，并期望3个输出。如果返回的结果不是预期的3，我们就没有通过测试。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="f269" class="ni mh iq ne b gy nj nk l nl nm">func TestProcessInput(t *testing.T)  {<br/>   myVariable := myStruct{}<br/>   res, err := processInput(myVariable, 1,2)<br/>   if err != nil {<br/>      t.Fatal(err)<br/>   }<br/>   if res != 3{<br/>      t.Fatalf("Expected result %d got %d", 3, res)<br/>   }<br/>}</span></pre><h2 id="f071" class="ni mh iq bd mi nr ns dn mm nt nu dp mq lf nv nw ms lj nx ny mu ln nz oa mw ob bi translated">2.<strong class="ak">表格法单元测试</strong></h2><p id="e6c1" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">当我们想要测试一些输入组合的功能时，上面简单的单元测试例子是很好的。</p><p id="db1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，当我们定义案例和输入，并迭代它们中的每一个来运行测试时，下面的测试表格方法更好。为此，我们利用了由<code class="fe no np nq ne b">testing</code>包提供的函数<code class="fe no np nq ne b">Run</code>。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="b205" class="ni mh iq ne b gy nj nk l nl nm">func TestProcessInputTabularMethod(t *testing.T) {<br/><br/>   cases := []struct {<br/>      name string<br/>      num1 int<br/>      num2 int<br/>      res  int<br/>      expectError bool<br/>   }{<br/>      {<br/>         name: "Case 1",<br/>         num1: 1,<br/>         num2: 2,<br/>         res:  3,<br/>         expectError: false,<br/>      },<br/>      {<br/>         name: "Case 2",<br/>         num1: 100,<br/>         num2: 200,<br/>         res:  300,<br/>         expectError: false,<br/>      },<br/>   }<br/><br/>   for _, tc := range cases {<br/>      t.Run(tc.name, func(t *testing.T) {<br/>         myVariable := myStruct{}<br/>         res, err := processInput(myVariable, tc.num1,tc.num2)<br/>         if err != nil &amp;&amp; !tc.expectError{<br/>            t.Fatal(err)<br/>         }<br/>            if res != tc.res{<br/>               t.Fatalf("Expected result %d got %d", tc.res, res)<br/>            }<br/>      })<br/>   }<br/>}</span></pre><h2 id="ee32" class="ni mh iq bd mi nr ns dn mm nt nu dp mq lf nv nw ms lj nx ny mu ln nz oa mw ob bi translated">3.<strong class="ak">接口函数自定义方法测试</strong></h2><p id="faab" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">如前所述，在编写单元测试时，我们必须注意依赖关系。我们的<code class="fe no np nq ne b">processInput</code>函数有如下签名:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="4f82" class="ni mh iq ne b gy nj nk l nl nm">func processInput(input client.Client, num1, num2 int) (int, error)</span></pre><p id="9d37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数的第一个参数是<code class="fe no np nq ne b">Client</code>接口，它提供了额外的能力，可以将任何满足<code class="fe no np nq ne b">Client</code>接口的结构传递给该函数，因此我们可以为<code class="fe no np nq ne b">Client</code>接口函数添加任何自定义行为来进行测试。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="f777" class="ni mh iq ne b gy nj nk l nl nm">type testStruct struct {<br/><br/>}<br/><br/>func (input testStruct) GetSum( num1, num2 int) (int, error) {<br/>   return 0, fmt.Errorf(" Intentional error ")<br/>}<br/><br/>func TestProcessInputCustomMethods(t *testing.T)  {<br/>   myVariable := testStruct{}<br/>   res, err := processInput(myVariable, 1,2)<br/>   if err == nil {<br/>      t.Fatal("Expecting error! got nil")<br/>   }<br/>   if res != 0{<br/>      t.Fatalf("Expected 0 found %d", res)<br/>   }<br/>}</span></pre><p id="0955" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们定义了一个名为<code class="fe no np nq ne b">testStruct</code>的结构，并针对它定义了<code class="fe no np nq ne b">GetSum</code>方法，这个方法总是返回一个错误。这有助于测试<code class="fe no np nq ne b">processInput</code>功能的负面情况。</p><h2 id="9097" class="ni mh iq bd mi nr ns dn mm nt nu dp mq lf nv nw ms lj nx ny mu ln nz oa mw ob bi translated">4.<strong class="ak">生成模拟方法</strong></h2><p id="2fbc" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">定义自定义接口方法将有助于测试，但是当接口非常大时，我们不能花时间定义所有的方法和每个方法的各种行为。</p><p id="1b96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述问题可以通过使用模拟来解决。我们将使用包<code class="fe no np nq ne b">mockgen</code>为我们的接口<code class="fe no np nq ne b">Client</code>创建一个模拟方法。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="f4d4" class="ni mh iq ne b gy nj nk l nl nm">func TestProcessInputMocks(t *testing.T){<br/>   mockCtrl := gomock.NewController(t)<br/>   mockClient := mock.NewMockClient(mockCtrl)<br/><br/>   mockClient.EXPECT().GetSum(11,2).Return(3, nil)<br/>   //mockClient.EXPECT().GetSum(gomock.Any(),gomock.Any()).Return(3, fmt.Errorf("Intention Error "))<br/>   //mockClient.EXPECT().GetSum(1,2).Return(33, nil)<br/>   //mockClient.EXPECT().GetSum(1,2).Return(3, nil).Times(2)<br/><br/>   res, err := processInput(mockClient, 11, 2)<br/>   if err != nil {<br/>      t.Fatal(err)<br/>   }<br/>   if res != 3{<br/>      t.Fatalf("Expected result %d got %d", 3, res)<br/>   }<br/>}</span></pre><p id="aaf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Mocks为我们提供了各种额外的测试特性。简单地说，我们必须用期望的输入和<code class="fe no np nq ne b">RETURN</code>值为接口函数定义<code class="fe no np nq ne b">EXPECT</code>方法。</p><p id="1f70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多关于mock的特性可以在<a class="ae kv" href="https://github.com/golang/mock" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>