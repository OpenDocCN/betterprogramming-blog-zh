<html>
<head>
<title>Parallax Scrolling With Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Jetpack合成的视差滚动</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/tldr-parallax-scrolling-with-jetpack-compose-ea2fe092a718?source=collection_archive---------5-----------------------#2022-05-15">https://betterprogramming.pub/tldr-parallax-scrolling-with-jetpack-compose-ea2fe092a718?source=collection_archive---------5-----------------------#2022-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2f11" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以不同的方式移动物体和移动其他物体的艺术。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/349fa3be397ca0446fe16347cfa6d525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P5IBYiEVda73LS3P"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/es/@jruscello?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰西卡·鲁斯切洛</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="17d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我爱你。对不起，那是我试图用英语口音发音说“你好”。没有吗？再试一次，特别强调L？还是没有？好吧，我讨厌口音。让我们继续Android开发。</p><p id="4a06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我不是作曲专家来告诉你怎么做。我是一名坚定的Android开发人员，正在过渡到Compose，并对不得不重新使用一些旧技巧感到焦虑。我有一些想法，我想记录一些概念证明可能会很好，因为我把它们敲出来，并与任何关心它们的人分享。因此，在您DR之前，因为这是TL，所以让我向您展示我们将实现的目标:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/460d84c519a9a7c9faa13d2d6543345a.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/1*3hr4wG6sDEiEXKKlroSjCw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">非常可爱的有平行名字的彩色车辆。</p></figure><p id="7be1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你可能会想，“Hellajoey，这看起来很棒，但你也喜欢彩色汽车或其他东西吗？”答案是“不”,但我确实喜欢不用走路就能去的地方。拍我加了一点颜色。</p><p id="ce51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我总是有点哈……—讨厌是一个很强烈的词—当我浏览代码教程时，会有点沮丧，突然之间，教程项目被一堆嵌入的图片塞满了。然后我得自己去找一堆图像。我哈...它。</p><p id="8951" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我的目标是确保我的Android教程可以在Android Studio中完全从零开始生成，这将不时地给你一些颜色鲜艳的车辆图像。</p><p id="9bc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Android Studio中创建彩色图标并不复杂，这篇文章在我们开始之前就已经是TLDR的了，所以我在这里又写了一篇文章<a class="ae kv" href="https://medium.com/@hellajoey/tldr-how-to-make-quick-sample-images-in-android-studio-fe77e21c8ef0" rel="noopener"/>来解释我是如何为那些想把它放在一边的人做的。</p><h1 id="2292" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">创建项目</h1><p id="613c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">好了，现在继续创建一个新的空编写活动，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/e0b2af7639b3c97a9ef361b7e98f3e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WI9nY7DEXO3RCTng6m-Dmw.png"/></div></div></figure><p id="8660" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">试一试。如果不行，就想办法。</p><p id="f9e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开您的<code class="fe mr ms mt mu b">MainActivity.kt</code>文件，清除“问候”代码或默认实现中的任何“Hello World”模板代码。它应该看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="e0f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在<strong class="ky ir"> </strong>我们要为一些有名字的东西创建一个<code class="fe mr ms mt mu b">LazyRow</code>。如你所知，我的东西将是可爱的，彩色车辆。如果你跟着我，再一次，你可以去<a class="ae kv" href="https://medium.com/@hellajoey/tldr-how-to-make-quick-sample-images-in-android-studio-fe77e21c8ef0" rel="noopener">这里</a>看看如何创建这些图像。</p><p id="a125" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要一个容器来存放单个车辆数据，所以我创建了这个数据类:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="9c25" class="nb lu iq mu b gy nc nd l ne nf">data class Vehicle(<br/>   val name: String,<br/>   val imageId: Int,<br/>   val color: Color,<br/>)</span></pre><p id="93c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想放哪就放哪。我现在要在<code class="fe mr ms mt mu b">onCreate()</code>中添加一个车辆列表，这样我们就有东西可以滚动了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="ee99" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">常规作曲材料</h1><p id="d8c5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在让我们添加一个标准的<code class="fe mr ms mt mu b">LazyRow</code>实现。这是纯香草味的。此外，我只是将组件添加到<code class="fe mr ms mt mu b">MainActivity</code>中以保持简单(单个文件演示，宝贝！).</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="51c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你运行它，它应该是这样的。很漂亮，对吧？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/01d9e38070d72720b815f06c5c1c9c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*tz8b3GOXOrx0-aiQnDDQ5Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">小汽车行。</p></figure><h1 id="fabd" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">一些准备</h1><p id="82ae" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">好的，现在让我们在进入视差部分之前做一些清理和准备。作为铺垫，我们将需要一些复杂的数据位来配置视差效果。</p><p id="e274" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我将创建一个<code class="fe mr ms mt mu b">VehicleUiInfo</code>数据类来包含上述数据。</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="4133" class="nb lu iq mu b gy nc nd l ne nf">data class VehicleUiInfo(val itemWidthDp: Float) {<br/>   <br/>   companion object {<br/>      <br/>      fun create(itemWidthDp: Float): VehicleUiInfo {<br/>         return VehicleUiInfo(itemWidthDp)<br/>      }<br/>   }<br/>}</span></pre><p id="f692" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这对于项目宽度来说绝对是多余的——这是我们目前所需要的——但是我们以后会添加更多的细节。</p><h2 id="1581" class="nb lu iq bd lv ng nh dn lz ni nj dp md lf nk nl mf lj nm nn mh ln no np mj nq bi translated">组合局部模式</h2><p id="5a59" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在我们还没有一个很深的可组合树，但是不管怎样，让我们从<code class="fe mr ms mt mu b">CompositionLocal</code>模式开始吧。这真的很棒。</p><p id="e1e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不打算深入讨论所有的具体细节——您可以通过谷歌搜索细节——但我们的想法是，我们可以预先定义数据，并在需要时访问它，而不是将某些复杂的数据传递给所有的组件。<code class="fe mr ms mt mu b">CompositionLocal</code>比这更强大，但我们将只使用这个最小的功能。</p><p id="fc81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要开始，请创建:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="d936" class="nb lu iq mu b gy nc nd l ne nf">val <em class="nr">LocalVehicleUiInfo </em>= <em class="nr">staticCompositionLocalOf </em><strong class="mu ir">{ </strong>VehicleUiInfo(0f) <strong class="mu ir">}</strong></span></pre><p id="9438" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并将它放在可组合函数之上。我们必须在创建时提供一个缺省值，但是一旦我们解决了这个问题，我们就会用我们想要的值来替换它，所以现在就用一个哑弹吧。</p><p id="dec1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将在<code class="fe mr ms mt mu b">onCreate()</code>中创建真正的<code class="fe mr ms mt mu b">VehicleUiInfo</code>对象，并将其设置为<code class="fe mr ms mt mu b">LocalVehicleInfo</code>提供的值。您的<code class="fe mr ms mt mu b">MainActivity</code>现在应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="2668" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以像这样使用<code class="fe mr ms mt mu b">VehicleItem()</code>中的<code class="fe mr ms mt mu b">vehicleUiInfo.itemWidthDp</code>值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="bbe3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正义。现在事情变得更大、更好、更坏。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/5399797c61e5f56d0b9d3e07c2847298.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*cYGhbXtonjuZpvrJ10F7uA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">更大的车辆排。</p></figure><p id="1252" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您也可以使用CompositionLocal访问您的<code class="fe mr ms mt mu b">vehicleList</code>对象，但是主要状态对象应该通过参数传递。深入CompositionLocal了解更多信息。</p><h2 id="e5f6" class="nb lu iq bd lv ng nh dn lz ni nj dp md lf nk nl mf lj nm nn mh ln no np mj nq bi translated">ConstraintLayout(是，用于合成)</h2><p id="fdac" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">接下来，让我们将这一行放在屏幕的中心。是时候向你介绍我最好的朋友之一ConstraintLayout先生或夫人了。好吧，你可能已经从基于视图的布局中知道了他们的表亲，但是不要错过通过使用这个版本的Compose来继续这个令人敬畏的功能。</p><p id="ccd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，将这个库引用添加到您的模块级<code class="fe mr ms mt mu b">build.gradle</code>文件中:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="b2d4" class="nb lu iq mu b gy nc nd l ne nf">implementation “androidx.constraintlayout:constraintlayout-compose:1.0.0”</span></pre><p id="9cdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们将把可组合的图像包装到可在<em class="nr"> VehicleItem() </em>函数中组合的ConstraintLayout中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="5e43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里需要注意一些事情:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="e8d0" class="nb lu iq mu b gy nc nd l ne nf">val (image) = createRefs()</span></pre><p id="b82c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">允许您引用您的组件，这样您就可以在<code class="fe mr ms mt mu b">ConstraintLayout</code>中将它们相互关联起来。</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="d8dc" class="nb lu iq mu b gy nc nd l ne nf">.<em class="nr">constrainAs</em>(image) <strong class="mu ir">{<br/>   </strong>top.linkTo(parent.top)<br/>   bottom.linkTo(parent.bottom)<br/><strong class="mu ir">}</strong>,</span></pre><p id="505e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将我们的图像在其父图像(具有全屏高度)中垂直居中。</p><h2 id="4a35" class="nb lu iq bd lv ng nh dn lz ni nj dp md lf nk nl mf lj nm nn mh ln no np mj nq bi translated">添加可组合文本</h2><p id="46d5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在是时候将我们的车辆名称添加到布局中了。在可在<code class="fe mr ms mt mu b">VehicleItem()</code>中组合的图像下插入以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6717" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，为这个可组合到<code class="fe mr ms mt mu b">ContraintLayout</code>引用的文本添加一个名称(是的，我将我的命名为“name”):</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="4366" class="nb lu iq mu b gy nc nd l ne nf">val (image, name) = createRefs()</span></pre><p id="25f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码将可组合文本居中放置在可组合图像的下方:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="7444" class="nb lu iq mu b gy nc nd l ne nf">.<em class="nr">constrainAs</em>(name) <strong class="mu ir">{<br/>   </strong>start.linkTo(image.start)<br/>   end.linkTo(image.end)<br/>   top.linkTo(image.bottom)<br/><strong class="mu ir">}</strong></span></pre><p id="b747" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但我认为这有点太低了，所以我也提出了一点:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="ef25" class="nb lu iq mu b gy nc nd l ne nf">.<em class="nr">offset </em><strong class="mu ir">{ </strong><em class="nr">IntOffset</em>(x = 0, y = -50) }</span></pre><p id="8717" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您运行该应用程序，您现在应该会看到以下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/4b680561f6cd8b1c8c93ce5870eb8366.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*p2FMVsmYsT4r2rJdzwFEyA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">居中并命名的车辆。</p></figure><p id="cfad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">越来越近了！在我们视差之前还有一件事。</p><h2 id="4a50" class="nb lu iq bd lv ng nh dn lz ni nj dp md lf nk nl mf lj nm nn mh ln no np mj nq bi translated">赶快</h2><p id="d0a8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">按照我的设计，我们希望滚动行为是这样的，中心项目将“捕捉”到位。</p><p id="b2b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在撰写本文时(2022年5月)，我不相信Jetpack对项目“捕捉”有内在支持。这让我很惊讶，所以也许他们确实在内心深处。但是我找不到它，所以我要用克里斯·贝恩斯的非常棒的snapper库。只需将这个引用添加到您的模块级<code class="fe mr ms mt mu b">build.gradle</code>文件中:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="3a04" class="nb lu iq mu b gy nc nd l ne nf">implementation “dev.chrisbanes.snapper:snapper:0.2.0”</span></pre><p id="a646" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后修改您的<code class="fe mr ms mt mu b">VehicleHorizontalScroll()</code>函数，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="5583" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不喜欢理所当然地依赖实验类，但我也怀疑我们应该很快就会有一个一流的公民，snapper功能可用。</p><p id="340d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行它，并确保它的工作。你会注意到，当屏幕启动时，它看起来和前面的图像一样。也就是说，当我们在这一行的两边时，我们没有一个水平居中的中间项目(除非你的手机屏幕宽度“非常”幸运)。在任何捕捉发生之前，您必须开始滚动。我真的很想通过添加缓冲区来解决这个问题，这样第一个项目就开始居中(相应的缓冲区在行尾)，但这将依赖于我们将用于视差效果的一些信息，所以我们稍后将混合这些信息。我们已经等得够久了。</p><h1 id="97f9" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">添加视差效果</h1><p id="c776" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">好了，这是开始变得有点真实的地方。我们要对屏幕的宽度进行数学计算。现在让我们来看看我们实际上在做什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/bbbd470fd2db7e047ff96c4be66f396a.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*v7EI2BsVGFshH8tabia4ig.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">视差图#1。</p></figure><p id="8691" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个项目完全居中时，我们希望它的名称完全居中，但当它向左或向右移动时，我们希望名称更快地向左或向右移动(是的，我知道项目实际上是齐平的，但我认为中间有一些空间看起来更酷。如果他们分开了，一切仍然正常。</p><p id="5382" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们需要做的第一件事是找出一个项目何时完全居中。正如我们在下图中看到的，这将是当项目的x坐标是(屏幕宽度-项目宽度)/ 2时。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/d71eb89585d1238c0257b1fd06a99ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*4a_wLJ1XaMpmQ6A3awVWag.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">居中项目的x坐标。</p></figure><p id="0ef1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们从x = 0开始，然后向右移动(屏幕宽度)/ 2，然后向后移动(项目宽度)/ 2，我们将得到居中项目的x坐标。当然还有:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="38b3" class="nb lu iq mu b gy nc nd l ne nf">(width-of-screen) / 2 - (width-of-item) / 2 = </span><span id="955e" class="nb lu iq mu b gy nu nd l ne nf">(width-of-screen - width-of-item) / 2</span></pre><p id="aa08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们继续将这个值添加到我们的<code class="fe mr ms mt mu b">VehicleUiInfo</code>类中。我们就叫它<code class="fe mr ms mt mu b">xForCenteredItem</code>。然而，要计算它，我们首先需要实际获得屏幕宽度(我们已经有了项目宽度)。有不同的方法可以做到这一点，我建议在应用程序启动时处理一次，以及在启动活动中设置的任何其他配置。</p><h2 id="948e" class="nb lu iq bd lv ng nh dn lz ni nj dp md lf nk nl mf lj nm nn mh ln no np mj nq bi translated">或者…用LocalConfiguration获得屏幕宽度</h2><p id="f8c3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">然而……因为我们试图保持简单，因为我发现了一种使用Compose获得屏幕宽度的新方法，所以我将违背我自己的建议，在我们的<code class="fe mr ms mt mu b">setContent</code>块中随机获取屏幕宽度。这个方法只能在可组合函数的上下文中使用，但它也是一个很棒的一行程序:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="f697" class="nb lu iq mu b gy nc nd l ne nf">screenWidthDp = <em class="nr">LocalConfiguration</em>.current.screenWidthDp.<em class="nr">dp</em>.value</span></pre><p id="dfc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经有了屏幕宽度和项目宽度，将<code class="fe mr ms mt mu b">VehicleUiInfo</code>更新为以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="4c7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实证明，我们实际上需要dp单位和px单位中的<code class="fe mr ms mt mu b">xForCenteredItem</code>值，所以我们不会在每次重组时计算px值，而是将两个值都存储在<code class="fe mr ms mt mu b">vehicleUiInfo</code>中，并且只计算一次。我们将dp值乘以器件密度。</p><p id="7b13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我写得令人困惑——就像我写的那样——就像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3f7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后在<code class="fe mr ms mt mu b">onCreate()</code>方法中弹出<code class="fe mr ms mt mu b">setContent</code>(对于<code class="fe mr ms mt mu b">LocalConfiguration.current</code>是必需的)内的<code class="fe mr ms mt mu b">vehicleUiInfo</code>对象的实例化，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="09e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，你还需要在<code class="fe mr ms mt mu b">LocalVehicleUiInfo</code> <em class="nr">中更新你的默认<code class="fe mr ms mt mu b">vehicleUiInfo</code>。</em></p><h2 id="ffb9" class="nb lu iq bd lv ng nh dn lz ni nj dp md lf nk nl mf lj nm nn mh ln no np mj nq bi translated">简短的放在一边，以缓冲前排和后排</h2><p id="cba7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">让我们暂时搁置，在我们之前讨论的行的两端添加缓冲区。请注意，所述缓冲区的宽度将等于居中项目的x坐标。(这就是为什么我们需要dp版的<code class="fe mr ms mt mu b">xForCenteredItem</code>)。</p><p id="999c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">VehicleHorizontalScroll()</code>中的<code class="fe mr ms mt mu b">LazyRow</code>中，在现有的<code class="fe mr ms mt mu b">items</code>函数前后增加一个<code class="fe mr ms mt mu b">item</code>函数，分别渲染<code class="fe mr ms mt mu b">VehicleScrollBuffer()</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="eacd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们将缓冲区的宽度设置为<code class="fe mr ms mt mu b">xForCenteredItemDp</code>。很好。</p><p id="1f7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您现在运行该应用程序，它应该像这样启动:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/39929a59f9a5385bd1b8f4ebc0596bba.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*TXdtzyYHSzCrnWuqp26eXg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带缓冲器的居中车辆。</p></figure><h1 id="75d6" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">是真正实现并行的时候了</h1><p id="e4fb" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">好了，现在是真正实现并行的时候了。因此，我们希望能够说的是“当项目从屏幕中心偏移时，文本将在同一方向偏移更多。”</p><p id="4a63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多了多少？我们将把它作为一个名为<code class="fe mr ms mt mu b">parallaxOffsetFactor</code>的变量，存储在我们的<code class="fe mr ms mt mu b">vehicleUiInfo</code>对象中，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="a734" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们可以简单地调整它，直到我们喜欢它的样子。在这篇文章顶部的动画中，我将其设置为0.33，如下所示:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="abc9" class="nb lu iq mu b gy nc nd l ne nf">val vehicleUiInfo = VehicleUiInfo.create(<br/>   screenWidthDp = <em class="nr">LocalConfiguration</em>.current.screenWidthDp.<em class="nr">dp</em>.value,<br/>   itemWidthDp = 200f,<br/>   parallaxOffsetFactor = .33f,<br/>)</span></pre><p id="516d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着无论项目相对于中心的绝对偏移量是多少，文本都会将该偏移量的0.33倍添加到自己的偏移量中。它应该以4/3的速度移动。</p><p id="d9dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在此之前，我们首先需要知道该项的偏移量是多少。</p><p id="bdfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们知道<code class="fe mr ms mt mu b">vehicleUiInfo.xForCenteredItemPx</code>是偏移量为0的项目的x坐标(x坐标总是以px为单位)，所以任何给定项目的偏移量都是其x坐标与<code class="fe mr ms mt mu b">vehicleUiInfo.xForCenteredItemPx</code>之间的差值。</p><p id="1f85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给定项目的x坐标是多少？我们将在一个变量中跟踪它，该变量在整个重新组合中记住它的值，如下所示:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="eb59" class="nb lu iq mu b gy nc nd l ne nf">var itemX by remember { mutableStateOf(0f) }</span></pre><p id="8b20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并且我们可以在</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="ccf4" class="nb lu iq mu b gy nc nd l ne nf">Modifier.onGloballyPositioned {}</span></pre><p id="8953" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">图像的属性可以这样组合:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="8d8e" class="nb lu iq mu b gy nc nd l ne nf">Modifier.onGloballyPositioned { itemX = it.positionInWindow().x }</span></pre><p id="fa74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们一直都知道一个项目的x坐标，并且我们知道这个项目从中心的偏移是它的x坐标和<code class="fe mr ms mt mu b">vehicleUiInfo.xForCenteredItemPx</code>之间的差，我们可以定义我们最重要的变量。这是我们期待已久的时刻:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="84b7" class="nb lu iq mu b gy nc nd l ne nf">val offsetFromCenterPx = itemX - vehicleUiInfo.xForCenteredItemPx</span></pre><p id="06e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哒哒。</p><p id="9812" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为<code class="fe mr ms mt mu b">itemX</code>是用<code class="fe mr ms mt mu b">by remember</code>委托的，并且它也是在Image composable中设置的，所以将您的<code class="fe mr ms mt mu b">offsetFromCenterPx</code>声明放在Image composable下面。否则，它将启动一个无用的重组。</p><p id="849d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当项目从中心偏移*更多*时，我们希望文本从中心偏移*更多*倍<code class="fe mr ms mt mu b">vehicleUiInfo.parallaxOffsetFactor</code>。因此，我们将文本偏移修改器更新为:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="1baa" class="nb lu iq mu b gy nc nd l ne nf">.<em class="nr">offset </em><strong class="mu ir">{<br/>   </strong><em class="nr">IntOffset</em>(x = (offsetFromCenterPx <br/>      * vehicleUiInfo.parallaxOffsetFactor).toInt(), y = -50)<br/><strong class="mu ir">}</strong></span></pre><p id="a6b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的<code class="fe mr ms mt mu b">VehicleItem()</code>函数现在应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="4ab2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">戴帽子的猫，就是这样。我们现在有多牛逼？！你的物品名称到处都是并列的！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/fb22ed587c827970c540da858c42a0c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/1*-EfVVMS0yU-HWdFrvH-bnw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">到处游荡。</p></figure><h2 id="9fb6" class="nb lu iq bd lv ng nh dn lz ni nj dp md lf nk nl mf lj nm nn mh ln no np mj nq bi translated">添加文本淡出</h2><p id="bf1f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">要使我们的滚动与这篇文章顶部的动画相匹配，剩下的唯一一步就是让名字从中间逐渐消失。现在的情况并不可怕，但有点奇怪的是，当那些非常可爱的车辆出现在屏幕上时，它们的名字就在屏幕之外，因为它们离它们太远了。</p><p id="0e49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我们将只显示中心项目的名称，当它视差太远时，我们将淡出它。</p><p id="a6b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这部分就简单了。首先，我们将通过添加变量<code class="fe mr ms mt mu b">parallaxOffsetFadeDistancePx</code>对<code class="fe mr ms mt mu b">VehicleUiInfo</code>进行最后一次更新:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="88e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当我们创建我们的<code class="fe mr ms mt mu b">vehicleUiInfo</code>对象时，我们传入新的<code class="fe mr ms mt mu b">itemWidthFactorForFadeDistance</code>变量。如果将此项设置为1，当项目距离中心1个项目宽度时，名称将淡出。对于我的钱，我将值设置为. 5f(这是在一个新名字淡入的同时名字开始淡出的地方)。把你的设置成你想要的:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="35e1" class="nb lu iq mu b gy nc nd l ne nf">val vehicleUiInfo = VehicleUiInfo.create(<br/>   screenWidthDp = <em class="nr">LocalConfiguration</em>.current.screenWidthDp.<em class="nr">dp</em>.value,<br/>   itemWidthDp = 200f,<br/>   parallaxOffsetFactor = .33f,<br/>   itemWidthFactorForFadeDistance = .5f,<br/>)</span></pre><p id="d151" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一步是实际应用渐变。将此变量添加到您的<code class="fe mr ms mt mu b">VehicleItem()</code>函数中:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="3508" class="nb lu iq mu b gy nc nd l ne nf">val alpha = ((vehicleUiInfo.parallaxOffsetFadeDistancePx - <br/>   abs(offsetFromCenterPx)) /<br/>      vehicleUiInfo.parallaxOffsetFadeDistancePx).<em class="nr">coerceAtLeast</em>(0f)</span></pre><p id="783b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这看起来可能很复杂，但它只是基于经典的归一化形式(K - x) / K，其中K是一个常数。请注意，当x = K时，值为0，当x = 0时，值为1。这正是我们想要的并行名字的阿尔法。</p><p id="73a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的案例中，当:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="b304" class="nb lu iq mu b gy nc nd l ne nf"><em class="nr">abs</em>(offsetFromCenterPx)) = vehicleUiInfo.parallaxOffsetFadeDistancePx</span></pre><p id="362a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">alpha为0，并且当:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="aa8e" class="nb lu iq mu b gy nc nd l ne nf"><em class="nr">abs</em>(offsetFromCenterPx)) = 0</span></pre><p id="12fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">阿尔法值是1。我们还使用:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="1e5d" class="nb lu iq mu b gy nc nd l ne nf">.<em class="nr">coerceAtLeast</em>(0f)</span></pre><p id="ed07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，当:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="4dfa" class="nb lu iq mu b gy nc nd l ne nf"><em class="nr">abs</em>(offsetFromCenterPx)) &gt; vehicleUiInfo.parallaxOffsetFadeDistancePx)</span></pre><p id="2bd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不会以负数结束。</p><p id="0fbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将alpha应用于可组合文本的修饰符:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="bcc9" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">实际完成</h1><p id="b5e0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">就是这样。你真的完了！</p><p id="3409" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你的视差滚动，命名，可爱的车辆行现在应该看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/460d84c519a9a7c9faa13d2d6543345a.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/1*3hr4wG6sDEiEXKKlroSjCw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">视差滚动，命名，可爱的车辆行的东西。</p></figure><p id="c6cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给自己一个大大的掌声！！如果你能想到一些改进，请随时告诉我。我真的受得了。</p><p id="e646" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>