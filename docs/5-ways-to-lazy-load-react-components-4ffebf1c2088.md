# 延迟加载 React 组件的 5 种方法

> 原文：<https://betterprogramming.pub/5-ways-to-lazy-load-react-components-4ffebf1c2088>

## 优化您的 React 前端以获得更好的用户体验

![](img/d85bae96ab7a69c42ff94d68f3dcf8e6.png)

凯特·斯通·马西森在 [Unsplash](https://unsplash.com/s/photos/lazy?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

通常，当我看 Figma 和 XD 设计时，它们看起来比它的宽度长，哦，我的意思是它们大多是肖像。

但是没关系，我们都不期望整个设计同时出现在屏幕上，我们理解，一部分设计会出现在屏幕上，一部分设计会在用户滚动时出现。

太棒了。所以我们戴上护目镜，开始一个像素一个像素地实现设计。问题是:如果我们从根本上意识到设计不会同时出现在屏幕上，那我们为什么还要麻烦浏览器一次呈现出来呢？难道我们不能找到一种好的方法来告诉浏览器只呈现即将到来的组件吗？

当页面被加载时，页脚怎么敢和页眉竞争资源呢？如果你看看你的网站统计数据，或者使用热图，无论如何，页脚的点击率都没有那么高。

这里的目标是优先考虑在特定时间对 UX 至关重要的组件和元素。谢天谢地，React 提供了一些很棒的 API 和指针来帮助我们进行优化。

# 先说图像。

图像是资源密集型的，通常情况下，它们会占用一个页面的很大一部分资源。问题是，实际上并不需要所有的图像。以幻灯片为例，最重要的图像是当前可用的图像。

那么，当从服务器请求资源时，为什么所有的图像应该被给予相同的优先级呢？

让我们考虑另一种情况，即图像在视口中不可用，同样，这些图像不应该像视口中的图像一样被赋予同样多的优先级。

最后，如果我们后退一步，你可能会意识到，有时，即使是视图端口中的图像也不应该被阻止，也不应该阻止网站加载其他内容，如 CSS 和一些核心 JavaScript。

我的做法是推迟所有图像，只要页面没有图像也可以，我说，让我们推迟图像的加载，直到加载了其他组件。然后，您可以在后台加载图像，或者在图像进入视口时加载图像。

让我们看看我们可以做到这一点的几种方法。

# 1.本机支持加载='lazy '

> 来自 MDN 文档
> 
> 惰性加载是一种将资源识别为非阻塞(非关键)的策略，只在需要时加载这些资源。这是缩短关键呈现路径长度的一种方式，也就是说减少了页面加载时间。
> 
> 通常情况下，网页包含许多图像，这些图像会影响数据的使用和页面加载的速度。这些图像中的大多数是离屏的(非关键的)，需要用户交互(一个例子是滚动)才能查看它们。

我们所要做的就是将`loading=“lazy”`添加到图像中

```
 <img src=”image.jpg” alt=”…” loading=”lazy”>
```

这非常有效，它会在图像进入视图时加载并渲染图像，而不会将其视为关键资源。不幸的是，它并不被所有的浏览器支持，因此，建议添加[聚投](https://github.com/mfranzke/loading-attribute-polyfill)。

# 2.交叉点观察器 API

另一种方法是使用交叉点观察器 API。

Mozilla web 文档将交叉点观察器 API 描述为:

> 交叉点观察器 API 提供了一种异步观察目标元素与祖先元素或顶层文档的[视口](https://developer.mozilla.org/en-US/docs/Glossary/Viewport)的交叉点变化的方法。
> 
> 交叉点观察器 API 让代码注册一个回调函数，每当它们希望监视的元素进入或退出另一个元素(或[视口](https://developer.mozilla.org/en-US/docs/Glossary/Viewport))时，或者当两个元素相交的量改变了请求的量时，就会执行该回调函数。通过这种方式，站点不再需要在主线程上做任何事情来监视这种元素的交集，浏览器可以自由地优化交集的管理。

我们首先将一个空的`src`附加到我们的图像上，当它在视图中时，我们将附加我们的`src`，然后浏览器将获取`src`，这将是一个双赢的局面。

# 3.使用库

在 JavaScript 生态系统中，还有其他库可以在这方面提供帮助，其中一些库专门用于 react。我将在此列出它们，但不会详细说明如何使用它们，因为它们都与我们在此讨论的内容有相似的概念。

*   [反应迟缓加载图像](https://www.npmjs.com/package/react-lazy-load-image-component)
*   [洛扎德](https://www.npmjs.com/package/lozad)
*   [Yall-js](https://www.npmjs.com/package/yall-js)
*   [懒人尺码](https://www.npmjs.com/package/lazysizes)

不幸的是，非基于 react 的可能会直接改变 DOM，所以您可能想要避免它们。

实际上，您可以创建一个图像组件，并使用`React.lazy()`和`React.suspense()`延迟加载它。接下来我们来看看这两个。

# 4.延迟加载组件

现在，随着延迟加载图像的概念的提出，我们可以将它扩展到其他组件，同样，当元素还没有出现在视图中时，为什么要做一些计算和动画。您应该再次推迟加载非关键组件。您可以通过内置的`React.Lazy`、`React.Suspense`和动态导入来实现这一点。

这是 react 的方法，可以轻松地对你的代码进行代码拆分。根据文件显示

> 对你的应用进行代码拆分可以帮助你“延迟加载”用户当前需要的东西，这可以极大地提高你的应用的性能。虽然你没有减少应用程序中的总代码量，但你避免了加载用户可能永远不需要的代码，并减少了初始加载期间所需的代码量。

让我们考虑一个关于页面，我们可能想在实际的关于内容下面显示一些文章和时事通讯。

“关于”页面对于一些图片来说可能很大，但是正如我们从上面了解到的，e 成功地延迟了图片，但是我们仍然对页面的大小不太感冒。

我们可以决定拆分时事通讯和“关于”页面上的文章，以减少初始加载的大小。让我们看看如何在这里实现这一点:

让我们看看这里发生了什么。

`import(“./NewPost”)` —这告诉捆绑器我们想在这里进行代码拆分，而不是添加到捆绑包中。

`const Posts = React.lazy(() => import(“./Posts”));` —这创建了一个可用的组件，我们可以将它添加到我们的 Jsx 中，就像它是一个组件一样。但是为了添加它，我们将把它包装在`Suspense`组件中，这样我们可以指定一个回退，只要我们的组件还没有完成获取，就应该呈现这个回退。你可以在这里展示你的超棒的装载机。就这样，我们就可以走了。

# 5.虚拟化巨大的桌子

我们都明白向用户显示一个巨大的列表是一种糟糕的用户体验，所以我们同意对它们进行分页或无限加载。

分页很棒，因为这意味着我们将只从服务器加载相当数量的数据，以便在特定时间向用户显示。但是无论我们做什么，有时甚至分页的列表在屏幕上也放不下。这是我认为虚拟化列表的亮点。

我最早是从 Android 上发现虚拟列表这个概念的。在移动设备上，我们没有太多的资源，所以无论如何我们都不能使用内存,`RecyclerView`只有几个容器可以呈现数据。当视图进入屏幕时，它使用一个现有的容器来呈现元素，当它被滚出屏幕时，容器被回收，数据被分离，以便再次重用。

因此，如果列表一次只能显示 9 件事情，无论你给它多少元素来显示在屏幕上，它将只使用 9 个容器，并通过它进行循环。在 r `eact-window`的帮助下，我们可以在 React 中使用类似的概念。

让我在这里解释几个道具:

*   `itemKey`是一个函数，它获取你的项目被渲染所需要的键。如果没有通过，它将使用索引。
*   `height`和`width`是容器(桌子)的尺寸。
*   `ItemSize`是要渲染的项目的垂直高度和水平宽度

你可以点击查看 react 窗口文档[。还有其他方法可以实现这一点，但是我发现 react-window 库从一开始就有点简单明了。你可以通过](https://react-window.vercel.app/#/examples/list/fixed-size)[谷歌](https://developers.google.com/web/updates/2016/07/infinite-scroller)查看这个帖子，或者查看`@moshe_31114`是如何构建 [his](https://medium.com/@moshe_31114/building-our-recycle-list-solution-in-react-17a21a9605a0) 的。

如果你想知道如何在 react 中防止多重渲染，请点击这里查看我的文章。这是我关于优化 React 前端的系列文章的一部分。

感谢阅读。