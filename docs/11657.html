<html>
<head>
<title>Stack Navigation on macOS in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中macOS上的堆栈导航</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stack-navigation-on-macos-41a40d8ec3a4?source=collection_archive---------5-----------------------#2022-04-06">https://betterprogramming.pub/stack-navigation-on-macos-41a40d8ec3a4?source=collection_archive---------5-----------------------#2022-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="795c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在macOS上创建堆栈导航，并在SwiftUI中通过您的多平台应用程序实现一致的导航</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/66cb91cf9548f5f61cb75b92cca719fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7sJmw6A27cyXo267qXvb3w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">列和堆栈导航样式比较</p></figure><p id="a1a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在SwiftUI中，我们可以选择两种导航视图样式:</p><ul class=""><li id="13f0" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><strong class="kx ir">列导航— </strong>由列中的一系列视图表示。通常，你通过侧边栏导航；</li><li id="b08c" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx ir">堆栈导航— </strong>由一个视图堆栈表示，一次只显示一个俯视图。</li></ul><p id="36ab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最佳实践是对小型设备使用堆栈导航样式，对大型设备使用列导航样式。</p><p id="4d32" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事实上，在小屏幕设备上，应用程序通常有一个标签栏来导航不同的部分，并使用堆栈导航来到达更深的层次；相反，在更大显示屏的设备上的应用程序通常会用侧边栏代替标签栏，侧边栏允许你拥有5个以上的元素(这是<a class="ae mf" href="https://developer.apple.com/design/human-interface-guidelines/ios/bars/tab-bars/" rel="noopener ugc nofollow" target="_blank">人机界面指南</a>建议标签栏拥有的最大元素数量)。</p><p id="c7a4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，如果您仍然需要层次导航，或者希望在您的多平台应用程序的所有环境中拥有一致的导航，该怎么办呢？</p><h1 id="4ba2" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">SwiftUI中的导航样式</h1><p id="00f6" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">为iOS/iPadOS设备编程时，堆栈导航很容易实现:</p><ul class=""><li id="7448" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">在<strong class="kx ir">iphone上，</strong> <em class="nd">堆栈导航</em>是默认导航样式；</li><li id="70da" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">相反，在<strong class="kx ir">ipad</strong>上，默认行为是<em class="nd">列导航</em>，但是您可以使用<code class="fe ne nf ng nh b">.navigationViewStyle()</code>修饰符指定您喜欢的导航样式:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5d29" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是macOS中的导航呢？</p><p id="ffb5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们假设你正在开发一个多平台的应用程序，并且已经解决了前面提到的iPad的“堆栈导航问题”。然后你试着在你的Mac上运行你的项目，你觉得会发生什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/e6ee30cb685c202731c618bbfcab08d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4l6NWUiOBYonglM8L96l4g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">navigationViewStyle()方法上的编译器错误</p></figure><p id="8b4a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">像iPads上的iOS一样，macOS默认使用分栏式导航，但在这种情况下，堆栈导航<em class="nd">不会像iOS一样免费提供</em>，因此，如果你需要它，你需要<em class="nd">自己创建</em>。</p><p id="347a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不过不用担心，下面我们就来看看如何实现这个目标！</p><h1 id="996f" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">创建StackNavigationView结构</h1><p id="4257" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated"><em class="nd">注意:在本文中,“根视图”指的是我们想要从其开始堆栈导航的父视图；“子视图”指的是我们想要从根视图“堆栈导航”的视图。</em></p><p id="134f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，在macOS组文件夹中新建一个文件。它只需要macOS目标，因为我们只在这个环境中使用它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/75a94669ce3a3d3879073030b1524d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*apFTQ6HMpApHfMn8hiYf1A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建StackNavigationView.swift文件并选择macOS目标</p></figure><p id="88d0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个文件中，我们创建了带有通用参数<code class="fe ne nf ng nh b">RootContent</code>的<code class="fe ne nf ng nh b">struct StackNavigationView()</code>，它符合<code class="fe ne nf ng nh b">View</code>协议:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0f68" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">意思是我们可以提供任何一种我们喜欢的内容，但是必须符合<code class="fe ne nf ng nh b">View</code>协议。</p><p id="92b4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个<code class="fe ne nf ng nh b">Struct</code>中，我们需要两个绑定值:</p><ol class=""><li id="2851" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq nm lx ly lz bi translated"><code class="fe ne nf ng nh b">currentSubview</code>–告知我们想要在哪个视图中导航；</li><li id="5280" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq nm lx ly lz bi translated"><code class="fe ne nf ng nh b">showingSubview</code>–告知我们想要导航的子视图是否显示。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1908" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们创建一个常量属性<code class="fe ne nf ng nh b">rootView</code>，它返回根视图内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="04e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们可以初始化我们的<code class="fe ne nf ng nh b">Struct</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1663" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，在我们的<code class="fe ne nf ng nh b">StackNavigationView</code>中，我们创建另一个<code class="fe ne nf ng nh b">Struct</code>，<code class="fe ne nf ng nh b">StackNavigationSubview</code>，它带有一个符合<code class="fe ne nf ng nh b">View</code>协议的通用参数，保存我们想要显示的子视图:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9d6f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该结构有两个参数:</p><ol class=""><li id="d9bd" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq nm lx ly lz bi translated">传达子视图是否可见的<code class="fe ne nf ng nh b">Binding</code></li><li id="0df0" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq nm lx ly lz bi translated">返回子视图内容的属性。</li></ol><p id="6a47" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe ne nf ng nh b">StackNavigationSubview()</code>结构的主体中，我们放置了<code class="fe ne nf ng nh b">contentView()</code>并创建了一个<code class="fe ne nf ng nh b">ToolbarItem</code>，它显示了一个返回到根视图的后退按钮:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c5a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在可以回到主<code class="fe ne nf ng nh b">StackNavigationView()</code>并使用其主体内的条件语句来查看<code class="fe ne nf ng nh b">showingSubview</code>参数并决定显示哪个视图，是根视图还是子视图:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6ed0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的堆栈导航行为已经准备好了，让我们看看如何使用它。</p><h2 id="98e3" class="nn mh iq bd mi no np dn mm nq nr dp mq le ns nt ms li nu nv mu lm nw nx mw ny bi translated">准备好一切</h2><p id="6dc8" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在实现之前，我们需要一些简单的配置。在实际的根视图中，我们需要两个<code class="fe ne nf ng nh b">@State</code>值，一个用于我们想要显示的子视图，另一个用于在显示和不显示子视图之间切换(这些是将值证明给我们在StackNavigationView结构中定义的两个绑定的属性):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="85da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">显然，我们需要一个函数来获取我们想要显示的视图，并切换<code class="fe ne nf ng nh b">showingSubview</code>状态:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="2c16" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">⚠️:我们在根视图中写的东西只能在macOS环境中使用。因此，请记住将它包装在条件编译块中！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b69b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在一切都设置为使用我们的<code class="fe ne nf ng nh b">StackNavigationView()</code>。</p><h1 id="f59f" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">实现堆栈导航视图</h1><p id="2b94" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在根视图的主体内，我们实例化结构，在花括号内，我们放置根视图的内容，以及触发导航的控件，例如按钮:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="34b0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/28d7188d0f1d8addd80383b09101a016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*l0gRgv_ZcWqdbetpcYaLpA.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">堆栈导航示例</p></figure><h1 id="c196" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">技巧</h1><h2 id="a22b" class="nn mh iq bd mi no np dn mm nq nr dp mq le ns nt ms li nu nv mu lm nw nx mw ny bi translated"><strong class="ak"> #1工具栏</strong></h2><p id="6fae" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">因为您的子视图有一个工具栏元素，所以为了避免这个奇怪的结果，您需要在根视图中也有一个工具栏元素。</p><p id="3e8a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在<code class="fe ne nf ng nh b">StackNavigationView()</code>上附加一个<code class="fe ne nf ng nh b">toolbar</code>，就像这样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/6eec3ac145643153311ef1d0ff86677b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6O_tgZck7oTp5pu65xaYzQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">工具栏问题已修复的堆栈导航示例</p></figure><h2 id="9b96" class="nn mh iq bd mi no np dn mm nq nr dp mq le ns nt ms li nu nv mu lm nw nx mw ny bi translated"><strong class="ak"> #2 zIndex </strong></h2><p id="7303" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在一些更复杂的界面中，在转换过程中，根视图可能会与子视图重叠。为了确保避免这种行为，在<code class="fe ne nf ng nh b">StackNavigationView()</code>中，您可以为根视图指定一个负的<code class="fe ne nf ng nh b">zIndex</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="1102" class="nn mh iq bd mi no np dn mm nq nr dp mq le ns nt ms li nu nv mu lm nw nx mw ny bi translated"><strong class="ak"> #3侧边栏</strong></h2><p id="a0cc" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">您也可以将堆栈导航与经典的栏导航(即边栏)一起使用。你只需要进入你的主视图(你的应用程序显示的第一个视图)，添加一个之前创建的侧边视图，然后把两个视图打包成一个<code class="fe ne nf ng nh b">NavigationView()</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/ad70effd13ec9c2c5ddcab89557dcb02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HiawY0cbQK8dshwqmFO7rQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带侧边栏的堆栈导航</p></figure></div></div>    
</body>
</html>