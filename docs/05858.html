<html>
<head>
<title>How to Fire and Forget Kotlin Coroutines in Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何解雇和忘记Spring Boot的科特林花冠</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-fire-and-forget-kotlin-coroutines-in-spring-boot-40f8204aac86?source=collection_archive---------2-----------------------#2020-08-12">https://betterprogramming.pub/how-to-fire-and-forget-kotlin-coroutines-in-spring-boot-40f8204aac86?source=collection_archive---------2-----------------------#2020-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a385" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建函数，阻塞，暂停，“作用域”…什么？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/48327ebe6b5ba77c409df75fdb784ca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nZCE3PqRZkOjE2W_4YlUAw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="2226" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当计算被转移到其他地方时，Kotlin协同程序是一种有效的(重用)线程的方式。协程与<code class="fe lu lv lw lx b">Scope</code>的概念绑定在一起:要运行协程，需要先声明一个作用域对象。这就是他们如何实现<a class="ae ly" href="https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency" rel="noopener ugc nofollow" target="_blank">结构化并发</a>。要得到一个作用域，你需要使用作用域生成器函数，比如<code class="fe lu lv lw lx b"><a class="ae ly" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html" rel="noopener ugc nofollow" target="_blank">coroutineScope{}</a></code>或者<code class="fe lu lv lw lx b"><a class="ae ly" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html" rel="noopener ugc nofollow" target="_blank">runBlocking{}</a></code>。作用域挂起(或阻塞)一个线程，直到它的所有协程都完成。</p><p id="d738" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下示例将打印“213”</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这张照片印了213页</p></figure><p id="f334" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着，如果您没有对<code class="fe lu lv lw lx b">main</code>的简单控制，您就不能“发射并忘记”一个操作(这在框架中很常见)。JVM将等待作用域完成，然后继续处理它之外的任何事情。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="2cbe" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">春天的花冠</h1><p id="d95e" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">在Spring的世界里，协同程序在框架层得到了Spring WebFlux的支持，Spring web flux是Spring Boot的非阻塞替代物。在Spring WebFlux中，控制器方法可以被声明为<code class="fe lu lv lw lx b">suspend</code>。</p><p id="14cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以编写以下内容:</p><pre class="kj kk kl km gt nf lx ng nh aw ni bi"><span id="0cba" class="nj mj it lx b gy nk nl l nm nn">@GetMapping("/foo")<br/><strong class="lx iu">suspend </strong>fun foo: X = <strong class="lx iu">coroutineScope</strong>{<br/><strong class="lx iu">    </strong>val x = <em class="no">async </em><strong class="lx iu">{ </strong>restClient.getForObject&lt;Int&gt;("/bla1") <strong class="lx iu">}<br/>    </strong>val y = <em class="no">async </em><strong class="lx iu">{ </strong>restClient.getForObject&lt;Int&gt;("/bla2") <strong class="lx iu">}</strong></span><span id="f7ef" class="nj mj it lx b gy np nl l nm nn">    x.await() + y.await()<br/>}</span></pre><p id="7e5b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Spring Boot，你不能将一个控制器声明为挂起，但是你可以使用<code class="fe lu lv lw lx b">runBlocking</code>。</p><pre class="kj kk kl km gt nf lx ng nh aw ni bi"><span id="0da8" class="nj mj it lx b gy nk nl l nm nn">@GetMapping("/foo")<br/>fun foo(): Int = <strong class="lx iu"><em class="no">runBlocking </em>{<br/>    </strong>val x = <em class="no">async </em><strong class="lx iu">{ </strong>restClient.getForObject&lt;Int&gt;("/bla1") <strong class="lx iu">}<br/>    </strong>val y = <em class="no">async </em><strong class="lx iu">{ </strong>restClient.getForObject&lt;Int&gt;("/bla2") <strong class="lx iu">}</strong></span><span id="c00b" class="nj mj it lx b gy np nl l nm nn">    x.await() + y.await()<br/><strong class="lx iu">}</strong></span></pre><p id="ada5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在最后一个例子中，即使线程被阻塞，协程的异步性也是有益的。线程无论如何都会被阻塞，因为Spring Boot实现了<a class="ae ly" href="https://dzone.com/articles/spring-webflux-eventloop-vs-thread-per-request-mod" rel="noopener ugc nofollow" target="_blank">每个请求一个线程的模型</a> <em class="no">。</em></p><h2 id="9add" class="nj mj it bd mk nq nr dn mo ns nt dp ms lh nu nv mu ll nw nx mw lp ny nz my oa bi translated">开火然后忘记</h2><p id="2315" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">让我们弄清楚您想要启动一个流或一个长时间运行的作业的情况。您不希望等到任务结束后才返回HTTP响应。对于流，您可以选择Server-Sent-Events，然后接受等待，直到流结束，但情况并非总是如此。例如，这不适合长时间运行的作业，或者如果流应该通过WebSocket传递。</p><p id="4c8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果使用生成器函数，协程作用域将绑定到方法的作用域。在该范围内的所有操作完成之前，该方法不会返回。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="950d" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">应用程序级范围</h1><p id="ce87" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">排除范围生成器函数，我们有两个选择:<code class="fe lu lv lw lx b">GlobalScope</code>或者一个定制的应用程序<code class="fe lu lv lw lx b">CoroutineScope</code>。选哪个？看情况。</p><h2 id="2dad" class="nj mj it bd mk nq nr dn mo ns nt dp ms lh nu nv mu ll nw nx mw lp ny nz my oa bi translated">全球范围</h2><p id="dba0" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated"><code class="fe lu lv lw lx b">GlobalScope</code>是最简单的选择。请看下面的例子:</p><pre class="kj kk kl km gt nf lx ng nh aw ni bi"><span id="ff4f" class="nj mj it lx b gy nk nl l nm nn">@GetMapping("/foo")<br/>fun get() : Int{<br/>    GlobalScope.<em class="no">launch </em><strong class="lx iu">{<br/>        </strong>...<br/>    <strong class="lx iu">}<br/>    </strong>return 0<br/>}</span></pre><p id="8438" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">来自官方的Kotlin协程文档:“全局协程就像守护线程。”</p><p id="7202" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦应用程序关闭，在其中启动的每个协程也将被取消。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这将只打印“2”</p></figure><p id="4276" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，当程序结束时，协程将被取消。</p><p id="4539" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">GlobalScope</code>不实现结构化并发。这意味着，如果其中的任何一个协程抛出异常，所有其他协程将继续运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在GlobalScope中启动:这将抛出并打印“hello 1”</p></figure><p id="264f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这未必是一件坏事。一个例子是一个控制器，它通过WebSocket执行启动流的命令。对控制器的每个调用都是一个新的流流；不会出现这样的情况:如果任何一条河流断流，那么所有其他河流也会停止运行。</p><h2 id="560c" class="nj mj it bd mk nq nr dn mo ns nt dp ms lh nu nv mu ll nw nx mw lp ny nz my oa bi translated">适用范围</h2><p id="d764" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">另一种选择是创建一个自定义范围，然后将其注入到您的应用程序中:</p><pre class="kj kk kl km gt nf lx ng nh aw ni bi"><span id="9560" class="nj mj it lx b gy nk nl l nm nn">@SpringBootConfiguration<br/>class MyConguration{   <br/>   @Bean<br/>   fun scope(): CoroutineScope =<br/>        C<em class="no">oroutineScope</em>(Dispatchers.Default)<br/>}</span><span id="633b" class="nj mj it lx b gy np nl l nm nn">@RestController<br/>class MyController(@Autowired private val scope: CoroutineScope) ...</span></pre><p id="85bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，结构化并发是适当的。如果在这个范围内运行的任何一个协程抛出，那么所有其他的协程也会停止。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这不会打印“hello 1”</p></figure><p id="f60e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像<code class="fe lu lv lw lx b">GlobalScope</code>一样，这种作用域不会阻止Spring Boot关闭，即使任何协程仍在运行。这是因为当它被垃圾收集器收集时，它的所有协程一起被取消。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="e3c5" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结论</h1><ul class=""><li id="2b9d" class="ob oc it la b lb na le nb lh od ll oe lp of lt og oh oi oj bi translated">如果你想完全支持协同程序，那么就使用Spring WebFlux。如果您的应用程序是IO受限的，建议这样做，以利用非阻塞模型。</li><li id="5010" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated">如果你坚持Spring Boot，那么你仍然可以得到好处。这些都与更有效地使用分配给请求的线程密切相关。</li><li id="5b3f" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated">如果所有的任务都必须在控制器调用期间完成，例如，如果您从数据库中获取一些东西，那么使用协程函数生成器(<code class="fe lu lv lw lx b">runBlocking</code>或<code class="fe lu lv lw lx b">coroutineScope</code>)。</li><li id="51f2" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated">用<code class="fe lu lv lw lx b">GlobalScope</code>开火，忘记必须过自己生活的长时间运行的任务。</li><li id="3790" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated">使用自定义作用域来触发并忘记必须相互关联的长期运行的任务。</li></ul></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="b7bc" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">奖金部分</h1><p id="de81" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">我总是喜欢用项目内的自定义类来包装作用域。姑且称之为<code class="fe lu lv lw lx b">AppCoroutineScope</code>。</p><pre class="kj kk kl km gt nf lx ng nh aw ni bi"><span id="919e" class="nj mj it lx b gy nk nl l nm nn">class AppC<em class="no">oroutineScope : </em>C<em class="no">oroutineScope by CoroutineScope(Dispatchers.Default)</em></span><span id="ad30" class="nj mj it lx b gy np nl l nm nn">or</span><span id="842e" class="nj mj it lx b gy np nl l nm nn">class AppC<em class="no">oroutineScope : </em>C<em class="no">oroutineScope by GlobalScope</em></span><span id="5f2c" class="nj mj it lx b gy np nl l nm nn">@SpringBootConfiguration<br/>class MyConguration{<br/>    @Bean<br/>    fun scope(): AppCoroutineScope = AppC<em class="no">oroutineScope</em>()<br/>}</span><span id="cfdc" class="nj mj it lx b gy np nl l nm nn">@RestController<br/>class MyController(@Autowired private val scope: AppCoroutineScope) ...</span></pre><p id="11d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过这种方式，您可以构建多个作用域类型，并决定如何注入它们。此外，如果您在选择范围时出错，则更容易切换。</p><p id="38e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>