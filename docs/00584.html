<html>
<head>
<title>Better Types, Fewer Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好的类型，更少的测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/better-types-less-tests-a5cf486903f3?source=collection_archive---------7-----------------------#2019-06-13">https://betterprogramming.pub/better-types-less-tests-a5cf486903f3?source=collection_archive---------7-----------------------#2019-06-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="39fd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么您应该关注类型，以及这如何影响自动化测试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e199da7192f1006b866b4f0ac89a56b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K9ZQ334EmZ7UicAf_MTt9g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=3222894" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kv" href="https://pixabay.com/users/Prettysleepy2-2973588/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=3222894" rel="noopener ugc nofollow" target="_blank"> Prettysleepy2 </a></p></figure><p id="ad76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我对编程的热情开始于动态类型语言(PHP)，所以我艰难地认识到一个类型良好的程序和一个检查器/编译器可以帮助我们防止错误。</p><p id="0fbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我也做了很多自动化测试的工作。多亏了令人敬畏的Ruby社区，我很早就学会了这项技能，但是这项技能也是动态类型化的。</p><p id="793c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将使用我在开发<a class="ae kv" href="https://github.com/cruijs/crui" rel="noopener ugc nofollow" target="_blank"> CRUI </a>时遇到的真实案例来展示类型如何帮助我们交付更好的代码，以及它们如何与测试相关联。</p><p id="c37c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为参考语言，我们将使用Javascript和<a class="ae kv" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> Typescript </a>，但本文适用于任何动态和类型化语言。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="23c8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">没有类型</h1><p id="e554" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在CRUI中，我们有一个绑定流和特定元素属性的函数。最简单的形式是这样的:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="e30a" class="nb ma iq mx b gy nc nd l ne nf">function h$b(tag, bind)</span></pre><p id="903b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">老实说，我不知道该拿这个函数怎么办。</p><p id="b1eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我真傻，问题显然是没有文档！补充一下吧。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="7bc4" class="nb ma iq mx b gy nc nd l ne nf">/**<br/> * Element with Bind.<br/> * Create an DOM Node and bind properties to a StreamBox.<br/> * <br/> * <a class="ae kv" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> tag A string with an HTML Tag like 'div'<br/> * <a class="ae kv" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> bind An object specifying which property to bind to which stream box.<br/> * <a class="ae kv" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> A component<br/> */<br/>function h$b(tag, bind)</span></pre><p id="d795" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在我准备好使用它了:我将使用<code class="fe ng nh ni mx b">'input'</code>作为标签，对于第二个，我需要一个带有流盒的对象，等等，文档中提到的这些属性是什么？</p><p id="5fd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过一番挖掘，我们(再次)发现了这个问题，并决定彻底解决这个问题:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="4589" class="nb ma iq mx b gy nc nd l ne nf">/**<br/> * Element with Bind.<br/> * Create an DOM Node and bind properties to a StreamBox.<br/> * <br/> * <a class="ae kv" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> tag A string with an HTML Tag like 'div'<br/> * <a class="ae kv" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> bind An object specifying which property to bind to which stream box. We support 2 properties: `value` and `checked`. <br/> *            This parameter should look like: {value: StreamBox}<br/> * <a class="ae kv" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> A component<br/> */<br/>function h$b(tag, bind)</span></pre><p id="d292" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个有效的例子是:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="487c" class="nb ma iq mx b gy nc nd l ne nf">const stream = new StreamBox('')<br/>const comp = h$b('input', {value: stream})</span></pre><p id="7e56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经理解了这个函数，我们仍然需要验证它是否实现了它的承诺。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9f62" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">无类型—测试</h1><p id="d81a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我认为测试是软件开发的基本部分。我们主要有两种方法来测试这个功能:</p><ul class=""><li id="7d71" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated"><strong class="ky ir">单元测试</strong>在隔离状态下执行，只测试手边的单元。隔离经常需要嘲笑依赖。</li><li id="2309" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><strong class="ky ir">集成测试</strong>考虑整体功能而不是单一功能，尽可能保持真实的依赖关系。</li></ul><p id="baee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这样一个简单的函数，单元测试就足够了。</p><p id="c802" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们开始测试并涵盖以下所有情况:</p><ul class=""><li id="5aba" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated">传递除了<code class="fe ng nh ni mx b">value</code>或<code class="fe ng nh ni mx b">checked</code>之外的任何属性都会抛出异常</li><li id="50f6" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">传递除了<code class="fe ng nh ni mx b">input</code>或其他支持<code class="fe ng nh ni mx b">value</code>和<code class="fe ng nh ni mx b">checked</code>的有效HTML元素标签之外的东西会抛出异常</li><li id="b631" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">对于<code class="fe ng nh ni mx b">checked</code>属性，只允许使用<code class="fe ng nh ni mx b">input</code>标签</li><li id="a36f" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">为绑定到<code class="fe ng nh ni mx b">value</code>的StreamBox设置一个值将对其进行字符串化</li><li id="d003" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">为绑定到<code class="fe ng nh ni mx b">checked</code>的StreamBox设置一个值会使它成为一个布尔值</li><li id="ca71" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">更改StreamBox值也会更改元素值</li><li id="4036" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">更改元素值也会更改StreamBox值</li></ul><p id="9f1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">唷！我们写了相当多的测试，但是现在我们完全有信心这个函数可以工作，并且会随着我们代码库的发展而继续工作。</p><p id="a9b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在应用程序中使用它。它看起来会像这样:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="0eae" class="nb ma iq mx b gy nc nd l ne nf">const stream = new StreamBox('')<br/>hc('div', [<br/>   h$b('input', { valeu: stream })<br/>])</span></pre><p id="35a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们对<code class="fe ng nh ni mx b">hc</code>和<code class="fe ng nh ni mx b">h$b</code>都进行了广泛的测试，所以我们非常有信心这段代码能够工作。我们通过我们最喜欢的捆绑器运行它，并打开浏览器来享受我们不可思议的创造…一个空白的页面。</p><p id="8dde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，出了点问题。我们打开浏览器控制台，发现如下异常:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="3b47" class="nb ma iq mx b gy nc nd l ne nf">Error: `valeu` property is not supported.</span></pre><p id="e7e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哎哟！一个愚蠢的错别字。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c4bc" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">无类型—经验教训</h1><ul class=""><li id="7956" class="nj nk iq ky b kz mr lc ms lf nx lj ny ln nz lr no np nq nr bi translated">函数签名通常很少告诉我们如何使用它。</li><li id="20d9" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">文档是必要的，但并不总是可靠的；要么是信息不够，要么是过时了。</li><li id="7b91" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">我们需要编写大量的测试和防御代码，以确保我们的函数行为正常，并且很容易找出哪里出了问题。</li><li id="c92c" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">正确性不会复合:在动态和弱类型语言中，单元测试对正确性的保证非常有限。</li><li id="f263" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">为了确保正确性，我们需要编写大量的集成测试，这些测试通常很难维护，执行和编写都很慢。</li><li id="a023" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">鉴于100%的集成测试覆盖率通常不是一件事，我们在代码库中添加的每一行都可能触发一个新的故障，这个故障只会在运行时被捕获。个人认为，这是一场噩梦。</li></ul><p id="bbb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当使用动态/弱类型语言时，确保代码正确的负担几乎完全由开发人员承担。我们必须更加细心和勤奋，才能做好我们的工作。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8a2f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">介绍类型</h1><p id="b854" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">上述函数的类型化版本可能是:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="4d6a" class="nb ma iq mx b gy nc nd l ne nf">function h$b(tag: string, bind: Object): Function</span></pre><p id="28fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这在Typescript中是有效的，并且稍微好一点，但是我认为它对我们没有任何帮助。</p><p id="45b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加随机类型不会解决任何问题。我们需要正确理解手头的<strong class="ky ir">域</strong>，然后<strong class="ky ir">尽可能通过<strong class="ky ir">类型</strong> <strong class="ky ir">系统</strong>表达出来</strong>。</p><p id="4639" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们重温一下我们为Javascript编写的文档:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="deaf" class="nb ma iq mx b gy nc nd l ne nf">/**<br/> * Element with Bind.<br/> * Create an DOM Node and bind properties to a StreamBox.<br/> * <br/> * <a class="ae kv" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> tag A string with an HTML Tag like 'div'<br/> * <a class="ae kv" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> bind An object specifying which property to bind to which stream box. We support 2 properties: `value` and `checked`. <br/> *            This parameter should look like: {value: StreamBox}<br/> * <a class="ae kv" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> A component<br/> */</span></pre><p id="8a0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，我们可以把它整理成:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="7ae5" class="nb ma iq mx b gy nc nd l ne nf">type Tag = string<br/>type Bind = { value?: StreamBox, checked?: StreamBox }<br/>type Component = () =&gt; Node</span><span id="465b" class="nb ma iq mx b gy ob nd l ne nf">function h$b(tag: Tag, bind: Bind): Component</span></pre><p id="18a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们正在谈话！零文档，我们已经有了比以前更多的信息:组件实际上是一个不接收任何东西并返回一个节点的函数。<em class="oa">(请注意，CRUI组件比这个稍微复杂一点)</em></p><p id="5ba3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类型/代码和文档的一个很大的区别是代码不能不同步。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7ec4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">类型—测试</h1><p id="a00c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们有我们的功能，但是现在我们需要用测试来覆盖它。</p><p id="ebf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们重温一下。</p><blockquote class="oc od oe"><p id="0b22" class="kw kx oa ky b kz la jr lb lc ld ju le of lg lh li og lk ll lm oh lo lp lq lr ij bi translated">传递除了<code class="fe ng nh ni mx b">value</code>或<code class="fe ng nh ni mx b">checked</code>之外的任何属性都会抛出异常。</p></blockquote><p id="b689" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等等，我们实际上不再有这个问题了，因为我们定义了Bind类型系统会强制遵守这个规则。</p><p id="2a57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，继续下一个:</p><blockquote class="oc od oe"><p id="4c24" class="kw kx oa ky b kz la jr lb lc ld ju le of lg lh li og lk ll lm oh lo lp lq lr ij bi translated">传递除了<code class="fe ng nh ni mx b">input</code>或其他有效的HTML元素标签之外的东西会抛出一个异常</p></blockquote><p id="04bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，我们不涵盖这一点，但我认为类型可以在这里有所帮助:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="43d4" class="nb ma iq mx b gy nc nd l ne nf">type Tag = 'input'|'select'|'textarea'<br/>function h$b(tag: Tag, bind: Bind): Component</span></pre><p id="eb88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不错！如果我们试图使用除了<code class="fe ng nh ni mx b">input</code>、<code class="fe ng nh ni mx b">select</code>或<code class="fe ng nh ni mx b">textarea</code>之外的任何东西，Typescript编译器会对我们大喊大叫，强迫我们使用有效的标签。</p><p id="7764" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一个:</p><blockquote class="oc od oe"><p id="b956" class="kw kx oa ky b kz la jr lb lc ld ju le of lg lh li og lk ll lm oh lo lp lq lr ij bi translated">对于<code class="fe ng nh ni mx b">checked</code>属性，只允许使用<code class="fe ng nh ni mx b">input</code>标记</p></blockquote><p id="8e59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在这里多考虑一点:我们可以对我们刚刚定义的所有标签使用<code class="fe ng nh ni mx b">value</code>，但是<code class="fe ng nh ni mx b">checked</code>只能和<code class="fe ng nh ni mx b">input</code>一起使用。有趣的是，由于<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/functions.html" rel="noopener ugc nofollow" target="_blank">函数重载</a>，Typescript在这里也能有所帮助:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="6703" class="nb ma iq mx b gy nc nd l ne nf">type Tag = 'input'|'select'|'textarea'<br/>type BindValue = { value: StreamBox }<br/>type BindChecked = { checked: StreamBox }</span><span id="b75e" class="nb ma iq mx b gy ob nd l ne nf">function h$b(tag: Tag, bind: BindValue): Component<br/>function h$b(tag: 'input', bind: BindChecked): Component</span></pre><p id="f5df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个定义看起来有点吓人，但它只是编码了我们对这个函数的接受标准:<code class="fe ng nh ni mx b">checked</code>只能绑定到一个<code class="fe ng nh ni mx b">input</code>元素，而<code class="fe ng nh ni mx b">value</code>可以用于定义的元素。代码将在两个定义之间共享。</p><p id="f472" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">跳过了另一个测试，请进行下一个测试！</p><blockquote class="oc od oe"><p id="2a07" class="kw kx oa ky b kz la jr lb lc ld ju le of lg lh li og lk ll lm oh lo lp lq lr ij bi translated">将一个值设置到绑定到<code class="fe ng nh ni mx b">value</code>的流盒会将其字符串化</p></blockquote><p id="ae4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说:<code class="fe ng nh ni mx b">value</code>只适用于字符串，<code class="fe ng nh ni mx b">checked</code>只适用于布尔值。</p><p id="9b56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们肯定可以通过增强StreamBox定义来解决这个问题:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="63b5" class="nb ma iq mx b gy nc nd l ne nf">type BindValue = { value: StreamBox&lt;string&gt; }<br/>type BindChecked = { checked: StreamBox&lt;boolean&gt; }</span></pre><p id="6623" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您不熟悉泛型，这只是通知编译器StreamBox包含一个用于<code class="fe ng nh ni mx b">value</code>的string类型值和一个用于<code class="fe ng nh ni mx b">checked</code>的boolean类型值。</p><p id="97fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在<code class="fe ng nh ni mx b">&lt;&gt;</code>之间添加任何其他类型，这就是为什么它被称为<em class="oa">通用</em>。</p><p id="2a00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是最后两个验收标准:</p><blockquote class="oc od oe"><p id="5ee8" class="kw kx oa ky b kz la jr lb lc ld ju le of lg lh li og lk ll lm oh lo lp lq lr ij bi translated">更改StreamBox值也会更改element值</p><p id="7061" class="kw kx oa ky b kz la jr lb lc ld ju le of lg lh li og lk ll lm oh lo lp lq lr ij bi translated">更改元素值也会更改StreamBox值</p></blockquote><p id="6ef8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里没有捷径，我们只需要编写测试。这个<em class="oa">是这个特定功能的实际业务逻辑</em>；剩下的只是细节。</p><p id="ae56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们通过使用类型系统覆盖了7个验收标准中的5个。这是一个令人难以置信的结果，特别是因为我们的函数逻辑和代码现在没有了Javascript版本中必须放置的所有防御代码和异常，这使得它更简单，更不容易出错。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c4b3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">经验教训</h1><ul class=""><li id="fbef" class="nj nk iq ky b kz mr lc ms lf nx lj ny ln nz lr no np nq nr bi translated">只写<em class="oa">一些</em>类型也无济于事。我们需要写出正确的类型。</li><li id="298c" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">由于IDE的支持，在类型系统中编码相当多的逻辑是可能的，这将避免运行时检查的必要性，简化逻辑，提高性能并防止我们编码时的错误。</li><li id="251f" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">我们需要编写比以前少得多的测试，同时对整体正确性有更强的保证。</li><li id="f8ca" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">正确性包括:类型可以确保每个函数都以预期的和正确的方式使用；因此，单元测试更加相关。</li><li id="6fb7" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">集成测试不太相关，但是对于覆盖类型不够的情况仍然很重要，例如:一个函数期望元素以一定的顺序正确地完成它的工作。</li><li id="9ea5" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">通过大量的单元测试和一些集成测试，100%的测试覆盖率是可以实现的。就我个人而言，我不认为这是一个要求。</li></ul><p id="a554" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里最重要的一点是，编译器现在将防止我们(以及我们函数的任何用户)犯任何愚蠢的错误——这将提高生产率。</p><h2 id="c22c" class="nb ma iq bd mb oi oj dn mf ok ol dp mj lf om on ml lj oo op mn ln oq or mp os bi translated">真实案例，比测试更好</h2><p id="e2a2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在开发<a class="ae kv" href="https://github.com/cruijs/crui" rel="noopener ugc nofollow" target="_blank"> CRUI </a>的时候，由于Streams的工作方式，我确实遇到了一些错误。我的第一反应是为它写一个测试，但是我很快意识到这一点帮助都没有。测试对于内部行为是有用的——但是对于由于接收错误信息而导致的问题，测试是无效的。</p></div></div>    
</body>
</html>