<html>
<head>
<title>Proper Fragment Communication in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中正确的片段通信</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/proper-fragment-communication-in-android-489fcac520b0?source=collection_archive---------4-----------------------#2020-04-30">https://betterprogramming.pub/proper-fragment-communication-in-android-489fcac520b0?source=collection_archive---------4-----------------------#2020-04-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="939c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不要让系统挂在你的片段的监听器上</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fea8056c416a4b6a4f87f948780332b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iTuGX5LepofXOCsv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由I <a class="ae ky" href="https://unsplash.com/@othentikisra?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> srael Palacio </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄。</p></figure><p id="5e53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能已经阅读了大量关于这个主题的文章。想知道我为什么要多写一个是合理的。</p><p id="a25b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我说的是<em class="lv">正确的方式</em>，事实上，有几种解决方案。Android生态系统从一开始就在发展，你可能希望利用<a class="ae ky" href="https://developer.android.com/topic/libraries/architecture/viewmodel?gclid=CjwKCAjwv4_1BRAhEiwAtMDLsgUPYGAEh1HAFlebOllUHvz0dEjmr2WnQlCQi4uA1r4FY5vx5vjtqBoCKSYQAvD_BwE&amp;gclsrc=aw.ds" rel="noopener ugc nofollow" target="_blank">视图模型</a>甚至第三方库，如<a class="ae ky" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>或<a class="ae ky" href="https://github.com/greenrobot/EventBus" rel="noopener ugc nofollow" target="_blank"> EventBus </a>。</p><p id="9b61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有兴趣了解更多关于视图模型的知识，我推荐您阅读这篇优秀的文章:</p><div class="lw lx gp gr ly lz"><a href="https://android.jlelse.eu/communicate-between-fragments-and-activity-using-livedata-631526d6357a" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">使用LiveData在片段和活动之间进行通信</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">本文分为两部分——一、片段间的交流二。活动与…之间的通信</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">android.jlelse.eu</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn ks lz"/></div></div></a></div><p id="82b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管上述所有优点都存在，但你可能处于无法利用它们的情况。然后，您又回到了良好的老式界面解决方案的起点。</p><p id="861f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，使用接口工作非常完美，并且仍然是可能的最轻的方法，因为它不需要任何第三方库。</p><p id="9a1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，开发人员经常无法正确配置它们。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="42f2" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">片段到活动的通信</h1><p id="0e8a" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">让我们假设您有一个嵌入片段的活动。当片段上发生特定事件时，您希望通知您的活动，以便它对该事件做出反应。</p><p id="fcca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个基本示例，其中有一个片段声明了一个接口，用于将事件传播给实现它的任何人:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">公开接口的片段。</p></figure><p id="11c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及实现接口的活动:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将实现接口的活动。</p></figure><p id="0e87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决契约，活动必须以侦听器的形式向片段声明自己。</p><p id="ea9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是:我们在哪里调用这个方法？例如，您可以选择在<code class="fe nu nv nw nx b">onCreate</code>方法中调用它。</p><p id="b4c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果碎片被破坏了呢？活动还在监听片段的事件吗？</p><p id="61da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是否定的，如果系统，出于任何原因，破坏了片段而不是活动。您的活动将创建另一个片段实例，但不会将侦听器重新附加到它。片段中的任何事件都不会传播到您的活动中，使其处于损坏状态。</p><p id="f7f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了正确处理所有情况，当您的活动被通知您的片段已被附加时，您必须绑定您的侦听器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">片段中正确附加的监听器。</p></figure><p id="2267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种配置，您可以将活动与片段松散地耦合在一起。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="6d9a" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">嵌套片段通信</h1><p id="cec4" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">如果您碰巧有一个片段托管另一个片段，您可以使用相同的机制在这两个片段之间进行通信。片段还提供了一个<code class="fe nu nv nw nx b">onAttachFragment</code>回调函数，在您的子片段被附加时通知您。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="0872" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">请使用正确的附加回调</h1><p id="20e3" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">最近在<a class="ae ky" href="https://developer.android.com/reference/android/app/Fragment#onAttachFragment(android.app.Fragment)" rel="noopener ugc nofollow" target="_blank"> API 24 </a>中添加了<code class="fe nu nv nw nx b">onAttachFragment</code>回调，然后用最新的<a class="ae ky" href="https://androidx.de/androidx/fragment/app/Fragment.html#onAttachFragment(androidx.fragment.app.Fragment)" rel="noopener ugc nofollow" target="_blank"> androidX支持包</a>进行了后移植。我仍然会在定义接口的片段中遇到前面的<code class="fe nu nv nw nx b">onAttach</code>方法的用法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Fragment强制其调用方实现其接口。</p></figure><p id="fff5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这两种解决方案都有效，但我推荐使用最新的，因为它防止片段知道哪个组件实现了它的接口。片段不应该负责附加它们自己的侦听器。</p><p id="97d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，通过这样做，您可以强制片段的调用者实现其接口——即使调用者不需要对片段事件做出反应。简直是糟糕的建筑。</p><p id="c9f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，Android团队更新了官方文档<a class="ae ky" href="https://developer.android.com/training/basics/fragments/communicating" rel="noopener ugc nofollow" target="_blank">以示支持。</a></p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="6b64" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">关于碎片化传播的思考</h1><p id="f10d" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我有机会尝试上述所有解决方案。到目前为止，我一直忠于接口，因为它们提供了一致的机制——无论我需要在片段之间还是在片段和活动之间进行通信。</p><p id="dcbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您如何进行，只要您理解一个片段的生命周期是如何工作的，您就不会有问题。</p></div></div>    
</body>
</html>