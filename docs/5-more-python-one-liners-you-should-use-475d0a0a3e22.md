# 您应该使用的另外 5 个 Python 一行程序

> 原文：<https://betterprogramming.pub/5-more-python-one-liners-you-should-use-475d0a0a3e22>

## 解决问题。节省时间。快走

![](img/594971b4ed44c0f3c3915b3ccc6e8cfe.png)

卢克·彼得斯在 [Unsplash](https://unsplash.com/s/photos/developer?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

欢迎回到另一个版本:

“看看这段简短的代码能做多少有趣的事情！”

在这一期中，我们将探索 Python 代码中一些非常酷的部分。这些简短的一行程序解决了广泛的问题，如果你已经设法将自己编程到一个角落，它们可以让你摆脱困境。

其中一些例子来自 Python 标准库，而另一些来自第三方库。下次你需要快速解决问题，想节省时间或者只是想让一些东西看起来更简洁，试试这些。

# 1.用 lambdas 映射列表

我们的第一个例子是最有用的，但也颇有争议。这个一行程序允许您遍历列表的内容，然后对列表中的单个元素执行操作。该列表可以很容易地就地修改，创建一个修改过的版本，并把你从经典的`for`或`while`循环中拯救出来。

下面是一个映射字符串列表并将短语“*_ 后缀*”添加到每个字符串末尾的示例:

```
original_list = ['one', 'two', 'three']new_list = list(map(lambda x: str(x) + '_suffix', original_list))
```

运行之后，我们的`new_list`变量应该包含以下内容:

```
['one_suffix', 'two_suffix', 'three_suffix']
```

使用这种紧凑方法有争议的原因是，对于较大的 lambda 表达式，它可能比传统的多行循环可读性差得多。lambda 函数可能会变得混乱，您可能会开始混淆代码中的意图。将它用于复杂的列表操作是不明智的，但是像这样的快速变化可以极大地清理事物。

# 2.检查字符串是否包含在字符串列表中

这是一段我已经重复了无数次的代码。能够知道某个内容是否包含在列表的任何项目中非常有用。这可以很容易地用于定位版本号或在名称列表中查找名称。

让我们试试名字的例子。假设我们有以下全名列表:

```
name_list = ['Kathy Bates', 'George Clooney', 'Will Smith']
```

现在，让我们假设我们想要确定任何名为“George”的人是否在我们的列表中:

```
any('George' in name for name in name_list)
```

又短又甜。使用带有简单的`in`检查的`any`允许我们快速确定是否有任何元素包含名称“乔治”。

显然，如果您运行这段代码，您会得到以下结果:

```
True
```

现在我们知道乔治·克鲁尼藏在哪里了。

# 3.选择性破坏分配

当你在处理析构赋值的时候，列表中有其他你不需要赋值的元素是很棘手的。这些元素通常出现在列表的末尾，但有时也会出现在列表的开头或中间。这带来了一个恼人的问题，即在析构赋值时必须删除一些变量。

幸运的是，在给变量赋值时，有一种简单的方法可以去掉不用的变量。我们拿下面的数据来说:

```
person = ['bob', 'smith', 39, 'professor']
```

在这些数据中，我们有一个人的信息。我们有名字、姓氏、年龄和职业。假设我们想把这个分解成单个变量，但是我们并不关心 Bob 的姓或者他的年龄(Bob 是永恒的):

```
first_name, *_, profession = person
```

使用神奇的`*_`语法，我们可以省略一行中的几个元素，只保留剩下的一个。如果我们打印出每个变量，我们可以看到我们现在有适当的数据:

```
print(first_name)
>>> bobprint(profession)
>>> professor
```

如果我们想简单地省略一个元素而不是许多元素，我们可以使用`_`。这将在我们使用列表中的下一个位置元素时跳过它。

# 4.仅从列表中获取唯一的项目

这是一个非常常见的编程任务。无论您是从数据库中获取数据，还是清理一些用户提供的信息，删除重复项都是一项非常常见的日常工作。

假设您有一个数字列表，并且希望确保它不包含任何重复的数字:

```
my_numbers = [1, 2, 3, 4, 4, 5, 6, 6, 7, 8]
```

使列表具有唯一性的最简单、最干净的方法是将其转换成一个`set`。默认情况下，A `set`不允许重复值，所以你的列表通过简单的转换就会自动变得唯一。别担心，您可以在以下时间后将其转换回列表:

```
unique_list = list(set(my_numbers))
```

现在，如果我们打印出我们的`unique_list`变量，我们将只看到唯一的值:

```
print(unique_list)
>>> [1, 2, 3, 4, 5, 6, 7, 8]
```

# 5.使用 pyforest 动态导入库

您是否曾经编写了一个冗长的脚本，或者处理了一个大型复杂的数据集，并以大量的 import 语句而告终？在你的文件顶部附近，看起来像是`import import import`的海洋。就像他们把电影的演职员表放在开头一样。带我去看精彩的部分吧。

如果你在一个进口城市游泳，那么你可能想知道如何减少声明的总数。一种方法可能是把你的文件分割得更细一些，使它们更加模块化。这是一种选择，但有时分解会导致不必要的重复，甚至增加复杂性。有时候，把所有内容都放在一个地方是很好的(也可能更具可读性)。

另一种方法是使用`pyforest`模块。这是一个第三方模块，允许您编写单行导入语句，并让它动态导入许多其他样板模块。

```
import pyforest
```

这就是拉进一辆装满模块的自动倾卸卡车所需要的一切。最棒的是，你并没有真的把他们拉进来… *而不是*。`pyforest`模块只会在你引用它的时候导入一些东西。因此，如果您想引用`os`模块(以及许多其他模块)，您所要做的就是导入`pyforest`,然后在 import 语句之后以任何形式使用`os`。

```
import pyforestos.getpid()
```

如果您运行上面的代码，您将看到一个成功的运行和当前 Python 实例的进程 ID。

这个模块对于减少混乱、动态加载模块和减少代码的总启动时间非常有用。

查看官方`pyforest` GitHub 获取更多信息:

[](https://github.com/8080labs/pyforest) [## GitHub-8080 labs/py forest:py forest-感受自动化导入的幸福

### 一遍又一遍地写同样的导入是你力所不及的。让 pyforest 替你做这件事。有了 pyforest 你…

github.com](https://github.com/8080labs/pyforest) 

感谢阅读！如果你喜欢这篇文章，请看看我下面的其他 Python 帖子:

*   [*便于清理代码的 Python 片段*](/handy-python-snippets-for-cleaner-code-a1e2c5d39a0d)
*   [*5 种晦涩难懂的 Python 语法你应该试试*](/obscure-python-syntax-you-should-try-831dbc96777e)