<html>
<head>
<title>Fun With HTML Canvas: Let’s Create a Star Field</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTML画布的乐趣:让我们创建一个星域</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/fun-with-html-canvas-lets-create-a-star-field-a46b0fed5002?source=collection_archive---------6-----------------------#2019-12-14">https://betterprogramming.pub/fun-with-html-canvas-lets-create-a-star-field-a46b0fed5002?source=collection_archive---------6-----------------------#2019-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="142c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">HTML画布上效果的分步指南</h2></div><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div><p class="kp kq gj gh gi kr ks bd b be z dk translated">一个简单而有效的星域效应</p></figure><p id="7ea5" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这一部分，你将学习如何创建上面嵌入的星域效果。是的，它正在运行——它不是GIF或视频。</p><p id="f54b" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我只用了一个HTML画布。不需要第三方库或高等数学。我使用直观的技术使效果更容易理解和适应。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="d857" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">代码</h1><p id="35f0" class="pw-post-body-paragraph kt ku it kv b kw mo ju ky kz mp jx lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">该效果的完整源代码可在<a class="ae mt" href="https://codesandbox.io/s/lucid-fast-0v7ch" rel="noopener ugc nofollow" target="_blank">这里</a>获得。我建议你在另一个窗口打开它，然后跟着走。</p><p id="5152" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这个例子的标记是基本的。HTML主体和画布被定义和样式化为在整个浏览器窗口上伸展。</p><pre class="ki kj kk kl gt mu mv mw mx aw my bi"><span id="df6f" class="mz lx it mv b gy na nb l nc nd">&lt;!DOCTYPE html&gt;<br/>&lt;meta charset="utf-8" /&gt;<br/>&lt;body<br/>  style="position: fixed; left: 0px; right: 0px; top: 0px; bottom: 0px; overflow: hidden; margin: 0; padding: 0;"<br/>&gt;<br/>  &lt;canvas<br/>    id="canvas"<br/>    style="width: 100%; height: 100%; padding: 0;margin: 0;"<br/>  &gt;&lt;/canvas&gt;<br/>  &lt;script&gt;<br/>     ...<br/>   &lt;/script&gt;<br/>&lt;/body&gt;</span></pre></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="394a" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">处理事情</h1><p id="9cfa" class="pw-post-body-paragraph kt ku it kv b kw mo ju ky kz mp jx lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">如果我们想在画布上绘制任何东西，我们需要获取它的DOM元素并对其调用<code class="fe ne nf ng mv b">getContext("2d")</code>。这使我们能够访问<a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank">画布API </a>。</p><pre class="ki kj kk kl gt mu mv mw mx aw my bi"><span id="7289" class="mz lx it mv b gy na nb l nc nd">const canvas = document.getElementById("canvas");<br/>const c = canvas.getContext("2d");</span></pre></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="de9c" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">跟踪窗口大小</h1><p id="b67b" class="pw-post-body-paragraph kt ku it kv b kw mo ju ky kz mp jx lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">HTML画布有自己的内部分辨率，您可以通过给上下文的<code class="fe ne nf ng mv b">width</code>和<code class="fe ne nf ng mv b">height</code>属性赋值来设置。</p><p id="bd01" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们希望画布总是匹配窗口大小，所以我们设置画布宽度和高度来匹配。画布的大小在以后的计算中很有用，所以我们将它保存在<code class="fe ne nf ng mv b">w</code>和<code class="fe ne nf ng mv b">h</code>变量中。</p><pre class="ki kj kk kl gt mu mv mw mx aw my bi"><span id="1294" class="mz lx it mv b gy na nb l nc nd">let w;<br/>let h;<br/><br/>const setCanvasExtents = () =&gt; {<br/>  w = document.body.clientWidth;<br/>  h = document.body.clientHeight;<br/>  canvas.width = w;<br/>  canvas.height = h;<br/>};<br/><br/>setCanvasExtents();<br/>    <br/>window.onresize = () =&gt; {<br/>  setCanvasExtents();<br/>};</span></pre><p id="39d2" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在此过程中，我们对窗口大小调整事件做出反应，确保画布的分辨率始终与窗口的大小相匹配。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="3bd9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">星星</h1><p id="f3e7" class="pw-post-body-paragraph kt ku it kv b kw mo ju ky kz mp jx lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">每颗星星都由一个拥有<code class="fe ne nf ng mv b">x</code>、<code class="fe ne nf ng mv b">y</code>和<code class="fe ne nf ng mv b">z</code>坐标的物体代表。我们创建10k个并把它们放在一个数组中。</p><p id="0888" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们的恒星生活在一个虚拟坐标系中，看起来像这样:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/5e98339fc5a71d7ecdf803040d197f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*f_vKwGIFEm54ZnwaMq8UIw.png"/></div></figure><p id="e9f3" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">坐标系的中心点将被绘制到画布的中心。我们用z值来表示恒星离x，y平面的距离。</p><p id="d102" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我在坐标系中选择了如下的恒星分布:</p><ul class=""><li id="19c7" class="nk nl it kv b kw kx kz la lc nm lg nn lk no lo np nq nr ns bi translated"><code class="fe ne nf ng mv b">x</code>数值范围从<code class="fe ne nf ng mv b">-800</code>到<code class="fe ne nf ng mv b">+800</code></li><li id="d7ca" class="nk nl it kv b kw nt kz nu lc nv lg nw lk nx lo np nq nr ns bi translated"><code class="fe ne nf ng mv b">y</code>数值范围从<code class="fe ne nf ng mv b">-450</code>到<code class="fe ne nf ng mv b">+450</code></li><li id="bda4" class="nk nl it kv b kw nt kz nu lc nv lg nw lk nx lo np nq nr ns bi translated"><code class="fe ne nf ng mv b">z</code>数值范围从<code class="fe ne nf ng mv b">0</code>到<code class="fe ne nf ng mv b">1000</code></li></ul><p id="a610" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这些范围并不完全是任意的。我希望星星生成在一个16/9的矩形中，接近普通显示器的大小——这样当全屏观看时，它们就会落入可见空间。</p><p id="58ca" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我选择了1000单位的最大距离，因为为什么不呢？就宽度和高度而言，感觉还不错。随意摆弄数字，观察变化。</p><pre class="ki kj kk kl gt mu mv mw mx aw my bi"><span id="66b4" class="mz lx it mv b gy na nb l nc nd">const makeStars = (count) =&gt; {<br/>  const out = [];<br/>    for (let i=0;i&lt;count;i++){<br/>      const s = {<br/>        x: Math.random()*1600-800,<br/>        y: Math.random()*900-450,<br/>        z: Math.random()*1000<br/>      };<br/>    out.push(s);<br/>  }<br/>  return out;<br/>}<br/><br/>let stars = makeStars(10000);</span></pre><blockquote class="ny nz oa"><p id="d90a" class="kt ku ob kv b kw kx ju ky kz la jx lb oc ld le lf od lh li lj oe ll lm ln lo im bi translated"><a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random" rel="noopener ugc nofollow" target="_blank"> Math.random() </a>生成一个介于<code class="fe ne nf ng mv b">0</code>(含)和<code class="fe ne nf ng mv b">1</code>(不含)之间的随机数。</p><p id="10e1" class="kt ku ob kv b kw kx ju ky kz la jx lb oc ld le lf od lh li lj oe ll lm ln lo im bi translated">所以<code class="fe ne nf ng mv b">Math.random() * 1600</code>会生成一个介于<code class="fe ne nf ng mv b">0</code>(含)和<code class="fe ne nf ng mv b">1600</code>(不含)之间的数字。</p><p id="b3cc" class="kt ku ob kv b kw kx ju ky kz la jx lb oc ld le lf od lh li lj oe ll lm ln lo im bi translated">通过抵消它，我们可以改变有效范围。</p><p id="6abf" class="kt ku ob kv b kw kx ju ky kz la jx lb oc ld le lf od lh li lj oe ll lm ln lo im bi translated">因此<code class="fe ne nf ng mv b">Math.random()*1600–800</code>在<code class="fe ne nf ng mv b">-800 </code>(含)和<code class="fe ne nf ng mv b">+800</code>(不含)之间产生一个随机数。</p></blockquote></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="0099" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">绘制背景</h1><p id="f6a1" class="pw-post-body-paragraph kt ku it kv b kw mo ju ky kz mp jx lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">我们需要一种方法在画布上画出我们的星星。我们想要一个黑色的背景，我们可以把我们的星星放在上面。</p><pre class="ki kj kk kl gt mu mv mw mx aw my bi"><span id="90a5" class="mz lx it mv b gy na nb l nc nd">const clear = () =&gt; {<br/>  c.fillStyle = "black";<br/>  c.fillRect(0, 0, canvas.width, canvas.height);<br/>};</span></pre><p id="3e25" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe ne nf ng mv b">clear</code>函数只是用我们的背景色填充整个画布。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="5f2e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">画一颗星星</h1><p id="56f4" class="pw-post-body-paragraph kt ku it kv b kw mo ju ky kz mp jx lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">我们还需要一种绘制单星的方法。我们将给一个亮度在<code class="fe ne nf ng mv b">0</code>和<code class="fe ne nf ng mv b">1</code>之间的像素着色。该值越高，像素越亮。</p><pre class="ki kj kk kl gt mu mv mw mx aw my bi"><span id="f649" class="mz lx it mv b gy na nb l nc nd">const putPixel = (x, y, brightness) =&gt; {<br/>  const intensity = brightness * 255;<br/>  const rgb = "rgb(" + intensity + "," + intensity + "," + intensity + ")";<br/>  c.fillStyle = rgb;<br/>  c.fillRect(x, y, 1, 1);<br/>};</span></pre><p id="f73f" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe ne nf ng mv b">putPixel</code>函数确定我们想要的亮度的<code class="fe ne nf ng mv b">rgb</code>颜色，并用该值填充一个一像素的矩形。</p><blockquote class="ny nz oa"><p id="ad6c" class="kt ku ob kv b kw kx ju ky kz la jx lb oc ld le lf od lh li lj oe ll lm ln lo im bi translated">RGB颜色的范围从<code class="fe ne nf ng mv b">0–255</code>到红色、绿色和蓝色的每个分量。</p><p id="6872" class="kt ku ob kv b kw kx ju ky kz la jx lb oc ld le lf od lh li lj oe ll lm ln lo im bi translated">当所有三个分量相等时，我们生成一个灰色。</p><p id="7640" class="kt ku ob kv b kw kx ju ky kz la jx lb oc ld le lf od lh li lj oe ll lm ln lo im bi translated">通过用一个在<code class="fe ne nf ng mv b">0.0</code>和<code class="fe ne nf ng mv b">1.0</code>之间的值缩放所有组件的<code class="fe ne nf ng mv b">255</code>，我们有效地生成了一个介于黑色和白色之间的灰度颜色。</p></blockquote></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="d18e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">移动星星</h1><p id="304b" class="pw-post-body-paragraph kt ku it kv b kw mo ju ky kz mp jx lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">每画一帧，我们都想把自己星域里的星星移向我们。为此，我们需要降低恒星的<code class="fe ne nf ng mv b">z</code>坐标。</p><p id="8da8" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">一旦它们接近屏幕平面，我们就把它们送回去，这样它们就可以继续攻击我们。</p><pre class="ki kj kk kl gt mu mv mw mx aw my bi"><span id="a8af" class="mz lx it mv b gy na nb l nc nd">const moveStars = (distance) =&gt; {<br/>  const count = stars.length;<br/>  for (var i = 0; i &lt; count; i++) {<br/>    const s = stars[i];<br/>    s.z -= distance;<br/>    while (s.z &lt;= 1){<br/>      s.z += 1000;<br/>    }<br/>  }<br/>}</span></pre></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="7d72" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">让它滴答作响</h1><p id="c1a5" class="pw-post-body-paragraph kt ku it kv b kw mo ju ky kz mp jx lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">控制动画播放的速度很重要。我们可以使用<code class="fe ne nf ng mv b">setTimeout</code>或<code class="fe ne nf ng mv b">setInterval</code>，但是绘制下一帧最方便的方式是让浏览器在下一次屏幕刷新时调用我们，同时给我们一个高分辨率的时钟值。</p><p id="8c35" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">时钟告诉我们从上一帧开始过了多长时间，从而告诉我们动画进展了多长时间。</p><p id="a405" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe ne nf ng mv b"><a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank">requestAnimationFrame</a></code>函数正是我们所需要的。首先，我要求浏览器调用<code class="fe ne nf ng mv b">init</code>并传递高分辨率时钟值。</p><pre class="ki kj kk kl gt mu mv mw mx aw my bi"><span id="3c97" class="mz lx it mv b gy na nb l nc nd">let prevTime;<br/>const init = time =&gt; {<br/>  prevTime = time;<br/>  requestAnimationFrame(tick);<br/>};<br/><br/>...<br/><br/>requestAnimationFrame(init);</span></pre><p id="64fa" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在<code class="fe ne nf ng mv b">init</code>内部，我将时钟值存储在<code class="fe ne nf ng mv b">prevTime</code>中，并请求接下来调用我们的<code class="fe ne nf ng mv b">tick</code>函数。</p><p id="c895" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe ne nf ng mv b">tick</code>函数确定自上次刷新以来经过了多长时间，向前移动我们的动画，在画布上绘制我们的星星的当前状态，然后请求在下一次屏幕刷新时再次被调用。</p><pre class="ki kj kk kl gt mu mv mw mx aw my bi"><span id="043c" class="mz lx it mv b gy na nb l nc nd">const tick = time =&gt; {<br/>  let elapsed = time - prevTime;<br/>  prevTime = time;<br/><br/>  moveStars(elapsed*0.1);<br/><br/>  clear();<br/><br/>  const cx = w/2;<br/>  const cy = h/2;<br/><br/>  const count = stars.length;<br/>  for (var i = 0; i &lt; count; i++) {<br/>    const star = stars[i];<br/><br/>    const x = cx + star.x/(star.z * 0.001);<br/>    const y = cy + star.y/(star.z * 0.001);<br/><br/>    if (x &lt; 0 || x &gt;= w || y &lt; 0 || y &gt;= h){<br/>      continue;<br/>    }<br/><br/>    const d = (star.z/1000.0)<br/>    const b = 1-d*d<br/><br/>    putPixel(x, y, b);<br/>  }<br/><br/>  requestAnimationFrame(tick);<br/>};</span></pre></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="d147" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">及时移动</h1><p id="2bfa" class="pw-post-body-paragraph kt ku it kv b kw mo ju ky kz mp jx lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">tick函数确定自上次调用以来已经过去了多长时间。</p><p id="228f" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">经过的时间告诉我们要移动多少星星。在一个60 fps的环境中，我们将以<code class="fe ne nf ng mv b">1000/60 ~ 16.6</code>毫秒的增量被调用，给或拿。</p><pre class="ki kj kk kl gt mu mv mw mx aw my bi"><span id="5c22" class="mz lx it mv b gy na nb l nc nd">moveStars(elapsed*0.1);</span></pre><p id="3e31" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我取这个数字，将其缩放到10%，所以它在<code class="fe ne nf ng mv b">1.6</code>左右，并且将所有的星星向前移动这个值。如果你想要更快或更慢的恒星，相应地缩放。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi of"><img src="../Images/97ec2d64a53a7441bec3aa41e865c5da.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/1*MXZTaliOjutneXguvoZ5xA.gif"/></div><p class="kp kq gj gh gi kr ks bd b be z dk translated">更快的恒星缩放时间由0.1改为1.9</p></figure></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="d0d8" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">用透视画法画星星</h1><p id="98af" class="pw-post-body-paragraph kt ku it kv b kw mo ju ky kz mp jx lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">接下来，画布被清空，所有的星星被绘制成一个循环。画布上的<code class="fe ne nf ng mv b">x</code>和<code class="fe ne nf ng mv b">y</code>坐标来自星星的<code class="fe ne nf ng mv b">x</code>、<code class="fe ne nf ng mv b">y</code>和<code class="fe ne nf ng mv b">z</code>坐标。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="bd68" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">协调</h1><p id="0026" class="pw-post-body-paragraph kt ku it kv b kw mo ju ky kz mp jx lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">我们需要做两件事来将星形坐标转换成画布坐标。</p><p id="5be1" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">首先，我们需要引入透视，所以更远的恒星更接近消失点。</p><p id="23ad" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">其次，我们需要将虚拟坐标转换成画布坐标。画布坐标的原点在左上角，而不是画布的中心，所以我们需要考虑这一点。</p><p id="4c31" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们的视角以我们的消失点为中心。在<code class="fe ne nf ng mv b">-200, -100, 100</code>离我们相对较近的一颗恒星应该出现在中心的左上方。在<code class="fe ne nf ng mv b">-200, -100, 900</code>更远处的一颗星也应该出现在左上角，但是更靠近消失点。所有其他象限也是如此:如果一颗恒星更近，它应该转换到更靠近<code class="fe ne nf ng mv b">0</code>的可见坐标。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi og"><img src="../Images/dd533a6fb1315cb5df6958af28bdd47a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CUUyI4SuNcecJVT8fqWk6A.png"/></div></div><p class="kp kq gj gh gi kr ks bd b be z dk translated">您可以通过1/z *阻尼缩放来实现透视</p></figure><p id="8c21" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">为了达到这个效果，我们可以简单地将<code class="fe ne nf ng mv b">x</code>和<code class="fe ne nf ng mv b">y</code>除以<code class="fe ne nf ng mv b">z</code>。<code class="fe ne nf ng mv b">z</code>越高，我们越接近零。然而，除以<code class="fe ne nf ng mv b">z</code>直接导致了一个相当严重的下降。我们需要让它看起来更有说服力。所以我们缩放除以的值。我用了<code class="fe ne nf ng mv b">0.001</code>。玩一玩，挑一个你喜欢的值。</p><p id="0e9c" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">完成后，我们将坐标偏移画布尺寸的一半，有效地将从零开始的坐标推到画布的中心。</p><pre class="ki kj kk kl gt mu mv mw mx aw my bi"><span id="5376" class="mz lx it mv b gy na nb l nc nd">const x = cx + star.x/(star.z * 0.001);<br/>const y = cy + star.y/(star.z * 0.001);<br/><br/>if (x &lt; 0 || x &gt;= w || y &lt; 0 || y &gt;= h){<br/>  continue;<br/>}</span></pre><p id="6e9a" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果恒星落在可见区域之外，我们就继续下一个，有效地跳过对不可见恒星的绘制调用。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="a1b1" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">明亮的星星</h1><p id="5f23" class="pw-post-body-paragraph kt ku it kv b kw mo ju ky kz mp jx lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">我们希望离我们较近的星星看起来更亮，而较远的星星看起来更暗。我们知道离我们最远的星星在<code class="fe ne nf ng mv b">z = 1000</code>，所以用<code class="fe ne nf ng mv b">z</code>除以<code class="fe ne nf ng mv b">1000</code>可以得到一个线性的亮度标度。我把这个值叫做<code class="fe ne nf ng mv b">d</code>。</p><p id="3cdb" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">恒星离得越远，<code class="fe ne nf ng mv b">d</code>离<code class="fe ne nf ng mv b">1.</code>越近，恒星离我们越近，<code class="fe ne nf ng mv b">d</code>离<code class="fe ne nf ng mv b">0</code>越近。因为我们希望它离我们近的时候亮度更亮。我们通过计算<code class="fe ne nf ng mv b">1-d</code>来反演该值。</p><p id="5262" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这给了我们一个亮度的线性梯度。</p><p id="67b0" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我稍微调整了一下计算方法，这样恒星看起来会比线性提前一点。我不是减去<code class="fe ne nf ng mv b">d</code>，而是减去<code class="fe ne nf ng mv b">d²</code></p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/880e870d6da631c54e5519f35210034c.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*hoX-8Gq5l7ONMR4oMlpJ_g.png"/></div><p class="kp kq gj gh gi kr ks bd b be z dk translated">一维整体上比线性渐变稍亮</p></figure><pre class="ki kj kk kl gt mu mv mw mx aw my bi"><span id="ca44" class="mz lx it mv b gy na nb l nc nd">const d = (star.z/1000.0)<br/>const b = 1-d*d<br/><br/>putPixel(x, y, b);</span></pre><p id="b0cb" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">剩下的就是调用<code class="fe ne nf ng mv b">putPixel</code>绘图函数，将像素星放到画布上。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="2af4" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="ea9d" class="pw-post-body-paragraph kt ku it kv b kw mo ju ky kz mp jx lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">这就是了。一个基本的3d效果，不需要3d数学。体验愉快！</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><p id="c417" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu"> PS: </strong>如果你准备好更上一层楼，为什么不在你的星域顶部放置一个标志性的星球大战标题爬行呢？</p><div class="om on gp gr oo op"><a href="https://medium.com/better-programming/create-a-star-wars-title-crawl-in-html-c25a76fea401" rel="noopener follow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">创建一个HTML格式的星球大战标题抓取</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">很久很久以前，在一个遥远的浏览器里</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">medium.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ni op"/></div></div></a></div></div></div>    
</body>
</html>