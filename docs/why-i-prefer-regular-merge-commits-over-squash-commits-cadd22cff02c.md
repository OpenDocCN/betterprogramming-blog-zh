# 为什么我更喜欢常规的合并提交而不是挤压提交

> 原文：<https://betterprogramming.pub/why-i-prefer-regular-merge-commits-over-squash-commits-cadd22cff02c>

## 我曾经认为壁球提交是*太酷了*，然后我不得不每天一整天都使用它们。这就是为什么你应该避免壁球

![](img/46109fa2a59f5496ea124df9bb5d0bfd.png)

我其实对南瓜不过敏，只是对南瓜过敏。(照片由[维维安娜·里舍](https://unsplash.com/@vivirishe?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄)

“哇，太酷了！”

我将永远记得看到我第一次壁球提交。

当我第一次加入一个拥有 200 多名成员的大型工程组织时，squash 提交是我注意到的第一件事。

对我来说，整个公司一致使用壁球提交体现了“专业精神”和“我们知道我们在做什么！”

我花了大约一个月的时间才意识到我真的*真的*不喜欢挤压提交，我开始渴望好的、老式的合并提交。

# 挤压与合并 Git 提交的比较

回顾一下,“挤压提交”和“合并提交”之间的区别在于，常规的“合并”包括目标分支历史中的所有 Git 提交，而“挤压”将它们展平为一个提交。

令人困惑的是，“壁球”并不是它自己的命令。相反，当您分别运行`git merge`或`git rebase`命令时，您可以选择“挤压并合并”或“挤压并重设基础”作为选项。

默认情况下，一个拉请求(PR)将是一个合并提交，因此在 PR 被合并之后，工作分支的整个历史将被合并，加上一个额外的提交(“来自分支的合并拉请求# 21……”)。

另一方面，您可以将您的存储库默认设置为“压缩并合并”，这意味着合并的 PRs 将只产生一个提交，而不是从工作分支带来所有的提交。

# 为什么有人会使用挤压提交？

挤压提交的好处是您保留了一个“干净的”Git 提交历史。因为我们开发人员是出了名的…让我们说“精确”吧…那么一个整洁的提交历史听起来绝对不可思议。不是的。

你可以看到为什么我对这种专业精神印象深刻——整个工程组织如此专注于拥有一个干净的提交历史，以至于他们已经强制将“挤压和合并”作为默认设置！

不幸的是，拥有干净的提交历史的好处也就到此为止了——历史可能是干净的，但是我的日常工作需要比压缩提交所能提供的更多的[上下文](https://www.urbandictionary.com/define.php?term=context)。

根据定义，挤压提交会丢失信息。我喜欢把它想象成一个黑洞，在那里信息被转化成“[霍金辐射](https://en.wikipedia.org/wiki/Hawking_radiation)”，在这个特殊的例子中，它是以开发者沮丧的单位来衡量的。

# 壁球提交的压倒性弱点

我很快对 squash 提交失望了，原因很简单，我的工作 90%是修复旧代码中的错误。当我使用 [Git Lens](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens) 运行`[git blame](https://www.git-scm.com/docs/git-blame)`来检查一行时，我永远也学不会所有的东西。

几乎公司的每一个`git blame` 都写着“由{我的老板或同事}提出的合并拉动请求#237”，没有其他信息。如果不手动查找，我甚至找不到公关的主题！多么令人沮丧！

我会尽职尽责地调出原始的 PR 和 ticket，试图了解为什么这一行代码会发生变化，但我不知道。你知道 PR 经常一次修改几百行代码吗？是啊…

我用一个手指就能数出我需要一次恢复一个被压扁的提交的次数，这是一次公关的戏剧性回滚，将我们的整个路线图推迟了整整一个月。

其余的时间，我会做我正常的工作，试图在“你能在今天结束前把这个交给 QA 吗？”的期限内修复 bug。当我检查一行代码时，我不知道它为什么会改变，因为有挤压提交。

# 为什么我不喜欢压缩我的合并提交

听着，我也想有一个干净的提交历史，但是不利的一面是日常工作的瘫痪。虽然很高兴知道“在修复另一个 bug 时出现了这个问题”，但是 squash commit 并没有给我足够的信息。

假设我知道我的老板在 18 个月前用`git blame`检查了某一行代码。在这一点上，他肯定不知道他为什么改变它，即使他能找到时间为我调查它。

使用 squash 提交，留给我的信息更少:我只能找到导致行被更改的 bugfix 或特性，而不是行被更改的实际原因，这不足以继续。

虽然如果每一行都有一两个代码注释会很好，但我们都知道大多数开发人员不是这样工作的——当我查看新的 React 代码库时，我通常看到不到 1%的代码实际上有任何注释。

我不知道为什么代码改变的原因很简单；我的老板当时写下了原因(在提交消息中)，但后来我们决定毫无理由地“压制”它。[那确实*而不是*激起欢乐](https://knowyourmeme.com/memes/does-it-spark-joy)。

# 解决方案是合并提交，而不是挤压提交

这里有一个超级简单的解决方案，它实际上是默认的——只是不要挤压。我想知道的并不多，但这很重要:

*   重构:我的老板是否“重构”了这段代码，以提高可读性或可维护性，希望不会影响实际的功能？
*   杂务:我的老板是否在做一些不应该影响产品代码的清理“杂务”，比如添加代码注释或测试？
*   修复:我的老板是否“修复”了一个已识别的问题，如果是，这段代码破坏的具体问题是什么？
*   专长:我的老板是否在实现一个新的特性，比如创建一个具有面向用户功能的全新组件？

你是否意识到这些是[常规提交](https://www.conventionalcommits.org/en/v1.0.0/)(也称为[语义提交](https://gist.github.com/joshbuchea/6f47e86d2510bce28f8e7f42ae84c716))，最好与[原子提交](https://www.freshconsulting.com/insights/blog/atomic-commits/)配对？

我对该公司如此失望的原因是，围绕承诺信息有一种很好的文化，但围绕公关却很糟糕。

因为我们有超长的 JIRA 票，所以没有很好的理由在公关中写太多，但后来我们通过挤压扔掉了所有的上下文。

结果是我们会花上几个小时试图修复错误，因为没有人记得任何给定的代码片段应该做什么。

所以，在我现在的公司，我一天要做几十个提交，当我合并我的 pr 时，我会把它们都留在历史中。这可能有点乱，但对我的理智有好处，对[我的 GitHub 贡献图](https://github.com/doctorderek)也有好处。

编码快乐！

另外，如果你喜欢这个关于 Git 最佳实践的热门话题，那么你会喜欢我试图说服你写 200 个字符的提交消息，对吗？读读这个:

[](/an-advice-for-developers-great-git-commit-messages-are-not-shorter-than-50-characters-2becf8fd481a) [## 给开发者的一个建议:“伟大的 Git 提交消息不要短于 50 个字符”

### 这个神话来自于 80 列 x 25 行的文本终端时代。这就是为什么你应该写长的提交消息

better 编程. pub](/an-advice-for-developers-great-git-commit-messages-are-not-shorter-than-50-characters-2becf8fd481a) 

德里克·奥斯汀博士是《职业编程:如何在 6 个月内成为一名成功的 6 位数程序员 》一书的作者，该书现已在亚马逊上架。