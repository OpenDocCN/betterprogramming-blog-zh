<html>
<head>
<title>Upload and Retrieve Images by Integrating MinIO With NestJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过集成MinIO和NestJS上传和检索图像</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/upload-and-retrieve-images-by-integrating-minio-with-nestjs-419e4e629b5d?source=collection_archive---------0-----------------------#2021-02-09">https://betterprogramming.pub/upload-and-retrieve-images-by-integrating-minio-with-nestjs-419e4e629b5d?source=collection_archive---------0-----------------------#2021-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0200" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">基于网络的应用程序的最小设置</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4220cd419b4e4c25032549e172ce7c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d8NgiSIGsXxV80Cb"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kv" href="https://unsplash.com/@tamanna_rumee?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tamanna Rumee </a>拍摄的照片。</p></figure><p id="fe4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">注意:如果您打算在本地安装MinIO，本文假设您已经在本地机器上安装了Docker。如果您在这里只是学习如何将MinIO与NestJS集成或者连接到外部MinIO服务器，那么您不需要Docker。</em></p><p id="78b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们开始讨论如何将MinIO与NestJS集成之前，让我们先来回答一下MinIO和NestJS是什么以及为什么。</p><p id="3115" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于那些不熟悉MinIO和NestJS的人来说，下面是对这两个工具是什么以及为什么使用它们的快速总结。尽管立即跳到实践环节可能很有诱惑力，但我建议你先了解你在做什么——尤其是如果你是新手的话。知道如何使用这些工具是一回事，但当你知道何时以及如何在正确的情况下应用它们时，它会更有价值。</p><p id="b16f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您已经熟悉这些工具，请随意跳过。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="e7d5" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">MinIO是什么？</h1><p id="387e" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">MinIO是一个对象存储服务器，实现了和亚马逊S3相同的公共API。它也可以被视为一个开源的、高性能的云替代方案。它的最大单个文件上传大小为5TB，与其他云服务提供的大小大致相同，并且也是为企业准备的。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="9230" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">为什么要用MinIO？</h1><p id="a070" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">既然我们已经有了云(例如AWS、GCP、Azure)，为什么我们还要托管自己的云呢？乍一看，这似乎有些多余，但是原因很简单。请记住，MinIO是作为企业解决方案构建的。一些公司已经拥有他们花费了数十万美元的现有基础设施，迁移到云并不是一个明智的想法。他们可以不使用第三方云服务，而是使用MinIO，这实质上允许他们拥有一个自托管的云平台。这意味着他们可以重用现有的基础架构，并为其提供类似云的功能。</p><p id="e396" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些公司也有政府合同，这意味着他们不能简单地使用第三方云服务，因为他们需要满足特定的要求。这就是MinIO发挥作用的地方。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="2982" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">什么是NestJS？</h1><p id="dd49" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在其<a class="ae kv" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank">官方主页</a>上，该团队将NestJS描述为一个开源、可扩展、通用和进步的Node.js框架。</p><p id="2bb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他们的<a class="ae kv" href="https://docs.nestjs.com/" rel="noopener ugc nofollow" target="_blank">官方文档</a>实际上很好地解释了什么是NestJS，但长话短说，它提供了一种灵活的模块化方法来创建你的后端API——更不用说它是用TypeScript构建的并且完全支持TypeScript。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ae79" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">为什么要用NestJS？</h1><p id="f338" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">因为NestJS是用TypeScript构建的，所以它越来越受到许多公司的青睐——特别是如果他们正在构建大规模的应用程序。NestJS还提供了很棒的文档，这使得它非常容易学习。NestJS提供的另一个有用的工具是NestCLI，这是一个命令行界面工具，允许您快速直观地搭建和维护您的嵌套应用程序。它还支持大量的数据库和模块，如TypeORM、GraphQL和OpenAPI。</p><p id="e41a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您需要一个可靠的Node.js框架来支持一系列特性，那么NestJS正是您所需要的。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="159d" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">实践课程</h1><p id="e1a2" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">现在，您已经理解了这两种工具的用途和原因，很明显它们是一个非常好的组合。两者都是企业就绪的解决方案，所以如果你是一家计划自己托管一些服务的公司，试试看。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="fe86" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">初始设置</h1><p id="35c6" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在我们开始之前，确保已经配置了NestJS和MinIO。<br/>我推荐用Docker设置MinIO。但是，如果您正在尝试与一个已经存在的MinIO实例(可能由您正在使用的客户端处理)集成，下面有一节专门针对这一点！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="8228" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">设置NestJS</h1><p id="1acb" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">按照<a class="ae kv" href="https://docs.nestjs.com/first-steps#setup" rel="noopener ugc nofollow" target="_blank">文档</a>中提供的步骤运行您的Nest应用程序。安装后，使用以下命令启动应用程序:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="0999" class="nc mb iq my b gy nd ne l nf ng">npm run start:dev </span></pre><p id="3ac4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">导航到<a class="ae kv" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>，您应该会看到<code class="fe nh ni nj my b">Hello World!</code>消息。如果这有效，NestJS就成功地安装在您的系统上了！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="9d61" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">设置MinIO</h1><p id="8f98" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">使用Docker是让MinIO快速启动并运行的最简单的方法。<a class="ae kv" href="https://docs.min.io/" rel="noopener ugc nofollow" target="_blank">文档</a>指导我们完成一个非常简单的设置过程。在NestJS创建的项目目录中，运行下面的命令:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="86d2" class="nc mb iq my b gy nd ne l nf ng">docker run -p 9000:9000 minio/minio server /data</span></pre><p id="e03b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将使用<code class="fe nh ni nj my b">minioadmin</code>作为访问和密钥来初始化MinIO。如果您想将默认密钥更改为您自己的密钥，您可以这样做:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="e01f" class="nc mb iq my b gy nd ne l nf ng">docker run -p 9000:9000 \<br/>  -e "MINIO_ROOT_USER=AKIAIOSFODNN7EXAMPLE" \<br/>  -e "MINIO_ROOT_PASSWORD=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY" \<br/>  minio/minio server /data</span></pre><p id="0633" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj my b">MINIO_ROOT_USER</code>是访问密钥，而<code class="fe nh ni nj my b">MINIO_ROOT_PASSWORD</code>是秘密密钥。</p><p id="9030" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦运行，导航到<a class="ae kv" href="http://127.0.0.1:9000/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:9000/ </a>应该会向您呈现MinIO的基于web的对象浏览器。这基本上是一个查看、下载或删除文件的GUI。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="bb81" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">将NestJS与MinIO集成</h1><p id="0539" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">完成初始设置后，我们将安装<code class="fe nh ni nj my b">nestjs-minio-client</code>，这是一个用于NestJS 的<a class="ae kv" href="https://github.com/djedlajn/nestjs-minio-client" rel="noopener ugc nofollow" target="_blank"> MinIO客户端，它将使连接MinIO的方式更加容易。安装npm或yarn，如下所示:</a></p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="bb1d" class="nc mb iq my b gy nd ne l nf ng">npm install nestjs-minio-client --save </span><span id="e71f" class="nc mb iq my b gy nk ne l nf ng">yarn add nestjs-minio-client</span></pre><p id="6455" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成后，我们需要为NestJS创建模块:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5dea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我们可以从修改我们的<code class="fe nh ni nj my b">minio-client.module.ts</code>文件开始:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a49e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你注意到，我们正在使用看起来像<code class="fe nh ni nj my b">configService.get('ENV_VARIABLE_NAME’)</code>的环境变量。由于一些原因，这可能看起来与你传统的<code class="fe nh ni nj my b">process.env.ENV_VARIABLE</code>不同。首先，NestJS推荐使用ConfigService模块，它允许我们在不同的<code class="fe nh ni nj my b">.env</code>文件之间轻松切换。它还允许我们将环境变量配置为全局变量，这样其他模块也可以很容易地使用它们。</p><p id="90cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们采用这种方法的另一个原因是，模块实际上是在加载环境变量之前注册的。这可能会导致您遇到如下所示的错误:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="37bb" class="nc mb iq my b gy nd ne l nf ng">Invalid endPoint: undefined </span></pre><p id="356e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么我们选择调用<code class="fe nh ni nj my b">MinioModule.registerAsync()</code>而不是<code class="fe nh ni nj my b">MinioModule.register()</code>。<code class="fe nh ni nj my b">registerAsync()</code>函数允许首先加载环境变量，然后ConfigService可以获取它们。</p><p id="5bf8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们了解了使用ConfigService的原因，我们首先需要使用以下命令安装所需的依赖项:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="fb5a" class="nc mb iq my b gy nd ne l nf ng">npm i --save @nestjs/config</span></pre><p id="1d4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以将这个模块导入到<code class="fe nh ni nj my b">app.module.ts</code>中。传入<code class="fe nh ni nj my b">isGlobal: true</code>属性允许它在AppModule导入的其他模块中使用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c286" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于额外的上下文，在一个适当的项目场景中，我们通常会有一个<code class="fe nh ni nj my b">.env</code>文件，我们在其中保存密钥和秘密。这是因为在应用程序中直接硬编码你的密钥/密码从来都不是一个好主意。通过检查应用程序的代码，可以很容易地抓取或访问它。只要记住<em class="ls">而不是</em> <strong class="ky ir"> </strong>提交并推送到GitHub或任何其他公共网站就行了！它们也可以被注入到Docker容器中，这在部署过程中非常方便。</p><p id="a2fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们创建我们的<code class="fe nh ni nj my b">.env</code>文件。请记住，环境变量名需要与我们在嵌套应用程序中编写的相匹配:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6146" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设置好之后，我们可以在<code class="fe nh ni nj my b">minio-client</code>文件夹下创建一个<code class="fe nh ni nj my b">file.model.ts</code>，导出我们可能使用的所有必要接口:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e43d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">继续我们的<code class="fe nh ni nj my b">minio-client.service.ts</code>文件，这是执行图像保存和删除的逻辑:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="080c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你仔细观察，我们正在散列日期字符串，并在将它保存到桶中时使用它作为文件名。这样做的原因是我们希望避免重复的文件名。这样做还可以避免文件名中的空白字符问题，空白字符会在文件检索过程中引起问题。</p><p id="b0f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设置好服务文件后，现在是时候创建我们的模块了，该模块将实际接收和处理API调用。通常建议将代码分割成模块，这是NestJS的要点。因此，我们可以创建一个名为<code class="fe nh ni nj my b">image-upload</code>的新模块来处理图像上传:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="da88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以修改我们的<code class="fe nh ni nj my b">image-upload.service.ts</code>文件了。这里，我们将使用我们在<code class="fe nh ni nj my b">minio-client.service.ts</code>中创建的上传功能。如果您还记得，它会返回一个包含上传图像的完整路径的<code class="fe nh ni nj my b">url</code>属性。可以返回给控制器，然后在我们进行API调用时作为响应返回:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="01e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦处理好，我们就可以修改<code class="fe nh ni nj my b">image-upload.controller.ts</code>。我们可以使用<code class="fe nh ni nj my b">FileInterceptor</code>拦截器来处理以<code class="fe nh ni nj my b">multipart/form-data</code>格式发布的数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1430" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们需要将<code class="fe nh ni nj my b">MinioClientModule</code>导入到<code class="fe nh ni nj my b">image-upload.module.ts</code>中，因为我们正在使用<code class="fe nh ni nj my b">MinioClientService</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="adda" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">斗牛中的最后一剑</h1><p id="b5f1" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">唷，那是一大堆的设置。在我们开始发布数据之前，让我们先重启NestJS，因为我们添加了新的环境变量。我们还将通过MinIO浏览器创建我们的bucket。确保桶名与您在<code class="fe nh ni nj my b">.env</code>文件中输入的相匹配。重启NestJS时，确保终端中没有记录错误。</p><p id="3cc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用Postman来发送我们的请求，因为我们在本教程中没有设置前端应用程序。您的POST请求应该发送到<a class="ae kv" href="http://localhost:3000/image-upload" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/image-upload</a>，因为这是我们在<code class="fe nh ni nj my b">image-upload.controller.ts</code>下设置的端点。在“Body”选项卡下，确保选择<code class="fe nh ni nj my b">form-data</code>并将键设置为<code class="fe nh ni nj my b">image</code>并将类型设置为<code class="fe nh ni nj my b">File</code>。可以参考下面的截图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/7e66277b7a1ecc5ba30838dadeee2367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8fIPsobgJVLeju9n0jrxWw.png"/></div></div></figure><p id="3e09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的请求通过了，而NestJS没有报告任何错误，这意味着它成功了！如果您刷新MinIO浏览器，您现在应该可以在那里看到您的文件。</p><p id="fd03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您试图导航到通过POST响应返回的URL，您将会意识到您被要求登录。你可能希望它只显示图片，如果你使用AWS或GCP等第三方云服务，这是可以预料的行为。那么，这是怎么回事？你不会想给别人你的访问权和密钥，对不对？</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="0bc7" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">收尾</h1><p id="c8d8" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">为了确保我们可以通过URL直接检索图像，就像我们通常对AWS或GCP所做的那样，我们需要修改bucket的策略。我们可以使用<code class="fe nh ni nj my b">setBucketPolicy</code>函数来修改bucket的策略，并使其可公开访问。由于我们只需要调用<code class="fe nh ni nj my b">setBucketPolicy</code>一次，我们可以临时修改<code class="fe nh ni nj my b">minio-client.service.ts</code>中的代码，并用它来调用构造函数中的那个函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3742" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦文件被保存，NestJS将自动重启，并进行新的修改(假设您使用了<code class="fe nh ni nj my b">npm run start:dev</code>)。如果没有，就停止并再次启动NestJS。您应该在输出中看到这一点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/e4165d86e5cbe2ab3c66198fffe26f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AUCM2TTQYRe_2mRTOXEeuw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">NestJS应注销“存储桶策略集”</p></figure><p id="7492" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您看到这个输出，您现在可以删除我们所做的更改，因为我们只需要它运行一次，而不是每次应用程序启动时。如果您现在导航到该URL，您应该会看到我们的图像立即加载，而不会提示您输入登录凭据！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/4706e395f5b9f5989c943d8db2eade63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*biCC9wOEaNMSN7esiLE5DA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一旦设置了新策略，您应该会立即看到该图像。</p></figure><p id="4ccc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就对了。我们成功地设置并集成了MinIO和NestJS，并让它们上传、存储和检索图像！给你们自己一点鼓励！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="4bce" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="d35f" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">事实证明，将MinIO和NestJS结合使用比想象的要简单。老实说，设置非常简单，我们不需要配置任何实例，也不需要经历这个过程中的那么多步骤。</p><p id="1159" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，这是在本地运行，而不是在世界任何地方公开。但是，如果您已经有了现有的基础架构，或者您的客户想知道他们是否应该迁移到云，那么您现在知道了一个新的替代方案！</p><p id="427c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想感谢你们所有人花时间通读并阅读这篇文章。我希望它能帮助你学习新的东西，或者在你尝试类似的事情时作为一个指南。</p></div></div>    
</body>
</html>