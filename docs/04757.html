<html>
<head>
<title>Get Started With Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/get-started-with-golang-fb75e3b180db?source=collection_archive---------11-----------------------#2020-05-06">https://betterprogramming.pub/get-started-with-golang-fb75e3b180db?source=collection_archive---------11-----------------------#2020-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b5cf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">初学者指南—立即学习围棋！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bcfd4754b6d6258bb0ea94148d848ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WEXWsv23IUK0zdtvAp9oeg.png"/></div></div></figure><p id="3374" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Golang也称为Go，是一种开源编程语言，由Google开发人员Robert Griesemer、Ken Thompson和Rob Pike在2007年创建。它是为了易于使用而创建的，许多开发人员称赞它构建了简单、可靠的程序。</p><p id="0c3d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">自发布以来，Golang越来越受欢迎。在2009年和2016年，英语被选为年度语言。它在2018年排名第10位，并继续进入<a class="ae lq" href="https://hub.packtpub.com/why-golan-is-the-fastest-growing-language-on-github/" rel="noopener ugc nofollow" target="_blank">主要组织</a>。</p><p id="6ea0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种语言有很多优点。任何想在谷歌工作的人都应该知道这一点。今天，我要给你一个关于Go编程语言的深度教程。</p><p id="e87c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今天我们将讨论:</p><ul class=""><li id="7924" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated"><a class="ae lq" href="#d680" rel="noopener ugc nofollow">Golang功能概述</a></li><li id="e6d3" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="#4c71" rel="noopener ugc nofollow">围棋中的基本术语和概念</a></li><li id="cfd0" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="#e1b8" rel="noopener ugc nofollow">围棋中的中级概念</a></li><li id="d3fb" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="#5832" rel="noopener ugc nofollow">围棋中的高级概念</a></li><li id="5791" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="#a1af" rel="noopener ugc nofollow">资源</a></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/e9d00943db7f9c899787297fd2517edb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-N5kG0GEzHBPbOxw.png"/></div></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="d680" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">Golang功能概述</h1><p id="a1f7" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">这种通用编程语言包含了其他编程语言的许多优秀特性。它是编译的、简单的、并发的、静态类型的、高效的。Go改进了编程语言的这些方面，简化了开发人员的工作环境。</p><p id="c105" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go本质上是一种支持并发概念的命令式语言。它带来了面向对象编程的一些优秀特性，比如接口，但是忽略了一些缺陷。Go被有意设计为排除OOP的更多重要特性。</p><p id="9e3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这方面，Go是混合的，包括了许多语言的最好的特性，有一个清晰的，有表现力的类型系统，同时保持了轻量级和易学性。</p><p id="be33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go可用于各种软件开发解决方案，如系统编程语言、通用编程语言或通用支持。它可以处理大量以服务器为中心的web服务、文本处理问题和大量分布式应用程序。</p><h2 id="37e2" class="nl mo it bd mp nm nn dn mt no np dp mx ld nq nr mz lh ns nt nb ll nu nv nd nw bi translated">为什么要学Golang？</h2><p id="17f1" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated"><strong class="kw iu">熟悉又易学。Go属于C家族，所以它与Java和C++等语言有许多相似之处。但是Go提供了更简洁的语法，所以更容易学习和阅读。与Python和Ruby类似，它也集成了动态编程的许多特性。</strong></p><p id="4436" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">满足开发者需求。</strong> Go试图满足开发者面临的一些常见需求。它加速了软件开发过程，而不影响效率。Go旨在通过网络通信、内存管理和速度来支持发展中的市场。</p><p id="f7e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">服务器端的简单性。</strong> Go使你的代码的服务器端工作变得容易。标准的Go库提供了标准的HTTP协议。</p><p id="4465" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经了解了围棋是什么，以及它能给我们带来什么，让我们进入基础部分。今天，我们将向您介绍Go编程语言的主要概念和核心构造。和往常一样，你需要一个更强大的课程来教你所有的细节。</p><p id="d09a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们跳进来吧！</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="4c71" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">围棋基础术语和概念</h1><h2 id="513f" class="nl mo it bd mp nm nn dn mt no np dp mx ld nq nr mz lh ns nt nb ll nu nv nd nw bi translated">文件名、关键字、标识符</h2><p id="b9ec" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated"><strong class="kw iu"> Go源代码</strong>存储在<code class="fe nx ny nz oa b">.go</code>文件中。所有文件名都是小写，可以用<code class="fe nx ny nz oa b">_</code>分隔多个单词。与大多数文件名一样，不能使用空格或特殊字符。</p><p id="03ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">Go中的关键字</strong>功能与大多数编程语言类似。这些是保留字，在您的代码中使用时具有特殊的含义。与Java或C++不同，Go的关键字少得多，更容易使用和学习。这些关键字是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/fbe9858f6bad85a4d93294c43129793e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tOuUsujwMice4f1a.png"/></div></div></figure><p id="cd8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">标识符</strong>类似于关键字，但是你是作为程序员来做的。您可以为变量、模板等元素指定名称。和大多数编程语言一样，标识符是区分大小写的。它们必须以字母或下划线开头，后跟数字。空白标识符<code class="fe nx ny nz oa b">_</code>可以在声明或变量赋值中使用。还有36个预先声明的标识符，它们是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/9970b0abaee54ce8a23b48697f229b96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TCZJyISpHwFueQoL.png"/></div></div></figure><h2 id="b750" class="nl mo it bd mp nm nn dn mt no np dp mx ld nq nr mz lh ns nt nb ll nu nv nd nw bi translated">基本结构</h2><p id="862d" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">Go中的程序是由关键字、运算符、类型、函数和常量组成的。代码由语句构成，但它不需要像许多其他C系列语言那样以<code class="fe nx ny nz oa b">;</code>结尾。如果多条语句写在一行，你必须用<code class="fe nx ny nz oa b">;</code>把它们分开。</p><p id="161b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go使用与其他语言类似的标点符号，包括<code class="fe nx ny nz oa b">.</code> <code class="fe nx ny nz oa b">,</code> <code class="fe nx ny nz oa b">;</code> <code class="fe nx ny nz oa b">:</code>和<code class="fe nx ny nz oa b">...</code>。Go在其代码中使用了三个分隔符:<code class="fe nx ny nz oa b">( )</code> <code class="fe nx ny nz oa b">[ ]</code>和<code class="fe nx ny nz oa b">{ }</code>。</p><h2 id="bd57" class="nl mo it bd mp nm nn dn mt no np dp mx ld nq nr mz lh ns nt nb ll nu nv nd nw bi translated">数据类型和变量</h2><p id="e3ad" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">像许多编程语言一样，<strong class="kw iu">变量</strong>包含不同类型的数据，这些数据定义了一组值或可以作用于这些值的操作。在Go中，您可以使用四种主要的数据类型:</p><ul class=""><li id="7544" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">初级(又名。原语):<code class="fe nx ny nz oa b">int</code>、<code class="fe nx ny nz oa b">float</code>、<code class="fe nx ny nz oa b">bool</code>、<code class="fe nx ny nz oa b">string</code></li><li id="1da4" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">结构(又名。复合):<code class="fe nx ny nz oa b">struct</code>、<code class="fe nx ny nz oa b">slice</code>、<code class="fe nx ny nz oa b">map</code>、<code class="fe nx ny nz oa b">array</code>、<code class="fe nx ny nz oa b">channel</code></li><li id="1f16" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">接口:描述类型的行为</li></ul><p id="e481" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Go中，结构化类型没有固有值，而是默认值<code class="fe nx ny nz oa b">nil</code>。</p><p id="0877" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">变量是在执行过程中可以改变的值。为了声明一个变量，我们使用了<code class="fe nx ny nz oa b">var</code>关键字。</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="8942" class="nl mo it oa b gy of og l oh oi">var identifier type = value</span></pre><p id="3a90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，<code class="fe nx ny nz oa b">identifier</code>是变量的名称，<code class="fe nx ny nz oa b">type</code>是类型。与其他C系列语言不同，我们将<code class="fe nx ny nz oa b">type</code>写在变量<code class="fe nx ny nz oa b">identifier</code>之后。当我们在Go中声明一个变量时，内存被初始化。我们还必须使用<code class="fe nx ny nz oa b">=</code>操作符给变量赋值。这个过程叫做给变量赋值。</p><p id="49c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有一种声明变量的简写方式:</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="c90a" class="nl mo it oa b gy of og l oh oi">f := "fruit"<br/>    fmt.Println(f)<br/>}</span></pre><h2 id="180f" class="nl mo it bd mp nm nn dn mt no np dp mx ld nq nr mz lh ns nt nb ll nu nv nd nw bi translated">经营者</h2><p id="9248" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">与许多编程语言一样，<strong class="kw iu">运算符</strong>是执行逻辑或数学运算的内置符号。Golang中有三种类型的运算符:算术、逻辑和按位。</p><p id="ed18" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">逻辑运算符</strong>类似于其他编程语言。然而，Go对可比较的值非常严格。这些操作符包括:</p><ul class=""><li id="7d11" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">等式运算符<code class="fe nx ny nz oa b">==</code></li><li id="6adc" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">不等运算符<code class="fe nx ny nz oa b">!=</code></li><li id="ef7e" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">小于运算符<code class="fe nx ny nz oa b">&lt;</code></li><li id="67c9" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">大于运算符<code class="fe nx ny nz oa b">&gt;</code></li><li id="63c0" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">小于等于运算符<code class="fe nx ny nz oa b">&lt;=</code></li><li id="4f84" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">大于等于运算符<code class="fe nx ny nz oa b">&gt;=</code></li></ul><p id="a4e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">位操作符</strong>处理位模式长度相等的整数变量。一些按位运算符是:</p><ul class=""><li id="7346" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">按位AND运算符<code class="fe nx ny nz oa b">&amp;</code></li><li id="9310" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">按位或运算符<code class="fe nx ny nz oa b">|</code></li><li id="f0f5" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">按位异或运算符<code class="fe nx ny nz oa b">^</code></li><li id="46c8" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">位清零操作符<code class="fe nx ny nz oa b">&amp;^</code></li><li id="b971" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">按位补码运算符<code class="fe nx ny nz oa b">^</code></li></ul><p id="66c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">算术运算符</strong>包括<code class="fe nx ny nz oa b">+</code> <code class="fe nx ny nz oa b">/</code> <code class="fe nx ny nz oa b">%</code>和<code class="fe nx ny nz oa b">*</code>。</p><p id="3607" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些执行常见的算术运算，甚至还有一些快捷方式。举个例子，</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="82d9" class="nl mo it oa b gy of og l oh oi">b = b + a</span></pre><p id="a137" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以缩短为</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="262b" class="nl mo it oa b gy of og l oh oi">b += a</span></pre><h2 id="8959" class="nl mo it bd mp nm nn dn mt no np dp mx ld nq nr mz lh ns nt nb ll nu nv nd nw bi translated">用线串</h2><p id="20c2" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated"><strong class="kw iu">字符串</strong>实现操作UTF-8编码字符串的功能。它们是默认编码的，所以它们可以包含任何语言的字符。这些定义在双引号<code class="fe nx ny nz oa b">“ “</code>之间，可以包含一系列可变宽度的字符，并且是不可变的。</p><p id="dab5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go字符串通常比其他语言中的字符串更好，因为它们使用更少的内存，并且由于UTF-8标准，您不需要解码它们。</p><p id="34ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Golang中有两种字符串文字，解释的和原始的。解释后的字符串用引号括起来，原始字符串用反斜线括起来。</p><p id="5149" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要声明一个字符串，我们使用<code class="fe nx ny nz oa b">string</code>关键字。看看下面的例子，看看它是如何做到的:</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="186e" class="nl mo it oa b gy of og l oh oi">package main<br/>import "fmt"</span><span id="06b1" class="nl mo it oa b gy oj og l oh oi">func main() {<br/>  var s string = "Hello, World"<br/>  fmt.Printf(s)<br/>}</span></pre><p id="bd66" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">输出:</strong>你好，世界</p><p id="f9b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以循环访问字符串中的字符来访问单个元素。我们使用<code class="fe nx ny nz oa b">for</code>循环，我们将在后面详细讨论。</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="e51d" class="nl mo it oa b gy of og l oh oi">package main<br/>import "fmt"</span><span id="86ed" class="nl mo it oa b gy oj og l oh oi">func main() {<br/>  var s string = "Hello, World"</span><span id="09f3" class="nl mo it oa b gy oj og l oh oi">  for index, character := range(s){<br/>    fmt.Printf("The character %c is in position %d \n", character, index)<br/>  }<br/>}</span></pre><p id="ed08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">输出:</strong> <br/>字符H在位置0</p><p id="c0cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">字符e在位置1</p><p id="4baf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">字符l在位置2</p><p id="6049" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">字符l在位置3</p><p id="0b01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">字符o在位置4</p><p id="a5ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">字符在位置5</p><p id="f278" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">角色在位置6</p><p id="87af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">字符W在位置7</p><p id="9de5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">字符o在第8位</p><p id="2c6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您也可以使用string从一部分字节值形成一个字符串。看看这个例子，看看是怎么做到的:</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="0fc2" class="nl mo it oa b gy of og l oh oi">package main<br/>import "fmt"</span><span id="c62b" class="nl mo it oa b gy oj og l oh oi">func main() {<br/>  myslice := []byte{0x48, 0x65, 0x6C,  0x6C, 0x6f} <br/>  mystring := string(myslice) </span><span id="22ab" class="nl mo it oa b gy oj og l oh oi">  fmt.Printf(mystring)<br/>}</span></pre><p id="fe2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">输出:</strong>你好</p><h2 id="6482" class="nl mo it bd mp nm nn dn mt no np dp mx ld nq nr mz lh ns nt nb ll nu nv nd nw bi translated">时间和日期</h2><p id="9732" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">在Golang中，包<code class="fe nx ny nz oa b">time</code>提供了测量和显示时间的能力。比如我们可以用<code class="fe nx ny nz oa b">time.Now( )</code>显示当前时间，用<code class="fe nx ny nz oa b">t.Day ( )</code>获取更小的部分。Go的<code class="fe nx ny nz oa b">time</code>包有很多有用的特性，比如函数<code class="fe nx ny nz oa b">Since(t Time)</code>，返回从<code class="fe nx ny nz oa b">t</code>开始经过的时间。你也可以制作自己的时间格式。</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="ca02" class="nl mo it oa b gy of og l oh oi">t := time.Now()<br/>fmt.Printf("%02d.%02d.%4d\n", t.Day(), t.Month(), t.Year()) // e.g.: 29.10.2019</span></pre><p id="6672" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于Go的<code class="fe nx ny nz oa b">time</code>包的更多信息，请查看<a class="ae lq" href="http://golang.org/pkg/time/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="e1b8" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">围棋的中级概念</h1><h2 id="eb33" class="nl mo it bd mp nm nn dn mt no np dp mx ld nq nr mz lh ns nt nb ll nu nv nd nw bi translated">控制结构</h2><p id="4aff" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">控制结构和C语言类似，但是它们通常更简单和灵活。没有<code class="fe nx ny nz oa b">do</code>或<code class="fe nx ny nz oa b">while</code>回路。相反，Go使用灵活的<code class="fe nx ny nz oa b">for</code>和<code class="fe nx ny nz oa b">switch</code>循环。</p><p id="e6f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有新的控制结构，比如a型开关和<code class="fe nx ny nz oa b">select</code>。我们不使用括号，并且主体是用括号分隔的。让我们更深入地看看Go控制结构。</p><p id="dec6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个构造测试一个条件语句，逻辑的或者布尔的。如果语句是<code class="fe nx ny nz oa b">true</code>，则执行{ 0 }之间的正文。如果是<code class="fe nx ny nz oa b">false</code>，则忽略这些语句，执行<code class="fe nx ny nz oa b">if</code>之后的语句。请记住，即使主体中只有一个语句，大括号也是必需的。</p><p id="d2db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nx ny nz oa b">switch-case</code>:这个结构用来代替比较变量和值的长<code class="fe nx ny nz oa b">if</code>语句。这个语句使得在你的代码中转移执行流变得容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/4a0b68a25dde86f41b627ea4120c8c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*e2XfzEby5W5nJYFW.png"/></div></div></figure><p id="eede" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nx ny nz oa b">switch</code>一般比其他语言更灵活。它的一般形式如下:</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="d7bd" class="nl mo it oa b gy of og l oh oi">switch var1 {<br/>case val1:<br/>...<br/>case val2:<br/>...<br/>default:<br/>...<br/>}</span></pre><p id="be10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像<code class="fe nx ny nz oa b">if</code>构造一样，<code class="fe nx ny nz oa b">switch</code>也可以包含初始化语句:</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="4ed5" class="nl mo it oa b gy of og l oh oi">switch initialization; {<br/>case val1:<br/>...<br/>case val2:<br/>...<br/>default:<br/>...<br/>}</span></pre><p id="3f2a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nx ny nz oa b">select</code>:这句话的意思是我们可以等待多通道操作，我们将在后面详细讨论。</p><p id="a2a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nx ny nz oa b">for-range</code>:在Go中，这个语句允许我们迭代一个计算为数组、切片、映射、字符串或通道的表达式。基本语法如下:</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="bbfb" class="nl mo it oa b gy of og l oh oi">for index, value := range mydatastructure {<br/>        fmt.Println(value)<br/>    }</span></pre><ul class=""><li id="3725" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated"><code class="fe nx ny nz oa b">index</code>:我们要访问的值的索引。</li><li id="3224" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><code class="fe nx ny nz oa b">value</code>:每次迭代的值。</li><li id="f98b" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><code class="fe nx ny nz oa b">mydatastructure</code>:保存我们在循环中访问其值的数据结构。</li></ul><p id="a093" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请记住，这个例子是一个概括。要了解更多有关具体案例的示例，请查看 <code class="fe nx ny nz oa b"><em class="nk">for-range</em></code> <em class="nk">循环</em> <a class="ae lq" href="https://www.educative.io/edpresso/what-is-the-for-range-loop-in-golang" rel="noopener ugc nofollow" target="_blank"> <em class="nk">上的EdPresso镜头，此处为</em> </a> <em class="nk">。</em></p><h2 id="f221" class="nl mo it bd mp nm nn dn mt no np dp mx ld nq nr mz lh ns nt nb ll nu nv nd nw bi translated">功能</h2><p id="6636" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated"><strong class="kw iu">函数</strong>是Golang的基本构建块，因为它拥有函数式语言的许多特性。正如我之前提到的，函数是数据，因为它们有值和类型。围棋程序是由几个函数组成的。最好从<code class="fe nx ny nz oa b">main( )</code>函数开始，按照调用或逻辑顺序编写它们。</p><p id="9197" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数将问题分解成更小的任务，使我们能够重用代码。Go中有三种类型的函数，当它们执行完<code class="fe nx ny nz oa b">}</code>之前的最后一条语句或执行一条返回语句时，所有函数都结束:</p><ul class=""><li id="f9fd" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">使用标识符的普通函数</li><li id="090a" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">匿名或lambda函数</li><li id="f48e" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">方法</li></ul><p id="afdb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用以下语法编写函数:</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="57a7" class="nl mo it oa b gy of og l oh oi">func g() { // VALID<br/> ...<br/>}</span></pre><p id="8fe5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们用这种通用格式来称呼它们:</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="9308" class="nl mo it oa b gy of og l oh oi">pack1.Function(arg1,arg2,...,argn)</span></pre><p id="73b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里<code class="fe nx ny nz oa b">function</code>是<code class="fe nx ny nz oa b">pack1</code>中的函数，<code class="fe nx ny nz oa b">arg1</code>是自变量。当我们调用一个函数时，它复制参数，这些参数被传递给被调用的函数。</p><p id="b288" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看一个函数的例子，看看Go的运行情况。在这里，我们将深入探讨Golang中的<code class="fe nx ny nz oa b">printf( )</code>功能。<code class="fe nx ny nz oa b">print</code>功能允许您打印格式化数据。它需要一个包含我们将要格式化的文本的模板字符串和一些告诉<code class="fe nx ny nz oa b">fmt</code>函数如何格式化的注释动词。</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="925b" class="nl mo it oa b gy of og l oh oi">fmt.printf("Sample template string %s",Object arg(s))</span></pre><p id="c192" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">转换字符告诉Golang如何格式化数据类型。一些常见的说明符有:</p><ul class=""><li id="cf16" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">v-以默认格式格式化值</li><li id="2d88" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">d-格式化十进制整数</li><li id="7519" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">g-格式化浮点数</li><li id="d3e7" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">b —格式化基数为2的数字</li></ul><p id="3ca2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们想打印一个字符串。在模板字符串中可以使用<code class="fe nx ny nz oa b">%s</code>对话字符来打印字符串值。看看下面的代码。<br/>我们还可以在许多其他情况下使用打印功能。要了解更多信息，请查看<a class="ae lq" href="https://www.educative.io/edpresso/how-to-use-the-printf-function-in-golang" rel="noopener ugc nofollow" target="_blank"> Golang打印功能</a>上的EdPresso镜头。</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="b27c" class="nl mo it oa b gy of og l oh oi">package main<br/>import "fmt"</span><span id="bbcd" class="nl mo it oa b gy oj og l oh oi">func main() {<br/>  var mystring = "Hello world"<br/>  fmt.Printf("The string is %s", mystring)<br/>}</span></pre><p id="c1b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">输出:</strong>字符串是Hello World</p><h2 id="dd59" class="nl mo it bd mp nm nn dn mt no np dp mx ld nq nr mz lh ns nt nb ll nu nv nd nw bi translated">地图</h2><p id="e0b2" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated"><strong class="kw iu"> Maps </strong>，在其他编程语言中也称为hashes或dicts，是Go内置的数据类型。这个名字解释了它们的用途:映射<em class="nk">将</em>键映射到值。可以把映射看作是存储键值对的一种方式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/fd8d574d710f17ee041e4b759e54609d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oEFZhgySYplucfZp.png"/></div></div></figure><p id="1cfa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以使用这些来基于键快速查找、检索或删除数据。</p><p id="434c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用以下语法声明一个映射:</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="2ae0" class="nl mo it oa b gy of og l oh oi">var m map[KeyType]ValueType</span></pre><ul class=""><li id="b860" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated"><code class="fe nx ny nz oa b">m</code>是地图变量的名称。</li><li id="eaba" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><code class="fe nx ny nz oa b">KeyType</code>是映射中键的选项数据类型。这也可以在初始化时声明。</li><li id="b980" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><code class="fe nx ny nz oa b">ValueType</code>是键值对中值的数据类型。</li></ul><p id="7547" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在声明时不需要知道映射的长度，所以它可以动态增长。未初始化映射的值是<code class="fe nx ny nz oa b">nil</code>。</p><p id="5563" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看一个具体的Golang地图示例，看看它们是如何制作的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="c7b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">输出:<br/> </strong>在“一”处的地图文字为:1 <br/>在“二”处创建的地图为:3.141590 <br/>在“二”处分配的地图为:3 <br/>在“十”处的地图文字为:0</p><h2 id="2bcb" class="nl mo it bd mp nm nn dn mt no np dp mx ld nq nr mz lh ns nt nb ll nu nv nd nw bi translated">数组和切片</h2><p id="4e76" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">Go中的数组类似于Python，但是它们在Go代码中并不常见，因为它们不灵活并且有固定的大小。相反，<strong class="kw iu">切片</strong>要常见得多，能提供更大的功率。Go中的切片构建了数组，因为它们是Go数组类型的抽象。</p><p id="e4c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要声明数组，我们使用以下语法:</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="eaa8" class="nl mo it oa b gy of og l oh oi">var identifier [len]type</span></pre><p id="92db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">数组的大小是固定的，因为它的长度是其类型的一部分。例如，<code class="fe nx ny nz oa b">[5]int</code>表示由五个整数组成的数组。切片允许我们克服数组的一些挑战，并在不使用额外内存的情况下处理类型化数据序列。</p><p id="2a07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">切片是对数组的连续部分的引用，称为基础数组。切片的大小是动态变化的，非常灵活。它是在我们指定两个索引时形成的，用冒号隔开。我们使用类型规范<code class="fe nx ny nz oa b">[ ]T</code>。t是切片中元素的类型。我们使用以下语法声明一个切片:</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="3571" class="nl mo it oa b gy of og l oh oi">letters := []string{"a", "b", "c", "d"}</span></pre><p id="c5d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要声明带有切片的变量的类型，我们使用带有切片元素类型的<code class="fe nx ny nz oa b">[ ]</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="d82d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与数组不同，切片在执行过程中会发生变化。此外，切片带有内置的<code class="fe nx ny nz oa b">append</code>，它可以返回包含一个或多个新值的切片。<code class="fe nx ny nz oa b">append</code>方法的语法是:</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="7436" class="nl mo it oa b gy of og l oh oi">slice = append(slice, elem1, elem2, ...)</span></pre><p id="6ad0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看看这是怎么做到的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="4e89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">输出:</strong> <br/>长度=0容量=0 [] <br/>长度=1容量=1 [0] <br/>长度=2容量=2 [0 1] <br/>长度=5容量=6 [0 1 2 3 4]</p><p id="cec9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经了解了一些中级围棋概念，让我们继续来看看Golang带来的一些高级东西。请记住，还有很多东西需要学习。其他一些中间概念包括:</p><ul class=""><li id="7d21" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">递归函数</li><li id="1ba0" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">高阶函数</li><li id="bc91" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">结构和方法</li><li id="67c0" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">接口和反射</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="5832" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">围棋中的高级概念</h1><h2 id="59c8" class="nl mo it bd mp nm nn dn mt no np dp mx ld nq nr mz lh ns nt nb ll nu nv nd nw bi translated">错误处理</h2><p id="d55d" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">Go没有异常处理机制。我们使用内置的接口类型<code class="fe nx ny nz oa b">error</code>。它的零值是<code class="fe nx ny nz oa b">nil</code>，所以如果它返回<code class="fe nx ny nz oa b">nil</code>，我们知道没有错误。处理错误最常见的方法是返回<code class="fe nx ny nz oa b">error</code>类型，作为检查<code class="fe nx ny nz oa b">nil</code>的函数调用的最后一个返回值。</p><p id="76f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看看一些代码，看看它是如何做到的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="affd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">输出:</strong>不能被0除！</p><h2 id="8798" class="nl mo it bd mp nm nn dn mt no np dp mx ld nq nr mz lh ns nt nb ll nu nv nd nw bi translated">戈鲁廷斯</h2><p id="e9f7" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">Go内置了对并发应用的支持。这些程序同时执行不同的代码。构造并发程序的基本构件是<a class="ae lq" href="https://tour.golang.org/concurrency/1" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> goroutines </strong> </a>和<a class="ae lq" href="https://tour.golang.org/concurrency/2" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">通道</strong> </a>。</p><p id="da3d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与Java不同的是，并发支持是通过特定的类型(chan)、关键字(<code class="fe nx ny nz oa b">go</code>、<code class="fe nx ny nz oa b">select</code>)和构造(goroutines)嵌入到语言中的。Go强调并发性而不是并行性，因为Go程序在默认情况下可能不是并行的。无论goroutines是否运行，Go程序都只使用一个内核或处理器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/20bef541c184eb1dde7a9cfc51f1c48c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mr3KvbcmveJotqRy.png"/></div></div></figure><p id="1d36" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，什么是goroutines？它们是与其他方法或函数一起运行的方法或函数。它们取决于我们如何称呼它们。可以把它们想象成线程，但是更容易，更轻量级。</p><p id="9ca8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用关键字<code class="fe nx ny nz oa b">go</code>来创建一个goroutine，所以当我们调用带有那个前缀的函数或方法时，一个goroutine就会被执行。</p><p id="bac4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想更好地了解Goroutines，请查阅Go 中的文章<a class="ae lq" href="https://medium.com/rungo/anatomy-of-goroutines-in-go-concurrency-in-go-a4cb9272ff88" rel="noopener">剖析goroutines。</a></p><p id="48ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以使用变量<code class="fe nx ny nz oa b">GOMAXPROCS</code>告诉运行时可以执行多少个goroutines。<code class="fe nx ny nz oa b">GOMAXPROCS</code>必须设置为大于缺省值1，否则所有的goroutines将共享同一个线程。</p><p id="9b10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="6fdb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">输出:<br/> </strong> In main() <br/>关于睡眠in main() <br/>开始longWait() <br/>开始shortWait() <br/>结束shortWait() <br/>结束longWait() <br/>结束main()</p><p id="18d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，程序表示程序所处的执行阶段的一部分。功能<code class="fe nx ny nz oa b">main( )</code>、<code class="fe nx ny nz oa b">shortWait( )</code>和<code class="fe nx ny nz oa b">longWait( )</code>作为独立的处理单元启动，然后并发工作。</p><p id="da71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通道与goroutines一起使用，以实现它们之间的<em class="nk">通信</em>。这些是传输数据的类型化消息队列。可以把它们想象成可以发送类型值的管道。这样，我们可以避免在goroutines之间共享内存。一个通道可以传输一种数据类型，但是我们可以为任何类型传输它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/a94b86196b394770d69276606747ae28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ntUlnY9gw34rZP33.png"/></div></div></figure><p id="b6ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要声明通道，我们使用以下格式:</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="bd82" class="nl mo it oa b gy of og l oh oi">var identifier chan datatype</span></pre><p id="35c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通道也是一个引用类型，所以，为了分配内存，我们使用了<code class="fe nx ny nz oa b">make( )</code>函数。请参见下面的如何声明字符串通道及其实例化:</p><pre class="kj kk kl km gt ob oa oc od aw oe bi"><span id="1b2e" class="nl mo it oa b gy of og l oh oi">var ch1 chan string<br/>ch1 = make(chan string)</span></pre><h2 id="c986" class="nl mo it bd mp nm nn dn mt no np dp mx ld nq nr mz lh ns nt nb ll nu nv nd nw bi translated">标准库和包</h2><p id="7e48" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">Go发行版包括250多个内置包，所有系统的API都是一样的。每个软件包都为您的Go代码引入了不同的功能。在这里见文档<a class="ae lq" href="https://golang.org/pkg/#stdlib" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="d606" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看它能提供什么。</p><ul class=""><li id="e676" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated"><code class="fe nx ny nz oa b">os/exec</code>:这提供了运行外部操作系统命令和程序的可能性。</li><li id="c1e8" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">这是一个底层的外部包，它为底层操作系统的调用提供了一个原始接口。</li><li id="3954" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><code class="fe nx ny nz oa b">archive/tar</code>和<code class="fe nx ny nz oa b">/zip – compress</code>:它们包含压缩(解压)文件的功能。</li><li id="decf" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><code class="fe nx ny nz oa b">fmt</code>:包含格式化输入输出功能。</li><li id="eaa7" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><code class="fe nx ny nz oa b">io</code>:这提供了基本的输入输出功能，主要作为操作系统功能的包装。</li><li id="a9a2" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><code class="fe nx ny nz oa b">bufio</code>:这环绕io以提供缓冲的输入输出功能。</li><li id="772f" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><code class="fe nx ny nz oa b">path/filepath</code>:这个包含了操作目标操作系统的文件名路径的例程。</li><li id="1536" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><code class="fe nx ny nz oa b">strconv</code>:将字符串转换成基本数据类型。</li><li id="0283" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><code class="fe nx ny nz oa b">unicode</code>:这个特殊函数用于Unicode字符。</li><li id="fd8d" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><code class="fe nx ny nz oa b">regexp</code>:这是字符串模式搜索功能。</li></ul><p id="3870" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也有外部第三方Go包可以用<code class="fe nx ny nz oa b">go get</code>工具安装。您需要验证<code class="fe nx ny nz oa b">GOPATH</code>变量已设置，否则，它将被下载到<code class="fe nx ny nz oa b">$GOPATH/src</code>目录中。看看这里的<a class="ae lq" href="https://github.com/golang/go/wiki/Projects" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="e153" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有500多个有用的项目可以介绍到你的围棋程序中。当向现有项目引入新功能时，最好加入一个预先存在的Go库。这需要了解库的API，API约束了调用库的方法。一旦你知道了API，调用库函数并开始。</p><p id="e0fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看导入外部库的完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="d06d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们对围棋中的一些高级概念有所了解。还有很多东西需要学习，包括:</p><ul class=""><li id="83aa" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">接口和反射</li><li id="a9cd" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">误差测试</li><li id="8539" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">匿名通道关闭</li><li id="94a9" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">网络、模板和网络应用</li><li id="c442" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">最佳实践和缺陷</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="a1af" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">资源</h1><p id="45fe" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">Golang是一种令人兴奋的语言，它可以加快开发速度，满足您的现实需求。幸运的是，有许多有用的资源可以学习、练习和与世界分享围棋。</p><h2 id="0c9a" class="nl mo it bd mp nm nn dn mt no np dp mx ld nq nr mz lh ns nt nb ll nu nv nd nw bi translated">课程</h2><ul class=""><li id="099c" class="lr ls it kw b kx nf la ng ld om lh on ll oo lp lw lx ly lz bi translated"><a class="ae lq" href="https://www.educative.io/courses/the-way-to-go" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">要走的路:</strong> </a>通过实践学习围棋核心概念和技术的权威场所</li><li id="5d5d" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="https://www.educative.io/courses/introduction-to-programming-in-go" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">围棋编程入门:</strong> </a>初学者详细说明</li><li id="f4aa" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="https://www.educative.io/courses/mastering-concurrency-in-go" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">掌握围棋中的并发:</strong> </a>适合希望提高技能的中级围棋学习者</li></ul><h2 id="7cc5" class="nl mo it bd mp nm nn dn mt no np dp mx ld nq nr mz lh ns nt nb ll nu nv nd nw bi translated">文档和指南</h2><ul class=""><li id="80f9" class="lr ls it kw b kx nf la ng ld om lh on ll oo lp lw lx ly lz bi translated"><a class="ae lq" href="https://tour.golang.org/welcome/1" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">围棋之旅:</strong> </a>官方围棋教程</li><li id="2735" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="https://golang.org/doc/" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">Golang官方文档:</strong> </a>深入代码</li><li id="f3d2" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="https://github.com/GoBootcamp/clirescue" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">GitHub Go boot camp:</strong></a>边练边学，适合初学者</li></ul><h2 id="9b3e" class="nl mo it bd mp nm nn dn mt no np dp mx ld nq nr mz lh ns nt nb ll nu nv nd nw bi translated">向其他开发者学习</h2><ul class=""><li id="8007" class="lr ls it kw b kx nf la ng ld om lh on ll oo lp lw lx ly lz bi translated"><a class="ae lq" href="https://medium.com/@meeusdylan/why-you-should-learn-go-in-2020-6ce975b66d47" rel="noopener"><strong class="kw iu">2020年为什么要学围棋</strong> </a></li><li id="a199" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="https://www.freecodecamp.org/news/here-are-some-amazing-advantages-of-go-that-you-dont-hear-much-about-1af99de3b23a/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">使用Go from FreeCodeChamp </strong> </a>的优势</li><li id="88f4" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="https://hackernoon.com/should-i-go-the-pros-and-cons-of-using-go-programming-language-8c1daf711e46" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">使用围棋的利弊</strong> </a></li></ul></div></div>    
</body>
</html>