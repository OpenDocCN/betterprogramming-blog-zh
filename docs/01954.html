<html>
<head>
<title>JavaScript Internals: Prototypal Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript内部:原型继承</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-internals-prototypal-inheritance-14b009dd89c8?source=collection_archive---------0-----------------------#2019-10-26">https://betterprogramming.pub/javascript-internals-prototypal-inheritance-14b009dd89c8?source=collection_archive---------0-----------------------#2019-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="10f0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用构造函数和对象实现继承</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/779948990ed99b8d060f63fdda32e8f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nxJNr7Q3IkcBGKzG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@trhammerhead?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布莱森锤</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="b721" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍</h1><p id="c1bc" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在这篇文章中，我们将讨论JavaScript的一个令人困惑的部分——原型继承。因为JavaScript是一种非常灵活的语言，所以有很多方法可以创建对象以及实现继承。使用新的ES2015 <code class="fe mu mv mw mx b">Class</code>语法，事情变得不那么明显了。</p><p id="493a" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我将关注对象如何继承数据和行为，以及如何在没有<code class="fe mu mv mw mx b">class</code>关键字的情况下实现继承。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="eb99" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">什么是继承？</h1><p id="9ca4" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">继承是面向对象编程的核心概念之一，它定义了一种在对象之间共享功能的机制。继承使我们的代码可重用。</p><p id="1676" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在基于类的语言中，如Java或C++，如果你想创建一个对象，你必须定义它的类。例如，<code class="fe mu mv mw mx b">Car</code>类是一个抽象，它代表汽车的集合。</p><p id="634e" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">一个实例，特定的对象，是一个类的成员。在我们的例子中，它可能是一个<code class="fe mu mv mw mx b">BMW</code>。您可以通过创建子类来扩展一个类。例如，<code class="fe mu mv mw mx b">Sedan</code>可以表示从<code class="fe mu mv mw mx b">Car</code>类继承方法和属性的更具体的汽车。</p><p id="c146" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">JavaScript不是基于类的语言。即使ES6引入了类，这样的语法也没有为JavaScript引入新的面向对象的继承模型。尽管如此，继承是基于<em class="nd">原型</em>。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="69c9" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">什么是原型？</h1><p id="4576" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">原型是包含特定状态和行为的对象。它可以与其他对象链接以扩展它们的功能。</p><p id="28c3" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">首先，让我们从调查一个普通的JavaScript对象开始。通常，我们使用对象文字语法创建它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/1727060a824e8709ff18abf235595685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g2Yyngzbx9Z7yz_RcVRWTg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/917ad7d3e35e926d8b53112f574f7cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0eRfApXenqn_GVBGB0wXDg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对象的[[原型]]</p></figure><p id="b7a5" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">JavaScript中的每个对象都有一个特殊的隐藏属性<code class="fe mu mv mw mx b">[[prototype]]</code>，在控制台中显示为<code class="fe mu mv mw mx b">__proto__</code>属性。</p><p id="8fb8" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">该属性由JavaScript引擎隐式管理。它可以是<code class="fe mu mv mw mx b">null</code>或者对一个对象的引用。这种物体被称为<em class="nd">原型</em>。</p><p id="a8ed" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在我们的例子中，它是<code class="fe mu mv mw mx b">Object.prototype</code>对象。如果我们使用返回<code class="fe mu mv mw mx b">target</code>的<code class="fe mu mv mw mx b">[[prototype]]</code>的<code class="fe mu mv mw mx b">Object.getPrototypeOf(target)</code>方法，我们可以检查它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/9b390a136855cbb66ff662dfef3a6a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wKjyWT1CMZYNKeb7riqiIw.png"/></div></div></figure><p id="9d38" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">当您创建一个对象文字时，JavaScript引擎会将<code class="fe mu mv mw mx b">[[prototype]]</code>的值设置为<code class="fe mu mv mw mx b">Object.prototype</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/f986fc407e358fda0b913c9aff0268f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*ij4P47Qe1U8A9Nx87UfZbQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">[[原型]]参考</p></figure><p id="7b3a" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">这种行为允许我们使用<code class="fe mu mv mw mx b">Object.prototype</code>中定义的方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/05c1c617e3902ab54059642a20855f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_bMXFIoM3JJSHU5-pojJdA.png"/></div></div></figure><p id="bcc7" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">每当您试图访问一个特定对象中不存在的属性时，JavaScript引擎会自动查看它的原型。</p><p id="23f0" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">如果原型对象没有所需的属性，引擎将在原型的原型中查找<em class="nd">。这样的搜索一直发生，直到引擎到达原型<code class="fe mu mv mw mx b">Object.prototype</code>，也就是<code class="fe mu mv mw mx b">null</code>。在这种情况下，返回<code class="fe mu mv mw mx b">undefined</code>。</em></p><p id="776d" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在我们的例子中，我们试图访问没有在<code class="fe mu mv mw mx b">button</code>中定义的<code class="fe mu mv mw mx b">toString</code>方法。因此，引擎将遵循指向<code class="fe mu mv mw mx b">Object.prototype</code>的<code class="fe mu mv mw mx b">[[prototype]]</code>参考。之后会执行<code class="fe mu mv mw mx b">toString</code>。</p><p id="1e7c" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">一个对象中的两个或多个原型形成一个<em class="nd">原型链</em>。<code class="fe mu mv mw mx b">Object.prototype</code>永远在它的上面。例如，如果我们创建一个数组，我们可以发现一个原型链:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/553017063b3086713bc4158093294713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4EUjLFqOwF5ZMrxAZz3cXA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/992cadbcf77fe0aaa28004ff314bd3e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZKZlYWLPgHWgd9PnbsZgg.png"/></div></div></figure><p id="7126" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">如我们所见，我们在链中有两个原型。第一个是<code class="fe mu mv mw mx b">Array.prototype</code>，第二个是<code class="fe mu mv mw mx b">Object.prototype</code>。我们可以使用<code class="fe mu mv mw mx b">Array.prototype</code>方法，也可以使用<code class="fe mu mv mw mx b">Object.prototype</code>方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/d1b9d62f91ca2984be43c9c2e2dfef47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TvCA6myrw2Iqx-AQcMpQdg.png"/></div></div></figure><p id="bb47" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">如果我们用相同的构造函数创建许多不同的对象，它们将共享相同的原型<em class="nd">。</em></p><p id="e933" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">例如，如果我们创建许多数组，它们的<code class="fe mu mv mw mx b">[[prototype]]</code>属性将引用同一个<code class="fe mu mv mw mx b">Array.prototype</code>对象。理解这一点很重要，在JavaScript中，对象是通过引用传递的。</p><p id="a59a" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">对原型的引用指向同一个内存空间。因此，<code class="fe mu mv mw mx b">Array.prototype</code>对象的变化将影响其所有实例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/03d75efe0b3746a584b8c507ee03300f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y7s3peNeA_p36Zb6-wxMlA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/a322789c2457e231f75b3d53fdb7d9c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*uE1-ymas2NqlNdApZ2FT9g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">原型链</p></figure><p id="43dc" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">考虑到这一点，我们可以说，在JavaScript中，对象从其他被称为<em class="nd">原型</em>的对象继承而来。现在剩下的就是找出如何将物体与我们自己的原型联系起来。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a08e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">链接原型</h1><p id="cf22" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">有几种方法可以将原型链接到对象。</p><p id="1291" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我们可以使用一种伪经典的方式，使用普通的旧构造函数或ES2015类，它们在幕后使用所有相同的构造函数。或者，我们可以使用一种对JavaScript更自然的方式，使用<code class="fe mu mv mw mx b">Object.create</code>或<code class="fe mu mv mw mx b">Object.setPrototypeOf</code>方法。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="73b0" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">构造函数</h1><p id="004c" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在前面的例子中，我们已经看到了像<code class="fe mu mv mw mx b">Array</code>或<code class="fe mu mv mw mx b">Object</code>这样的内置构造函数。JavaScript引擎将他们的<code class="fe mu mv mw mx b">prototype</code>属性设置为我们的<code class="fe mu mv mw mx b">button</code>和<code class="fe mu mv mw mx b">elements</code>对象。</p><p id="7e6c" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">基本上，构造函数是用<code class="fe mu mv mw mx b">new</code>关键字调用的函数。原来任何函数都可以是构造函数。将构造函数的名字大写以区别于常规函数是一种惯例。</p><p id="3f89" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">构造函数创建并返回一个名为<em class="nd">的对象实例</em>。在创建之前，可以使用<code class="fe mu mv mw mx b">this</code>关键字在构造函数和原型方法中访问实例。</p><p id="18e4" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">JavaScript引擎将实例属性<code class="fe mu mv mw mx b">[[prototype]]</code>设置为构造器属性<code class="fe mu mv mw mx b">prototype</code>的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/8e5017a5515ae91164e3340e3ba070eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lvmUgxrB5ZZYqqgA302gg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/a1bf68024f866ccb489d6e28ac549cac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZdAFM_5sQ6sMKuOfi-hCg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">构造函数原型</p></figure><p id="0103" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在上图中，<code class="fe mu mv mw mx b">Button</code>实例的<code class="fe mu mv mw mx b">text</code>属性被设置为<code class="fe mu mv mw mx b">Submit</code>，它的原型有两个属性——我们的<code class="fe mu mv mw mx b">render</code>方法和<code class="fe mu mv mw mx b">constructor</code>，后者指向用于创建实例的构造函数。</p><p id="5af3" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">当我们使用<code class="fe mu mv mw mx b">Button</code>构造函数创建对象时，它们共享同一个<code class="fe mu mv mw mx b">prototype</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/652f5571a3ed078760f0aad4751f3c6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H6xcNEEwJLUPFaU477112w.png"/></div></div></figure><p id="b07b" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">当我们需要一种方法来创建许多具有相同“类型”的对象时，构造函数会很有用。<code class="fe mu mv mw mx b">instanceof</code> <strong class="ma iu"> </strong>运算符用于在运行时检查对象的类型。</p><p id="d7ec" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">如果对象是特定类的实例，它返回<code class="fe mu mv mw mx b">true</code>。换句话说，对象必须在其原型链中有一个特定构造函数的原型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/516b999dbdf35d4e089c67d424d47f56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XwTWsWVejQBhyR_YzzbW0A.png"/></div></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2519" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">直接链接</h1><p id="8152" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe mu mv mw mx b">Object.create</code>或<code class="fe mu mv mw mx b">Object.setPrototypeOf</code>方法是设置对象的<code class="fe mu mv mw mx b">[[prototype]]</code>属性的另一种方式。与构造函数不同，我们需要做的就是创建子对象和父对象，并构建一个原型链。</p><p id="2daa" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><code class="fe mu mv mw mx b">Object.setPrototypeOf(target, proto)</code>将<code class="fe mu mv mw mx b">target</code>的<code class="fe mu mv mw mx b">[[prototype]]</code>设置为<code class="fe mu mv mw mx b">proto</code>对象或空。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/e99e8032a3ef4d9b0e4cb4efb90e3a35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VvMmC1McPTQlS0x7EQw5SA.png"/></div></div></figure><p id="673a" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><code class="fe mu mv mw mx b">Object.create(proto[, propertyDescriptor])</code>返回一个空对象，其中<code class="fe mu mv mw mx b">proto</code>为<code class="fe mu mv mw mx b">[[Prototype]]</code>。可选地，您可以传递一个<a class="ae ky" href="https://www.javascripture.com/PropertyDescriptor" rel="noopener ugc nofollow" target="_blank">属性描述符</a>来为一个新对象添加属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/48d650d2399fcf0efa1553b544ffde4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjFcHsI96shuWQ3xaYTBGg.png"/></div></div></figure><p id="9252" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我们可以看到<code class="fe mu mv mw mx b">Object.setPrototypeOf</code>更新了一个指定对象的原型链，而<code class="fe mu mv mw mx b">Object.create</code>创建了一个链中只有一个原型的新对象。在这两种情况下，我们得到相同的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/033934717f17a90947728481185b9978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FVUwMpv15NdckII6UxG-KA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">链接原型</p></figure><p id="b0ef" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">使用<code class="fe mu mv mw mx b">Object.create</code>更有效，因为改变原型链会破坏JavaScript引擎优化。<code class="fe mu mv mw mx b">Object.setPrototypeOf</code>可以在构建贯穿整个程序生命周期的长期原型链时使用。</p><p id="1b62" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">使用这些方法的主要优点是它们允许我们直接从其他对象继承。</p><p id="36d6" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">它们通常被用作设置对象的<code class="fe mu mv mw mx b">[[prototype]]</code>的简单方法。每当你想使用一个构造函数来实例化一个对象的时候，用<code class="fe mu mv mw mx b">Object.create</code>来代替它可能会更好。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a8b6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">子类</h1><p id="649d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">有时候，我们想从几个对象中继承。在JavaScript中，要创建一个“子类”，只需在原型链中再添加一个对象。</p><p id="b9e3" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">例如，我们需要在新的仪表板页面上呈现一个可拖动的<code class="fe mu mv mw mx b">clock</code>组件。</p><p id="b655" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">有了描述呈现元素的基本功能的<code class="fe mu mv mw mx b">component</code>抽象，我们可以定义一个<code class="fe mu mv mw mx b">widget</code>来抽象可拖动的元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/58fb5453fd22702e1952310d669d0956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*Mz5-L8Zag-iVjHJ_3YfhmA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">原型遗传</p></figure><p id="f820" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">用<em class="nd">直接链接</em>可以很容易地做到这一点。我们可以使用<code class="fe mu mv mw mx b">Object.setPrototype</code>将<code class="fe mu mv mw mx b">component</code>和<code class="fe mu mv mw mx b">widget</code>对象的原型链链接到<code class="fe mu mv mw mx b">clock</code>对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/3dc7b33f0aaf3fbeb3ccf9f7019c0f90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x_SiWbDX_eSAqyoLOQChxg.png"/></div></div></figure><p id="4b46" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在上面的例子中，我们用需要的方法创建了两个基本对象，<code class="fe mu mv mw mx b">component</code>和<code class="fe mu mv mw mx b">widget</code>。</p><p id="3d65" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">之后，我们使用<code class="fe mu mv mw mx b">Object.setPrototypeOf</code>将它们链接在一起。我们做的最后一件事是创建我们的<code class="fe mu mv mw mx b">clock</code>对象，并将其与原型链链接。</p><p id="a071" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">关于函数构造函数，创建<code class="fe mu mv mw mx b">clock</code>需要更多的代码。首先，我们必须定义<code class="fe mu mv mw mx b">Widget</code>、<code class="fe mu mv mw mx b">Component</code>和<code class="fe mu mv mw mx b">Clock</code>构造函数及其方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/9a27b9b9ba930f454249d1ae90158301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g2FgWLEUy5Zuzs5temHRjQ.png"/></div></div></figure><p id="a55f" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">注意带有<code class="fe mu mv mw mx b">Component.call(this, ...args)</code>和<code class="fe mu mv mw mx b">Widget.call(this, ...args)</code>代码的行。在子函数构造函数中，我们必须用子上下文执行父构造函数。这样做是为了将父构造函数逻辑应用到子构造函数。</p><p id="71c9" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">下一步是将我们的构造器原型链接在一起:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/021a30ebeb785dc27c97b2059844f121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mNk59PLKQBLDCxrJJdQJeQ.png"/></div></div></figure><p id="8fc2" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我们使用<code class="fe mu mv mw mx b">Object.create</code>方法创建一个带有指定原型的空对象，如<code class="fe mu mv mw mx b">Component.prototype</code>或<code class="fe mu mv mw mx b">Widget.prototype</code>。</p><p id="61c3" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">由于我们完全重新定义了<code class="fe mu mv mw mx b">prototype</code>属性，我们需要手动为<code class="fe mu mv mw mx b">constructor</code>属性分配一个构造函数。因此，我们有:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/37b60a9f95d904585e15896e3cbe0fee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EIVj1SD6h6ZpGM4nnaZ61A.png"/></div></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7be7" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="7646" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">当然，您可以使用ES2015类来保持简单。而且，在很多情况下，这已经足够了。但是，了解语法糖背后发生的事情会让你有能力发掘原型的全部潜力。</p></div></div>    
</body>
</html>