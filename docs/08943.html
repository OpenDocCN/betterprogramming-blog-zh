<html>
<head>
<title>The Complete Guide to React 18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 18完全指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-complete-guide-to-react-18-dd8763430345?source=collection_archive---------3-----------------------#2021-06-29">https://betterprogramming.pub/the-complete-guide-to-react-18-dd8763430345?source=collection_archive---------3-----------------------#2021-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4556" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">React新特性的最终文档</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5ea39f0ce61526328126a29d8b1e3186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qDaBQhlDUQkNcAl_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aaron Burden </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="8e52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">更新:2022年3月29日，React 18发布。自从我们写了基于React 18 Alpha版本的文章以来，已经过去了9个月。本学习指南在正式版本的基础上进行了全面更新。</em></p><p id="e161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React 18可以用以下命令安装:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="6a25" class="mb mc it lx b gy md me l mf mg">npm i react@latest react-dom@latest</span></pre><p id="4a7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React版本在<code class="fe mh mi mj lx b">package.json</code>的<code class="fe mh mi mj lx b"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/package-jsons-dependencies-in-depth-a1f0637a3129">dependencies</a></code>中更新:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="24e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你安装一个全新的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/an-in-depth-guide-for-create-react-app-5-cra-5-b94b03c233f2"> Create React App </a>，React版本会自动指向React 18，虽然不包括<code class="fe mh mi mj lx b">createRoot</code>的改动。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="a889" class="mb mc it lx b gy md me l mf mg">npx create-react-app react-release-18<br/>cd react-release-18</span></pre><p id="6bc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React 18是一个主要版本，它在客户端和服务器端都带来了变化。它提高了内存使用率，并放弃了对Internet Explorer的支持。</p><p id="d0d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React 18具有以下新功能:</p><ul class=""><li id="5b0a" class="mm mn it lb b lc ld lf lg li mo lm mp lq mq lu mr ms mt mu bi translated">用<code class="fe mh mi mj lx b">createRoot</code>替换渲染。</li><li id="82cc" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated">给<code class="fe mh mi mj lx b">StrictMode</code>添加严格的特效。</li><li id="3a42" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated">更少渲染的自动批处理。</li><li id="2981" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated"><code class="fe mh mi mj lx b">startTransition</code>保持用户界面的响应性。</li><li id="b98d" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated"><code class="fe mh mi mj lx b">useDeferredValue</code>生成延期值。</li><li id="ff2c" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated">并行的<code class="fe mh mi mj lx b">Suspense</code>改进。</li><li id="4a57" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated">更新了服务器渲染API。</li><li id="893a" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated">减少对警告的反应。</li></ul></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="cc79" class="nh mc it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">用createRoot替换Render</h1><p id="b9b0" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">React 18提供了两个根API:遗留根API和新根API。</p><ul class=""><li id="8da1" class="mm mn it lb b lc ld lf lg li mo lm mp lq mq lu mr ms mt mu bi translated">遗留根API——这是用<code class="fe mh mi mj lx b">render</code>调用的现有API，从<code class="fe mh mi mj lx b">'react-dom'</code>导入。这将创建一个在传统模式下运行的根目录。它的工作方式与React 17完全相同。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><ul class=""><li id="4ad8" class="mm mn it lb b lc ld lf lg li mo lm mp lq mq lu mr ms mt mu bi translated">新的根API——新的根API用从<code class="fe mh mi mj lx b">'react-dom/client'</code>导入的<code class="fe mh mi mj lx b">createRoot</code>调用。这个根增加了React 18的所有改进，并支持并发特性。这应该是向前发展的根API。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="f6be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第4行，<code class="fe mh mi mj lx b">root</code>是一个指向顶级数据结构的指针，React使用它来跟踪要呈现的树。在React 18中，它可以随时连接到不同的组件(第3行)。</p><p id="4890" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于新的根，建议使用<code class="fe mh mi mj lx b">root.unmount()</code>，而不是<code class="fe mh mi mj lx b">unmountComponentAtNode(container)</code>。</p><p id="cde0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于两个原因，<code class="fe mh mi mj lx b">render</code>和<code class="fe mh mi mj lx b">createRoot</code>都在React 18中提供:</p><ul class=""><li id="7a81" class="mm mn it lb b lc ld lf lg li mo lm mp lq mq lu mr ms mt mu bi translated">平稳升级—允许用户花时间升级。</li><li id="dd36" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated">实验—允许用户比较旧根和新根之间的差异。</li></ul><p id="5a3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于<code class="fe mh mi mj lx b">render</code>被<code class="fe mh mi mj lx b">createRoot</code>取代，<code class="fe mh mi mj lx b">hydrate</code>被<code class="fe mh mi mj lx b">hydrateRoot</code>取代，也是从<code class="fe mh mi mj lx b">react-dom/client</code>输出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="c7f7" class="nh mc it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">向StrictMode添加严格效果</h1><p id="7d9a" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated"><code class="fe mh mi mj lx b">StrictMode</code>是一个突出应用程序中潜在问题的工具。<code class="fe mh mi mj lx b">StrictMode</code>不呈现任何可见的用户界面。它会为其子代激活额外的检查和警告。</p><p id="feac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着React 18的发布，<code class="fe mh mi mj lx b">StrictMode</code>获得了一个额外的行为，称为严格效果模式。当启用了严格效果时，React故意为开发模式中新挂载的组件<em class="lv">双击效果(<code class="fe mh mi mj lx b">mount</code> - &gt; <code class="fe mh mi mj lx b">unmount</code> - &gt; <code class="fe mh mi mj lx b">mount</code>)。</em></p><p id="e187" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么React增加了严格效果？</p><p id="3008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一些特征要求部件被弹性地安装和拆卸不止一次。</p><p id="af36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个这样的特性是快速刷新，它在<a class="ae ky" href="https://medium.com/p/b94b03c233f2" rel="noopener"> Create React App </a>中。它通过在重新加载之间准确地保留组件状态来提供良好的开发体验。</p><p id="70ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mh mi mj lx b">StrictMode</code>中的特效不能关闭。如果有问题，移除<code class="fe mh mi mj lx b">&lt;StrictMode&gt;</code>直到问题解决。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="60c3" class="nh mc it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">较少渲染的自动批处理</h1><p id="dac2" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">批处理是将多个状态更新组合到一个重新渲染中以获得更好的性能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="b216" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第8行，<code class="fe mh mi mj lx b">count</code>状态被更新。在第9行，<code class="fe mh mi mj lx b">flag</code>状态被更新。出于性能原因，第8行不触发重新渲染。因为第9行是最后一次状态更新，所以第8行和第9行同时被重新渲染。此行为节省了一轮渲染，从视觉上看，它同时更改了计数值和颜色。</p><p id="abe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React 17和早期版本为事件处理程序正确地做到了这一点。但是，如果更新在promises、<code class="fe mh mi mj lx b">setTimeout</code>、本地事件处理程序(例如<code class="fe mh mi mj lx b">addEventListener</code>)或任何其他事件中，默认情况下它们不会被批处理。</p><p id="cf8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从React 18开始，如果<code class="fe mh mi mj lx b">rootElement</code>被<code class="fe mh mi mj lx b">createRoot</code>调用，所有的更新都会自动批处理。如果<code class="fe mh mi mj lx b">rootElement</code>被<code class="fe mh mi mj lx b">render</code>调用，旧的行为将被保留。</p><p id="0633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果使用了<code class="fe mh mi mj lx b">createRoot</code>，并且需要立即改变状态，<code class="fe mh mi mj lx b">ReactDOM.flushSync()</code>提供了退出批处理的功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="0be2" class="nh mc it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">开始转换保持用户界面响应</h1><p id="af75" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">你能说出下面这段代码的意图吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="1280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第2行在输入字段中设置一个新的输入值。第6行设置显示更新的查询UI的搜索查询状态的输入值。</p><p id="0c22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe mh mi mj lx b">setSearchQuery</code>需要时间渲染，可能会延迟整个UI的更新，导致屏幕死机。为了让用户感觉到UI是响应性的，我们将第6行放入超时回调或者使用常见的变体，比如节流和去抖动。然后，击键立即显示在屏幕上，随后发生随后的屏幕重新呈现。</p><p id="b40e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React 18提供了一个API<code class="fe mh mi mj lx b">startTransition</code>来执行这种功能。我们可以使用API将非紧急更新标记为转换，以保持浏览器的响应，而转换发生在之后。</p><p id="8920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">状态更新分为两类:</p><ul class=""><li id="909e" class="mm mn it lb b lc ld lf lg li mo lm mp lq mq lu mr ms mt mu bi translated">紧急更新——它们反映了直接的交互，比如打字、点击、按压、拖动等。</li><li id="56bf" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated">转换更新—它们将用户界面从一个视图转换到另一个视图。</li></ul><p id="7fc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了<code class="fe mh mi mj lx b">startTransition</code>，我们不再需要<code class="fe mh mi mj lx b">setTimeout</code>黑客。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="d9f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mh mi mj lx b">startTransition</code>本身立即被调用。执行代码的时间由React决定，与任意延迟相比，这是一个改进。</p><p id="c499" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个<code class="fe mh mi mj lx b">useTransition</code>挂钩提供<code class="fe mh mi mj lx b">isPending</code>和<code class="fe mh mi mj lx b">startTransition</code>。当转换开始时，<code class="fe mh mi mj lx b">isPending</code>转动<code class="fe mh mi mj lx b">true</code>。当转换完成时，<code class="fe mh mi mj lx b">isPending</code>转动<code class="fe mh mi mj lx b">false</code>。<code class="fe mh mi mj lx b">isPending</code>可用于在UI上显示过渡，如微调器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="cae4" class="nh mc it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">useDeferredValue生成延迟值</h1><p id="9c27" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated"><code class="fe mh mi mj lx b">useDeferredValue</code>是一个钩子，它接受一个值并返回该值的一个新副本，该副本将服从更紧急的更新。在紧急更新完成之前，会保留先前的值。然后，呈现新值。这个钩子类似于<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/lodash-create-react-apps-built-in-library-for-debounce-and-throttle-with-hooks-3418087f44d8">使用去抖动或节流来延迟更新</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="9fa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第4行创建<code class="fe mh mi mj lx b">text</code>。第5行基于<code class="fe mh mi mj lx b">text</code>创建了<code class="fe mh mi mj lx b">deferredText</code>。第11行是对输入字段的紧急更新。第13行将延迟值用于非紧急更新。</p><p id="c02e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mh mi mj lx b">useDeferredValue</code>可与<code class="fe mh mi mj lx b">startTransition</code>和<code class="fe mh mi mj lx b">useTransition</code>配合使用。</p><p id="2a49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe mh mi mj lx b">useDeferredValue</code>和<code class="fe mh mi mj lx b">useTransition</code>，React 18中还有其他新的钩子:<code class="fe mh mi mj lx b">useId</code>、<code class="fe mh mi mj lx b">useSyncExternalStore</code>、<code class="fe mh mi mj lx b">useInsertionEffect</code>。详细描述见<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/5-new-hooks-in-react-18-300aa713cefe">5 React 18</a>中的新挂钩。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="24d1" class="nh mc it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">并发暂记变化</h1><p id="5618" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated"><code class="fe mh mi mj lx b">Suspense</code>让组件在渲染之前等待。它可能是一个延迟加载的组件，或者正在等待一个异步API调用来获取一些数据。</p><p id="b9e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在React 18中，<code class="fe mh mi mj lx b">Suspense</code>的工作方式与之前的版本略有不同。React 18中的新行为叫做并发<code class="fe mh mi mj lx b">Suspense</code>。</p><p id="b688" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是典型的<code class="fe mh mi mj lx b">Suspense</code>代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="2398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2号线是悬挂部件。第3行是正常组件。</p><p id="c67a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mh mi mj lx b">ComponentThatSuspends</code>对于遗留<code class="fe mh mi mj lx b">Suspense</code>和并发<code class="fe mh mi mj lx b">Suspense</code>的工作方式相同。React显示<code class="fe mh mi mj lx b">Loading</code>组件(第1行),直到<code class="fe mh mi mj lx b">ComponentThatSuspends</code>中的数据解析。</p><p id="abe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe mh mi mj lx b">Sibling</code>组件，它的工作方式不同。在传统版本<code class="fe mh mi mj lx b">Suspense</code>中，它会被立即挂载到DOM中，并且它的效果/生命周期会被触发。然后组件被React隐藏。在并发的<code class="fe mh mi mj lx b">Suspense</code>中，它不会被挂载到DOM中，它的效果/生命周期也不会被触发，直到<code class="fe mh mi mj lx b">ComponentThatSuspends</code>解决。</p><p id="3a0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Concurrent <code class="fe mh mi mj lx b">Suspense</code>等待<code class="fe mh mi mj lx b">Suspense</code>边界内的一切(挂起的组件及其所有兄弟组件),直到挂起的数据被解析。然后整个树被挂载，并且它的效果/生命周期在一个单一的、一致的批次中同时启动。</p><p id="52e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种新的行为降低了实现的复杂性，并产生了更可预测的行为。对于副作用和突变来说，这是一个小的突破性变化。</p><p id="b9bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并发的<code class="fe mh mi mj lx b">Suspense</code>也会改变从父节点传入的<code class="fe mh mi mj lx b"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/most-things-you-want-to-know-about-react-refs-29901ebf28c6">refs</a></code>的时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="48e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在传统的<code class="fe mh mi mj lx b">Suspense</code>中，<code class="fe mh mi mj lx b">refPassedFromParent.current</code>在<code class="fe mh mi mj lx b">ComponentThatSuspends</code>解析之前的初始渲染中直接指向一个DOM节点。</p><p id="6bf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在并发<code class="fe mh mi mj lx b">Suspense</code>中，<code class="fe mh mi mj lx b">refPassedFromParent.current</code>为<code class="fe mh mi mj lx b">null</code>，直到<code class="fe mh mi mj lx b">ComponentThatSuspends</code>解决并且<code class="fe mh mi mj lx b">Suspense</code>边界未被阻塞。</p><p id="266c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并发<code class="fe mh mi mj lx b">Suspense</code>由正在使用的<code class="fe mh mi mj lx b">createRoot</code>启用。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="152b" class="nh mc it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">更新的服务器渲染API</h1><p id="0d87" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">React 18改版服务器端API，放入<code class="fe mh mi mj lx b">react-dom/server</code>。这些API完全支持服务器上的<code class="fe mh mi mj lx b">Suspense</code>和流式SSR。</p><ul class=""><li id="460c" class="mm mn it lb b lc ld lf lg li mo lm mp lq mq lu mr ms mt mu bi translated"><code class="fe mh mi mj lx b">renderToNodeStream</code>被<em class="lv">弃用</em>。</li><li id="b2ec" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated"><code class="fe mh mi mj lx b">renderToString</code>将一个React元素呈现给它的初始HTML，但是它对<code class="fe mh mi mj lx b">Suspense</code>的支持<em class="lv">有限。</em></li><li id="42c0" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated"><code class="fe mh mi mj lx b">renderToStaticMarkup</code>类似于<code class="fe mh mi mj lx b">renderToString</code>，除了它不会创建额外的DOM属性。它对<code class="fe mh mi mj lx b">Suspense</code>有<em class="lv">有限的</em>支持。</li><li id="2031" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated"><code class="fe mh mi mj lx b">renderToStaticNodeStream</code>类似于<code class="fe mh mi mj lx b">renderToNodeStream</code>，除了它不会创建额外的DOM属性。它继续用于呈现电子邮件。</li><li id="6b00" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated"><code class="fe mh mi mj lx b">renderToPipeableStream</code>节点环境中的流。React 18.0.0中还没有这个新的API。</li><li id="4be3" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated"><code class="fe mh mi mj lx b">renderToReadableStream</code>是针对现代的edge运行时环境，比如Deno和Cloudflare workers。React 18.0.0中还没有这个新的API。</li></ul><h1 id="7522" class="nh mc it bd ni nj od nl nm nn oe np nq jz of ka ns kc og kd nu kf oh kg nw nx bi translated">较少反应警告</h1><p id="8e29" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">对于那些不想要警告/错误消息的人，React 18删除了一些烦人的输出:</p><ul class=""><li id="7502" class="mm mn it lb b lc ld lf lg li mo lm mp lq mq lu mr ms mt mu bi translated">React不再警告组件返回<code class="fe mh mi mj lx b">undefined</code>。</li><li id="32d5" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated">React在卸载的组件上调用<code class="fe mh mi mj lx b">setState</code>时不再警告内存泄漏。</li><li id="d47f" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated">React不再记录端到端测试的<code class="fe mh mi mj lx b">act</code>警告。</li><li id="ba44" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated">React 18不再记录严格模式的第二次渲染。</li><li id="53ef" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated"><code class="fe mh mi mj lx b">renderToString</code>和<code class="fe mh mi mj lx b">renderToStaticMarkup</code>不再出现服务器暂停时的错误。</li></ul></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="1a6a" class="nh mc it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">结论</h1><p id="76aa" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated"><a class="ae ky" href="https://reactjs.org/blog/2022/03/29/react-v18.html" rel="noopener ugc nofollow" target="_blank"> React 18现正式发布</a>。您可以升级项目，以利用新功能获得更好的性能和更可靠的行为。</p><p id="7897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。如果你有兴趣，可以看看<a class="ae ky" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener">我的其他媒体文章</a>。</p></div></div>    
</body>
</html>