# 揭秘 Java Lambda 表达式

> 原文：<https://betterprogramming.pub/demystifying-java-lambda-expressions-d122b4b23b70>

## 凭空变出功能

![](img/20240af0e8e4a21019c08be7c4a6f704.png)

图片由 [Anja 提供🤗#伸出援手#团结#保持健康🙏](https://pixabay.com/users/cocoparisienne-127419/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=739165)来自 [Pixabay](https://pixabay.com/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=739165)

我好像花了很多时间解释 Java 函数式编程。真的，这里没有魔法。您将函数传递给函数以适应它们的行为。你为什么要这么做？如果你正在使用面向对象的开发，你已经在做了，但是是以一种非常可控的方式。Java 的多态性是通过保存一个可以用子类替换的函数列表来实现的。那么该类的其他函数可能会调用一个被覆盖的函数，因此即使外部函数本身没有被覆盖，它的行为也会改变。

让我们举一个多态的例子，并把它转换成 lambda 表达式的函数。这里有一个例子:

这是非常经典的面向对象，一个`Dog`和`Cat`类型实现了一个`Pet`类型。听起来熟悉吗？在这个极其简单的例子中，如果你打扰了你的宠物，它会做什么？一只狗叫，一只猫喵喵。

但是如果你也想要一条蛇呢？你必须创建一个新的类。如果你想要一千种类型呢？每一个都有很多样板文件。如果`Pet`接口只有一个方法，Java 可以像对待函数一样对待它。我将把`disturb`方法移出`Pet`接口(它可能一开始就不属于那里，因为它不是宠物的属性)。它看起来是这样的:

正是这个奇怪的语法`() -> something`，让一些人陷入了困境。但它所做的只是定义一个不带参数的函数，并返回一些东西。由于`Pet`接口只有一个方法，这就是你如何调用你创建的函数。从技术上来说，它实现了覆盖`vocalize`函数的类型`Pet`。但是为了我们讨论的目的，它是一个可以传递给另一个函数的函数。

您可以进一步减少这种情况，因为可以用“提供”发声的`Supplier`接口来代替`Pet`接口。看起来是这样的:

在`java.util.function`包中提供了`Supplier`类型，因为它是如此常见的函数类型。

这些 lambda 函数让我们看起来像是在凭空创造一个函数。但是在幕后，我们用单个方法实现一个接口，并提供单个方法的实现。

让我们来看看另一个常见的函数，`Consumer`。一个`Consumer`函数以一个值作为参数，不返回任何东西，基本上就是消耗值。如果您曾经使用过列表或流的`forEach`方法，那么您就使用了`Consumer`。我们将把你的宠物的所有叫声收集到一个列表中，然后调用每一个。它看起来是这样的:

现在，如果你添加一只鸟到你的动物园，你只需要添加`() -> “chirp”`到列表中。请注意，我没有在`v -> disturbPet(v)` lambda 中的 v 周围加上括号。对于单参数 lambdas，括号是可选的。

好吧，我的例子很做作。我只想从多态函数走到 lambda 函数。你什么时候会真正使用 lambda 表达式？有几个例子非常常见，值得一读。这些被用作流库的一部分。

作为一个不那么做作的例子，我将获得一个文件列表，删除不以点开头的文件，并获得文件的名称和大小。第一项工作是从当前目录中获取文件数组，并将其转换成`Stream`类型。我们可以用`File`类型做到这一点:

```
File dir = new File(".");
Stream s = Arrays.*stream*(dir.listFiles());
```

由于目录是一个文件，我们可以用`File`类型对它进行操作。我们也知道。是一个目录，所以我们可以在上面调用`listFiles`。但是它返回一个数组，所以要使用 streams 来操作它，我们必须使用`Arrays.stream`函数将数组转换成`Stream`。

现在，让我们删除以点开始的文件，将`File`类型转换为带有名称和大小的字符串，按字母顺序排序，并记录下来。

采用 lambda 表达式的两个新函数是`filter`和`map`。`filter`函数采用一个`Predicate`类型，`map`函数采用一个(不要笑)`Function`函数，这两个函数都是`java.util.function`包的一部分。两者都提供了非常常见的操作，你可以对一个对象进行操作，`Predicate`测试对象的某些方面，并`Function`将它从一个东西转换成另一个东西。两者都将一个对象作为参数，但是`Predicate`返回一个布尔值，而`Function`返回另一个对象。

请注意，我还检查了该项是一个文件。我们应该如何处理目录？如果我们递归进入目录怎么样？你会如何处理流呢？有一种特殊类型的映射将内部流(子目录)添加到外部流中。那到底是什么意思？看一下这个例子:

正如您所看到的，如果所讨论的文件是一个目录，那么在`flatMap`方法中使用的 lambda 将会递归，如果不是，那么将会返回文件本身。`flatMap`的 lambda 必须返回某个东西的`Stream`。所以在单个文件的情况下，我们必须用`Stream.of()`包装它，以匹配递归调用`getFiles()`的返回类型。还要注意，lambda 包含在花括号中，所以如果希望它返回某个东西，它必须有一个 return 语句。

为了使用这个`getFiles`函数，我们可以将它添加到 main 方法中:

我们必须通过一些机制来获得没有完整路径的文件名的相对路径。但是，嘿，这很有效。

以函数为参数的函数通常称为*高阶函数*。我们见过几个高阶函数:`forEach`、`filter`、`map`、`flatMap`。每一种都以抽象的方式代表了一种非常常见的对象操作方式，通过参数和返回值来区分。我们使用 lambdas 来提供要执行的明确操作。通过这种方式，我们可以对对象序列进行链式操作，以获得想要的结果。

我希望这已经揭开了 lambda 函数的神秘面纱。我想当我第一次被介绍给它的时候，这个名字本身就很吓人。当然，这是借用了阿隆佐·邱奇的 lambda 微积分，但那是另一个故事了。现在，您需要知道的是，函数可以通过简单的语法凭空变出来。