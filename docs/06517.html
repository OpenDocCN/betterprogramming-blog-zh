<html>
<head>
<title>The Technical Interview Guide to Dynamic Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态编程技术面试指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-technical-interview-guide-to-dynamic-programming-3ce755d99849?source=collection_archive---------8-----------------------#2020-10-08">https://betterprogramming.pub/the-technical-interview-guide-to-dynamic-programming-3ce755d99849?source=collection_archive---------8-----------------------#2020-10-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3cd8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">面试准备和日常编码的动态编程JavaScript指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2a133bc8ae90c0d09afc6ad5142cfd16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xnh91sAu46n_PmnCnmZ_MA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="e860" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">讨论完如何准备字符串操作面试问题，我们接下来要关注另一个热门话题:动态编程。</p><p id="a240" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/Dynamic_programming" rel="noopener ugc nofollow" target="_blank">动态规划</a>是一种通过构建解决较小子问题的解决方案来解决较大问题的方法。</p><p id="facf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个迭代实现，渴望和预缓存，通常是首选，因为它需要更少的时间和内存。然而，带迭代的动态编程更难思考。</p><p id="9880" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">迭代实现也称为制表。这个过程类似于填表格。这是一种自下而上的方法，首先解决较小的子问题，然后构建整个解决方案。这使得跟踪调试过程更加容易。</p><p id="313c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">递归是一种解决问题的方法，其解决方案依赖于同一问题的较小实例的解决方案。但是递归在性能和空间使用上可能是低效的。动态编程通过内存化提高了性能和空间利用率。</p><p id="09be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">记忆化动态规划是一种自顶向下的方法，假设较小的子问题已经解决，并且整个解决方案是从这些子解决方案中导出的。所有的递归算法都可以迭代实现，虽然有时候不太直观。</p><p id="bcac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们在本文中提供了JavaScript示例。然而，该原理和算法也可以应用于其他语言。</p><p id="1151" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个面试系列会让你为一个成功的技术面试做好准备，对日常编码也很有用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3e7a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">排列</h1><p id="d7a8" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">对于动态编程来说，<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">数组</a>与<a class="ae lu" href="https://medium.com/better-programming/the-technical-interview-guide-to-string-manipulation-92f4c4649cd" rel="noopener">映射和集合</a>一样，是记忆化的基本数据结构。</p><p id="df14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Array是一个类似列表的对象，它有执行遍历和变异操作的方法。在JavaScript中，数组长度和元素类型可以重置。它可以作为一个对象互换使用。以下是供回顾的代码样本，包括ES2016中的<code class="fe mz na nb nc b">includes</code>、ES2019中的<code class="fe mz na nb nc b">flat</code> / <code class="fe mz na nb nc b">flatMap</code>和ES2022中的<code class="fe mz na nb nc b">at</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="afc0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">动态规划</h1><p id="b233" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">还有很多动态编程相关的测试。不可能全部都练习。我们通过一系列测试来强调解决问题的技巧。</p><p id="e67a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于每个测试，我们给出两个动态规划解，一个迭代实现，一个递归实现。</p><p id="8454" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们尝试通过以下步骤实现解决方案的标准化:</p><ul class=""><li id="fc24" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">将记忆数组命名为<code class="fe mz na nb nc b">dp</code>。</li><li id="a14e" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">将递归名命名为<code class="fe mz na nb nc b">findResult</code>。</li><li id="9ced" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">将递归放在函数内部，以利用<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">闭包</a>。</li></ul><p id="d020" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">闭包是一个函数与对其周围状态的引用捆绑在一起(封闭)的组合。换句话说，闭包让我们可以从内部函数访问外部函数的范围。在JavaScript中，闭包是在每次创建函数时创建的。</p><h2 id="d417" class="nt md it bd me nu nv dn mi nw nx dp mm lh ny nz mo ll oa ob mq lp oc od ms oe bi translated">斐波那契数</h2><p id="9afc" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">斐波那契数</a>是一个经典的动态规划问题。斐波纳契数列是一系列数字，其中一个数字是最后两个数字的相加，从0和1开始。斐波纳契数列中的每个数字称为斐波纳契数。</p><p id="8081" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于得出第n个斐波那契数的算法，等式是:</p><ul class=""><li id="51f6" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated"><code class="fe mz na nb nc b">fibonacci(n) = fibonacci(n - 1) + fibonacci(n — 2)</code></li></ul><p id="028b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是计算第n个斐波那契数的迭代算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="362e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是计算第n个斐波那契数的递归算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c660" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="33d9" class="nt md it bd me nu nv dn mi nw nx dp mm lh ny nz mo ll oa ob mq lp oc od ms oe bi translated"><strong class="ak">最小路径</strong></h2><p id="933d" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">最小路径是通过向右或向下寻找矩阵中从左上角到右下角的路径，其中假设矩阵中的每个点都被赋予一个值，则该路径应该具有最小和。例如，<code class="fe mz na nb nc b">[[1,2], [3,4]]</code>有一条从1 → 2 → 4的最小路径，其和为7。</p><p id="ba2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们初始化一个二维数组用于记忆，其中<code class="fe mz na nb nc b">dp[i][j]</code>代表从<code class="fe mz na nb nc b">point[0][0]</code>到<code class="fe mz na nb nc b">point[i][j]</code>的最小路径和。最小路径从左侧点(<code class="fe mz na nb nc b">dp[i][j — 1]</code>)或从上方点(<code class="fe mz na nb nc b">dp[i — 1][j]</code>)开始累积:</p><ul class=""><li id="e9fb" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated"><code class="fe mz na nb nc b">dp[i][j] = Math.min(dp[i][j — 1], dp[i — 1][j]) + matrix[i][j]</code>。</li></ul><p id="2332" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是计算最小路径和的迭代算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7017" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是计算最小路径和的递归算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ac3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="fbf7" class="nt md it bd me nu nv dn mi nw nx dp mm lh ny nz mo ll oa ob mq lp oc od ms oe bi translated">L <strong class="ak">最大增长子序列</strong></h2><p id="acee" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">一个<a class="ae lu" href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence" rel="noopener ugc nofollow" target="_blank">最长递增子序列</a> (LIS)是寻找一个给定序列中最长的子序列，其中子序列的元素按从低到高的顺序排列，并且子序列尽可能长。这个子序列不一定是连续的或唯一的。例如，<code class="fe mz na nb nc b">[1, 3, 2, 2, 4]</code>具有最长的递增子序列，<code class="fe mz na nb nc b">[1, 2, 2, 4]</code>，其长度为4。</p><p id="2ae8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">给定一个数字数组<code class="fe mz na nb nc b">nums</code>，我们初始化一个数组用于记忆，其中<code class="fe mz na nb nc b">dp[i]</code>代表<code class="fe mz na nb nc b">nums.slice(0, i + 1)</code>中最长的递增子序列。<code class="fe mz na nb nc b">nums</code>中每个元素都是一个单长度的列表。如果后续元素等于或大于，则当前元素可以将长度扩展1。如果这个值更大，选择这个新值。分解算法是这样的:</p><p id="b4ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">dp[i] = Math.max(dp[j] + 1)</code>，对于每个<code class="fe mz na nb nc b">0 ≤ j &lt; i</code>和<code class="fe mz na nb nc b">nums[j] &lt; nums[i]</code></p><p id="d998" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将选择所有选项中最长的<code class="fe mz na nb nc b">dp[i]</code>，因为结果不一定是最后一个元素的<code class="fe mz na nb nc b">dp[nums.length — 1]</code>。</p><p id="ba4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这不是最快的算法，但很容易理解。如果你在寻找一个O(n log n)的解决方案，请查看这个维基页面。</p><p id="f445" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是计算LIS长度的迭代算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="87d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是计算LIS长度的递归算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a176" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="44c2" class="nt md it bd me nu nv dn mi nw nx dp mm lh ny nz mo ll oa ob mq lp oc od ms oe bi translated">变革</h2><p id="3c9e" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">一个<a class="ae lu" href="https://en.wikipedia.org/wiki/Change-making_problem" rel="noopener ugc nofollow" target="_blank">找零</a>问题解决的是找到给定金额的最小硬币数的问题。给定<code class="fe mz na nb nc b">[1, 5]</code>的硬币选择，制造100的最小硬币数是20，即<code class="fe mz na nb nc b">5 x 20 = 100</code>。如果无解，硬币数为-1。</p><p id="99c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">给定一个数字数组<code class="fe mz na nb nc b">coins</code>，我们初始化一个数组用于记忆，其中<code class="fe mz na nb nc b">dp[i]</code>代表产生数量<code class="fe mz na nb nc b">i</code>的最小硬币数。等式是:</p><p id="e862" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">dp[i] = Math.min(dp[i — coins[j]] + 1)</code>，对于每一个<code class="fe mz na nb nc b">0 ≤ j &lt; coins.length </code>和<code class="fe mz na nb nc b">i — coins[j] &gt;= 0</code>和<code class="fe mz na nb nc b">dp[i — coins[j]] !== -1</code></p><p id="c25d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是计算目标金额硬币数的迭代算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4ca2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是计算目标金额硬币数的递归算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ba2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="48de" class="nt md it bd me nu nv dn mi nw nx dp mm lh ny nz mo ll oa ob mq lp oc od ms oe bi translated">L <strong class="ak">最长公共子序列&amp; </strong>最短公共超序列</h2><p id="0802" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">一个<a class="ae lu" href="https://en.wikipedia.org/wiki/Longest_common_subsequence_problem" rel="noopener ugc nofollow" target="_blank">最长公共子序列</a> (LCS)被用来寻找两个序列的最长公共子序列。子序列在原始序列中不需要连续。为了简化，我们假设字符串只包含小写字母。给定两个字符串<code class="fe mz na nb nc b">“apple”</code>和<code class="fe mz na nb nc b">“peach”</code>，最长的公共子序列是<code class="fe mz na nb nc b">“pe”</code>，长度为2。</p><p id="2beb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/Shortest_common_supersequence_problem" rel="noopener ugc nofollow" target="_blank">最短公共超序列</a> (SCS)是两个给定序列的最小长度的公共超序列。同样的例子，<code class="fe mz na nb nc b">“apple”</code>和<code class="fe mz na nb nc b">“peach”</code>，短接的公共超序列是<code class="fe mz na nb nc b">“appleach”</code>，长度为8。</p><p id="8399" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你注意到什么了吗？<code class="fe mz na nb nc b">“apple”</code>和<code class="fe mz na nb nc b">“peach”</code>的总长度为10，减去复制的最长公共子序列<code class="fe mz na nb nc b">“pe”</code>的长度，剩余值为8。因此，LCS和SCS的长度可以一起计算。</p><p id="1d83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">给定两个字符串<code class="fe mz na nb nc b">str1</code>和<code class="fe mz na nb nc b">str2</code>，我们初始化一个二维数组用于记忆，<code class="fe mz na nb nc b">dp[i][j]</code>代表<code class="fe mz na nb nc b">str1.slice(0, i)</code>和<code class="fe mz na nb nc b">str2.slice(0, j)</code>的最长公共子序列。该算法可以描述如下:</p><ul class=""><li id="ea56" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">如果<code class="fe mz na nb nc b">(str1[i — 1] === str2[j — 1])</code>，那么<code class="fe mz na nb nc b">dp[i][j] = dp[i — 1][j — 1] + 1</code>。</li><li id="c40e" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">否则，<code class="fe mz na nb nc b">dp[i][j] = Math.max(dp[i][j — 1], dp[i — 1][j])</code>。</li></ul><p id="6f7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是计算LCS和SCS长度的迭代算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="201d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是计算LCS和SCS长度的递归算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2633" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="433b" class="nt md it bd me nu nv dn mi nw nx dp mm lh ny nz mo ll oa ob mq lp oc od ms oe bi translated">正则表达式匹配</h2><p id="a885" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">正则表达式是定义搜索模式的字符序列。该模式用于对字符串执行“查找”或“查找和替换”操作。这里我们将模式简化为以下情况之一:</p><ul class=""><li id="1923" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated"><code class="fe mz na nb nc b">.</code>匹配任何单个字符。</li><li id="c777" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe mz na nb nc b">*</code>匹配前面的字符0次或更多次。</li><li id="e6ad" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">否则，字符匹配自身。</li></ul><p id="14e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，<code class="fe mz na nb nc b">“a”</code>匹配模式<code class="fe mz na nb nc b">“a”</code>、<code class="fe mz na nb nc b">“.”</code>、<code class="fe mz na nb nc b">“a*”</code>、<code class="fe mz na nb nc b">“a*b*”</code>和<code class="fe mz na nb nc b">“a*b*c*”</code>。但是<code class="fe mz na nb nc b">“a”</code>与模式<code class="fe mz na nb nc b">“b”</code>、<code class="fe mz na nb nc b">“b*”</code>、<code class="fe mz na nb nc b">“*a*b*”</code>和<code class="fe mz na nb nc b">“a*b*c*d”</code>不匹配。</p><p id="8812" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是检查正则表达式匹配的迭代算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7729" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是检查正则表达式匹配的递归算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="bedc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是验证测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="90b2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="6051" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">动态规划问题有很多种。熟能生巧。享受编码。</p><p id="d19e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae lu" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p></div></div>    
</body>
</html>