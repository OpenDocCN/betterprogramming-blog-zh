<html>
<head>
<title>Python: How Instance and Class Attributes Work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python:实例和类属性如何工作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/python-how-object-and-class-attributes-work-8edf4ed9caa4?source=collection_archive---------5-----------------------#2019-05-28">https://betterprogramming.pub/python-how-object-and-class-attributes-work-8edf4ed9caa4?source=collection_archive---------5-----------------------#2019-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ed88" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">比较、对比和编码类和实例属性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/b6fc6d7d902ca5b48c0d11a957776e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*yXh9d-I8XrxFDyCwjfCDqg.jpeg"/></div></figure><p id="eed9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">到目前为止，我们只讨论了Linux和C编程问题。最近在霍尔伯顿学校，我们开始学习<strong class="ks iu"> Python </strong>。这种编程语言由<strong class="ks iu"> Guido Van Rossum </strong>创造，于1991年发布，是当今最流行和使用的语言之一。开发者喜欢它的众多原因之一是它的范例之一是<strong class="ks iu"> OOP </strong>。OOP代表<strong class="ks iu">“面向对象编程”</strong>。在OOP中，数据在<strong class="ks iu">对象</strong>(或者Python中的<strong class="ks iu">类</strong>)中进行组织和重组，这些对象包含字段，也称为<strong class="ks iu">属性</strong>，以及<strong class="ks iu">方法</strong>，类似于函数。这使得我们有更多的可读性，可移植性和模块化的代码。</p><p id="10eb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当Guido Van Rossum创建Python时，他希望它是“一流的一切”，这意味着一切都将是平等地位的对象。所以Python中的一切(或者几乎)都是一个<strong class="ks iu">类</strong>。一个类本质上由一个缩进的语句块组成，其中包含属性、方法、特性和其他我们在这里不讨论的东西。例如，列表(类似于C数组)是一个类，有预定义的方法来构建和修改它们。但是我们也可以构建我们自己的类在我们的代码中使用。</p><p id="384f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">今天，我们将重点讨论<strong class="ks iu">属性。同一个类可以有几个<strong class="ks iu">实例</strong>，属性可以属于单个实例，也可以属于类本身。为了说明这一点，我们将构建一个名为<em class="lm"> Person </em>的类。每个人都是类<em class="lm"> Person </em>的不同实例。所有的人都有属性，就像头发或者眼睛的颜色，每个人的属性都和其他人的属性不一样。</strong></p><p id="76d4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，让我们只放一个“pass”语句，使它成为一个空类。</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="1877" class="ls lt it lo b gy lu lv l lw lx">class Person:<br/>    pass</span></pre><h2 id="54bb" class="ls lt it bd ly lz ma dn mb mc md dp me kz mf mg mh ld mi mj mk lh ml mm mn mo bi translated">关于属性的一点背景知识</h2><p id="bd3a" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">在进入我们的主题之前，让我们记住一些关于属性的事情。</p><p id="8fd5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">属性定义了一个类的特性或特征。它们可以是<strong class="ks iu">变量</strong>，是字段，也可以是<strong class="ks iu">方法</strong>，是在类内部定义的函数，可以这样调用:<em class="lm"> &lt;类名&gt;。&lt;方法名【参数】&gt; </em>。</p><p id="521c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">属性可以是公共的、受保护的或私有的。不必深入了解这三个属性级别的太多细节，重要的是要知道:</p><ul class=""><li id="a06f" class="mu mv it ks b kt ku kw kx kz mw ld mx lh my ll mz na nb nc bi translated">私有属性只能在类内部使用和修改。他们的名字前面有“__”</li><li id="fbab" class="mu mv it ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated">受保护的属性可以在类之外使用，但仅在特定条件下。他们的名字以“_”开头。</li><li id="e872" class="mu mv it ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated">公共属性可以被类内外的任何人使用和修改。</li></ul><p id="3550" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在本文中，为了简单起见，我们将主要使用公共属性。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="6a55" class="np lt it bd ly nq nr ns mb nt nu nv me jz nw ka mh kc nx kd mk kf ny kg mn nz bi translated">什么是类属性？</h1><p id="beb9" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">类属性是属于类本身的属性。它由该类的所有实例共享，它对任何实例都有相同的值。让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="fd11" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果我们执行这些行，我们将看到以下输出:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="80c8" class="ls lt it lo b gy lu lv l lw lx">I am a class attribute<br/>I am a class attribute<br/>I am a class attribute</span></pre><p id="475e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">是的，所有三个print语句都打印相同的内容，因为<em class="lm"> Person </em>和<em class="lm"> Person </em>的<em class="lm">实例</em>本身都有class属性<em class="lm"> class_attr </em>。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="fa99" class="np lt it bd ly nq nr ns mb nt nu nv me jz nw ka mh kc nx kd mk kf ny kg mn nz bi translated">什么是实例属性？</h1><p id="6030" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">实例属性是属于类的一个实例的属性，并且只能在该实例的范围内访问。让我们用我们的<em class="lm">人</em>类来说明这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="20fe" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这将产生以下输出:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="bf24" class="ls lt it lo b gy lu lv l lw lx">I am a new class attribute of the Person class<br/>I am an instance attribute belonging to person_1</span></pre><p id="97f8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里我们改变了类属性<em class="lm"> class_attr </em>，所以我们会认为打印同一个类的一个实例的同一个属性会打印这个改变后的字符串，但实际上，<em class="lm"> person_1 </em>仍然是我们在改变类属性之前创建的<strong class="ks iu">实例，所以它的<em class="lm"> class_attr </em>是一个只有<em class="lm"> person_1 </em>可以访问的实例属性。</strong></p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="a73a" class="np lt it bd ly nq nr ns mb nt nu nv me jz nw ka mh kc nx kd mk kf ny kg mn nz bi translated">类和实例属性之间有什么区别</h1><p id="4bfc" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">正如我们在例子中看到的，类和实例属性是不同的。类的所有实例都可以访问类属性，而实例属性只能由该类的特定实例访问。我们可以通过实例或类名来访问类属性，而实例属性只能通过它所属的实例来访问。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="3a55" class="np lt it bd ly nq nr ns mb nt nu nv me jz nw ka mh kc nx kd mk kf ny kg mn nz bi translated">我们怎样才能创造它们，什么是Pythonic式的方法？</h1><p id="3fac" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">正如我们前面看到的，我们创建了<strong class="ks iu">类属性</strong>，方法是在类内部，在该类的方法外部声明它们并给它们赋值<strong class="ks iu">。传统上，它是在班级的顶端完成的，在其他任何事情之前。</strong></p><p id="1c27" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们还创建了<strong class="ks iu">实例属性</strong>，方法是在类的之外声明它们并给它们赋值<strong class="ks iu">。还有一种方法，使用<strong class="ks iu"> __init__ </strong>方法。它是一个<strong class="ks iu">构造函数</strong>方法，在创建了一个类的实例后自动调用。它通常是类中定义的第一个方法。这是一种更pythonic化的方式。让我们使用我们的示例，并为<em class="lm">人员</em>添加一个<em class="lm">名称</em>属性:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0bbe" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">注意<em class="lm"> self </em>关键字。它引用该类的当前实例或对象。现在我们可以这样创建一个<em class="lm"> Person </em>的新实例:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="9ced" class="ls lt it lo b gy lu lv l lw lx">person_1 = Person('Laura')</span></pre><p id="ac41" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">将调用<em class="lm"> __init__ </em>方法，并将实例属性名设置为‘Laura’。基本上就像生下一个人，叫他们劳拉！<em class="lm">名字</em>是一个实例属性，因为劳拉这个名字并不被地球上的所有其他人共享(也被称为<em class="lm">人物</em>类的其他实例)。</p><p id="8810" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">请注意，我们的类属性<em class="lm"> class_attr </em>仍然存在，并且仍然可以通过以下方式访问:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="ec15" class="ls lt it lo b gy lu lv l lw lx">person_1.class_attr</span></pre><p id="a091" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">此外，我们可以定义<strong class="ks iu"> getter </strong>和<strong class="ks iu"> setter方法</strong>，它们将分别检索和设置<strong class="ks iu"> private </strong>实例属性的值。还记得我们说过私有属性只能从类内部访问吗？这就是如何为一个类的实例设置和检索它们。__init__方法将依次调用setter方法或属性来设置属性的值。这些getters和setters是<strong class="ks iu">数据封装</strong>原则的一部分，这意味着类内部的细节对用户是隐藏的。在Python中，最好将它们作为<strong class="ks iu">属性</strong>而不是方法使用，所以我们在这里只讨论属性。让我们来看看怎么做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="db2c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">哇，我们加了这么多东西！首先，@前面的行是<strong class="ks iu">装饰符</strong>。它们允许类知道当他们需要<strong class="ks iu">检索</strong>或者<strong class="ks iu">设置</strong>一个属性的值的时候去哪里看。然后，我们使用单词<em class="lm"> self </em>来引用当前实例并访问其属性。然后我们可以看到属性和setter方法都有<strong class="ks iu">相同的名字</strong>，但是<strong class="ks iu">不同的实参</strong>。这是因为当我们创建一个<em class="lm"> Person </em>的新实例时，我们可以这样做:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="e615" class="ls lt it lo b gy lu lv l lw lx">person_1 = Person('Laura')<br/>print(person_1.name)</span></pre><p id="30f9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第一行将调用<em class="lm"> __init__ </em>方法，该方法又调用setter，setter将检查传递给它的参数的类型是否为string，然后将instance属性设置为‘Laura’。第二行将知道通过调用<em class="lm"> name() </em>属性来打印私有<em class="lm"> name </em>属性的值。</p><p id="3a11" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">另一种知道我们是在处理类属性还是实例属性的方法是使用<em class="lm"> &lt;类名&gt;。&lt;属性&gt;或</em>自我。&lt;属性&gt; 。这意味着在我们的例子中，如果我们在类中编写<em class="lm"> Person.class_attr </em>，我们将访问类属性。但是如果我们要写<em class="lm"> self.class_attr </em>，我们将仍然访问class属性，但是作为一个实例属性。它只是为这个实例创建一个实例属性，这个实例由<em class="lm"> self </em>表示，但是与class属性同名。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="ee0c" class="np lt it bd ly nq nr ns mb nt nu nv me jz nw ka mh kc nx kd mk kf ny kg mn nz bi translated">类和实例属性的优缺点是什么？</h1><p id="8778" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">类别属性的优点:</p><ul class=""><li id="deea" class="mu mv it ks b kt ku kw kx kz mw ld mx lh my ll mz na nb nc bi translated">类的所有实例都从类继承它们。</li><li id="9b0c" class="mu mv it ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated">它们存储与所有实例相关的数据。例如，我们可以有一个<em class="lm">计数器</em>类属性，它在我们每次创建一个新实例时递增，在我们每次删除一个实例时递减。这样我们就可以一直跟踪我们创建的同一个类有多少个实例。</li></ul><p id="7272" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">类属性的缺点:</p><ul class=""><li id="25a5" class="mu mv it ks b kt ku kw kx kz mw ld mx lh my ll mz na nb nc bi translated">当您创建一个class属性值不同于class属性值的实例，然后试图通过另一个实例检索它时，这可能会变得很混乱。这种行为很快变得出乎意料。</li><li id="f0c8" class="mu mv it ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated">不可能有两个具有不同值的实例。所以你不能用它们在不同的物体上做不同的事情。如果<em class="lm"> Person </em>类只有类属性，我们将无法创建一个包含不同人的联系人列表。</li></ul><p id="5ceb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">实例属性的优点:</p><ul class=""><li id="3c00" class="mu mv it ks b kt ku kw kx kz mw ld mx lh my ll mz na nb nc bi translated">它们是特定于一个对象的，由于有了属性，它们很容易设置和获取。</li><li id="11e5" class="mu mv it ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated">一旦实例被删除，它们就被丢弃了，所以它们和与之相关联的实例一起消亡，这样事情就更清楚了。</li></ul><p id="0ea8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">实例属性的缺点:</p><ul class=""><li id="46b7" class="mu mv it ks b kt ku kw kx kz mw ld mx lh my ll mz na nb nc bi translated">它们不允许跟踪实例之间的值。</li><li id="bb43" class="mu mv it ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated">它们的值在删除时会丢失，这一事实在某些情况下也是一个缺点，例如，您希望保留值的历史记录。</li></ul></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="a407" class="np lt it bd ly nq nr ns mb nt nu nv me jz nw ka mh kc nx kd mk kf ny kg mn nz bi translated">Python如何使用<code class="fe oc od oe lo b">Dictionary?</code>处理实例和类属性</h1><p id="f188" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">所有实例都有一个<em class="lm"> __dict__ </em>字典，用来存储它们的属性和相应的值。让我们举个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="5655" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">输出:</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="22ae" class="ls lt it lo b gy lu lv l lw lx">{'_Person__name': 'Laura', 'class_attr': 'This is a changed class attribute'}<br/>{'_Person__name': 'Bob'}<br/>{'__doc__': None, 'class_attr': 'I am a class attribute', '__init__': &lt;function Person.__init__ at 0x7f687cb7b950&gt;, '__module__': '__main__', 'name': &lt;property object at 0x7f687cadb6d8&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Person' objects&gt;, '__dict__': &lt;attribute '__dict__' of 'Person' objects&gt;}</span></pre><p id="6e20" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="lm"> __dict__ </em>只会显示实例属性！但是<em class="lm"> class_attr </em>不是类属性吗？它在那里做什么？嗯，我们之前说过，通过给实例<em class="lm"> person_1 </em>的<em class="lm"> class_attr </em>赋值，使其成为与类属性<em class="lm">同名的实例属性，</em>和<em class="lm"> __dict__ </em>会优先列出实例类。<em class="lm"> </em>同样，<em class="lm"> person_2 </em>上的<em class="lm"> __dict__ </em>只会列出它知道的<em class="lm"> person_2 </em>的实例属性，而不会列出<em class="lm"> Person </em>其他实例的属性。最后，我们可以看到，在<em class="lm"> Person </em>类上应用<em class="lm"> __dict__ </em>也可以打印一个带有属性的字典。是的，因为即使<em class="lm"> Person </em>是一个类，它在技术上也是一个对象，并且具有可以列出的属性。我们可以注意到<em class="lm">‘class _ attr’:‘我是一个类属性’</em>，这是我们的类属性，<em class="lm"> name </em>属性没有值，因为它的值在类的每个实例化中都给定了。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="c383" class="np lt it bd ly nq nr ns mb nt nu nv me jz nw ka mh kc nx kd mk kf ny kg mn nz bi translated">结论</h1><p id="58ed" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">总之，我们可以说类是OOP的一个强大的工具，它们可以以多种方式使用，它们的属性也是如此。选择使用类属性还是实例属性取决于我们想要创建什么样的类，在使用它们时，我们应该确保理解这两者。</p><h1 id="02f2" class="np lt it bd ly nq of ns mb nt og nv me jz oh ka mh kc oi kd mk kf oj kg mn nz bi translated">来源</h1><div class="ok ol gp gr om on"><a href="https://en.wikipedia.org/wiki/Python_%28programming_language%29" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">Python(编程语言)-维基百科</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">Python是一种解释型高级通用编程语言。由吉多·范·罗苏姆和第一…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">en.wikipedia.org</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ko on"/></div></div></a></div><div class="ok ol gp gr om on"><a href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">面向对象编程-维基百科</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">编辑描述</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">en.wikipedia.org</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb ko on"/></div></div></a></div><div class="ok ol gp gr om on"><a href="https://www.python-course.eu/python3_object_oriented_programming.php" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">Python教程:面向对象编程</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">面向对象编程的一般介绍及其在Python中的使用方式</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">www.python-course.eu</p></div></div><div class="ow l"><div class="pd l oy oz pa ow pb ko on"/></div></div></a></div><div class="ok ol gp gr om on"><a href="https://docs.python.org/2/tutorial/classes.html" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">9.类- Python 2.7.16文档</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">与其他编程语言相比，Python的类机制用最少的新语法和…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">docs.python.org</p></div></div></div></a></div><div class="ok ol gp gr om on"><a href="https://www.python-course.eu/python3_class_and_instance_attributes.php" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">Python教程:类与实例属性</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">Python中的面向对象编程:实例属性与类属性及其正确使用。</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">www.python-course.eu</p></div></div><div class="ow l"><div class="pe l oy oz pa ow pb ko on"/></div></div></a></div><div class="ok ol gp gr om on"><a href="https://dzone.com/articles/python-class-attributes-vs-instance-attributes" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">Python中的类属性与实例属性:你可能错过了什么</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">讨论Python编程语言面向对象的一个方面，类属性和实例…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">dzone.com</p></div></div><div class="ow l"><div class="pf l oy oz pa ow pb ko on"/></div></div></a></div></div></div>    
</body>
</html>