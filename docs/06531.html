<html>
<head>
<title>The Guide to MongoDB Field Level Encryption</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MongoDB字段级加密指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-guide-to-mongodb-field-level-encryption-55c5b0b90bf7?source=collection_archive---------3-----------------------#2020-10-09">https://betterprogramming.pub/the-guide-to-mongodb-field-level-encryption-55c5b0b90bf7?source=collection_archive---------3-----------------------#2020-10-09</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="caf6" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">如何更好地保护您和您客户的数据</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/864f0e6f8576a0c6e1030de849c1dc49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sKsVfwwKRxPhkAeUjfjtvw.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由来自<a class="ae kz" href="https://www.pexels.com/photo/woman-draw-a-light-bulb-in-white-board-3758105/" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kz" href="https://www.pexels.com/@olly" rel="noopener ugc nofollow" target="_blank">安德里亚·皮亚卡迪奥</a>拍摄</p></figure><p id="633d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一如既往，虽然建立一个新项目很有趣，而且现在的大多数技术都很容易集成。但是一旦你开始考虑操作和数据安全，事情往往会变得更加棘手。MongoDB提供了三个加密选项，其中两个只有企业许可才可用。</p><ol class=""><li id="94cf" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">静态加密从3.2版开始提供，但仅面向企业客户。</li><li id="f2a6" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">自动字段级加密仅在MongoDB 4.2 Enterprise和MongoDB Atlas 4.2上可用。</li><li id="75f5" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">MongoDB 4.2 Community Edition(免费版本)提供了手动字段级加密。</li></ol><p id="7786" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">只有付费许可证持有人有资格使用自动MongoDB加密。就收入而言，Mongo的决定并不坏，对我们来说也不是一个巨大的挑战，因为我们仍然可以使用显式客户端字段级加密(CSFLE)。我们做了一些研究，找到了一些文档和指南，但没有足够的解释和解决方案。</p><p id="f37a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们构建了一个小的MVP和一个简短的测试，它将数据写入MongoDB实例，然后读取相同的文档，这就开始将所有的部分组合在一起。</p><p id="80ec" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的初步测试结果:</p><pre class="kk kl km kn gu mk ml mm mn aw mo bi"><span id="fb9d" class="mp mq iu ml b gz mr ms l mt mu">Users<br/>    .getUser<br/>      √ returns a user that was previously added (262ms)</span><span id="6c9e" class="mp mq iu ml b gz mv ms l mt mu">1 passing (337ms)</span></pre></div><div class="ab cl mw mx hy my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="in io ip iq ir"><h1 id="434b" class="nd mq iu bd ne nf ng nh ni nj nk nl nm ka nn kb no kd np ke nq kg nr kh ns nt bi translated">基础设施设置</h1><h2 id="4785" class="mp mq iu bd ne nu nv dn ni nw nx dp nm lj ny nz no ln oa ob nq lr oc od ns oe bi translated">加密密钥设置</h2><p id="6a77" class="pw-post-body-paragraph la lb iu lc b ld of jv lf lg og jy li lj oh ll lm ln oi lp lq lr oj lt lu lv in bi translated">MongoDB使用一个叫做<em class="ok">信封加密</em>的概念来加密和解密数据。封装要求使用数据密钥对数据进行加密，并且数据密钥本身由另一个称为主密钥的密钥进行加密。这个过程的优点是您的数据密钥永远不会以纯文本的形式存储。在MongoDB上下文中，数据密钥将加密存储在数据库内部的专用集合中。就设置和操作而言，这增加了一些复杂性，但这都是为了更好的利益。</p><p id="06db" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，我们需要创建一个主密钥，然后使用该主密钥生成一个数据密钥。根据定义，主密钥的长度必须正好是96个字节。一个shell命令就可以创建这个随机序列，并将其以base64编码存储在一个文本文件中。</p><pre class="kk kl km kn gu mk ml mm mn aw mo bi"><span id="0f92" class="mp mq iu ml b gz mr ms l mt mu"><strong class="ml iv">$</strong> head -c 96 /dev/random | base64 -w0 &gt; key.base64.txt</span></pre><p id="e290" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">数据键的创建也是我们在数据库初始设置后运行的一次性任务。下面的脚本正是这样做的。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ol om l"/></div></figure><ul class=""><li id="dde5" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv on mc md me bi translated">第1行—第8行:使用名为<code class="fe oo op oq ml b">__keys</code> <strong class="lc iv"> </strong>和数据库<code class="fe oo op oq ml b">encryption</code>的新集合以及主密钥创建加密选项。</li><li id="79df" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">第10–13行:连接到MongoDB实例并传递加密选项。</li><li id="a39c" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">第15行:获取对key vault对象的引用。</li><li id="7a7f" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">第17–20行:创建一个名为<code class="fe oo op oq ml b">local</code>和<code class="fe oo op oq ml b">www</code>的新数据键。</li></ul><p id="ea3b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">数据键的别名<code class="fe oo op oq ml b">www</code>，我们稍后将在应用程序中使用它来引用数据键。我们建议不要在数据库服务器上运行脚本，而是在一次性服务器或容器中运行:</p><ul class=""><li id="c73f" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv on mc md me bi translated">使用模板引擎替换生成服务器上的所有变量。如果你在Kubernetes上运行，把这个文件挂载成一个<a class="ae kz" href="https://kubernetes.io/docs/concepts/storage/volumes/#secret" rel="noopener ugc nofollow" target="_blank">秘密卷</a>来防止它被写到磁盘上。</li></ul><pre class="kk kl km kn gu mk ml mm mn aw mo bi"><span id="7c11" class="mp mq iu ml b gz mr ms l mt mu">mongo ./create-mongodb-data-key.js</span></pre><ul class=""><li id="20e2" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv on mc md me bi translated">填充环境变量，最好是容器或短期服务器的环境变量，将变量传递给<code class="fe oo op oq ml b">mongo</code> shell，并调用脚本。</li></ul><pre class="kk kl km kn gu mk ml mm mn aw mo bi"><span id="8321" class="mp mq iu ml b gz mr ms l mt mu">mongo --eval 'mongo_root_user=\"$MONGO_ROOT_USER\", mongo_root_password=\"$MONGO_ROOT_PASSWORD\", mongo_host=\"MONGO_HOST\", encryption_master_key=\"$MONGO_ENCRYPTION_KEY\"' ./create-mongodb-data-key.js</span></pre></div><div class="ab cl mw mx hy my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="in io ip iq ir"><h1 id="eabb" class="nd mq iu bd ne nf ng nh ni nj nk nl nm ka nn kb no kd np ke nq kg nr kh ns nt bi translated">客户端应用程序设置</h1><h2 id="6b9b" class="mp mq iu bd ne nu nv dn ni nw nx dp nm lj ny nz no ln oa ob nq lr oc od ns oe bi translated">运行时依赖关系</h2><p id="6ef6" class="pw-post-body-paragraph la lb iu lc b ld of jv lf lg og jy li lj oh ll lm ln oi lp lq lr oj lt lu lv in bi translated">为了启用客户端加密，我们需要首先在服务器或容器中安装所需的C库。需要的C库是<a class="ae kz" href="http://mongoc.org/libbson/current/index.html" rel="noopener ugc nofollow" target="_blank"> libbson </a>和<a class="ae kz" href="http://mongoc.org/libmongoc/current/using_client_side_encryption.html" rel="noopener ugc nofollow" target="_blank"> libmongocrypt </a>。</p><p id="615c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们还必须将相应的包装器库作为依赖项添加到我们的应用程序中。NodeJS包装器的npm包叫做<a class="ae kz" href="https://www.npmjs.com/package/mongodb-client-encryption" rel="noopener ugc nofollow" target="_blank">MongoDB-client-encryption</a>；Java包装器被称为<a class="ae kz" href="https://mvnrepository.com/artifact/org.mongodb/mongodb-crypt" rel="noopener ugc nofollow" target="_blank"> mongodb-crypt </a>，可以在Maven Central上获得。</p><h2 id="4dfd" class="mp mq iu bd ne nu nv dn ni nw nx dp nm lj ny nz no ln oa ob nq lr oc od ns oe bi translated">模式对象</h2><p id="8ada" class="pw-post-body-paragraph la lb iu lc b ld of jv lf lg og jy li lj oh ll lm ln oi lp lq lr oj lt lu lv in bi translated">创建完加密密钥后，我们可以继续安装客户端应用程序了。我们希望存储加密的数据，并强制规定特定字段不能未加密存储。通过这种方式，我们可以防止某些信息以纯文本形式存储，并防止任何直接访问数据库的人访问这些信息。</p><p id="2378" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">JSON模式是执行模式验证的推荐方法。<br/><a class="ae kz" href="https://docs.mongodb.com/manual/core/schema-validation/" rel="noopener ugc nofollow" target="_blank">docs.mongodb.com</a>/</p><p id="b8b1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">特定字段的加密等需求可以通过模式定义添加到MongoDB集合中。模式描述了MongoDB文档的结构和特征，因此可以定义以下内容:</p><ul class=""><li id="c447" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv on mc md me bi translated">必需和可选属性</li><li id="edf7" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">属性名称及其类型</li><li id="1eaa" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">最小值和最大值</li><li id="07fd" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">正则表达式，值必须匹配</li><li id="d11b" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">枚举情况下的一组预定义值</li></ul><p id="c41b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">MongoDB推荐使用JSON模式来描述文档。JSON模式是一个JSON对象，它概述了将用于模式验证的需求。</p><p id="d3a8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">根据<a class="ae kz" href="https://json-schema.org/" rel="noopener ugc nofollow" target="_blank">文件</a>，</p><blockquote class="or os ot"><p id="d445" class="la lb ok lc b ld le jv lf lg lh jy li ou lk ll lm ov lo lp lq ow ls lt lu lv in bi translated">“JSON Schema是一个词汇表，允许您注释和验证JSON文档。</p><p id="3349" class="la lb ok lc b ld le jv lf lg lh jy li ou lk ll lm ov lo lp lq ow ls lt lu lv in bi translated">-描述您现有的数据格式。<br/> -提供清晰的人类和机器可读的文档。<br/> -验证对自动化测试有用的数据。确保客户提交数据的质量。"</p></blockquote><p id="79c3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的用户对象包含一个唯一的随机id、一个名字和一个电子邮件地址。我们希望所有这些属性都是强制性的。此外，我们强制要求:</p><ul class=""><li id="a713" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv on mc md me bi translated">设置id、姓名和电子邮件地址</li><li id="dddc" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">id是有效的UUID</li><li id="05e1" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">姓名和电子邮件地址被加密存储</li></ul><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ox"><img src="../Images/2b798ac61afade2f68864d3b27249cec.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*h2ZyrVb2Zab_iHu6qYb8mA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">具有id、名称和电子邮件属性的用户对象</p></figure><p id="81ad" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面的JSON文件显示了包含我们需求的JSON模式对象的外观。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ol om l"/></div></figure><ul class=""><li id="dec2" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv on mc md me bi translated">第2行–第4行:这个文档的元数据:文档的标题和我们将要定义的类型。</li><li id="a851" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">第4行—第8行:关键字<code class="fe oo op oq ml b">required</code> <strong class="lc iv"> </strong>定义了一个非可选属性数组。</li><li id="42c8" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">第9行—第29行:关键字<code class="fe oo op oq ml b">properties</code>定义了一个已知属性的对象。</li><li id="115b" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">第10行—第14行:属性<code class="fe oo op oq ml b">id</code> <strong class="lc iv"> </strong>必须是一个字符串，并且匹配给定的正则表达式。</li><li id="a9b8" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">第15行—第21行:属性<code class="fe oo op oq ml b">name</code> <strong class="lc iv"> </strong>必须是用确定性算法加密的字符串。</li><li id="90e1" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">第22行—第28行:属性<code class="fe oo op oq ml b">email</code> <strong class="lc iv"> </strong>必须是用非确定性算法加密的字符串。</li></ul><p id="ffee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">确定性算法确保相同的值总是加密到相同的输出。这对于查找加密数据是必要的，因为它允许我们重建加密值，从而在数据库查询中使用它。</p><p id="4ac0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">相反，非确定性随机算法确保相同值的加密产生不同的输出。因为输出会随着每次加密而改变，所以与确定性算法相比，计算输入值更加困难。安全方面，这是一个优势。缺点是我们不能查询用随机算法加密的数据。然而，我们仍然可以通过其他标准来查询文档。</p><p id="423c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在任何情况下，使用这些算法之一加密的数据都可以被有权使用主密钥的应用程序解密。因此，关于算法，我们主要必须决定是否要使用加密数据作为MongoDB查询的密钥。如果是，我们必须使用确定性算法。如果没有，我们可以使用随机化算法，它提供了更好的数据安全性。</p><h2 id="f304" class="mp mq iu bd ne nu nv dn ni nw nx dp nm lj ny nz no ln oa ob nq lr oc od ns oe bi translated"><strong class="ak">模式验证</strong></h2><p id="26b7" class="pw-post-body-paragraph la lb iu lc b ld of jv lf lg og jy li lj oh ll lm ln oi lp lq lr oj lt lu lv in bi translated">上面显示的JSON模式必须添加到MongoDB集合中，以启用模式验证。在我们的例子中，我们在应用程序启动之后、第一个查询执行之前添加模式。由于我们的应用程序不是在弹性环境中运行，并且我们不希望出现流量高峰，所以这不是性能问题。在具有动态伸缩的高流量环境中运行的应用程序应该使用专用的应用程序/容器来更新模式，以提高性能并消除数据库的负载。</p><p id="269c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">总之，这里有一个类，我们用它来创建、缓存和检索到MongoDB实例的连接。这个类还负责创建集合和启用JSON模式验证。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ol om l"/></div></figure><p id="57be" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第41行–第56行:如果在当前集合中找不到该集合，则创建它。</p><p id="33ce" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第58行—第64行:从schemas文件夹中查找schema对象，并相应地更新当前集合的验证器。将验证级别设置为strict，以便根据更新的模式验证所有现有的和新的文档。</p><p id="e8ca" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">插入新文档现在会失败，因为我们仍然需要添加实际的字段加密。客户端显示的错误消息非常普通，但是在我们的例子中，它与更新的加密需求直接相关。</p><p id="3a93" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的测试现在退出，并显示以下消息:</p><pre class="kk kl km kn gu mk ml mm mn aw mo bi"><span id="4a6f" class="mp mq iu ml b gz mr ms l mt mu">Users<br/>    .getUser<br/>      1) returns a user that was previously added</span><span id="dae6" class="mp mq iu ml b gz mv ms l mt mu">0 passing (201ms)<br/>  1 failing</span><span id="b3c8" class="mp mq iu ml b gz mv ms l mt mu">1) Users<br/>       .getUser<br/>         returns a user that was previously added:<br/>       <br/>    MongoError: Document failed validation</span></pre><h2 id="38a5" class="mp mq iu bd ne nu nv dn ni nw nx dp nm lj ny nz no ln oa ob nq lr oc od ns oe bi translated">客户端加密的实现</h2><p id="365d" class="pw-post-body-paragraph la lb iu lc b ld of jv lf lg og jy li lj oh ll lm ln oi lp lq lr oj lt lu lv in bi translated">最后的任务。让我们更新上面代码片段中显示的<code class="fe oo op oq ml b">mongodb-connection</code>类，以透明地处理加密和解密。因此，我们需要将主密钥和加密密钥集合名称以及一个活动的<code class="fe oo op oq ml b">MongoClient</code>传递给<code class="fe oo op oq ml b">ClientEncryption</code>构造函数。</p><pre class="kk kl km kn gu mk ml mm mn aw mo bi"><span id="1c7d" class="mp mq iu ml b gz mr ms l mt mu">this._clientEncryption = new ClientEncryption(this._client, {<br/>  keyVaultNamespace: 'encryption.__keys',<br/>  kmsProviders: {<br/>    local: {<br/>      key: Buffer.from(encryptionKey, 'base64') <br/>    }<br/>  }<br/>})</span></pre><p id="c31d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe oo op oq ml b">ClientEncryption</code>是mongodb-client-encryption包中的一个类。<code class="fe oo op oq ml b">ClientEncryption</code>的实例有一个方法<code class="fe oo op oq ml b">enrypt</code>和<code class="fe oo op oq ml b">decrypt</code>，它们返回一个承诺，并将分别用加密或解密的数据进行解析。</p><p id="5a02" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们需要实现的最后一件事是实际的加密。这是目前为止最简单的一步，所以让我们直接跳到结果。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ol om l"/></div></figure><p id="1c77" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第14行—第21行:在存储姓名和电子邮件之前，它们是加密的。加密后，加密模型将获得一个唯一的UUID。</p><p id="4f08" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第23行——第31行:为了通过名字查找用户，我们首先加密名字，因为名字被加密存储在我们的数据库中。</p><p id="663c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最终测试结果:</p><pre class="kk kl km kn gu mk ml mm mn aw mo bi"><span id="c3f2" class="mp mq iu ml b gz mr ms l mt mu">Users<br/>    .getUser<br/>      √ returns a user that was previously added (262ms)</span><span id="af72" class="mp mq iu ml b gz mv ms l mt mu">1 passing (337ms)</span></pre></div><div class="ab cl mw mx hy my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="in io ip iq ir"><h1 id="dba5" class="nd mq iu bd ne nf ng nh ni nj nk nl nm ka nn kb no kd np ke nq kg nr kh ns nt bi translated">摘要</h1><p id="77c3" class="pw-post-body-paragraph la lb iu lc b ld of jv lf lg og jy li lj oh ll lm ln oi lp lq lr oj lt lu lv in bi translated">MongoDB提供了两种现成的客户端字段级加密(CSFLE)方法:自动和手动CSFLE。Automatic CSFLE是一个方便的特性，因为它可以基于JSON模式自动加密数据。不幸的是，它只适用于MongoDB企业版。每个运行MongoDB Community Edition的人都必须使用手动CSFLE，这就是为什么我们在这里描述如何正确配置它。</p><p id="6bae" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">设置CSLFE需要对MongoDB和客户端应用程序进行一些修改。最后，这些是提高我们客户数据的完整性、真实性和整体安全性的重要步骤。</p></div><div class="ab cl mw mx hy my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="in io ip iq ir"><h1 id="ffb7" class="nd mq iu bd ne nf ng nh ni nj nk nl nm ka nn kb no kd np ke nq kg nr kh ns nt bi translated">资源</h1><ul class=""><li id="bd4c" class="lw lx iu lc b ld of lg og lj oy ln oz lr pa lv on mc md me bi translated"><a class="ae kz" href="https://www.npmjs.com/package/mongodb-client-encryption" rel="noopener ugc nofollow" target="_blank">CSFLE NPM套餐</a></li><li id="fd49" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated"><a class="ae kz" href="https://docs.mongodb.com/drivers/use-cases/client-side-field-level-encryption-guide" rel="noopener ugc nofollow" target="_blank"> MongoDB CSFLE指南</a></li><li id="60f3" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated"><a class="ae kz" href="https://docs.mongodb.com/manual/core/security-explicit-client-side-encryption/" rel="noopener ugc nofollow" target="_blank"> MongoDB Explicit CSFLE手册</a></li><li id="a9e5" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated"><a class="ae kz" href="https://docs.mongodb.com/manual/core/schema-validation/" rel="noopener ugc nofollow" target="_blank"> MongoDB模式验证手册</a></li><li id="1761" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated"><a class="ae kz" href="https://json-schema.org/" rel="noopener ugc nofollow" target="_blank"> JSON模式主页</a></li></ul></div><div class="ab cl mw mx hy my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="in io ip iq ir"><p id="ab7e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢来到这里，也感谢你的阅读。</p></div></div>    
</body>
</html>