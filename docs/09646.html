<html>
<head>
<title>Using NFS Persistent Volumes Across Pods in ReadWriteMany Mode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在读写多模式下跨pod使用NFS永久卷</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-nfs-persistent-volumes-across-pods-in-readwritemany-mode-357a41eed6c9?source=collection_archive---------8-----------------------#2021-09-21">https://betterprogramming.pub/using-nfs-persistent-volumes-across-pods-in-readwritemany-mode-357a41eed6c9?source=collection_archive---------8-----------------------#2021-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b682" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将Google Filestore作为NFS共享安装到多个pod</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/14250be542d6cfbaf7dbc6661fa5596d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kUnhmZWPsFUp-EdE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@hngstrm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亨利&amp;公司</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5742" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网络文件共享或NFS是通过网络提供的块存储。在它的帮助下，您可以跨多个主机装载相同的存储资源。它是在各种系统间存储和共享信息的绝佳选择。当您希望应用程序的多个实例在高可用性模式下工作时，它通常会有所帮助。</p><p id="447e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从性能角度来看，传统上，NFS比基于SAN的永久磁盘要慢。然而，有了云中可用的托管服务，这个缺点就基本上被掩盖了。例如，以GCP的文件存储为例，它为不同类别的文件共享提供了以下IOPs:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/b90c4f16092ee8a7643fe4b7fb4b6abc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*php8f3aCXji6X5y2WeTEPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://cloud.google.com/filestore/docs/performance" rel="noopener ugc nofollow" target="_blank">谷歌云</a></p></figure><p id="3820" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们看一下持久性磁盘，您会看到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/4f71a2d1845a8cbcead89d358ec951d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*46Gc_ss94HkM2k2XlKatPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://cloud.google.com/compute/docs/disks/performance" rel="noopener ugc nofollow" target="_blank">谷歌云</a></p></figure><p id="20b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您查看这两个表，您会发现在这两种情况下IOPs和吞吐量是相当的，因此，如果您选择托管NFS产品，您不会损失太多。</p><p id="db07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，开始动手练习。我们将创建一个新的Google Filestore文件共享，并使用一个<code class="fe lw lx ly lz b">PersistentVolume</code>资源来访问它。然后我们将声称<code class="fe lw lx ly lz b">PersistentVolume</code>使用了<code class="fe lw lx ly lz b">PersistentVolumeClaim</code>资源。然后，我们将在一个<code class="fe lw lx ly lz b">Deployment</code>中使用<code class="fe lw lx ly lz b">PersistentVolumeClaim</code>，在这里我们将运行一个Flask应用程序的三个实例作为<code class="fe lw lx ly lz b">Pods</code>。每个<code class="fe lw lx ly lz b">Pod</code>将报告主机名和对特定应用程序的整体访问次数。所有三个<code class="fe lw lx ly lz b">Pods</code>将从文件共享中的同一个文件读取和写入。那么，现在，事不宜迟，让我们看看先决条件。</p><h1 id="0865" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">先决条件</h1><p id="8707" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在练习中，我们将使用Google Kubernetes引擎(GKE)集群和Google Filestore文件共享。因此，你自然需要一个GCP账户。好消息是，如果你还没有注册，你可以注册三个月的GCP免费试用。</p><p id="0868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还需要分叉<a class="ae ky" href="https://github.com/bharatmicrosystems/k8s-nas-pvc-gcp-fs" rel="noopener ugc nofollow" target="_blank">这个</a>存储库，克隆它，并<code class="fe lw lx ly lz b">cd</code>到其中进行练习。现在，让我们继续下一步创建GKE群集。</p><h1 id="7165" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">创建GKE集群</h1><p id="e34a" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">要创建GKE集群，请使用以下命令:</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="fb08" class="nb mb it lz b gy nc nd l ne nf">$ gcloud container clusters create cluster-1 --zone us-central1-a</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/0a25a3a06985419ea195cdbde5fc1938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qYWS63AERZlc7V57.gif"/></div></div></figure><p id="2d46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这需要几分钟的时间，您应该已经启动并运行了GKE集群。接下来，我们需要创建一个文件存储实例。</p><h1 id="657e" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">创建文件存储实例</h1><p id="9b79" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我们将创建一个具有<code class="fe lw lx ly lz b">3TB</code>容量的<code class="fe lw lx ly lz b">STANDARD</code>层文件存储实例，因为这只是一个演示。您可以使用适合您的使用情形和性能要求的层。</p><p id="b35d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建文件存储，请使用以下命令:</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="a4eb" class="nb mb it lz b gy nc nd l ne nf">$ gcloud filestore instances create cluster-1-fs --location us-central1-a --tier STANDARD --file-share=name="cluster_1_fs",capacity=3T --network=name=default</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/9d4e3fdbdb898e84dcf9dd1ebe29a9e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vBjdwvGRHW9-74c3XtbwiA.gif"/></div></div></figure><p id="af32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如我们所见，文件存储已创建。现在，让我们开始创建Kubernetes资源。</p><h1 id="aa83" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">创建Kubernetes资源</h1><p id="edaa" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我们首先必须创建一个指向我们创建的文件共享的<code class="fe lw lx ly lz b">PersistentVolume</code>，并创建一个<code class="fe lw lx ly lz b">PersistentVolumeClaim</code>来声明它。</p><h2 id="ea5a" class="nb mb it bd mc ni nj dn mg nk nl dp mk li nm nn mm lm no np mo lq nq nr mq ns bi translated">创建持久卷和声明</h2><p id="48b9" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在此之前，我们需要文件共享中的一些细节。让我们使用以下命令来列出它:</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="e6c5" class="nb mb it lz b gy nc nd l ne nf">$ gcloud filestore instances list</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/d079d51786eac2a9cc4d171d6cc543bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-HcLMWsaTcTlkPkMkTx2EA.gif"/></div></div></figure><p id="e271" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以在<code class="fe lw lx ly lz b">PersistentVolume</code>规范中使用这些细节。我们还需要声明<code class="fe lw lx ly lz b">PersistentVolume</code>使用了我们将要使用的<code class="fe lw lx ly lz b">PersistentVolumeClaim</code>资源。结合这两者，我们有以下清单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c9a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lw lx ly lz b">PersistentVolume</code> <code class="fe lw lx ly lz b">spec</code>部分，我们已经定义了:</p><ul class=""><li id="f614" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated"><code class="fe lw lx ly lz b">3TB</code>中的一个<code class="fe lw lx ly lz b">capacity</code>。这是我们在创建Filestore实例时指定的大小。</li><li id="8985" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><code class="fe lw lx ly lz b">accessModes</code>段有<code class="fe lw lx ly lz b">ReadWriteMany</code>，表示多个<code class="fe lw lx ly lz b">Pods</code>可以从这个<code class="fe lw lx ly lz b">PersistentVolume</code>同时读写。</li><li id="8df0" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">在<code class="fe lw lx ly lz b">nfs</code>部分中，我们有包含文件共享名的<code class="fe lw lx ly lz b">path</code>和应该包含文件存储的<code class="fe lw lx ly lz b">IP_ADDRESS</code>。用它替换<code class="fe lw lx ly lz b">&lt;YOUR_NAS_ENDPOINT&gt;</code>占位符。</li></ul><p id="a135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">PersistentVolumeClaim</code> <code class="fe lw lx ly lz b">spec</code>部分定义如下:</p><ul class=""><li id="eb66" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated"><code class="fe lw lx ly lz b">accessModes</code>设置为<code class="fe lw lx ly lz b">ReadWriteMany</code></li><li id="4794" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><code class="fe lw lx ly lz b">storageClassName</code>设置为<code class="fe lw lx ly lz b">""</code>。我们不想使用<code class="fe lw lx ly lz b">default</code>T3，而是想声明一个自定义<code class="fe lw lx ly lz b">PersistentVolume</code>。</li><li id="7c96" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><code class="fe lw lx ly lz b">volumeName</code>设置为<code class="fe lw lx ly lz b">fileserver-pv</code>。这将<code class="fe lw lx ly lz b">PersistentVolumeClaim</code>映射到我们定义的<code class="fe lw lx ly lz b">PersistentVolume</code>。</li><li id="3020" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">我们还在这里请求一个资源<code class="fe lw lx ly lz b">3TB</code>。</li></ul><p id="cd48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们继续使用以下命令应用清单:</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="367f" class="nb mb it lz b gy nc nd l ne nf">$ kubectl apply -f fileserver-pvc.yaml</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/736a091d709b7542ae3f61677b6c8199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*z5JLY6fQpPoPlYz9plu49g.gif"/></div></div></figure><p id="7485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，<code class="fe lw lx ly lz b">PersistentVolume</code>是可用的，并且绑定到了<code class="fe lw lx ly lz b">PersistentVolumeClaim</code>。因此，我们现在可以开始部署应用程序了。</p><h1 id="4d8f" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">部署应用程序</h1><p id="0f79" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">该应用程序是一个简单的Python Flask应用程序，它返回访问计数。以下是<code class="fe lw lx ly lz b">app.py</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="171d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们从代码中看到的，它试图从文件<code class="fe lw lx ly lz b">/data/count</code>中读取最新的访问计数，将数字递增<code class="fe lw lx ly lz b">1</code>，并返回该值，同时将更新后的值写入文件。为了确保多个实例不会同时修改文件，write函数中有一个锁定、修改和解锁模式。</p><p id="65b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这个应用程序已经构建好了，可以在DockerHub上使用。因此，我们将使用以下清单来部署它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="2562" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">清单由一个<code class="fe lw lx ly lz b">Deployment</code>和一个<code class="fe lw lx ly lz b">Service</code>资源组成。<code class="fe lw lx ly lz b">Deployment</code>资源运行我们应用程序的三个副本，它们都使用<code class="fe lw lx ly lz b">fileserver-pvc</code> <code class="fe lw lx ly lz b">PersistentVolumeClaim</code>。这意味着所有的副本可以同时从同一个文件系统中读取和写入。</p><p id="7c54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">Service</code>资源只是在负载均衡器的端口<code class="fe lw lx ly lz b">80</code>上公开应用程序。因此，我们应该能够使用负载平衡器IP地址从外部访问服务。</p><p id="076b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们继续使用以下命令应用清单:</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="4cf9" class="nb mb it lz b gy nc nd l ne nf">$ kubectl apply -f app-deployment.yam</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/0e422cd36ba0c1dcfdefbe27963f4fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0f5dViUc7D9WmjkGEg88Aw.gif"/></div></div></figure><p id="1f75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，<code class="fe lw lx ly lz b">Pods</code>正在运行，<code class="fe lw lx ly lz b">Service</code>有一个外部IP，我们可以开始测试了。</p><h1 id="8de4" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">测试部署</h1><p id="cfa0" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我们将使用<code class="fe lw lx ly lz b">curl</code>访问服务的外部IP，我们应该会看到负载在三个<code class="fe lw lx ly lz b">Pods</code>之间大致均衡。我们还应该看到访问计数器随着每次点击而增加，而不管点击的<code class="fe lw lx ly lz b">Pod</code>是什么。</p><p id="12e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用下面的命令来点击<code class="fe lw lx ly lz b">Service</code>:</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="4596" class="nb mb it lz b gy nc nd l ne nf">$ curl &lt;External_Service_IP&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/7c5949f5d2f7b619e1bee90d61404559.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MwUP_OIYF30mLVV65nqJYg.gif"/></div></div></figure><p id="23c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，当我们点击端点十次时，每次点击计数都会增加一，同时我们还可以观察到响应来自不同的<code class="fe lw lx ly lz b">Pods</code>。这意味着所有三个<code class="fe lw lx ly lz b">Pods</code>都是指文件共享中相同的事实来源。这就是<code class="fe lw lx ly lz b">ReadWriteMany</code>模式PVC为您带来的效果。</p><h1 id="d0da" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">结论</h1><p id="26d0" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">使用Google Filestore这样的托管服务作为<code class="fe lw lx ly lz b">ReadWriteMany</code> PVC的NFS，是一个非常高性能的选择，尤其是当您需要在您的环境中进行HA配置而又不使您的应用程序设计复杂化的时候。</p><p id="7e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望你喜欢这篇文章！</p></div></div>    
</body>
</html>