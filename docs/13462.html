<html>
<head>
<title>Displaying SQLite Data From the Flutter App on the iOS Home Screen</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iOS主屏幕上显示Flutter应用程序中的SQLite数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/displaying-sqlite-data-from-the-flutter-app-on-the-ios-home-screen-ea62965c92a6?source=collection_archive---------14-----------------------#2022-08-29">https://betterprogramming.pub/displaying-sqlite-data-from-the-flutter-app-on-the-ios-home-screen-ea62965c92a6?source=collection_archive---------14-----------------------#2022-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5cad" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Flutter与SwiftUI和Dart与Swift——从Flutter开发者的角度</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/70c359929cc6505cebd75d58a77addbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l2WViSCbU8FRcvhI-8LSiw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">这张图片的背景是由<a class="ae kv" href="https://www.freepik.com/free-vector/versus-vs-comparision-screen-background-template-design_9874140.htm" rel="noopener ugc nofollow" target="_blank">星线</a>制作的</p></figure><p id="80b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嘿，德夫斯！如果你已经几乎完美地完成了你的Flutter项目，并且正在寻找其他方法来提高用户使用你的应用程序(例如，在iPhones上)时的UX，有一个选择——在iOS主屏幕上显示你的应用程序数据！如果你没有Swift开发的经验，那就更好了，因为在本文中，我将从一个Flutter开发者的角度，向你展示Dart与Swift以及Flutter与SwiftUI的一些基本区别。</p><h1 id="247b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">开始之前</h1><p id="fcbc" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有两个小限制——你不能在Flutter框架中编写iOS上的主屏幕小部件，而且这些小部件只能在iOS 14+上使用。你将需要用Swift编写它们，但是如果你已经是一个有经验的Flutter开发者，用Swift编码对你来说将是小菜一碟。Dart在功能和用途方面与Swift非常相似，只有语法和符号上的细微差别。</p><p id="3d3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将看到一个在Dart和Swift中具有相同功能的数据库服务类的示例，以及Flutter和SwiftUI之间的基本差异。正如您可能注意到的，我们将添加的Swift部分将是绝对最小的。相对来说，这是对你知识的一个很好的扩展，而且对你的开发者简历来说是一个额外的奖励。</p><p id="1e03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在此处获得包含VCS提交历史记录的源代码，以查看更改情况:</p><div class="mp mq gp gr mr ms"><a href="https://github.com/tsinis/flutter_widgetkit" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">GitHub-tsin is/flutter _ widget kit:在iOS主屏幕上显示来自Flutter应用程序的SQLite数据…</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng kp ms"/></div></div></a></div><p id="5be0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以抓住它作为一个起点/参考，让我们去做吧！</p><h1 id="dc8a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们将做什么</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/f4f15dd3329a3092f0720a3c4e146e4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*g9nEsYH37fiQ__jdU0PplA.png"/></div></figure><p id="3815" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了进行演示，我们将重写经典的Flutter " <strong class="ky ir"> Counter </strong>"应用程序，在你的iPhone主屏幕上显示点击次数。因此，我们将把计数数据存储在Flutter中可用的最好的本地存储器之一— <strong class="ky ir"> SQLite </strong>。但是你可以很容易地使用你喜欢的方式，比如键值数据库、<code class="fe ni nj nk nl b">NSUserDefaults</code>等等。，这样就更容易了。SQLite具有独立于平台的优势，因此只要有SQLite支持，您的查询就可以工作。</p><p id="64da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便说一下，Swift对SQLite有“开箱即用”的支持。</p><p id="b565" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将每隔15分钟自动刷新一次主屏幕数据，但(主要)是直接从Flutter实时刷新。</p><h1 id="0cff" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">入门</strong></h1><p id="c512" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我假设您已经有了这个项目，如果没有，那么通过下面的命令创建一个新的项目:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="8e52" class="nq lt iq nl b gy nr ns l nt nu">flutter <strong class="nl ir">create</strong> ...</span></pre><p id="6993" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，让我们创建Swift的小部件。从您的Flutter项目命令的根目录运行:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="6795" class="nq lt iq nl b gy nr ns l nt nu"><strong class="nl ir">open</strong> ios/Runner.xcworkspace</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/98da64b31a82c412915cd2984cf5f2c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jI5iOVNFF_3L-m-GJ2BM4g.png"/></div></div></figure><p id="68dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将一个新的微件扩展目标(<strong class="ky ir">文件- &gt;新目标- &gt;微件扩展</strong>)添加到您最顶层的跑步者，并给它起一个您喜欢的名字。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/e279365147fa6af1cf00e897793324fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uSy_rDJtUPwmuih90ZOHoQ.png"/></div></div></figure><p id="c755" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在意图配置的<strong class="ky ir">包括配置意图</strong>上添加复选标记；否则，它将创建一个静态配置。IDE将添加一些文件，其中一些我们将在后续步骤中进行编辑。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/7d4b33f7e8107dbb9a39fced792e238c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kPtKArnMxd5ugVaOFRA54w.png"/></div></div></figure><h2 id="22da" class="nq lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated">数据库服务Swift文件</h2><p id="ed59" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们在Xcode中添加一个<code class="fe ni nj nk nl b">DatabaseService.swift</code>文件，我们将在后续步骤中用到它。右击<code class="fe ni nj nk nl b">CounterWidget</code>文件夹，选择<strong class="ky ir">新建文件… </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/29983462aedebf85a882fa919bffb26c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z6Mv6AI7fJLu8RFeh3eDvg.png"/></div></div></figure><p id="a2b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">选择<strong class="ky ir"> Swift文件</strong>并提供一个名称，确保选择正确的目标(不是Runner一个，而是你的Widget一个)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/23934ae14c70a789ba3502f471c2aef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j82Jq0cpPTZtA7JvOEGrFw.png"/></div></div></figure><h2 id="5ccc" class="nq lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated">应用程序组</h2><p id="4811" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们还没有离开Xcode，因为:</p><blockquote class="oj ok ol"><p id="8140" class="kw kx om ky b kz la jr lb lc ld ju le on lg lh li oo lk ll lm op lo lp lq lr ij bi translated">iOS应用程序是“<strong class="ky ir">沙箱化的</strong>”，所以我们必须创建一个<strong class="ky ir">应用程序组</strong>来连接主屏幕小部件和我们的Flutter应用程序。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/dd7f4238c5f3fdf0dc3ef25439799fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_4-krDg2aHKW3-kpFd1AHQ.png"/></div></div></figure><p id="958a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，只需将功能<em class="om"/><strong class="ky ir">应用程序组</strong>添加到您的Flutter应用程序和主屏幕小部件中。两个目标的组名(<strong class="ky ir">group.com.somename</strong>)必须相同。这一刻到此为止，现在是代码时间！</p></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><h1 id="7511" class="ls lt iq bd lu lv oy lx ly lz oz mb mc jw pa jx me jz pb ka mg kc pc kd mi mj bi translated">代码部分</h1><p id="d8f0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Xcode的官僚作风已经结束，所以让我们创建一个服务，它将提供在设备上存储离线数据的能力，并且在两种语言中非常相似。由于它是一个SQLite数据库，因此该服务的设计应该能够完成类似如下的工作:</p><ul class=""><li id="f2bc" class="pd pe iq ky b kz la lc ld lf pf lj pg ln ph lr pi pj pk pl bi translated">必须导入SQLite库，</li><li id="839f" class="pd pe iq ky b kz pm lc pn lf po lj pp ln pq lr pi pj pk pl bi translated">有一个合适的名字，像<code class="fe ni nj nk nl b">DatabaseService</code>，</li><li id="ae67" class="pd pe iq ky b kz pm lc pn lf po lj pp ln pq lr pi pj pk pl bi translated">SQLite本身有私有字段<code class="fe ni nj nk nl b">db</code>，</li><li id="7f78" class="pd pe iq ky b kz pm lc pn lf po lj pp ln pq lr pi pj pk pl bi translated">有一个打开数据库和初始化类的方法<code class="fe ni nj nk nl b">openDb()</code>，</li><li id="26f6" class="pd pe iq ky b kz pm lc pn lf po lj pp ln pq lr pi pj pk pl bi translated">具有用于读取存储值的方法<code class="fe ni nj nk nl b">getCount()</code>，</li><li id="5412" class="pd pe iq ky b kz pm lc pn lf po lj pp ln pq lr pi pj pk pl bi translated">具有私有的不可变的<code class="fe ni nj nk nl b">String</code>字段，用于应用程序组ID、数据库文件名和允许从数据库获取数据的SELECT语句</li></ul><p id="1942" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Dart端，我们还需要表名、id和值标识符的字段，以及更新计数器并将其保存到DB的方法。因此，让我们在每种语言中一步一步地创建它，并看看它们之间的一些差异，让我们总是从Dart开始，您可能更熟悉它。</p><h1 id="1166" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">骨架类</h1><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="44f3" class="nq lt iq nl b gy nr ns l nt nu"><strong class="nl ir">class</strong> DatabaseService {} // Dart class.</span></pre><p id="fa21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Swift中可能也是如此，但在这里我们可能更愿意使用<code class="fe ni nj nk nl b">struct</code>。</p><p id="70d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为在Swift中<code class="fe ni nj nk nl b">Classes</code>是引用类型，<code class="fe ni nj nk nl b">Structs</code>是值类型对象:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="e8f4" class="nq lt iq nl b gy nr ns l nt nu"><strong class="nl ir">struct</strong> DatabaseService {}</span></pre><p id="3a91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将它以及Swift中所有与DB相关的东西添加到<code class="fe ni nj nk nl b">DatabaseService.swift</code>文件中。</p><h2 id="6b95" class="nq lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated">不可变字段</h2><p id="934d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在Dart语言中，我们是这样声明私有不可变字段的:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="61fa" class="nq lt iq nl b gy nr ns l nt nu"><em class="om">static</em> <em class="om">const</em> <strong class="nl ir">_appGroupId</strong> = ‘group.com.example.flutterWidgetkit’;<br/><em class="om">static</em> <em class="om">const</em> <strong class="nl ir">_dbPath</strong> = ‘database.db’;<br/><em class="om">static</em> <em class="om">const</em> <strong class="nl ir">_queryStatementInt</strong> = “SELECT value FROM counter;”;</span></pre><p id="8514" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Swift中，我们必须使用一个<em class="om"> "private" </em>关键字来代替名称中的下划线，并使用一个<em class="om"> "let" </em>关键字来实现不变性。</p><p id="0ce0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要指定类型，我们必须编写“:<em class="om">String”</em>并用双引号将文本值括起来</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="7409" class="nq lt iq nl b gy nr ns l nt nu"><em class="om">private</em> <em class="om">let</em> <strong class="nl ir">queryStatementInt</strong> = “SELECT value FROM counter;”<br/><em class="om">private</em> <em class="om">let</em> <strong class="nl ir">appGroupId</strong> = “group.com.example.flutterWidgetkit”<br/><em class="om">private</em> <em class="om">let</em> <strong class="nl ir">dbPath</strong>: String = “database.db”</span></pre><h2 id="95a0" class="nq lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated">进口</h2><p id="28b1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Dart/Flutter没有对<code class="fe ni nj nk nl b">SQLite</code>的官方支持，所以选择你最喜欢的包，在这个例子中，我将使用<code class="fe ni nj nk nl b"><a class="ae kv" href="https://pub.dev/packages/sqflite" rel="noopener ugc nofollow" target="_blank">sqflite</a></code>包。首先，使用以下命令将其添加到您的项目中:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="122f" class="nq lt iq nl b gy nr ns l nt nu">flutter pub add <strong class="nl ir">sqflite</strong></span></pre><p id="68d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在导入看起来像这样:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="4907" class="nq lt iq nl b gy nr ns l nt nu"><em class="om">import</em> ‘package:sqflite/sqflite.dart’;</span></pre><p id="59d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于Swift内置了对SQLite的支持，因此它将站在Swift一边:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="6091" class="nq lt iq nl b gy nr ns l nt nu"><em class="om">import</em> SQLite3</span></pre><p id="db72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于一些基本层也是如此:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="e571" class="nq lt iq nl b gy nr ns l nt nu"><em class="om">import</em> Foundation</span></pre><h2 id="f766" class="nq lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated">数据库字段</h2><p id="2dd2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这将再次成为一个私有的:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="e5b4" class="nq lt iq nl b gy nr ns l nt nu"><em class="om">final</em> <strong class="nl ir"><em class="om">Database</em></strong> _db;</span></pre><p id="baf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Swift中，它可能是可变的和可空的，因为如果Swift没有找到DB文件，我们不应该仅仅创建一个新的数据库(与Flutter相反，Flutter应该在第一次运行时创建一个DB):</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="480a" class="nq lt iq nl b gy nr ns l nt nu"><em class="om">private</em> <em class="om">var</em> <strong class="nl ir">db</strong>: OpaquePointer?</span></pre><p id="60b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，这个支持空值的操作符与Dart相同。</p><h2 id="ba80" class="nq lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated">类初始化</h2><p id="50e7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">由于Dart没有异步构造函数/工厂，数据库打开总是异步操作，我们可以使用私有构造函数和静态异步方法<code class="fe ni nj nk nl b">openDb()</code>，它将返回<code class="fe ni nj nk nl b">DatabaseService</code>本身:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="5bbb" class="nq lt iq nl b gy nr ns l nt nu"><em class="om">const</em> <em class="om">DatabaseService</em>._(this._db);</span><span id="5474" class="nq lt iq nl b gy pr ns l nt nu"><em class="om">static</em> <em class="om">Future</em>&lt;<em class="om">DatabaseService</em>&gt; <strong class="nl ir">openDb</strong>() <em class="om">async</em> {<br/>...<br/><em class="om">return</em> <em class="om">DatabaseService</em>._(database);<br/>}</span></pre><p id="b309" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Swift中，用箭头-&gt;符号指定返回类型，用<code class="fe ni nj nk nl b">func</code>关键字声明函数/方法</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="d72c" class="nq lt iq nl b gy nr ns l nt nu"><strong class="nl ir"><em class="om">init</em></strong>() {<br/>db = openDb()<br/>}</span><span id="5d21" class="nq lt iq nl b gy pr ns l nt nu"><em class="om">private</em> <em class="om">func</em> <strong class="nl ir">openDb</strong>() -&gt; OpaquePointer? {<br/>...<br/>}</span></pre><h2 id="68f4" class="nq lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated">获取计数数据方法</h2><p id="6c9a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在Dart中，它将再次是异步操作，因为我们正在使用本机平台功能，并且在两端都有可空的返回，因为DB不一定包含数据(如果没有进行tap)。</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="a1a8" class="nq lt iq nl b gy nr ns l nt nu"><em class="om">Future</em>&lt;<em class="om">int</em>?&gt; <strong class="nl ir">getCount</strong>() <em class="om">async</em> {}</span></pre><p id="b688" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是在Swift中我们只显示数据，所以我们只能返回字符串:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="9aa1" class="nq lt iq nl b gy nr ns l nt nu"><em class="om">func</em> <strong class="nl ir">getCount</strong>() -&gt; String? {}</span></pre><h2 id="2e11" class="nq lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated"><strong class="ak">完成省道边</strong></h2><p id="2362" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">好了，让我们用Flutter中的实际功能来填充我们的框架。因此，为了打开和创建一个DB，我们还需要几个编译时常量:表名、id和值标识符。</p><p id="6665" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要打开数据库，我们需要知道应用程序组目录(因为你可能还记得，iOS应用程序是沙箱化的)，有几个软件包，但我将使用<a class="ae kv" href="https://pub.dev/packages/app_group_directory" rel="noopener ugc nofollow" target="_blank">这个</a>:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="ec06" class="nq lt iq nl b gy nr ns l nt nu">flutter pub add <strong class="nl ir">app_group_directory</strong></span></pre><p id="93f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们考虑依赖关系，让我们添加一个<a class="ae kv" href="https://pub.dev/packages/flutter_widgetkit" rel="noopener ugc nofollow" target="_blank">包</a>，用于手动触发iOS主屏幕小部件的刷新:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="993e" class="nq lt iq nl b gy nr ns l nt nu">flutter pub add <strong class="nl ir">flutter_widgetkit</strong></span></pre><p id="2f7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="om">顺便说一句，这个包中有很棒的文档，也有一篇文章的链接，其中有一个类似的例子，但是使用了</em><a class="ae kv" href="https://developer.apple.com/documentation/foundation/userdefaults" rel="noopener ugc nofollow" target="_blank"><em class="om">user defaults</em></a><em class="om">作为本地存储。</em></p><p id="5539" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在打开DB就像这样简单:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="f666" class="nq lt iq nl b gy nr ns l nt nu"><em class="om">static</em> <em class="om">Future</em>&lt;<em class="om">DatabaseService</em>&gt; <strong class="nl ir">openDb</strong>() <em class="om">async</em> {<br/><em class="om">final</em> directory = <em class="om">await AppGroupDirectory</em>.getAppGroupDirectory(_appGroupId);</span><span id="d7cd" class="nq lt iq nl b gy pr ns l nt nu"><em class="om">if</em> (directory == <em class="om">null</em>) <em class="om">throw</em> <em class="om">Exception</em>(‘App Group $_appGroupId not found!’);</span><span id="abc9" class="nq lt iq nl b gy pr ns l nt nu"><em class="om">final</em> database = <em class="om">await</em> openDatabase(join(directory.path, _dbPath),<br/>version: <em class="om">1</em>,<br/>onCreate: (db, _) =&gt; db.execute(<br/>‘’’<br/>CREATE TABLE $_table(<br/>$_id TEXT PRIMARY KEY,<br/>$_value INTEGER<br/>)<br/>‘’’,<br/> ),<br/>);</span><span id="a7e1" class="nq lt iq nl b gy pr ns l nt nu"><em class="om">return</em> <em class="om">DatabaseService</em>._(database);<br/>}</span></pre><p id="6903" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更新计数和强制窗口小部件刷新，让我们写(id在这里永远不会改变，但这只是一个例子，对不对？):</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="2993" class="nq lt iq nl b gy nr ns l nt nu"><em class="om">Future</em>&lt;<em class="om">void</em>&gt; <strong class="nl ir">updateCount</strong>(<em class="om">int</em> count) <em class="om">async</em> {<br/><em class="om">/// Insert a new count to the database, if exists — just replace it.<br/>await</em> _db.insert(<br/>_table,<br/>{_id: _id, _value: count},<br/>conflictAlgorithm: ConflictAlgorithm.replace,<br/>);</span><span id="84f4" class="nq lt iq nl b gy pr ns l nt nu"><em class="om">/// This will trigger a rebuild of Swift’s home-screen widget.<br/>return</em> <em class="om">WidgetKit</em>.reloadAllTimelines();<br/>}</span></pre><p id="2f84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，要从DB中获得值，请添加以下几行:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="4936" class="nq lt iq nl b gy nr ns l nt nu"><em class="om">Future</em>&lt;<em class="om">int</em>?&gt; <strong class="nl ir">getCount</strong>() <em class="om">async</em> {<br/><em class="om">final</em> map = <em class="om">await</em> _db.rawQuery(_queryStatementInt);<br/><em class="om">if</em> (map.isEmpty) <em class="om">return</em> <em class="om">null</em>;<br/><em class="om">final</em> maybeCount = map.first[_value];</span><span id="32bd" class="nq lt iq nl b gy pr ns l nt nu"><em class="om">return</em> maybeCount <em class="om">is</em> <em class="om">int</em> ? maybeCount : <em class="om">null</em>;<br/>}</span></pre><p id="2957" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在只需传递您的通行证存储计数，并更新您的应用程序的回调，我们就完成了。你可以在GitHub上看到结果</p><div class="mp mq gp gr mr ms"><a href="https://github.com/tsinis/flutter_widgetkit/blob/main/lib/database_service.dart" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">主tsin is/flutter _ widget kit/database _ service . dart</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">此文件包含双向Unicode文本，其解释或编译可能与下面显示的不同…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="ps l nd ne nf nb ng kp ms"/></div></div></a></div><h2 id="9903" class="nq lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated"><strong class="ak">最终确定Swift数据库服务</strong></h2><p id="4376" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">从<code class="fe ni nj nk nl b">DatabaseService</code>的角度来看，很容易打开我们将使用与Dart中类似的方法:打开应用程序组目录并查找数据库数据(如果存在):</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="84c6" class="nq lt iq nl b gy nr ns l nt nu"><em class="om">private</em> <em class="om">func</em> <strong class="nl ir">openDb</strong>() -&gt; OpaquePointer? {<br/><em class="om">let</em> fileManager = <em class="om">FileManager</em>.default<br/><em class="om">let</em> directory = fileManager.containerURL(forSecurityApplicationGroupIdentifier: appGroupId)<br/><em class="om">let</em> dbFile = directory!.appendingPathComponent(dbPath)<br/><em class="om">var</em> db: OpaquePointer?</span><span id="59a9" class="nq lt iq nl b gy pr ns l nt nu"><em class="om">if</em> sqlite3_open(dbFile.path, &amp;db) != SQLITE_OK {<br/>print(“Error opening database”)<br/><em class="om">return</em> <em class="om">nil<br/></em>} <em class="om">else</em> {<br/>print(“Successfully opened connection to database at \(dbPath)”)<br/><em class="om">return</em> db<br/> }<br/>}</span></pre><blockquote class="oj ok ol"><p id="f653" class="kw kx om ky b kz la jr lb lc ld ju le on lg lh li oo lk ll lm op lo lp lq lr ij bi translated">正如您可能注意到的，<strong class="ky ir"> nil </strong>是Swift的Dart的<strong class="ky ir"> null </strong>值的等价物。</p></blockquote><p id="3fd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">算起来，不会那么相似:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="55df" class="nq lt iq nl b gy nr ns l nt nu"><em class="om">func</em> <strong class="nl ir">getCount</strong>() -&gt; String? {<br/><em class="om">var</em> maybeCount: String?<br/><em class="om">var</em> queryStatement: OpaquePointer?<br/><em class="om">let</em> sqlState = sqlite3_prepare_v2(db, queryStatementInt, <em class="om">-1</em>, &amp;queryStatement, <em class="om">nil</em>)<br/><em class="om">if</em> sqlState == SQLITE_OK {<br/>  <em class="om">while</em> sqlite3_step(queryStatement) == SQLITE_ROW {<br/>  <em class="om">let</em> value = sqlite3_column_int(queryStatement, <em class="om">0</em>)<br/>  maybeCount = String(describing: value)<br/>  }<br/>} <em class="om">else</em> {<br/>  print(“SELECT statement could not be prepared”)<br/>}<br/>sqlite3_finalize(queryStatement)</span><span id="98b4" class="nq lt iq nl b gy pr ns l nt nu"><em class="om">return</em> maybeCount<br/>}</span></pre><p id="6d97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Swift实现数据库服务的结果也可在GitHub上获得:</p><div class="mp mq gp gr mr ms"><a href="https://github.com/tsinis/flutter_widgetkit/blob/main/ios/CounterWidget/DatabaseService.swift" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">主tsin is/flutter _ widget kit/databaseservice . swift</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="pt l nd ne nf nb ng kp ms"/></div></div></a></div><h1 id="9a20" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">为iOS编写主屏幕小工具</strong></h1><p id="32c9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，我们将需要在SwiftUI中编写一个主屏幕小部件，但重要的是，我们已经有了Xcode的大部分代码。</p><p id="3374" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看它在<code class="fe ni nj nk nl b">CounterWidget.swift</code>文件中给我们提供了什么。有很多类，但是我们可以忽略其中的大部分。其中最重要的一条是:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="7113" class="nq lt iq nl b gy nr ns l nt nu">struct SimpleEntry: <strong class="nl ir">TimelineEntry</strong></span></pre><p id="a9b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ni nj nk nl b">TimelineEntry</code>是一个协议，指定何时应该显示一个小部件，在这里我们可以添加我们需要在UI上显示的数据，在这个例子中，我们将只添加可空类型的计数(您可能还记得，总有一种情况是数据库中还没有存储数据，但不用担心我们会在UI上处理它):</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="a104" class="nq lt iq nl b gy nr ns l nt nu"><em class="om">struct</em> SimpleEntry: TimelineEntry {<br/><em class="om">let</em> date: Date<br/><em class="om">let</em> configuration: ConfigurationIntent<br/><em class="om">let</em> <strong class="nl ir">count</strong>: String?<br/>}</span></pre><p id="fe84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将会看到许多警告，并大叫缺少“<em class="om">计数</em>”，您现在只需提供默认值“1”就可以平息大多数警告。</p><p id="e4eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一个重要的东西是我们的UI(视图)，它在</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="b250" class="nq lt iq nl b gy nr ns l nt nu">CounterWidgetEntryView : <strong class="nl ir">View</strong></span></pre><p id="5034" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这包含以下可访问<code class="fe ni nj nk nl b">entry.count</code>值的代码:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="2a77" class="nq lt iq nl b gy nr ns l nt nu">var <strong class="nl ir">entry</strong>: Provider.Entry</span></pre><p id="2502" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SwiftUI与Flutter共享相同的声明性，所以让我们替换默认的:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="d2a9" class="nq lt iq nl b gy nr ns l nt nu">Text(entry.<strong class="nl ir">date</strong>, style: .time),</span></pre><p id="1365" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="8691" class="nq lt iq nl b gy nr ns l nt nu">Text(entry.<strong class="nl ir">count</strong> ?? “0”),</span></pre><p id="6167" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来就像我们在颤振中做的一样，对吗？</p><p id="a366" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我宁愿在上面添加一些标题来描述这个数字，在Flutter中，我会使用这样的<code class="fe ni nj nk nl b">Column</code>小部件:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="1360" class="nq lt iq nl b gy nr ns l nt nu"><strong class="nl ir"><em class="om">Column</em></strong><em class="om">(<br/>  children: [<br/>   </em>Text(“Count:”),<br/>   Text(entry.count ?? “0”),<br/>]</span></pre><p id="1d76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在SwiftUI中，这将非常非常相似:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="adcc" class="nq lt iq nl b gy nr ns l nt nu"><strong class="nl ir">VStack</strong> {<br/>  Text(“Count:”)<br/>  Text(entry.count ?? “0”).font(.title)<br/>}</span></pre><p id="5d0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您可能看到的，它几乎是1:1，语法和命名几乎没有区别。</p><p id="1f8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Swift的<code class="fe ni nj nk nl b">VStack</code>是Flutter的<code class="fe ni nj nk nl b">Column</code>一样的组件。</p><p id="6910" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还在计数中添加了“<em class="om"> title </em>”样式，使其更大。UI到此为止。</p><p id="573b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后也是最重要的一个需要理解的类是<code class="fe ni nj nk nl b"><a class="ae kv" href="https://developer.apple.com/documentation/widgetkit/intenttimelineprovider" rel="noopener ugc nofollow" target="_blank">IntentTimelineProvider</a></code>。该协议负责构建UI并在时间轴上显示/更新它，它包含三种方法:</p><ul class=""><li id="0e83" class="pd pe iq ky b kz la lc ld lf pf lj pg ln ph lr pi pj pk pl bi translated"><code class="fe ni nj nk nl b"><em class="om">placeholder</em></code>:允许我们向用户显示一个占位符视图，并告诉<em class="om"> WidgetKit </em>在加载小部件时呈现什么。</li><li id="53b6" class="pd pe iq ky b kz pm lc pn lf po lj pp ln pq lr pi pj pk pl bi translated"><code class="fe ni nj nk nl b"><em class="om">getSnapshot</em></code> : <code class="fe ni nj nk nl b"><em class="om">WidgetKit</em></code>在短暂的情况下显示小部件时发出快照请求，例如当我们在屏幕上添加一个小部件时。</li><li id="6452" class="pd pe iq ky b kz pm lc pn lf po lj pp ln pq lr pi pj pk pl bi translated">最重要的一个，它允许你从数据库加载数据，并声明我们的小部件的下一个刷新时刻。我们的代码使用<code class="fe ni nj nk nl b">.after</code>更新策略，它告诉<code class="fe ni nj nk nl b"><em class="om">WidgetKit</em></code>每隔大约15分钟请求一次新的时间线，但是我们将更依赖于来自Dart端的更新(通过<code class="fe ni nj nk nl b">WidgetKit.reloadAllTimelines()</code> <em class="om"> </em>调用)。在这里，我们可以初始化我们的<code class="fe ni nj nk nl b">DatabaseService</code>，从中获取值，并将其添加到时间轴中。</li></ul><p id="f777" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在这里看到默认Flutter/SwiftUI生成的文件和最终结果之间的差异:</p><div class="mp mq gp gr mr ms"><a href="https://github.com/tsinis/flutter_widgetkit/compare/2841d6aff96862c0c86e2a7e6e440f277fbf09df...main" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">比较2841 D6 aff 96862 c0c 86 e 2 a 7 e 6 e 440 f 277 fbf 09 df...main tsinis/flutter_widgetkit</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">很遗憾，我们现在似乎无法为您提供这种比较。可能太大了，也可能有…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="pu l nd ne nf nb ng kp ms"/></div></div></a></div><p id="1b53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这样，现在你应该可以通过Swift的WidgetKit在iOS主屏幕上显示Flutter应用程序的点击次数了。只需在项目根目录下使用以下命令运行您的应用程序，然后从Xcode运行您的主屏幕小部件(在顶部菜单中选择合适的目标):</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="c422" class="nq lt iq nl b gy nr ns l nt nu">flutter <strong class="nl ir">run</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pv"><img src="../Images/3de36d03a096e8e2e785481d51722f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-TBBUkZS3WiKKNjN7fdzmA.png"/></div></div></figure></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><p id="7ecb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望在读完这篇文章后，你已经获得了足够的勇气，开始自己用Swift编程。不管Flutter是否存在，这种类似Dart的语言将会伴随我们一段时间，正如你所看到的，它在你的Flutter项目中非常有用。感谢阅读！</p></div></div>    
</body>
</html>