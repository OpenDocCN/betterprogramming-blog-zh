<html>
<head>
<title>Recoil.js: The Future of React State Management?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React状态管理的未来？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/recoiljs-the-future-of-react-state-management-ffb1345833b6?source=collection_archive---------3-----------------------#2020-10-21">https://betterprogramming.pub/recoiljs-the-future-of-react-state-management-ffb1345833b6?source=collection_archive---------3-----------------------#2020-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4964" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入了解脸书新国家管理图书馆</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/254701db1fec303c777ffa1360046ec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*VLy_EwE7BnCao3moK4x-gw.jpeg"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">拉詹的照片— <a class="ae kr" href="https://medium.com/swlh/recoil-a-better-react-state-management-library-c136c41a5578" rel="noopener">来源</a></p></figure><p id="f23b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">脸书最近在欧洲的年度React会议上推出了作为开源状态管理库的<a class="ae kr" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>。</p><p id="dc6d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">它旨在:</p><ol class=""><li id="c9eb" class="lo lp iq ku b kv kw ky kz lb lq lf lr lj ls ln lt lu lv lw bi translated">尽量少反应。</li><li id="fccb" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated">通过纯函数和高效订阅驯服派生数据和异步查询。</li><li id="6067" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated">在不影响代码拆分的情况下，进行跨应用程序的观察和调试。</li></ol><p id="c0db" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">引用<strong class="ku ir"> </strong> <a class="ae kr" href="https://twitter.com/dan_abramov/status/1262141017421209604" rel="noopener ugc nofollow" target="_blank">丹·阿布拉莫夫</a><strong class="ku ir"/>(Redux的原作者)<strong class="ku ir"> </strong>回到2019年5月:</p><blockquote class="mc md me"><p id="eb34" class="ks kt mf ku b kv kw jr kx ky kz ju la mg lc ld le mh lg lh li mi lk ll lm ln ij bi translated">“首先，后坐力只在少数地方使用。脸书是一个巨大的代码库(&gt; 100，000个组件)，你不能期望某个单一的方法在任何地方都能使用。有几个地方也在用Redux。但这并没有解决反冲试图解决的问题。”</p></blockquote><p id="d405" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">从那以后，后坐力的受欢迎程度急剧上升。在撰写本文时，反冲已经获得了超过10k+ GitHub星，是前十名的每周趋势JS GitHub repos，其每周NPM包下载自发布以来一直呈上升趋势。当您考虑到该库仍处于试验阶段，并且对于生产级应用程序来说太不稳定时，这是非常令人印象深刻的。</p><p id="e027" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><em class="mf">注:脸书已经成功地在生产中为其一些内部工具部署了反冲。</em></p><p id="b97b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">那么这一切炒作是为了什么？反冲试图解决的那些问题是什么？还有…</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="ea2f" class="mq mr iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">我们是怎么到这里的？</h1><p id="bdde" class="pw-post-body-paragraph ks kt iq ku b kv ni jr kx ky nj ju la lb nk ld le lf nl lh li lj nm ll lm ln ij bi translated">让我们快速看一下促使脸书工程团队开发后坐力的一些潜在驱动因素。我们将会看到与其他常见的流行状态管理解决方案相比，反冲提供了一些独特的优势，例如<strong class="ku ir"> </strong> Redux和Hooks/Context API。</p><h2 id="5b6c" class="nn mr iq bd ms no np dn mw nq nr dp na lb ns nt nc lf nu nv ne lj nw nx ng ny bi translated"><strong class="ak"> Vs. Redux </strong></h2><ul class=""><li id="7fd1" class="lo lp iq ku b kv ni ky nj lb nz lf oa lj ob ln oc lu lv lw bi translated">更少的样板代码——反冲可以用更少的代码完成与Redux相同的关键功能，比如向存储订阅组件和分派动作</li><li id="6829" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln oc lu lv lw bi translated">更容易的学习曲线——实现Redux需要大量的设置开销。你有一个商店，reducers，<code class="fe od oe of og b">mapDispatchToProps</code>，<code class="fe od oe of og b">mapStateToProps</code>，这样的例子不胜枚举…</li><li id="71ec" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln oc lu lv lw bi translated">并发模式支持——反冲与并发模式兼容，但Redux没有纳入兼容性的计划。</li></ul><h2 id="3711" class="nn mr iq bd ms no np dn mw nq nr dp na lb ns nt nc lf nu nv ne lj nw nx ng ny bi translated"><strong class="ak"> Vs .上下文API </strong></h2><ul class=""><li id="666b" class="lo lp iq ku b kv ni ky nj lb nz lf oa lj ob ln oc lu lv lw bi translated">无上下文的地狱——尽管Context API的样板文件比Redux少，但是具有不确定数量的提供者的应用程序可能会导致您的React应用程序看起来像这样:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="12c7" class="lo lp iq ku b kv kw ky kz lb lq lf lr lj ls ln oc lu lv lw bi translated">更高效、更具性能的更新——由于状态变化而导致的不必要的渲染会影响应用程序的性能。这是上下文API的一个问题，因为上下文提供者值的更新会导致订阅该值的组件有时不得不进行不必要的重新呈现。</li><li id="697a" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln oc lu lv lw bi translated">不限于低频率更新— <strong class="ku ir"> <em class="mf"> </em> </strong>当与高频率更新一起使用时，Context API的性能会急剧下降，并且最终它从未打算以那种方式使用。</li></ul><p id="67d4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在让我们更深入地了解反冲的核心概念以及它如何管理状态。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="3074" class="mq mr iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">反冲核心概念</h1><p id="ba20" class="pw-post-body-paragraph ks kt iq ku b kv ni jr kx ky nj ju la lb nk ld le lf nl lh li lj nm ll lm ln ij bi translated">假设我们有一个如下所示的应用程序:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/cd9a92c43888dac5e922b98bf1f57df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*-EuDwALNpHGP0SfFH7295w.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">Redhwan Nacef 的反冲教程。</p></figure><p id="64eb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们看到NavBar、Body、Profile和Count <strong class="ku ir"> </strong>组件都订阅了相同的用户名状态:“Redhwan Nacef。”</p><p id="7b25" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们的组件树看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ol om di on bf oo"><div class="gh gi ok"><img src="../Images/2c1c64d7f13e91ed328cd6f2e354f04b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dv0QRKzTOxGDdofN32sfxg.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">Redhwan Nacef 的反冲教程。</p></figure><p id="e0b9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在组件树中，<strong class="ku ir"> </strong>导航组件与计数和配置文件组件“相距数英里”。为了在所有组件之间共享相同的状态，您通常会做的是从应用程序到计数和配置文件的适当钻取状态。</p><p id="7c61" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们知道这在较大的应用程序中不能很好地扩展，因为当状态改变时，它会导致组件不必要的渲染。</p><p id="8131" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">那么反冲如何解决这个问题呢？</p><p id="c301" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了回答这个问题，我们将介绍原子和选择器。</p><p id="2b5e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们可以想象将组件树平铺在一个平面上，与该平面正交的是<strong class="ku ir"> </strong>原子和选择器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ol om di on bf oo"><div class="gh gi op"><img src="../Images/4bd97157fcb8b41b80ab9462eaa17307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nXmCK-coNHDcEe2-W9O-rg.gif"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">React欧洲会议<a class="ae kr" href="https://www.youtube.com/watch?v=_ISAA_Jt9kI" rel="noopener ugc nofollow" target="_blank"> 2020反冲演示</a></p></figure><p id="2948" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">原子是组件可以订阅的状态单位。您可以订阅和更新它们，但这里的关键是，当每个原子的状态改变时，只有订阅了该原子的组件才会被重新呈现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/2b1c142369f5fd1c8ada930c444a9fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*5WyU0pNNC-yk9YKdHBEK3A.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">官方文件:原子</p></figure><p id="827b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">一旦创建了一个原子并声明了状态(类似于Redux store)，您就可以通过使用以下任一方法为该原子订阅组件:</p><ol class=""><li id="6c5e" class="lo lp iq ku b kv kw ky kz lb lq lf lr lj ls ln lt lu lv lw bi translated"><code class="fe od oe of og b">useRecoilValue</code></li><li id="3424" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated"><code class="fe od oe of og b">useRecoilState</code>(类似于钩子中的<code class="fe od oe of og b">useState</code>)</li></ol><p id="6e3c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">选择器<strong class="ku ir"> </strong>代表一个派生状态，当您想要一个从多个原子或依赖项派生的输出时，它是适用的。下面的反冲文档显示了一个很好的例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi or"><img src="../Images/28354feea855f5c329087c1d747b8444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*p_hQk-5emzvx1t7zXvfdLg.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">反冲JS <a class="ae kr" href="https://recoiljs.org/docs/basic-tutorial/selectors/" rel="noopener ugc nofollow" target="_blank">公文</a>:选择器</p></figure><p id="c825" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果你有兴趣了解更多，请查看本系列的<a class="ae kr" href="https://medium.com/@guizzettic/2e242d4509ae" rel="noopener">第2部分</a>，在那里我们将深入了解当前存在反冲的开发者工具的情况。</p><p id="c61f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">撰稿人:Vincent Nguyen、Sanjay Lavingia、Jason Victor、Chris Guizzetti和Alexander Landeros。</p></div></div>    
</body>
</html>