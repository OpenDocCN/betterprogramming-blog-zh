<html>
<head>
<title>Three Easy Ways to Improve Web Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高Web性能的三种简单方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/three-easy-ways-to-improve-web-performance-f9ca7e5caf32?source=collection_archive---------1-----------------------#2019-05-12">https://betterprogramming.pub/three-easy-ways-to-improve-web-performance-f9ca7e5caf32?source=collection_archive---------1-----------------------#2019-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2cf5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过利用代码分割、PRPL模式和延迟加载来提高效率</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6dc56fd701f3d676bb183c3cf7872c6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4CbZg-R10S5-oX5eKamOg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/javascript-startup-optimization/" rel="noopener ugc nofollow" target="_blank"> JavaScript下载和执行成本</a></p></figure><p id="2e5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几周前，我参加了一个meetup，有机会了解了一些不可思议的Google Dev工具，可以通过Google Chrome扩展、命令行或节点模块使用。这些工具中我最喜欢的一个是<a class="ae ky" href="https://developers.google.com/web/tools/lighthouse/" rel="noopener ugc nofollow" target="_blank">谷歌灯塔</a>，它对网页进行审计，并生成一份详细说明性能、可访问性、PWA等等的报告。它还提供了具体的细节，如哪些因素影响了特定的分数，以及如何提高分数的清晰建议和文档。</p><p id="3fbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最近的一次工作面试之前，我在公司网站上运行了谷歌灯塔来检查他们的表现(希望能得到额外的印象分！).结果他们在网站性能上得了27分(满分100分)，这使他们进入了红色区域。大OOF！</p><p id="4938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在审查该报告时，我们可以看到主要的罪魁祸首是:</p><ul class=""><li id="8cae" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">主线工作</li><li id="69c1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">JavaScript执行时间</li><li id="9065" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">巨大的网络负载</li></ul><blockquote class="mj"><p id="8853" class="mk ml it bd mm mn mo mp mq mr ms lu dk translated">“JavaScript在主线程上被解析和编译。当主线程繁忙时，页面无法响应用户输入。[……]JavaScript也在主线程上执行。”</p></blockquote><p id="65d0" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">根据Google Lighthouse的报告，主线程工作给加载时间增加了惊人的10.2秒。这个时间包括解析、编译和执行JavaScript。此外，该网站的网络负载为<strong class="lb iu">4327 KB</strong>——肯定不是最佳的。JavaScript量越大，下载时间越长，网络成本越大，不幸的是，用户体验越不愉快。</p><p id="edba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们如何减少主线程工作的大小和时间呢？我们来看几个选项。</p><h1 id="8863" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">代码分割</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/b2f540f38a35d1944471ca02d375f001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PFTAxe9mTRvesrs27I3TXQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://developers.google.com/web/fundamentals/performance/webpack/" rel="noopener ugc nofollow" target="_blank">代码分割</a></p></figure><p id="ed80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你试着一次吃掉一整个三明治，可能会比你一次吃一小口并依次消化每一口花费更长的时间。类似地，如果您将所有的JavaScript放在一个大堆中，编译器将需要很长时间来读取所有代码，然后在执行环境中处理所有代码以呈现网页。<a class="ae ky" href="https://developers.google.com/web/fundamentals/performance/optimizing-javascript/code-splitting/" rel="noopener ugc nofollow" target="_blank">代码分割</a>是一种简单的方法，它以较小的包交付JavaScript，以加快解析和编译时间，然后将每个包发送到执行环境。使用较小的JavaScript块，可以减少加载时间并提高web性能。</p><p id="cf29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">三种不同的代码分解方式:</p><ul class=""><li id="5587" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">供应商分割</strong>是将代码中任何你认为是“依赖”或第三方来源的东西分离到一个单独的文件夹中，通常是“<em class="nr">/供应商”</em>。如果您的应用程序代码或供应商代码有任何更改，它们可以单独处理，而不会干扰其他代码。</li><li id="a86a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">入口点分割</strong>推荐用于没有明确设置服务器端路由和客户端路由的应用程序。这意味着在最初构建依赖项时，使用像<a class="ae ky" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>这样的工具来拆分代码。</li><li id="634f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">对于使用动态“<em class="nr">import()”</em>语句的单页应用程序，建议使用动态拆分</strong>。</li></ul><p id="3c8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重建整个代码库来实现代码拆分似乎是一场磨难，但好消息是有大量工具可以让这个过程自动化(<a class="ae ky" href="https://github.com/developit/preact-cli/" rel="noopener ugc nofollow" target="_blank"> Preact CLI </a>、<a class="ae ky" href="https://github.com/Polymer/pwa-starter-kit/" rel="noopener ugc nofollow" target="_blank"> PWA Starter Kit </a>等)。).但是如果你正在开发一个更小的特性、项目，或者刚刚起步，要知道手动代码分割是由<a class="ae ky" href="https://reactjs.org/docs/code-splitting.html" rel="noopener ugc nofollow" target="_blank"> React </a>、<a class="ae ky" href="https://vuejsdevelopers.com/2017/07/03/vue-js-code-splitting-webpack/" rel="noopener ugc nofollow" target="_blank"> Vue </a>和<a class="ae ky" href="https://angular.io/guide/lazy-loading-ngmodules" rel="noopener ugc nofollow" target="_blank"> Angular </a>支持的。</p><h1 id="83ef" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">PRPL</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/857ac612eac1d9636e4d72b7ba9a9d7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Wyjtu0IsVdiDgU9eqhSPQ.png"/></div></div></figure><ul class=""><li id="6835" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">推送</strong>初始URL路由的关键资源。</li><li id="c890" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">渲染</strong>初始路线。</li><li id="c6fa" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">预缓存</strong>剩余路线。</li><li id="c937" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">延迟加载</strong>并按需创建剩余路线。</li></ul><p id="c72f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建代码的体系结构是一个很好的实践，这样您首先发送显示页面所需的最少量的代码。本质上，从发送骨骼开始，然后在后面添加肌肉、器官和衣服。这将大大提高你的互动时间。开发人员设计了PRPL模式来减少加载时间，并将移动网络的内存使用保持在最低水平。</p><p id="702a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/" rel="noopener ugc nofollow" target="_blank">谷歌文档</a>有效且高效地解释了PRPL，但为了给你一个快速纲要，PRPL最好与以下应用程序结构一起使用:</p><ul class=""><li id="fb27" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">入口点:</strong>index.html——应该非常小，以最大限度地减少RAM的使用</li><li id="60cc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">外壳:</strong>顶层应用-逻辑、路由、主UI、静态依赖</li><li id="a850" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">片段:</strong>在加载的DOM内容中不能立即看到的任何东西。这就是延迟加载发挥作用的地方。</li></ul><p id="bbdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以定制您的非捆绑构建过程，并利用<a class="ae ky" href="https://developers.google.com/web/fundamentals/performance/http2/#server-push" rel="noopener ugc nofollow" target="_blank"> HTTP/2 Push </a>或<code class="fe nt nu nv nw b"><a class="ae ky" href="https://developers.google.com/web/updates/2016/03/link-rel-preload" rel="noopener ugc nofollow" target="_blank">&lt;link rel="preload"&gt;</a></code>来指示哪些代码片段对于框架框架是必不可少的。如果不支持这些特性，您可以将您的构建过程捆绑到shell和fragment包中。</p><p id="8043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">减少有效负载的其他方法包括通过使用压缩器缩小JS、HTML和CSS，使用文本压缩如GZIP，以及选择最佳的图像文件类型和压缩级别。</p><h1 id="e411" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">惰性装载</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/f552aa3c76fb1f4307dbab2b0764f6e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DBV0rf1m6CjzQSKRwjMW8Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">当滚动到视窗中时，首先显示一个<a class="ae ky" href="https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/" rel="noopener ugc nofollow" target="_blank">占位符图像，并迅速替换为实际图像</a></p></figure><p id="b88a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">延迟加载就像它听起来的那样——它将准备好加载，但是在以后你需要它的时候。节省数据和处理时间的一个快速方法是推迟任何资源，直到它们进入视口。对于图像，可以使用事件处理程序，如<em class="nr"> "scroll" </em>或<em class="nr"> "resize" </em>，但是在更现代的浏览器上，可以使用<a class="ae ky" href="https://developers.google.com/web/updates/2016/04/intersectionobserver" rel="noopener ugc nofollow" target="_blank">交叉点观察器API </a>。</p><p id="75c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两种情况下，您都指定了某种类型的<strong class="lb iu">指示器</strong>来让代码知道资源何时在视窗中。你可以声明一个“懒惰”的图像url，和实际的图像url，只要给你的图像标签一个类<em class="nr">“懒惰”；</em>对于div的背景图像，使用类别<em class="nr">。懒惰-背景“</em>和<em class="nr">”。懒-background.visible”。</em>正如所料，这些<a class="ae ky" href="https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/#lazy_loading_libraries" rel="noopener ugc nofollow" target="_blank">惰性加载库</a>的存在有助于加速惰性加载的实现，因此您不必彻底调查幕后发生了什么。难道你不喜欢开发者让彼此的生活变得更容易吗？</p><h1 id="0f11" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">结论</h1><p id="c722" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">PRPL模式是黄金标准，特别是对于移动开发来说，它可以最小化网络负载并有效地组织你的代码架构。这很大程度上意味着人们应该应用代码分割和延迟加载来获得最佳实践。<strong class="lb iu">代码分割</strong>对于将你的代码分解成便于执行环境处理的可管理的片段来说是很棒的，这样就可以理清主线程的工作。<strong class="lb iu">延迟加载</strong>通过仅在需要时调用资源片段，尤其是媒体文件类型，可以节省内存并减少加载时间。通过这三个简单的实现，您可以显著减少交互时间，从而创建更好的用户体验。</p><blockquote class="od oe of"><p id="7fef" class="kz la nr lb b lc ld ju le lf lg jx lh og lj lk ll oh ln lo lp oi lr ls lt lu im bi translated">仅发送您的用户需要的代码。</p><p id="b8e8" class="kz la nr lb b lc ld ju le lf lg jx lh og lj lk ll oh ln lo lp oi lr ls lt lu im bi translated">缩小你的代码。</p><p id="5783" class="kz la nr lb b lc ld ju le lf lg jx lh og lj lk ll oh ln lo lp oi lr ls lt lu im bi translated">压缩你的代码。</p><p id="0f1a" class="kz la nr lb b lc ld ju le lf lg jx lh og lj lk ll oh ln lo lp oi lr ls lt lu im bi translated"><strong class="lb iu">删除不用的代码。</strong></p><p id="43a1" class="kz la nr lb b lc ld ju le lf lg jx lh og lj lk ll oh ln lo lp oi lr ls lt lu im bi translated">缓存你的代码以减少网络行程。</p><p id="7570" class="kz la nr lb b lc ld ju le lf lg jx lh og lj lk ll oh ln lo lp oi lr ls lt lu im bi translated">——<a class="ae ky" href="https://developers.google.com/web/tools/lighthouse/audits/bootup?utm_source=lighthouse&amp;utm_medium=extension" rel="noopener ugc nofollow" target="_blank">developers.google.com</a></p></blockquote></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="b05c" class="my mz it bd na nb oq nd ne nf or nh ni jz os ka nk kc ot kd nm kf ou kg no np bi translated">资源</h1><ul class=""><li id="b976" class="lv lw it lb b lc ny lf nz li ov lm ow lq ox lu ma mb mc md bi translated"><a class="ae ky" href="https://developers.google.com/web/tools/lighthouse/audits/bootup?utm_source=lighthouse&amp;utm_medium=extension" rel="noopener ugc nofollow" target="_blank"> <em class="nr">谷歌灯塔</em> </a></li><li id="3d15" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://developers.google.com/web/fundamentals/performance/optimizing-javascript/code-splitting/" rel="noopener ugc nofollow" target="_blank"> <em class="nr">代码拆分</em> </a></li><li id="0ed3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/" rel="noopener ugc nofollow" target="_blank"> <em class="nr">优化内容效率</em> </a></li><li id="0b9b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/What_is_JavaScript" rel="noopener ugc nofollow" target="_blank"><em class="nr">Javascript——什么是Javascript，如何工作</em> </a></li><li id="12ed" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://developers.google.com/web/tools/lighthouse/audits/network-payloads?utm_source=lighthouse&amp;utm_medium=extension" rel="noopener ugc nofollow" target="_blank"> <em class="nr">网络有效载荷</em> </a></li><li id="c238" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/" rel="noopener ugc nofollow" target="_blank"> <em class="nr"> PRPL </em> </a></li><li id="56e9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/" rel="noopener ugc nofollow" target="_blank"> <em class="nr">偷懒加载图片和视频</em> </a></li><li id="1e22" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://developers.google.com/web/tools/lighthouse/audits/offscreen-images" rel="noopener ugc nofollow" target="_blank"> <em class="nr">屏幕外图像</em> </a></li></ul></div></div>    
</body>
</html>