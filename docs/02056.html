<html>
<head>
<title>Compare Leading JavaScript Functional Reactive Stream Libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较领先的JavaScript函数式反应流库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/compare-leading-javascript-functional-reactive-stream-libraries-544163c1ded6?source=collection_archive---------7-----------------------#2019-11-03">https://betterprogramming.pub/compare-leading-javascript-functional-reactive-stream-libraries-544163c1ded6?source=collection_archive---------7-----------------------#2019-11-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8bbd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">RxJS、@most/core和XStream</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8ebe4b07e79478d504f249db9baafcda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UmiUDuB4ldK9d9Lx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@quinoal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奎诺·阿尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2681" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">关于功能反应流</h1><blockquote class="ly"><p id="c03a" class="lz ma it bd mb mc md me mf mg mh mi dk translated"><em class="mj">“反应式编程是一种声明式编程范式，关注数据流和变化的传播[1]。”— </em> <a class="ae ky" href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="841e" class="pw-post-body-paragraph mk ml it mm b mn mo ju mp mq mr jx ms mt mu mv mw mx my mz na nb nc nd ne mi im bi translated">每个反应式编程应用程序的基础都有一个库，它提供数据结构和操作符来组成模拟解决方案的数据流。</p><p id="d621" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">这些库通常被称为<em class="nk">流库</em>，其特征在于不同的因素。让我们看看其中的一些。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6f28" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">推/拉</h1><p id="16cd" class="pw-post-body-paragraph mk ml it mm b mn nl ju mp mq nm jx ms mt nn mv mw mx no mz na nb np nd ne mi im bi translated">在基于推的行为中，程序图准备好了，并且不断地监听新的输入数据。例如，DOM元素上的事件侦听器就是这种情况:当新的输入事件发生时，相对回调就会运行。</p><p id="6e31" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">相比之下，对于基于拉的输入，它在需要时被读取。这通常发生在连续变化的值上，例如，当我们调用一个返回当前时间的函数时。</p><p id="8b72" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">功能反应库通常专注于推，但也有实验扩展到支持拉。(例如，参见<a class="ae ky" href="https://github.com/funkia/hareactive" rel="noopener ugc nofollow" target="_blank">主动行为</a>【2】和<a class="ae ky" href="https://github.com/cyclejs/cyclejs/issues/581" rel="noopener ugc nofollow" target="_blank"> Xstream信号</a>【3】)。)</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8586" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">冷/热流</h1><p id="528e" class="pw-post-body-paragraph mk ml it mm b mn nl ju mp mq nm jx ms mt nn mv mw mx no mz na nb np nd ne mi im bi translated">反应式库为构建我们的应用程序业务图提供了基础。当图形开始运行输入数据时，生成器连接并监听输入事件。</p><p id="5a65" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">这里有两种口味。如果在将侦听器添加到流(或相关流)时，在流内部创建了数据生成器，则该流被定义为冷流。这通常意味着流在默认情况下是单播的，并且每个连接的侦听器都会获得不同的生成器实例化。</p><p id="f8ba" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">当生产者被创建在流之外时，我们称之为热流。这种情况通常是多播，许多流可以监听同一个共享数据源。为了得到更多的解释，我把戴夫·塞克斯顿关于热/冷现象的文章转发给你。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="4340" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">隐式/显式时间建模</h1><p id="50db" class="pw-post-body-paragraph mk ml it mm b mn nl ju mp mq nm jx ms mt nn mv mw mx no mz na nb np nd ne mi im bi translated">如前所述，反应库的基本功能是实现应用程序数据图，该数据图对输入数据做出反应，并随着时间的推移产生所需的输出。</p><p id="97cf" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">时间概念可以用输入数据推送时间和函数调用顺序显式表示。或者，以一种更含蓄的方式，为每个输入数据创建一个元组，将它与一个时间号相关联。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="839f" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">同步/异步启动</h1><p id="0f72" class="pw-post-body-paragraph mk ml it mm b mn nl ju mp mq nm jx ms mt nn mv mw mx no mz na nb np nd ne mi im bi translated">在应用程序图被声明和实例化之后，需要调用一个方法来开始观察输入事件。</p><p id="98f1" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">有两种策略。同步启动时，通常会在流上调用一个<code class="fe nq nr ns nt b">addListener</code>方法。该方法同步向后运行网络，在到达输入源时创建并观察输入源。</p><p id="8da2" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">通常，在同步启动的应用程序中，当应用程序需要观察新的数据源时，我们会在不同的时间点发现许多对<code class="fe nq nr ns nt b">addListener</code>方法的调用。</p><p id="5a1a" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">在异步启动中，通常每个应用程序只有一个运行效果函数调用。所有的流(现有的和未来的)合并/合成为这个单一的最终流。这种启动方法通常是异步的，所有流都等待处理输入事件，直到整个网络预热。</p><p id="5b85" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">让我们介绍一下竞争者…</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="d080" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">RxJS:可观察的Boss</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/89d715e4eda0f79dfd09491b1c8d3b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*UKlZfV1HSd8cNsjb.png"/></div></figure><p id="13f9" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">可能是JavaScript生态系统中最成熟、最常用的反应式lib。</p><ul class=""><li id="ccd0" class="nv nw it mm b mn nf mq ng mt nx mx ny nb nz mi oa ob oc od bi translated">仓库:【https://github.com/ReactiveX/rxjs】T2。</li><li id="452a" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">当前版本:6.3.3。</li><li id="6741" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">星星和所用:2.1K 2m。</li><li id="6f88" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">类型支持:本机类型脚本。</li><li id="81cb" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">推/拉:推。</li><li id="c76d" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">冷/热:热(能支持冷)。</li><li id="bddb" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">隐式/显式时间:隐式。</li><li id="5367" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">API样式:静态或由管道点状。</li><li id="68ea" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">原生ES6模块支持:不支持(在v.7中支持，目前在alpha中支持。)</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="aa4c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">XStream:循环之王</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/e21816f3d84cd6b6a4ad145e9fdf2327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fiaqvs39rw68UsoxnNvQFA.png"/></div></div></figure><p id="c6a7" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">为了更好地解决<a class="ae ky" href="https://cycle.js.org/" rel="noopener ugc nofollow" target="_blank"> Cycle.js </a>的特定功能需求，它可以被认为是来自<a class="ok ol ep" href="https://medium.com/u/3ba9db42812d?source=post_page-----544163c1ded6--------------------------------" rel="noopener" target="_blank"> André Staltz </a>的RxJS的精简版和自以为是的版本。</p><ul class=""><li id="9a3b" class="nv nw it mm b mn nf mq ng mt nx mx ny nb nz mi oa ob oc od bi translated">知识库:<a class="ae ky" href="https://github.com/staltz/xstream" rel="noopener ugc nofollow" target="_blank">https://github.com/staltz/xstream</a>。</li><li id="c726" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">当前版本:11.11.0。</li><li id="1b12" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">星星:1.9K。</li><li id="9e7c" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">类型支持:本机类型脚本。</li><li id="cecc" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">推/拉:推。</li><li id="f34b" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">冷/热:热。</li><li id="ebfa" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">隐式/显式时间:隐式。</li><li id="b532" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">API风格:以点为主。</li><li id="7892" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">原生ES6模块支持:否</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e24e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">@most/core:新城</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/8a36e29eba138b1a5b451dd1fe2947f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*Zy0iJwK06VzjWZzFAKP3Gg.png"/></div></figure><p id="968d" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">来自Brian Cavalier 的FRP一元流工具包的新化身。</p><ul class=""><li id="320a" class="nv nw it mm b mn nf mq ng mt nx mx ny nb nz mi oa ob oc od bi translated">知识库:<a class="ae ky" href="https://github.com/mostjs/core" rel="noopener ugc nofollow" target="_blank">https://github.com/mostjs/core</a>。</li><li id="1bf9" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">当前版本:1.4.1。</li><li id="ea64" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">星星:223(主项目上3.1K)。</li><li id="2884" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">类型支持:流和类型脚本定义。</li><li id="5531" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">推/拉:推。</li><li id="0f18" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">冷/热:热。</li><li id="7599" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">隐式/显式时间:显式。</li><li id="954c" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">API风格:静态。</li><li id="c8bc" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">原生ES6模块支持:是。</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a81d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">基准应用程序</h1><p id="1b1b" class="pw-post-body-paragraph mk ml it mm b mn nl ju mp mq nm jx ms mt nn mv mw mx no mz na nb np nd ne mi im bi translated">为了进行基准测试，用三个库复制了一个简单的图形网络。</p><p id="94dc" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">每个版本都在独立的ES6模块中实现。对于每一个输入脉冲，网络都会生成一个待办事项列表。每个项目都有一个旧项目的副本(旧项目每四个元素更新一次)。</p><p id="07af" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">该网络非常简单，但使用了三个libs的一些主要运营商。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="8e13" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">该网络的另一个特点是存在一个“钻石”。不建议使用菱形流，因为它会在执行过程中<a class="ae ky" href="https://staltz.com/rx-glitches-arent-actually-a-problem.html" rel="noopener ugc nofollow" target="_blank">导致故障</a>。在演示中，钻石被自愿引入，以比较三个lib的反应。</p><p id="cfee" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">简而言之，<a class="ae ky" href="https://github.com/mostjs/core" rel="noopener ugc nofollow" target="_blank">最</a>，其明确的时间表示和异步启动是最直观和抗故障的。对于另外两个库，有必要强制一个异步行为，添加一个<code class="fe nq nr ns nt b">setTimeout</code>以使菱形网络按预期工作。</p><p id="5785" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">让我们看看三个版本的核心加上一个命令式的传统版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">命令式繁体版本</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">RxJS版本</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">@ most/核心版</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">XStream版本</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="1105" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">速度基准</h1><p id="ba55" class="pw-post-body-paragraph mk ml it mm b mn nl ju mp mq nm jx ms mt nn mv mw mx no mz na nb np nd ne mi im bi translated"><a class="ae ky" href="https://benchmarkjs.com/" rel="noopener ugc nofollow" target="_blank"> Benchmark.js </a>用于比较三个库的速度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每秒操作数(越高越好)</p></figure><ul class=""><li id="2524" class="nv nw it mm b mn nf mq ng mt nx mx ny nb nz mi oa ob oc od bi translated">@most/core — 60.83操作/秒2.60% (72次运行采样)。</li><li id="a040" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">XStream — 54.59操作/秒1.46%(采样了81次运行)。</li><li id="d303" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated">RxJS — 51.58操作/秒2.59% (80次运行采样)。</li></ul><p id="ba9d" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">最快的是@most/core。18.40s完成，纱速17.22s，用户0.58s，系统93% cpu，总计18.955。</p><p id="5477" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">所有三个lib都非常有性能。Most/core以最佳每秒运算值胜出。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f143" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">内存基准</h1><p id="3054" class="pw-post-body-paragraph mk ml it mm b mn nl ju mp mq nm jx ms mt nn mv mw mx no mz na nb np nd ne mi im bi translated">内存管理与速度同等重要，甚至更重要。在现实世界的应用程序中，我们将拥有成千上万的流节点。正确有效的内存管理将是基础。</p><p id="743c" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">为了测量内存压力，Node以一个暴露的<a class="ae ky" href="https://nodesource.com/blog/request-garbage-collection-for-node-js-processes-with-n-solid/" rel="noopener ugc nofollow" target="_blank">垃圾收集器API </a>启动，并且使用<a class="ae ky" href="https://github.com/HolgerFrank/node-memwatch" rel="noopener ugc nofollow" target="_blank"> Airbnb Memwatch </a>库来跟踪堆使用情况。</p><p id="045a" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">这些库甚至与该算法的强制性变异“传统”版本进行了比较。</p><p id="456e" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">进行了两种不同的测试。一个递归，一个基于承诺。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c2df" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">递归记忆测验</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基于递归的内存测试应用</p></figure><p id="47db" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">给出了两个图表，一个带有命令式版本，另一个没有。这是因为命令式版本的结果很糟糕，混淆了其他库的比较。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">递归算法(越低越好)</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">递归算法(没有命令版本，低更好)</p></figure><p id="af94" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">命令式版本无法在递归迭代之间卸载内存。除去命令，我们看到@most/core是更好的。</p><p id="dc19" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">RxJS和XStream稍微贵一点。XStream显示出增长趋势，这表明需要更多的调查。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="cee8" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">基于承诺的记忆测验</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基于承诺的记忆测试应用</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基于承诺(越低越好)</p></figure><p id="75a0" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">使用承诺，命令通过优化内存使用来报复。@most/core仍然是三个流库中最好的，但偏差更多，XStream更贵，但发热峰值更线性。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5ed8" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="656b" class="pw-post-body-paragraph mk ml it mm b mn nl ju mp mq nm jx ms mt nn mv mw mx no mz na nb np nd ne mi im bi translated">在Node.js上测试了三个主要的功能反应式编程流JavaScript库的速度和内存使用情况。</p><p id="19f8" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">这三个库在速度和内存使用效率方面都非常出色。</p><p id="2d9f" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">@most/core已被确定为速度最好且内存使用效率最高的。此外，显式时间表示和始终异步启动有助于防止故障，并具有易于理解和可预测的数据流。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c93e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">引文</strong></h1><p id="ac01" class="pw-post-body-paragraph mk ml it mm b mn nl ju mp mq nm jx ms mt nn mv mw mx no mz na nb np nd ne mi im bi translated">[1]维基百科—【https://en.wikipedia.org/wiki/Reactive_programming T2】</p><p id="3a91" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">[2]https://github.com/funkia/hareactive的行为— <a class="ae ky" href="https://github.com/funkia/hareactive" rel="noopener ugc nofollow" target="_blank"/></p><p id="9476" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">[3] XStream信号—<a class="ae ky" href="https://github.com/cyclejs/cyclejs/issues/581" rel="noopener ugc nofollow" target="_blank">https://github.com/cyclejs/cyclejs/issues/581</a></p><p id="6c4b" class="pw-post-body-paragraph mk ml it mm b mn nf ju mp mq ng jx ms mt nh mv mw mx ni mz na nb nj nd ne mi im bi translated">[4]冷热可观测量—<a class="ae ky" href="http://davesexton.com/blog/post/Hot-and-Cold-Observables.aspx" rel="noopener ugc nofollow" target="_blank">http://davesexton . com/blog/post/Hot-and-Cold-observables . aspx</a></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a615" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">资源链接</h1><ul class=""><li id="5b5c" class="nv nw it mm b mn nl mq nm mt oq mx or nb os mi oa ob oc od bi translated"><a class="ae ky" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a></li><li id="0fed" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated"><a class="ae ky" href="https://github.com/staltz/xstream" rel="noopener ugc nofollow" target="_blank"> XStream </a></li><li id="e755" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated"><a class="ae ky" href="https://mostcore.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">最核心</a></li><li id="e7c6" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated"><a class="ae ky" href="https://github.com/FbN/reactive-benchmark" rel="noopener ugc nofollow" target="_blank">基准的源代码</a></li><li id="888d" class="nv nw it mm b mn oe mq of mt og mx oh nb oi mi oa ob oc od bi translated"><a class="ae ky" href="https://drive.google.com/drive/folders/12aDWclrQXGn2F3XlVFGqOemxqzHEJ4pe?usp=sharing" rel="noopener ugc nofollow" target="_blank">基准测试的结果数据</a></li></ul></div></div>    
</body>
</html>