<html>
<head>
<title>How I Explained IoC and DI to Our Senior Software Engineer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何向我们的高级软件工程师解释IoC和DI</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-i-explained-ioc-and-di-to-our-senior-software-engineer-1561d200b9a5?source=collection_archive---------0-----------------------#2022-08-17">https://betterprogramming.pub/how-i-explained-ioc-and-di-to-our-senior-software-engineer-1561d200b9a5?source=collection_archive---------0-----------------------#2022-08-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6900" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">控制反转和依赖注入是你经常听到但可能从未完全理解的两个术语？下面是假人教程！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9404bc1a6d96312f0d643b93423cea67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x4hbmhfFrBjM5zNlkFjhRA.jpeg"/></div></div></figure><p id="d3f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">控制反转和依赖注入是现代软件开发中经常听到的两个热门词汇。至少在我开始职业生涯的时候是这样。这就是为什么我花了相当多的时间来研究这个话题。我很惊讶我们的高级软件工程师没有…</p><p id="597a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我不得不在审查我的一些代码时向他解释。我仍然记得他的反应:</p><blockquote class="ln lo lp"><p id="74eb" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">就这样？这么容易吗？多年来，我一直对这种东西感到困惑，而你只是在一个简短的电话中向我解释了它？</p></blockquote><p id="cae7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果连我过去几年的良师益友、我的重要同事都不明白这个概念，我想可能有必要写下另一个解释:</p><h2 id="f027" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated"><em class="mn">反转控制</em>和<em class="mn">依赖注入</em>为<em class="mn">假人</em>！</h2><p id="623f" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">假设你想写一段代码来记录你在电脑前花了多少时间。您可能会想到一个简单的API，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a7f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我的同事在几年前实现了这个接口，它看起来应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4a15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简单明了。这个类唯一需要做的事情是一个<code class="fe mv mw mx my b">Stopwatch</code>实例。</p><blockquote class="ln lo lp"><p id="b703" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">该类需要一个<code class="fe mv mw mx my b">Stopwatch</code>的实例。</p><p id="af4e" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">这个类依赖于一个<code class="fe mv mw mx my b">Stopwatch</code>。</p><p id="0be4" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated"><code class="fe mv mw mx my b">Stopwatch</code>是<code class="fe mv mw mx my b">ComputerTimeTracker</code>类的一个依赖项。</p></blockquote><p id="98d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到目前为止，一切顺利。现在让我们对代码做一点修改:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3fe2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">唯一改变的是构造函数。</p><p id="f4e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不是<em class="lq">在构造函数中创建</em>的实例，而是<em class="lq">将</em>注入到构造函数中。</p><blockquote class="ln lo lp"><p id="76b9" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">我们<em class="iq">将<code class="fe mv mw mx my b">Stopwatch</code>注入</em>到构造函数中。</p><p id="beb2" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">我们<em class="iq">将</em>的<em class="iq">依赖</em>的<code class="fe mv mw mx my b">Stopwatch</code>注入到构造函数中。</p><p id="e970" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">我们刚刚做了一个依赖注入。</p></blockquote><p id="d838" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我只想说清楚:这就是全部！依赖注入意味着向需要依赖的人提供依赖，而不是让他们自己创建依赖。</p><p id="c2b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">无论是通过类构造函数、通过属性还是通过setter-method注入依赖项，都没有关系。你所做的只是注入一个依赖。</p><p id="c999" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">再次引用我同事的话:</p><blockquote class="ln lo lp"><p id="d9d4" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">我想我们必须讨论一下。现在我需要在创建一个<code class="fe mv mw mx my b">ComputerTimeTracker</code>实例之前创建一个<code class="fe mv mw mx my b">Stopwatch</code>实例。太糟糕了。那不是代码味吗？<em class="iq">面向对象编程</em>总是夸<em class="iq">信息隐藏</em>，现在却不得不了解一个<code class="fe mv mw mx my b">Stopwatch</code>？当我在构造函数中创建实例时，我只需要创建我的<code class="fe mv mw mx my b">ComputerTimeTracker</code>，它会为我处理剩下的事情。我不想知道实现细节，我只想用类。综上所述:<code class="fe mv mw mx my b">Stopwatch</code>应该由<code class="fe mv mw mx my b">ComputerTimeTracker</code>控制。</p></blockquote><p id="f524" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意他已经使用了<em class="lq">控制</em>这个词。我会把这个想法想得更远一点:</p><p id="616f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我同事的方法中，我们有明确的<em class="lq">控制顺序:</em></p><blockquote class="ln lo lp"><p id="f78d" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">类<code class="fe mv mw mx my b">ComputerTimeTracker</code>正在控制<code class="fe mv mw mx my b">Stopwatch</code>。</p><p id="a5dd" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">控制<code class="fe mv mw mx my b">Stopwatch</code>是<code class="fe mv mw mx my b">ComputerTimeTracker</code>的责任。</p></blockquote><p id="b2b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在请注意我们注入<code class="fe mv mw mx my b">Stopwatch</code>的方法发生了什么变化:</p><blockquote class="ln lo lp"><p id="68d6" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">我们，<code class="fe mv mw mx my b">ComputerTimeTracker</code>的用户，在控制<code class="fe mv mw mx my b">Stopwatch</code>。</p><p id="cbbe" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">控制<code class="fe mv mw mx my b">Stopwatch</code>是用户的责任。</p></blockquote><p id="57e5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可能已经注意到了。通过注入依赖性，我们颠倒了控制的顺序。我们将控制<code class="fe mv mw mx my b">Stopwatch</code>的责任从类转移到了类的用户身上。这就是控制的倒置。再说一遍:真的就这些了！</p><p id="19bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">既然行话已经不再神秘，我们可以谈谈为什么我们可能更喜欢依赖注入的方法。让我们进一步增强我们的示例代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d7f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我所做的改变只是将类依赖关系<code class="fe mv mw mx my b">Stopwatch</code>换成了接口依赖关系<code class="fe mv mw mx my b">IStopwatch</code>。这样，类<code class="fe mv mw mx my b">ComputerTimeTracker</code>就不依赖于。NET框架，但是<em class="lq">松散地耦合</em>到任何实现接口<code class="fe mv mw mx my b">IStopwatch</code>的实例。现在对我们最大的好处是:</p><h1 id="5ebb" class="mz lv iq bd lw na nb nc lz nd ne nf mc jw ng jx mf jz nh ka mi kc ni kd ml nj bi translated">单元测试！</h1><p id="c685" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">我们通过一个接口注入到一个类中的所有依赖关系都可以被<em class="lq">模仿</em>。那是超级方便的。考虑以下使用案例:</p><ul class=""><li id="af71" class="nk nl iq kt b ku kv kx ky la nm le nn li no lm np nq nr ns bi translated">你开始追踪</li><li id="2caa" class="nk nl iq kt b ku nt kx nu la nv le nw li nx lm np nq nr ns bi translated">你在电脑前度过42小时</li><li id="d60f" class="nk nl iq kt b ku nt kx nu la nv le nw li nx lm np nq nr ns bi translated">你停止追踪</li><li id="1d1c" class="nk nl iq kt b ku nt kx nu la nv le nw li nx lm np nq nr ns bi translated">你检查花费的时间</li></ul><p id="a0ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当在<code class="fe mv mw mx my b">ComputerTimeTracker</code>的构造函数中创建了<code class="fe mv mw mx my b">Stopwatch</code>实例时，为那个用例编写单元测试是困难的。你无法真正取代它。当你无法取代它时，你就无法控制<code class="fe mv mw mx my b">Stopwatch</code>。所以你得等42小时。有了依赖注入，你可以简单地注入一个模拟的<code class="fe mv mw mx my b">Stopwatch</code>到类中，只是为了测试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="66f7" class="mz lv iq bd lw na nb nc lz nd ne nf mc jw ng jx mf jz nh ka mi kc ni kd ml nj bi translated">结论</h1><p id="8349" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">依赖注入和控制反转是每个开发人员都应该知道的重要概念。他们有点炒作，经常被误解。但是如果你花一些时间去真正挖掘它，你会发现它们实际上是多么的简单。</p><p id="05e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为什么他们会被大肆宣传呢？因为它们使我能够为我的代码编写可读的单元测试。这已经为我卖出去了。</p><p id="4cd2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是这里还有更多我没有提到的好处:<em class="lq">依赖关系的动态替换</em>或者使用<em class="lq"> IoC容器。但是这些是另一篇文章的主题…</em></p><p id="7ce4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有什么概念是你不明白的吗？让我知道！:-)</p><p id="84a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>