<html>
<head>
<title>4 Lesser-Known Performance Tips to Improve User Experience in React Native Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">4个鲜为人知的性能技巧，用于改善React原生应用的用户体验</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-lesser-known-performance-tips-to-improve-user-experience-in-react-native-apps-6f2dc8c45623?source=collection_archive---------5-----------------------#2020-02-13">https://betterprogramming.pub/4-lesser-known-performance-tips-to-improve-user-experience-in-react-native-apps-6f2dc8c45623?source=collection_archive---------5-----------------------#2020-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cbd6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">除了优化渲染频率，你还可以做更多的事情</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b51303285321dc5c6481bdf0acc09ab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jgkh5czCQvmKVqDj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@emilep?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">émile Perron</a>拍摄。</p></figure><p id="c6fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一家开发每天有数万活跃用户的React原生应用的公司的CTO，我最关心的问题之一是确保该应用为所有用户提供出色的体验——无论他们的移动设备是好是坏。</p><p id="5190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能听说过React Native或React应用程序的性能直接取决于渲染的数量和频率。你可以<a class="ae ky" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank">在<a class="ae ky" href="https://reactjs.org/docs/optimizing-performance.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>上</a>读到它。在开发React或React Native应用程序时，避免不必要的渲染是您应该考虑的第一件事。你可以通过快速的谷歌搜索了解更多，所以我不打算讨论这个。</p><p id="60b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我会给你额外的性能提示，这将使你的应用程序的性能有很大的不同。从我的经验来看，总有四个有问题的组件。优化后，它们会让应用程序感觉更快，总体来说反应更灵敏。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8c98" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4个最有问题的组件</h1><p id="aee0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">1.导航:慢速动画</p><p id="f607" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.列表:占用大量内存</p><p id="b18d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.长时间运行的函数:阻塞JavaScript线程</p><p id="d63f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.持久化数据:降低整个应用程序的速度</p><p id="59ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们逐一检查这些组件，找出每个问题，并找到解决方案。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4895" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">航行</h1><p id="637c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你的用户会注意到有故障或缓慢的导航体验，这足以让应用程序失去他们的注意力。你的目标应该是屏幕之间平滑的动画过渡，但情况并非总是如此。</p><p id="e437" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在有很多组件的屏幕上，你可能会发现在用户按下按钮和转换到新屏幕之间有很大的延迟。</p><p id="cd0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这取决于您用于导航的库。例如，使用<a class="ae ky" href="https://reactnavigation.org/" rel="noopener ugc nofollow" target="_blank"> React Navigation </a>，屏幕被渲染到屏幕外，动画仅在之后出现。所以你应该做的是快速的第一次渲染，并且只在动画结束后渲染组件的大列表。</p><p id="44ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在有很多商业逻辑的屏幕上，你可能会发现动画有点问题。</p><p id="987f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也取决于您用于导航的库，但是如果它使用JS加速的动画，业务逻辑可能会导致它丢弃帧，因为它们都运行在同一个JavaScript线程上。所以你要做的是，在动画完成之后，才整理好你的业务逻辑。</p><p id="b897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，你想要的是知道动画什么时候完成。有三个选项可用于实现这一点:</p><ol class=""><li id="7745" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe ni nj nk nl b">InteractionManager</code>:提供一个在所有动画完成后触发的回调。</li><li id="cebb" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated"><code class="fe ni nj nk nl b">didFocus</code>:当屏幕聚焦时提供回调。如果有过渡，则过渡完成。</li><li id="9a3e" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated"><code class="fe ni nj nk nl b">setTimeout</code>:确保你让动画得到一些帧。这更像是一种黑客行为，但有时您可能会发现<code class="fe ni nj nk nl b">InteractionManager</code>或<code class="fe ni nj nk nl b">didFocus</code>方法的等待时间太长了。<code class="fe ni nj nk nl b">setTimout</code>让你更好地控制时间。</li></ol><p id="7049" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来看看如何实现其中的每一项:</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="eedf" class="nv md it nl b gy nw nx l ny nz">/* </span><span id="d5d8" class="nv md it nl b gy oa nx l ny nz"> Option 1: Using <strong class="nl iu"><em class="ob">InteractionManager</em></strong><em class="ob"> </em></span><span id="eb0d" class="nv md it nl b gy oa nx l ny nz">*/<br/>componentDidMount() {<br/> // You can do purely async functions here<br/> fetchData()<br/> <br/><br/> <strong class="nl iu">InteractionManager.runAfterInteractions</strong>(() =&gt; {<br/>  // Navigation is done animating</span><span id="f822" class="nv md it nl b gy oa nx l ny nz">  // Synchronous function<br/>  const data = processData()</span><span id="607c" class="nv md it nl b gy oa nx l ny nz">  // Render the screen<br/>  this.setState({<br/>   loading: false,<br/>   data<br/>  })</span><span id="c412" class="nv md it nl b gy oa nx l ny nz"> })<br/>}<br/></span><span id="dcb3" class="nv md it nl b gy oa nx l ny nz">/* </span><span id="3191" class="nv md it nl b gy oa nx l ny nz"><em class="ob"> </em>Option 2: Using <strong class="nl iu"><em class="ob">didFocus</em></strong><em class="ob"> </em></span><span id="6b6d" class="nv md it nl b gy oa nx l ny nz">*/<br/>componentDidMount() {<br/> // You can do purely async functions here<br/> fetchData()<br/> <br/> <strong class="nl iu">navigation.addListener('didFocus'</strong>, () =&gt;{<br/>  // Navigation is done animating</span><span id="cbb6" class="nv md it nl b gy oa nx l ny nz">  // Synchronous function<br/>  const data = processData()</span><span id="92eb" class="nv md it nl b gy oa nx l ny nz">  // Render the screen<br/>  this.setState({<br/>   loading: false,<br/>   data<br/>  })</span><span id="003f" class="nv md it nl b gy oa nx l ny nz"> })<br/>}</span><span id="3151" class="nv md it nl b gy oa nx l ny nz">/* </span><span id="ceb8" class="nv md it nl b gy oa nx l ny nz"> Option 3: Using <strong class="nl iu"><em class="ob">setTimeout</em></strong><em class="ob"> </em></span><span id="1dd5" class="nv md it nl b gy oa nx l ny nz">*/<br/>componentDidMount() {<br/> // 1. You can do purely async functions here<br/> fetchData()</span><span id="e106" class="nv md it nl b gy oa nx l ny nz"> <strong class="nl iu">setTimeout</strong>(() =&gt; {<br/>  // Navigation got some frames for animating</span><span id="4f9e" class="nv md it nl b gy oa nx l ny nz">  // Synchronous function<br/>  const data = processData()</span><span id="f510" class="nv md it nl b gy oa nx l ny nz">  // Render the screen<br/>  this.setState({<br/>   loading: false,<br/>   data<br/>  })</span><span id="1171" class="nv md it nl b gy oa nx l ny nz"> }, 1)<br/>}</span><span id="a958" class="nv md it nl b gy oa nx l ny nz">/* Render */<br/>render() {<br/>  /* When loading is true, render just a very simple loading view */<br/>  /* When loading is false, render the components */<br/>}</span></pre><h2 id="ff2e" class="nv md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">额外小费</h2><p id="e8ea" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因为导航将屏幕保留在堆栈上，而不是卸载它们，所以应用程序内存可能会开始增加很多。您可以使用<code class="fe ni nj nk nl b">willBlur</code>(失去焦点)为那些隐藏的屏幕卸载或呈现更简单的组件(加载屏幕)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cef4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">列表</h1><p id="dcaa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">列表往往会占用大量内存，并可能导致JS和UI帧丢失。如果你的应用程序使用导航或者滑动器，你可能会有一些列表没有显示给用户，但是仍然会占用大量的内存资源，因为它们被安装在了某个地方。此外，即使您的列表当前正在显示给用户，他们也可能不会向下滚动列表，所以列表中的所有项目是否都已挂载并不重要。</p><p id="3936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，您想要的是尽可能呈现最少的列表项，同时确保当用户看到列表时，至少显示前几项。</p><p id="40ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果列表当前显示在活动屏幕上，则只能传递列表数组的前三项。</p><p id="6ea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果列表当前正在显示，您可以控制最初呈现的项目数量。</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="d4af" class="nv md it nl b gy nw nx l ny nz">/* If your screen loses focus or is not visible, you can manipulate the data being rendered */</span><span id="ed15" class="nv md it nl b gy oa nx l ny nz"><strong class="nl iu">const data = this.isVisible ?<br/> this.state.bigList<br/> : this.state.bigList.slice(0, 3)</strong></span><span id="966a" class="nv md it nl b gy oa nx l ny nz"><br/>&lt;FlatList<br/> data={data}</span><span id="24a7" class="nv md it nl b gy oa nx l ny nz"> /* If your list is always visible, you can try adding */<br/> <strong class="nl iu">initialNumToRender = {5}</strong></span><span id="5319" class="nv md it nl b gy oa nx l ny nz">...<br/>/&gt;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d1aa" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">长期运行的功能</h1><p id="fb1e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">React Native的一个缺点是每个JavaScript代码都运行在单个JavaScript线程上。如果JavaScript线程被阻塞，您可能会注意到整个应用程序通常很慢或者完全没有响应。</p><p id="9d2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以首先，你根本不应该在React Native中有任何长时间运行的同步函数。但有时这是无法避免的。在这种情况下，您可以使用React Native workers，这需要一些时间来实现。您还可以将长时间运行的函数分成一批一批的小步骤。这些批处理应该以几毫秒的间隔依次运行。</p><p id="2a03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这几毫秒让JavaScript线程有一些帧来执行其他动作。这将使长时间运行的功能稍微慢一点，但你的应用程序将再次完全响应。最棒的是，这可以通过使用<code class="fe ni nj nk nl b">await</code>非常容易地实现。</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="465b" class="nv md it nl b gy nw nx l ny nz">const sleep = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms))</span><span id="47b0" class="nv md it nl b gy oa nx l ny nz">// How many steps your heavy function should run before it goes to sleep<br/>const sleepFrequency = 200</span><span id="9a1b" class="nv md it nl b gy oa nx l ny nz">// How much time in ms your heavy function should sleep<br/>const sleepTime = 10</span><span id="c239" class="nv md it nl b gy oa nx l ny nz">longRunningFunction()<br/> for (let i = 0; i &lt; enormousNumberOfSteps; i++) {</span><span id="f3c0" class="nv md it nl b gy oa nx l ny nz">  stepProcessing()</span><span id="543a" class="nv md it nl b gy oa nx l ny nz">  /* Add this on your intensive functions */<strong class="nl iu">  <br/>  if (i % sleepFrequency === 0 &amp;&amp; i &gt; 0){<br/>   await sleep(sleepTime)<br/>  }</strong></span><span id="d37d" class="nv md it nl b gy oa nx l ny nz"> }<br/>}</span></pre><h2 id="2a4f" class="nv md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">额外小费</h2><p id="915d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果用户离开屏幕或使用不同的参数再次调用长时间运行的函数，您应该在运行过程中通过检查不同的参数并在函数结束前退出函数来取消上一个函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e613" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">持久数据</h1><p id="6acd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你需要持久化数据，你可能会发现频繁地保存大量数据会使你的应用程序变慢。例如，我处理需要保存到用户设备的实时数据。所以我用的是<code class="fe ni nj nk nl b">debounce</code>。反跳延迟调用保存功能，直到从上次调用它起已经过了X毫秒。它对需要保存的内容进行批处理，然后一次性保存所有内容。如果使用React Persist，这很容易做到:</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="8069" class="nv md it nl b gy nw nx l ny nz">const persistConfig = {<br/>    ...</span><span id="7569" class="nv md it nl b gy oa nx l ny nz">//Add debounce here<br/> <strong class="nl iu">debounce: 1000 </strong>//OR <!-- -->throttle if you are using redux-persist v5+</span><span id="03b8" class="nv md it nl b gy oa nx l ny nz">};</span><span id="598a" class="nv md it nl b gy oa nx l ny nz">const persistedReducer = persistReducer(persistConfig, rootReducer)</span></pre><h2 id="2b2e" class="nv md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated"><strong class="ak">奖励提示</strong></h2><p id="7939" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您也可以仅在特定时间点保存应用数据(例如，就在用户离开应用之前)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6774" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="52d4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我希望这有助于您改进您的应用程序！</p><p id="b780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在开发方面需要帮助或有任何问题，请随时发表评论或通过andre@andrepimenta.io联系我。</p></div></div>    
</body>
</html>