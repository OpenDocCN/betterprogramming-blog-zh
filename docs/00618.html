<html>
<head>
<title>Build a Stunning Breadcrumb Component in React with Plain CSS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中构建一个令人惊叹的Breadcrumb组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-stunning-breadcrumb-component-in-react-with-plain-css-414c68db293?source=collection_archive---------7-----------------------#2019-06-19">https://betterprogramming.pub/build-a-stunning-breadcrumb-component-in-react-with-plain-css-414c68db293?source=collection_archive---------7-----------------------#2019-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4b40" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">现在是让React做大事的时候了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/34c85e5304f03b97dbdcce95ea28c42c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VcCOkZFg9vU4J3GlmmRTIg.jpeg"/></div></div></figure><p id="4066" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你有没有在个人设备上浏览过一个网站，发现自己不知道自己在网站的哪个位置？别担心，你不是一个人。</p><p id="74e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你认为还有多少用户有过类似的经历？</p><p id="68c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是开发人员现在在他们的web应用程序中改善用户体验时考虑的一个常见场景。</p><p id="3c10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果你像我一样，你会发现<em class="lq">面包屑</em>在谈到界面时是一个非常尴尬的术语。如果你是第一次尝试，让我来帮你理清<em class="lq">面包屑</em>的概念。</p><p id="8718" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Dictionary.com给了我们两个<a class="ae lr" href="https://www.dictionary.com/browse/breadcrumb" rel="noopener ugc nofollow" target="_blank">定义</a>:</p><ol class=""><li id="6ba9" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp lx ly lz ma bi translated">干的或软的面包屑。</li><li id="9de4" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated"><em class="lq">网站或基于网络的应用程序的当前页面上的一系列文本链接，通常位于顶部，显示页面在内容层次结构或浏览历史中的位置，并提供方便的导航工具。</em></li></ol><p id="e7a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们是在谈论用美味的膳食纤维来源来保持健康，以帮助我们作为web开发人员长期保持高效吗？没有。你可能已经猜到了，我们正在讨论第二个定义。</p><p id="e9fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像Craigslist这样的网站在他们的应用程序中使用面包屑组件来描述用户的位置，并且以一些令人惊讶的方式改善了他们的用户体验。</p><p id="d39d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能已经开发了一个如下所示的导航栏:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/3ec5f730f85e9eb7214d789a40ceda6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wOC9Fge8IOkavtrH.JPG"/></div></div></figure><p id="ce8c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这并没有错，但是如果你想知道你还可以在这个非常尴尬的空白空间放置什么，面包屑组件实际上可以很好地完成这项工作！</p><p id="0515" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本教程结束时，您应该能够学习如何创建一个面包屑组件，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/ba7ae7487fea69b230e527aef95c4f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*j6qDahPD7DuHTJOS.gif"/></div></figure><p id="5b82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者这个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/89492624997a8b78dfc425fb460b8055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*tqJFsEeDOhjvC_Bo.gif"/></div></figure><p id="bfcb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">甚至是这个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/a2b52107b7b1a825fb0dc038711ab53e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*jz1ujDeabRcplDGE.gif"/></div></figure><p id="4cbb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">值得一提的是，您将创建一个breadcrumb <em class="lq">组件</em>，它将允许您在将 <em class="lq"> breadcrumb </em>插入到接口中的组件时附加一个<em class="lq">逻辑</em> <em class="lq">实现。然而，<em class="lq">实现面包屑</em>的逻辑</em> <em class="lq">稍微复杂一点。如果你想看如何实现这个逻辑的源代码，你可以在这里查看例子<a class="ae lr" href="https://github.com/icd2k3/react-router-breadcrumbs-hoc/blob/master/src/index.js" rel="noopener ugc nofollow" target="_blank"/>。</em></p><p id="3571" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们开始吧！</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="40cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本教程中，我们将使用create-react-app快速生成一个react项目。</p><p id="0c29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">(如果你想从github获得一份库的副本，点击<a class="ae lr" href="https://github.com/jsmanifest/breadcrumb" rel="noopener ugc nofollow" target="_blank">这里</a>)。</p><p id="1afc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">继续使用下面的命令创建一个项目。对于本教程，我将我们的项目称为<em class="lq"> breadcrumb </em>。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="1bc8" class="mu mv it mq b gy mw mx l my mz">npx create-react-app breadcrumb</span></pre><p id="3abf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完成后，进入目录:</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="f16c" class="mu mv it mq b gy mw mx l my mz">cd breadcrumb</span></pre><p id="aea4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在主条目<code class="fe na nb nc mq b">src/index.js</code>中，我们将对其进行一点清理，这样我们可以只关注组件:</p><blockquote class="nd ne nf"><p id="e51a" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/index.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7d74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在创建<code class="fe na nb nc mq b">src/App.js</code>:</p><blockquote class="nd ne nf"><p id="b5df" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/App.js </em></p></blockquote><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="ca4f" class="mu mv it mq b gy mw mx l my mz">import React from 'react'</span><span id="806d" class="mu mv it mq b gy nl mx l my mz">const App = () =&gt; &lt;div /&gt;</span><span id="0052" class="mu mv it mq b gy nl mx l my mz">export default App</span></pre><p id="298e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用<code class="fe na nb nc mq b">App.js</code>来呈现面包屑组件。我们还将使用它来定义一些示例路线，以便稍后可以看到实际操作中的面包屑。</p><p id="1d6e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将创建一个<code class="fe na nb nc mq b">src/pages</code>目录，并通过为每个路径创建文件来添加示例路径:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2cbe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将它们导入到我们的<code class="fe na nb nc mq b">App.js</code>组件中，并在一个<em class="lq">路由器</em>中呈现它们，这样我们的breadcrumb组件就可以对它们进行操作。您可以使用任何路由库，但是对于本教程，我将使用<a class="ae lr" href="https://reach.tech/router" rel="noopener ugc nofollow" target="_blank"> @reach/router </a>:</p><blockquote class="nd ne nf"><p id="1ae1" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/App.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="870e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是我的开始<em class="lq"> css样式</em>:</p><blockquote class="nd ne nf"><p id="2fe9" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/styles.css </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f750" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将创建<em class="lq"> Breadcrumb </em>组件，这样我们就可以呈现每个路径路径中的Breadcrumb项目:</p><blockquote class="nd ne nf"><p id="34fd" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/Breadcrumb.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="812c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在您可以从<code class="fe na nb nc mq b">App.js</code>导入它，并在它的render方法中渲染它。</p><p id="e1fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我还将一些路由定义为一个数组，这样我就可以在breadcrumb组件中呈现它们。(注意:在实际场景中，您将提供子路由，这些子路由会随着浏览器位置在层次结构中的下移而呈现——但是我们在这里仅使用顶级路由来展示breadcrumb界面的实际实现)</p><blockquote class="nd ne nf"><p id="eb41" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/App.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="daf7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您现在应该会看到类似这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c054465f94c94a84fea01eb1c797999c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/0*LRA4y3tntQ28MoYr.JPG"/></div></figure><p id="0c71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">开始像面包屑了！在目前的状态下，它在90年代可能已经足够了——但是我们必须不断想办法改进它。</p><p id="431a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以从在每个面包屑项目周围提供一个<em class="lq">包装器</em>开始。此外，当我们将这些项目呈现为一个列表时，我们可以将元素转换为一个<em class="lq">有序列表，</em>这样我们会更正式一些:</p><blockquote class="nd ne nf"><p id="d8df" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/Breadcrumb.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a313" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">而对于<code class="fe na nb nc mq b">BreadcrumbItem</code> <em class="lq"> </em>组件，我们可以在顶部这样定义:</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="37e1" class="mu mv it mq b gy mw mx l my mz">const BreadcrumbItem = ({ children, ...props }) =&gt; (<br/>  &lt;li className='breadcrumb-item' {...props}&gt;<br/>    {children}<br/>  &lt;/li&gt;<br/>)</span></pre><p id="2e68" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是它现在的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/1f1879b8fca8412adb7cccb6e26beda7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/0*oxp_bLAJvodAjPDh.JPG"/></div></figure><p id="6564" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们将一个<em class="lq">有序列表</em>和一个<em class="lq">列表项目</em>元素列表应用到了我们的breadcrumb组件，我们必须改变项目所面对的<em class="lq">方向</em>。我们还需要删除数字字符。</p><p id="5f40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以用<em class="lq">普通css </em>来完成这个任务:</p><blockquote class="nd ne nf"><p id="a1d3" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/styles.css </em></p></blockquote><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="27f7" class="mu mv it mq b gy mw mx l my mz">ol {<br/>  list-style: none;<br/>  display: flex;<br/>  align-items: center;<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/a69d4417b75c58677ff91790ee9f1050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/0*opZnAG-2dmZLThwd.JPG"/></div></figure><p id="9c53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在breadcrumb组件中，您可能已经注意到了一件奇怪的事情，那就是这一行:</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="b1d5" class="mu mv it mq b gy mw mx l my mz">let children = React.Children.toArray(props.children)</span></pre><p id="3015" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是有充分理由的。当我们将项目呈现为breadcrumb组件的直接子组件时，我们是这样做的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="8a28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React将直接在其下渲染的每个组件视为一个<em class="lq">数组，</em>，只要有多个组件。</p><p id="06f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们使用各种方法(例如<em class="lq"> slice </em>)操作这个组件“数组”时，react每次都需要一个<em class="lq">键</em>传递给它们。当我们使用<em class="lq">反应时。Children.toArray </em>为了包装我们的孩子，react <a class="ae lr" href="https://reactjs.org/docs/react-api.html#reactchildren" rel="noopener ugc nofollow" target="_blank">自动将所有的关键需求</a>分配和处理给原始的孩子，以供后续使用。<em class="lq">完美</em>！我们不必将不必要的丑陋代码应用到我们的组件代码中。谢谢你的反应！</p><p id="e795" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">面包屑通常使用一个<em class="lq">分隔符</em>来分隔它们的每一项，这样它们更容易使用和阅读。当你使用一个分隔符(最常见的是像<em class="lq">/</em>这样的斜线)时，用户将能够分辨出哪些部分是相互分离的。有时候——在某些屏幕上——你会发现你的单词出乎意料地彼此靠得太近，所以这有助于解决这些可见性问题。</p><p id="708e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来我们将继续添加一个<em class="lq">。将</em>减少到子项，以便我们可以应用逻辑将这些分隔符放置到位:</p><blockquote class="nd ne nf"><p id="57ba" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/Breadcrumb.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/b95ed8d20d3718f98187fc2d0bb3d836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/0*GdFJpNe951JU1bnp.JPG"/></div></figure><p id="2266" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">(注意:我们实现了一个条件检查，这样我们就不会不必要地在面包屑的末尾添加一个斜杠)</p><p id="d388" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从截图中我们可以清楚地看到，我们分离了每个面包屑项目。然而，回到我之前的评论，一些用户不能清楚地看到单词，因为单词在一些屏幕上变得非常近，现在分隔符又出现了同样的问题。</p><p id="0e35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们将为分隔符应用一个包装器，并将一个<em class="lq"> className </em> prop附加到<em class="lq"> li </em>元素上，这样我们就可以稍微控制一下间距:</p><blockquote class="nd ne nf"><p id="0ea7" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/Breadcrumb.js </em></p></blockquote><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="f0fe" class="mu mv it mq b gy mw mx l my mz">const BreadcrumbSeparator = ({ children, ...props }) =&gt; (<br/>  &lt;li className='breadcrumb-separator' {...props}&gt;<br/>    {children}<br/>  &lt;/li&gt;<br/>)</span></pre><blockquote class="nd ne nf"><p id="bcbe" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/styles.css </em></p></blockquote><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="2638" class="mu mv it mq b gy mw mx l my mz">.breadcrumb-separator {<br/>  color: #333;<br/>  margin: auto 6px;<br/>  user-select: none;<br/>}</span></pre><p id="aeac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们只需要用新的包装组件包装我们的分离器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/62ea9358270189984e98542a4df7bae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/0*mY3Ya7g1DqHaUVa2.JPG"/></div></figure><p id="ad24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完美！</p><p id="a37f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，有时候作为一名开发人员，我们可能想要切换使用哪种分隔符——比如一个<em class="lq">箭头</em>。我们可以通过允许调用者传入一个自定义分隔符作为属性来进行自定义:</p><blockquote class="nd ne nf"><p id="2b12" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/Breadcrumb.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><blockquote class="nd ne nf"><p id="d8c7" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/App.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/39a7d258b5f70a1e09611ca13225d280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/0*U_PHgRqIV-bcuUCo.JPG"/></div></figure><blockquote class="nd ne nf"><p id="2b1a" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/App.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/42c53c426cf3160c8fb9ee2fad17ecf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*_ipQ8vpuZFjl2_U6.gif"/></div></figure><p id="09dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">面包屑变得太长会发生什么？</p><p id="cbbe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在大规模应用程序中最常见的是，可能有大量的路由会使面包屑的长度超过它应有的长度。</p><p id="8939" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们想解决这个问题，一个已知的解决方案是使用<em class="lq">折叠器</em>。</p><p id="4144" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将创建一个collapser组件。</p><p id="9c33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先创建<code class="fe na nb nc mq b">src/BreadcrumbCollapser.js</code>。这将用于从界面中<em class="lq">折叠</em>项，以便breadcrumb组件可以隐藏它的一些项:</p><blockquote class="nd ne nf"><p id="4afb" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it">src/bread crumb collapser . js</em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><blockquote class="nd ne nf"><p id="6d12" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/styles.css </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6abb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们引入任何形式的“崩溃器”时，我们需要它知道<em class="lq">何时</em>或<em class="lq">何时不</em>崩溃。赋予用户控制该行为的能力是增强折叠器用户体验的一个好方法。</p><p id="0092" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将创建一个名为<code class="fe na nb nc mq b">useBreadcrumb.js</code>的自定义钩子，并设置一个名为<em class="lq">扩展</em>的<em class="lq">状态</em>。接口将需要这个信息，所以它是从自定义钩子返回的:</p><blockquote class="nd ne nf"><p id="6c0d" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/useBreadcrumb.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3c34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在一个单独的文件中创建一个定制的react钩子可能有些多余，但是我喜欢它给我的开发流程带来的额外的组织习惯！这完全是可选的，你可以直接在<em class="lq"> breadcrumb组件</em>中设置状态。</p><p id="274b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我从<code class="fe na nb nc mq b">Breadcrumb.js</code>文件中导入了定制钩子和breadcrumb collapser:</p><blockquote class="nd ne nf"><p id="3ca2" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/Breadcrumb.js </em></p></blockquote><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="9603" class="mu mv it mq b gy mw mx l my mz">import React from 'react'<br/>import useBreadcrumb from './useBreadcrumb'<br/>import BreadcrumbCollapser from './BreadcrumbCollapser'</span></pre><p id="c8db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用自定义挂钩:</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="db6d" class="mu mv it mq b gy mw mx l my mz">const Breadcrumb = ({ separator, ...props }) =&gt; {<br/>  let children = React.Children.toArray(props.children)</span><span id="19d4" class="mu mv it mq b gy nl mx l my mz">  const { expanded, open } = useBreadcrumb()</span></pre><p id="579f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">提供一个自定义属性可能会有所帮助，调用者可以传入该属性来控制折叠或显示的项目数量，因此我们允许调用者传入一个自定义的<em class="lq">折叠</em>属性，我们可以用它来应用到breadcrumb collapser:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4999" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将确保呼叫者有能力控制<em class="lq">要看什么，如果需要的话，对其进行裁剪，使其与他们的UI更加兼容。</em></p><p id="e0f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，将折叠器应用于渲染子对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="36bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是我们迄今为止的完整面包屑实现:</p><blockquote class="nd ne nf"><p id="54f1" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/Breadcrumb.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/6b430f762b773c1877953b06e880d5a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*guLaYY7xFkxlat7P.gif"/></div></figure><p id="2394" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些链接需要一点点的定制，因为它们是非常基本和古老的。让我们改变这一点:</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="fa93" class="mu mv it mq b gy mw mx l my mz">a {<br/>  text-decoration: none;<br/>  font-weight: 400;<br/>  color: #424548;<br/>}</span><span id="55b0" class="mu mv it mq b gy nl mx l my mz">a:hover {<br/>  color: #1da2b3;<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/e75224251391276dfcc100f99b3fcfa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*sE7avM75n7oegNrV.gif"/></div></figure><p id="b4a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你是一个功能型的人，而我们的组件对你来说不是很有吸引力，那么把它重构得更有吸引力一点是很好的:</p><blockquote class="nd ne nf"><p id="2e58" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/Breadcrumb.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/dc6b6d7fac5c4bfb2ba7be038cb8952f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*VnJ9W1I7Oqp_YEwo.gif"/></div></figure><p id="6ca4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里要记住的是，如果我们<em class="lq">没有</em>使用<code class="fe na nb nc mq b">React.Children.toArray</code>来包装我们的孩子，我们将会在控制台中得到键<em class="lq"> </em>错误，用于呈现孩子列表，而没有提供一个键给他们。</p><p id="3f6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想知道如何在两者之间渲染图标？有多种方法可以实现这一点，但其中一种方法可能是这样的:</p><blockquote class="nd ne nf"><p id="e429" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><em class="it"> src/App.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/3c494361af036a457889ef53f58878f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*omxAJXm4Vhmh_-mz.gif"/></div></figure><p id="3d46" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我前面提到过，在现实世界场景中，我们会在breadcrumb组件中呈现子路由——通过层次结构。在本教程中，我们使用了顶级路由，这并不理想，但我想展示接口是如何实现的。使用本教程中的策略可以实现更真实的界面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/c815c5207e195b516cd28ff4798d9f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*aJweyWuEl1w67Wbd.gif"/></div></figure><p id="d959" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">漂亮！</p><h1 id="fcd2" class="ns mv it bd nt nu nv nw nx ny nz oa ob jz oc ka od kc oe kd of kf og kg oh oi bi translated">结论</h1><p id="cb9a" class="pw-post-body-paragraph ku kv it kw b kx oj ju kz la ok jx lc ld ol lf lg lh om lj lk ll on ln lo lp im bi translated">本教程到此结束！如果你一直在看我以前的帖子，你可能已经意识到我在结论中没有说太多——因为一切都已经在上面说过了！</p><p id="a3ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下次再见，期待更多高质量的帖子！</p></div></div>    
</body>
</html>