<html>
<head>
<title>Understand GraphQL Subscriptions in Java With a Tic-Tac-Toe Game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过井字游戏理解Java中的GraphQL订阅</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-graphql-subscriptions-in-java-with-a-tic-tac-toe-game-832ba2729e6d?source=collection_archive---------4-----------------------#2021-04-23">https://betterprogramming.pub/understand-graphql-subscriptions-in-java-with-a-tic-tac-toe-game-832ba2729e6d?source=collection_archive---------4-----------------------#2021-04-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1159" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Java和Spring Boot实现GraphQL订阅的分步指南，并附有一个工作示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/187729ae91d79b171a1a24317ca4bd12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7yx0IthAYxUhuuyL"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔恩·泰森在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="11bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">订阅肯定是更有趣的特性之一，因为它们颠覆了传统的客户端-服务器通信流程:不再是客户端请求一些数据，而是服务器可以随时向客户端发送数据，只要数据可用。人们很容易被这样一个世界迷住，在这个世界里，你不必分分钟检查烤箱里的蛋糕是否做好了，而是烤箱本身告诉你蛋糕已经做好了！</p><p id="838b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">订阅很棒，但是实现起来也很复杂，需要复杂的架构，而且通常很难找到详尽的文档或工作示例。</p><p id="e84e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，您将学习如何用Java实现GraphQL订阅，使用<a class="ae ky" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>和<a class="ae ky" href="https://www.graphql-java-kickstart.com/" rel="noopener ugc nofollow" target="_blank"> Kickstart库</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="562f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">开始吧！</h1><p id="749e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将通过实现一个简单的井字游戏来学习如何使用订阅。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ad79" class="ne md it na b gy nf ng l nh ni">❌ │ ⭕ │ <br/>──────────────<br/>❌ │ ❌ │ <br/>──────────────<br/>⭕ │ ⭕ │ ❌</span></pre><p id="4404" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在游戏中，我们希望使用订阅有两个目的:</p><ul class=""><li id="b64b" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">通知用户另一个玩家加入了游戏并且比赛可以开始</li><li id="e704" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">通知玩家对手已经走了一步</li></ul><p id="1771" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图为游戏流程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/5d5a8b432e09af01ec63d7d36f9526e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5JmDmW7ytLXbEc7zRLmMBw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">游戏流程(突变用蓝色表示，订阅用橙色表示)(图片来源:作者)</p></figure><p id="e894" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在GitHub上找到应用程序的<a class="ae ky" href="https://gist.github.com/pixel13/f57695b66823913d46745ca220d142f5" rel="noopener ugc nofollow" target="_blank">完整GraphQL模式；总之，游戏流程很简单:</a></p><ul class=""><li id="1b02" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">第一个玩家通过调用<code class="fe ny nz oa na b">startGame</code>突变开始游戏，然后等待对手。</li><li id="ed31" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">使用<code class="fe ny nz oa na b">opponentArrived</code>订阅，当另一个用户进来时，可以通知第一个玩家。</li><li id="6981" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">当另一个玩家调用<code class="fe ny nz oa na b">startGame</code>变异时，服务器通过<code class="fe ny nz oa na b">opponentArrived</code>订阅发送一些数据:比赛可以开始了！</li><li id="87ef" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">每个玩家依次下一步棋:在等待的时候，另一个玩家可以使用<code class="fe ny nz oa na b">opponentMove</code>订阅来获得对手下一步棋的通知；这个循环一直持续到游戏结束。</li></ul><p id="0136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与查询和变异相比，订阅需要我们注意一些额外的方面:</p><ul class=""><li id="9ded" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">不同且更复杂的<strong class="lb iu">通信协议</strong></li><li id="272b" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">从服务器到客户端的<strong class="lb iu">连续数据流</strong></li><li id="331b" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">专用的<strong class="lb iu">认证系统</strong></li><li id="a412" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu">外部持久性和通信层</strong>维护订阅的状态</li></ul><p id="1a92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，在我们的示例应用程序中，我们将使用内存解决方案，因此我们将忽略后一点。无论如何，请记住，在真实的生产环境中，您可能需要一个外部代理或消息传递系统(例如，<a class="ae ky" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Kafka </a>或<a class="ae ky" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ad1e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">WebSocket处理</h1><p id="e0e3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们更深入地了解一下通信协议:订阅在客户机和服务器之间打开了一个持久通道。在大多数GraphQL实现中，这个通道是使用WebSocket协议建立的。对于那些不熟悉这项技术的人来说，它是一种在双方之间创建通道的协议，可用于双向通信。为了建立初始连接，该过程从传统的HTTP请求/响应(一个<em class="ob">握手</em>)开始，然后通过WebSocket协议继续通信。</p><p id="42c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL规范没有规定客户机和服务器之间必须交换的消息的细节；反正知名公司<a class="ae ky" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> Apollo GraphQL </a>自己写的规范，已经成为事实上的标准。它要求通过WebSocket交换的消息使用特定的格式，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/92d9ee8fef82346bda553b10d63ba9fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FBs5_SGnYnZqhQeiBJPnXQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">典型GraphQL订阅中的WebSocket消息交换(图片来源:作者)</p></figure><p id="c1ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在无聊的部分结束了，我们最后来看看代码。</p><p id="254b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，Kickstart库负责与WebSocket通信协议相关的所有方面，并且它还实现了Apollo GraphQL规范。我们只需要定义一个实现<code class="fe ny nz oa na b">GraphQLSubscriptionResolver</code>接口的Spring bean。</p><p id="70ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据GraphQL规范，订阅必须实现<a class="ae ky" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" rel="noopener ugc nofollow" target="_blank">发布-订阅模式</a>，因此Kickstart期望resolver方法从<a class="ae ky" href="https://www.reactive-streams.org/" rel="noopener ugc nofollow" target="_blank">反应流</a>返回<code class="fe ny nz oa na b">Publisher</code>接口的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">井字游戏服务器的订阅服务器框架</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="74c1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用数据流</h1><p id="fffe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了让我们的订阅工作，我们必须知道如何处理一个反应性的流，以及如何馈送它。</p><p id="6bef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几个很好的Reactive Streams规范的Java实现:如果您正在使用Spring，我建议您尝试一下<a class="ae ky" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank"> Project Reactor </a>，因为它完全集成了这个框架。让我们看看如何在我们的应用程序中使用它。</p><p id="0296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的基本实现中，数据流将完全保存在应用程序内部的内存中，因此我们只需要声明几个Spring beans:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">定义反应流两端的beans</p></figure><p id="292a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会深入到Project Reactor的细节中，但是如果你不熟悉反应式编程，你可以把反应式流想象成一个数据流动的管道。</p><p id="822d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面定义的两个beans代表管道的两端:</p><ul class=""><li id="6b39" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">接收器是数据进入的地方</li><li id="15b5" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu">通量</strong>是数据出来的地方</li></ul><p id="97f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的应用程序中定义的<code class="fe ny nz oa na b">Game</code>对象表示将流经流的数据类型。</p><p id="5072" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几个客户端(订阅者)可以连接到反应流(使用GraphQL订阅)并接收流入其中的数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/fd85f1c0e9656590a8eb0a23c0e589c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DLPO5QV-QXs-cCzDrPMOaQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用管道表示的反应流(图片来源:作者)</p></figure><p id="dc91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经在应用程序中定义了两个beans，我们可以在解析器中自动连接它们，并使用它们将数据放入或获取到流中。</p><p id="a2fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何为应用程序的两个订阅提供流:</p><ul class=""><li id="0d1b" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">为了实现<code class="fe ny nz oa na b">opponentArrived</code>订阅，我们需要在第二个玩家调用<code class="fe ny nz oa na b">startGame</code>突变时将数据放入流中。</li><li id="71fe" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">为了实现<code class="fe ny nz oa na b">opponentMove</code>订阅，我们必须在每次玩家移动时，也就是每次调用<code class="fe ny nz oa na b">move</code>突变时，将数据放入接收器。</li></ul><p id="abb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们只需要在变异解析器中自动连接接收bean，并调用<code class="fe ny nz oa na b">tryEmitNext()</code>方法将数据放入流中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">变异解析器使用gameSink将数据放入反应流</p></figure><p id="d52d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以在根订阅解析器中自动连接flux bean，并将其返回给客户端。</p><p id="85cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于两个订阅共享相同的反应流，我们必须区分应该发送给<code class="fe ny nz oa na b">opponentArrived</code>发布者的数据和应该发送给<code class="fe ny nz oa na b">opponentMove</code>发布者的数据。为此，我们可以使用<code class="fe ny nz oa na b">Game</code>对象的<code class="fe ny nz oa na b">isStarted()</code>方法:如果游戏还没有开始，我们必须向<code class="fe ny nz oa na b">opponentArrived</code>发送数据；否则，我们必须向<code class="fe ny nz oa na b">opponentMove</code>发送数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">订阅解析器返回流量</p></figure><p id="adb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，在<code class="fe ny nz oa na b">opponentArrived()</code>方法中，流经flux的数据也被映射为只返回第二个玩家的名字(根据GraphQL模式)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="616f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">认证订阅</h1><p id="ac03" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们必须处理最后一个问题:我们的应用程序中有一个共享的反应流，但是可能会有几个用户同时玩这个游戏。我们只想给玩家发送他们自己比赛的信息。如何才能实现？</p><p id="90e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要为我们的订阅建立一个认证系统，这样我们就可以在通过特定用户建立的WebSocket通道发送数据之前，过滤掉属于其他玩家的数据。</p><p id="24e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用Spring安全支持来管理订阅解析器中的认证，但是我们需要一个专用系统来认证WebSocket连接。</p><p id="3d04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，Kickstart库帮助了我们，它允许我们截取订阅连接期间发生的主要事件。我们所要做的就是实现<code class="fe ny nz oa na b">ApolloSubscriptionConnectionListener</code>接口和:</p><ul class=""><li id="4c0f" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">覆盖<code class="fe ny nz oa na b">onConnect()</code>方法来拦截<code class="fe ny nz oa na b">GQL_CONNECTION_INIT</code>消息</li><li id="e4e1" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">覆盖<code class="fe ny nz oa na b">onStart()</code>方法来拦截<code class="fe ny nz oa na b">GQL_START</code>消息</li></ul><p id="a588" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理订阅认证最常见的方式是使用与<code class="fe ny nz oa na b">GQL_CONNECTION_INIT</code>消息一起传输的有效负载。</p><p id="60f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，只有当客户端同时发送<code class="fe ny nz oa na b">GQL_CONNECTION_INIT</code>和<code class="fe ny nz oa na b">GQL_START</code>消息，以便在服务器端由同一个线程处理时，这个认证系统才能工作。</p><p id="b24e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，如果这两条消息是分开发送的，它们可能由两个不同的线程提供服务。在这种情况下，认证将失败，除非在服务器接收到<code class="fe ny nz oa na b">GQL_START</code>消息时也进行了处理。</p><p id="4381" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的代码中，我们决定处理这两种情况下的身份验证，以确保服务器将与大多数客户端一起工作。在<code class="fe ny nz oa na b">SubscriptionConnectionListener</code>中，我们将实现<code class="fe ny nz oa na b">onConnect()</code>和<code class="fe ny nz oa na b">onStart()</code>两种方法:在第一种方法中，我们将使用有效载荷处理认证，在第二种方法中，我们将使用原始握手请求的授权头:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">处理身份验证的ApolloSubscriptionConnectionListener的实现</p></figure><p id="239a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，连接已经过身份验证，我们可以使用订阅解析器中的当前用户身份来过滤掉不应发送给订阅用户的所有消息，例如，仅当当前用户在特定游戏中移动时才发送数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">与身份验证系统集成的订阅解析程序</p></figure><p id="2905" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！我们终于有了实现两个订阅的井字游戏GraphQL服务器！我们的工作完成了，游戏可以开始了！❌ ⭕️</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6040" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">概述</h1><p id="71c0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们快速回顾一下今天学到的内容:</p><ul class=""><li id="740d" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">要构建订阅解析器，实现<code class="fe ny nz oa na b">GraphQLSubscriptionResolver</code>接口就足够了。</li><li id="8bcf" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">订阅解析器必须从反应流返回<code class="fe ny nz oa na b">Publisher</code>接口的实现。</li><li id="da7c" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">使用Project Reactor，我们可以将一个反应流定义为一个bean，它可以自动连接并在GraphQL解析器中使用。</li><li id="fb17" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">订阅中的认证可以通过实现<code class="fe ny nz oa na b">ApolloSubscriptionConnectionListener</code>接口来处理。</li></ul><p id="a8ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在GitHub上找到井字游戏服务器应用程序的<a class="ae ky" href="https://github.com/pixel13/tic-tac-toe" rel="noopener ugc nofollow" target="_blank">完整代码</a>以及一个简单的CLI客户端来测试它(使用<a class="ae ky" href="https://github.com/apollographql/apollo-android" rel="noopener ugc nofollow" target="_blank"> Apollo Android </a>客户端和<a class="ae ky" href="https://github.com/square/okhttp" rel="noopener ugc nofollow" target="_blank"> OkHttp库</a>制作)。</p><p id="b1fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fa01" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><div class="og oh gp gr oi oj"><a href="https://www.graphql-java-kickstart.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">GraphQL Java Kickstart</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">使用Java轻松入门GraphQL的项目。这些项目依赖于graphql-java库作为…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">www.graphql-java-kickstart.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ks oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a href="https://www.apollographql.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">阿波罗图表</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">Apollo数据图平台——将API、微服务和数据库统一到一个数据图中，您可以使用GraphQL进行查询</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">www.apollographql.com</p></div></div><div class="os l"><div class="oy l ou ov ow os ox ks oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a href="https://github.com/reactor" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">反应堆</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">基于反应流的反压异步消息传递项目。无阻塞反应型粉底…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="oz l ou ov ow os ox ks oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a href="https://github.com/pixel13/tic-tac-toe" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">pixel 13/井字游戏</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">这是一个井字游戏的GraphQL演示应用程序，用Java、Spring Boot和Kickstart库实现…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="pa l ou ov ow os ox ks oj"/></div></div></a></div></div></div>    
</body>
</html>