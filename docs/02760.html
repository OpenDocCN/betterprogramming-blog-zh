<html>
<head>
<title>Be the Master of the Event Loop in JavaScript (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">成为JavaScript中事件循环的主人(第3部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/be-the-master-of-the-event-loop-in-javascript-part-3-df51ab655c94?source=collection_archive---------3-----------------------#2019-12-26">https://betterprogramming.pub/be-the-master-of-the-event-loop-in-javascript-part-3-df51ab655c94?source=collection_archive---------3-----------------------#2019-12-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d388" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">XMLHttpRequest、fetch和Axios</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/500499e65030d3a88c42ff2944f1818b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eKaZLXK3Njtwb91E"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@aaronandrewang?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aaron Andrew Ang </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="db7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是JavaScript事件循环的最后一个系列。如果你没有看过我之前的帖子，我建议你先看看那些。</p><ul class=""><li id="beba" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第1部分— <a class="ae ky" href="https://medium.com/better-programming/be-the-master-of-the-event-loop-in-javascript-part-1-6804cdf6608f" rel="noopener">宏任务、微任务、执行上下文、事件队列和rAF </a></li><li id="c982" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第2部分— <a class="ae ky" href="https://medium.com/better-programming/be-the-master-of-the-event-loop-in-javascript-part-2-54637d49889f" rel="noopener">事件冒泡、捕获和委托</a></li></ul><p id="10ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将讨论JavaScript中的异步函数。</p><ul class=""><li id="2abd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">XMLHttpRequest</li><li id="1873" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">取得</li><li id="6a3e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Axios</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c337" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">XMLHttpRequest</h1><p id="9483" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">JavaScript允许您以异步方式获取数据。最古老、最经典的方法是使用<code class="fe nn no np nq b">XMLHttpRequest</code>。这是一个构造函数，允许你向服务器发送一个HTTP请求。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="5456" class="nv mr it nq b gy nw nx l ny nz">const oReq = new XMLHttpReqeust();</span></pre><p id="034b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在<code class="fe nn no np nq b">oReq</code>拥有了<em class="oa"> XMLHttpRequest </em>对象。要发出HTTP请求，您应该首先打开请求。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="ae7a" class="nv mr it nq b gy nw nx l ny nz">oReq.open('GET', 'https://jsonplaceholder.typicode.com/todos/1');</span></pre><p id="e9d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">XHR方法不区分大小写。所以，你甚至可以把它写成“geT”，因为在这个过程中它会被大写。然后，您可以将请求发送到服务器。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="13d5" class="nv mr it nq b gy nw nx l ny nz">oReq.send();</span></pre><p id="b5bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了接收请求的响应，您应该将一个回调函数附加到<em class="oa"> XMLHttpRequest </em>对象上。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="0727" class="nv mr it nq b gy nw nx l ny nz">oReq.addEventListener('load', function () {<br/>  console.log(this.responeText);<br/>});</span><span id="a1a0" class="nv mr it nq b gy ob nx l ny nz">// Result<br/>{<br/>  "userId": 1,<br/>  "id": 1,<br/>  "title": "delectus aut autem",<br/>  "completed": false<br/>}</span></pre><p id="2b26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，您应该使用普通函数而不是箭头函数，因为普通函数的<code class="fe nn no np nq b">this</code>绑定到XMLHttpRequest，而箭头函数绑定到<code class="fe nn no np nq b">window</code>。XMLHttpRequest的<code class="fe nn no np nq b">responseText</code>在<code class="fe nn no np nq b">e</code>的原型链中不存在。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="41fa" class="nv mr it nq b gy nw nx l ny nz">'responseText' in e === false</span></pre><p id="b50a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，你不觉得很奇怪吗？我在以前的文章中解释过JavaScript中有几种类型的任务。但是为什么叫异步函数呢？</p><p id="eaba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在关于<em class="oa"> XMLHttpRequest </em>发送的<a class="ae ky" href="https://xhr.spec.whatwg.org/#the-send()-method" rel="noopener ugc nofollow" target="_blank"> WHATWG文档中是这样描述的:</a></p><ol class=""><li id="b43e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu oc mb mc md bi translated"><em class="oa">设置发送()标志。</em></li><li id="0c3a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oc mb mc md bi translated">如果同步标志未置位，则:<br/> … <br/> -处理网络任务源上的任务队列。<br/> -如果自上次调用这些步骤后已经过了大约50毫秒，则终止这些步骤。</li></ol><p id="8fde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该关注<strong class="lb iu">任务队列</strong>和<strong class="lb iu">50毫秒</strong>。这听起来不像是我们一起调查过的事情吗？是的。这是一个<em class="oa">超时</em>！所以我们知道<em class="oa"> XMLHttpRequest </em>实际上使用了<em class="oa"> setTimeout </em>来执行。如果<em class="oa"> XMLHttpRequest </em>使用<em class="oa"> setTimeout </em>，那么它应该被无限<em class="oa">承诺</em>阻塞，因为它们是微任务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a1be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在Codepen中运行了这个例子；记录<code class="fe nn no np nq b">this.responseText</code>的总时间约为114，000毫秒。这意味着即使<em class="oa"> XMLHttpRequest </em>是一个异步函数，仍然有办法阻止它的执行，所以您应该将代码放在正确的位置。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0041" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">取得</h1><p id="2413" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><em class="oa"> fetch </em>是一个较新的API，它具有<em class="oa"> XMLHttpRequest </em>所没有的额外特性。它返回一个<em class="oa">承诺</em>，该承诺解析对该请求的响应，不管它是否成功。</p><p id="1181" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<em class="oa">取出</em>:</p><ul class=""><li id="372e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">缓存API可用于请求和响应对象。</li><li id="1d3c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="oa">获取</em>不会收到跨站cookies。</li><li id="c91f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="oa">获取</em>不会发送cookies。</li><li id="b9a8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">fetch中的<em class="oa">承诺</em>不会拒绝HTTP错误状态。</li></ul><p id="fa0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有<em class="oa"> XMLHttpRequest </em>可以:</p><ul class=""><li id="2921" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">中止请求。</li><li id="79c1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">报告进展。</li></ul><p id="b362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个区别是IE不支持fetch，因为它使用了IE也不支持的<em class="oa"> Promise </em>。所以如果你应该支持旧的浏览器，你应该使用<em class="oa"> XMLHttpRequest </em>。</p><p id="aea0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MDN说有一个允许你中止请求的界面，但它说这是一项实验性的技术。它不支持IE，但部分支持Safari。从<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController" rel="noopener ugc nofollow" target="_blank">这里</a>查看。</p><p id="c11b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oa"> fetch </em>给你一些更方便的方法来检查你的响应状态。</p><p id="daee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">res.json()</code>将响应解析为JSON对象。如果你使用<em class="oa"> Promise，</em>你应该再次返回<code class="fe nn no np nq b">res.json()</code>来获得下一个<code class="fe nn no np nq b">.then</code>链中正确的JSON对象。如果用<code class="fe nn no np nq b">async</code>和<code class="fe nn no np nq b">await</code>，可以简单的加上<code class="fe nn no np nq b">await</code>。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="76d6" class="nv mr it nq b gy nw nx l ny nz">// Promise<br/>fetch(url)<br/>  .then(res =&gt; {<br/>    return res.json();<br/>  })<br/>  .then(data =&gt; {<br/>    console.log(data);<br/>  });</span><span id="80d0" class="nv mr it nq b gy ob nx l ny nz">// async &amp; await<br/>const res = await fetch(url);<br/>const data = await res.json();<br/>console.log(data);</span></pre><p id="269a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<em class="oa"> fetch </em>里面，可以看到是怎么描述的。</p><p id="71de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在<em class="oa">请求</em>上排队获取任务以运行操作，请运行以下步骤:</p><ol class=""><li id="51ec" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu oc mb mc md bi translated">如果请求的客户端为空，则终止这些步骤。</li><li id="14a3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oc mb mc md bi translated">使用网络任务源，将任务排队以在请求的客户端的负责事件循环上运行操作。</li></ol><p id="fe9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该看到的是“任务排队”。在这个上下文中，“将任务排队”意味着将任务添加到任务队列中。由于<em class="oa">获取</em>返回一个<em class="oa">承诺</em>，所以这是一个微任务。但是你可以在<code class="fe nn no np nq b">then</code>得到结果。有很多微任务在运行怎么办？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="680d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像我们在<em class="oa"> XMLHttpRequest </em>中试验的一样，<em class="oa"> fetch </em>也被阻塞了许多毫秒，直到前面的微任务完全执行完。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="5ab7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">Axios</h1><p id="e5f0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Axios是一个适用于浏览器和节点的现代HTTP请求库。它拥有来自用户的超过67K颗星。它吸取了<em class="oa"> XMLHttpRequest </em>和<em class="oa"> fetch </em>的精华。</p><p id="438b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，使用<em class="oa"> Axios </em>的方法其实很简单容易。这与如何使用<em class="oa">获取</em>非常相似。您将一个URL作为第一个参数传递给Axios，但是相反，您应该使用正确的HTTP方法，比如<em class="oa"> Axios.get </em>。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="e00f" class="nv mr it nq b gy nw nx l ny nz">// Promise <br/>axios.get('/user?ID=12345')<br/>  .then(function (response) {<br/>    // handle success<br/>    console.log(response);<br/>  })<br/>  .catch(function (error) {<br/>    // handle error<br/>    console.log(error);<br/>  })<br/>  .finally(function () {<br/>    // always executed<br/>  });</span><span id="1dcd" class="nv mr it nq b gy ob nx l ny nz">// async &amp; await<br/>async function getUser() {<br/>  try {<br/>    const response = await axios.get('/user?ID=12345');<br/>    console.log(response);<br/>  } catch (error) {<br/>    console.error(error);<br/>  }<br/>}</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a1ad" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="813f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">JavaScript事件是一个非常复杂和困难的话题，但是如果你每天都使用JavaScript，你应该很了解它。我尽力解释了我所知道的JavaScript事件。我希望我至少能对你的理解有一点点帮助！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f9fd" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">本系列的更多内容</h1><ul class=""><li id="b481" class="lv lw it lb b lc ni lf nj li of lm og lq oh lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/be-the-master-of-the-event-loop-in-javascript-part-2-54637d49889f" rel="noopener">阅读成为JavaScript中事件循环的主人(第2部分)</a></li><li id="175d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/be-the-master-of-the-event-loop-in-javascript-part-3-df51ab655c94" rel="noopener">阅读成为JavaScript中事件循环的主人(第3部分)</a></li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="788c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">资源</h1><ul class=""><li id="7775" class="lv lw it lb b lc ni lf nj li of lm og lq oh lu ma mb mc md bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" rel="noopener ugc nofollow" target="_blank"> XMLHttpRequest — MDN </a></li><li id="5f22" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://xhr.spec.whatwg.org/#interface-xmlhttprequest" rel="noopener ugc nofollow" target="_blank"> XMLHttpRequest接口— WhatWG </a></li><li id="909a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"> Rest API示例站点— JsonPlaceHolder </a></li><li id="b1d5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取— MDN </a></li><li id="eed7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/35549547/fetch-api-vs-xmlhttprequest" rel="noopener ugc nofollow" target="_blank">获取API与XMLHttpRequest-stack overflow</a></li><li id="f0aa" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController" rel="noopener ugc nofollow" target="_blank">流产控制员— MDN </a></li><li id="11b0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://javascript.info/fetch" rel="noopener ugc nofollow" target="_blank"> fetch — JavaScript.info </a></li><li id="acbc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> Axios — Github </a></li></ul></div></div>    
</body>
</html>