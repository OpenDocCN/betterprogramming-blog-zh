<html>
<head>
<title>How to Create Lazy Attributes to Improve Performance in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中创建惰性属性以提高性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-lazy-attributes-to-improve-performance-in-python-b369fd72e1b6?source=collection_archive---------0-----------------------#2020-07-09">https://betterprogramming.pub/how-to-create-lazy-attributes-to-improve-performance-in-python-b369fd72e1b6?source=collection_archive---------0-----------------------#2020-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5528" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它关乎高效的性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/825db9445833cc33a4ce0e011112b090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wluO6HgYGxq80hfa"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">罗伯特·尼克森在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ad35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">惰性评估</em>是一个编程实现范例，它将评估必要的操作推迟到被请求的时候。</p><p id="a807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，当运算开销很大，需要大量处理时间或内存时，惰性求值是首选实现。例如，在Python中，涉及惰性求值的最著名的技术之一是生成器。生成器不会为迭代创建整个序列(这会消耗大量内存),而是缓慢地评估当前需求，并在请求时一次生成一个元素。</p><p id="d7b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了生成器特性，在Python世界之外，许多其他面向对象的编程语言，比如Swift和Kotlin，都有与对象相关的惰性求值。具体来说，您可以指定自定义实例对象的特定属性在这些语言中是惰性的，这意味着这些属性在被显式访问之前不会被创建。</p><p id="a0ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，据我所知，在Python教程中对惰性属性的讨论较少。因此，为了向Python学习者提供一个概念证明，我将向您介绍Python中的惰性属性。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="15e7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">这个问题</h1><p id="c444" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在我们开始讨论懒惰属性之前，有些人可能想知道为什么它很重要，或者为什么我们要费心使用懒惰属性。</p><p id="c3e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个可能的场景:假设我们正在构建一个允许用户与其他用户交互的网站。一个功能是查看一个人的追随者，在一个列表中。当我们点击一个用户时，我们可以在弹出窗口中查看该用户的个人资料。让我们写一些代码来展示一个可能的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">问题是</p></figure><p id="6f37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，当前的实现包括获取列表中所有用户的配置文件数据。获取简档数据的操作可能是昂贵的。它不仅需要访问远程服务器，还需要将数据存储在内存中。</p><p id="088c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是，显示所需的用户界面并不需要这些简档数据，因为简档数据仅在点击特定用户名时使用。这个用例为我们实现懒惰属性奠定了完美的基础。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c64a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">解决方案1:使用“@property”</h1><p id="152f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">首先，属性与Python中的属性不是完全相同的概念。本质上，<em class="lv">属性</em>是修饰函数。并且通过修饰，常规函数被转换成属性，这些属性可以用作其他属性，比如支持点记法访问。</p><p id="e01b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，严格地说，创建属性本身并不是真正创建惰性属性。相反，这只是提供一个接口来简化数据处理的问题。在幕后，还涉及到其他一些过程。在我解释它是如何工作的之前，让我们先看看下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">惰性属性:“@property”</p></figure><p id="5511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码有以下与使用<code class="fe nc nd ne nf b">@property</code> decorator实现lazy属性相关的变化。</p><ul class=""><li id="a72c" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">我们现在有了一个受保护的属性<code class="fe nc nd ne nf b">_profile_data</code>，它是在对象的实例化过程中作为<code class="fe nc nd ne nf b">None</code>创建的，用作以后数据处理的占位符。</li><li id="b3c0" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">我们使用<code class="fe nc nd ne nf b">@property</code>装饰器来装饰<code class="fe nc nd ne nf b">profile_data</code>函数，这样我们就可以使用点符号来访问<code class="fe nc nd ne nf b">profile_data</code>的属性。</li><li id="c2db" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">在<code class="fe nc nd ne nf b">profile_data</code>函数中，我们首先检查<code class="fe nc nd ne nf b">_profile_data</code>属性是否有数据，只有当它没有数据时(即<code class="fe nc nd ne nf b">None</code>)，我们才执行重运算。在我们的用例中，如果一个特定的用户从未被点击来显示他们的配置文件，我们将永远不需要获取配置文件数据，这正是惰性评估的目的——它只会在绝对需要时运行昂贵的操作。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">评估用“@property”实现的惰性属性</p></figure><p id="e98b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码用于检查惰性属性的实现是否如预期的那样工作。我们尝试访问属性两次，正如您所看到的，这个昂贵的操作只在属性为<code class="fe nc nd ne nf b">None</code>时运行了一次。当我们第二次访问该属性时，我们立即获得了获取的值。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="01d9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">解决方案2:使用“__getattr__”特殊方法</h1><p id="89c2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在Python中，名字前后有双下划线的函数被称为<em class="lv">特殊</em>或<em class="lv">神奇</em>方法。有些人也称它们为<em class="lv"> dunder </em>(即双下划线)方法。一个特殊的方法——<code class="fe nc nd ne nf b">__getattr__</code>——可以帮助我们实现懒惰属性。</p><p id="63ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于自定义类，实例对象将其属性保存在字典中，可以使用特殊方法<code class="fe nc nd ne nf b">__dict__</code>访问该字典。具体来说，这个字典将属性名存储为它的键，将相应的属性值存储为它的值。值得注意的是，如果字典不包含指定的属性，那么将调用特殊方法<code class="fe nc nd ne nf b">__getattr__</code>作为后备机制。</p><p id="dbfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这听起来可能令人困惑，但对于真实的代码示例来说并不难，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">惰性属性:“__getattr__”</p></figure><p id="288d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码有以下与使用<code class="fe nc nd ne nf b">__getattr__</code>特殊方法实现惰性属性相关的变化。</p><ul class=""><li id="64a0" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">更新后的<code class="fe nc nd ne nf b">__init__</code>方法删除了配置文件数据的属性设置。这是一个必要的改变，因为如果设置了它，即使值为<code class="fe nc nd ne nf b">None</code>，属性及其值也将存储在对象的<code class="fe nc nd ne nf b">__dict__</code>属性中。在这种情况下，特殊方法<code class="fe nc nd ne nf b">__getattr__</code>不会被调用。</li><li id="35e1" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">我们还实现了<code class="fe nc nd ne nf b">__str__</code>方法，该方法将用于显示对象以供参考(即在<code class="fe nc nd ne nf b">__getattr__</code>方法中引发的异常中)。</li><li id="087e" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">在<code class="fe nc nd ne nf b">__getattr__</code>方法中，我们指定当访问<code class="fe nc nd ne nf b">profile_data</code>属性时，我们将远程获取数据并使用<code class="fe nc nd ne nf b">setattr</code>方法设置属性。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">惰性属性的测试</p></figure><p id="f00e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的代码是为了展示特殊方法<code class="fe nc nd ne nf b">__getattr__</code>是否能够帮助我们实现惰性属性。</p><p id="6754" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们第一次尝试获取名为<code class="fe nc nd ne nf b">profile_data</code>的属性时，调用了<code class="fe nc nd ne nf b">__getattr__</code>特殊方法并为我们创建了属性<code class="fe nc nd ne nf b">profile_data</code>。</p><p id="e1e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，当我们试图检索<code class="fe nc nd ne nf b">profile_data</code>属性时，特殊的<code class="fe nc nd ne nf b">__getattr__</code>方法没有被第二次调用，因为这个特殊的属性已经在<code class="fe nc nd ne nf b">__dict__</code>字典中可用。让我们用下面的代码检查一下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">__dict__ '和“__getattr__”</p></figure><p id="3603" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，<code class="fe nc nd ne nf b">profile_data</code>属性不在字典中。在我们试图检索它之后，<code class="fe nc nd ne nf b">__getattr__</code>方法被调用，<code class="fe nc nd ne nf b">profile_data</code>属性及其值被保存在字典中。</p><p id="8b50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一次我们访问该属性时，它直接从字典中返回，而不触发<code class="fe nc nd ne nf b">__getattr__</code>方法。这正是我们想要懒惰评估拥有的行为。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9e7a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">荣誉奖:' __getattribute__ '</h1><p id="e44e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">除了<code class="fe nc nd ne nf b">__getattr__</code>方法，Python中还有另一种特殊的方法叫做<code class="fe nc nd ne nf b">__getattribute__</code>。虽然它们的名称相似，工作原理在某种程度上也相似，但请不要混淆这两种不同的方法。</p><p id="fce1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与当特定属性在实例字典中时不会被调用的<code class="fe nc nd ne nf b">__getattr__</code>方法不同，<code class="fe nc nd ne nf b">__getattribute__</code>方法在每次检索属性时都会被调用。</p><p id="7016" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有当您预期属性会非常频繁地改变并且只有最新的数据是相关的时，这个特性才是有用的。在这些情况下，我们可以通过定义相关的函数来达到效果。</p><p id="951d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，我不建议你尝试实现它，因为让它正常工作很棘手(参见<a class="ae ky" href="https://stackoverflow.com/questions/3278077/difference-between-getattr-vs-getattribute" rel="noopener ugc nofollow" target="_blank">这里</a>的简短讨论)。例如，您可能遇到的一个特殊问题是无限递归循环——<code class="fe nc nd ne nf b">__getattribute__</code>方法被调用了无数次，会使您的程序崩溃。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="dffd" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="2abf" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在本文中，我们重点讨论了在Python中实现惰性属性的两种实用方法(外加一种不详细讨论也不推荐的巧妙方法):一种使用<code class="fe nc nd ne nf b">@property</code>装饰器，另一种使用<code class="fe nc nd ne nf b">__getattr__</code>特殊方法。</p><p id="b227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就我个人而言，我更喜欢使用属性装饰器，它更简单易懂。然而，当您需要定义多个惰性属性时，<code class="fe nc nd ne nf b">__getattr__</code>方法更好，因为它提供了一个集中的地方来管理这些惰性属性。</p><p id="b4d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>