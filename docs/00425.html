<html>
<head>
<title>Breaking Down the Analysis Phase of a Compiler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分解编译器的分析阶段</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/breaking-down-the-syntax-analysis-phase-of-a-compiler-18964309f332?source=collection_archive---------2-----------------------#2019-05-18">https://betterprogramming.pub/breaking-down-the-syntax-analysis-phase-of-a-compiler-18964309f332?source=collection_archive---------2-----------------------#2019-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="6403" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">编译理论</h1><p id="316f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">尽管人们普遍认为JavaScript是一种“动态”或“解释”语言，但它实际上是一种编译语言。这种误解的原因之一可能是因为JavaScript没有提前编译好，就像你在许多传统编译语言中看到的那样。但是最终，JavaScript引擎会执行许多与其他语言相同的步骤，甚至可能以更复杂的方式执行。(旁注:引擎负责我们JavaScript程序的从头到尾的编译和执行。)</p><blockquote class="lm"><p id="db22" class="ln lo it bd lp lq lr ls lt lu lv ll dk translated">在传统的编译语言过程中，一大块源代码，也就是你的程序，在执行之前通常会经历三个步骤<em class="lw">*</em>，大致称为“编译”</p><p id="0e42" class="ln lo it bd lp lq lr ls lt lu lv ll dk translated">~埃里克·埃利奥特</p></blockquote><p id="ed92" class="pw-post-body-paragraph ko kp it kq b kr lx kt ku kv ly kx ky kz lz lb lc ld ma lf lg lh mb lj lk ll im bi translated">这两个阶段，<strong class="kq iu">词法分析</strong>和<em class="mc"> </em> <strong class="kq iu">语法分析</strong> <em class="mc">，</em>合起来称为<strong class="kq iu">分析阶段</strong>，或者说<strong class="kq iu">编译器的</strong> <strong class="kq iu">前端</strong>。这是一个<strong class="kq iu">中间代码表示<em class="mc"> </em> </strong>，编译器用它来表示一个源文本。</p><p id="dd4c" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">涉及的步骤(按此顺序)如下:</p><h1 id="0066" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">步骤1:词法分析阶段</h1><p id="37ab" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是扫描器和标记器的共同努力。</p><h2 id="f17f" class="mi jr it bd js mj mk dn jw ml mm dp ka kz mn mo ke ld mp mq ki lh mr ms km mt bi translated">第一部分:扫描文本</h2><p id="0d71" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">编译器做的第一件事就是扫描文本。这项工作由<strong class="kq iu">扫描仪</strong>和<em class="mc">执行。</em>文本分解成尽可能小的部分，称为<strong class="kq iu">词位</strong> <em class="mc">。</em></p><h2 id="eb02" class="mi jr it bd js mj mk dn jw ml mm dp ka kz mn mo ke ld mp mq ki lh mr ms km mt bi translated"><strong class="ak">B部分:标记化/词法分析</strong></h2><p id="5207" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第二件事是创建一个令牌流来解析代码生成。所以基本上，这将一串字符分解成有意义的(对语言来说)块，称为<strong class="kq iu">记号</strong>。这一行代码，<code class="fe mu mv mw mx b">var a= 2;</code>经过标记化阶段后会分解，看起来像<code class="fe mu mv mw mx b">var</code>、<code class="fe mu mv mw mx b">a</code>、<code class="fe mu mv mw mx b">=</code>、<code class="fe mu mv mw mx b">2</code>、<code class="fe mu mv mw mx b">;</code>。</p><h1 id="af26" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">步骤2:语法分析阶段</h1><p id="618d" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，我将在这里解释两件事，但它们可能会因语言而异。一旦词法分析完成，我们就开始语法分析阶段。根据手头的语言，一些语言可能会开发一个<strong class="kq iu">解析树，具体语法树(CST) </strong>，然后使用它来派生它们的<strong class="kq iu">抽象语法树(AST)。</strong>然而，像JavaScript这样的一些语言会直接开发AST，而不需要任何CST。让我们先看一下CST，然后再看AST，以帮助您理解。</p><p id="ee16" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">这里你可以用简单的英语来描述CST。</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="ab gu cl nd"><img src="../Images/1df16d8ffd32fecf2d34fb89ff8b8586.png" data-original-src="https://miro.medium.com/v2/format:webp/1*zQ_bUppUhjPj3JjJ-uQv0w.jpeg"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated"><a class="ae nk" href="https://medium.com/basecs/grammatically-rooting-oneself-with-parse-trees-ec9daeda7dad" rel="noopener">https://medium . com/basecs/grammatically-root-self-with-parse-trees-EC 9 daeda 7 dad</a></p></figure><blockquote class="lm"><p id="cd82" class="ln lo it bd lp lq nl nm nn no np ll dk translated">以英语为例，每个句子的最小“部分”是一个单词；单词可以组合成短语，如名词短语或动词短语，这些短语又可以与其他短语结合在一起，形成句子表达式。</p><p id="3445" class="ln lo it bd lp lq lr ls lt lu lv ll dk translated">~ Vaidehi</p></blockquote><p id="a8e5" class="pw-post-body-paragraph ko kp it kq b kr lx kt ku kv ly kx ky kz lz lb lc ld ma lf lg lh mb lj lk ll im bi translated">因此，将一个英语句子解析成CST似乎很容易。让我们来看看它是如何应用到数学上的。</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="ab gu cl nd"><img src="../Images/1c36d96c69258c2364d0b255bff6262c.png" data-original-src="https://miro.medium.com/v2/format:webp/1*PfSCFpmeTRe050GvziXgEA.jpeg"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated"><a class="ae nk" href="https://medium.com/basecs/grammatically-rooting-oneself-with-parse-trees-ec9daeda7dad" rel="noopener">https://medium . com/basecs/grammatically-root-self-with-parse-trees-EC 9 daeda 7 dad</a></p></figure><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="ab gu cl nd"><img src="../Images/1cf2ee4ef269730db1fe90441a718a3f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*pZQeACNRqVdegpDMP4nHfg.jpeg"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated"><a class="ae nk" href="https://medium.com/basecs/grammatically-rooting-oneself-with-parse-trees-ec9daeda7dad" rel="noopener">https://medium . com/basecs/grammatically-root-self-with-parse-trees-EC 9 daeda 7 dad</a></p></figure><p id="d73d" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">很酷，对吧？基于数学规则，我们相应地创建了一个CST！但是等等，根据我们遍历树的方式，它可能会被错误地解释。让我们看看几种不同的方法可以遍历它。</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="ab gu cl nd"><img src="../Images/3f0702b6255a011f6d9ddc13a1a7964a.png" data-original-src="https://miro.medium.com/v2/format:webp/1*kbeiQA0pBr--lGGSjdUg6A.jpeg"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated"><a class="ae nk" href="https://medium.com/basecs/grammatically-rooting-oneself-with-parse-trees-ec9daeda7dad" rel="noopener">https://medium . com/basecs/grammatically-root-self-with-parse-trees-EC 9 daeda 7 dad</a></p></figure><p id="8564" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">这里要注意的关键点是存在歧义，而<em class="mc">歧义对于编译器来说是个问题。</em>所以作为回报，编译器寻找<em class="mc">清晰</em>，<em class="mc">方向</em>来遵循。在这个例子中，我们可能给编译器的一个方向是简单地从左向右遍历。后来，我们可能会添加一些括号、指数、乘法、除法、加法和减法<strong class="kq iu"> (PEMDAS) </strong>方向，等等规则<em class="mc">。</em></p><p id="1c28" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">CST规则将依赖于手边的语言，但是它们总是将令牌分解成最小形式的有意义节点的树。</p><p id="b244" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">那么到底什么是AST，为什么JavaScript直接创建了它？</p><p id="539b" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">在我们深入研究它之前，您需要知道:解析器将总是生成一个AST作为它的输出，不管它是否在两者之间创建了一个解析树。</p><p id="65b6" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">明白了吗？很好，这里有一个AST中节点的简单例子:</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="ab gu cl nd"><img src="../Images/96226a180adf604c15d784c27615e878.png" data-original-src="https://miro.medium.com/v2/format:webp/1*NO_p9739sX6Tf-ESRkSKaw.jpeg"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated"><a class="ae nk" href="https://medium.com/basecs/leveling-up-ones-parsing-game-with-asts-d7a6fc2400ff" rel="noopener">https://medium . com/basecs/leveling-up-ones-parsing-game-with-asts-d 7 a6 fc 2400 ff</a></p></figure><p id="d8b7" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">我们之前对<code class="fe mu mv mw mx b">5 + (1 x 12)</code>的简单表达可以被构建成AST的可视化图示，如下所示:</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="ab gu cl nd"><img src="../Images/e1ad90ac90316b145e3b0720dcc9df3e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*0n73V3Ld0e-nTmZKGw3OpQ.jpeg"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated"><a class="ae nk" href="https://medium.com/basecs/leveling-up-ones-parsing-game-with-asts-d7a6fc2400ff" rel="noopener">https://medium . com/basecs/leveling-up-ones-parsing-game-with-asts-d 7 a6 fc 2400 ff</a></p></figure><p id="6f8a" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">注意到我们是如何丢失括号的吗？我们可以看到，AST并不关心将所有的令牌插入到节点中，而是通读每个令牌并确定其重要性。这取决于我们讨论的语言规则。所以AST的最终结果看起来更容易理解。但不要曲解。即使抽象语法树可能比CST更紧凑，并且在输出节点方面关心的要少得多，但它的推导仍然要复杂得多。AST必须确定令牌的重要性，这对于编译器来说变得复杂了😬。</p><blockquote class="nq nr ns"><p id="4c85" class="ko kp mc kq b kr md kt ku kv me kx ky nt mf lb lc nu mg lf lg nv mh lj lk ll im bi translated"><em class="it">经典JavaScript，fandangling的东西在一起🤣</em></p></blockquote><p id="50fe" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">一旦解析器知道了它试图解析的语言的语法，构建CST实际上是相当容易的。它不需要做任何复杂的工作来判断一个令牌是否“重要”。取而代之的是，它只是按照它所看到的特定顺序准确地获取它所看到的东西，并将其全部吐到一棵树上。</p><h1 id="9fd3" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">第三步:代码生成</strong></h1><p id="38d8" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后一步是<strong class="kq iu">代码生成</strong>。这是获取AST并将其转化为可执行代码的过程。这部分根据语言、目标平台等有很大的不同。对我们来说，了解这一点也不像开发人员那样重要，所以我们不会深入讨论这一部分的细节。只需知道有一种机制将AST视为“var a = 2；并把它变成一组机器指令，实际上<em class="mc">创建</em>一个名为<code class="fe mu mv mw mx b">a</code>的变量(包括保留内存等。)，然后将一个值存储到<code class="fe mu mv mw mx b">a</code>中。引擎如何管理系统资源比我们现在需要挖掘的更深入，所以我们只是想当然地认为引擎能够根据需要创建和存储变量🙂。</p><h1 id="476a" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">最终注释</strong></h1><p id="246b" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">JavaScript引擎比这三个步骤要复杂得多，大多数其他语言编译器也是如此。例如，在解析和代码生成的过程中，肯定会有一些优化执行性能的步骤，包括折叠冗余元素等。但是现在知道这三个步骤是最重要的。一旦你更深入地研究像JavaScript这样的语言的数据流和作用域，你就会明白作为一名开发人员，了解编译器为你做了什么是如此重要。</p><p id="1d28" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">感谢所有为撰写关于你不知道JavaScript的6本书做出贡献的人，感谢<a class="ae nk" href="https://medium.com/@vaidehijoshi" rel="noopener"> Vaidehi Joshi </a>，我为此借用了他们的图片。</p></div></div>    
</body>
</html>