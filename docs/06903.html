<html>
<head>
<title>When Coroutines Meet Android Permissions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当协同程序满足Android权限时</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/when-coroutines-meet-android-permissions-a1f048e70f74?source=collection_archive---------4-----------------------#2020-11-16">https://betterprogramming.pub/when-coroutines-meet-android-permissions-a1f048e70f74?source=collection_archive---------4-----------------------#2020-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8caa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用协程处理单行运行时权限</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1f0eda2db1c93a68cc7dbf2b766b6998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4mRk5sJN7VEc-erb"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="3620" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，您将了解如何使用协程从Android Marshmallow处理Android运行时权限。这种方法可以用最少的代码轻松处理Android组件中的权限。你将不再需要处理回调和<code class="fe lv lw lx ly b">onResult</code>函数。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a10a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">概观</h1><p id="fcda" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们将要创建的过程非常简单。我们需要创建一个基础片段来处理系统所需的所有权限处理。因此，核心部分将与代码的其余部分隔离开来，附带的好处是可重用性。</p><p id="ed34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们必须将这个片段声明为一个抽象类，以便它可以扩展。之后，创建另一个片段，我们用基本片段扩展它。这里，我们将使用协程来观察基础中权限执行的状态，并将其更新到调用站点。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="59ac" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">我们开始吧</h1><p id="4a5b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了使状态流不那么模糊，我们必须创建一个密封的类，并包含来自系统的所有可能的权限回调和必要的信息，如结果代码。</p><p id="9a0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，有四种类型的结果:</p><ul class=""><li id="8779" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">的确;因为</li><li id="bd21" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">拒绝</li><li id="07e8" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">展示理性的信息</li><li id="35ee" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">永久拒绝。</li></ul><p id="7ccd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看覆盖所有结果类型的密封类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">处理权限的自定义密封类</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9394" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">BasePermissionController</h1><p id="2609" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">作为计划的一部分，我们必须创建一个名为<code class="fe lv lw lx ly b">BasePermissionController</code>的抽象类，并用<code class="fe lv lw lx ly b">Fragment</code>扩展它。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ceeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须创建一个抽象函数，可以导入到扩展基础的片段中，以便快速传递结果。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f28b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要创建一个函数来处理与系统和用例的交互，比如向用户显示一个rational消息。然后我们必须将数据转换成我们的密封类。别说了。看一下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">处理系统权限</p></figure><p id="f328" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们所做的很简单:首先，我们维护了一个<code class="fe lv lw lx ly b">hashmap</code>请求，我们需要用结果代码作为键来执行这些请求。然后，我们必须检查所请求的权限是否已经被授予，或者我们是否必须显示一条合理的消息。如果是这样，我们用适当的类型创建一个密封的类对象，并将其传递回去。</p><p id="4a06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，在我们必须请求访问的地方，我们已经将结果代码添加到映射中，并再次调用该函数。当第二次执行时(因为代码已经存在于映射中)，流进入<code class="fe lv lw lx ly b">hashmap</code>索引块并触发实际的权限执行。</p><p id="ff83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在用户与权限对话框交互之后，我们将在<code class="fe lv lw lx ly b">onRequestPermissionsResult</code>上收到结果。我们需要创建一个密封类的新实例，并将数据传递回调用站点。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们完成了核心权限处理。当我们把所有的部分放在一起时，看看基类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f8f3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">许可控制器</h1><p id="1574" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">然后我们需要创建另一个名为<code class="fe lv lw lx ly b">PermissionController</code>的类，并用<code class="fe lv lw lx ly b">BasePermissionController</code>扩展它。接下来，我们要导入抽象函数<code class="fe lv lw lx ly b">onPermissionResult</code>。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，是时候使用协程编写实际的逻辑了。一旦从基本控制器调用了<code class="fe lv lw lx ly b">onPermissionResult</code>，我们需要将<code class="fe lv lw lx ly b">permissionResult</code>传递回调用站点。为了用协程做到这一点，我们使用了<code class="fe lv lw lx ly b">CompletableDeferred</code>:</p><blockquote class="nt nu nv"><p id="9669" class="kz la nw lb b lc ld ju le lf lg jx lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated">“一个可以通过公共函数<code class="fe lv lw lx ly b"><em class="it">complete</em></code>或<code class="fe lv lw lx ly b"><em class="it">cancel</em></code>完成的<code class="fe lv lw lx ly b"><em class="it">Deferred</em></code>。</p><p id="f131" class="kz la nw lb b lc ld ju le lf lg jx lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi">…</p><p id="8334" class="kz la nw lb b lc ld ju le lf lg jx lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated">这个接口上的所有函数[以及从它派生的所有接口]都是线程安全的，可以在没有外部同步的情况下从并发协同例程中安全地调用。”—<a class="ae ky" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-completable-deferred/" rel="noopener ugc nofollow" target="_blank">GitHub上的kot Lin</a></p></blockquote><p id="ef95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们必须创建一个类型为<code class="fe lv lw lx ly b">PermissionResult</code>的<code class="fe lv lw lx ly b">CompletableDeferred</code>实例，并在<code class="fe lv lw lx ly b">onPermissionResult</code>函数中调用它。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="18c0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">快速存取</h1><p id="63ab" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了使调用点的权限处理更加流畅，我们可以在<code class="fe lv lw lx ly b">PermissionController</code>的伴随对象上创建一个可公开访问的函数，并编写样板代码。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e983" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">呼叫站点</h1><p id="26f3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在调用点——无论是活动还是片段——我们必须从一个挂起函数或带有<code class="fe lv lw lx ly b">Dispatcher.Main</code>的协程作用域中调用<code class="fe lv lw lx ly b">requestPermissions</code>。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="36e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们收到数据，我们就可以使用<code class="fe lv lw lx ly b">when</code>关键字处理它，并根据状态进行导航。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a525" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">借鉴与启发</h1><p id="20a7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读！</p><p id="f03b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里使用的所有代码都是从sagar-viradiya/eazypermissions示例中提取的。如果您感兴趣，请随时查看以下资源库:</p><div class="oa ob gp gr oc od"><a href="https://github.com/sagar-viradiya/eazypermissions" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">Sagar-vira diya/eazy权限</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">一个轻量级的Android库，它包装了运行时权限的样板代码，并允许你请求权限…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">github.com</p></div></div><div class="om l"><div class="on l oo op oq om or ks od"/></div></div></a></div></div></div>    
</body>
</html>