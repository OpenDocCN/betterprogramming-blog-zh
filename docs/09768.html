<html>
<head>
<title>3 Takeaways From WWDC 21's Demystifying SwiftUI Talk</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从WWDC 21的揭秘SwiftUI对话中获得的3点启示</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-takeaways-from-wwdc-21s-demystifying-swiftui-talk-967bb9ab1f17?source=collection_archive---------6-----------------------#2021-10-07">https://betterprogramming.pub/3-takeaways-from-wwdc-21s-demystifying-swiftui-talk-967bb9ab1f17?source=collection_archive---------6-----------------------#2021-10-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="24a8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">避免错误和提高性能的提示和技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b940ca6ef3cab361674832d986d0dc08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZRMaZadvgrJ1xSnb_DrPAw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2021/10022/" rel="noopener ugc nofollow" target="_blank"> WWDC第21届会议的截屏</a></p></figure><p id="8032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">去年夏天，我<a class="ae ky" href="https://marklucking.medium.com/the-best-apple-wwdc-talk-ever-16d613815f86" rel="noopener">写了一篇文章</a>，讲述了我认为是近年来最好的WWDC会谈之一。一个演讲，虽然没有说太多，但我觉得它说明了编码和软件工程之间的区别——因为我相信你知道——它们不是一回事。</p><p id="29bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我认为这个展示<a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2021/10022/" rel="noopener ugc nofollow" target="_blank">揭开SwiftUI 3.0 </a>的神秘面纱属于同一个阵营。不像许多WWDC演讲，告诉你什么是新的，并给你使用新功能的提示，这个演示集中在野兽的“内脏”，野兽是，在这种情况下，SwiftUI。</p><p id="239d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用演示者的话说，“SwiftUI是一个声明式UI框架，你描述你想要什么，它决定如何去做。这种解决方案通常很有效，但并不总是如此”。</p><p id="0660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解SwiftUI在查看您的代码时看到了什么，这是编码和软件工程之间的区别。这就是让SwiftUI按照你想要的方式做事和只是完成它们之间的区别。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b109" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">身份、生存期和依赖关系</h1><p id="1c3c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">身份是SwiftUI在您的UI中将元素识别为相同或不同的方式。生存期是SwiftUI如何随着时间的推移跟踪视图和数据，依赖于SwiftUI如何理解您的界面何时需要更新以及为什么需要更新。</p><blockquote class="mz na nb"><p id="8ed2" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">下面显示的代码示例与讲座中的不同——非常欢迎您查看这两个示例来理解所涉及的主题。</p></blockquote><p id="cc9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，身份在大计划中是至关重要的，因为SwiftUI使用它来计算如何从一种状态到另一种状态的动画。你需要问自己的问题是:“你所看到的景色是相同的还是不同的？”。这个问题的答案决定了SwiftUI需要如何在视图之间进行转换。</p><p id="474c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果两个视图包含相同的元素，则它们共享相同的身份，即使它们的排列方式不同——然而，如果它们包含不同的元素，那么它们显然是不同的视图。</p><p id="2260" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像动画语句一样，视图和数据有两种类型的标识，显式的和结构化的。“结构性”这个词在这里是隐式的另一种说法——你分配的显式身份，系统分配的隐式或结构性身份。</p><p id="763c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">演讲[11:28]的第一个要点是:</p><blockquote class="ng"><p id="bf2f" class="nh ni it bd nj nk nl nm nn no np lu dk translated"><strong class="ak">尽量减少应用程序中的身份数量。</strong></p></blockquote><p id="be7a" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">这样做，SwiftUI可以更有效地转换所述视图<strong class="lb iu">。讲座中有一个代码示例，下面是我的版本，让您了解讨论的要点。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="69e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，演讲描述了如何找出他们称之为结构视图身份的克星的东西:标签[15:40]。</p><p id="70c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我们想到了本次演讲的第二个要点:</p><blockquote class="ng"><p id="d08e" class="nh ni it bd nj nk nl nm nn no np lu dk translated">如果可以通过编码绕过AnyView指令，就不要使用它。</p></blockquote><p id="faea" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">更好的是，他们解释了如何做到这一点，用一个非常好的十行代码示例将视图更改为包装在<code class="fe nx ny nz oa b">@ViewBuilder</code>指令中的函数。这里有一个代码示例来说明我所说的内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="b87a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们转到讨论视图标识的生存期及其相关状态。本次讨论的关键要点[23:06]是:</p><blockquote class="ng"><p id="445b" class="nh ni it bd nj nk nl nm nn no np lu dk translated">状态信息的生命周期与视图有着内在的联系。</p></blockquote><p id="cea2" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">所以当一个视图被创建时，<code class="fe nx ny nz oa b">@State</code>和<code class="fe nx ny nz oa b">@StateObjects</code>也被创建。当视图随后消失时，所述对象将随之毁灭。</p><p id="ac1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个iOS 15的例子来说明这一点。运行这段代码，它不会倒计数，因为每次循环时<code class="fe nx ny nz oa b">@State</code>都会被销毁；去掉<code class="fe nx ny nz oa b">@State</code>这个词就可以了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="e550" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们跳回身份，下一个要点[25:06]强调所谓稳定身份的重要性。</p><p id="7910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除非标识所引用的数据改变，否则标识不应改变。它对事物的大计划如此重要，以至于SwiftUI有一个协议来描述它，即<code class="fe nx ny nz oa b">Identifiable</code>。这一点至关重要，因为它会影响应用的性能&amp;正确性。选择一个稳定的身份有助于SwiftUI管理您的视图的生命周期，并确实正确地管理过渡/动画。</p><p id="f1e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI鼓励您在这个问题上正确编码，将正确的编码风格融入语法中，尽管当然仍有可能出错。</p><p id="d32c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，如果您决定分配显式标识，请确保在这样做时，当它们链接到的数据或视图发生更改时，它们不会重新生成或重新分配，除非数据本身发生了更改。</p><p id="58c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们看一下依赖性，在[28.56]分钟有一个简单的定义，在[32.15]分钟有一个完整的列表。演示者再次告诉我们，标识符的稳定性对视图的生命周期至关重要，有时还会影响应用程序的性能或正确性。他从[33:00]开始给出了一个很棒的代码示例。</p><p id="2913" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本节的关键要点是:</p><blockquote class="ng"><p id="381a" class="nh ni it bd nj nk nl nm nn no np lu dk translated">为你的视图选择一个唯一稳定的身份很重要。</p></blockquote><p id="a10e" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">像以前一样，讲座最后更多地讨论了结构标识以及在SwiftUI代码中非常小心分支的必要性。</p><p id="dbb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不同的分支意味着不同的身份，你应该在你的代码中尽可能的避免分支。</p><p id="681e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我们回到第一个代码示例。这就是这篇文章的结尾。感谢阅读。</p></div></div>    
</body>
</html>