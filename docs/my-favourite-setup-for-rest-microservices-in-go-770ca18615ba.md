# Go 中我最喜欢的 REST 微服务设置

> 原文：<https://betterprogramming.pub/my-favourite-setup-for-rest-microservices-in-go-770ca18615ba>

## Go 中微服务的模板

![](img/24831e3f2c5b032df49c301ebc9fa117.png)

照片由[摄影师](https://unsplash.com/@ffstop?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/programming?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

在这个故事中，我想分享一下我个人对于 Go 中服务 REST APIs 的微服务的模板。因为我已经开始从头开始编写一些服务，观察到特定的代码部分总是重复，所以我决定将它们导出到一个模板中并共享它。

虽然某些部分可能会在其他框架更受欢迎的情况下进行调整，但我希望整体结构能够以更简单、更快速的方式帮助您实现下一个项目。

在这个故事中，我展示了一个示例项目服务，它提供 API 端点来管理项目、里程碑和任务。

# 文件夹结构

首先，我想分享我的首选文件夹结构，在这里您可以找到运行示例`project-service`的所有文件。

*   `api/`包含一个或多个版本的 REST API
*   `dbs/`包含初始化数据库连接和执行迁移的代码
*   `models/`包含所有模型定义和潜在的模型相关逻辑
*   `pkg/**/*`包含模型的服务逻辑
*   `seeds/`包含最初用一些数据播种数据库的代码

# 模型

为了简化数据库操作，ORM 是一个非常好的选择。我个人比较喜欢 [gorm](https://gorm.io/) 。Gorm 通过标签反射工作，这意味着您向模型的字段添加标签，gorm 将处理它们。gorm 可以处理的简单模型如下所示:

尽管非常灵活，gorm 还是提供了简单的用法和强大的缺省值。通过扩展`gorm.Model`结构，您的模型将获得一个 ID 字段，用作标识符(默认情况下，它将是一个自动递增的整数)。

未标记的字段被转换为 snake case 列名。通过字段标签，我们可以配置 gorm 的行为，在本例中，我们只需向 name 列添加一个索引。

其他模型可以通过使用它们的结构作为字段，甚至作为切片来引用。我们的服务有三种模式:`Project`、`Milestone`、`Task`。一个项目有一个或多个里程碑，每个里程碑可能有一个或多个任务。

我建议为每个模型创建一个单独的`.go` 文件，如果模型还实现了其他接口或者有特定的(反)序列化逻辑，那么这个文件会更容易维护。

最后，我总是在`models`文件夹中添加一个`migrate.go`文件，其中包含自动迁移代码。对于 gorm，如果您遵循指南，这是一个显而易见的事情，您可以简单地将所有模型的引用放入`gorm.AutoMigrate()`:

# 数据库初始化

我的模板的下一部分是设置数据库连接和执行迁移等初始操作的逻辑。在`dbs`文件夹中，我有一个名为`setup.go`的文件，它运行初始化首选数据库连接的代码。代码如下所示:

代码很简单，有一个`InitializeDatabaseLayer`函数传递`DB`环境变量并检查应该使用哪个数据库驱动程序。在这个示例中，实现了用于开发的 SQLite 和用于生产设置的 Postgres，但是它可以很容易地扩展到所有其他支持的 gorm 驱动程序。

对于这两个驱动程序中的每一个，我都添加了一个从环境中加载所需信息并连接到数据库的方法。之后，调用给出的`automigrate`方法来确保数据库与模型同步。最后是 gorm 的一个实例。DB 将返回给应用程序。我喜欢将这个实例保存在一个变量中，并导出一个函数来获取它，在本例中，是`GetDB`方法。

# 执行数据库逻辑的服务实例

既然已经建立了数据库连接，接下来要考虑的是实际的数据库相关逻辑。在我的展示中，我有所有三个需要实现的模型的 CRUD 操作。在我的模板中，我喜欢为每个模型创建一个文件夹，并在那里找到所有相关的实现，从一个`service.go`文件开始。以下代码显示了项目的该文件:

服务实现从一个`ProjectService`结构和它的单例实例开始，调用`projects.GetService().`将返回该结构和单例实例。服务本身包含为项目模型执行数据库操作的逻辑。使用在`setup.go`文件中初始化的 gorm 数据库实例，将基本 CRUD 操作实现为专用方法。因为 gorm 给了我们一个很好的特性集，所以实现这些 CRUD 操作很简单。TODO:可以在不同的 API 中重用

对于其余的模型，服务实现看起来是相似的。虽然这对于我们的三个模型及其简单的逻辑来说看起来相当冗长，但我认为当您的代码库增长时，以这种方式分离和实现东西将会带来巨大的好处。

# 使用 Gin Gonic 的休止端点

在实现了与数据库相关的核心逻辑之后，我们需要通过 REST API 公开它。因此，我通常会创建一个包含版本化 API 的`api`文件夹，例如在这个简单的例子中的`v1.go`，在更复杂的 API 中，为每个版本创建专用的文件夹可能也是聪明的做法。

具有特定版本号的 API 总是有自己的 URL 上下文，例如版本 1 的`/v1/*`。API 代码相对简单，因为我们的核心逻辑是在服务中实现的:

我通过使用一个结构来实现每个 API 版本，例如对于 REST API 版本 1 使用`RESTAPIV1`。作为一个 HTTP 框架，我个人喜欢使用 [Gin Gonic](https://gin-gonic.com/) ，因为它简单而强大。

我把 gin 路由器作为 API struct 中的一个字段，添加了`Serve`方法，可以从主程序调用。

在构造函数`NewRestApiV1`中，我通过`router.POST`或`router.GET`等实例化了这个路由器并注册了所有路由器。可通过路线中的`:paramName`简单配置参数。正如我们在`EditProject`方法中看到的(它获得对`gin.Context`的引用作为唯一的参数)，param 可以通过`c.Param("paramName").` Gin Gonic 通过`ShouldBindJSON`方法为使用 JSON 提供了很好的开发人员体验。

最后，返回代码和 JSON 响应很容易通过`c.JSON`和简写`gin.H`实现，它们可以用作通用映射。

虽然通过 Gin Gonic 的 REST 只是一个例子，但是许多其他组合也是可能的，例如 GRPC 或 Websockets，或者如果喜欢的话，简单地使用另一个 HTTP 库。

# 种子

虽然我们可以通过迁移将我们的模型表示与数据库同步，但是向数据库添加初始数据通常非常有帮助，例如，一个管理员用户。这避免了使用外部管理工具连接到数据库来手动添加这些数据。

我更喜欢将种子文件的路径作为命令行参数传递给服务，当该文件存在并且数据库为空时，服务将加载种子文件并插入所有包含的数据。

为了便于编辑，我更喜欢对种子文件使用 JSON。运行种子的代码如下所示:

首先，获取所有服务实例。之后，代码检查数据库中是否有任何任务，如果有，则返回方法，因为我们希望种子数据只插入一次。

如果数据库中没有任务，代码会打开种子，创建一个 JSON 编码器并解析文件，以防它是有效的 JSON。JSON 应该是一个`Seeds`对象，它有项目、里程碑和任务片段作为字段。最后，这些切片将被迭代以插入数据。

这里需要注意的一点是，种子项目也可以有里程碑，这些里程碑也可以有任务。

# 主程序

在详细介绍了所有部分之后，最后缺少的部分就是主程序，它存储在`main.go`中:

主程序非常短，因为这个模板为微服务的所有核心部分提供了专用文件夹。它从通过 Go 的内部标志包设置一些命令行标志开始。这些标志如下:HTTP 端点监听的本地地址`laddr`、`loglevel`和初始种子文件的路径`initialSeedFile`。我喜欢使用 [logrus](https://github.com/sirupsen/logrus) 进行日志记录，它接受不同`loglevels`的列表。除了一些首选的格式设置外，`configureLogging`方法从标志中解析`loglevel`并相应地设置它。主函数调用`configureLogging`，初始化数据库层(包括迁移)，然后运行种子(如果`initialSeedFile`已设置)，然后创建 REST API 并在已配置的`laddr`下服务它。

# Dockerfile 文件

最后，我想简单介绍一下 Dockerfile，我总是把它添加到我的 Go 服务中，把它们作为容器来部署。这是一个基于 alpine 的多阶段 dockerfile 文件，它创建了相对较小的容器。

它开始使用 1.18 Golang alpine 容器，将当前文件夹复制到其中，并通过`CGO_ENABLED=0 go build`进行构建。

虽然这里可能不需要`CGO_ENABLED=0`部分，但如果所有阶段都基于类似的 alpine 版本，这有助于避免在更改第一或第二阶段基本容器时出现问题。

构建完成后，我使用默认的 alpine 映像作为第二阶段，安装`ca-certificates`(如果您想与通过 TLS 保护的外部端点通信，这是必须的)，然后复制第一阶段构建的二进制文件。最后一步是简单地设置 docker `ENTRYPOINT`。

在这个故事中，我分享了我在 Go 中首选的微服务模板。我认为它提供了一个很好的起点，也可以扩展到更大的服务。我很高兴得到任何反馈或建议来改进这个故事。

完整的代码可以在 [GitHub](https://github.com/martenwallewein/go-sample-microservice) 上找到。