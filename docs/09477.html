<html>
<head>
<title>8 Git Tips To Improve Code Reviewing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改进代码审查的8个Git技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/8-git-tips-to-improve-code-reviewing-71cae7883d6f?source=collection_archive---------9-----------------------#2021-08-30">https://betterprogramming.pub/8-git-tips-to-improve-code-reviewing-71cae7883d6f?source=collection_archive---------9-----------------------#2021-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bc2d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何让<code class="fe ki kj kk kl b">git diff</code>、<code class="fe ki kj kk kl b">git log</code>和其他git命令成为我的代码审查仪式的一部分</h2></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/2a3105f189a59e0640db199d6e3931a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yrVoL0h_mXgfHDDU"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">代码审查不仅仅是拉…照片由<a class="ae lc" href="https://unsplash.com/@charlesdeluvio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Charles Deluvio </a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9d5e" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">过去几个月是代码审查的密集期。然而，与以前的代码审查高峰不同，我花了一点时间来找出如何让我的生活变得更简单。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="9484" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">本文中的示例使用了两个简单的JSON文件:</p><ul class=""><li id="8bc9" class="mg mh it lf b lg lh lj lk lm mi lq mj lu mk ly ml mm mn mo bi translated"><code class="fe ki kj kk kl b">beers.json</code> ( <a class="ae lc" href="https://github.com/Al-un/beerworld/blob/develop/git/pr/beers.json" rel="noopener ugc nofollow" target="_blank">来源</a>)</li><li id="805a" class="mg mh it lf b lg mp lj mq lm mr lq ms lu mt ly ml mm mn mo bi translated"><code class="fe ki kj kk kl b">countries.json</code> ( <a class="ae lc" href="https://github.com/Al-un/beerworld/blob/develop/git/pr/countries.json" rel="noopener ugc nofollow" target="_blank">来源</a>)</li></ul><p id="a3b0" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">从<code class="fe ki kj kk kl b">feature/update-countries</code>分支创建一个针对<code class="fe ki kj kk kl b">master</code>分支的拉式请求，其中<code class="fe ki kj kk kl b">countries.json</code>发生了变化:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">模拟打字错误纠正😁</p></figure><h1 id="a92c" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">1.隔离评审存储库和工作存储库</h1><p id="2319" class="pw-post-body-paragraph ld le it lf b lg no ju li lj np jx ll lm nq lo lp lq nr ls lt lu ns lw lx ly im bi translated">在经历了多个git分支的不幸之后，我现在使用一个存储库的两个克隆来隔离开发活动和评审任务:<code class="fe ki kj kk kl b">&lt;the_repo&gt;</code>和<code class="fe ki kj kk kl b">&lt;the_repo&gt;-review</code>。如果需要更多的克隆，只需遵循<code class="fe ki kj kk kl b">&lt;the_repo&gt;-&lt;purpose&gt;</code>语法。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nt"><img src="../Images/aa4b151d78048662286fcfe7213f2fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XsRkpv2LP6aNqg9T"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://unsplash.com/@jhaland?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约尔根·哈兰</a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8348" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">有了这样的结构，我不担心弄乱了<code class="fe ki kj kk kl b">[repo]-review</code>文件夹里的分支。也省了我很多<code class="fe ki kj kk kl b">git stash</code>。藏东西很好，但当我疯狂地在多个分支之间跳跃时，它会变得很伤脑筋。</p><p id="2567" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当审查代码时，我有时会在提交评论之前尝试或简单地起草更改，以确保我将编写的内容有意义。有了一个专门的评审库，我可以非常轻松地进行操作，而不用关心隐藏变更。</p><h1 id="4421" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">2.从远程更新分支而不签出</h1><p id="b9ef" class="pw-post-body-paragraph ld le it lf b lg no ju li lj np jx ll lm nq lo lp lq nr ls lt lu ns lw lx ly im bi translated">我越来越需要更新公共分支，<code class="fe ki kj kk kl b">develop</code>或<code class="fe ki kj kk kl b">master</code>，而不需要检查它。谢天谢地，代码很简单:</p><pre class="kn ko kp kq gt nu kl nv nw aw nx bi"><span id="8fe0" class="ny mx it kl b gy nz oa l ob oc">git fetch origin &lt;branch&gt;:&lt;branch&gt;</span></pre><p id="108d" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">此语法假设分支可以快进。否则，需要结帐。例如，在一个特征分支被重定基础后，我的方法是使用下面的代码:</p><pre class="kn ko kp kq gt nu kl nv nw aw nx bi"><span id="99d7" class="ny mx it kl b gy nz oa l ob oc">git checkout feature/update-countries<br/>git fetch origin feature/update-countries<br/>git reset --hard origin/feature/update-countries</span></pre><p id="2a98" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">文档链接:</p><ul class=""><li id="dc9b" class="mg mh it lf b lg lh lj lk lm mi lq mj lu mk ly ml mm mn mo bi translated"><code class="fe ki kj kk kl b"><a class="ae lc" href="https://git-scm.com/docs/git-checkout" rel="noopener ugc nofollow" target="_blank">git checkout</a></code></li><li id="41fd" class="mg mh it lf b lg mp lj mq lm mr lq ms lu mt ly ml mm mn mo bi translated"><code class="fe ki kj kk kl b"><a class="ae lc" href="https://git-scm.com/docs/git-fetch" rel="noopener ugc nofollow" target="_blank">git fetch</a></code></li></ul><h1 id="c06c" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">3.正确列出来自拉取请求的所有更改</h1><p id="254b" class="pw-post-body-paragraph ld le it lf b lg no ju li lj np jx ll lm nq lo lp lq nr ls lt lu ns lw lx ly im bi translated">虽然GitHub和GitLens VS代码扩展提供了一个很好的界面来显示更改，但是知道如何在终端中显示更改不止一次地帮助了我。这一切都从下面的代码开始:</p><pre class="kn ko kp kq gt nu kl nv nw aw nx bi"><span id="2fdb" class="ny mx it kl b gy nz oa l ob oc">git diff master...</span><span id="c91c" class="ny mx it kl b gy od oa l ob oc"># Equivalent after 2.30<br/>git diff --merge-base master</span><span id="6259" class="ny mx it kl b gy od oa l ob oc"># Equivalent before 2.30:<br/>git diff $(git merge-base master HEAD)</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oe"><img src="../Images/8bd6374ebc4f5468061b981070abe0ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a-zMpPxoUSvH1q5QSokVMA.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">新旧语法提供相同的输出</p></figure><p id="6a78" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为什么把<code class="fe ki kj kk kl b">git diff</code>的命令复杂化？如果<code class="fe ki kj kk kl b">master</code>分支收到了一些更新，一个简单的<code class="fe ki kj kk kl b">git diff master</code>会列出所有的差异，而不仅仅是特性分支带来的差异。</p><p id="e4e5" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们假设<code class="fe ki kj kk kl b">master</code>收到了<code class="fe ki kj kk kl b">beers.json</code>文件中的一些更新，而<code class="fe ki kj kk kl b">feature/update-countries</code>分支没有修改它。结果如下:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi of"><img src="../Images/ae49beb8b48dc26a31448e5d17cd0943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1YU1hxZQA4K6pNw_9due7w.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">这模拟了在“功能/更新-国家”被合并之前，两个拉请求被合并到“主”中</p></figure><p id="2410" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如上所述，一个简单的<code class="fe ki kj kk kl b">git diff master</code>返回所有的差异，如下所示:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi og"><img src="../Images/02f988cb67d6633c316cde9ecaf58a07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wB0aSBCtdyJUN6i8IxUj5w.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">“beers.json”文件中的更改未被请求</p></figure><p id="2587" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此需要<code class="fe ki kj kk kl b">master...</code>范围或<code class="fe ki kj kk kl b">--merge-base</code>选项。</p><p id="937f" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">作为一名前端开发人员，我的评论通常涵盖冗余文件模式，如下所示:</p><ul class=""><li id="8f95" class="mg mh it lf b lg lh lj lk lm mi lq mj lu mk ly ml mm mn mo bi translated"><code class="fe ki kj kk kl b">src/components/some-folder/another-folder/Something.ts</code></li><li id="a337" class="mg mh it lf b lg mp lj mq lm mr lq ms lu mt ly ml mm mn mo bi translated"><code class="fe ki kj kk kl b">src/components/some-folder/another-folder/Something.spec.ts</code></li><li id="8112" class="mg mh it lf b lg mp lj mq lm mr lq ms lu mt ly ml mm mn mo bi translated"><code class="fe ki kj kk kl b">src/components/some-folder/another-folder/Something.stories.ts</code></li></ul><p id="0f55" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我发现显示组件及其相关文件的更改非常有用:</p><pre class="kn ko kp kq gt nu kl nv nw aw nx bi"><span id="d2b7" class="ny mx it kl b gy nz oa l ob oc">git diff master.. -- src/components/some-folder/**/*.ts</span></pre><p id="148b" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">文档链接:</p><ul class=""><li id="7c1c" class="mg mh it lf b lg lh lj lk lm mi lq mj lu mk ly ml mm mn mo bi translated"><code class="fe ki kj kk kl b"><a class="ae lc" href="https://git-scm.com/docs/git-diff" rel="noopener ugc nofollow" target="_blank">git diff</a></code></li><li id="1626" class="mg mh it lf b lg mp lj mq lm mr lq ms lu mt ly ml mm mn mo bi translated"><code class="fe ki kj kk kl b"><a class="ae lc" href="https://git-scm.com/docs/git-log" rel="noopener ugc nofollow" target="_blank">git log</a></code></li></ul><p id="1951" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf iu">注意:</strong>我不使用<code class="fe ki kj kk kl b"><em class="oh">git blame</em></code>，因为GitLens VS代码扩展(<a class="ae lc" href="https://gitlens.amod.io/" rel="noopener ugc nofollow" target="_blank">主页</a>)提供了这个信息。请随意查看它的<a class="ae lc" href="https://git-scm.com/docs/git-blame" rel="noopener ugc nofollow" target="_blank">文档页</a>，因为它是一个有用的命令。</p><h1 id="b2e8" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">4.列出所有更改的文件</h1><p id="2597" class="pw-post-body-paragraph ld le it lf b lg no ju li lj np jx ll lm nq lo lp lq nr ls lt lu ns lw lx ly im bi translated">由于前面的技巧和<code class="fe ki kj kk kl b">--name-status</code>选项(<a class="ae lc" href="https://git-scm.com/docs/git-diff#Documentation/git-diff.txt---name-status" rel="noopener ugc nofollow" target="_blank">文档链接</a>)，通过拉请求列出修改过的文件是小菜一碟，如下所示:</p><pre class="kn ko kp kq gt nu kl nv nw aw nx bi"><span id="4e25" class="ny mx it kl b gy nz oa l ob oc">git diff --name-status master...<br/># OR<br/>git diff --master-base --name-status master</span></pre><p id="cbd6" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">VS Code terminal中的这种列表非常方便，只需简单的Ctrl+click / Cmd+click就可以打开文件。这个命令通常是我代码审查仪式的第一步。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oi"><img src="../Images/4e2f1da72ed84966bbe7a7f2633475ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYKnzVuJ8wZVxRQvSDBSVQ.png"/></div></div></figure><p id="5049" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">没有<code class="fe ki kj kk kl b">--master-base </code>或者没有<code class="fe ki kj kk kl b">…</code>范围，<code class="fe ki kj kk kl b">beers.json</code>也会出现，这不是期望的结果。</p><p id="71dc" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果您想通过提交来分解它，您可以使用以下命令:</p><pre class="kn ko kp kq gt nu kl nv nw aw nx bi"><span id="e543" class="ny mx it kl b gy nz oa l ob oc">git log --oneline --name-status master..</span></pre><p id="e036" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果没有<code class="fe ki kj kk kl b">..</code>范围操作符，它将包含同时出现在<code class="fe ki kj kk kl b">master</code>和<code class="fe ki kj kk kl b">feature/update-countries</code>分支中的提交。</p><h1 id="0481" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">5.仅对添加和修改的文件执行NPM命令</h1><p id="2cff" class="pw-post-body-paragraph ld le it lf b lg no ju li lj np jx ll lm nq lo lp lq nr ls lt lu ns lw lx ly im bi translated">为了进一步循环利用<code class="fe ki kj kk kl b">git diff</code>命令，我当前的团队构建了一些神奇的命令，只对添加和修改的文件运行<code class="fe ki kj kk kl b">npm run lint</code>，忽略删除的文件。非常感谢，团队！</p><pre class="kn ko kp kq gt nu kl nv nw aw nx bi"><span id="762c" class="ny mx it kl b gy nz oa l ob oc">git diff --name-status master... | awk '/^[A|M].*\.(js|ts)$/ {print $2}' | xargs npm run lint</span></pre><p id="d280" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">用所需的扩展名列表替换<code class="fe ki kj kk kl b">(js|ts)</code>。例如，对于Vue.js项目，扩展列表可能是<code class="fe ki kj kk kl b">(js|ts|vue)</code>。</p><p id="fbbb" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这个特别的命令是我们日常生活中的生命救星，因为我们正在更新我们的林挺规则。一些林挺规则需要复杂的操作，比如文件重命名，所以我们不喜欢一下子改变整个代码库，而是逐步发展。</p><p id="61a5" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们确实有一些CI来自动检查它，但是在提交拉取请求之前进行本地检查并没有什么坏处。</p><h1 id="1b9c" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">6.用“Git Branch”删除多个分支</h1><p id="0933" class="pw-post-body-paragraph ld le it lf b lg no ju li lj np jx ll lm nq lo lp lq nr ls lt lu ns lw lx ly im bi translated">除了<code class="fe ki kj kk kl b">git fetch origin --prune</code>删除远程删除分支的引用(<a class="ae lc" href="https://git-scm.com/docs/git-fetch#Documentation/git-fetch.txt---prune" rel="noopener ugc nofollow" target="_blank">文档链接</a>，我喜欢保持本地分支的引用干净。</p><p id="28e7" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在审查了多个拉请求之后，删除所有分支很快就会变成一件麻烦的事情。在我的代码评审库中，我可以在大型评审会议后批量删除分支:</p><pre class="kn ko kp kq gt nu kl nv nw aw nx bi"><span id="7fb6" class="ny mx it kl b gy nz oa l ob oc">git branch --list &lt;pattern&gt; | xargs git branch -d</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oj"><img src="../Images/a84d57d7b695cf3ecb1050bb4aace20d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*14XVGYmx1HPs1dPfQG8rCg.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">请注意，使用了“-d”。如果你使用“git branch -D ”,确保你知道你在做什么😨</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="b0a2" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">羞耻区:<strong class="lf iu"> </strong>现在我们来了解一下……嗯……从“不太聪明”的情况中学到的。</p><h1 id="dc10" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">7.用“git rebase -i”修复过去的提交</h1><p id="c02c" class="pw-post-body-paragraph ld le it lf b lg no ju li lj np jx ll lm nq lo lp lq nr ls lt lu ns lw lx ly im bi translated">当根据评审员的评论更新我的代码时，我……嗯……有时没有正确检查我是否纠正了所有的错误，所以很明显，我漏掉了一两个地方。</p><p id="c0db" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当然我可以用<code class="fe ki kj kk kl b">git commit -m "oops, forgot here"</code>，但是不是很干净。因此，如果我能够承担得起(例如，尚未推送更改或重写历史的安全部分)，我更喜欢更正过去的提交。</p><p id="df88" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果只需要编辑最后一次提交，<code class="fe ki kj kk kl b">git commit --amend</code>就足够了。编辑旧的提交需要一个交互式的rebase。</p><p id="5207" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">例如，如果我想修改提交<code class="fe ki kj kk kl b">e935a02</code>，它是<code class="fe ki kj kk kl b">b6719a9</code>的子节点。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ok"><img src="../Images/c4b0c6909e977285b448bcf620f04b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K5S6lbidM16bfD-8VCf3Cw.png"/></div></div></figure><p id="7750" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">开始交互式重建基础。起点必须是您想要编辑的最早提交之前的提交<em class="oh">。</em></p><pre class="kn ko kp kq gt nu kl nv nw aw nx bi"><span id="2797" class="ny mx it kl b gy nz oa l ob oc">git rebase -i b6719a9</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ol"><img src="../Images/5b65e0a584152e33710b2715b6a1e67d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*to76GOOplFoOS3blvhO3rA.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">“git log”有助于找到交互式rebase的起点</p></figure><p id="0846" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">出现从所提供的起点开始的提交列表，起点被排除在外，并且对于每个提交，必须定义一个动作。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi om"><img src="../Images/e827d67d19d71b69d18fbee164ad6849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FBopYhCFq1sTxS5feNqLtQ.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">我选择只修改一个提交</p></figure><p id="ee36" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">重置将在提交<code class="fe ki kj kk kl b">e935a02</code>时停止。可以进行更改，一旦完成，<code class="fe ki kj kk kl b">git commit --amend</code>更新提交:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi on"><img src="../Images/7ffab345370eca07431a688c54b03cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fR0V5ubz07yARBYsXzDUDQ.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">对于这个例子，我只是更改了提交消息，但是您可以自由地用更多的文件更改来修改提交</p></figure><p id="9afa" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">请注意，与任何重置基础一样，这将重写分支历史:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oo"><img src="../Images/510534b161a2fb821e37345b922185bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xKH0C0IkGmwvZoNtCBlF0g.png"/></div></div></figure><p id="ab82" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">友情提示，以防万一:这绝对<strong class="lf iu">不是</strong>推荐给公共分支机构的。</p><h1 id="97aa" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">8.使用“git cherry-pick”将提交从不正确的分支转移到正确的分支</h1><p id="2c24" class="pw-post-body-paragraph ld le it lf b lg no ju li lj np jx ll lm nq lo lp lq nr ls lt lu ns lw lx ly im bi translated">不幸的是，这种事情发生得比我的自尊心所能承认的还要频繁😅。在分割我的工作存储库和我的评审存储库之前，忘记切换到正确的分支比它应该发生的更频繁。</p><p id="f434" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">例子:在<code class="fe ki kj kk kl b">feature/update-countries</code>分支上工作，我修改了超出范围的<code class="fe ki kj kk kl b">beers.json</code>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi op"><img src="../Images/2e9df400b39f81091142eb36d56d6488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eFYOEokpGMC-6qzK1xgSRQ.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">哇哦…</p></figure><p id="ae6a" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe ki kj kk kl b">git cherry-pick</code>结合<code class="fe ki kj kk kl b">git log</code>可以帮助我们将最后两次提交转移到正确的分支:</p><pre class="kn ko kp kq gt nu kl nv nw aw nx bi"><span id="6500" class="ny mx it kl b gy nz oa l ob oc"># Back to master<br/>git checkout master</span><span id="2e4f" class="ny mx it kl b gy od oa l ob oc"># Spawn a branch if necessary or checkout to the correct branch<br/>git checkout -b fix/oops-the-beers</span><span id="c280" class="ny mx it kl b gy od oa l ob oc"># And save the day!<br/>git log --reverse --pretty=%h --max-count=2 feature/update-countries | xargs git cherry-pick</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oq"><img src="../Images/8bd5023ed82aca14570dcc804def82ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GdiXBZBx9U8_whjScbZJ7w.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">出于习惯，我留下了“- oneline”参数，但在这里没有必要</p></figure><ul class=""><li id="d29d" class="mg mh it lf b lg lh lj lk lm mi lq mj lu mk ly ml mm mn mo bi translated"><code class="fe ki kj kk kl b">--reverse</code>:樱桃采摘必须按照正确的顺序进行</li><li id="22bf" class="mg mh it lf b lg mp lj mq lm mr lq ms lu mt ly ml mm mn mo bi translated"><code class="fe ki kj kk kl b">--max-count=2</code>:根据自己的情况调整号码。</li><li id="e05a" class="mg mh it lf b lg mp lj mq lm mr lq ms lu mt ly ml mm mn mo bi translated"><code class="fe ki kj kk kl b">--pretty=%h</code>(或<code class="fe ki kj kk kl b">--format=%h</code>):只需要提交散列</li></ul><p id="a57e" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这个技巧只有在最后一个<code class="fe ki kj kk kl b">N</code>提交必须被移动时才有效。<code class="fe ki kj kk kl b">git log</code>有一个<code class="fe ki kj kk kl b">--grep</code>选项，但是我强烈建议不要对不连续的提交使用这个技巧。</p><p id="0042" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">错误的提交现在可以从<code class="fe ki kj kk kl b">feature/update-countries</code>分支中移除。请注意，这将影响分支历史！</p><pre class="kn ko kp kq gt nu kl nv nw aw nx bi"><span id="a858" class="ny mx it kl b gy nz oa l ob oc">git reset HEAD~2<br/># OR<br/>git reset 0f34663</span></pre><p id="8b67" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果您确定可以放弃更改，请使用<code class="fe ki kj kk kl b">git reset --hard</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="4119" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我希望这篇文章能以某种方式帮助你改善日常生活。至于最后两条建议，我希望你不要经常用到。</p><p id="0ae3" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">一些代码审查会议实际上可能变成一些悲惨的git事故，所以知道一些”(dirty？)招数”可以省去你很多麻烦。</p><p id="9445" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">感谢您阅读到目前为止，代码审查愉快！</p></div></div>    
</body>
</html>