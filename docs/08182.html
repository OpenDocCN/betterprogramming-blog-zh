<html>
<head>
<title>10 JavaScript Array Methods To Boost Your Code Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高代码性能的10种JavaScript数组方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-javascript-array-methods-to-boost-your-code-performance-acb57b455189?source=collection_archive---------0-----------------------#2021-04-05">https://betterprogramming.pub/10-javascript-array-methods-to-boost-your-code-performance-acb57b455189?source=collection_archive---------0-----------------------#2021-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="80c9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Every、some、includes和其他数组方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/596b2be7ab697eb9ec83299ba0be807f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MlUyoQbk7EgcHKEJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿诺德·弗朗西斯卡在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4695" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拥有大量实例方法的Array API是JavaScript中最大的API之一。起初，它可能是压倒性的。花些时间熟悉它是很重要的。像<code class="fe lv lw lx ly b">map()</code>和<code class="fe lv lw lx ly b">forEach()</code>这样的方法被广泛滥用。相反，通过使用正确的接口，你可以使你的代码更快、更有效、更易读。</p><p id="069e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用数组方法时需要考虑一些事情:有些是不可变的，有些是可变的。知道你正在使用哪种方法是至关重要的。误用会导致讨厌的错误。</p><p id="a60b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将看看JavaScript数组对象的十个更有用的实例方法，以及它们的亮点。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b8c1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">1.薄片</h1><p id="5246" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果你想通过开始和结束索引复制一个数组，你可能想使用<code class="fe lv lw lx ly b">slice()</code>。这个方法是一个纯函数，所以它不会有任何副作用，也不会改变目标数组。</p><blockquote class="nd ne nf"><p id="e4d4" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">"<code class="fe lv lw lx ly b">slice()</code>方法将数组的一部分的浅表副本返回到从<code class="fe lv lw lx ly b">start</code>到<code class="fe lv lw lx ly b">end</code>(不包括<code class="fe lv lw lx ly b">end</code>)中选择的新数组对象中，其中<code class="fe lv lw lx ly b">start</code>和<code class="fe lv lw lx ly b">end</code>表示该数组中项目的索引。原始数组不会被修改。— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="noopener ugc nofollow" target="_blank"> MDN </a></p></blockquote><p id="1b7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个参数都是可选的。如果不带任何参数调用，它将复制整个对象。如果你只用一个正参数调用它，它会给你一个长度=1的数组。您可以使用负偏移量来获取数组的最后一个元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/6aa85d257d3fecc04961127f16972188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_8asTpM_ILO4XKPeRBPoA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者使用不同参数执行方法切片的屏幕截图</p></figure><p id="20aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您需要在一个数组上构建子集并且不希望目标数组发生变化时，这种方法很有用。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b2ee" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">2.接合</h1><p id="7886" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这个方法类似于前一个方法，但是有一个很大的不同:它将改变你的目标数组。当您处理一个大数组，并且需要部分使用它的子集时，这很有用。</p><blockquote class="nd ne nf"><p id="3ed6" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">"<code class="fe lv lw lx ly b">splice()</code>方法通过移除或替换现有元素和/或在适当的位置添加新元素来改变数组的内容。"— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" rel="noopener ugc nofollow" target="_blank"> MDN </a></p></blockquote><p id="30b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们执行前面的例子，但是使用<code class="fe lv lw lx ly b">splice()</code>方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/c7de4ca3f51f64c72b2fa0d424bd6b7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OcROCA4Px61iRkLGCdfoSw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由具有不同参数的方法拼接执行的作者制作的屏幕截图</p></figure><p id="1d23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以观察到目标数组是如何变异的，以及在两次执行<code class="fe lv lw lx ly b">splice()</code>方法后它是如何空白的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b85b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">3.包含</h1><p id="5369" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">includes()</code>方法是检查数组中是否存在某个元素的工具。它返回<code class="fe lv lw lx ly b">true</code>或<code class="fe lv lw lx ly b">false</code>。</p><p id="e92d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它不接受任何等式函数，所以如果对象/原语包含在对象中，它将匹配。对于性能调优，可以将起始索引作为第二个参数传递。该指数可以是负数，也可以是正数。如果为负，它将检查最后一个<code class="fe lv lw lx ly b">x</code>数字。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/23c16a1f4d8f00adaab7a56d34c91563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*ePDBQSj4O1-pX9CQCyjk-w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="e2a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦找到一个项目，它将停止遍历剩余的项目，从而获得比遍历整个数组更好的性能。</p><p id="d63f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这比构建如下所示的自定义模板更有效:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4215" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">4.一些</h1><p id="cffc" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">some()</code>方法类似于<code class="fe lv lw lx ly b">includes()</code>方法。它也不会改变数组。不同之处在于<code class="fe lv lw lx ly b">some()</code>提供了一个等式回调，而<code class="fe lv lw lx ly b">includes()</code>依赖于匹配的原语/对象。另一个区别是，它不允许您自定义起始索引。</p><p id="bb11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看语法:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="c2ba" class="nt mh it ly b gy nu nv l nw nx">arr.some(callback(element[, index[, array]])[, thisArg])</span></pre><p id="90db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个数组，我们想检查是否有任何项大于<code class="fe lv lw lx ly b">10</code>。我们不能在这种情况下使用<code class="fe lv lw lx ly b">includes()</code>方法。让我们看看用<code class="fe lv lw lx ly b">some()</code>方法做这件事有多直观。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a7f5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">5.每个</h1><p id="f824" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">该方法的工作原理与<code class="fe lv lw lx ly b">some()</code>相似。然而，只有当所有元素都符合标准时，它才会返回<code class="fe lv lw lx ly b">true</code>。标准由回调函数给出，就像前面的方法一样。</p><blockquote class="nd ne nf"><p id="1847" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">every()</code>方法测试数组中的所有元素是否通过了由提供的函数实现的测试。它返回一个布尔值。— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" rel="noopener ugc nofollow" target="_blank"> MDN </a></p></blockquote><p id="f5f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法与<code class="fe lv lw lx ly b">some()</code>相同:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="ef42" class="nt mh it ly b gy nu nv l nw nx">arr.every(callback(element[, index[, array]])[, thisArg])</span></pre><p id="ff4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用前面的例子。假设我们希望确保所有项目都大于<code class="fe lv lw lx ly b">10</code>。由于接口参数相似，我们可以使用之前声明的<code class="fe lv lw lx ly b">greaterThan10</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c718" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">6.发现</h1><p id="4a63" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果你想寻找一个精确的元素,<code class="fe lv lw lx ly b">find()</code>界面是很有用的。当您可以使用内置时，人们通常会忘记它的存在，而使用一些强制性的查找方法。</p><p id="9290" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，语法与前两种方法几乎相同:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="dfc3" class="nt mh it ly b gy nu nv l nw nx">arr.find(callback(element[, index[, array]])[, thisArg])</span></pre><p id="20c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将返回符合条件的第一个项目，如果没有符合条件的项目，则返回<code class="fe lv lw lx ly b">undefined</code>。当有多个项目符合回调标准时，请注意。</p><p id="63ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以再次使用前面的例子。运行我们的<code class="fe lv lw lx ly b">greaterThan10</code>结合<code class="fe lv lw lx ly b">find()</code>将返回大于<code class="fe lv lw lx ly b">10</code>的第一个元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你只对元素的数组位置感兴趣，最好使用<code class="fe lv lw lx ly b">findIndex()</code>方法。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="11ae" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">7.变化</h1><p id="0937" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">shift()</code>方法简单直观。它只是从数组中移除第一项，然后将它返回。小心，因为它会改变你的数组对象。</p><p id="4bdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与<code class="fe lv lw lx ly b">pop()</code>有什么不同？接口<code class="fe lv lw lx ly b">pop()</code>将移除并返回数组的最后一个元素，而<code class="fe lv lw lx ly b">shift()</code>将移除并返回第一个元素。两者都确实改变了阵列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="495e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是FIFO实现的理想选择。您可以在一个数组中排列您的项目，并使用<code class="fe lv lw lx ly b">shift()</code>从队列中取出下一个项目。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="72d2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">8.松开打字机或键盘的字型变换键</h1><p id="78a0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这种方法与我们以前看到的完全相反。它不是移除一个项，而是将它添加到数组的开头。</p><p id="78b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">unshift()</code>和<code class="fe lv lw lx ly b">push()</code>的方法与<code class="fe lv lw lx ly b">shift()</code>和<code class="fe lv lw lx ly b">pop()</code>的方法相同。<code class="fe lv lw lx ly b">unshift()</code>将在开头添加元素，而<code class="fe lv lw lx ly b">push()</code>将在结尾添加元素。两者都会改变阵列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cfba" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">9.平面地图</h1><p id="c58d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在直接跳入<code class="fe lv lw lx ly b">flatMap()</code>之前，我们先了解一下<code class="fe lv lw lx ly b">flat()</code>的方法。</p><blockquote class="nd ne nf"><p id="87df" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">"<code class="fe lv lw lx ly b">flat()</code>方法创建了一个新数组，所有子数组元素递归地连接到其中，直到指定的深度。"— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat" rel="noopener ugc nofollow" target="_blank"> MDN </a></p></blockquote><p id="3a91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您需要展平数组时，这是最佳选择。它接受一个深度参数，您希望在该深度内展平数组。默认为<code class="fe lv lw lx ly b">1</code>。</p><p id="e1e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个例子，看看通过使用正确的方法，我们的代码是如何变得更加易读和简洁的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="cfcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在准备开始<code class="fe lv lw lx ly b">flatMap()</code>了。这种方法就像是<code class="fe lv lw lx ly b">map()</code>和<code class="fe lv lw lx ly b">flat()</code>组合的简写。</p><blockquote class="nd ne nf"><p id="27fc" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">flatMap()</code>方法返回一个新的数组，该数组是通过对数组的每个元素应用给定的回调函数，然后将结果平坦化一级而形成的。这与深度为1的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">map()</a></code>后跟一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat" rel="noopener ugc nofollow" target="_blank">flat()</a></code>是一样的，但是比分别调用这两个方法要稍微有效一些。— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap" rel="noopener ugc nofollow" target="_blank"> MDN </a></p></blockquote><p id="9338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="cc72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能够在一个函数中表达更多内容，而不会有任何性能损失。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="281e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">10.减少</h1><p id="25b8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">reduce()</code>方法是一种强大而灵活的方法。这个概念是redux管理库中的核心部分。</p><blockquote class="nd ne nf"><p id="760e" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">reduce()</code>方法对数组的每个元素执行一个reducer函数(您提供的),产生一个输出值— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noopener ugc nofollow" target="_blank"> MDN </a></p></blockquote><p id="af45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe lv lw lx ly b">reduce()</code>来模拟许多数组接口。您可以这样做并不意味着您必须这样做，因为内置的方法可读性更强，效率更高。</p><p id="fa7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了好玩，让我们使用<code class="fe lv lw lx ly b">reduce()</code>创建一个<code class="fe lv lw lx ly b">map()</code>等价物。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cd13" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">最后的想法</h1><p id="7819" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">JavaScript的数组API中有大量的数组方法。对它们中的每一个都有深刻的理解是很重要的。</p><p id="bb25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，在使用数组时，您需要问自己:</p><ul class=""><li id="2d1c" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">这是最适合我的特定场景的方法吗？</li><li id="c620" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">我想让我的对象变异吗？</li></ul><p id="e325" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用错误的方法可能会导致性能或内存下降。在小范围内，好处不太明显，但是一旦您的应用程序数据增长，您将开始看到性能提升。</p><p id="4cc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为软件工程师，我们有责任关注性能，而不仅仅是以一种野蛮的方式让事情运转起来。</p><p id="177f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干杯！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="54b3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">有关系的</h1><div class="om on gp gr oo op"><a rel="noopener  ugc nofollow" target="_blank" href="/5-common-javascript-memory-mistakes-c8553972e4c2"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">5个常见的JavaScript内存错误</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">避免应用程序内存泄漏的技巧</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">better编程. pub</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div></div></div>    
</body>
</html>