<html>
<head>
<title>Truffle * React * Monorepo With TypeScript: Build an Ethereum dApp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">truffle * React * mono repo With TypeScript:构建以太坊dApp</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/truffle-react-monorepo-with-typescript-4421039d4ba8?source=collection_archive---------7-----------------------#2022-01-10">https://betterprogramming.pub/truffle-react-monorepo-with-typescript-4421039d4ba8?source=collection_archive---------7-----------------------#2022-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e3aa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用TypeScript、Truffle、Ganache和React开始web3开发</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b67722d34da2818c9a2d11a5a5dcea16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DOTkmmkTtF3xX5lAtTIGzA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="29bf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有很多关于如何为dApp开发建立项目的例子。但是他们中的大多数仍然使用JavaScript。</p><p id="53df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我想使用TypeScript来获得更高的生产率和更好的代码质量。此外，我希望在一个回购中包含所有内容，并为我的代码提供一份有价值的覆盖报告。GitHub库可以在这里<a class="ae lr" href="https://github.com/mseemann/truffle-react-typescript" rel="noopener ugc nofollow" target="_blank">找到</a>——所以你可以把它作为你自己项目的起点。</p><h1 id="9431" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">积木</h1><p id="8932" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">让我们明确我们想要实现的目标:</p><ul class=""><li id="8cd8" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">块菌用于后端开发</li><li id="a63b" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">React用于客户端</li><li id="5f85" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">尽可能使用TypeScript而不是Javascript</li><li id="b9de" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">整个项目在一个根文件夹中——所以我们可以利用monorepo模式</li><li id="93dc" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">该项目托管在GitHub上，每次提交时，我们都要为整个项目运行测试和构建</li><li id="f4c3" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">代码质量通过代码覆盖率来衡量，并提交给<code class="fe nd ne nf ng b">coveralls</code></li></ul><p id="30ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您的机器上应该有什么:</p><ul class=""><li id="6d6a" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">我将使用yarn作为包管理器，但是你也可以使用npm</li><li id="0da8" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated"><code class="fe nd ne nf ng b">truffle</code>应全球安装</li><li id="f649" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated"><code class="fe nd ne nf ng b">ganache</code>应该可以在你的机器上找到</li></ul><p id="8d28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请参考<a class="ae lr" href="https://trufflesuite.com/" rel="noopener ugc nofollow" target="_blank">块菌文档</a>以了解如何在您的机器上安装块菌文档。</p><p id="4277" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要开始，只需创建项目根文件夹:<code class="fe nd ne nf ng b">mkdir truffle-react-typescript </code>和<code class="fe nd ne nf ng b">cd</code>。</p><h1 id="d923" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">后端</h1><p id="2289" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">后端会存在一个文件夹<code class="fe nd ne nf ng b">backend</code>。</p><p id="dfa8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，让我们创建文件夹并在其中运行<code class="fe nd ne nf ng b">truffle init</code>:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="d1e9" class="nl lt iq ng b gy nm nn l no np">mkdir backend<br/>cd backend</span><span id="6ed8" class="nl lt iq ng b gy nq nn l no np">truffle init</span></pre><p id="220d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将产生一个最低限度的松露项目。</p><p id="4401" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除此之外，我们还可以为它创建一个样本契约和一个相应的测试:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="1f53" class="nl lt iq ng b gy nm nn l no np">truffle create contract SampleContract<br/>truffle create test SampleContract</span></pre><p id="4088" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，迁移和测试文件都是作为JavaScript文件生成的。</p><p id="40fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们添加TypeScript特性之前，让我们将一些示例代码添加到我们的契约中，为我们的契约创建迁移，并检查一切是否按预期工作。</p><p id="0c8e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">契约只是存储和读取一个值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e4a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe nd ne nf ng b">1_initial_migration.js</code>旁边添加文件<code class="fe nd ne nf ng b">2_deploy_contracts.js</code>，并粘贴以下内容:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="c1d0" class="nl lt iq ng b gy nm nn l no np">var SampleContract = artifacts.require("SampleContract");<br/><br/>module.exports = function (deployer) {<br/>    deployer.deploy(SampleContract);<br/>};</span></pre><p id="6077" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用默认设置启动<a class="ae lr" href="https://trufflesuite.com/ganache/" rel="noopener ugc nofollow" target="_blank"> ganache </a>后，您应该能够无任何错误地运行<code class="fe nd ne nf ng b">truffle migrate</code>和<code class="fe nd ne nf ng b">truffle test</code>。</p><h2 id="4d19" class="nl lt iq bd lu nt nu dn ly nv nw dp mc le nx ny me li nz oa mg lm ob oc mi od bi translated">后端打字</h2><p id="cc00" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">首先，我们需要将后端项目初始化为节点项目。</p><p id="1dcb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只需在<code class="fe nd ne nf ng b">backend</code>文件夹中运行<code class="fe nd ne nf ng b">yarn init</code>——您可以使用提供的默认值。之后，我们可以添加所需的npm包来启用类型化功能。这些软件包是:</p><ul class=""><li id="859e" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated"><code class="fe nd ne nf ng b">typescript</code></li><li id="07cc" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">一些打字(<code class="fe nd ne nf ng b">truffle-typings</code>、<code class="fe nd ne nf ng b">@typechain/truffle-v5</code>、<code class="fe nd ne nf ng b">@types/bn.js, @types/chai</code>、<code class="fe nd ne nf ng b">@types/mocha</code>、<code class="fe nd ne nf ng b">@types/web3</code>)</li><li id="bfaa" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated"><code class="fe nd ne nf ng b">typechain</code></li></ul><p id="a67a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有这些都在一个命令中:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="1b16" class="nl lt iq ng b gy nm nn l no np">yarn add — dev typescript truffle-typings <a class="ae lr" href="http://twitter.com/typechain/truffle-v5" rel="noopener ugc nofollow" target="_blank">@typechain/truffle-v5</a>       <a class="ae lr" href="http://twitter.com/types/bn" rel="noopener ugc nofollow" target="_blank">@types/bn</a>.js <a class="ae lr" href="http://twitter.com/types/chai" rel="noopener ugc nofollow" target="_blank">@types/chai</a> <a class="ae lr" href="http://twitter.com/types/mocha" rel="noopener ugc nofollow" target="_blank">@types/mocha</a> <a class="ae lr" href="http://twitter.com/types/web3" rel="noopener ugc nofollow" target="_blank">@types/web3</a> typechain</span></pre><p id="63a0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们可以使用<code class="fe nd ne nf ng b">typechain</code>来生成我们的契约的类型定义。</p><p id="a290" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这应该在项目初始化后自动完成，因为我们不希望生成的代码成为git项目的一部分。</p><p id="eedb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这可以通过我们的<code class="fe nd ne nf ng b">package.json</code>中的<code class="fe nd ne nf ng b">postinstall</code>脚本来实现:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="f9b4" class="nl lt iq ng b gy nm nn l no np">"scripts": {<br/>  "generate-types": "typechain --target=truffle-v5 './build/contracts/*.json'",<br/>  "postinstall": "truffle compile &amp;&amp; yarn generate-types"<br/> },</span></pre><p id="f888" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，每次<code class="fe nd ne nf ng b">yarn install</code>针对我们的项目运行时，契约都被编译(这将在<code class="fe nd ne nf ng b">build</code>文件夹中生成契约<em class="oe"> </em> JSON文件),并且<code class="fe nd ne nf ng b">typechain</code>将在<code class="fe nd ne nf ng b">types</code>文件夹中生成类型定义。</p><p id="fbb3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">必须指定目标，以便生成的类型定义匹配我们的<code class="fe nd ne nf ng b">truffle</code>项目。稍后我们将为web3添加类型。</p><p id="9672" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看能否将单元测试转换成TypeScript。</p><p id="80d9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将文件<code class="fe nd ne nf ng b">sample_contract.js</code>重命名为<code class="fe nd ne nf ng b">sample_contract.ts</code>。现在将以下内容粘贴到其中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="100f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您检查IDE中的代码，您会发现没有可用的类型信息。</p><p id="426e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这可以通过项目文件夹中的适当的<code class="fe nd ne nf ng b">tsconfig.json</code>来解决:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6a69" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在测试应该可以工作了，即使它们是类型脚本文件，如果你的测试不再匹配solidity contracts API，你会得到编译错误。</p><p id="0091" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们想要合同测试的覆盖报告，我们可以使用<code class="fe nd ne nf ng b"><a class="ae lr" href="https://github.com/sc-forks/solidity-coverage" rel="noopener ugc nofollow" target="_blank">solidity-coverage</a></code>。</p><p id="27c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，让我们将它添加到我们的后端项目:<code class="fe nd ne nf ng b">yarn add — dev solidity-coverage</code>，并向包中添加一个脚本。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="88f1" class="nl lt iq ng b gy nm nn l no np">"coverage": "truffle run coverage"</span></pre><p id="b4a6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，我们需要告诉<code class="fe nd ne nf ng b">truffle</code>有一个新的插件可用。</p><p id="7229" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这需要在插件属性:<code class="fe nd ne nf ng b">plugins: [“solidity-coverage”]</code>内的<code class="fe nd ne nf ng b">truffle-config.js</code> <em class="oe"> </em>文件中完成。</p><p id="1d02" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果脚本现在被执行<code class="fe nd ne nf ng b">truffle test</code>被执行，覆盖率被测量并且结果被存储在项目中。报告以不同的格式生成。例如作为HTML:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/731726922c9f4d360077aea874922902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cgwH4Gxqxcd8XF1xKuD1sw.png"/></div></div></figure><p id="9eb6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将迁移脚本转换成TypeScript稍微复杂一点，因为truffle希望迁移文件夹中有<code class="fe nd ne nf ng b">*.js</code>文件。</p><p id="a4be" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了实现这一点，我们需要在运行迁移之前生成<code class="fe nd ne nf ng b">*.js</code>文件。这可以通过<code class="fe nd ne nf ng b">package.json</code>文件中的特殊脚本来实现:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="bd2f" class="nl lt iq ng b gy nm nn l no np">"migrate": "tsc -p ./tsconfig.migrate.json --outDir migrations &amp;&amp; truffle migrate",</span></pre><p id="c356" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另外，需要一个特殊的<code class="fe nd ne nf ng b">tsconfig</code>文件来包含类型定义。<code class="fe nd ne nf ng b">tsconfig.migrate.json</code>文件应该是:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="8cb6" class="nl lt iq ng b gy nm nn l no np">{<br/>  "extends": "./tsconfig.json",<br/>  "include": ["./migrations/*.ts", "./types/truffle-contracts/**/*.ts"]<br/>}</span></pre><p id="7f4e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如你所看到的，这个配置继承了默认的<code class="fe nd ne nf ng b">tsconfig</code>，并包含了<code class="fe nd ne nf ng b">*.ts</code>和类型定义文件。</p><p id="c104" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果运行迁移脚本,<code class="fe nd ne nf ng b">*.js</code>和<code class="fe nd ne nf ng b">*.map</code>文件将被写入迁移文件夹。</p><p id="6e27" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果存在同名的<code class="fe nd ne nf ng b">*.ts</code>文件，并且我已经从git中排除了生成的文件，我的IDE就会隐藏这些文件。如果这不适合您，您可以在<code class="fe nd ne nf ng b">truffle</code>配置中更改迁移文件夹。房产为<code class="fe nd ne nf ng b">migrations_directory</code>。</p><p id="7626" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样。后端现在已经完全类型化了，我们可以关心客户端了。</p><h1 id="2a91" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">客户</h1><p id="6257" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">要生成客户端存根，我们可以将<code class="fe nd ne nf ng b">react-script</code>与TypeScript模板一起使用:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="a6fe" class="nl lt iq ng b gy nm nn l no np">yarn create react-app client --template typescript</span></pre><p id="ae80" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是有趣的部分:所有相关文件已经是<code class="fe nd ne nf ng b">*.ts</code>或<code class="fe nd ne nf ng b">*.tsx</code>文件。因此，让我们开始构建一个示例应用程序来演示我们的后端契约的用法。</p><p id="d325" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们将使用web3，所以我们需要将web3库添加到客户端项目:<code class="fe nd ne nf ng b">yarn add web3</code>。<code class="fe nd ne nf ng b">App.tsx</code>文件将包含以下内容(一个非常简单的例子——肯定不适合真实的应用程序):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2a02" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可能已经注意到了，会有一堆打字错误。所以让我们来解决它们:</p><h2 id="aada" class="nl lt iq bd lu nt nu dn ly nv nw dp mc le nx ny me li nz oa mg lm ob oc mi od bi translated">纱线工作空间</h2><p id="e8b5" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">您可以看到我们引用了来自<code class="fe nd ne nf ng b">backend</code>项目的已编译合同。为了让这个工作，我们需要设置一个<code class="fe nd ne nf ng b">yarn workspace</code>。</p><p id="7ed6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在整个项目的根文件夹中放置一个<code class="fe nd ne nf ng b">package.json</code>，例如在文件夹<code class="fe nd ne nf ng b">backend</code>和<code class="fe nd ne nf ng b">client</code> <em class="oe">旁边。</em>内容应该是以下一条:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="1819" class="nl lt iq ng b gy nm nn l no np">{<br/>  "private": true,<br/>  "workspaces": {<br/>    "packages": [<br/>      "backend",<br/>      "client"<br/>    ],<br/>    "nohoist": [<br/>      "client/**"<br/>    ]<br/>  }<br/>}</span></pre><p id="0ff7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">删除现有的<code class="fe nd ne nf ng b">node_modules</code>文件文件夹和<code class="fe nd ne nf ng b">backend</code>和<code class="fe nd ne nf ng b">client</code>文件夹中的<code class="fe nd ne nf ng b">yarn.lock</code>文件，并将<code class="fe nd ne nf ng b">“backend”: “1.0.0”</code>作为依赖添加到客户端。</p><p id="4f33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦完成，从根文件夹运行<code class="fe nd ne nf ng b">yarn install</code>。您现在可以通过在导入中引用带有前缀<code class="fe nd ne nf ng b">backend</code>的文件来引用来自<code class="fe nd ne nf ng b">backend</code>项目的文件。</p><p id="5065" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不幸的是，<code class="fe nd ne nf ng b">nohoist</code>是必需的，因为<code class="fe nd ne nf ng b">backend</code>和<code class="fe nd ne nf ng b">client</code>提供的库之间存在类型冲突。</p><p id="188d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有可能将特定包装排除在提升之外。但我最终排除了完整的客户。如果你有更好的解决方案，请告诉我。</p><h2 id="7ab3" class="nl lt iq bd lu nt nu dn ly nv nw dp mc le nx ny me li nz oa mg lm ob oc mi od bi translated">我们合同的网络3打字</h2><p id="3709" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">下一个缺失的导入是来自<code class="fe nd ne nf ng b">backend</code>项目的类型<code class="fe nd ne nf ng b">SimpleContract</code>。这里我们需要的是<code class="fe nd ne nf ng b">web3</code>库的特殊类型定义。</p><p id="93d9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们必须将<code class="fe nd ne nf ng b">@typechain/web3</code>作为依赖项添加到我们的<code class="fe nd ne nf ng b">backend</code>项目中，并以我们为<code class="fe nd ne nf ng b">truffle</code>生成它们的相同方式生成它们。</p><p id="bc06" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这也应该在我们纱线项目的<code class="fe nd ne nf ng b">postinstall</code>阶段完成:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="36e0" class="nl lt iq ng b gy nm nn l no np">"generate-types-client": "./node_modules/.bin/typechain --target=web3-v1 './build/contracts/*.json'",<br/>"postinstall": "truffle compile &amp;&amp; yarn generate-types &amp;&amp; yarn generate-types-client",</span></pre><h2 id="9a2d" class="nl lt iq bd lu nt nu dn ly nv nw dp mc le nx ny me li nz oa mg lm ob oc mi od bi translated">提供window.ethereum的类型</h2><p id="7727" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">代码中的类型错误现在几乎已经修复。</p><p id="ea36" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编译器抱怨<code class="fe nd ne nf ng b">window</code>对象上的<code class="fe nd ne nf ng b">ethereum</code>属性。</p><p id="49c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以在r <em class="oe"> eact-app-env.d.ts </em>文件中添加所需的类型:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="791f" class="nl lt iq ng b gy nm nn l no np">interface Window {<br/>    ethereum: any;<br/>}</span></pre><p id="7934" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在代码应该编译没有任何错误，我们可以启动开发服务器。因为我们现在有了monorepo，所以我们可以从根项目启动dev服务器:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="1321" class="nl lt iq ng b gy nm nn l no np">yarn workspace client start</span></pre><p id="3628" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您的浏览器将会打开，并尝试与我们的合同进行交互。</p><p id="a4a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请确保元掩码连接到您的本地ganache实例，并且您的合同已部署。如果一切顺利，您应该在UI中看到存储的值。</p><p id="64ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只有一个小问题。当前版本5的<code class="fe nd ne nf ng b">react-script</code>在引擎盖下使用webpack 5。并且webpack 5不再为节点包提供<code class="fe nd ne nf ng b">polyfills</code>。</p><p id="9205" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是<code class="fe nd ne nf ng b">web3</code>需要它们，这样我们的代码才能工作。如果你遇到这个问题，请看看这个<a class="ae lr" href="https://github.com/ChainSafe/web3.js/issues/4659#issuecomment-1004660167" rel="noopener ugc nofollow" target="_blank">问题评论</a>。我已经描述了一个暂时解决这个问题的方法。</p><p id="e78c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于单元测试，<code class="fe nd ne nf ng b">package.json</code>中已经有一个脚本，如果我们想要客户项目的覆盖报告，我们可以提供一个特殊的选项，告诉<code class="fe nd ne nf ng b">react-scripts</code>生成报告:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="9bb1" class="nl lt iq ng b gy nm nn l no np">"coverage": "react-scripts test --coverage",</span></pre><p id="6df6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该报告被写入客户端文件夹中的<code class="fe nd ne nf ng b">coverage</code>目录。</p><h1 id="9cb9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">GitHub行动和工作服</h1><p id="e2bf" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">既然后端和客户端可以在本地测试、构建、部署和运行，让我们确保我们的monorepo有一个自动测试和构建流程。</p><p id="4c87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了尽可能简单，我们将使用GitHub动作，因为代码已经托管在GitHub上。我将只强调重要的方面。</p><h2 id="32ca" class="nl lt iq bd lu nt nu dn ly nv nw dp mc le nx ny me li nz oa mg lm ob oc mi od bi translated">缓存节点_模块</h2><p id="e778" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">作为开发人员，我们想要的是快速响应，如果我们的lint、测试和构建运行时没有任何错误。</p><p id="2f18" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">monorepo使运行一个<code class="fe nd ne nf ng b">yarn install</code>命令和缓存<code class="fe nd ne nf ng b">node_modules</code>文件夹成为可能，以备将来或后续ci运行。</p><p id="151d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，后端和客户端步骤可以并行运行。</p><p id="1b19" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了避免应用程序的每个部分执行两次<code class="fe nd ne nf ng b">yarn install</code>，我们可以运行一次，确保<code class="fe nd ne nf ng b">node_modules</code>文件夹被缓存，后端和客户端使用这些缓存的文件。这将看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/896dbb0cd0002b86dbc1fd60d086d60f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9sexbBbI2PG55oV9ddt4LQ.png"/></div></div></figure><p id="b1e7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在请忽略<code class="fe nd ne nf ng b">finish job</code>，因为我们稍后会处理它。<code class="fe nd ne nf ng b">prepare-dependencies</code>工作看起来是这样的:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="f048" class="nl lt iq ng b gy nm nn l no np">prepare-dependencies:<br/>  runs-on: ubuntu-latest<br/>  steps:<br/>    - uses: actions/checkout@v2<br/>    - name: Use Node.js<br/>      uses: actions/setup-node@v2<br/>      with:<br/>        node-version: '14'<br/>    - uses: actions/cache@v2<br/>      id: yarn-cache<br/>      with:<br/>        path: '**/node_modules'<br/>        key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}<br/>        restore-keys: |<br/>          ${{ runner.os }}-yarn-<br/>    - name: Install Deps<br/>      if: steps.yarn-cache.outputs.cache-hit != 'true'<br/>      run: yarn install --immutable --immutable-cache --check-cache</span></pre><p id="52ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在步骤checkout和<code class="fe nd ne nf ng b">node setup</code> <em class="oe"> </em>之后，一个缓存作业用来恢复缓存的<em class="oe"> </em> <code class="fe nd ne nf ng b">node_modules</code> <em class="oe"> </em>文件夹。这将恢复每个<code class="fe nd ne nf ng b"><em class="oe">node_module</em></code>文件夹的缓存，甚至包括子文件夹。如果缓存无法恢复(例如没有<code class="fe nd ne nf ng b">cache-hit</code>)，则执行<code class="fe nd ne nf ng b">yarn install</code>。</p><p id="ec19" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另外两个作业(后端和客户端)在<code class="fe nd ne nf ng b">prepare-dependencies</code>作业运行后执行。因此，我们可以始终确保缓存可用，并且不需要再次运行<code class="fe nd ne nf ng b">yarn install</code>。</p><p id="4e2f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是我们需要再次调用<code class="fe nd ne nf ng b">postinstall</code>脚本来编译solidity代码并生成我们的类型。</p><p id="4b2d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个工作的步骤都是一样的:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="f69a" class="nl lt iq ng b gy nm nn l no np">- uses: actions/cache@v2<br/>  id: yarn-cache<br/>  with:<br/>    path: '**/node_modules'<br/>    key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}<br/>    restore-keys: |<br/>      ${{ runner.os }}-yarn-<br/>- name: Run Postinstall<br/>  run: yarn workspace backend postinstall</span></pre><p id="7a4a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，我们不需要cd到子文件夹中。这由纱线工作区处理。</p><h2 id="cb55" class="nl lt iq bd lu nt nu dn ly nv nw dp mc le nx ny me li nz oa mg lm ob oc mi od bi translated">测试可靠性代码</h2><p id="7765" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">可靠性测试的执行需要一个正在运行的ganache实例和迁移的契约。</p><p id="b43f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，我们需要在执行可靠性测试之前启动一个<code class="fe nd ne nf ng b">ganache</code>实例。</p><p id="614c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以使用<code class="fe nd ne nf ng b">ganache-cli</code>包(<code class="fe nd ne nf ng b">yarn workspace backend add</code> <em class="oe"> — </em> <code class="fe nd ne nf ng b">dev ganache-cli</code>)。</p><p id="40d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">安装完成后，我们在<code class="fe nd ne nf ng b">package.json</code>中创建一个脚本:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="a6cb" class="nl lt iq ng b gy nm nn l no np">"ganache-cli": "ganache-cli -p 7545 --gasLimit=0x1fffffffffffff --allowUnlimitedContractSize -e 1000000000 &gt; /dev/null &amp;"</span></pre><p id="0118" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">..以及一个GitHub动作作业，它将启动ganache实例并停止作业执行，直到<code class="fe nd ne nf ng b">ganache</code>实例准备好在TCP端口接受调用:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="9a16" class="nl lt iq ng b gy nm nn l no np">- name: Start ganache<br/>  run: |<br/>    yarn workspace backend ganache-cli<br/>    while netstat -lnt | awk '$4 ~ /:7545/ {exit 1}'; do sleep 5; done</span></pre><p id="52f7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">果不其然，如果我们完成了所有其他工作，我们需要停止<code class="fe nd ne nf ng b">ganache</code>:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="bdb6" class="nl lt iq ng b gy nm nn l no np">- name: Stop ganache<br/>  run: kill $(lsof -t -i:7545)</span></pre><p id="ffd4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样。现在我们可以执行<code class="fe nd ne nf ng b">yarn workspace backend migrate</code>、<code class="fe nd ne nf ng b">test</code>和<code class="fe nd ne nf ng b">coveralls</code>。</p><h2 id="69c7" class="nl lt iq bd lu nt nu dn ly nv nw dp mc le nx ny me li nz oa mg lm ob oc mi od bi translated">monorepo的工作服</h2><p id="d808" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">执行CI作业后，我们可以将覆盖报告上传到<code class="fe nd ne nf ng b">coveralls</code>。我们唯一需要注意的是:我们有两个作业正在运行，并且希望<code class="fe nd ne nf ng b">coveralls</code>将结果组合起来，得到一个总的代码覆盖率。</p><p id="3e18" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于后端，我们定义了以下作业:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="9c66" class="nl lt iq ng b gy nm nn l no np">- name: Coveralls<br/>  uses: coverallsapp/github-action@master<br/>  with:<br/>    github-token: ${{ secrets.GITHUB_TOKEN }}<br/>    flag-name: Backend<br/>    path-to-lcov: ./backend/coverage/lcov.info<br/>    parallel: true</span></pre><p id="8000" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">连体工作服需要项目的读取权限。为此，我们可以使用自动生成的<code class="fe nd ne nf ng b">GITHUB_TOKEN</code>(默认权限是读/写。</p><p id="0d00" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果需要，可以在动作设置中将其更改为只读)。需要<code class="fe nd ne nf ng b">flag-name</code>来识别作业。我们需要告诉<code class="fe nd ne nf ng b">coverall</code>我们有并行运行的作业。</p><p id="2d08" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">客户端的代码是:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="4ba6" class="nl lt iq ng b gy nm nn l no np">- name: Coveralls<br/>  uses: coverallsapp/github-action@master<br/>  with:<br/>    github-token: ${{ secrets.GITHUB_TOKEN }}<br/>    flag-name: Client<br/>    path-to-lcov: ./client/coverage/lcov.info<br/>    parallel: true<br/>    base-path: ./client</span></pre><p id="1426" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，<code class="fe nd ne nf ng b">client</code>作业的<code class="fe nd ne nf ng b">flag-name</code>不同于后端作业。</p><p id="9c03" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们告诉工作服<code class="fe nd ne nf ng b">monorepo</code>中的客户端文件夹的<code class="fe nd ne nf ng b">base-path</code>来对齐路径信息。后端使用<code class="fe nd ne nf ng b">lcov.info</code>文件中的绝对路径信息，不需要这些额外的信息。</p><p id="090d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后一步是告诉工作服，所有的工作已经执行。如果<code class="fe nd ne nf ng b">backend</code>和<code class="fe nd ne nf ng b">client</code>作业已经完成，我们工作流程中的作业必须运行:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="da72" class="nl lt iq ng b gy nm nn l no np">finish:<br/>  needs: [backend, client]<br/>  runs-on: ubuntu-latest<br/>  steps:<br/>    - name: Coveralls Finished<br/>      uses: coverallsapp/github-action@master<br/>      with:<br/>        github-token: ${{ secrets.github_token }}<br/>        parallel-finished: true</span></pre><p id="b943" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们的工作流完成了，我们可以在工作服用户界面中看到组合的覆盖率结果，并有可能深入到每一行代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/badca7eecf8b3669a469848ef03c5e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4MPyU7hJkUG2dPAUMGTP2A.png"/></div></div></figure></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h1 id="6595" class="ls lt iq bd lu lv op lx ly lz oq mb mc jw or jx me jz os ka mg kc ot kd mi mj bi translated">结论——还有哪些可以改进的地方</h1><p id="a83e" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如您所见，获得完整的类型化代码和运行的工作流需要付出很多努力——比我想象的要多。值得吗？</p><p id="ff4f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我会说:是的。</p><p id="50f6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们现在可以依靠类型代码和两个受益于类型信息的项目(后端和客户端)。然而，它们是分开的，每个项目都有自己的职责。我们可以很容易地将不同的客户项目添加到我们的yarn工作空间中。</p><p id="9ab3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">目前的一个难点是客户端npm包的禁用提升，因为后端和客户端所需的包中的类型信息会导致类型冲突。</p><p id="a4d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请记住，他们使用不同的测试框架。此外，web3类型需要显式类型转换。也许<code class="fe nd ne nf ng b"><a class="ae lr" href="https://github.com/dethcrypto/eth-sdk" rel="noopener ugc nofollow" target="_blank">eth-sdk</a></code>项目可以克服这些限制。</p><p id="eaa4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你有任何改进上述方法的想法，请告诉我。</p><h1 id="0129" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">源代码</h1><p id="bd74" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">你会在这个<a class="ae lr" href="https://github.com/mseemann/truffle-react-typescript" rel="noopener ugc nofollow" target="_blank"> GitHub Repo </a>中找到当前的代码——只要分叉它。</p></div></div>    
</body>
</html>