<html>
<head>
<title>Dealing With Race Conditions In Chained API Calls Using Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Swift处理链式API调用中的竞争条件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dealing-with-race-conditions-in-chained-api-calls-96809839ec87?source=collection_archive---------11-----------------------#2022-08-04">https://betterprogramming.pub/dealing-with-race-conditions-in-chained-api-calls-96809839ec87?source=collection_archive---------11-----------------------#2022-08-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1f9b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用完成处理程序、递归和信号量示例进行解释</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/51ad5965726ae0cae4689a162fd589a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*spDxJtUUtx7UJKof78Ow3w.jpeg"/></div></div></figure><p id="3659" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将分享一些我在Nano Challenge 2应用程序<strong class="kt ir"> Colorio中处理链式API调用的经验。</strong>这里我将谈谈我处理它们的方法，以及可以使用的替代方法。</p><h1 id="b77d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">关键词</h1><ul class=""><li id="1bc1" class="mf mg iq kt b ku mh kx mi la mj le mk li ml lm mm mn mo mp bi translated">完成处理程序</li><li id="ac9a" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">递归</li><li id="762b" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">信号灯</li></ul><h1 id="e5a7" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">让我们从一个基本的API调用开始</h1><p id="8864" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">你有没有想过使用一个API并把它们的数据加载到一个表格视图中？通常你会在你的视图控制器中这样做:</p><p id="8e9e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从API获取的JSON数据示例:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="b8db" class="nd lo iq mz b be ne nf l ng nh">[<br/>  {<br/>    "id": 1,<br/>    "author": "Gregorius Albert",<br/>    "content": "This is my first tweet"<br/>  },<br/>  {<br/>    "id": 2,<br/>    "author": "Taylor Swift",<br/>    "content": "It's August baby"<br/>  },<br/>  {<br/>    "id": 3,<br/>    "author": "Justin Bieber",<br/>    "content": "What's about the Baby song thing?"<br/>  }<br/>]</span></pre><p id="e28c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从API获取数据并加载到表视图的代码是:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="275e" class="nd lo iq mz b be ne nf l ng nh">let url = URL(string: Helper.BASE_URL)!<br/>var request = URLRequest(url: url)<br/>request.httpMethod = "GET"<br/><br/>URLSession.shared.dataTask(with: request){ (data, response, error) in<br/><br/>    let json = try! JSONSerialization.jsonObject(with: data!) as! [[String:Any]]<br/>	<br/>    for result in json {<br/>        let author = result["author"] as! String<br/>        let content = result["content"] as! String<br/>        let tweet = Tweet(author: author, content: content)<br/>        self.tweets.append(tweet)<br/>    }<br/>	<br/>    DispatchQueue.main.async {<br/>        self.tableView.reloadData()<br/>    }<br/>	<br/>}.resume()</span></pre><p id="f946" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果API可以批量或集合地返回数据，那么这个解决方案是可行的。这就像在SQL数据库中做一个<code class="fe ni nj nk mz b">SELECT *</code>。</p><h1 id="bcf8" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">使用不提供批量数据的公共API</h1><p id="0441" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">但是如果您使用的是不提供批量数据的公共API呢？有些API只允许你根据一个参数获取一个数据。请看下面的例子。</p><p id="b84f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">API URL: <code class="fe ni nj nk mz b"><a class="ae nl" href="https://www.thecolorapi.com/id?hex=E62028" rel="noopener ugc nofollow" target="_blank">https://www.thecolorapi.com/id?hex=E62028</a></code></p><p id="e912" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">返回的结果:</p><pre class="kg kh ki kj gt my mz nm nn aw no bi"><span id="8509" class="np lo iq mz b gy nq nr l ns nh">{<br/>  "hex": {<br/>    "value": "#E62028",<br/>    "clean": "E62028"<br/>  },<br/>  "rgb": {<br/>    "fraction": {<br/>      "r": 0.9019607843137255,<br/>      "g": 0.12549019607843137,<br/>      "b": 0.1568627450980392<br/>    },<br/>    "r": 230,<br/>    "g": 32,<br/>    "b": 40,<br/>    "value": "rgb(230, 32, 40)"<br/>  },<br/>  "name": {<br/>    "value": "Alizarin Crimson",<br/>    "closest_named_hex": "#E32636",<br/>    "exact_match_name": false,<br/>    "distance": 349<br/>  }<br/>}<br/><br/>// Some value from the API have been deleted to shorten this article</span></pre><p id="de14" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，我从URL中给出的参数<code class="fe ni nj nk mz b"><a class="ae nl" href="https://www.thecolorapi.com/id?hex=E62028" rel="noopener ugc nofollow" target="_blank">E62028</a></code>中获取值。但是我需要一次得到多种颜色的数据。我该怎么做呢？</p><h1 id="d67f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">我所尝试的</h1><p id="8b4a" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">嗯，很多人可能认为“<em class="nt">只需循环API调用“</em>。从技术上讲，你可以像这样运行API调用。让我们尝试循环5个十六进制代码，并从数组中的每个十六进制代码获取颜色名称。</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="1a6b" class="nd lo iq mz b be ne nf l ng nh">let hexArr = ["FFFFFF", "000000", "FF0000", "00FF00", "0000FF"]<br/>// White, Black, Red, Green, Blue<br/><br/>for hex in hexArr {<br/>	fetchAPI(hexParam: hex)<br/>}<br/><br/>func fetchAPI(hexParam: String) -&gt; Void {<br/><br/>    let url = URL(string: "https://www.thecolorapi.com/id?hex=\(hexParam)")!<br/>    var request = URLRequest(url: url)<br/>    request.httpMethod = "GET"<br/>    <br/>    URLSession.shared.dataTask(with: request) { data, response, error in<br/>        <br/>        let json = try! JSONSerialization.jsonObject(with: data!) as! [String:Any]<br/>        <br/>        let name = json["name"] as! [String:Any]<br/>        let nameValue = name["value"] as! String<br/>        <br/>        DispatchQueue.main.async {<br/>            print(nameValue)<br/>        }<br/>                    <br/>    }.resume()<br/><br/>}</span></pre><p id="e224" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们希望得到的结果是:</p><pre class="kg kh ki kj gt my mz nm nn aw no bi"><span id="5b9f" class="np lo iq mz b gy nq nr l ns nh">White <br/>Black <br/>Red <br/>Green <br/>Blue</span></pre><p id="a13e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，它返回了:</p><pre class="kg kh ki kj gt my mz nm nn aw no bi"><span id="ef73" class="np lo iq mz b gy nq nr l ns nh">Black <br/>White <br/>Green <br/>Red <br/>Blue</span></pre><p id="f815" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们把所有的颜色都弄对了。但不是按顺序…如果您尝试再次运行该代码，它将以不同的顺序返回。</p><p id="c3a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">💡这种情况称为竞争情况。</p><p id="e721" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">竞争条件是指同时执行多个任务的情况。尽管我们已经在数组的序列中调用了<code class="fe ni nj nk mz b">fetchAPI()</code>，但是每个API调用的完成时间都不相同。</p><p id="b365" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们知道，每一个叫做<code class="fe ni nj nk mz b">URLSession</code>的都是异步运行的。因此，如果您需要循环调用有序，您必须操纵API调用。</p><h1 id="fa15" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">操纵API调用</h1><p id="4551" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">这里，<code class="fe ni nj nk mz b">URLSession</code>将在<code class="fe ni nj nk mz b">URLSession</code>关闭括号旁边的<code class="fe ni nj nk mz b">.resume()</code>被调用后异步运行另一个任务。所以理论上，你需要在URLSession的右括号前调用<code class="fe ni nj nk mz b">fetchAPI()</code>。</p><pre class="kg kh ki kj gt my mz nm nn aw no bi"><span id="eff0" class="np lo iq mz b gy nq nr l ns nh">URLSession.shared.dataTask(with: request) { data, response, error in<br/>	<br/>    let json = try! JSONSerialization.jsonObject(with: data!) as! [String:Any]<br/>    <br/>    let name = json["name"] as! [String:Any]<br/>    let nameValue = name["value"] as! String<br/>    <br/>    DispatchQueue.main.async {<br/>        print(nameValue)<br/>    }<br/>    <br/>    // MARK: The next API call should be here<br/>				<br/>}.resume()</span></pre><p id="9a7d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">理论上，实现这一点最简单的方法是使用递归。因为我们可以在指定的行中再次调用函数。</p><h1 id="f5e4" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">递归方法</h1><p id="a5e4" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">我个人在我的Nano Challenge 2应用程序Colorio中使用了这种方法。尽管这种方法有点狭隘，因为它是纯逻辑的，并且没有利用像队列和信号量这样的Swift特性。性能也可能是一个问题，因为递归中的内存管理并不是最好的。</p><p id="ff7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我是这样实现递归的:</p><ul class=""><li id="aec2" class="mf mg iq kt b ku kv kx ky la nu le nv li nw lm mm mn mo mp bi translated">设置何时停止递归的基本条件</li><li id="f19e" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">我们可以使用简单的<code class="fe ni nj nk mz b">if-else</code>或<code class="fe ni nj nk mz b">guard</code></li><li id="c29f" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">我们需要添加一个<code class="fe ni nj nk mz b">index</code>参数来标记何时停止</li><li id="1814" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">在右括号前递归该函数</li></ul><p id="0452" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">💡这里，函数将在5次函数调用后停止运行，这是数组内容的计数</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="4728" class="nd lo iq mz b be ne nf l ng nh">let hexArr = ["FFFFFF", "000000", "FF0000", "00FF00", "0000FF"]<br/>// White, Black, Red, Green, Blue<br/><br/>// Defining when the recursion needs to stop based on the array count<br/>let arrayCount = hexArr.count<br/><br/>// Calling the function<br/>fetchAPI(index: 0) <br/><br/>func fetchAPI(index: Int) -&gt; Void {<br/>    <br/>    // Guarding the function to stop after it reaches the array count<br/>    guard index &lt; arrayCount else { return }<br/><br/>    let url = URL(string: "https://www.thecolorapi.com/id?hex=\(hexArr[index])")!<br/>    var request = URLRequest(url: url)<br/>    request.httpMethod = "GET"<br/>    <br/>    URLSession.shared.dataTask(with: request) { data, response, error in<br/>        <br/>        let json = try! JSONSerialization.jsonObject(with: data!) as! [String:Any]<br/>        <br/>        let name = json["name"] as! [String:Any]<br/>        let nameValue = name["value"] as! String<br/>        <br/>        DispatchQueue.main.async {<br/>            print(nameValue)<br/>        }<br/>        <br/>        // Calling the recursion<br/>        fetchAPI(index: index+1)<br/>        <br/>    }.resume()<br/><br/>}</span></pre><p id="609f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如你所见，结果总是一致的。但是它们会一个接一个地缓慢加载。</p><pre class="kg kh ki kj gt my mz nm nn aw no bi"><span id="e128" class="np lo iq mz b gy nq nr l ns nh">White <br/>Black<br/>Red<br/>Green<br/>Blue</span></pre><p id="0b91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们尝试用另一种方式来实现顺序调用，信号量。</p><h1 id="7a5d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">信号量方法</h1><p id="72b2" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">在我们继续代码实现之前，这里有一些关于信号量的理论，来自<a class="ae nl" href="https://medium.com/@roykronenfeld/semaphores-in-swift-e296ea80f860" rel="noopener"> Roy Kronenfeld的文章</a>以帮助您快速了解:</p><blockquote class="nx ny nz"><p id="1075" class="kr ks nt kt b ku kv jr kw kx ky ju kz oa lb lc ld ob lf lg lh oc lj lk ll lm ij bi translated">信号量由一个线程队列和一个计数器值(Int类型)组成。</p><p id="8f05" class="kr ks nt kt b ku kv jr kw kx ky ju kz oa lb lc ld ob lf lg lh oc lj lk ll lm ij bi translated">信号量使用线程队列来跟踪FIFO顺序中等待的线程(<em class="iq">一旦共享资源可用，第一个进入队列的线程将是第一个访问共享资源的线程</em>)。</p><p id="3cd4" class="kr ks nt kt b ku kv jr kw kx ky ju kz oa lb lc ld ob lf lg lh oc lj lk ll lm ij bi translated">信号量使用计数器值来决定线程是否应该访问共享资源。当我们调用signal()或wait()函数时，计数器值会发生变化。</p><p id="2781" class="kr ks nt kt b ku kv jr kw kx ky ju kz oa lb lc ld ob lf lg lh oc lj lk ll lm ij bi translated"><strong class="kt ir">那么，什么时候应该调用wait()和signal()函数呢？</strong></p><p id="64d0" class="kr ks nt kt b ku kv jr kw kx ky ju kz oa lb lc ld ob lf lg lh oc lj lk ll lm ij bi translated">——来源:<a class="ae nl" href="https://medium.com/@roykronenfeld/semaphores-in-swift-e296ea80f860" rel="noopener">罗伊·克罗南菲尔德</a></p></blockquote><h1 id="52d3" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">代码实现</h1><p id="ab54" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">下面是我们初始化信号量所需的步骤:</p><ul class=""><li id="2906" class="mf mg iq kt b ku kv kx ky la nu le nv li nw lm mm mn mo mp bi translated"><code class="fe ni nj nk mz b">let semaphore = DispatchSemaphore(value: 1)</code></li><li id="7f65" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">根据队列数量为value参数赋值。在这里，因为我们希望按顺序执行，所以需要逐个对数组进行排队。因此将参数赋值为1。<code class="fe ni nj nk mz b">DispatchSemaphore(value: 1)</code></li><li id="00ef" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">将API调用封装到一个函数中。这里命名为<code class="fe ni nj nk mz b">fetchAPI(hexParam: String)</code></li><li id="c0b5" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">创建一个调用函数的循环</li><li id="e4d6" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">在调用<code class="fe ni nj nk mz b">fetchAPI(hexParam: String)</code>之前，分配<code class="fe ni nj nk mz b">semaphore.wait()</code>初始化队列</li><li id="5bc9" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">分配<code class="fe ni nj nk mz b">semaphore.signal()</code>继续<code class="fe ni nj nk mz b">.resume()</code>之前的队列</li></ul><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="39c9" class="nd lo iq mz b be ne nf l ng nh">let hexArr = ["FFFFFF", "000000", "FF0000", "00FF00", "0000FF"]<br/>// White, Black, Red, Green, Blue<br/><br/>// Assign the semaphore variable<br/>let semaphore = DispatchSemaphore(value: 1)<br/><br/>for hex in hexArr {<br/>    semaphore.wait() // Initiate the queue<br/>    fetchAPI(hexParam: hex)<br/>}<br/><br/>func fetchAPI(hexParam: String) -&gt; Void {<br/><br/>    let url = URL(string: "https://www.thecolorapi.com/id?hex=\(hexParam)")!<br/>    var request = URLRequest(url: url)<br/>    request.httpMethod = "GET"<br/>    <br/>    URLSession.shared.dataTask(with: request) { data, response, error in<br/>        <br/>        let json = try! JSONSerialization.jsonObject(with: data!) as! [String:Any]<br/>        <br/>        let name = json["name"] as! [String:Any]<br/>        let nameValue = name["value"] as! String<br/>        <br/>        DispatchQueue.main.async {<br/>            print(nameValue)<br/>        }<br/><br/>        semaphore.signal() // Continue the queue<br/>        <br/>    }.resume()<br/><br/>}</span></pre><h1 id="6f4a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">完成处理程序</h1><p id="2155" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">如果我们想在一个API调用中重用这个函数呢？我们怎样才能在函数中删除<code class="fe ni nj nk mz b">semaphore.signal()</code>，同时还能像以前一样在链接API调用时传递信号呢？</p><p id="2d52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于这种用法，我们可以使用完成处理程序。</p><p id="57e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">💡完成处理程序允许您将某些函数或代码行嵌入到函数中的任何位置，而不仅仅是在函数调用的末尾。</p><p id="1950" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在处理异步任务时，我们需要在参数中使用<code class="fe ni nj nk mz b">@escaping</code>来等待异步任务完成，然后运行我们的完成处理程序。如果我们不使用<code class="fe ni nj nk mz b">@escaping</code>,处理程序将立即运行，而不会在运行处理程序之前等待异步任务完成。</p><p id="6dce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们将<code class="fe ni nj nk mz b">finished()</code>处理程序放在一个异步的URLSession闭包内，没有<code class="fe ni nj nk mz b">@escaping</code>关键字，Xcode将返回一个错误:</p><pre class="kg kh ki kj gt my mz nm nn aw no bi"><span id="3dff" class="np lo iq mz b gy nq nr l ns nh">expression failed to parse:<br/>error: MyPlayground.playground:21:47: error: escaping closure captures non-escaping parameter 'finished'<br/>    URLSession.shared.dataTask(with: request) { data, response, error in<br/>                                              ^<br/><br/>MyPlayground.playground:15:47: note: parameter 'finished' is implicitly non-escaping<br/>func fetchAPIUsingSemaphore(hexParam: String, finished: () -&gt; Void) -&gt; Void {<br/>                                              ^<br/><br/>MyPlayground.playground:32:9: note: captured here<br/>        finished()<br/>        ^</span></pre><p id="ad31" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，下面是实现示例:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="a0b7" class="nd lo iq mz b be ne nf l ng nh">myFunction() {<br/>    // Code to inject to the function<br/>}<br/><br/>func myFunction(finished: @escaping() -&gt; Void) -&gt; Void {<br/><br/>    URLSession.shared.dataTask(with: request) { data, response, error in<br/>    <br/>        // Any process handling the data<br/>        <br/>        finished() // Put where you want any code injected to the function<br/>        <br/>    }.resume()<br/><br/>}</span></pre><p id="daa4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，我们想在<code class="fe ni nj nk mz b">fetchAPI</code>函数恢复之前注入<code class="fe ni nj nk mz b">semaphore.signal()</code>。</p><p id="781c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们可以创建一个闭包，并将信号放在闭包内，当代码到达<code class="fe ni nj nk mz b">finished().</code>时，闭包就会运行</p><p id="2db7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于单个API调用，只需调用函数并给它一个空闭包。</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="4cbb" class="nd lo iq mz b be ne nf l ng nh">let hexArr = ["FFFFFF", "000000", "FF0000", "00FF00", "0000FF"]<br/>// White, Black, Red, Green, Blue<br/><br/>let semaphore = DispatchSemaphore(value: 1)<br/><br/>// Looping and chaining the API Call<br/>for hex in hexArr {<br/>		semaphore.wait()<br/>    fetchAPI(hexParam: hex) {<br/>				// Injecting semaphore.signal to the function<br/>        semaphore.signal()<br/>    }<br/>}<br/><br/>// Single API Call. Just give an empty closure<br/>fetchAPI(hexParam: "FAFAFA"){}<br/><br/>func fetchAPI(hexParam: String, finished: @escaping() -&gt; Void) -&gt; Void {<br/><br/>    let url = URL(string: "https://www.thecolorapi.com/id?hex=\(hexParam)")!<br/>    var request = URLRequest(url: url)<br/>    request.httpMethod = "GET"<br/>    <br/>    URLSession.shared.dataTask(with: request) { data, response, error in<br/>        <br/>        let json = try! JSONSerialization.jsonObject(with: data!) as! [String:Any]<br/>        <br/>        let name = json["name"] as! [String:Any]<br/>        let nameValue = name["value"] as! String<br/>        <br/>        DispatchQueue.main.async {<br/>            print(nameValue)<br/>        }<br/>        <br/>        finished()<br/>        <br/>    }.resume()<br/><br/>}</span></pre><p id="9c41" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">瞧，竞争条件已经处理好了，您的API请求将按顺序获取。</p><p id="9b76" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读。</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="0d54" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Colorio是一个调色板生成器，为你的完美色彩日提供日常建议。我们建议从你的基础上选择完美的色调和巧妙的组合，增加个人风格的感觉。然后，您可以选择您需要的产品——您的底座，或者我们的精选产品。</p><p id="1957" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nt">这个应用程序主要由两个API提供支持，你可以在这里找到应用程序的源代码—</em><a class="ae nl" href="https://github.com/gal-bert/Colorio" rel="noopener ugc nofollow" target="_blank"><em class="nt">GitHub—gal-Bert/Colorio</em></a><em class="nt">。</em></p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="2b73" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nt">原载于</em><a class="ae nl" href="https://gist.github.com/gal-bert/474cadda5664bcbc41622fd84c9c252d" rel="noopener ugc nofollow" target="_blank"><em class="nt">http://github.com</em></a><em class="nt">。</em></p></div></div>    
</body>
</html>