<html>
<head>
<title>Promisification in JavaScript: How to and When is It Safe?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的允诺:如何以及何时是安全的？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/promisification-in-javascript-how-to-and-when-is-it-safe-1794e3c69b32?source=collection_archive---------4-----------------------#2022-04-26">https://betterprogramming.pub/promisification-in-javascript-how-to-and-when-is-it-safe-1794e3c69b32?source=collection_archive---------4-----------------------#2022-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="64b2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何将接受回调的函数变成承诺</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d3118bab32b3706f3e5a6a06c82bb50d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wo60eFEeNKs4OMd03bN7FA.png"/></div></div></figure><p id="2a15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为JavaScript开发人员，我们大多数人都讨厌使用回调。你们中的许多人可能听说过<a class="ae lq" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank">回调地狱</a>以及它如何破坏应用程序的可读性。如果我们正在编写代码，我们可以选择使用承诺，但是可能有内置函数或者来自外部库的函数使用回调。</p><p id="f324" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么不把它们变成承诺呢？</p><p id="b820" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我将向你展示如何做到这一点，以及什么时候这样做是安全的——因为这会带来一些后果。</p><h1 id="ef91" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">例子</h1><p id="373e" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">先说个例子。假设您有一个接受回调的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2c95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了运行这个函数，我们需要提供一个回调函数，它有两个参数——结果和潜在错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="64fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在假设您想在您漂亮的<code class="fe mr ms mt mu b">async/await</code>代码中使用它。有两条路可以走。</p><h1 id="cf2b" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">短路径</h1><p id="c5e8" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">最好也是最简单的方法是使用一个已经实现的方法，将接受回调的函数转换成承诺。如果你正在使用node.js，在<code class="fe mr ms mt mu b">utils</code>包中有适合它的<code class="fe mr ms mt mu b">promisify</code>方法。在前端，你可以使用一个流行的<a class="ae lq" href="https://www.npmjs.com/package/es6-promisify" rel="noopener ugc nofollow" target="_blank"> es6-promisify </a>包。</p><p id="f717" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">来自<code class="fe mr ms mt mu b">utils</code>的<code class="fe mr ms mt mu b">promisify</code>的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="fc0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用<code class="fe mr ms mt mu b">promisify</code>后，我们的功能变成了承诺。我们现在可以在它上面使用<code class="fe mr ms mt mu b">.then</code> / <code class="fe mr ms mt mu b">.catch</code>或者<code class="fe mr ms mt mu b">await</code> / <code class="fe mr ms mt mu b">try-catch</code>。</p><blockquote class="mv mw mx"><p id="d61c" class="ku kv lr kw b kx ky ju kz la lb jx lc my le lf lg mz li lj lk na lm ln lo lp im bi translated">使用内置<code class="fe mr ms mt mu b">promisify</code>时，你要承诺的函数必须遵循一个标准:<br/> 1。将callback作为最后一个参数。<br/> 2。回调需要以这种精确的顺序将错误和结果作为参数。<br/>你可以在这里阅读如何克服这个限制<a class="ae lq" href="https://nodejs.org/dist/latest-v8.x/docs/api/util.html#util_custom_promisified_functions" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="37f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是…引擎盖下到底发生了什么？</p><h1 id="4a5e" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">手动路径</h1><p id="91cd" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">为了更好地理解它，让我们自己来承诺一下所提供的功能。让我们从定义我们想如何称呼它开始。这将类似于<code class="fe mr ms mt mu b">utils</code>中的<code class="fe mr ms mt mu b">promisify</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8cd9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是<code class="fe mr ms mt mu b">customPromisify</code>的一个可能实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="c098" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有点复杂，我们来分解一下。</p><ol class=""><li id="012d" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated"><code class="fe mr ms mt mu b">line #2</code> : <code class="fe mr ms mt mu b"> customPromisify</code>返回一个函数，我们将把原始函数的参数传递给它。在给定的例子中，<code class="fe mr ms mt mu b">'a'</code>和<code class="fe mr ms mt mu b">'b'</code>参数将出现在<code class="fe mr ms mt mu b">args</code>数组中。</li><li id="fd26" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe mr ms mt mu b">line #3</code>:返回的函数返回一个承诺，所以我们可以给它附加<code class="fe mr ms mt mu b">.then</code>和<code class="fe mr ms mt mu b">.catch</code>(或者使用<code class="fe mr ms mt mu b">await</code>)。</li><li id="e6d3" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe mr ms mt mu b">lines #4–7</code>:在一个承诺中，我们创建了一个定制的回调函数，它将相应地<code class="fe mr ms mt mu b">resolve</code>或<code class="fe mr ms mt mu b">reject</code>一个承诺。</li><li id="7fbc" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe mr ms mt mu b">line #8</code>:然后我们需要将自定义回调添加到参数列表中，这样它就被传递给一个函数(<code class="fe mr ms mt mu b">fn</code>)并在需要时执行。</li><li id="d9eb" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe mr ms mt mu b">line #9</code>:最后，我们在包含<code class="fe mr ms mt mu b">customCallback</code>的<code class="fe mr ms mt mu b">args</code>数组上调用提供的函数(<code class="fe mr ms mt mu b">fn</code>)。</li></ol><p id="e0c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样！我们有一种方法来约定一个函数。<code class="fe mr ms mt mu b">customPromisify</code>可扩展接受更多回调或非标准回调。</p><blockquote class="mv mw mx"><p id="9815" class="ku kv lr kw b kx ky ju kz la lb jx lc my le lf lg mz li lj lk na lm ln lo lp im bi translated">如果你想看更多自定义的promisification的例子，你可以查看<a class="ae lq" href="https://medium.com/@bsalwiczek/how-to-develop-react-chrome-extension-for-medium-in-26-steps-d0401149e3a2" rel="noopener">如何在26个步骤中为媒体开发React Chrome扩展</a>中的第10个步骤。</p></blockquote><p id="202f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在你知道<em class="lr">如何</em>了。让我们来回答<em class="lr">什么时候</em>去做。</p><h1 id="0118" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">承诺什么时候安全？</h1><p id="3a8a" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">要回答这个问题，我们需要认识到承诺和回电之间的一个重要区别。</p><blockquote class="np"><p id="f344" class="nq nr it bd ns nt nu nv nw nx ny lp dk translated">承诺只能有<strong class="ak">一个</strong>结果，而回调可能被调用<strong class="ak">多次</strong>。</p></blockquote><p id="fe5b" class="pw-post-body-paragraph ku kv it kw b kx nz ju kz la oa jx lc ld ob lf lg lh oc lj lk ll od ln lo lp im bi translated">结果是，在将接受回调的函数更改为承诺时，您需要非常小心。在承诺之后，有些功能可能不会像你想的那样发挥作用。</p><h2 id="c9c5" class="oe lt it bd lu of og dn ly oh oi dp mc ld oj ok me lh ol om mg ll on oo mi op bi translated">不安全承诺</h2><p id="806f" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">你知道<code class="fe mr ms mt mu b">setInterval()</code>功能吗？它将一个自定义函数作为回调函数，每隔X毫秒执行一次。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="18e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它将在每个<code class="fe mr ms mt mu b">1000ms</code>打印<code class="fe mr ms mt mu b">"test"</code>，直到您终止该进程或使用<code class="fe mr ms mt mu b">clearInterval()</code>。</p><p id="8811" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们把它变成一个承诺:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="b85e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mr ms mt mu b">customPromisify</code>针对这种情况做了一点改动。回调现在只接受一个参数。它也被作为第一个参数添加到<code class="fe mr ms mt mu b">args</code>列表中，因此它匹配<code class="fe mr ms mt mu b">setInterval</code>的实现方式。</p><p id="0cec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是上面代码的执行过程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/7c4c4f86d10a9a5dcd6b4f0c9d2abff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lqiClnfPuhnqjbiDa0lGwg.png"/></div></div></figure><p id="96f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mr ms mt mu b">"test"</code>打印一次，因为承诺只能解决一次。而且setInterval从来不清零，所以程序挂起。</p><h2 id="13e6" class="oe lt it bd lu of og dn ly oh oi dp mc ld oj ok me lh ol om mg ll on oo mi op bi translated">结论</h2><p id="f2a7" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated"><code class="fe mr ms mt mu b">setInterval</code>不是许诺的好人选。实际上，任何多次调用回调函数的函数都不应该被承诺。</p><h1 id="5451" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">最终注释</h1><p id="3eeb" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">我希望在读完这篇文章后，你能理解如何把一个接受回调的函数变成一个承诺。更重要的是，您现在知道它并不总是安全的，所以您应该仔细查看文档，并检查回调现在是否将被多次执行。</p></div></div>    
</body>
</html>