<html>
<head>
<title>Understanding fuzzing in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解围棋中的模糊</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/fuzzing-in-go-40796a54dc8b?source=collection_archive---------3-----------------------#2022-08-07">https://betterprogramming.pub/fuzzing-in-go-40796a54dc8b?source=collection_archive---------3-----------------------#2022-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6257" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">动作中的模糊</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ae0cb6229222f460c53a4e10eeffac81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5xYF4N4X3GunR4YX"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@huefnerdesign?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tim Hüfner </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="c5dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">"模糊测试是发现软件应用程序中安全漏洞或缺陷的一种新方法."</p><p id="1ba9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模糊化的概念是在1988年提出的，当时巴顿·米勒教授和他的学生发现，一个操作系统“在受到随机的意外输入时通常会崩溃。”</p><p id="bb7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模糊测试通过使用提供的种子数据为函数生成输入。这是从代码中发现意外行为的好方法。当我第一次看到fuzzing的概念时，我认为这将是一个自动化测试的好方法。</p><p id="f5ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了将这个想法放入上下文中，我发现在过去很难想到测试输入案例，fuzzing似乎是一个自动化的好方法。模糊化不是不实现<code class="fe ls lt lu lv b">Unit</code>和其他形式测试的借口，因为模糊化会为函数生成输入。</p><p id="4ae4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Fuzzing是在Go 1.18中引入的，所以我有点迟到了。在这篇文章中，我将尝试描述模糊化的一个基本用例。</p><h1 id="8bf1" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">CSV行解析器</h1><p id="e48b" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">对于我的用例，我将编写一个解析CSV行的函数。</p><p id="8161" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数将采用逗号分隔的字符串，并处理一些数据。</p><p id="d98b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数将尝试将第一列转换为int，并将<code class="fe ls lt lu lv b">Senegal</code>追加到第三列的值中。</p><p id="990b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第三列代表没有指定国家的地址。</p><p id="7041" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是该函数的样子:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="b597" class="mx lx iq lv b gy my mz l na nb">package fuzzing</span><span id="972a" class="mx lx iq lv b gy nc mz l na nb">import (<br/> "strings"<br/> "strconv"<br/>)</span><span id="7139" class="mx lx iq lv b gy nc mz l na nb">func ParseString(s string) error {<br/>  parts := strings.Split(s, ",")</span><span id="88df" class="mx lx iq lv b gy nc mz l na nb">  _, err := strconv.Atoi(parts[0])</span><span id="b211" class="mx lx iq lv b gy nc mz l na nb"> if err != nil {<br/>  return err<br/> }</span><span id="626c" class="mx lx iq lv b gy nc mz l na nb"> parts[2] += ", Senegal"</span><span id="7981" class="mx lx iq lv b gy nc mz l na nb"> return nil<br/>}</span></pre><p id="b072" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我有了我的函数，我将继续定义模糊测试。与单元测试不同，我必须为fuzzer提供种子数据。</p><p id="13e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的函数<code class="fe ls lt lu lv b">ParseString</code>中，我提供了2个逗号分隔的CSV行，3列。</p><p id="9f08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在编写模糊测试时，用下面的格式命名测试是很重要的<code class="fe ls lt lu lv b">FuzzXxx</code>。我让测试检查来自函数<code class="fe ls lt lu lv b">ParseString</code>的错误。</p><p id="a65f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是测试文件:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="433c" class="mx lx iq lv b gy my mz l na nb">package fuzzing</span><span id="ba0a" class="mx lx iq lv b gy nc mz l na nb">import (<br/> "testing"<br/>)</span><span id="08bc" class="mx lx iq lv b gy nc mz l na nb">func <strong class="lv ir">FuzzParseString</strong>(f *testing.F){<br/> f.<strong class="lv ir">Add</strong>("1, Name, 23rd Fifth Street")<br/> f.<strong class="lv ir">Add</strong>("2, Name2, 1 Main street")</span><span id="6e04" class="mx lx iq lv b gy nc mz l na nb"> f.Fuzz(func(t *testing.T, s string){<br/>    err := <strong class="lv ir">ParseString</strong>(s)</span><span id="e58e" class="mx lx iq lv b gy nc mz l na nb">    if err != nil {<br/>     t.Errorf("%v", err)<br/>    }<br/> })<br/>}</span></pre><p id="df85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名程序员，我最大的弱点是无法理解边缘情况。所以当我运行测试时，第一次运行就失败了。</p><p id="26a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我检查提供的数据时，提供了一个空字符串。</p><p id="d38c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是测试的输出:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="f88d" class="mx lx iq lv b gy my mz l na nb">cheikh@cheikh-s5-1110:~/go/src/fuzzing$ go test -fuzz FuzzParseString<br/>fuzz: elapsed: 0s, gathering baseline coverage: 0/8 completed<br/>fuzz: minimizing 41-byte failing input file<br/>fuzz: elapsed: 0s, gathering baseline coverage: 2/8 completed<br/>--- FAIL: FuzzParseString (0.01s)<br/>    --- FAIL: FuzzParseString (0.00s)<br/>        testing.go:1349: panic: runtime error: index out of range [2] with length 1<br/>            goroutine 33 [running]:<br/>            runtime/debug.Stack()<br/>             /usr/lib/go-1.18/src/runtime/debug/stack.go:24 +0x90<br/>            testing.tRunner.func1()<br/>             /usr/lib/go-1.18/src/testing/testing.go:1349 +0x1f2<br/>            panic({0x5b3700, 0xc000116210})<br/>             /usr/lib/go-1.18/src/runtime/panic.go:838 +0x207<br/>            fuzzing.ParseString({0x6dcc20?, 0xc00008ea50?})<br/>             /home/cheikh/go/src/fuzzing/lib.go:17 +0x105<br/>            fuzzing.FuzzParseString.func1(0xc000130680, {0x6dcc20, 0x1})<br/>             /home/cheikh/go/src/fuzzing/lib_test.go:12 +0x45<br/>            reflect.Value.call({0x594a60?, 0x5cfb08?, 0x13?}, {0x5c17a6, 0x4}, {0xc00008f050, 0x2, 0x2?})<br/>             /usr/lib/go-1.18/src/reflect/value.go:556 +0x845<br/>            reflect.Value.Call({0x594a60?, 0x5cfb08?, 0x514?}, {0xc00008f050, 0x2, 0x2})<br/>             /usr/lib/go-1.18/src/reflect/value.go:339 +0xbf<br/>            testing.(*F).Fuzz.func1.1(0x0?)<br/>             /usr/lib/go-1.18/src/testing/fuzz.go:337 +0x231<br/>            testing.tRunner(0xc000130680, 0xc0000e8990)<br/>             /usr/lib/go-1.18/src/testing/testing.go:1439 +0x102<br/>            created by testing.(*F).Fuzz.func1<br/>             /usr/lib/go-1.18/src/testing/fuzz.go:324 +0x5b8</span></pre><p id="f04e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">fuzzer检测到运行时问题。考虑到这个错误，我将再次编辑我的函数以支持空的或不完整的字符串。新函数将如下所示:(新增加的内容以粗体显示)</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="3a9e" class="mx lx iq lv b gy my mz l na nb">func ParseString(s string) error {<br/>  parts := strings.Split(s, ",")</span><span id="b514" class="mx lx iq lv b gy nc mz l na nb">  <strong class="lv ir">if(len(parts) &lt; 3){<br/>    return errors.New("Invalid string")<br/>  }</strong></span><span id="3975" class="mx lx iq lv b gy nc mz l na nb">  _, err := strconv.Atoi(parts[0])</span><span id="bd57" class="mx lx iq lv b gy nc mz l na nb">  if err != nil {<br/>    return err<br/>  }</span><span id="7413" class="mx lx iq lv b gy nc mz l na nb">  parts[2] += ", Senegal"</span><span id="89b0" class="mx lx iq lv b gy nc mz l na nb">  return nil<br/>}</span></pre><p id="bb57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的程序将返回一个错误的错误字符串，但我不希望我的fuzzer就此打住。为此，如果返回的错误是<code class="fe ls lt lu lv b">Invalid string</code>，我将添加一个提前返回。下面是更新后的测试函数:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="3b8e" class="mx lx iq lv b gy my mz l na nb">func FuzzParseString(f *testing.F){<br/>  f.Add("1, Name, 23rd Fifth Street")<br/>  f.Add("2, Name2, 1 Main street")</span><span id="8393" class="mx lx iq lv b gy nc mz l na nb">  f.Fuzz(func(t *testing.T, s string){<br/>    err := ParseString(s)</span><span id="d8fc" class="mx lx iq lv b gy nc mz l na nb">    if err != nil {</span><span id="a339" class="mx lx iq lv b gy nc mz l na nb">      <strong class="lv ir">if err.Error() == "Invalid string" {<br/>        return<br/>      }</strong></span><span id="d0c4" class="mx lx iq lv b gy nc mz l na nb">      t.Errorf("%v", err)<br/>    }  <br/>  })<br/>}</span></pre><p id="a661" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重新运行后，fuzzer通过提供以下输入<code class="fe ls lt lu lv b">string(",,")</code>检测到另一个问题。以下是终端的输出:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="df95" class="mx lx iq lv b gy my mz l na nb">cheikh@cheikh-s5-1110:~/go/src/fuzzing$ go test -fuzz FuzzParseString<br/>fuzz: elapsed: 0s, gathering baseline coverage: 0/8 completed<br/>fuzz: elapsed: 0s, gathering baseline coverage: 8/8 completed, now fuzzing with 2 workers<br/>fuzz: minimizing 61-byte failing input file<br/>fuzz: elapsed: 0s, minimizing<br/>--- FAIL: FuzzParseString (0.02s)<br/>    --- FAIL: FuzzParseString (0.00s)<br/>        lib_test.go:20: strconv.Atoi: parsing "": invalid syntax<br/>    <br/>    Failing input written to testdata/fuzz/FuzzParseString/74498b2a8282174de6870175ab847ba882cd8356506d60b9a28f23ec8e721c76<br/>    To re-run:<br/>    go test -run=FuzzParseString/74498b2a8282174de6870175ab847ba882cd8356506d60b9a28f23ec8e721c76<br/>FAIL<br/>exit status 1<br/>FAIL fuzzing 0.025s</span></pre><p id="1110" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我设法找到了一个绕过丢失的ID bug的方法，fuzzer会找到其他bug吗？</p><p id="9ab8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">fuzzer发现的下一个问题是给第一列分配一个非数字值。我可以不断重复这个过程，直到代码稳定。</p><p id="a1b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是起毛的好处。下面是我的测试的另一个输出:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="d49b" class="mx lx iq lv b gy my mz l na nb">cheikh@cheikh-s5-1110:~/go/src/fuzzing$ go test -fuzz FuzzParseString<br/>fuzz: elapsed: 0s, gathering baseline coverage: 0/10 completed<br/>fuzz: elapsed: 0s, gathering baseline coverage: 10/10 completed, now fuzzing with 2 workers<br/>fuzz: minimizing 46-byte failing input file<br/>fuzz: elapsed: 0s, minimizing<br/>--- FAIL: FuzzParseString (0.02s)<br/>    --- FAIL: FuzzParseString (0.00s)<br/>        lib_test.go:20: strconv.Atoi: parsing "A": invalid syntax<br/>    <br/>    Failing input written to testdata/fuzz/FuzzParseString/215375fdfbd654b9fd5b654b45a8676d2b81e538d2a852773673a3713deb50a6<br/>    To re-run:<br/>    go test -run=FuzzParseString/215375fdfbd654b9fd5b654b45a8676d2b81e538d2a852773673a3713deb50a6<br/>FAIL<br/>exit status 1<br/>FAIL fuzzing 0.025s</span></pre><h1 id="4fbe" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="99fd" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">测试是围棋的核心部分。有没有可能不经过测试就写出一个程序？是的，如果你想牺牲你的节目质量。</p><p id="a2d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Fuzzing使开发人员能够测试意外情况。它不会取代其他类型的测试，而是对其进行补充。这是增加测试覆盖率和识别测试用例的好方法。</p><p id="4800" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在编写了漂亮的惯用代码后，我们可能会有点精疲力尽地生成测试用例，这就是fuzzing的亮点。</p><p id="5342" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的是，测试包不支持复杂类型，这是我希望在未来看到的。</p><h1 id="d745" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">参考</h1><div class="nd ne gp gr nf ng"><a href="https://about.gitlab.com/topics/devsecops/what-is-fuzz-testing/" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">什么是模糊测试？</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">模糊测试是发现软件应用程序中安全漏洞或错误的一种新方法。不同于传统的…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">about.gitlab.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu kp ng"/></div></div></a></div><div class="nd ne gp gr nf ng"><a href="https://github.com/cheikhshift/medium_examples/tree/main/fuzzing" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">medium _ examples/在主cheikhshift/medium_examples处模糊化</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">中型文章的代码示例。在GitHub上创建一个帐户，为cheikhshift/medium_examples开发做贡献。</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">github.com</p></div></div><div class="np l"><div class="nv l nr ns nt np nu kp ng"/></div></div></a></div><div class="nd ne gp gr nf ng"><a href="https://go.dev/doc/fuzz/#glos-fuzz-test" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">Go Fuzzing-Go编程语言</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">从Go 1.18开始，Go在其标准工具链中支持模糊化。OSS-模糊支持本地Go模糊测试。尝试…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">go.dev</p></div></div><div class="np l"><div class="nw l nr ns nt np nu kp ng"/></div></div></a></div></div></div>    
</body>
</html>