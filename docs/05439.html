<html>
<head>
<title>Dynamic Programming Interview Questions: Levenshtein Distance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态规划面试问题:Levenshtein距离</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dynamic-programming-interview-questions-levenshtein-distance-d415cb5e36ca?source=collection_archive---------8-----------------------#2020-07-08">https://betterprogramming.pub/dynamic-programming-interview-questions-levenshtein-distance-d415cb5e36ca?source=collection_archive---------8-----------------------#2020-07-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d17f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">找出两个单词之间的距离</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bb78adb6faf0e8e0ebe153b3c31158ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XmXmpURhnbIIGK3X"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">努诺·安图内斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="0f92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说起来很难过，但是这个系列终于要结束了。我决定结束它，因为我不想拖太久，也因为我认为7是一个很好的结束数字。幸运七号，你知道吗？</p><p id="2609" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，今天的问题是，我们来看看如何计算两个单词之间的Levenshtein距离(又名编辑距离)。</p><blockquote class="lv lw lx"><p id="a861" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">两个单词之间的Levenshtein距离(也称为编辑距离)是将一个单词变为另一个单词所需的最小单字符编辑次数(插入、删除或替换)— <a class="ae ky" href="https://en.wikipedia.org/wiki/Levenshtein_distance#" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="5776" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">问题是</h1><p id="06f5" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">注:此问题来自<a class="ae ky" href="https://leetcode.com/problems/edit-distance/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>。</p><blockquote class="lv lw lx"><p id="57cd" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">给定两个单词word1和word2，找出将word1转换为word2所需的最少运算次数。</p><p id="c8ea" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">您可以对一个单词进行以下3种操作:</p><p id="54bc" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">插入一个字符</p><p id="8106" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">删除一个字符</p><p id="eecc" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">替换一个字符</p><p id="e2ee" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">示例1:</p><p id="9989" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">输入:word1 = "horse "，word2 = "ros "</p><p id="5dc8" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">输出:3</p><p id="3d52" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">解释:</p><p id="5ccf" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">horse -&gt; rorse(将“h”替换为“r”)</p><p id="0fa2" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">rorse -&gt; rose(删除“r”)</p><p id="5382" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">玫瑰-&gt;玫瑰(去掉‘e’)</p><p id="a8ba" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">示例2:</p><p id="632b" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">输入:word1 =“意图”，word2 =“执行”</p><p id="9283" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">输出:5</p><p id="93e7" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">解释:</p><p id="df9d" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">意向-&gt; inention(去掉‘t’)</p><p id="f72b" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">inention -&gt; enention(用“e”替换“I”)</p><p id="0a2d" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">延伸-&gt;延伸(用“x”替换“n”)</p><p id="e237" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">执行-&gt;执行(用“c”替换“n”)</p><p id="0e4e" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">执行-&gt;执行(插入' u ')</p></blockquote><p id="527b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的目标似乎很简单，但是和大多数动态编程问题一样，围绕解决方案建立基础是最困难的。</p><p id="6c81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我应该在本系列的开始提到这一点，但迟做总比不做好:动态规划问题非常适用于具有最优子结构特性的问题——给定子问题的最优解，就可以找到问题的最优解，我们在分治型问题中也看到了这一特性。不同之处在于，在动态规划中，子问题是重叠的，因此一个子问题需要另一个子问题的解决方案，这使得记忆/列表对于降低时间复杂度非常有用。</p><p id="a1c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是意味着解决任何DP问题的关键是首先尝试将主要问题分解成子问题。很容易，我们应该看到这一点:</p><ul class=""><li id="19f3" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">问题:通过对word1 (word2)执行插入、删除或替换操作，将word1转换为word2。</li><li id="9aaa" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">子问题:通过对word1执行插入、删除或替换操作，将word1[: i]转换为word2[: j]。</li></ul><p id="2fda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经分解了问题，我们需要建立基本案例。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="6a82" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">基础案例</h1><p id="ed99" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">word1或word2是空字符串。</p><ul class=""><li id="3946" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">如果word1是一个空字符串，那么我们要在word1中插入<em class="ly"> k </em>个字符，其中<em class="ly">k</em>= word 2的长度，所以我们这里的代价是<em class="ly"> k </em>。</li><li id="024f" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">如果word2是空字符串，那么我们要从word1中删除<em class="ly"> k </em>个字符，其中<em class="ly">k</em>= word 1的长度，所以我们这里的代价也是<em class="ly"> k </em>。</li></ul></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="636e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">数据结构和制表</h1><p id="3fb4" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">但是现在我们需要在某个地方存储我们的基本案例，那么什么是一个好的数据结构来表示它呢？当比较两个事物时，通常矩阵做得很好，对吗？一个字符串可以在一个轴上，另一个字符串可以在第二个轴上，该值可以是两个字符串之间的Levenshtein距离。例如，对于本田和现代，我们有:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/bc3a6b92e1c6d4021a34060b0a3b622e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/0*JtHCR3IZT0tkp2Hd"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://www.cuelogic.com/blog/the-levenshtein-algorithm" rel="noopener ugc nofollow" target="_blank"> Cuelogic </a>。</p></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="cb53" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">一路向上</h1><p id="04fc" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当我们向上发展时，有时考虑解决方案表的递归定义是有用的。我们知道我们的基本情况，但是递归情况下是什么？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="78e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<em class="ly"> n </em>和<em class="ly"> m </em>的数值。通过零索引，这意味着我们有一个矩阵<em class="ly"> (n+1) * (m+1) </em>。这是因为我们希望包括空字符串的情况(即，<code class="fe nx ny nz oa b">dist_table[i][0]</code>表示空字符串，而不是单词2的第一个字母，同样，<code class="fe nx ny nz oa b">dist_table[0][j]</code>表示单词1的空字符串，而不是它的第一个字母)。</p><p id="800c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要问自己，从word1到word2的操作何时需要成本，何时不需要？</p><h2 id="4de2" class="ob mk it bd ml oc od dn mp oe of dp mt li og oh mv lm oi oj mx lq ok ol mz om bi translated">案例A:无成本</h2><p id="f98f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这个非常简单:不需要成本的唯一方法是字母相同。根据递归定义，这意味着:</p><p id="43a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ly">注意:Python切片工作使得</em> <code class="fe nx ny nz oa b"><em class="ly">word[:k]</em></code> <em class="ly">是</em> <code class="fe nx ny nz oa b"><em class="ly">word</em></code> <em class="ly">从索引0到索引k-1的子串，所以索引k不包括在内。</em></p><pre class="kj kk kl km gt on oa oo op aw oq bi"><span id="764b" class="ob mk it oa b gy or os l ot ou"># if the last letters are the same<br/>if word1[n] == word[m]:<br/>    return lev_dist(word1[:n], word2[:m])</span></pre><p id="bdc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们简单地递归子串，排除最后一个索引。</p><h2 id="571e" class="ob mk it bd ml oc od dn mp oe of dp mt li og oh mv lm oi oj mx lq ok ol mz om bi translated">案例B:当有成本时</h2><p id="41a7" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">显然，如果字母不同，就会有成本，因此情况A的反面本质上是情况b。让我们进一步将其分解为当字母不同时可以进行哪些操作，以及它对我们的递归定义究竟有什么影响。</p><ul class=""><li id="1fe1" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">Insert:这会将word1的长度增加1，因为我们将word2的最后一个字母插入到word1中，所以word1和word2现在具有相同的最后一个字母。现在，我们可以在这些字符串上递归，就像我们在情况A中所做的那样，排除两个相同的字母，如下所示:</li></ul><pre class="kj kk kl km gt on oa oo op aw oq bi"><span id="4147" class="ob mk it oa b gy or os l ot ou">return lev_dist(word1, word2[:m]) + 1</span></pre><p id="d5db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们是如何为插入操作添加<code class="fe nx ny nz oa b">1</code>的，word1基本上保持不变。</p><ul class=""><li id="a9b0" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">删除:这将word1的长度减少了1，我们可以简单地递归如下:</li></ul><pre class="kj kk kl km gt on oa oo op aw oq bi"><span id="e510" class="ob mk it oa b gy or os l ot ou">return lev_dist(word1[:n], word2) + 1</span></pre><ul class=""><li id="d147" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">Replace:这将把word1的最后一个字母替换为与word2的最后一个字母相同的字母，因此情况A适用，我们可以类似地递归:</li></ul><pre class="kj kk kl km gt on oa oo op aw oq bi"><span id="0b6d" class="ob mk it oa b gy or os l ot ou">return lev_dist(word1[:n], word[:m]) + 1</span></pre><p id="bb5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">综上所述，我们现在有了最终的递归定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="485c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在剩下要做的就是将同样的想法转换成自底向上的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="24c0" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="3f3c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这就把我们带到了动态编程系列的结尾！希望你已经学到了很多关于如何处理DP问题以及如何着手解决它们的知识，这样你就能在下一次面试中胜出！</p><p id="edc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝你好运，感谢你的阅读！</p></div></div>    
</body>
</html>