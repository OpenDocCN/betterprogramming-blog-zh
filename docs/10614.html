<html>
<head>
<title>Writing Robust and Error-Free Python Code Using Pydantic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pydantic编写健壮且无错误的Python代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-robust-and-error-free-python-code-using-pydantic-151a135a9ff0?source=collection_archive---------9-----------------------#2022-01-18">https://betterprogramming.pub/writing-robust-and-error-free-python-code-using-pydantic-151a135a9ff0?source=collection_archive---------9-----------------------#2022-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6558" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">终于！实际工作的Python自动完成(像在C#和Java中)和类型提示支持</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6e2fc5005f48567deecb085a8b97ccca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*m3XL6FT8UR43V5-b.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">演员表:作者</p></figure><p id="22e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python是一种动态类型语言，这意味着类型检查是在运行时(执行时)进行的。如果代码中有错误，将在执行时抛出。像Java、C#和C这样的语言是静态类型的，这意味着类型检查是在编译时执行的。在这种情况下，该错误将在程序运行之前抛出。</p><p id="3199" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在静态类型语言中，构造的类型不能改变。编译器需要事先知道类型。例如，在C中声明为<code class="fe lu lv lw lx b">int</code>的变量不能在以后更改为<code class="fe lu lv lw lx b">string</code>。</p><p id="a4bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，我们可以在Python中做到这一点:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="dd85" class="mc md it lx b gy me mf l mg mh">myVar = 1 <br/>myVar = "hello" #this works</span></pre><p id="9c62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种增强的灵活性意味着动态类型语言的执行速度比静态类型语言慢。在运行时必须进行大量的检查，以确定变量和其他结构的类型，这样程序才能被执行。这造成了开销。</p><p id="7f6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在Python是机器学习的首选语言，开发服务于机器学习模型的API和web应用程序的用例越来越多。用一种语言来创建模型并把它们包装在面向用户的应用程序中要比用多种语言简单得多。</p><p id="a32b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，对于这些全栈应用程序，当类型检查在运行时而不是编译时执行时，类型错误的几率会增加。这就是Python类型提示的用处。它允许我们直接在代码中声明编程结构的类型。</p><p id="bb66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们看看类型提示的基础。</p><h1 id="b714" class="mi md it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">Python类型提示和代码完成</h1><p id="64a6" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">为了定义函数参数的类型提示，我们可以在变量名后写一个<code class="fe lu lv lw lx b">:</code>(冒号)，后跟类型。对于非单一类型，如<em class="ne">列表、字典、集合</em>，我们需要导入<code class="fe lu lv lw lx b">typing</code>包。</p><p id="e6f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一些代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="235e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们定义了一个函数<code class="fe lu lv lw lx b">get_stuff()</code>，它将提供的<code class="fe lu lv lw lx b">item</code>追加到项目列表<code class="fe lu lv lw lx b">fridge</code>中。<br/>之后，<code class="fe lu lv lw lx b">fridge</code>中的所有项目都被大写。</p><p id="445e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码按预期工作，返回水果列表:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="36cb" class="mc md it lx b gy me mf l mg mh">['Apple', 'Grape', 'Pear', 'Orange']</span></pre><p id="8b1f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们将<code class="fe lu lv lw lx b">fridge</code>定义为字符串和代码的列表(安装了PyLance和Python扩展),所以提供了即时的代码完成。<br/>如果您键入<code class="fe lu lv lw lx b">fridge.</code>，请注意建议是如何弹出的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/62ec21b8ae7e52161ec9dbe16f69dfb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*a6_YR8CBgV9wTj8s.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">类型提示代码完成列表</p></figure><p id="d0e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似地，由于我们已经将<code class="fe lu lv lw lx b">fridge</code>定义为一个字符串列表，我们可以编写<code class="fe lu lv lw lx b">x.</code>来查看冰箱中每一个字符串项的所有可能操作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3db709da97c895e77a368cacde5ec3c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9e_4zZV70pisfzw_.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">字符串的类型提示代码完成</p></figure><p id="04cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如你所看到的，类型提示节省了大量的时间，因为不需要在在线文档中来回查找方法和属性。</p><h1 id="c32a" class="mi md it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">Pydantic模型</h1><blockquote class="nh ni nj"><p id="bd78" class="ky kz ne la b lb lc ju ld le lf jx lg nk li lj lk nl lm ln lo nm lq lr ls lt im bi translated"><em class="it">使用python类型注释的数据验证和设置管理。在运行时强制执行类型提示，并在数据无效时提供用户友好的错误。</em>来源:<a class="ae nn" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank"> Pydantic </a></p></blockquote><p id="e698" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管Python支持类型提示，但这不是强制的。因此，传递不正确类型的对象仍然是可能的，如果尝试不支持的操作，将会导致错误。例如，尝试对<code class="fe lu lv lw lx b">int</code>类型进行<code class="fe lu lv lw lx b">str</code>操作。Pydantic是一个Python库，它实现了这一点，这意味着它规避了这样的错误。</p><p id="5cd8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子来巩固这一点。</p><p id="8cd2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们的函数有一些不好的输入，并且<code class="fe lu lv lw lx b">fridge</code>包含一个<code class="fe lu lv lw lx b">int</code>和<code class="fe lu lv lw lx b">strings</code>。<br/>代码的其余部分保持不变，我们用修改后的<code class="fe lu lv lw lx b">fridge</code>调用<code class="fe lu lv lw lx b">get_stuff()</code>:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="60b9" class="mc md it lx b gy me mf l mg mh">print(get_stuff("orange", ["apple", 1, "pear"]))</span></pre><p id="9792" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">会发生什么？</p><p id="509e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们得到以下运行时错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/77c4689b8a3fa940a4e7d3f1f821963e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/0*uUfSwC1SFxa3kkV2.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行时错误</p></figure><p id="181e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">即使我们声明<code class="fe lu lv lw lx b">x</code>是类型<code class="fe lu lv lw lx b">str</code>的，但是<code class="fe lu lv lw lx b">get_stuff()</code>函数很乐意接受一个带有一个<code class="fe lu lv lw lx b">int</code>元素的列表，并且<code class="fe lu lv lw lx b">toUpper()</code>试图在<code class="fe lu lv lw lx b">int</code>对象上调用<code class="fe lu lv lw lx b">capitalize()</code>。</p><p id="0420" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这一点上，似乎类型提示的好处仅限于自动完成。</p><p id="8d96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以重构代码来使用Pydantic。我们定义了一个继承自Pydantic <code class="fe lu lv lw lx b">BaseModel</code>的数据模型。这是在Pydantic中创建数据模型的主要方式。由于这是我们数据应该如何表示的蓝图，我们将其定义为一个类。</p><p id="b678" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">继续安装Pydantic和:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="3a1b" class="mc md it lx b gy me mf l mg mh">pip3 install pydantic</span></pre><p id="b313" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后定义一个继承自<code class="fe lu lv lw lx b">BaseModel</code>的<code class="fe lu lv lw lx b">Frdige</code>类，如下所示:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="8b28" class="mc md it lx b gy me mf l mg mh">from pydantic import BaseModel</span><span id="302b" class="mc md it lx b gy np mf l mg mh">class Fridge(BaseModel):<br/>    items: List[str]</span></pre><p id="3118" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们给<code class="fe lu lv lw lx b">Fridge</code>类一个名为<code class="fe lu lv lw lx b">items</code>的属性，这将是一个字符串列表。我们创建了一个<code class="fe lu lv lw lx b">Fridge</code>的实例，并在调用<code class="fe lu lv lw lx b">get_stuff()</code>函数时将其作为参数传递。</p><p id="78bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">重构后的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ca68" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们现在尝试再次运行它，您会注意到代码没有错误！<br/>将<code class="fe lu lv lw lx b">int</code>转换成一个<code class="fe lu lv lw lx b">string</code>对象，并附加到列表中，给出以下返回对象:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="00a7" class="mc md it lx b gy me mf l mg mh">['1', 'Apple', 'Pear', 'Orange']</span></pre><p id="6ec8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你还会注意到，当我们创建一个<code class="fe lu lv lw lx b">Fridge</code>对象的实例时，我们传递了一个Python <code class="fe lu lv lw lx b">set</code>而不是一个<code class="fe lu lv lw lx b">list</code>。这里，Pydantic再次负责将<code class="fe lu lv lw lx b">set</code>转换为<code class="fe lu lv lw lx b">list</code>！</p><p id="a2be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能想知道如果我们真的想要一个混合类型的列表，比如一个包含字符串或整数的列表，应该怎么做。为此，我们可以使用类似逻辑or的<code class="fe lu lv lw lx b">Union</code>类型注释。<br/>例如,<code class="fe lu lv lw lx b">Fridge</code>定义如下:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="7242" class="mc md it lx b gy me mf l mg mh">class Fridge(BaseModel):<br/>    items: List[Union[int, str]]</span></pre><p id="1c6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将以下列表传递给<code class="fe lu lv lw lx b">Fridge</code>现在可以工作了:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="393c" class="mc md it lx b gy me mf l mg mh">[1, "apple", "orange", "pear"]</span></pre><p id="92d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，Pydantic优先考虑<code class="fe lu lv lw lx b">Union</code>中列出的第一种类型。所以如果我们写下:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="a457" class="mc md it lx b gy me mf l mg mh">class Fridge(BaseModel):<br/>    items: List[Union[str, int]]</span></pre><p id="c5f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么传递的列表中的<code class="fe lu lv lw lx b">int</code>将被强制转换为<code class="fe lu lv lw lx b">string</code>，即使<code class="fe lu lv lw lx b">int</code>出现在类型注释中。这将给出(这不是我们想要的):</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="7357" class="mc md it lx b gy me mf l mg mh">["1", "apple", "orange", "pear"]</span></pre><p id="81aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好了，我们已经谈了很多了！但是还有一点要注意。</p><p id="2760" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在对更复杂的数据类型建模时，Pydantic确实大放异彩。为此，我们需要看看递归模型。</p><h1 id="2306" class="mi md it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">递归模型</h1><p id="b1a8" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">还可以在Pydantic中为更复杂的数据模型定义递归模型。递归模型是包含另一个模型作为其一个属性中的类型定义的模型。因此，我们可以用<code class="fe lu lv lw lx b">List[Cars]</code>代替<code class="fe lu lv lw lx b">List[str]</code>，其中<code class="fe lu lv lw lx b">Cars</code>是我们代码中定义的Pydantic模型。</p><p id="906c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">再举一个例子！</p><p id="5e68" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们还想存储冰箱中每种水果的数量。为此，我们创建了一个<code class="fe lu lv lw lx b">Fruit</code>数据模型:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="4a8f" class="mc md it lx b gy me mf l mg mh">class Fruit(BaseModel):<br/>    name:str<br/>    num:int</span></pre><p id="ab24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe lu lv lw lx b">Fridge</code>数据模型中，我们可以将列表定义为<code class="fe lu lv lw lx b">Fruits</code>列表，而不是<code class="fe lu lv lw lx b">ints</code>列表:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="76d3" class="mc md it lx b gy me mf l mg mh">class Fridge(BaseModel):<br/>    items: List[Fruit]</span></pre><p id="dc05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完整代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1bf8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们用包含一系列<code class="fe lu lv lw lx b">Fruit</code>对象的<code class="fe lu lv lw lx b">Fridge</code>对象来调用<code class="fe lu lv lw lx b">get_most_fruits()</code>。很简单。</p><p id="d025" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们希望退回编号最高的水果。在对水果列表进行操作之前，我们使用<code class="fe lu lv lw lx b">jsonable_encoder()</code>方法将列表转换成JSON兼容的类型。如果我们没有这样做，那么列表中的一个元素将是不能被操作的类型<code class="fe lu lv lw lx b">Fruit</code>。</p><p id="9396" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在编码阶段之后，我们得到一个<code class="fe lu lv lw lx b">dict</code>对象的列表，这些对象的键、值对对应于<code class="fe lu lv lw lx b">Fruit</code>类中定义的<code class="fe lu lv lw lx b">name</code>和<code class="fe lu lv lw lx b">num</code>字段。</p><p id="b9d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在可以对这个列表进行排序，返回编号最高的水果。</p><h1 id="b82e" class="mi md it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="7447" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">在这篇文章中，我们回顾了动态和静态类型语言。我们看了Python中的类型提示以及使用Pydantic来加强类型提示。</p><p id="de0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总之，键入提示有助于:</p><ul class=""><li id="2053" class="nq nr it la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated">通过IDE自动完成加速软件开发。</li><li id="7af0" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">通过使代码更易于理解和阅读，有助于提高代码质量。</li><li id="74f9" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">改进编码风格和整体软件设计。</li><li id="0ad7" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">通过减少运行时错误，创建更健壮、无错误的软件。尤其是在大型复杂的软件项目中。</li></ul><p id="84ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望你在这篇文章中学到了一些有用的东西。</p><p id="68c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一次我们将关注FastAPI，这是一个流行的Python web框架，完全支持Pydantic。</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="cdb6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ne">最初发表于</em><a class="ae nn" href="https://haseebkamal.com/2022/01/15/towards-robust-and-error-free-python-code-with-pydantic/" rel="noopener ugc nofollow" target="_blank"><em class="ne">https://haseebkamal.com</em></a></p></div></div>    
</body>
</html>