<html>
<head>
<title>6 Advanced Python Decorator Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6种高级Python装饰模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/six-advanced-decorator-patterns-5ffe67552691?source=collection_archive---------1-----------------------#2021-06-01">https://betterprogramming.pub/six-advanced-decorator-patterns-5ffe67552691?source=collection_archive---------1-----------------------#2021-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bd1b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过模板开发解释Python decorator的代码示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8477ae1e43ba6712533d93e1ee6c3d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u_auxZS6jVHK3K1jKTVYLA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。装饰器(淡紫色)包裹着一个函数(橙色)。在<a class="ae ky" href="https://unsplash.com/s/photos/macro?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@lucas_starman?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">先生拍摄的Starman </a>照片。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ce5d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">计算机语言编码经验</h1><p id="36cc" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在许多方面，我的编码经历类似于考古挖掘中的冰层。</p><p id="54d2" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">底层——或最老的层——是几个不同的汇编器。以下各层按层龄顺序分别是FORTRAN、Lisp(几个变种)、C、PL/1、SQL、C++和Java。最后几层，代表过去八年，混合了R、Python、Ruby、Scala和Go。</p><p id="b1a0" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在C中使用宏，C++是简单的替换。许多权威人士认为在Java中使用宏是一种不好的做法。Lisp宏可能太强大了吗？</p><p id="652c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">对我来说，最优雅的宏是Python decorator。</p><p id="ff75" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><em class="mz">注意:如果Python被编译成静态伪代码并具有无需人工干预的并发性，那么它将是我最喜欢的语言。对我来说，使用PySpark、云或跳到另一种语言来受益于多核CPU感觉很糟糕。</em></p><p id="d5ae" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我假设您对初级和高级Python装饰器的使用都很熟悉。</p><p id="0eff" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果您需要复习Python decorator概念，请阅读下面的文章。它提供了我所遇到的Python decorators的最佳解释:</p><div class="na nb gp gr nc nd"><a href="https://medium.com/techtofreedom/7-levels-of-using-decorators-in-python-370473fcbe76" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">在Python中使用Decorators的7个层次</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">掌握Python最神奇的特性</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr ks nd"/></div></div></a></div><p id="e0ab" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在本文中，我将介绍用于日志记录、调试、显示函数元数据和枚举的decorator模式。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e38a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">1.基本装饰模板:日志记录</h1><p id="31f9" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我将从一个用于日志记录的通用装饰器开始。</p><p id="20a5" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe ns nt nu nv b">log_call</code>是一个基本的Python装饰器。它封装了<code class="fe ns nt nu nv b">add_one</code>函数调用前后的日志执行。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="d680" class="oa lh it nv b gy ob oc l od oe">def log_call(fun):<br/>    """<br/>        Decorator <a class="ae ky" href="http://twitter.com/log_call" rel="noopener ugc nofollow" target="_blank">@log_call</a> wraps the funtion <br/>        with log events.<br/>    """<br/>    def wrapper(*args, **kwargs):<br/>        #Pre:<br/>        logger.info("before function: {}".format(fun.__name__))<br/>        result = fun(*args, **kwargs)<br/>        #post:<br/>        logger.info("after function: {}, result:<br/>                   {}".format(fun.__name__,result))<br/>        return result<br/>    return wrapper</span><span id="153f" class="oa lh it nv b gy of oc l od oe"><a class="ae ky" href="http://twitter.com/log_call" rel="noopener ugc nofollow" target="_blank">@log_call</a><br/>def add_one(x):<br/>    x = x+1<br/>    return(x)</span><span id="5cdf" class="oa lh it nv b gy of oc l od oe">y=0<br/>y = add_one(y)<br/>y</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/16cfad70550dbc5a7303d985a4236e03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tYaldx-uAgXria_tZ6G3jQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图二。用decorator log_call包装的add_one的输出。图片:作者终端截图。</p></figure><p id="3e26" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">代码在<a class="ae ky" href="https://github.com/bcottman/pyprobasic/blob/main/src/decorator-blog.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>中给出并运行。</p><p id="e4ae" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe ns nt nu nv b">login_call</code>装饰器是我们的第一个模式例子。您可以在<code class="fe ns nt nu nv b">login_call</code>装饰模式中替换任何之前或之后的样板代码或名称。</p><h2 id="945f" class="oa lh it bd li oh oi dn lm oj ok dp lq mh ol om ls ml on oo lu mp op oq lw or bi translated">带参数模板的装饰器(错误)</h2><p id="7a0e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果装饰模式有参数，它会变得更加强大。</p><p id="c9df" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">添加参数的一个简单的Pythonic方法是将<code class="fe ns nt nu nv b">*a, **kw</code>放在调用签名中的<code class="fe ns nt nu nv b">func</code>之后。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="8b4b" class="oa lh it nv b gy ob oc l od oe">def log_call(func,*a, **kw):<br/>    """<br/>        Decorator <a class="ae ky" href="http://twitter.com/log_call" rel="noopener ugc nofollow" target="_blank">@log_call</a> with arguments wraps the funtion <br/>        with log events.<br/>    """<br/>    def wrapper(*args, **kwargs):<br/>        #Pre<br/>        result = func(*args, **kwargs)<br/>        #post:<br/>        logger.info("function: {}, result:{}".format(func.__name__,result))<br/>        return result<br/>    return wrapper</span><span id="0c42" class="oa lh it nv b gy of oc l od oe"><a class="ae ky" href="http://twitter.com/log_call" rel="noopener ugc nofollow" target="_blank">@log_call</a>(1, ERROR=True)<br/>def add_one(x):<br/>    x = x+1<br/>    return(x)<br/>y=0</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/f9116eadecb363ce6a452c88fd5a9174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6AbmNwKQLWOKuN0R0l3lQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3。尝试用带参数的decorator log_call包装add_one的输出。图片:作者终端截图。</p></figure><p id="fe3a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在调用签名中的<code class="fe ns nt nu nv b">func</code>后添加<code class="fe ns nt nu nv b">*a, **kw</code>不起作用。</p><p id="0677" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">下一节将展示一种创建带参数的装饰器的正确方法。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6269" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">2.带参数的装饰器:日志记录(正确)</h1><p id="706a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">一个带参数的装饰器需要<code class="fe ns nt nu nv b">@wrap</code>和另一个功能层。我把这个新功能层任意命名为<code class="fe ns nt nu nv b">decorator</code>。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="50c6" class="oa lh it nv b gy ob oc l od oe">def log_call(*a, **kw):<br/>    """<br/>        Decorator <a class="ae ky" href="http://twitter.com/log_call" rel="noopener ugc nofollow" target="_blank">@log_call</a> wraps the funtion <br/>        with log events.<br/>    """<br/>    def decorator(func):<br/>        <a class="ae ky" href="http://twitter.com/wraps" rel="noopener ugc nofollow" target="_blank">@wraps</a>(func)<br/>        def wrapper(*args, **kwargs):<br/>            #Pre:<br/>            result = func(*args, **kwargs)<br/>            #post:<br/>            logger.info("function: {}, result:{}".format(func.__name__,result))<br/>            return result<br/>        return wrapper<br/>    return decorator</span><span id="d1bb" class="oa lh it nv b gy of oc l od oe"><a class="ae ky" href="http://twitter.com/log_call" rel="noopener ugc nofollow" target="_blank">@log_call</a>(ERROR=True)<br/>def add_one(x):<br/>    x = x+1<br/>    return(x)<br/>y=0<br/>y = add_one(y)<br/>y</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/62346d5ef436db2f45d6cb2305da6199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUHZvKsj79blu5Uu8ul6oA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4。add_one的输出用带参数log_call的decorator包装。图片:作者终端截图。</p></figure><p id="1699" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">接下来，我们深入研究一下<code class="fe ns nt nu nv b">@wrap</code>，找出我们为什么需要它。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="679b" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">3.@wrap保留函数元数据</h1><p id="42ff" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">通常没有必要保留功能对象实例元数据。然而，我们需要函数对象实例引用来正确包装装饰器。</p><p id="bbb1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">内置的Python函数<code class="fe ns nt nu nv b">dir(function-symbol)</code>详述了函数元数据。在下面的例子中，我们使用<code class="fe ns nt nu nv b">dir(function-symbol)</code>创建一个装饰器来详述函数的元数据。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="3192" class="oa lh it nv b gy ob oc l od oe">def bad_dir(*a, **kw):<br/>    """<br/>        Decorator <a class="ae ky" href="http://twitter.com/bad_dir" rel="noopener ugc nofollow" target="_blank">@bad_dir</a> wraps a call of dir<br/>        on the funtion inefficently.<br/>    """<br/>    def decorator(func):<br/>        <a class="ae ky" href="http://twitter.com/wraps" rel="noopener ugc nofollow" target="_blank">@wraps</a>(func)<br/>        def wrapper(*args, **kwargs):<br/>            #Pre:<br/>            result = dir(func)<br/>            #post:<br/>            logger.info("function: {}, a:{},<br/>                       kw()".format('bad_dir',a, kw))<br/>            logger.info("function: {}, args:{}, kwargs()".format(func.__name__,args, kwargs))<br/>            return result<br/>        return wrapper<br/>    return decorator</span><span id="8630" class="oa lh it nv b gy of oc l od oe"><a class="ae ky" href="http://twitter.com/bad_dir" rel="noopener ugc nofollow" target="_blank">@bad_dir</a>(1, ERROR=True)<br/>def add_one(x):<br/>    x = x+1<br/>    return(x)</span><span id="809b" class="oa lh it nv b gy of oc l od oe">y=0<br/>add_one(y)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/521d9a9aee6d116e9e74799c8947918f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fZezdcQqL-dr1dqzP5jTuQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5。用decorator bad_dir包装的add_one的输出。图片:作者终端截图。</p></figure><p id="7d28" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们的<code class="fe ns nt nu nv b">log_call</code>装饰器使用了<code class="fe ns nt nu nv b">__name__</code>函数对象属性，但是您可以查看列表来找到其他有用的函数对象属性。</p><p id="7bc6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><em class="mz">注:</em><a class="ae ky" href="https://stackoverflow.com/questions/308999/what-does-functools-wraps-do" rel="noopener ugc nofollow" target="_blank"><em class="mz">@ wrap</em></a><em class="mz">在</em> <code class="fe ns nt nu nv b"><em class="mz">functools</em></code> <em class="mz">包里。</em></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="10f6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">4.带参数的装饰模板:日志记录使用参数</h1><p id="76b5" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们需要使用<code class="fe ns nt nu nv b">log_call</code>装饰器参数的助手函数的封装代码。</p><p id="b730" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe ns nt nu nv b">log_output</code>功能具体实际是做什么的？</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="0f2f" class="oa lh it nv b gy ob oc l od oe">from typing import Dict, List, Any<br/>def log_output(fun, result:Any, kw:Dict, check_state:List ) -&gt; None:<br/>    for key in kw:<br/>        keyl = key.lower()<br/>        if  keyl in check_state:<br/>            if kw[key]:<br/>                eval('logger.'+keyl)("function: {}, result:<br/>                                   {}".format(fun.__name__,result))</span></pre><p id="7236" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们接下来创建<code class="fe ns nt nu nv b">log_call</code>装饰器，使用新的装饰器模式接受参数。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="e628" class="oa lh it nv b gy ob oc l od oe">def log_call(*a, **kw):<br/>    """<br/>        Decorator <a class="ae ky" href="http://twitter.com/log_call" rel="noopener ugc nofollow" target="_blank">@log_call</a> wraps the funtion <br/>        with log events.<br/>    """<br/>    def decorator(fun):<br/>        <a class="ae ky" href="http://twitter.com/wraps" rel="noopener ugc nofollow" target="_blank">@wraps</a>(fun)<br/>        def wrapper(*args, **kwargs):<br/>            #Pre:<br/>            result = fun(*args, **kwargs)<br/>            #post:<br/>            check_state = ('debug', 'info', 'success',<br/>                           'warning', 'error', 'critical')<br/>            log_output(fun, result, kw, check_state)<br/>            return result<br/>        return wrapper<br/>    return decorator</span><span id="08d5" class="oa lh it nv b gy of oc l od oe"><a class="ae ky" href="http://twitter.com/log_call" rel="noopener ugc nofollow" target="_blank">@log_call</a>(ERROR=True)<br/>def add_one(x):<br/>    x = x+1<br/>    return(x)<br/>y=0</span><span id="cd41" class="oa lh it nv b gy of oc l od oe">y = add_one(y)<br/>y</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/bfaee76ec5f7b6aa14b20968033a059e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3aW5jcO9ZKtz_jHV4Qqq8Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图6。add_one的输出用带参数log_call的decorator包装。图片:作者终端截图。</p></figure><p id="40b4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">输出显示我们通过调用<code class="fe ns nt nu nv b">@log_call(ERROR=True)</code>成功地改变了日志记录状态。</p><p id="3cd1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">使用<code class="fe ns nt nu nv b">@log_call(ERROR=True, CRITICAL=True, FAIL=True)</code>的输出会是什么？</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c73a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak"> 5。使用两个装饰器:add_one </strong></h1><p id="c68b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们将<code class="fe ns nt nu nv b">add_one</code>变成一个装饰器，将全局<code class="fe ns nt nu nv b">call_count</code>加1。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="6968" class="oa lh it nv b gy ob oc l od oe">#GLOBAL <br/>call_count= 0<br/>def add_one(fun):<br/>    """<br/>            Decorator pre-function call and post-function call of function func.<br/>    """<br/>    def wrapper(*args, **kwargs):<br/>        global call_count<br/>        #Pre action<br/>        result = fun(*args, **kwargs)<br/>        logger.info('call_count:{}'.format(call_count))<br/>        call_count = call_count+1<br/>        logger.info('Increase call_count:{}'.format(call_count))<br/>        return result<br/>    return wrapper</span></pre><p id="fab6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">实际上，我们用了三个装修工。<code class="fe ns nt nu nv b">@wraps</code>算作应用于函数<code class="fe ns nt nu nv b">pow</code>的装饰器。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="8aac" class="oa lh it nv b gy ob oc l od oe"><a class="ae ky" href="http://twitter.com/log_call" rel="noopener ugc nofollow" target="_blank">@log_call</a>(CRITICAL=True)<br/><a class="ae ky" href="http://twitter.com/add_one" rel="noopener ugc nofollow" target="_blank">@add_one</a><br/>def pow(x,y):<br/>    return(x**y)</span><span id="7f64" class="oa lh it nv b gy of oc l od oe">print('',call_count)<br/>print(pow(2,10))</span></pre><p id="6336" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">结果是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/72e8b208c9052fc56952f1e087594598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XKk1ZZiwrCUFa40wXs2P_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图7。pow函数的输出用decorators log _ call、wraps和add_one包装。图片:作者终端截图。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ae47" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">6.使用四个装饰者:jit</h1><p id="9b5a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在这个模式中，我们使用了四个装饰者。<code class="fe ns nt nu nv b"><a class="ae ky" href="https://numba.readthedocs.io/en/stable/user/jit.html" rel="noopener ugc nofollow" target="_blank">@jit</a></code>是<em class="mz">即时</em>编译成C存根的缩写。记住，<code class="fe ns nt nu nv b">@wrap</code>是用在函数<code class="fe ns nt nu nv b">decorator</code>里面的。</p><p id="720d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">为了展示<code class="fe ns nt nu nv b"><a class="ae ky" href="https://numba.readthedocs.io/en/stable/user/jit.html" rel="noopener ugc nofollow" target="_blank">@jit</a></code>的效果，一开始我们不使用。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="b9da" class="oa lh it nv b gy ob oc l od oe"><a class="ae ky" href="http://twitter.com/log_call" rel="noopener ugc nofollow" target="_blank">@log_call</a>(ERROR=True)<br/><a class="ae ky" href="http://twitter.com/add_one" rel="noopener ugc nofollow" target="_blank">@add_one</a><br/>def cum_one(x:int,y:int) -&gt; int:<br/>    total = 1 <br/>    for i in range(2,y,1):<br/>        total += 1<br/>    return(total))</span><span id="7717" class="oa lh it nv b gy of oc l od oe">cum_one(2,100_000_000)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/b36e85da0be3fb477ba8e672577bfbce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KCQIFcbRj7AA5HTYhTmeoA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图7。用decorators log_call、wraps和add_one包装的cum_one函数的输出。图片:作者终端截图</p></figure><p id="1499" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">没有<code class="fe ns nt nu nv b">@jit</code>，需要7.09秒的挂钟时间。</p><p id="ffe5" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><strong class="ma iu"> <em class="mz">注</em> </strong> <em class="mz"> : </em> <code class="fe ns nt nu nv b"><em class="mz">jit</em></code> <em class="mz">是</em> <code class="fe ns nt nu nv b"><a class="ae ky" href="http://numba.pydata.org/" rel="noopener ugc nofollow" target="_blank"><em class="mz">numba</em></a><em class="mz"> </em></code> <em class="mz">包的一部分。</em></p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="1145" class="oa lh it nv b gy ob oc l od oe"><a class="ae ky" href="http://twitter.com/add_one" rel="noopener ugc nofollow" target="_blank">@add_one</a><br/><a class="ae ky" href="http://twitter.com/log_call" rel="noopener ugc nofollow" target="_blank">@log_call</a>(ERROR=True)<br/><a class="ae ky" href="http://twitter.com/jit" rel="noopener ugc nofollow" target="_blank">@jit</a><br/>def cum_one(x:int,y:int) -&gt; int:<br/>    total = 1 <br/>    for i in range(2,y,1):<br/>        total += 1<br/>    return(total)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/ae7b8b642ddf2df361bfbf2664f253bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NdPUWuJvLMEoQmwN5T1CvA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8。用decorators add _ one、log_call、wraps和jit包装的cum_one函数的输出。图片:作者终端截图</p></figure><p id="2e2e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">使用<code class="fe ns nt nu nv b">@jit</code>，需要0.24秒的挂钟时间。大约30倍的加速。</p><p id="1697" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe ns nt nu nv b">@jit</code>缓存每个编译后的命名函数，从而在第二次调用中获得更快的速度。没有<code class="fe ns nt nu nv b">@jit</code>编译开销。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/27f777ac9d47c01cd73f7a28b7cee37b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pJlsK9iZ4up2Aysj5YSWjQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图9。cum_one函数的输出演示了@it缓存的效果。图片:作者终端截图。</p></figure><p id="3023" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe ns nt nu nv b">@jit</code>结果是挂钟时间的0.011秒。大约640倍的加速比。</p><h2 id="aaa8" class="oa lh it bd li oh oi dn lm oj ok dp lq mh ol om ls ml on oo lu mp op oq lw or bi translated">装饰器调用的顺序对@jit很重要</h2><p id="1620" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">当我们调用<code class="fe ns nt nu nv b">log_call</code>结果然后调用<code class="fe ns nt nu nv b">add_one</code>时会发生什么？</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="0c82" class="oa lh it nv b gy ob oc l od oe"><a class="ae ky" href="http://twitter.com/log_call" rel="noopener ugc nofollow" target="_blank">@log_call</a>(ERROR=True)<br/><a class="ae ky" href="http://twitter.com/add_one" rel="noopener ugc nofollow" target="_blank">@add_one</a><br/><a class="ae ky" href="http://twitter.com/jit" rel="noopener ugc nofollow" target="_blank">@jit</a><br/>def cum_one(x:int,y:int) -&gt; int:<br/>    total = 1 <br/>    for i in range(2,y,1):<br/>        total += 1<br/>    return(total)</span><span id="d19c" class="oa lh it nv b gy of oc l od oe">cum_one(2,100_000_000)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/da77ef3fb7363fc0415d1263d440532e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xwb2RCxiM9b53SIqWLsBNQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图10。cum_one函数的输出演示了decorator调用效果的排序。图片:作者终端截图。</p></figure><p id="aab2" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe ns nt nu nv b">log_call</code>的日志事件先于<code class="fe ns nt nu nv b">add_one</code>的日志事件。</p><p id="418c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们看看我们是否先给<code class="fe ns nt nu nv b">@jit</code>打电话。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="606f" class="oa lh it nv b gy ob oc l od oe"><a class="ae ky" href="http://twitter.com/jit" rel="noopener ugc nofollow" target="_blank">@jit</a><br/><a class="ae ky" href="http://twitter.com/log_call" rel="noopener ugc nofollow" target="_blank">@log_call</a>(ERROR=True)<br/><a class="ae ky" href="http://twitter.com/add_one" rel="noopener ugc nofollow" target="_blank">@add_one</a><br/>def cum_one(x:int,y:int) -&gt; int:<br/>    total = 1 <br/>    for i in range(2,y,1):<br/>        total += 1<br/>    return(total)</span><span id="72ee" class="oa lh it nv b gy of oc l od oe">cum_one(2,100_000_000)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/ba17c5e50262bbc1a827397e35d36375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VpKOmuhilu1VP_sxcD1svQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图11。cum_one函数的输出演示了@ JIT not last decorator调用的效果。图片:作者终端截图。</p></figure><p id="0473" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">哎哟！似乎<code class="fe ns nt nu nv b">@jit</code>需要在函数之前被调用。</p><p id="c3b5" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我远离哲学。我更像是一个<em class="mz">完成</em>类型的人。我会让你决定这是<code class="fe ns nt nu nv b">@jit</code>的一个特点还是一个缺陷。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5532" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">摘要</h1><p id="bf51" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在本文中，我讨论了:</p><ol class=""><li id="8b31" class="pc pd it ma b mb mu me mv mh pe ml pf mp pg mt ph pi pj pk bi translated">没有日志记录参数的Decorators。</li><li id="28c6" class="pc pd it ma b mb pl me pm mh pn ml po mp pp mt ph pi pj pk bi translated">带有日志参数的装饰器。</li><li id="3b4c" class="pc pd it ma b mb pl me pm mh pn ml po mp pp mt ph pi pj pk bi translated"><code class="fe ns nt nu nv b">@wraps</code>的值。</li><li id="caba" class="pc pd it ma b mb pl me pm mh pn ml po mp pp mt ph pi pj pk bi translated">使用三个装饰者。</li><li id="0e01" class="pc pd it ma b mb pl me pm mh pn ml po mp pp mt ph pi pj pk bi translated"><code class="fe ns nt nu nv b">@add_one</code>装饰工。</li><li id="33b2" class="pc pd it ma b mb pl me pm mh pn ml po mp pp mt ph pi pj pk bi translated">使用四个装饰者。</li><li id="76d8" class="pc pd it ma b mb pl me pm mh pn ml po mp pp mt ph pi pj pk bi translated">使用<code class="fe ns nt nu nv b">@jit</code>装饰器可以获得什么样的加速。</li><li id="4405" class="pc pd it ma b mb pl me pm mh pn ml po mp pp mt ph pi pj pk bi translated">装饰者的顺序是不可传递的。</li></ol><p id="de27" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">本文中的代码在<a class="ae ky" href="https://github.com/bcottman/pyprobasic/blob/main/src/decorator-blog.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>中给出并运行。</p><p id="51a6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在下一篇文章中，我将展示一个包，用于方便地记录和使用YAML文件的参数。</p><p id="b27e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">编码快乐！</p></div></div>    
</body>
</html>