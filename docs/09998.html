<html>
<head>
<title>How to Use Git as an Offline-First Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Git作为离线优先数据库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-git-as-an-offline-first-database-dca7f9604142?source=collection_archive---------1-----------------------#2021-11-11">https://betterprogramming.pub/how-to-use-git-as-an-offline-first-database-dca7f9604142?source=collection_archive---------1-----------------------#2021-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c216" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">答案是为自动同步和冲突解决设计确定性的规则</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/328157c835f973d6c233c7a302765499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/0*WrHcdhDcnKRCLUQZ.jpg"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图1:离线优先的概念。图片来源:作者</p></figure><p id="be1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面是我的画，展示了离线优先的概念。<a class="ae ln" href="http://offlinefirst.org/" rel="noopener ugc nofollow" target="_blank">离线优先</a>是一个设计范例，确保你的应用程序离线和在线都能工作。</p><p id="d8a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">他的名字叫不插电塔努基。他平时都是离线，偶尔在线。他将数据存储在分散的地方，以便无论身在何处都能享受乐趣。此外，当在线时，他可以将他的分布式数据彼此同步。正因为如此，他脱离了互联网连接。</p><p id="11a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">多主数据库是这种模式的重要组成部分。在多主数据库中，您拥有的分布式数据不是服务器的缓存，而是克隆的原始数据。因此，您不需要从服务器获取初始数据。</p><p id="a941" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为一个类似的概念，您可能对Git很熟悉。Git是一个流行的分布式版本控制系统，它允许您管理多个位置的文件，并将本地文件与远程文件合并。如果Git可以被用作数据库，难道不可以创建离线优先的应用程序，与Git强大的工具集和GitHub这样的生态系统一起工作吗？</p><p id="9572" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Git当然是一个优秀的离线优先系统。尽管如此，还没有将它用作分布式数据库的例子。这是为什么呢？</p><p id="f9c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">原因是Git是一个面向人的工具，你需要为自动化处理设置规则。Git没有内置的自动方法来同步和解决分布式数据的冲突。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/8a8eb9cde7dbe0dbbf6ae4c2b9f100fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/0*9O0Va_WSWlIkIpUK.jpg"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图2:完全自动化的Git。图片来源:作者</p></figure><p id="b58b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将讨论Git全自动同步和冲突解决的规则。之后，我将介绍GitDocumentDB，这是一个离线优先的数据库，它使用TypeScript实现那些规则。</p><p id="6174" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">顺便问一下，我们能不能把版本控制系统和分布式数据库相提并论？问题可以代替这个问题，“Git是CRDT吗？."在本文中，我将首先展示该问题的技术解决方案。然后我将给出一些关于CRDTs的理论背景。</p><h1 id="21ee" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">规则1:提交的串行一致性约束</h1><p id="447f" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在Git中，一个文件有许多版本，用户可以任意决定选择哪一个。另一方面，计算机不能决定，除非有一个确定性的规则，只选择一个版本。</p><p id="ed5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了帮助Git确定性地工作并确定冲突的唯一赢家，您可以设置以下三个约束:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/7fdd9bf67e80f09204182b62355eeb88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/0*uilr8TXFcXPCMQuF"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图3:提交的串行一致性约束。图片来源:作者</p></figure><h2 id="712a" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">1)一个公共工作分支</h2><p id="1ce7" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">只有一个工作分支和一个远程分支与之同步。</p><h2 id="b8f9" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">2)一片叶子</h2><p id="7b3e" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">提交图在同步前后必须只有一个叶。</p><p id="4dc5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在图3中，同步之前提交树中唯一的叶子是(h1)，其中(h1)是HEAD。当a)同步开始，b)获取，c)解决冲突和合并，d)推送，以及e)同步结束时，提交树中唯一的叶子是(h2)。在这一点上，历史绝不能出现分歧。</p><p id="6f16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">结果，计算机只能选择一片叶子(h2)作为下一个头。</p><h2 id="613b" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">3)序列化</h2><p id="b329" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">提交和同步操作必须按顺序排队。</p><p id="c085" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些约束确保在同步周期中确定性方法仅选择一个优胜叶(头)。</p><h1 id="49c3" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">规则2:确定性冲突解决流程</h1><p id="0978" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">接下来，我们需要定义自动同步和冲突解决的流程。</p><p id="b200" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在同步工作流中，可能会出现以下三种冲突:</p><h2 id="91df" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">1)一致性冲突</h2><p id="9fd2" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">当本地和远程储存库不具有相同根的相同提交树时，就会发生冲突。如果您组合这些不一致的存储库，将会对任一存储库中的提交树产生破坏性的后果。在这种情况下，用户必须提前决定是抛出异常还是强制合并。</p><h2 id="763e" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">2)交易冲突</h2><p id="e1f8" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">假设在同步过程中，在远程端进行了新的提交。在这种情况下，将会发生冲突，因为远程状态将在同步开始前改变。重试同步可以解决这种冲突。</p><h2 id="11cd" class="mm lp iq bd lq mn mo dn lu mp mq dp ly la mr ms ma le mt mu mc li mv mw me mx bi translated">3)历史冲突</h2><p id="0082" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">当在本地和远程端的提交树上执行不同的操作时，会发生冲突。</p><p id="b01b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本节将仅详述历史冲突的自动解决流程。</p><p id="207e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在图4中，本地存储库和远程存储库有共同的提交，并且是离线的。<br/>离线时向本地和远程添加不同的提交会导致它们再次在线时发生冲突。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/9bba0d45f8528c38d354425c83f7814e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bkyF-cgiy_22MWzP"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图4:历史冲突。图片来源:作者</p></figure><p id="391f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上表中，本地端的新提交数量位于纵轴上。在远程端的新提交的数量在水平轴上，并且所需的操作被填充。</p><ul class=""><li id="d50d" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm ni nj nk nl bi translated"><strong class="kt ir"> (a) NOP </strong>:如果本地提交计数为零，远程提交计数为零，则什么也不做。</li><li id="eac2" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated"><strong class="kt ir"> (b)推送</strong>:如果本地提交数大于零，远程提交数为零，则执行推送操作。</li><li id="d680" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated"><strong class="kt ir"> (c)快进合并</strong>:如果本地提交数为零，远程提交数大于零，则执行快进合并。</li><li id="ce59" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated"><strong class="kt ir"> (d)合并推送</strong>:如果本地提交数大于零，远程提交数大于零，则需要合并。如果没有冲突，合并和推送。</li><li id="4a2b" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated"><strong class="kt ir"> (e)合并，解决冲突，推送</strong>:在(d)中，如果有冲突，解决冲突，推送。</li></ul><p id="d35b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上述流程与用户的日常合并过程一致。你的下一个问题可能是如何合并和解决冲突。</p><h1 id="1d4a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">规则3:回溯文档合并</h1><p id="6ade" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">文档合并是通过比较本地端和远程端对给定文档的更改操作，然后合并更改操作来完成的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nr"><img src="../Images/c7417d2502b2cbff32025590e6b947d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dnjZrY4_uWxvynNm"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图5:自动解决冲突的案例。图片来源:作者</p></figure><p id="5efb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">图5显示了Git中三路合并的自动化版本。3-merge将“base”用于本地和远程端的公共父提交，“ours”用于最新的本地提交，“theirs”用于最新的远程提交。对于给定的文件，检查提交中是否存在单元格，如果不存在，则在单元格上加上“-”。例如，如果在“base”和“theirs”中找不到README.md文件，但在“ours”中找到了它，则该表将指向“[2] Accept ours <create>”单元格。这个单元格意味着“我们的”状态将被接受为合并结果，并且将执行文件创建操作。</create></p><h1 id="6c2f" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">规则4:冲突解决策略</h1><p id="b2bc" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">虽然人类用户可以微调解决冲突时采用的结果，但计算机很难模仿。为了实现自动冲突解决，计算机应该根据人类预先确定的策略运行。</p><p id="0b8f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">针对冲突的“我们的”策略和“他们的”策略与同名的Git策略具有相似的含义。换句话说，上表单元格中的“冲突:接受我们的”意味着在发生冲突时，“我们”方的内容优先于“他们”方的内容。</p><p id="bf53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可以通过覆盖整个文档或合并文档的文本来解决冲突。例如，“我们”方的文件会覆盖“他们”方的文件。在其他情况下，当对文件进行比较并应用合并的补丁时,“我们的”方将优先于“他们的”方。“他们的”策略则相反。</p><p id="9bc3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">函数还可以提供应用程序的决策标准。该函数将“base”、“ours”和“theirs”中要比较的文件作为参数，并返回“ours”策略或“theirs”策略作为结果。</p><h1 id="ab17" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">添加文档数据库API</h1><p id="7704" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我已经在<a class="ae ln" href="https://gitddb.com/" rel="noopener ugc nofollow" target="_blank"> GitDocumentDB </a>中实现了上述规则，这是一个用TypeScript编写的库。您可以查看源代码，了解如何实现它，也有教程。</p><p id="83b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了自动同步和自动冲突解决之外，GitDocumentDB还提供了一个数据库API来处理Git中的JSON文档，使其易于用作数据库。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/5b65a77964c347c1502f2bf3772028aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*aKPDmN5vyxLWfd_s"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图6:添加文档数据库API。图片来源:作者</p></figure><p id="1e31" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">API包括读取、写入、更新、删除、正向匹配搜索、倒带修订、收集和使用队列的任务序列化。</p><p id="333c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用GitDocumentDB，应用程序开发人员在开发基于Git的应用程序时，不需要创建他们的API、自动同步或冲突解决。如果他们连接到GitHub，他们不需要服务器。</p><p id="9fe8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从JavaScript调用Git有两个广为人知的库:<a class="ae ln" href="https://github.com/isomorphic-git/isomorphic-git" rel="noopener ugc nofollow" target="_blank">同构-git </a>和<a class="ae ln" href="https://github.com/nodegit/nodegit" rel="noopener ugc nofollow" target="_blank">节点Git </a>。每一个都有其<a class="ae ln" href="https://gitddb.com/blog/git-engines" rel="noopener ugc nofollow" target="_blank">的优点和缺点</a>，但是GitDocumentDB兼容这两个库。</p><p id="1aa6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为一个在JavaScript/TypeScript中创建离线优先应用的平台，Electron可能是最好的选择。</p><h1 id="29aa" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">Git是CRDT吗？</h1><p id="a504" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">从理论的角度来看，Git似乎是一种<a class="ae ln" href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type" rel="noopener ugc nofollow" target="_blank">无冲突复制数据类型(CRDT) </a>，一种在分布式数据库中更新复制数据的模型。</p><p id="8437" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Git通常不被称为CRDT，但它从多个角度展现了CRDT的方方面面。我很少在社交网站上看到这种讨论。然而，他们没有对Git和现有的CRDTs进行具体的比较。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/306a03d0d5d7123b3234a85634f9630b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/0*tqJ-DJUtLmGxyBdo"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图Git的提交图。图片来源:作者</p></figure><p id="ba45" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，Git有一个多值寄存器(MV寄存器)的特性。MV-Register是一种CRDT，因为一块数据有多个版本，所以在不同地方同时编辑不会破坏数据。</p><p id="4124" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其次，Git具有只加单调DAG的特性。Git的提交图是一个有向无环图(DAG)。在这个图中，合并操作被设计成不破坏图结构，即使多个用户在不同的位置更新同一个提交图。这样的图是只加单调DAG，一种CRDT。</p><p id="9acc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Git对于分布式数据库有很好的特性，因为上面描述了CRDTs的最终一致性模型。坏的方面是Git没有为计算机提供确定性地同步和解决冲突的方法，如上所述。其他问题是Git没有类似于数据库的API，并且作为一个数据库来看有很多开销。</p><p id="4fed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">CRDTs通常都有数学证明，这里我只列出了表面的相似之处。希望有人来挑战这个证明。</p><h1 id="239a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">利弊</h1><p id="4d08" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">已经有很多离线优先的数据库了，那么我为什么要使用Git作为我的数据库呢？</p><p id="2c10" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简单的回答是GitDocumentDB兼容Git。分布式多主数据库和高效的CI/CD是从Git继承来的特性。</p><p id="69c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">优点:</strong></p><ul class=""><li id="4d1d" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm ni nj nk nl bi translated">除了版本冲突之外，它还通过解决事务性和一致性冲突来自动化Git同步工作流。</li><li id="e558" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated">典型的同步模式和差异修补策略可以解决这些问题。用于处理JSON reduce任务的可访问CRUD和集合API。</li></ul><p id="2c2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">缺点:</strong></p><ul class=""><li id="ab95" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm ni nj nk nl bi translated">GitDocumentDB的吞吐量和Git差不多。它没有典型的数据库快。</li><li id="57f0" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated">管理文档的多个修订版本时，存储容量会增加。</li></ul><p id="92df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些是Git特性的一个折衷。如果你的离线优先应用不需要Git兼容性，还有其他选择。另一个众所周知的具有多个主数据库的离线优先数据库是<a class="ae ln" href="https://pouchdb.com/" rel="noopener ugc nofollow" target="_blank"> PouchDB </a>。如果你想要基于CRDTs的高级同步，<a class="ae ln" href="https://github.com/automerge/automerge" rel="noopener ugc nofollow" target="_blank">自动合并</a>或<a class="ae ln" href="https://github.com/amark/gun" rel="noopener ugc nofollow" target="_blank">枪</a>是一个选项。</p><h1 id="1331" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/03e1e79e894384b522bd1fc5365b180f.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*HvM2eLs-dRJqssML"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图8:由Git提供支持。图片来源:作者</p></figure><p id="fe8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想在JavaScript/TypeScript中构建一个离线优先的应用，并且Git兼容性对你来说至关重要，那么<a class="ae ln" href="https://gitddb.com/" rel="noopener ugc nofollow" target="_blank">gitdocumendb</a>是一个强有力的候选。</p><p id="66e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有兴趣的请关注<a class="ae ln" href="https://twitter.com/gitddb" rel="noopener ugc nofollow" target="_blank"> @gitddb </a>。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="c676" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">[1]:下面的研究报告介绍了很多CRDTs，包括MV-Register和add-only单调DAG: Marc Shapiro，Nuno Preguiç，Carlos Baquero，Marek Zawirski。对收敛和可交换复制数据类型的综合研究。【研究报告】RR-7506，Inria —巴黎中心-罗奎考特；INRIA。2011年，第50页</p></div></div>    
</body>
</html>