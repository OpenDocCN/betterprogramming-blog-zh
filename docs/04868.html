<html>
<head>
<title>How to Pass Closures Between Sibling Views (and UIViewRepresentables) in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在SwiftUI中的兄弟视图(和UIViewRepresentables)之间传递闭包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/passing-closures-between-swiftui-sibling-views-and-uiviewrepresentables-1f81a6cf5be6?source=collection_archive---------7-----------------------#2020-05-18">https://betterprogramming.pub/passing-closures-between-swiftui-sibling-views-and-uiviewrepresentables-1f81a6cf5be6?source=collection_archive---------7-----------------------#2020-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5e34" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在组件之间共享状态</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4c2b4c11410b68e091fe32e14b3885ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5CQKkfHyjTtDvaVY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@jcmu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jose Murillo </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="0010" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看下面的场景:您有一个带有两个子视图<code class="fe lv lw lx ly b">ChildView1</code>和<code class="fe lv lw lx ly b">ChildView2</code>的<code class="fe lv lw lx ly b">ParentView</code>。在<code class="fe lv lw lx ly b">ChildView1</code>上，你有一个按钮可以触发<code class="fe lv lw lx ly b">ChildView2</code>中的一个动作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="cd68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在点击按钮，我们希望将文本字段中的文本更改为更合适的内容。让我们首先为闭包定义一个typealias。如果你不知道闭包是什么，它基本上就是一个方法。你可以在文档中读到更多关于闭包<a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="4725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将下面的typealias添加到我们的<code class="fe lv lw lx ly b">ParentView</code>声明之上:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="782a" class="mf mg it ly b gy mh mi l mj mk">typealias OnClickHandler = (() -&gt; Void)</span></pre><p id="70e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以就变成了:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="f860" class="mf mg it ly b gy mh mi l mj mk">typealias OnClickHandler = (() -&gt; Void)<br/><br/>struct ParentView: View {<br/>    ...<br/>}</span></pre><p id="2b9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并将其初始化为我们的<code class="fe lv lw lx ly b">ParentView</code>中的<code class="fe lv lw lx ly b">@State</code>属性:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="b51c" class="mf mg it ly b gy mh mi l mj mk">struct ParentView: View {<br/> <br/>   @State var onClick: OnClickHandler = { }<br/>   ...</span><span id="e62f" class="mf mg it ly b gy ml mi l mj mk">}</span></pre><p id="3f0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的想法是，在<code class="fe lv lw lx ly b">ParentView</code>中定义的这个<code class="fe lv lw lx ly b">onClick</code>是我们唯一的真理来源。我们不希望在调用堆栈的某个地方初始化另一个闭包。我们希望这一点传递给我们双方的孩子。</p><p id="5cdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在按钮所在的<code class="fe lv lw lx ly b">ChildView2</code>中，我们将它添加为<code class="fe lv lw lx ly b">@Binding</code>，因为它已经在<code class="fe lv lw lx ly b">ParentView</code>中初始化，而<code class="fe lv lw lx ly b">ChildView2</code>此时只对它进行操作。然后我们将它作为动作添加到我们的按钮:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="a05b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到，我们删除了旧的闭包，在这个闭包中我们将打印我们的消息，而只是将我们的作为参数传递。这不是强制性的，但是更短更干净。</p><p id="d66c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，您的<code class="fe lv lw lx ly b">ParentView</code>正在通知您，当您初始化<code class="fe lv lw lx ly b">ChildView2</code>时，您缺少了<code class="fe lv lw lx ly b">onClick</code>参数，所以让我们添加:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="7ca8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会注意到我们将<code class="fe lv lw lx ly b">$onClick</code> <strong class="lb iu"> </strong>传递给了<code class="fe lv lw lx ly b">ChildView2</code>，因为我们将属性定义为<code class="fe lv lw lx ly b">@Binding</code>，所以我们使用<code class="fe lv lw lx ly b">$</code>来传递绑定而不是值。</p><p id="d996" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在要对我们的<code class="fe lv lw lx ly b">ChildView1</code>做同样的事情——添加一个绑定属性——但是这一次我们也要编写当点击按钮时被调用的函数，并且我们要将该函数分配给我们传递的闭包:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="a92e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的神奇之处是在文本元素上调用<code class="fe lv lw lx ly b">onAppear</code> <strong class="lb iu"> </strong>。这意味着当那个字段出现时(想想UIKit中的<code class="fe lv lw lx ly b">viewDidAppear</code>，我们将运行下面的代码块。在这个代码块中，我们给我们的<code class="fe lv lw lx ly b">onClick</code>闭包分配了一个函数来修改我们的字符串的值。</p><p id="721f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想变得更有趣或者你的方法更大，你甚至可以将整个代码块提取到一个不同的方法中，并将其分配给<code class="fe lv lw lx ly b">onClick</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="4bde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，通过SwiftUI和Combine的魔力，您成功地链接了两个互不了解的视图。恭喜你！</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="6b79" class="mt mg it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated"><strong class="ak">奖金</strong></h1><p id="eb58" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">“如果我想在没有<code class="fe lv lw lx ly b">onAppear</code>的地方用一个视图和UIViewRepresentable来做这件事怎么办？”</p><p id="3cc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很好的问题，亚历克斯！</p><p id="7c91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们将使用函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="6c3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到我已经把它发送到一个后台线程。这是因为编译器会在运行时通知我们“在视图更新期间修改状态，这将导致未定义的行为。”</p><p id="3113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是苹果的说法，当视图被重绘时，我们在更新状态。</p><p id="703b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已。完整代码可在<a class="ae ky" href="https://gist.github.com/trusk89/9e9742e5e3b1663d568bc9dc71dcb0c7" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。编码快乐！</p></div></div>    
</body>
</html>