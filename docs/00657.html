<html>
<head>
<title>Why I Fell in Love With Ramda and Functional Programming in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我爱上了Ramda和JavaScript中的函数式编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-i-fell-in-love-with-ramda-and-functional-programming-in-javascript-797c070133b0?source=collection_archive---------2-----------------------#2019-06-26">https://betterprogramming.pub/why-i-fell-in-love-with-ramda-and-functional-programming-in-javascript-797c070133b0?source=collection_archive---------2-----------------------#2019-06-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/39528140e9b26d92b8ee26fd1c1a2dc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7A93nnWIwtDliB-0T_fZw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">Ramda.js</p></figure><p id="9db7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这一切都始于斯德哥尔摩2018年12月黑暗的一天。我搬到斯德哥尔摩，在一家新公司开始一份新工作，当我到达那里时，每个人都在为一月份的假期做准备。我的入职人员把我放在一个遗留项目上，这个项目是他们从黑客周项目中获得的，并告诉我对这个项目进行更改，并在4月份之前准备好投入生产。我想，<em class="ld">好吧，我开始了一份新工作，所以我应该在每个人度假回来的时候交付所有东西</em>。</p><p id="3025" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我打开git repo，发现这个项目完全是用JavaScript以反应式和函数式编程风格编写的。我没有任何JavaScript的反应式和函数式编程的背景。</p><p id="82e6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">之前的开发者确实使用了<a class="ae le" href="https://github.com/cujojs/most" rel="noopener ugc nofollow" target="_blank"> cujojs/Most </a>作为<a class="ae le" href="https://github.com/ReactiveX/rxjs" rel="noopener ugc nofollow" target="_blank"> RxJs </a>的替代，后者取了反应式编程部分，而<a class="ae le" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>取了函数式编程部分。</p><p id="13b2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当时，我只是盯着屏幕，试图理解这个<a class="ae le" href="https://github.com/cujojs/most" rel="noopener ugc nofollow" target="_blank"> Most库</a>是什么，它到底是做什么的。我花了大约两周的时间来理解核心概念。这个库的愚蠢的名字使得它无法在谷歌上搜索一些教程文章。唯一有知识的学习来源是Github Wiki页面。</p><p id="0f5c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">试着在谷歌中搜索下面的关键词(在第一页甚至其他有谷歌搜索结果的页面上，你都找不到任何有用的链接)。</p><p id="9f48" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">使用大多数JavaScript开始反应式编程。</strong></p><p id="fc4f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我的头脑花了很长时间才明白之前的开发者做了什么。但是随着我对<a class="ae le" href="https://github.com/cujojs/most" rel="noopener ugc nofollow" target="_blank"> cujojs/Most </a>、<a class="ae le" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>的了解越来越多，并把它们结合在一起，我发现了我作为一个开发者的生活中的一个新窗口。</p><p id="398a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我想分享一下我用<a class="ae le" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>和函数式编程的经验。我喜欢<a class="ae le" href="https://github.com/cujojs/most" rel="noopener ugc nofollow" target="_blank"> cujojs/Most </a>在反应式编程中的思考方式。还有很多其他选择，所以我觉得不能推荐<a class="ae le" href="https://github.com/cujojs/most" rel="noopener ugc nofollow" target="_blank"> cujojs/Most </a>。本文将只告诉你使用<a class="ae le" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>的好处以及函数式编程概念。</p><h1 id="7786" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">函数式编程</h1><p id="140e" class="pw-post-body-paragraph kf kg it kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">在开始函数式编程之前，我需要解释一下<a class="ae le" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>的一些概念和好处。然后，我们将研究一些真实世界的案例，在这些案例中，通过函数式编程，它变得更加容易和优雅。</p><h2 id="1c82" class="mi lg it bd lh mj mk dn ll ml mm dp lp kq mn mo lt ku mp mq lx ky mr ms mb mt bi translated"><strong class="ak">纯功能</strong></h2><p id="397e" class="pw-post-body-paragraph kf kg it kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">有一个函数的概念叫做纯函数<strong class="kh iu">。纯函数</strong>是一个接受输入并返回一个值的函数，而不依赖于其范围之外的任何数据(副作用)。输出或返回值必须依赖于输入/参数，并且必须返回值。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="bead" class="mi lg it mz b gy nd ne l nf ng">let b = 10;</span><span id="9437" class="mi lg it mz b gy nh ne l nf ng">function sum(a)<br/>{<br/>    return a + b;<br/>}</span><span id="6990" class="mi lg it mz b gy nh ne l nf ng">let c = sum(5);</span></pre><p id="0541" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上面的代码是一个不纯的函数。根据定义，它应该接受参数，只返回基于输入参数的值，而不依赖或更改范围外的变量。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="49bd" class="mi lg it mz b gy nd ne l nf ng">function sum( a , b )<br/>{<br/>    return a + b;<br/>}</span><span id="5f63" class="mi lg it mz b gy nh ne l nf ng">let s = sum(10 , 5)</span></pre><p id="1f61" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上面的函数是一个<strong class="kh iu">纯函数。</strong></p><p id="d4f1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">那么，我们为什么需要纯函数呢？在函数式编程中，把你的代码想象成一些块，它们集成在一起就能完成一项有意义的工作。这些模块是可重复使用的，并且可以针对不同的任务以不同的方式集成。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/3fcd7c654ff07f0dfa77a0e84cf18b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*imxtCJUNJWFV9_LVTYrg7w.jpeg"/></div></figure><p id="d8eb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这正是孩子们用乐高积木搭建东西的方式。每块积木都有一个概念和意义，以不同的方式组合在一起可以解决不同的问题。</p><h2 id="12fa" class="mi lg it bd lh mj mk dn ll ml mm dp lp kq mn mo lt ku mp mq lx ky mr ms mb mt bi translated"><strong class="ak">函数式编程的优势</strong></h2><ul class=""><li id="5f1c" class="nj nk it kh b ki md km me kq nl ku nm ky nn lc no np nq nr bi translated">编写测试更容易</li><li id="fb22" class="nj nk it kh b ki ns km nt kq nu ku nv ky nw lc no np nq nr bi translated">纯函数可读性更强</li><li id="bf17" class="nj nk it kh b ki ns km nt kq nu ku nv ky nw lc no np nq nr bi translated">更好的调试，因为纯函数和只检查输入和输出。</li><li id="a386" class="nj nk it kh b ki ns km nt kq nu ku nv ky nw lc no np nq nr bi translated">少写代码</li><li id="a38e" class="nj nk it kh b ki ns km nt kq nu ku nv ky nw lc no np nq nr bi translated">作为一等公民的职能</li><li id="20a4" class="nj nk it kh b ki ns km nt kq nu ku nv ky nw lc no np nq nr bi translated">综合代码</li><li id="c13a" class="nj nk it kh b ki ns km nt kq nu ku nv ky nw lc no np nq nr bi translated">更多可重用代码</li><li id="f6b4" class="nj nk it kh b ki ns km nt kq nu ku nv ky nw lc no np nq nr bi translated">等等。</li></ul></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="5b59" class="lf lg it bd lh li oe lk ll lm of lo lp lq og ls lt lu oh lw lx ly oi ma mb mc bi translated">现实世界的例子</h1><p id="b0b2" class="pw-post-body-paragraph kf kg it kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">我经常使用函数式编程进行对象操作。这里我们将研究一个复杂的对象操作。</p><p id="e45e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">假设我们有一个来自REST API调用的对象，如下所示:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="9068" class="mi lg it mz b gy nd ne l nf ng">var data = {<br/>  "result": {<br/>    "authors": [<br/>      {"id":101,"authorName":"Alice","phoneNumber":"555-1234"}, <br/>      {"id":124,"authorName":"John","phoneNumber":"893-4564" }<br/>    ],<br/>    "books": [<br/>      { "id": 434, "title": "Divergent", "author": 124 },<br/>      { "id": 435, "title": "The Giver", "author": 124 },<br/>      { "id": 434, "title": "The Maze Runner", "author": 101 }<br/>    ]<br/>  }<br/>}</span></pre><h2 id="aad3" class="mi lg it bd lh mj mk dn ll ml mm dp lp kq mn mo lt ku mp mq lx ky mr ms mb mt bi translated">案例1——我们想要获得一个作者姓名的数组。</h2><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="e05b" class="mi lg it mz b gy nd ne l nf ng">const {pipe , map, path} = require("ramda"); // import functions</span><span id="3baa" class="mi lg it mz b gy nh ne l nf ng">const pickAuthorNames = pipe(<br/>  path(["result" , "authors"] ),<br/>  map(item =&gt; item.authorName)<br/> );</span><span id="3ec9" class="mi lg it mz b gy nh ne l nf ng">pickAuthorName(data); // this will return ["Alice" , "John"]</span></pre><p id="f7a6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了熟悉<a class="ae le" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>的威力，我推荐看一下它的<a class="ae le" href="https://ramdajs.com/docs" rel="noopener ugc nofollow" target="_blank"> <em class="ld">文档</em> </a>和函数列表。</p><p id="68a7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">默认情况下，所有的<a class="ae le" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>函数都支持currying，简而言之，就是当你有一个接受两个参数的函数时。如果只提供其中一个参数，它将返回另一个接受第二个参数的函数。</p><p id="0be3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">例如，路径的最后一个参数总是您应该为函数提供的数据。第二个函数调用是currying。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="c1c9" class="mi lg it mz b gy nd ne l nf ng">1- path(["result","authors"] , data)</span><span id="6ae8" class="mi lg it mz b gy nh ne l nf ng">2- path(["result","authors"])(data)<br/></span></pre><p id="fdd5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">管道函数将函数集成在一起。当您为管道提供输入时，它会将值传递给第一个函数，然后用第一个函数调用的结果调用第二个函数。</p><h2 id="e3b5" class="mi lg it bd lh mj mk dn ll ml mm dp lp kq mn mo lt ku mp mq lx ky mr ms mb mt bi translated">案例2——为了尝试更复杂的东西，让我们在作者和书籍之间做一个内部连接</h2><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="9092" class="mi lg it mz b gy nd ne l nf ng">const {pipe , map, path, filter, head, mergeDeepLeft} = require("ramda");</span><span id="de49" class="mi lg it mz b gy nh ne l nf ng">const getAuthor = (id) =&gt; pipe( // create function to get an author<br/>  path(["result" , "authors"]), // gets authors arrays<br/>  filter(item =&gt; item.id === id), // find an array of items with id<br/>  head // picks the first one<br/>)</span><span id="62f0" class="mi lg it mz b gy nh ne l nf ng">const getJoin = (data) =&gt; <br/>pipe(<br/>  path(["result" , "books"]), // get list of books<br/>  map(item =&gt; // join items<br/>    mergeDeepLeft(item ,getAuthor(item.author)(data)) <br/>  )<br/>)(data)</span><span id="f827" class="mi lg it mz b gy nh ne l nf ng">getJoin(data)</span></pre><p id="2eb7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">创建了两个功能，并轻松地将它们集成在一起。如果你不熟悉函数式编程，一开始，你可能会看一下这段代码，然后想<em class="ld">哈哈</em>！🧐</p><p id="25d4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是请相信我，这些代码是可读的，并且编写测试要容易得多。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/6372540b85bfd80f771eee3f4230af4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*2tUrW7CfHRux-idpbo_lrQ.jpeg"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">在函数式编程中思考就像在块中思考一样。</p></figure><h1 id="00b9" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论:<a class="ae le" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a> vs Loadash vs下划线</h1><ul class=""><li id="a5cd" class="nj nk it kh b ki md km me kq nl ku nm ky nn lc no np nq nr bi translated"><strong class="kh iu">curry:</strong>默认情况下，所有<a class="ae le" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>函数都支持curry。</li><li id="88f7" class="nj nk it kh b ki ns km nt kq nu ku nv ky nw lc no np nq nr bi translated"><strong class="kh iu">不可变结构:</strong> <a class="ae le" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>强烈支持输入参数不可变。</li><li id="a0ad" class="nj nk it kh b ki ns km nt kq nu ku nv ky nw lc no np nq nr bi translated">家里最小的</li><li id="9abd" class="nj nk it kh b ki ns km nt kq nu ku nv ky nw lc no np nq nr bi translated">良好的功能界面</li></ul><p id="7258" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你需要考虑的最重要的事情是改变你的思维模式来解决函数式编程中的问题。把每个功能想象成一个模块，把它们组合在一起就能解决问题。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/591567c8f1d6f6095cb13952a7ae23c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*bBn49rQ1wYnrVaTJ5Jzutw.jpeg"/></div></figure><p id="e525" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我选择了拉姆达，并喜欢和它一起工作。它提供了一整套优化的功能，可在不同的情况下使用，并以一种简单的方式集成在一起。</p></div></div>    
</body>
</html>