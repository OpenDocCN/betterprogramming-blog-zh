# 使用 Go 中的“快速”库编写更好的测试

> 原文：<https://betterprogramming.pub/test-better-with-quick-library-in-go-1bc59074b5b>

## 知道什么是魔快库吗？

![](img/7b295d40b4b760bd21b087b8f4517481.png)

*“我的单元测试通过了！”—著名遗言*

> 包`quick`实现了实用函数来帮助黑盒测试。

[测试包](https://pkg.go.dev/testing/quick)中的快速库可用于基于属性的测试。如果你熟悉 Haskell 的 [QuickCheck，它们非常相似。](https://hackage.haskell.org/package/QuickCheck)

## 让我们整理一下其中一些术语的含义…

**基于属性的测试**根据一系列自动生成的输入来验证组件或系统的预期行为，并确保其成立。

**黑盒测试**涉及在没有任何内部工作知识的情况下测试一个组件或系统。

通过将所有这些部分放在一起，这意味着如果我们知道函数的属性是什么，我们可以使用这个神奇的库对它们进行黑盒测试！

好了，现在我们知道它的功能了。让我们用一个简单的例子来尝试一下。

## 减法

让我们使用上面的例子，并想出几个它的属性的例子:

1.  如果`a > b`，结果将是**阳性**
2.  如果`b > a`，结果将是**否定**
3.  如果`a == b`，结果将是**零**
4.  如果`b < 0`，结果将大于`a`
5.  这样的例子不胜枚举…

我觉得数字`4`是最有趣的例子！让我们利用这一点！

传统上，我们将使用基于实例的测试，我们预先定义一些输入和它们各自的输出，断言它们并确保它们相符。例如:

我们现在有了一个简单的基于实例的测试的例子，它测试了属性号`4`。

然而，这真的够了吗？现在，让我们尝试在相同的属性上使用基于属性的测试！🔍

这似乎是合理的。我们只关心`b`小于`0`的测试用例。因此，我们忽略所有`b`为正的测试用例。

好吧，我们的时间到了！让我们运行这个！

```
--- FAIL: TestSubtractPropertyFour (0.00s)
    sub_test.go:19: #1: failed on input 9071749008449132817, -404711346371707334
```

让我手动操作…

如果`a`是`9071749008449132817`，`b`是`-404711346371707334`，那就意味着从数学上来说，`9071749008449132817 — (-404711346371707334)`就是说`9071749008449132817 + 404711346371707334`应该是表达式。这显然意味着我们的财产号`4`是真实的。

好吧…所以一定是哪里出了问题，是时候找出问题了！

有很多方法可以调试这个问题，但是我有点大胆地使用编译器，通过声明上述输入的减法常数来告诉我哪里出错了。

这是 Go 编译器的结果…

```
cannot use 9071749008449132817 - (-8970283718888711465) (untyped int constant 18042032727337844282) as int value in constant declaration (overflows)
```

> 🌊🌊🌊🌊🌊🌊啊…所以溢出来了！🌊🌊🌊🌊🌊🌊

这就对了。我们已经找到了一个测试用例，它将炸毁我们看似无辜的*减法函数。*

# 结论

我们已经见证了基于属性的测试是多么不可思议。使用这个库，我们可以轻松地生成成千上万的随机测试用例，而不是使用基于实例的测试。当然，为您正在编写的每个函数找到属性并不总是一件简单的任务。

即使你现在可能无法应用它，我相信有一天它会派上用场的！