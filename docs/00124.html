<html>
<head>
<title>What Every Programmer Should Know About ‘String’</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个程序员都应该知道的“字符串”</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-every-programmer-should-know-about-string-a6611537f84e?source=collection_archive---------0-----------------------#2018-04-23">https://betterprogramming.pub/what-every-programmer-should-know-about-string-a6611537f84e?source=collection_archive---------0-----------------------#2018-04-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0fabaa8238f335f6070195ff78ee043c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_oci0catb5JTI5w-B5u4w.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">在<a class="ae kf" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kf" href="https://unsplash.com/photos/zFz3jThypsA?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杯子先生/杨奇煜·巴拉</a>拍摄的照片</p></figure><p id="474c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“字符串”是一系列字符。</p><p id="357a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑到你很可能是一名程序员，你很可能已经知道这个定义。我认为假设你已经在至少一种编程语言中使用过<code class="fe le lf lg lh b">String</code>是公平的。</p><p id="f9fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管如此，我还是要再提醒你一次——编程世界里的<code class="fe le lf lg lh b">String</code>与<a class="ae kf" href="https://www.forbes.com/sites/startswithabang/2016/11/25/what-every-layperson-should-know-about-string-theory/#27fc88395a53" rel="noopener ugc nofollow" target="_blank"> <em class="li">弦理论没有任何关系</em> </a> <a class="ae kf" href="http://bigbangtheory.wikia.com/wiki/Sheldon_Cooper" rel="noopener ugc nofollow" target="_blank">谢尔顿·库珀</a>比其他任何物理学家都更普及。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="739d" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">介绍</h1><p id="ccf1" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">在本文中，我将向您介绍一些与<code class="fe le lf lg lh b">String</code>相关的非常重要的概念和术语，您可能需要在日常编程中使用它们。</p><p id="9caa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，熟悉这些术语也许有一天会对你的工作面试有所帮助，谁知道呢？</p><p id="734a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管有些术语从语言学的角度来看有着复杂的含义，但我会尽量避免使用难懂的词，并从程序员需要理解的角度来解释。</p><p id="1ee0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一件需要提及的事情是，我不会展示任何代码示例，也不会展示如何用你喜欢的语言进行字符串操作。</p><p id="7958" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我只谈术语和概念，你的工作是在需要的时候找出如何使用它们。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="632d" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">字符编码</h1><p id="ec48" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">一个<code class="fe le lf lg lh b">String</code>的主要组件是一个<code class="fe le lf lg lh b">Character</code>，但是你可能已经知道了。但你知道字符只是代码表示吗？</p><p id="63bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的意思是，计算机不知道字符、字母等。，也不会将它们存储在内存中。计算机将它们存储为数字(准确地说是二进制)。</p><p id="80e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一些约定来定义哪个数字代表哪个字符。这个字符集将一些数字或代码点映射到文本字符。</p><p id="e885" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，在视觉表示时，计算机从内存中读取它们，并基于该映射将它们表示为字符。这种映射和字符表示被称为<em class="li">字符编码</em>。</p><p id="616d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">【http://kunststube.net/encoding/】(如果点击链接不起作用，试试这个链接:<a class="ae kf" href="http://kunststube.net/encoding/" rel="noopener ugc nofollow" target="_blank"/>)这篇文章很好地解释了它的一切。所以，我建议你读一下，以便更好地理解字符编码。</p><p id="3aeb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数程序员新手(尤其是那些用类C语言开始编程的人)都认为世界上所有的字符都是单字节的，显然是ASCII字符。</p><p id="a31e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我不怪他们，因为我也是他们中的一员。但是现在我知道这不是真的，有一个巨大的Unicode字符世界，作为一名程序员，你需要经常与它们打交道。</p><p id="04b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，你需要记住的第一件事是:</p><p id="0df1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">世界上所有的字符并不都是平等的，它们也不总是单字节字符。</p><p id="4627" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数Unicode字符可以存储为16位或2字节数据类型。</p><p id="66a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但还是有一些不能。Unicode 中定义了超过136000个码位，其中两个字节可以存储多达65536个字符。</p><p id="d523" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，需要多字节数据类型来存储余数。你应该记住:</p><ul class=""><li id="99f7" class="mt mu it ki b kj kk kn ko kr mv kv mw kz mx ld my mz na nb bi translated">一些编程语言(C，<a class="ae kf" href="http://www.cplusplus.com/doc/tutorial/" rel="noopener ugc nofollow" target="_blank"> C++ </a>等。)提供专门用于ASCII字符的单字节数据类型(<code class="fe le lf lg lh b">char</code>)和用于Unicode的多字节数据类型(<code class="fe le lf lg lh b">wchar_t</code>)。</li><li id="8792" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">一些编程语言(Java等。)对于字符类型只有多字节数据类型。</li><li id="cae7" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">一个字节=一个字符的日子已经一去不复返了，你需要记住这一点。</li></ul><p id="6f52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们在做的时候，让我们给你另外一点信息。</p><p id="c845" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字符编码可以是固定长度或可变长度。</p><p id="a56a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能听说过像UTF 8，UTF-16，UTF-32等编码方案。虽然还有各种其他编码，但是让我们简单了解一下这三种Unicode字符编码。</p><ul class=""><li id="5d9b" class="mt mu it ki b kj kk kn ko kr mv kv mw kz mx ld my mz na nb bi translated">UTF-16以单个16位字符类型表示大多数常用的Unicode码位。它使用两个16位字符来表示余数。这意味着UTF-16是一种可变长度编码，使用最小16位(两个字节)和最大32位(四个字节)。</li><li id="c9e5" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">UTF-8使用一到四个8位字符对所有Unicode码位进行编码。它也是另一种可变长度编码，用一个字节表示ASCII字符。(这很方便，因为这意味着ASCII文本在UTF-8中也是有效的)其余的代码根据需要分成两个、三个或四个字节。</li><li id="cfb1" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">UTF-32对所有字符使用四个字节。这是一种固定长度的编码。</li></ul><p id="73b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你使用国际化和本地化时，你的字符编码知识可能会派上用场。此外，你可以从<a class="ae kf" href="https://www.quora.com/What-is-the-file-size-of-text-that-is-200-characters" rel="noopener ugc nofollow" target="_blank">这个单独的讨论线索</a>中猜到，这些知识在其他方面也非常重要，比如你的文本会消耗多少空间和内存，基于它的编码。</p><p id="30b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我要说的是，在处理<code class="fe le lf lg lh b">String</code>或<code class="fe le lf lg lh b">Text</code>时，要小心字符编码。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="74db" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">字符串不变性</h1><p id="c3ec" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">大多数语言都提供<code class="fe le lf lg lh b">String</code>作为基本数据类型。关于你正在使用的语言，你需要知道的是你的语言的<code class="fe le lf lg lh b">String</code>数据类型是<code class="fe le lf lg lh b">Mutable</code> <strong class="ki iu"> </strong>还是<code class="fe le lf lg lh b">Immutable</code>。</p><p id="2c29" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，Java和<a class="ae kf" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a> <code class="fe le lf lg lh b">String</code>类型是<code class="fe le lf lg lh b">Immutable</code>。</p><p id="83c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你试图把一个<code class="fe le lf lg lh b">Immutable</code> <code class="fe le lf lg lh b">String</code>当作<code class="fe le lf lg lh b">Mutable</code>来处理，它会抛出一个错误，你可能会怀疑你的字符串出了什么问题。</p><p id="9b04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能很想知道为什么在一些语言中字符串是<code class="fe le lf lg lh b">Immutable</code>。</p><p id="4f73" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们来稍微探索一下。</p><p id="153d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你看，在C之类的语言中，它们将字符串存储为字符数组，充当通用数组。因此，正如您可以轻松地改变数组一样，您也可以改变<code class="fe le lf lg lh b">String</code>。</p><p id="0cd9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，像Java和Python这样的语言将<code class="fe le lf lg lh b">String</code>视为<code class="fe le lf lg lh b">Object</code>，它们留出一个特殊的内存区域，称为<em class="li">字符串常量池</em>。</p><p id="7f03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当编译器看到一个<code class="fe le lf lg lh b">String</code>字面值时，它会在池中寻找<code class="fe le lf lg lh b">String</code>。如果找到匹配，对新文字的引用指向现有的<code class="fe le lf lg lh b">String</code>并且不创建新的<code class="fe le lf lg lh b">String</code>对象。</p><p id="335f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现有的<code class="fe le lf lg lh b">String</code>只是多了一个参考。</p><p id="c402" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使字符串对象不可变的要点是:</p><p id="9e6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe le lf lg lh b">String</code>常量池中，<code class="fe le lf lg lh b">String</code>对象可能有一个或多个引用。如果几个引用指向同一个字符串，而自己却不知道，如果其中一个引用修改了那个<code class="fe le lf lg lh b">String</code>值，那就糟了。</p><p id="4f3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是为什么<code class="fe le lf lg lh b">String</code>对象是不可变的。</p><p id="289e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在使用它们之前，请确保在您最喜欢的语言中字符串的不变性。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="de19" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">字符串术语</h1><p id="4919" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">是时候学习一些术语了。</p><h2 id="e4be" class="nh lr it bd ls ni nj dn lw nk nl dp ma kr nm nn me kv no np mi kz nq nr mm ns bi translated">子链</h2><p id="780a" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">字符串<em class="li"> S </em>的子串，是出现在<em class="li"> S </em>中的字符串。</p><p id="bed6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们说得更清楚些。</p><p id="cb0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字符串的任何连续部分都是它的子串。因此，“is nice”是字符串“This is nice”的子字符串。但是' nice is '不是，因为' nice is '在字符串' This is nice '中找不到。<strong class="ki iu">您必须在字符串中找到子字符串。</strong></p><p id="34a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字符串"<em class="li"> apple </em>"的所有子字符串列表将是:<br/> " <em class="li"> apple </em>"，<em class="li"> appl </em>"，<em class="li"> pple </em>"，<em class="li"> app </em>"，<em class="li"> ppl </em>"，<em class="li"> ple </em>"，<em class="li"> ap </em>"，<em class="li"> pp </em>"，"</p><h2 id="b51b" class="nh lr it bd ls ni nj dn lw nk nl dp ma kr nm nn me kv no np mi kz nq nr mm ns bi translated">前缀</h2><p id="3229" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">字符串<em class="li"> S </em>的前缀是出现在<em class="li"> S </em>的<em class="li">开始</em>处的<em class="li"> S </em>的子串。</p><p id="afbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">举个例子可能会更清楚。</p><p id="f41a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字符串"<em class="li"> apple </em>"的所有前缀列表将是:<br/> " <em class="li"> apple </em>"，<em class="li"> appl </em>"，<em class="li"> app </em>"，<em class="li"> ap </em>"，<em class="li"> a" </em></p><p id="4c6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，要成为前缀，子字符串需要从该字符串的开头开始。</p><p id="d272" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字符串的<em class="li">固有前缀</em>不等于字符串本身。所以，“苹果”不会是一个合适的“苹果”前缀。</p><h2 id="159f" class="nh lr it bd ls ni nj dn lw nk nl dp ma kr nm nn me kv no np mi kz nq nr mm ns bi translated">后缀</h2><p id="42f8" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">字符串<em class="li"> S </em>的后缀是出现在<em class="li"> S </em>的<em class="li">末端</em>的<em class="li"> S </em>的子串。</p><p id="1664" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字符串"<em class="li"> apple </em>"的所有后缀列表如下:<br/> " <em class="li"> apple </em>"，<em class="li"> pple </em>"，<em class="li"> ple </em>"，<em class="li"> le </em>"，<em class="li"> e </em>"</p><p id="a26e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，要成为后缀，子字符串需要在该字符串的末尾结束。</p><p id="2bc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字符串的<em class="li">正确后缀</em>不等于字符串本身。所以，“苹果”不会是一个合适的“苹果”后缀。</p><h2 id="e964" class="nh lr it bd ls ni nj dn lw nk nl dp ma kr nm nn me kv no np mi kz nq nr mm ns bi translated">随后</h2><p id="055c" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">子序列的正式定义是:</p><blockquote class="nt"><p id="0058" class="nu nv it bd nw nx ny nz oa ob oc ld dk translated"><em class="od">“一个</em> <strong class="ak"> <em class="od">子序列</em> </strong> <em class="od">是一个可以通过删除一些元素或者不删除元素而不改变剩余元素顺序的序列。”— </em> <a class="ae kf" href="https://en.wikipedia.org/wiki/Subsequence" rel="noopener ugc nofollow" target="_blank"> <em class="od">维基百科</em> </a></p></blockquote><p id="3ca6" class="pw-post-body-paragraph kg kh it ki b kj oe kl km kn of kp kq kr og kt ku kv oh kx ky kz oi lb lc ld im bi translated">我用简单的话解释一下。</p><p id="556b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字符串是一系列字符，对吗？因此，如果我们选择一些字符，保持出现在原始<code class="fe le lf lg lh b">String</code>中的相同序列，那么得到的<code class="fe le lf lg lh b">String</code>将是原始字符串的子序列。</p><p id="d7bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有一个字符串“Hello”。那么“eo”就是该字符串的子序列。</p><p id="e6aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但“ol”不会是子序列，因为它没有出现在“Hello”的同一个序列中。</p><p id="c41a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">单词"<em class="li"> apple </em>"的所有子序列列表将是:<br/> " <em class="li"> e，l，le，p，pe，pl，ple，p，pe，pl，ple，pp，ppe，ppl，pple，a，ae，al，ale，ap，ape，apl，aple，ap，ape，apl，aple，app，appe，appl，apple" </em>。</p><p id="8fa0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你知道子串和子串的区别吗？</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="ecbc" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">常见操作</h1><p id="aca8" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">让我们来学习一些<code class="fe le lf lg lh b">Strings</code>的常用操作。</p><h2 id="7a89" class="nh lr it bd ls ni nj dn lw nk nl dp ma kr nm nn me kv no np mi kz nq nr mm ns bi translated">串联</h2><p id="2d06" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这意味着将两个或更多的字符串连接在一起。</p><p id="5fab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设有两个字符串:<em class="li">【你好】</em>和<em class="li">【世界】</em>。这两个字符串的串联结果产生另一个字符串<em class="li">‘Hello World’</em>。</p><h2 id="39c3" class="nh lr it bd ls ni nj dn lw nk nl dp ma kr nm nn me kv no np mi kz nq nr mm ns bi translated">大写/大小写折叠</h2><p id="20fa" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这意味着将字符串中的所有字符都转换成相同的大小写，无论是小写还是大写。</p><p id="253b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大写有各种用例。</p><p id="1afb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个用例:如果您需要以不区分大小写的方式在两个<code class="fe le lf lg lh b">Strings</code>之间进行比较，您总是需要将两个文本规范化为小写或大写。</p><p id="158b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好吧，说实话，事情不会总是那么简单。如果您的字符串包含非拉丁字符，您将面临一些奇怪的情况。</p><p id="2d75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设你的字符串是<em class="li">resume</em>。要将字符串转换为大写，通常需要将[a-z]字符集转换为[A-Z]字符集。</p><p id="d129" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，é的大写字母是什么？在这种情况下，您需要考虑其他因素，比如Unicode规范化等等。在本文中了解更多信息。</p><h2 id="65c2" class="nh lr it bd ls ni nj dn lw nk nl dp ma kr nm nn me kv no np mi kz nq nr mm ns bi translated">加入</h2><p id="4ca2" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">虽然从名字上看‘join’和‘concatenation’相似，但是它们之间有一个微妙但重要的区别。</p><p id="38b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与连接不同，join在每个字符串元素之间使用给定的“分隔符”或“粘合”来连接字符串。</p><p id="13b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果给定的字符串列表如下:<em class="li"> ['Hello '，' world '，' again']，</em>以及分隔符/胶水<strong class="ki iu"> '-' </strong>，那么得到的字符串将是:<em class="li"> 'Hello-world-again' </em>。</p><p id="2624" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在某些情况下，分隔符可以是空字符串(“”)，其行为与串联完全一样。</p><h2 id="dfe1" class="nh lr it bd ls ni nj dn lw nk nl dp ma kr nm nn me kv no np mi kz nq nr mm ns bi translated">分割/标记化</h2><p id="e945" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">分割或标记字符串意味着根据一个或一组分隔符将单个字符串分解成几个部分。</p><p id="4122" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设你有一个<code class="fe le lf lg lh b">String</code>:<em class="li">‘为什么这么严肃？’</em></p><p id="b1ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果你基于空白标记这个字符串，你将得到一个字符串或标记的列表:<em class="li"> ['Why '，' so '，' serious？'】</em>。</p><p id="1ac9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，分隔符不会包含在结果字符串中。</p><p id="0698" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，在某些情况下，您可能需要基于模式对字符串进行标记化，而不是基于某些特定的分隔符。这可以通过<a class="ae kf" href="https://en.wikipedia.org/wiki/Regular_expression" rel="noopener ugc nofollow" target="_blank">正则表达式</a>轻松完成。</p><h2 id="190c" class="nh lr it bd ls ni nj dn lw nk nl dp ma kr nm nn me kv no np mi kz nq nr mm ns bi translated">修剪/剥离</h2><p id="37ed" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">修剪或剥离字符串通常意味着从字符串中删除前导和尾随空白。</p><p id="3c3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个上下文中，空白是所有的空白字符(空格、制表符、不间断空格等。)和所有的<a class="ae kf" href="https://en.wikipedia.org/wiki/Newline" rel="noopener ugc nofollow" target="_blank">行结束符(LF，CR等。)</a>。</p><p id="6470" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，一个给定的字符串:<em class="li">‘这很简单’</em>在修剪/剥离后将是<em class="li">‘这很简单’</em>。</p><p id="02d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">修剪/剥离的变体包括:</p><ul class=""><li id="5ac4" class="mt mu it ki b kj kk kn ko kr mv kv mw kz mx ld my mz na nb bi translated">仅修剪/去除前导(左修剪)或尾随(右修剪)空白。</li><li id="8498" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">字符串中的任何空白字符序列都被替换为一个空格，这也称为“空格规范化”。</li></ul><h2 id="9731" class="nh lr it bd ls ni nj dn lw nk nl dp ma kr nm nn me kv no np mi kz nq nr mm ns bi translated">词典排序</h2><p id="91dd" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">有时你需要为字符串列表定义一个顺序。</p><p id="53a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最流行的排序是<strong class="ki iu"> ' </strong>字典序'，也叫‘字母序’或‘字典序’。</p><p id="3a99" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你见过单词在字典里是如何排序的？这正是字典顺序。</p><p id="3d5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，如果你按字典顺序排列单词列表<em class="li"> ['蚂蚁'，'斑马'，'苹果'，'苹果车'] </em>，它将是:</p><pre class="oj ok ol om gt on lh oo op aw oq bi"><span id="749e" class="nh lr it lh b gy or os l ot ou">Zebra <br/>ant<br/>apple<br/>applecart</span></pre><p id="ad91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，在字典顺序中，大写字母在小写字母之前，这就是为什么“斑马”在“蚂蚁”之前。</p><p id="807b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，较长的字符串出现在相同的前缀较小的字符串之后，这就是为什么“apple”在“applecart”之前。</p><h2 id="8ded" class="nh lr it bd ls ni nj dn lw nk nl dp ma kr nm nn me kv no np mi kz nq nr mm ns bi translated">字符串搜索/比较</h2><p id="4a17" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">您经常会执行与某种字符串搜索和/或比较直接或间接相关的任务。</p><p id="fd2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">先说一些常见的字符串/模式匹配的类型。</p><p id="dbae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中最常见的是检查两个字符串之间的精确匹配。你会认为你用==操作符做到了。</p><p id="117d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是我想给你一个简单的建议，也许有一天会让你免除很多麻烦。</p><p id="8919" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果将两个字符串存储在两个变量中，并尝试用==运算符检查它们的相等性，您需要知道您的编程语言是在进行值匹配还是只是引用匹配。</p><p id="167a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你的编程语言将<code class="fe le lf lg lh b">String</code>视为<code class="fe le lf lg lh b">Object</code>，那么当你试图用==操作符<a class="ae kf" href="https://stackoverflow.com/questions/513832/how-do-i-compare-strings-in-java" rel="noopener ugc nofollow" target="_blank">检查两个<code class="fe le lf lg lh b">String</code> <code class="fe le lf lg lh b">Object</code>时，它将检查两个</a> <code class="fe le lf lg lh b"><a class="ae kf" href="https://stackoverflow.com/questions/513832/how-do-i-compare-strings-in-java" rel="noopener ugc nofollow" target="_blank">Object</a></code> <a class="ae kf" href="https://stackoverflow.com/questions/513832/how-do-i-compare-strings-in-java" rel="noopener ugc nofollow" target="_blank">的引用是否相等，而不是它们的值</a>。</p><p id="f082" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，其他编程语言可能只是检查这两个字符串变量的值是否相等。所以，记住这一点。</p><p id="6ef5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你在谷歌搜索或手机的联系人搜索中见过自动完成或自动建议功能，对吗？</p><figure class="oj ok ol om gt ju gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/ec0b88f925e2787f0dda17034a691b5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*hIMhwVvHvbyoc4Ljdeqt_w.png"/></div></figure><p id="4caf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您仔细观察，您会发现它们正在进行某种形式的前缀匹配。</p><p id="150b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你输入的字符串和他们已经存储的字符串列表。</p><p id="6d2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，如果需要的话，你会怎么自己做呢？如果您的字符串列表不是很大，您可以采取任何方法来匹配所有的字符串。但是对于大型列表来说，这种方法效率不高。</p><p id="6017" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有效的方法是使用复杂的数据结构，如<a class="ae kf" href="https://en.wikipedia.org/wiki/Trie" rel="noopener ugc nofollow" target="_blank"> trie </a>。详细的讨论超出了本文的范围，所以您应该自己深入研究。</p><p id="17ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似地，如果您需要进行后缀匹配，您可以通过存储字符串的逆序以及实际的字符串，将问题转化为前缀匹配问题，或者您可以使用<a class="ae kf" href="https://en.wikipedia.org/wiki/Suffix_tree" rel="noopener ugc nofollow" target="_blank">后缀树</a>的帮助。</p><p id="c1e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有时，您需要进行模式匹配，例如检查一个字符串是否是给定字符串的子字符串，或者是否可以在给定字符串中找到模式。</p><p id="8de7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这些情况下，您需要从各种<a class="ae kf" href="https://en.wikipedia.org/wiki/String_searching_algorithm" rel="noopener ugc nofollow" target="_blank">字符串搜索算法</a>中获取帮助，并选择满足您需求的算法。</p><p id="7fc0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在某些情况下，当我们运行搜索时，我们希望找到相关的结果，不仅是我们在搜索栏中键入的精确表达式，还包括我们使用的单词的其他可能形式。</p><p id="0a51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们在搜索栏中键入了<em class="li">“run”</em>，我们很可能希望看到包含表单<em class="li">“ran”</em>和<em class="li">“running”</em>的结果。</p><p id="67d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可以通过两种可能的方法来实现:<a class="ae kf" href="https://nlp.stanford.edu/IR-book/html/htmledition/stemming-and-lemmatization-1.html" rel="noopener ugc nofollow" target="_blank">词干化和</a>。</p><p id="65c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两个过程的目的是一样的:将每个单词的屈折形式简化为一个共同的基础或词根。虽然这个术语在<a class="ae kf" href="https://en.wikipedia.org/wiki/Natural-language_processing" rel="noopener ugc nofollow" target="_blank"> NLP </a>中最流行，但它也用于数据库系统中的全文搜索机制和文本搜索引擎，如<a class="ae kf" href="https://www.elastic.co/guide/en/elasticsearch/guide/current/stemming.html" rel="noopener ugc nofollow" target="_blank"> Elasticsearch </a>。</p><p id="ebd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我<em class="li"> </em>最后要提的是‘音标串匹配’。语音算法根据单词的发音对其进行索引。</p><p id="a534" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，如果你想通过发音来匹配两个单词，你需要使用语音算法。语音算法最常见的用途是拼写检查、搜索等。</p><p id="ded4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有几种语音算法可以完成这项工作，如<a class="ae kf" href="https://en.wikipedia.org/wiki/Soundex" rel="noopener ugc nofollow" target="_blank"> Soundex </a>、<a class="ae kf" href="https://en.wikipedia.org/wiki/Metaphone" rel="noopener ugc nofollow" target="_blank"> Metaphone、</a>等。但是请注意，大多数语音算法是为英语开发的。它们可能不像您预期的那样适用于其他语言。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="783e" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结论</h1><p id="a38c" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">在这篇文章中，我主要关注的是让您熟悉<code class="fe le lf lg lh b">String</code>和文本处理的流行词汇。我可能给了你很多信息，但没有详细解释，但如果你知道术语，你可以自己详细探索，如果有必要的话。</p><p id="5efe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，今天就到此为止。感谢阅读！</p></div></div>    
</body>
</html>