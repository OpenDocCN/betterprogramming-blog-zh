<html>
<head>
<title>19 Java Collection Classes With Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">19个Java集合类及示例</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/19-java-collection-classes-with-examples-1597f106d0f2?source=collection_archive---------19-----------------------#2022-01-24">https://betterprogramming.pub/19-java-collection-classes-with-examples-1597f106d0f2?source=collection_archive---------19-----------------------#2022-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="900a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">每个Java程序员应该知道的基本概念</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0d8ec09ae9839e5fde905b81c894fa4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z12bWM_7LVgaoxV3OHKblg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/photo/abstract-close-up-cobweb-connection-276502/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>的<a class="ae ky" href="https://www.pexels.com/@pixabay?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="8c9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将展示用于在Java中处理数据的集合框架的主要方法。这个框架提供了一个架构，用于通过不同的接口和实现来存储和操作不同的对象。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f452" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">目录</h2><p id="51db" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">列表界面在<code class="fe na nb nc nd b">Java.util</code>包中定义。它包括基于索引的方法来插入、更新、删除和搜索元素。它也可以有重复元素和空元素。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="bd5c" class="mc md it nd b gy ni nj l nk nl">public interface List&lt;E&gt; extends Collection&lt;E&gt;</span></pre><h2 id="1452" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">数组-数组列表</h2><h2 id="0cf6" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><strong class="ak">数组</strong></h2><p id="f309" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Array类是List接口的实现。这个类可以包含多个值，不像常规变量只包含一个值。</p><p id="7931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="5f31" class="mc md it nd b gy ni nj l nk nl">//Need to specify the size for array<br/><strong class="nd iu">int</strong>[] array1 = <br/> new<!-- --> <!-- -->int[4];</span><span id="ab8b" class="mc md it nd b gy nm nj l nk nl">array1[0] = 1;<br/>array1[1] = 2;<br/>array1[2] = 3;<br/>array1[3] = 4;</span></pre><h2 id="ddb2" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><strong class="ak">数组列表</strong></h2><p id="58f2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">List接口的<code class="fe na nb nc nd b">ArrayList</code>实现是使用最广泛的实现之一，并且不需要同步访问。</p><p id="92a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两种情况下，我们都可以获得位于索引位置的任何数据。</p><p id="e038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="4c99" class="mc md it nd b gy ni nj l nk nl">//It is not necessary to specify the size<br/>ArrayList&lt;Integer&gt; array2 =<br/> <strong class="nd iu">new</strong> <!-- -->ArrayList&lt;Integer&gt;();</span><span id="8484" class="mc md it nd b gy nm nj l nk nl">array2.add(1);<br/>array2.add(2);</span></pre><p id="ae16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe na nb nc nd b">Array</code>是固定长度的数据结构，而<code class="fe na nb nc nd b">ArrayList</code>是可变长度的集合类。</p><p id="88c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不能在<code class="fe na nb nc nd b">ArrayList</code>中存储原语；它只能存储对象。但是数组可以包含原语和对象。</p><h2 id="ebfe" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">矢量</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="611e" class="mc md it nd b gy ni nj l nk nl">public class Vector&lt;E&gt;  extends Object&lt;E&gt;  implements List&lt;E&gt;, Cloneable, Serializable</span></pre><p id="a07d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类用于实现列表接口。尽管如此，它还是很少被使用，因为它是一个总是被同步访问的列表结构，这在许多情况下会降低性能。</p><p id="3433" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以存储n个元素，因为没有大小限制。</p><p id="4b76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个实现包含许多不属于集合框架的遗留方法。</p><p id="a48d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="6126" class="mc md it nd b gy ni nj l nk nl">//Create Integer type vector<br/>Vector&lt;Integer&gt; vector=<br/> new Vector&lt;&gt;();</span><span id="eea9" class="mc md it nd b gy nm nj l nk nl">vector.add(1);</span><span id="7513" class="mc md it nd b gy nm nj l nk nl">//Using index number<br/>vector.add(2, 2);</span></pre><h2 id="3ebe" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">堆</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="4c2f" class="mc md it nd b gy ni nj l nk nl">public class Stack&lt;E&gt;<strong class="nd iu"> </strong>extends <a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/util/Vector.html" rel="noopener ugc nofollow" target="_blank">Vector</a>&lt;E&gt;</span></pre><p id="7838" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Stack类是LIFO(后进先出)的一个类，它实现了List类，并扩展了de Vector类的五个操作，允许将一个Vector视为一个堆栈。</p><p id="9454" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本操作是push(将元素推送到堆栈上)、pop(将元素弹出堆栈)、peek(查询堆栈顶部的第一个元素)、empty(检查堆栈是否为空)和search(搜索堆栈中的给定元素并返回其在堆栈中的位置)。</p><p id="ccbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="d20e" class="mc md it nd b gy ni nj l nk nl">Stack&lt;Integer&gt; stack =<br/> <strong class="nd iu">new</strong> <!-- -->Stack&lt;Integer&gt;();</span><span id="f9d3" class="mc md it nd b gy nm nj l nk nl">stack.push(1);<br/>stack.pop();//1</span></pre><h2 id="ff48" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">链接列表</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="6a25" class="mc md it nd b gy ni nj l nk nl">public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, Serializable</span></pre><p id="9ff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类几乎与<code class="fe na nb nc nd b">ArrayList</code>相同，因为它们实现了List接口。我们可以类似地添加、修改和删除项目，但是它们的构建方式不同。</p><p id="9df0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">ArrayList</code>类内部有一个常规数组。当添加一个元素时，它被放入数组中。如果数组的大小不够，就会创建一个新的更大的数组来替换旧的数组，然后删除旧的数组。<code class="fe na nb nc nd b">LinkedList</code>使用双向链表来存储元素。</p><p id="836c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种实现在操作数据时具有更好的性能，因为它使用双向链表，所以在内存中不需要移位。另一方面，<code class="fe na nb nc nd b">ArrayList</code>更适合存储和访问数据。</p><p id="e100" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两者都是非同步类。</p><p id="910e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="c8af" class="mc md it nd b gy ni nj l nk nl">LinkedList&lt;String&gt; l <br/> = new LinkedList&lt;String&gt;();</span><span id="b43f" class="mc md it nd b gy nm nj l nk nl">l.add("a");<br/>l.add("b");</span><span id="bd2c" class="mc md it nd b gy nm nj l nk nl">//Iterating LinkedList<br/>Iterator&lt;String&gt; iterator = l.iterator();<br/>while(iterator.hasNext()){<br/>  System.out.println(iterator.next());<br/>  //a, b<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="c1ba" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">地图</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="4548" class="mc md it nd b gy ni nj l nk nl">public interface Map&lt;K,V&gt;</span></pre><p id="b131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Map接口用于匹配键值和值或对象。地图支持任何对象。但是，映射不能有重复的键。</p><p id="6b2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，equals和<code class="fe na nb nc nd b">hashCode</code>方法在通用地图上没有帮助，所以您必须覆盖它们以使它们根据您的需要工作。</p><p id="868e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe na nb nc nd b">Map</code>不能被遍历，所以你需要用<code class="fe na nb nc nd b">entrySet</code>方法或者<code class="fe na nb nc nd b">keySet</code>方法把它转换成Set。</p><h2 id="7ab9" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">散列表</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="a8da" class="mc md it nd b gy ni nj l nk nl">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;                          implements Map&lt;K,V&gt;, Cloneable, Serializable</span></pre><p id="9450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">A <code class="fe na nb nc nd b">HashMap</code>是Map接口的实现之一；这个接口是一种集合，它存储将键与值相关联的数据，但是它不维护任何顺序。</p><p id="4b43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">HashMap</code>的工作原理是通过Java <code class="fe na nb nc nd b">hashCode()</code>方法为一个键分配一个位置。</p><p id="2158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="b611" class="mc md it nd b gy ni nj l nk nl">HashMap&lt;String, Integer&gt; numbers <br/>= new HashMap&lt;String, Integer&gt;();</span><span id="c1d4" class="mc md it nd b gy nm nj l nk nl">numbers.put("one", 1)<br/>numbers.put("two", 2)</span><span id="cb56" class="mc md it nd b gy nm nj l nk nl">System.out.println(numbers.get("one"));<br/>//1</span></pre><h2 id="1301" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">LinkedHashMap</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="26a5" class="mc md it nd b gy ni nj l nk nl">public class LinkedHashMap&lt;K,​V&gt; extends HashMap&lt;K,​V&gt; implements Map&lt;K,​V&gt;</span></pre><p id="9a80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">LinkedHashMap</code>实现扩展实现Map接口的<code class="fe na nb nc nd b">HashMap</code>类。它保持插入顺序。</p><p id="c1c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">LinkedHashMap</code>与<code class="fe na nb nc nd b">HashMap</code>相似，但增加了一个保持插入顺序的特征。</p><p id="1612" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="4753" class="mc md it nd b gy ni nj l nk nl">LinkedHashMap&lt;Integer, String&gt; lmap <br/>= new LinkedHashMap&lt;&gt;();</span><span id="c0f1" class="mc md it nd b gy nm nj l nk nl">lmap.put(1, null);<br/>lmap.put(2, "two");</span><span id="c5dd" class="mc md it nd b gy nm nj l nk nl">System.out.println(lmap.get(1));<br/>//null</span></pre><h2 id="f277" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">分类地图</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="174a" class="mc md it nd b gy ni nj l nk nl">public interface SortedMap&lt;K, V&gt; extends Map&lt;K, V&gt;</span></pre><p id="04c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个界面非常类似于地图界面。然而，它的不同之处在于<code class="fe na nb nc nd b">SortedMap</code>允许收集组中的元素被完全排序，使得搜索和查询中的访问更快。</p><p id="903c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些元素按其关键元素排序。</p><h2 id="f826" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">树形图</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="e8e3" class="mc md it nd b gy ni nj l nk nl">public class TreeMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements NavigableMap&lt;K, V&gt;, Cloneable, Serializable;</span><span id="9ab1" class="mc md it nd b gy nm nj l nk nl">public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt;;</span></pre><p id="bbb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">TreeMap</code>基于一个允许有序映射的树形实现。它保持升序。</p><p id="463d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">TreeMap</code>在Java中不允许空键(像Map)。但是，多个空值可以与不同的键相关联。</p><p id="7c71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="0f5b" class="mc md it nd b gy ni nj l nk nl">Example:</span><span id="01b1" class="mc md it nd b gy nm nj l nk nl">SortedMap&lt;Integer, String&gt; tm<br/>            = new TreeMap&lt;Integer, String&gt;();</span><span id="9e73" class="mc md it nd b gy nm nj l nk nl">tm.put(new Integer(2), "a");<br/>tm.put(new Integer(3), "b");<br/>tm.put(new Integer(5), "c");<br/>tm.put(new Integer(4), "d");<br/>tm.put(new Integer(1), "e");</span><span id="69a7" class="mc md it nd b gy nm nj l nk nl">Set s = tm.entrySet();<br/>Iterator i = s.iterator();</span><span id="92c9" class="mc md it nd b gy nm nj l nk nl">while (i.hasNext()) {<br/>        Map.Entry m = (Map.Entry)i.next();  <br/>        System.out.println((String)m.getValue());<br/>}</span><span id="c7d4" class="mc md it nd b gy nm nj l nk nl">//e<br/>//a<br/>//b<br/>//d<br/>//c</span></pre><h2 id="074b" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">并发哈希表</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="e2b7" class="mc md it nd b gy ni nj l nk nl">public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ConcurrentMap&lt;K, V&gt;, Serializable</span></pre><p id="1d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">ConcurrenthashMap</code>与<code class="fe na nb nc nd b">HashMap</code>相似，但不同之处在于，如果被多个线程使用，它是可靠的。因此，它是线程安全的，也就是说，多个线程可以对一个对象进行操作，而没有任何复杂性。</p><p id="4061" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe na nb nc nd b">ConcurrentHashMap</code>中插入空对象作为键或值是不可能的。</p><p id="ad9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="af46" class="mc md it nd b gy ni nj l nk nl">ConcurrentHashMap&lt;String, Integer&gt; days = <br/>new ConcurrentHashMap&lt;String, Integer&gt;();</span><span id="f929" class="mc md it nd b gy nm nj l nk nl">days.put("monday", Integer.valueOf(1));<br/>days.put("saturday", Integer.valueOf(2));</span><span id="6dce" class="mc md it nd b gy nm nj l nk nl">System.out.println(days.get("monday"));<br/>//1</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="8991" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">一组</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="f209" class="mc md it nd b gy ni nj l nk nl">public interface Set&lt;E&gt; extends Collection&lt;E&gt;</span></pre><p id="0a2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">Set</code>接口定义了一个不能包含重复元素的<code class="fe na nb nc nd b">Collection</code>。</p><p id="ccbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与列表相比，集合中的元素没有保证的内部顺序。然而，列表中的元素有内部顺序，我们可以使用这个顺序迭代它们。</p><h2 id="9c39" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">哈希特</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="e682" class="mc md it nd b gy ni nj l nk nl">public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, Serializable</span></pre><p id="0b4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类实现了Set接口，并通过哈希结构定义了Set(不重复元素的组)的概念。</p><p id="c54c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不能保证我们在<code class="fe na nb nc nd b">HashSet</code>中插入的对象会以相同的顺序插入。这是因为对象是根据它们的哈希代码插入的。</p><p id="3857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe na nb nc nd b">HashSet</code>不允许重复的对象，但是允许空元素。</p><p id="a03f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="93ac" class="mc md it nd b gy ni nj l nk nl">HashSet&lt;String&gt; hset =<strong class="nd iu">new</strong> HashSet();<br/>hset.add("b");    <br/>hset.add("a");</span><span id="da0a" class="mc md it nd b gy nm nj l nk nl">//This will not add new element as "a" already exists<br/>hset.add("a");<br/>hset.add("c");</span><span id="aa38" class="mc md it nd b gy nm nj l nk nl">Iterator&lt;String&gt; i=hset.iterator();  <br/>while(i.hasNext()) {  <br/>  System.out.println(i.next());  <br/>}<br/>//a<br/>//c<br/>//b</span></pre><h2 id="e5e6" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">LinkedHashSet</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="7249" class="mc md it nd b gy ni nj l nk nl">public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, Serializable</span></pre><p id="f352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类扩展了<code class="fe na nb nc nd b">HashSet</code>类，并通过在等式中添加一个双向链表来定义集合概念，以确保元素总是以相同的方式被遍历。</p><p id="5393" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以<code class="fe na nb nc nd b">LinkedHashSet</code>是<code class="fe na nb nc nd b">HashSet</code>的排序版本。</p><p id="44df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="3f7f" class="mc md it nd b gy ni nj l nk nl">LinkedHashSet&lt;String&gt; linkedset<br/>            = new LinkedHashSet&lt;String&gt;();</span><span id="93d0" class="mc md it nd b gy nm nj l nk nl">linkedset.add("A");<br/>linkedset.add("B");<br/>linkedset.add("C");</span><span id="705c" class="mc md it nd b gy nm nj l nk nl">System.out.println(linkedset);<br/>[A, B, C]</span></pre><h2 id="8935" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">分类集合</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="82d2" class="mc md it nd b gy ni nj l nk nl">public interface SortedSet&lt;E&gt; extends Set&lt;E&gt;</span></pre><p id="920c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">SortedSet</code>接口扩展了<code class="fe na nb nc nd b">Set</code>接口，并声明了按升序排序的集合的行为。</p><h2 id="d1b0" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">树集</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="3c93" class="mc md it nd b gy ni nj l nk nl">public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, Serializable</span></pre><p id="6d06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类使用一个树形结构，允许元素按照自然顺序或者由一个<code class="fe na nb nc nd b">Comparator</code>定义的顺序进行排序。此外，该类有助于比较元素，如大于或小于。</p><p id="749b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="fe50" class="mc md it nd b gy ni nj l nk nl">SortedSet&lt;String&gt; ts<br/>    = new TreeSet&lt;String&gt;();</span><span id="9c92" class="mc md it nd b gy nm nj l nk nl">ts.add("A");<br/>ts.add("C");<br/>ts.add("B");</span><span id="e477" class="mc md it nd b gy nm nj l nk nl">Iterator&lt;String&gt; i = ts.iterator();<br/>while (i.hasNext()){<br/>  System.out.println(i.next());<br/>}</span><span id="6a11" class="mc md it nd b gy nm nj l nk nl">//A<br/>//B<br/>//C</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f0bb" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">长队</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="3a80" class="mc md it nd b gy ni nj l nk nl">public interface Queue&lt;E&gt; extends Collection&lt;E&gt;</span></pre><p id="7f09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">Queue</code>接口按照FIFO(先进先出)顺序存储和处理项目。</p><p id="de96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个有序的对象列表，其用途仅限于按照FIFO(先入先出)原则在列表末尾插入元素和从<code class="fe na nb nc nd b">List</code>开头删除元素。</p><h2 id="0d2c" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">优先级队列</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="fe2b" class="mc md it nd b gy ni nj l nk nl">public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements Serializable</span></pre><p id="28c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该类根据自然顺序对元素进行排序，如通过<code class="fe na nb nc nd b">Comparable</code>方法或通过定义<code class="fe na nb nc nd b">Comparator</code>对象所指定的。这个类允许按顺序插入和从前面删除。插入是根据优先级完成的，因此优先级最高的元素放在最前面。</p><p id="8b4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最常见的操作是:</p><ul class=""><li id="474d" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">提供:根据优先权插入一个位置。</li><li id="1c9c" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">投票:用于拆包。</li><li id="5742" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">偷看:在队列中得到第一个。</li><li id="e78e" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">清除:删除队列中的所有元素。</li><li id="174e" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">size:获取队列中元素的数量。</li></ul><p id="0da8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="0b72" class="mc md it nd b gy ni nj l nk nl">PriorityQueue&lt;Integer&gt; pQueue <br/>  =new PriorityQueue&lt;Integer&gt;();</span><span id="6988" class="mc md it nd b gy nm nj l nk nl">pQueue.add(1);<br/>pQueue.add(2);<br/>pQueue.add(3);</span><span id="1e9f" class="mc md it nd b gy nm nj l nk nl">//Printing the top element of PriorityQueue<br/>System.out.println(pQueue.peek());</span><span id="e647" class="mc md it nd b gy nm nj l nk nl">//1</span><span id="1a1a" class="mc md it nd b gy nm nj l nk nl">//Printing the top element and removing it.<br/>System.out.println(pQueue.poll());<br/>//1</span><span id="f53c" class="mc md it nd b gy nm nj l nk nl">//Printing the top element again<br/>System.out.println(pQueue.peek());<br/>//2</span></pre><h2 id="b3ed" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">并发链接队列</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="7ec1" class="mc md it nd b gy ni nj l nk nl">public class ConcurrentLinkedQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements Queue&lt;E&gt;, Serializable</span></pre><p id="8c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类实现了队列接口和排序元素FIFO(先进先出)。</p><p id="abcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当许多线程共享对一个公共集合的访问时，<code class="fe na nb nc nd b">ConcurrentLinkedQueue</code>是合适的，因为当队列为空并返回null <em class="ob">时，它不会阻塞访问线程。</em></p><p id="9214" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该类不允许空元素。</p><h2 id="f83d" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">阻塞队列</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="e136" class="mc md it nd b gy ni nj l nk nl">public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt;</span></pre><p id="81fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个接口扩展了<code class="fe na nb nc nd b">Queue</code>接口。该接口旨在允许任何操作等待，直到它可以成功执行。</p><p id="42af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们想从空队列中删除一个项目，这种类型的队列允许删除操作等待，直到队列包含要删除的项目。</p><h2 id="8051" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><strong class="ak"> ArrayBlockingQueue </strong></h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="c4a7" class="mc md it nd b gy ni nj l nk nl">public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, Serializable</span></pre><p id="09be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">ArrayBlockingQueue</code>类实现了<code class="fe na nb nc nd b">BlockingQueue</code>接口。</p><p id="bf69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个阻塞队列是一个固定大小的队列。因此，试图将一个项目放入满队列将会阻止操作。类似地，从空队列中获取元素的尝试也会被阻止。</p><h2 id="2484" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">LinkedBlockingQueue</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="c2dd" class="mc md it nd b gy ni nj l nk nl">public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, Serializable</span></pre><p id="a04e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类也实现了<code class="fe na nb nc nd b">BlockingQueue</code>接口。</p><p id="715a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">LinkedBlockingQueue</code>将元素保持在一个链接的结构中。<code class="fe na nb nc nd b">LinkedBlockingQueue</code>按照FIFO(先入先出)顺序存储元素。</p><p id="d854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">LinkedBlockingQueue</code>是阻塞队列。因此，当队列为空时，它会阻塞访问线程。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="534f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，考虑通过我的<a class="ae ky" href="https://kesk.medium.com/membership" rel="noopener">个人资料</a>订阅Medium。谢谢大家！</p><h1 id="a283" class="oc md it bd me od oe of mh og oh oi mk jz oj ka mn kc ok kd mq kf ol kg mt om bi translated">参考</h1><p id="ffc6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://docs.oracle.com/en/" rel="noopener ugc nofollow" target="_blank">https://docs.oracle.com/en/</a></p></div></div>    
</body>
</html>