<html>
<head>
<title>All About Debugging: The Techniques</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于调试的一切:技术</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/all-about-debugging-the-techniques-920b06d61a9e?source=collection_archive---------8-----------------------#2020-07-27">https://betterprogramming.pub/all-about-debugging-the-techniques-920b06d61a9e?source=collection_archive---------8-----------------------#2020-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4dfb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">调试器工作的不同方式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e53368f1661181f8dd4a70349cc09d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XsSH7c0tqqtaP8uacrQJvg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片(使用<a class="ae ky" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>制作)</p></figure><p id="617c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于任何软件项目来说，调试都被认为是一项必不可少但要求很高的任务。开发人员必须进入一个连续的测试、调试和部署周期，以确保他们的产品是最新的，并能在所有目标平台上正常运行。</p><p id="89fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，这个过程是这样进行的:一旦开发人员最终确定了产品的程序代码库，这个代码库就被发送给测试人员。测试人员根据明确定义的输入测试运行代码库，以检查程序是否给出了预期的输出。在测试过程中，测试人员观察程序的输入和输出之间的关系。如果其中一个测试用例产生了错误的结果，测试会将结果报告给最初的开发人员。</p><p id="d91e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">程序故障意味着代码库包含一个错误，但这并不能给我们任何关于错误位置的进一步信息。换句话说，测试揭示了错误的存在<strong class="lb iu"> </strong>和影响——而不是错误的<em class="lv">原因</em>。然后，开发人员必须经历一个调试过程，以确定原因并修复导致它们的错误。</p><p id="fd69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然没有固定的过程来修复所有的错误，但是有几种技术可以减少您的调试工作。这个过程的很大一部分(如果不是全部的话)花费在寻找bug的位置上。</p><p id="bd8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论三种最常见和最常用的技术:</p><ul class=""><li id="c9be" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">基于跟踪的调试</li><li id="4b80" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">基于频谱的调试</li><li id="af1d" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">增量调试</li></ul><p id="e611" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不同的技术更适合不同的情况。没有精确的最佳方法。这完全取决于您正在测试的代码库的类型和您的偏好。然而，它适合于拥有所有这些方法的知识和经验的开发人员。有时，这些方法中的一种或多种的组合将引导您找到bug的位置。</p><p id="bb2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我们开始调试吧。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="7d54" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">基于跟踪的调试</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/73efc4337bd417460756579696ced83b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iTfZM7Msd5Vi3FCSD8DWpw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片(使用<a class="ae ky" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>制作)</p></figure><p id="9cab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于跟踪的调试是传统的，也是当今大多数调试工具中最常用的调试技术。基于跟踪的调试基于断点的概念。</p><p id="8cd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">断点是添加到程序中的暂停或停止点，用于检查程序执行到该点的状态。在纠正了当前的bug之后，开发人员通常会设置下一个断点，并重复相同的过程，直到所有的bug都被纠正。</p><p id="8632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于跟踪的调试有四个子技术</p><ol class=""><li id="7b1f" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu nj mc md me bi translated">跟踪调试(TD)</li><li id="09d2" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nj mc md me bi translated">全知调试</li><li id="ba6a" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nj mc md me bi translated">算法调试</li><li id="602e" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nj mc md me bi translated">混合调试(高清)</li></ol><p id="e8ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些子技术都基于同一个概念:程序切片。</p><h2 id="aa24" class="nk ms it bd mt nl nm dn mx nn no dp nb li np nq nd lm nr ns nf lq nt nu nh nv bi translated">限幅</h2><p id="1e0f" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">程序切片是计算机科学中使用的一种技术，通过专注于程序中较小的、选定的部分来简化大程序。切片过程删除了程序中对被测试的方面或程序的整体输出没有影响或影响很小的部分。1981年，PARC施乐公司的计算机科学家兼首席技术官马克·魏泽将程序切片定义为:</p><blockquote class="ob"><p id="242b" class="oc od it bd oe of og oh oi oj ok lu dk translated">"人们在调试程序时所做的精神抽象."</p></blockquote><p id="6a16" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">程序切片在计算机科学中有许多应用:</p><ol class=""><li id="bf2c" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu nj mc md me bi translated">调试。</li><li id="0dbf" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nj mc md me bi translated">对程序进行逆向工程。</li><li id="525c" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nj mc md me bi translated">测量程序的覆盖范围、重叠或聚类。</li><li id="506b" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nj mc md me bi translated">更深入地理解程序的内部运作。</li></ol><p id="6df8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对程序进行切片有几种可能的方法，比如静态切片、动态切片、条件切片和无定形切片。</p><ul class=""><li id="9852" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">静态切片:<strong class="lb iu"> <em class="lv"> </em> </strong>静态切片是对程序变量的子集构造的，对程序的输入没有任何假设。在选择一个切片的变量集后，我们可以构造两种类型的切片之一:向后切片或向前<strong class="lb iu">切片。后向<strong class="lb iu"> </strong>切片包含可能影响切片变量的程序部分，而前向<strong class="lb iu"> </strong>切片包含受切片变量<em class="lv"> </em>影响的那些部分。</strong></li><li id="bf55" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">动态切片:除了程序产生错误的输入值序列之外，动态切片是基于变量集和我们想要检查的代码点形成的。这个信息被称为动态切片标准。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ad405871b983dc42050612bf0171996d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ZsTkTfrbHEHe5E8iwLoEg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片(使用<a class="ae ky" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>拍摄)</p></figure><ul class=""><li id="364c" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">条件切片:在静态切片中，我们不提供任何关于输入的内容。在动态切片中，我们基于特定的<em class="lv"> </em>输入来构建它。条件切片位于中间。在条件切片中，我们可以向切片工具提供关于输入的信息<em class="lv"> </em>，而不需要<strong class="lb iu"> </strong>对精确值如此具体。</li><li id="39fb" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">无定形切片:到目前为止讨论的所有切片都表示语法保留。这些方法是通过删除不影响相关变量集的语句来构建的。然而，无定形切片是使用任何程序转换来构造的，这简化了程序，同时保留了整个程序的功能。</li></ul><p id="e9d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这四种类型中，动态切片是调试中最常用的技术。这是因为当我们调试时，我们有一个产生错误的特定测试用例，所以我们可以使用这个测试用例作为输入来构造我们的切片。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="c71c" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">跟踪调试</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/b121eea061f8f5c5c9cbeeb788b36cb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VrldOaP2AQAv1IGySzuo9Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片(使用<a class="ae ky" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>制作)</p></figure><p id="b011" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在跟踪调试(TD)中，调试器可以设置断点，当程序执行过程中到达断点时，程序将被挂起。然后，程序员可以通过逐行运行来检查程序状态。调试器只控制解释器，因此TD的可伸缩性与解释器相同。在查找bug位置的过程中，如果在断点之前发现了bug，那么调试过程需要重新启动来捕捉它。</p><h2 id="3772" class="nk ms it bd mt nl nm dn mx nn no dp nb li np nq nd lm nr ns nf lq nt nu nh nv bi translated">全知调试</h2><p id="36a9" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">在全知调试(OD)中，也称为及时返回调试，调试器可以向前和向后跟踪程序的计算。在这种类型的调试中，执行跟踪是巨大的，存储它们是一项具有挑战性的任务，因此OD的可伸缩性相当棘手。</p><h2 id="aff2" class="nk ms it bd mt nl nm dn mx nn no dp nb li np nq nd lm nr ns nf lq nt nu nh nv bi translated">算法调试</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/d6429bc835f85ddd7684dd42a25ac1f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_wnx1RMFKpiuqWmaqXqVbw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片(使用<a class="ae ky" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>拍摄)</p></figure><p id="a563" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">算法调试(AD)是一种半自动调试技术，它在调试器和开发人员之间产生一个对话来查找bug。因此，不需要查看代码来执行实际的调试。这也是AD抽象程度高的原因。AD分两个阶段完成:首先，构建给定程序的执行树。然后，对生成的执行树进行了详细的研究。</p><h2 id="b6cb" class="nk ms it bd mt nl nm dn mx nn no dp nb li np nq nd lm nr ns nf lq nt nu nh nv bi translated">混合调试</h2><p id="1486" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">混合调试(HD)是一种结合了跟踪调试、全知调试和算法调试的调试技术。首先，它使用跟踪调试来找出程序中发生错误的部分。然后，它只对程序的这一部分使用算法调试，并生成它的执行树。之后，它将全知调试应用到算法调试识别出一个bug的单个方法中。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="18b9" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">基于频谱的调试</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/bd75c71abf728b5351595f514f8886df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ni15TdTqTlEj0atzEulL5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片(使用<a class="ae ky" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>制作)</p></figure><p id="655d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在基于频谱的调试中，也称为基于频谱的故障定位(SFL)，调试过程是通过监控特定执行树中包含的语句来完成的。这是通过使用程序谱来识别程序运行期间的活动部分来实现的。程序谱<em class="lv"> </em>是运行时信息<em class="lv"> </em>的集合，给出了程序动态行为的视图。它包括一些对应于程序不同部分的标志。存在不同类型的程序谱，例如<code class="fe ot ou ov ow b">block hit/miss</code>和<code class="fe ot ou ov ow b">function hit/miss</code>。这些谱用于精确定位为特定或抽象输入运行的代码的确切部分。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="0d35" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">增量调试</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/be022cbad7f5ed10034bd1ccef24dc18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1DnHhvY77HIhcYAper-cWw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片(使用<a class="ae ky" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>制作)</p></figure><p id="7136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">增量调试(DD)的过程是最小化自动化测试用例。它获取可能导致错误的测试用例，并准备一份错误报告。从那个错误报告中，<em class="lv"> </em>根据产生错误的高概率选择最小的测试用例。最少的测试用例将重新产生相同的错误，从而帮助开发人员定位错误背后的bug。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="eb26" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="2704" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">有许多其他策略可以用来帮助开发人员定位代码中存在的bug。作为一名开发人员，我总是提醒自己一些事情:</p><ul class=""><li id="d7b3" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">bug可能不在你要找的地方。<em class="lv"> </em>有时候当一个开发人员寻找一个bug时，他们会花很长时间检查代码的一个特定部分，只是为了发现这个bug在别的地方。</li><li id="7e5f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">换个角度看问题，视角就不一样了。通过指出没有bug的代码部分，我们可以揭示bug到底在哪里。</li><li id="e73c" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">检查输入数据和测试细节。<em class="lv"> </em>有时候，测试用例可能会被打破。所以，从头到尾看一遍，确保每件事都准确无误，总是一个好主意。</li></ul><p id="889d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上都是用来定位bug错误的技术，但是接下来呢？</p><p id="3f4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦发现了错误，就必须纠正错误。在某些情况下，这可能是微不足道的。在其他时候，它会很简单。开发人员必须彻底考虑特定的修复将如何影响代码的其余部分。他们需要确保修复不会导致代码的其他部分中断。毫无疑问，代表代码中概念错误的bug是最难修复的。这就是为什么开发人员不仅要重新考虑修复，还要重新考虑程序的逻辑。</p><p id="0bfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是讨论调试和调试器的系列文章中的第二篇。第一条是:</p><ul class=""><li id="2545" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">关于调试的一切:简介。它概述了调试，为什么它是软件开发人员的基本工具/技能，以及调试和测试之间的区别。</li></ul><p id="ebe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即将发布的文章包括:</p><ul class=""><li id="1eb3" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">所有关于调试:特殊系统。我将讨论调试特殊系统，如大规模调试、并行系统调试等等。</li><li id="c699" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">关于调试的一切:高级方法。<strong class="lb iu"> </strong>我将讨论关于调试器、可视化调试器以及最新调试研究的未解问题。</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="f40a" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">参考</h1><ol class=""><li id="378d" class="lw lx it lb b lc nw lf nx li ox lm oy lq oz lu nj mc md me bi translated">B.Korel，J. Rilling，<em class="lv">动态切片在程序调试中的应用</em>。</li><li id="8b47" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nj mc md me bi translated">G.Pothier，E. Tanter，J. Piquer，<em class="lv">可扩展全知调试</em>。</li><li id="b72d" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nj mc md me bi translated">页（page的缩写）Fritzson，<em class="lv">广义算法调试，以及测试</em>。</li><li id="7229" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nj mc md me bi translated">J.Gonzlez，D. Insa，J. Silva，<em class="lv">一种新的eclipse混合调试架构</em>。</li><li id="86e2" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nj mc md me bi translated">G.Mariga，K. Mwiti，<em class="lv">自动调试方法:文献综述</em>。</li></ol></div></div>    
</body>
</html>