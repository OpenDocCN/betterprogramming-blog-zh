# 掌握 Python 闭包需要知道的 6 件事

> 原文：<https://betterprogramming.pub/6-things-to-know-to-master-python-closures-1586ca5165c6>

## 闭包可能很棘手

![](img/b26babafe46020b6c677be735f94ece9.png)

照片由[蒂姆·福斯特](https://unsplash.com/@timberfoster?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

掌握一门编程语言需要相当长的时间。你可能需要几个月的时间来理解基本的数据结构和控制流，并使用函数执行某些操作。这些基础知识大部分都非常简单，可以通过简单的代码示例来理解。以下示例向您展示了我们如何理解 Python 中函数调用的基本元素。

功能基础

在上面的代码中，我们首先定义了一个名为`say_hello`的函数，它接受一个名为`name`的参数。在函数体中，我们从`name`参数创建了问候消息，并将其作为函数输出返回。要调用这个函数，我们只需使用带括号的函数名来括起所需的参数。如您所见，问候消息按预期打印出来了。一切都是非常基本的，并按照它应该的那样工作。

上面的代码只是一个例子，展示了一些简单的编程概念。但是，其他一些概念可能需要更长的时间才能完全消化。在 Python 中，与函数创建相关的一个例子是闭包。据我所知，这是很多初学者都知道的东西，但还没有到了解透彻的程度。在这篇文章中，我将解释 Python 闭包，我希望我的解释能帮助你理解它。

# 1.封闭的建筑构件

一般来说，闭包是在编程语言中具有一级函数的词汇范围名称绑定的函数( [Wikipedia](https://en.wikipedia.org/wiki/Closure_(computer_programming)) 参考)。我觉得这不是最容易理解的定义。我们将逐步展开讨论，并使用更明智的例子来阐述 Python 中的闭包。让我们首先定义一个简单的闭包，这将作为我们后续讨论的基础。

闭包的基本形式

在上面的代码中，`say_hi`变量是一个闭包。为了使它成为一个闭包，应该注意三个关键的构建组件。

*   闭包是一个函数，或者更严格地说，**一个内部函数**，它被定义在另一个函数(称为外部函数)的范围内。在这种情况下，`greeting_creator`是外部函数，而内部函数是`greet`。
*   内部函数是**外部函数**的返回值。在这种情况下，`greeting_creator`返回`greet`函数作为输出。不要将这与其他一些嵌套函数混淆，这些嵌套函数可能返回内部函数的输出值(例如，返回`greet`，而不是返回调用`greet(“John”)`生成的字符串)。
*   内部函数**绑定了在其自身作用域**之外定义的变量。在这种情况下，除了内部函数自己创建的`name`变量，它还使用了`greeting_word`变量。重要的是，`greeting_word`变量在外层函数的范围内(您会发现它被称为封闭范围)。

要知道某个对象是不是闭包，可以简单参考上面的标准。如果它们都被满足，那么这个特定的对象就是一个闭包。不过，如果这三点还是让你困惑的话也没关系。我们将在接下来的章节中展开它们。先说最混乱的一个，第三个——**闭包的变量绑定**。

# 2.变量和范围

## 局部和内置变量和范围

当我们使用函数时，我们知道函数可以使用在调用过程中发送的参数。例如，在`say_hello`函数中，我们使用了`name`变量。用 Python 的行话来说，我们把这个变量称为**局部变量**，因为它在函数本身的作用域内(即局部作用域)，我们不能在函数之外访问`name`变量。此外，`say_hello`函数使用了`print`函数，它是内置 Python 库的一部分。在这种情况下，我们将`print`函数称为**内置变量**，因为它在内置范围内。

顺便提一下，你可能也听说过全局变量和全局范围。这些变量是在模块中定义的。在大多数情况下，您可以考虑在 Python 文件的顶层定义变量。文件中定义的函数和类可以访问它们。

## 非局部变量和封闭范围

我们现在已经了解了局部和内置变量和范围。我们可能想知道代码示例中的`greeting_word`变量。显然，它不是一个内置或全局变量。这意味着它是一个局部变量吗？

答案是肯定和否定的。对于外部函数`greeting_creator`，它是一个局部变量，因为它在`greeting_creator`函数的局部范围内。然而，对于内部函数`greet`，变量`greeting_word`被称为**非局部变量**或自由变量。与非局部变量密切相关的是**封闭范围**的概念，它从内部函数的角度引用外部函数的范围。任何在外部函数局部范围内的变量都被称为内部函数的非局部变量。

# 3.非局部变量绑定

如上所述，内部函数`greet`使用了非局部变量`greeting_word`。我们说的*绑定*这个词是什么意思？它不仅仅意味着使用变量。它实际上意味着内部函数“拥有”或“捕获”变量，就像绑定到内部函数的变量一样。为了找出哪些变量被绑定到闭包，我们可以运行一些检查，如代码片段所示。

自由变量的检验

如上所示，闭包绑定了一个自由变量`greeting_word`，它的值是`Hi`，这正是我们在创建闭包时使用的问候词。为了进一步了解非局部变量绑定的有趣方面，考虑下面的代码。

闭包之间的不同绑定

我们刚刚创建了另一个具有不同问候语的闭包。捕获变量的名称仍然不变(即`greeting_word`)。但是，捕获的值是`Hey`，这反映了每个闭包都有自己的非局部变量绑定的特性。

# 4.非局部关键字和 LEGB 规则

我们已经看到闭包是如何绑定非局部变量的。在所示的例子中，闭包只使用了非局部变量。如果闭包需要修改非局部变量的值怎么办？我们能简单地做它吗？我们试试看有没有可能。

unboundlocalrerror

如上图，我们做不到，遇到了`UnboundLocalError`。对于新的 Python 学习者来说，这个异常可能是最令人困惑的异常之一。如回溯所示，有问题的代码行是`greeting_word = “Non-” + greeting_word`，错误消息告诉我们在赋值前引用了局部变量`greeting_word`。

之前，我们已经讨论过`greeting_word`是一个非局部变量。但是在这个例子中，根据错误信息，它怎么会变成局部变量呢？为了更好地理解这个变化，我们需要理解 Python 中的变量查找规则，也就是俗称的 **LEGB** 。这个首字母缩写代表**局部、封闭、全局和内置**，我们已经在上面简要讨论了所有这些概念。具体来说，LEGB 规则决定了如何在链中查找变量。如果可以在局部范围内找到一个变量(即函数本身)，Python 会直接使用它。如果可以在封闭范围内找到，则停止进一步查找，依此类推。

当 Python 解释代码行`greeting_word = “Non-” + greeting_word`时，它实际上在局部范围内创建了一个名为`greeting_word`的变量。在这个赋值语句的左边，Python 将理解这个新的局部变量将被绑定到一个特定的值(这个 *bound* 意味着赋值，语义上不同于非局部变量绑定)，所以它继续解释。在右边，它遇到了`greeting_word`，Python 会查找这个变量，用它的实际字符串值替换它。Python 在局部范围内找到了，但是还没有绑定任何值！于是，`UnboundLocalError`就提出来了。

实际上，我们可以通过指导 Python 解释器如何查找变量来解决这个问题。具体来说，我们可以利用**非本地**关键字。让我们看看下面的修复。*理论上，我可以使用不同的变量名来创建修改后的问候词，而不修改原始变量，但我只是想向您展示我们如何使用非本地关键字来学习。*

非本地关键字的使用

如上所示，我们简单地指出`greeting_word`是一个非局部变量，这样 Python 就会理解这个变量应该在封闭范围而不是局部范围中查找。如你所见，它停止抱怨未绑定错误，问题解决了！

# 5.内部函数和作为对象的函数

到目前为止，您可能已经对闭包的非局部变量绑定有了很好的理解。如果我们参考这三个标准，我们基本上已经涵盖了第三个标准，如前所述，它被认为是最难理解的标准。说完这些，让我们回顾一下前两个，它们要简单得多。

## 内部功能

函数可以有嵌套结构。在 Python 中，我们简单地通过使用不同的缩进层次来安排结构，这非常类似于在许多其他编程语言中使用花括号。当我们在另一个函数中定义一个函数时，我们将内部函数称为内部函数，将外部函数称为外部函数。有些人将内部函数称为嵌套函数。我们看到的例子都是简单的两层结构。如果我们愿意，我们可以有三层甚至更多层——内部函数定义在内部函数中。

## 作为对象的功能

另一个标准是外部函数返回内部函数作为返回值。有可能是因为 Python 把一切都当成对象，也就是说函数在 Python 里也是对象。这也是为什么有人说函数是 Python 中的一等公民，因为函数是作为其他对象工作的。因此，函数可以是其他函数的返回值。与此相关，那些可以将函数作为输入和/或返回其他函数作为输出的函数被称为高阶函数。

# 6.闭包的实际例子:装饰者

到目前为止，我们已经关注了闭包的理论讨论，比如它们是什么以及我们如何构建它们。但是你可能想知道我们用它们做什么。为了理解它们的实际用法，让我们看看利用闭包技术的一个重要的 Python 特性——decorator。

简单地说，Python decorators 修改另一个函数的行为，而不影响该函数的原始功能。先看个例子再解释。

装修工

在上面的代码中，我们定义了一个名为`echo`的装饰函数，它简单地调用传递的函数两次。要使用装饰器，我们只需使用@符号前缀将装饰器函数名放在要装饰的函数上方。当我们调用被修饰的函数`say_good_morning`时，该函数确实被调用了两次，这表明修饰是成功的。

但是为什么我说装饰者在利用闭包呢？先来看一些代码。

检查装饰函数

如上所示，有趣的是，修饰后的函数变成了一个闭包，这实际上一点也不奇怪。您可能已经注意到，decorator 函数返回内部函数作为其输出。重要的是，它绑定了非局部变量`func`。因此，内部函数满足闭包的所有三个标准。这就是为什么修饰函数是一个闭包。与此相关的是，装修过程相当于下面的代码。要装饰的函数被发送给要装饰的装饰函数，从装饰函数返回的是内部函数。

显性装饰

# 结论

在这篇文章中，我们回顾了结束的三个标准。从结构的角度来看，闭包可以通过下面的讨论来理解。

闭包是在另一个函数中定义并从另一个函数返回的内部函数对象，它们绑定在封闭范围中定义的非局部变量。

我们还简要回顾了装饰器技术，它利用闭包技术来装饰函数。