<html>
<head>
<title>Automate Docker Registry Cleanup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动清理Docker注册表</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/automate-docker-registry-cleanup-3a1af0aa1535?source=collection_archive---------4-----------------------#2019-12-15">https://betterprogramming.pub/automate-docker-registry-cleanup-3a1af0aa1535?source=collection_archive---------4-----------------------#2019-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0683" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过清理旧的、未使用的Docker映像，优化Docker注册表的磁盘空间使用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ac28338adb10e55f5d4fadfed1650ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lpct0OEFobUJrFaf"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">詹妮弗·伯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="eede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">托管一个私有的Docker注册表对于使用Docker部署软件的各方来说非常有帮助。将本地集群连接到私有Docker注册中心也是一个好主意，而不是将集群直接暴露给公共Docker hub。</p><p id="a828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然安装和托管Docker注册表非常简单，可以通过一个<code class="fe lv lw lx ly b">docker</code>命令或<code class="fe lv lw lx ly b">docker-compose</code>文件轻松完成，但管理Docker集群和清理旧的或不需要的Docker映像可能是一项具有挑战性的任务。但是为什么我们首先需要清理呢？</p><p id="4320" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker Registry在文件系统上存储Docker映像(它也支持其他云存储<a class="ae ky" href="https://docs.docker.com/registry/storage-drivers/" rel="noopener ugc nofollow" target="_blank">选项</a>)。因此，需要在Docker注册主机上附加足够的存储空间，以便能够存储Docker映像，并确保始终有足够的存储空间来存储新的Docker映像。否则，一旦主机上没有足够的空间，Docker注册表将不会接受Docker映像。</p><p id="4a3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题的一个解决方案是在注册服务器上不断添加存储资源。然而，在大多数情况下，这是非常昂贵的，尤其是当Docker注册中心用于开发过程时。在这种情况下，Docker映像是根据源代码为每个pull请求构建的，根据项目的大小，我们可能每天会构建数百个Docker映像。</p><p id="8ec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，大多数Docker图像属于特性分支，可以在测试特性后从注册表中清除。事实上，我们可以说，除了带有特殊标签(如<code class="fe lv lw lx ly b">develop</code>、<code class="fe lv lw lx ly b">master</code>、<code class="fe lv lw lx ly b">latest</code>和版本标签)的Docker图像之外，大多数Docker图像都可以被删除。</p><p id="9a6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将解释如何建立一个bash脚本来自动清理docker注册表。但是首先，让我们用下面的Docker-compose文件部署我们的Docker注册中心。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="acc8" class="md me it ly b gy mf mg l mh mi">$&gt; git clone <a class="ae ky" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:wshihadeh/docker-registry.git<br/>$&gt; cd docker-registry<br/>$&gt; docker-compose up -d </span></pre><p id="21f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述命令将在本地启动Docker注册表容器。下一步是实现这个Docker注册表的清理脚本。</p><p id="f056" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始编写清理脚本之前，让我们花点时间了解一下docker注册表是如何在文件系统上存储Docker映像的，以及我们可以使用哪些工具来执行Docker清理。</p><p id="b3e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker注册表使用<a class="ae ky" href="https://docs.pulpproject.org/plugins/pulp_docker/user-guide/concepts.html#:~:targetText=Blobs%20are%20the%20layers%20that,for%20one%20or%20more%20platforms." rel="noopener ugc nofollow" target="_blank">多个对象</a>将Docker映像存储在文件系统中，这些对象是:</p><ul class=""><li id="4e45" class="mj mk it lb b lc ld lf lg li ml lm mm lq mn lu mo mp mq mr bi translated">斑点:共同构成docker图像的实际层。</li><li id="5ccd" class="mj mk it lb b lc ms lf mt li mu lm mv lq mw lu mo mp mq mr bi translated">图像清单:在docker图像中将blob对象以正确的顺序关联在一起的元数据。</li><li id="1468" class="mj mk it lb b lc ms lf mt li mu lm mv lq mw lu mo mp mq mr bi translated">清单列表:一个或多个平台的映像清单列表。这个对象可以用标签来标记。</li><li id="3661" class="mj mk it lb b lc ms lf mt li mu lm mv lq mw lu mo mp mq mr bi translated">Tag:这个对象引用一个清单(图像或列表),方法是对引用N个Blobs的图像清单进行同样的处理。</li></ul><p id="dccc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的好消息是docker registry提供了一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.docker.com/registry/garbage-collection/" rel="noopener ugc nofollow" target="_blank">garbage-collect</a></code>命令，它将对docker registry文件系统执行清理。但是，该命令只会在blobs不再被任何清单引用时从文件系统中删除它们。因此，清理脚本不应该接触文件系统上的docker图像数据，而是应该负责删除旧的未使用的blobs的引用。为了简化这一过程，清理脚本应该执行以下操作:</p><ul class=""><li id="37a6" class="mj mk it lb b lc ld lf lg li ml lm mm lq mn lu mo mp mq mr bi translated">删除旧的Docker标签:所有超过30天的Docker标签都应该从注册表中删除(我们可以排除特殊标签)。</li><li id="3849" class="mj mk it lb b lc ms lf mt li mu lm mv lq mw lu mo mp mq mr bi translated">删除根本没有标记的docker清单:这些清单占用了磁盘空间，但是它们没有在任何托管的Docker映像中使用。</li><li id="272a" class="mj mk it lb b lc ms lf mt li mu lm mv lq mw lu mo mp mq mr bi translated">运行<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.docker.com/registry/garbage-collection/" rel="noopener ugc nofollow" target="_blank">garbage-collect</a></code>负责清理所有Docker未使用的斑点和层。</li></ul></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="589c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在清楚了清理脚本中需要实现的内容，让我们开始探索脚本中最有趣的部分。</p><p id="235f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">脚本接口对于理解脚本如何工作以及如何与之交互非常重要。清理脚本需要有以下配置项(这些配置可能因环境而异)。</p><ul class=""><li id="1eed" class="mj mk it lb b lc ld lf lg li ml lm mm lq mn lu mo mp mq mr bi translated"><code class="fe lv lw lx ly b">REGISTRY_URL</code>:这是注册表的HTTP网址。</li><li id="4a67" class="mj mk it lb b lc ms lf mt li mu lm mv lq mw lu mo mp mq mr bi translated"><code class="fe lv lw lx ly b">REGISTRY_DIR</code>:这是注册表数据文件夹路径。</li><li id="cfe7" class="mj mk it lb b lc ms lf mt li mu lm mv lq mw lu mo mp mq mr bi translated"><code class="fe lv lw lx ly b">MAX_AGE_SECONDS</code>:这个数字代表标签的最大寿命，以秒为单位。</li><li id="20d7" class="mj mk it lb b lc ms lf mt li mu lm mv lq mw lu mo mp mq mr bi translated"><code class="fe lv lw lx ly b">DOCKER_REGISTRY_NAME</code>:这是注册Docker容器名称。</li><li id="4d1f" class="mj mk it lb b lc ms lf mt li mu lm mv lq mw lu mo mp mq mr bi translated"><code class="fe lv lw lx ly b">DOCKER_REGISTRY_CONFIG</code>:注册表配置文件的路径。</li><li id="a417" class="mj mk it lb b lc ms lf mt li mu lm mv lq mw lu mo mp mq mr bi translated"><code class="fe lv lw lx ly b">DRY_RUN</code>:布尔标志，支持清理的预演执行。</li><li id="443a" class="mj mk it lb b lc ms lf mt li mu lm mv lq mw lu mo mp mq mr bi translated"><code class="fe lv lw lx ly b">EXCLUDE_TAGS</code> : Regex，定义需要从清理中排除的标签列表。</li></ul><p id="2e96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">脚本应该处理的下一步是尝试从文件系统中删除旧的Docker标记。为了能够执行这个步骤，我们需要理解标签是如何存储在文件系统中的。</p><p id="cb95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker注册表将Docker映像存储在文件系统中的以下路径下<code class="fe lv lw lx ly b">${REGISTRY_DIR}/docker/registry/v2/repositories</code>。例如，如果Docker注册中心拥有两个Docker映像<code class="fe lv lw lx ly b">nginx</code>和<code class="fe lv lw lx ly b">redis</code>，命名空间为<code class="fe lv lw lx ly b">shih</code>，那么文件夹<code class="fe lv lw lx ly b">shih</code>将存在于上述路径下，并带有两个子文件夹，名称分别为<code class="fe lv lw lx ly b">nginx</code>和<code class="fe lv lw lx ly b">redis</code>。图像的标签存储在文件系统<code class="fe lv lw lx ly b">${image_folder}/_manifests/tags/*</code>中以下路径下的图像文件夹中。下图显示了托管<code class="fe lv lw lx ly b">mysql</code> Docker映像的注册表的文件结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/9de8c2e00316b4d68fd537bbc0b9ac51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-iBx4d5WFwm__JY0pLsYvw.png"/></div></div></figure><p id="575e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了以上关于Docker标签的文件结构的信息，我们可以遵循以下建议来清理所有旧的Docker标签。</p><ul class=""><li id="a08b" class="mj mk it lb b lc ld lf lg li ml lm mm lq mn lu mo mp mq mr bi translated">循环所有图像中的所有标签。</li><li id="7003" class="mj mk it lb b lc ms lf mt li mu lm mv lq mw lu mo mp mq mr bi translated">对于包含在清理中的标签，执行以下几点。</li><li id="ffde" class="mj mk it lb b lc ms lf mt li mu lm mv lq mw lu mo mp mq mr bi translated">如果超过了<code class="fe lv lw lx ly b">$MAX_AGE_SECONDS</code>，则删除标签。</li></ul><p id="c077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe lv lw lx ly b">remove_image_tags</code>函数的伪代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="cfc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个任务是移除所有没有标签的Docker <code class="fe lv lw lx ly b">manifests</code>。命令<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.docker.com/registry/garbage-collection/" rel="noopener ugc nofollow" target="_blank">garbage-collect</a></code>不会删除<code class="fe lv lw lx ly b">blobs</code>或仍然链接在Docker <code class="fe lv lw lx ly b">manifests</code>中的图像数据。另一方面，这些<code class="fe lv lw lx ly b">manifests</code>不再被使用，因为它们没有被任何现有的docker标签引用。</p><p id="0af6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了能够找到并删除未使用的<code class="fe lv lw lx ly b">manifests</code>，深入挖掘<code class="fe lv lw lx ly b">manifests</code>和<code class="fe lv lw lx ly b">tags</code>的注册表结构非常重要。这对于了解这些对象是如何存储在文件系统中的，以及如何在不丢失或损坏Docker注册表数据的情况下执行清理是很重要的。</p><p id="b848" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker registry正在为推送到注册表的每个图像创建三个子文件夹。例如，如果我们将一个<code class="fe lv lw lx ly b">mysql</code> Docker映像放在<code class="fe lv lw lx ly b">shih</code>名称空间下，我们将在<code class="fe lv lw lx ly b">${REGISTRY_DIR}/docker/registry/v2/repositories</code>下得到下面的文件结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/3f5eb4ef38db93ac462c4823d9fd433e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gKY47bJi_3GeR9_xsLZxMA.png"/></div></div></figure><p id="1668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上图所示，Docker注册表为<code class="fe lv lw lx ly b">mysql</code> Docker映像创建了以下三个子文件夹。</p><ul class=""><li id="207b" class="mj mk it lb b lc ld lf lg li ml lm mm lq mn lu mo mp mq mr bi translated"><code class="fe lv lw lx ly b">_layers</code>:将Docker图层映射到<code class="fe lv lw lx ly b">blobs</code>。该文件夹将包含Docker图像中每一层的子文件夹，以及相应<code class="fe lv lw lx ly b">blob.</code>的地图或摘要链接</li><li id="a849" class="mj mk it lb b lc ms lf mt li mu lm mv lq mw lu mo mp mq mr bi translated"><code class="fe lv lw lx ly b">_manifests</code>:该文件夹存储Docker图像的<code class="fe lv lw lx ly b">tags</code>和<code class="fe lv lw lx ly b">revisions</code>。目录<code class="fe lv lw lx ly b">revisions</code>将包含所有Docker图像版本(甚至是没有被任何标签引用的版本，这允许我们基于这些<code class="fe lv lw lx ly b">revisions</code>提取图像)。另一方面，<code class="fe lv lw lx ly b">tags</code>目录将包含每个图像标签的子文件夹。标签只是图像<code class="fe lv lw lx ly b">revisions</code>的链接。因此，Docker注册中心正在根据<code class="fe lv lw lx ly b">tags</code>和<code class="fe lv lw lx ly b">revisions</code>提取Docker图像。例如，下面的两个命令都是有效的，并将提取Docker图像。</li></ul><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e208" class="md me it ly b gy mf mg l mh mi">docker pull myregistry:5000/shih/mysql:5.9<br/>docker pull myregistry:5000/shih/mysql@sha256:c3490dcf10ffb6530c</span></pre><ul class=""><li id="6542" class="mj mk it lb b lc ld lf lg li ml lm mm lq mn lu mo mp mq mr bi translated"><code class="fe lv lw lx ly b">_uploads</code>:在<code class="fe lv lw lx ly b">docker push</code>期间使用的临时docker _uploads目录，通常这个目录应该是空的。</li></ul><p id="4629" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过执行以下步骤，可以找到所有这些<code class="fe lv lw lx ly b">manifests</code>并将其移除。</p><ul class=""><li id="7539" class="mj mk it lb b lc ld lf lg li ml lm mm lq mn lu mo mp mq mr bi translated">找到所有没有标签的<code class="fe lv lw lx ly b">manifests</code>，但是取<code class="fe lv lw lx ly b">revisions</code>和<code class="fe lv lw lx ly b">tags</code>文件夹之间的差异。<code class="fe lv lw lx ly b">manifests</code>在<code class="fe lv lw lx ly b">revisions</code>文件夹中找到但没有对应的<code class="fe lv lw lx ly b">tags</code>被认为是没有标签的<code class="fe lv lw lx ly b">manifests</code>，可以安全删除。</li><li id="e9a5" class="mj mk it lb b lc ms lf mt li mu lm mv lq mw lu mo mp mq mr bi translated">在找到的<code class="fe lv lw lx ly b">manifests</code>上循环，并执行以下动作。</li><li id="0b1e" class="mj mk it lb b lc ms lf mt li mu lm mv lq mw lu mo mp mq mr bi translated">找到包含给定<code class="fe lv lw lx ly b">manifest</code>的所有存储库/名称空间。</li><li id="b199" class="mj mk it lb b lc ms lf mt li mu lm mv lq mw lu mo mp mq mr bi translated">从每个找到的名称空间中删除<code class="fe lv lw lx ly b">manifest</code>。</li></ul><p id="4cba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe lv lw lx ly b">delete_mainifests_without_tags</code>函数的伪代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="8bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数<code class="fe lv lw lx ly b">delete_manifest</code>可以通过向Docker注册中心发送删除API请求来实现，URL如下:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="842d" class="md me it ly b gy mf mg l mh mi">${REGISTRY_URL}/v2/${repo}/manifests/sha256:${<em class="ni">hash</em>}</span></pre><p id="d840" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者使用下面的命令直接从文件系统中删除文件(该算法需要一个额外的步骤来查找包含清单的标签)。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="2a04" class="md me it ly b gy mf mg l mh mi">REPO_DIR=${REGISTRY_DIR}/docker/registry/v2/repositories</span><span id="e284" class="md me it ly b gy nj mg l mh mi"><em class="ni">rm -r $</em>REPO_DIR<em class="ni">/${repo}/_manifests/tags/${tag}/index/sha256/${hash}<br/>rm -r $</em>REPO_DIR<em class="ni">/${repo}/_manifests/revisions/sha256/${hash}</em></span></pre><p id="a28a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在完全删除旧标签和没有标签的<code class="fe lv lw lx ly b">manifests</code>之后，脚本应该在Docker注册表容器中启动<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.docker.com/registry/garbage-collection/" rel="noopener ugc nofollow" target="_blank">garbage-collect</a></code>命令。这一步可以通过执行以下命令来完成:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="bdc0" class="md me it ly b gy mf mg l mh mi">docker exec -i $REGISTRY /bin/registry garbage-collect $CONFIG</span></pre><p id="1880" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是执行Docker注册表清理的建议方法的完整实现，该脚本从一些通用配置开始，可以修改这些配置以满足不同Docker注册表的需求。该脚本还包括执行清理所需的所有函数和工具，并且它还支持脚本的模拟执行。你也可以在Github <a class="ae ky" href="https://github.com/wshihadeh/docker-registry" rel="noopener ugc nofollow" target="_blank">上找到这个脚本。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div></div>    
</body>
</html>