<html>
<head>
<title>How to Implement a Unit Test in an iOS Legacy Codebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在iOS遗留代码库中实现单元测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-unit-test-in-ios-legacy-codebase-d11c640c52eb?source=collection_archive---------2-----------------------#2022-10-22">https://betterprogramming.pub/implement-unit-test-in-ios-legacy-codebase-d11c640c52eb?source=collection_archive---------2-----------------------#2022-10-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2a95" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">测试旧代码的简单指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/15e10dcad025cac0c1125c462c02fc05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vrerj_fjbvFZswJv"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@davidgrdm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·格兰穆金</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="15fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">拥有一个单元测试总是很重要的，它给了我们很多好处。它给你快速的反馈，并最小化你的代码在生产中的严重错误。当你想对你的代码库进行大的重构时，单元测试也可以一步一步地保护你。单元测试也可以作为文档，这对公司的新员工来说非常有用。</p><p id="1e67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是实现单元测试并不容易，尤其是对于遗留代码库。通常，遗留代码库并不关心代码质量，因为有很多因素。也许我们有一个紧迫的期限，应该尽快交付应用程序，或者我们只是不知道如何在当前时刻创建一个可扩展的代码。但这完全没问题。我们都经历过这一刻，对吧？我们必须继续前进，现在就考虑可能的解决方案。</p><p id="e6f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，出于教育目的，我创建了一个示例应用程序，演示了一个简单的iOS遗留代码库。这是一个显示神奇宝贝列表的简单应用程序。虽然这是一个简单的应用程序，但它可能是您学习如何添加单元测试和一步一步重构的良好开端。检查它，克隆存储库，并将您的分支切换到<code class="fe ls lt lu lv b">legacy</code>。</p><div class="lw lx gp gr ly lz"><a href="https://github.com/tifoaudii/PokemonApp" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">GitHub — tifoaudii/PokemonApp</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">在GitHub上创建一个帐户，为tifoaudii/PokemonApp开发做贡献。</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">github.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kp lz"/></div></div></a></div><h2 id="e62c" class="mo mp iq bd mq mr ms dn mt mu mv dp mw lf mx my mz lj na nb nc ln nd ne nf ng bi translated">我们应该从哪里开始？</h2><p id="4ea7" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">首先可以查一下<code class="fe ls lt lu lv b">PokemonLegacyListViewController.swift</code>，给几分钟熟悉一下代码。这个简单的应用程序在视图加载时从服务器获取神奇宝贝的数据。如果成功，该视图将显示神奇宝贝卡的集合。否则，它将显示错误状态。</p><p id="0544" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">PokemonAppTest</code>目录中，创建一个名为<code class="fe ls lt lu lv b">PokemonLegacyViewControllerTest</code>的新文件。在类内部，创建第一个名为<code class="fe ls lt lu lv b">test_whenSuccessFetchPokemons_shouldRenderCollectionCard</code>的测试用例函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7b27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当创建一个测试用例功能时，我们通常有三个遵循惯例的部分。它从<code class="fe ls lt lu lv b">Given</code>开始，在这一部分，我们设置被测系统并提供它所需的依赖项。然后我们有<code class="fe ls lt lu lv b">When</code>部分。这里，我们模拟被测系统的动作。最后，我们有<code class="fe ls lt lu lv b">Then</code>部分，在那里我们将在系统测试动作完成后断言条件。</p><p id="77dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当处理遗留代码库时，总是从简单的案例开始。在这种情况下，我们知道当视图加载时，我们从API服务器获取了神奇宝贝。让我们像这样编写我们的第一个测试用例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8d73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尝试点击<code class="fe ls lt lu lv b">cmd + U</code>运行测试，测试结果失败。当我们运行测试时，它是作为一个网络请求来执行的，在我们从API服务器获取数据之前，您的测试就已经完成了。为了测试异步代码，我们可以像这样给测试增加一个延迟:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7b7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">试着再运行一次测试，嘣，成功了。但是我们需要等三秒钟才能得到测试结果。如果API服务器关闭，也许我们应该等待三秒以上。所以此时此刻，我们的测试并不可靠，而且耗时太长。单元测试应该是快速和独立的，所以我们不想执行异步操作，这是测试环境中真正的网络请求。</p><p id="e02b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用的方法是用spy对象替换网络服务。一个spy对象用于记录来自被测系统的一个动作的信息，它也可以作为一个stub，在那里我们可以得到一个预定义的结果。</p><p id="3551" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们再来看看<code class="fe ls lt lu lv b">PokemonLegacyListViewController.swift</code>，里面的<code class="fe ls lt lu lv b">viewDidLoad</code>函数。我们使用<code class="fe ls lt lu lv b">PokemonLegacyService</code> singleton来执行网络请求。在这种情况下，使用singleton使我们的类具有隐式依赖。所以我们需要一些重构来支持测试环境中依赖实例的变化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="eb31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在这里创建一个新的属性，使用属性注入来注入依赖项。现在我们可以使用spy对象来更改我们的测试实现。当处理混乱的遗留代码库时，通过属性进行依赖注入是很容易的。但是如果您从头开始编写代码，实现依赖注入的最佳实践是使用初始化器注入。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="536f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在测试环境中，我们可以使用一个spy对象，而不需要执行网络请求。因此，我们还可以提供一个预定义的结果，在本例中，是我们获取神奇宝贝时的结果。我们的测试现在既可靠又快速！</p><p id="ba9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但问题是，如果<code class="fe ls lt lu lv b">PokemonLegacyService</code>是最终类，那么我们就不能创建子类。然后我们可以为这种情况创建一个特定的协议，并使我们的<code class="fe ls lt lu lv b">PokemonLegacyViewController</code>依赖于协议而不是具体的实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0a03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们的<code class="fe ls lt lu lv b">PokemonLegacyService</code>已经有了<code class="fe ls lt lu lv b">fetchPokemons</code>函数的实现，我们就不用再写什么了。只需改变<code class="fe ls lt lu lv b">PokemonLegacyListViewController</code>内部的依赖类型。在这一点上，我们已经实现了依赖倒置原则，这很好！</p><p id="28df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以更新spy对象实现了。再次运行测试，以确保我们没有打破任何东西。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5a57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太棒了。当我们从API服务器得到错误响应时，让我们编写另一个测试用例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="da36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们想要模拟API服务器给出的错误响应，所以我们需要更改spy对象中的预定义结果。为了简化我们的项目，我们可以在这里创建一个新的私有类型<code class="fe ls lt lu lv b">AnyError</code>。但是也许我们需要在现实世界中断言不同种类的错误状态。运行测试以确保一切正常。</p><h1 id="321e" class="no mp iq bd mq np nq nr mt ns nt nu mw jw nv jx mz jz nw ka nc kc nx kd nf ny bi translated">从这里去哪里</h1><p id="1e74" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">恭喜你关注了这篇文章。您已经深入了解了如何开始一小步来改进遗留代码库。虽然是一个相当简单的例子，但希望能对你有用。理解如何实现单元测试的基础知识现在非常重要。我们可以从中获得很多好处。</p><p id="7eb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您阅读这篇文章。如果您有任何建议或反馈，请告诉我。</p><p id="5087" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另文再见！</p></div></div>    
</body>
</html>