# 使用 SwiftUI 4 的多对等连接框架构建游戏

> 原文：<https://betterprogramming.pub/using-the-multipeer-connectivity-framework-with-swiftui4-b2bf97f5be79>

## 石头、纸和剪刀

![](img/285fda1b86f2e18f9066a529b9666eac.png)

马库斯·沃利斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

欢迎来到我的第一个 SwiftUI 教程！在这个项目中，我将演示如何实现一个使用 SwiftUI 4 的基本多对等连接应用程序，不需要 UIKit！

事不宜迟，我们开始吧！

# 应用程序结构

我们的应用程序的基本结构如下:

*   一个用于处理配对和与配对对等体通信的对象
*   `PairView`将向用户显示一个可用的同伴列表，并允许他们邀请他们参加游戏
*   `GameView`将显示游戏控件，告诉用户他们是赢了还是输了

该游戏将是一个基本的“石头，剪刀，布”游戏。用户将彼此配对，然后他们将看到三个选项，石头、布或剪刀。当用户选择一步棋时，它将被发送到对手的设备上，一旦定时器到时，结果就会显示出来。

有了基本的概述，让我们深入一些代码。

# 密码

我们将从创建`MultipeerSession`对象开始。首先，我们需要将`MultipeerConnectivity`导入到我们的类中，并继承`NSObject`和`ObrvableObject`。

这里我们创建了一个`serviceType`字符串，它将让其他正在扫描对等点的设备知道我们正在使用`RPS`应用程序，并且只在寻找`RPS`对等点。这个字符串可以是任何能够将我们的多点服务与其他服务区分开来的东西。然后我们创建一些实例变量来保存我们的`MCPeerID`、`MCNearbyServiceAdvertiser`、`MCNearbyServiceBrowser`和`MCSession`。这些字段需要被公开，这样我们就可以在`RPSMultipeerSession`类之外使用它们执行操作。

在我们对象的`init()`中，我们需要给上面创建的变量赋值。

在我们的应用程序中，我们将允许用户创建一个用户名，以便更容易地发现同行。这里，我们将提供的用户名作为初始化器中的一个参数，并从中创建一个`MCPeerID`。

同样在初始化器内部，我们创建:

*   `session`:用于发送和接收 RPS 移动
*   用于向附近的玩家宣传我们自己
*   `serviceBrowser`:用于查找附近有空的玩家

别忘了调用`super.init()`来调用超类的 init 方法’!

接下来，我们需要考虑如何从我们的对等点接收数据。稍后，我们将为我们的`session`对象创建一个委托，它将从我们的对等体接收一个`Data`对象，然后我们可以将它转换成更容易处理的东西。

因为我们实际上只有四个选项(石头、剪刀、布，没有)，所以我们将使用一个`enum`来使处理响应更具可读性，也更容易操作。

类似这样的东西，放在与我们的`RPSMultipeerSession`类相同的文件中，就足够了:

稍后，我们将使用我们的`Move`的一个`String`表示向我们的玩家显示一个图像。通过使用`CustomStringConvertible`，我们可以减少这样做所需的代码量。

既然我们已经创建并使用了`Move`枚举，我们应该考虑什么类型的数据需要对我们的视图可用。我们知道我们的`PairView`，将允许玩家找到他们的朋友并与他们配对，将需要访问当前可用的同伴列表。

当我们收到另一个玩家的邀请时，同样的观众需要知道这个玩家是谁。`GameView`需要知道我们何时收到对手的移动。

我们的不止一个视图可能会发现知道我们当前是否与一个玩家配对是有用的，最后，我们的`PairView`将需要有某种方式来接受或拒绝另一个玩家的邀请。

总之，在我们的`RPSMultipeerSession`中将有六个`@Published`属性。制作这些变量`@Published`使得我们的视图不仅可以看到变量的值，还可以在值改变时得到通知。

这样一来，我们需要为我们的`session`、`serviceAdvertiser`和`serviceBrowser`创建一些代理。先说最长的一个，`MCSessionDelegate`。

会话委托有方法来处理:

*   当对等体改变状态(连接、断开、连接)时
*   当我们收到来自同行的`Data`
*   当我们收到来自对等体的`InputStream`
*   当我们收到来自对等方的`Resource`时(有或没有进展)
*   当我们收到来自对等方的证书时(身份验证)

我们实际上只关心其中的两种方法:当一个对等体改变状态时，以及当我们从一个用户接收到`Data`时。尽管如此，这些方法中的每一个都需要在委托内部实现。

Swift 有一个简洁的特性，叫做`extensions`。如果您不熟悉，扩展本质上允许您向任何 Swift 类添加代码。

人们可以在`String`类上创建一个`extension`来对字符串执行任何类型的操作。s 非常强大，我强烈建议查看细节，但现在这应该是足够的介绍，让我们继续下去。

为了防止我们的`RPSMultipeerSession`变得太大而无法处理，我们将利用 Swift 的`extension`来实现这些委托。我们可以简单地做:

```
extension RPSMultipeerSession: MCSessionDelegate
```

并在那里实现委托函数，在主类之外，但仍然在同一个文件中。人们可以将这些委托放在单独的文件中，但是我个人选择将它们都放在一个文件中。

就像我之前说的，这是一个大问题。确保使用 Xcode 的自动完成功能来声明函数。

如您所见，大多数函数只是在控制台上打印一行，实际上根本不做任何事情。这是因为我们的应用程序不支持发送或接收流或资源。不过，随着教程的进行，这种情况可能会改变。

我们还没完呢！如果您按照代码进行操作，您可能已经注意到该委托实际上根本不做任何事情。我们需要实现逻辑来响应对等连接状态的变化，并从我们的对手那里接收数据。我将在第 2 部分详细讨论如何处理这些事件，所以现在，让我们继续。

接下来，我们将实现`MCNearbyServiceAdvertiserDelegate`。这个更容易理解:

服务广告商有两种方法:一种是当广告商由于某种原因无法开始广告时调用，另一种是当我们收到另一个玩家的邀请时调用。后者将在第 2 部分再次实现！

最后但同样重要的是，我们需要实现`MCNearbyServiceBrowserDelegate`。

此委托具有在以下情况下调用的方法:

*   浏览器由于某种原因没有开始浏览
*   浏览器发现附近的对等点正在广告我们的`serviceType`
*   浏览器失去了一个正在广告我们的`serviceType`的邻近对等点

现在我们已经设置了我们的代理，我们可以将它们应用到我们的`session`、`serviceAdvertiser`和`serviceBrowser`。

在调用`super.init()`之后，我们将这个添加到我们的`init()`中。这将分配代理，并开始向/为对等方做广告和浏览。

我们几乎完成了，但是我们不能忘记告诉我们的广告商和浏览器在`deinit()`内停止

现在我们已经完成了所有这些，我们的`RPSMultipeerSession.swift`文件应该是这样的:

你可以在我的 [GitHub 回购里找到代码！](https://github.com/TheNightmanCodeth/RPS)

感谢阅读。这是本教程的第二部分。