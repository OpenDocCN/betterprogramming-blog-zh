<html>
<head>
<title>Understand the MySQL Index Optimization Artifact</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解MySQL索引优化神器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-the-mysql-index-optimization-artifact-d4d7c6eb31f3?source=collection_archive---------3-----------------------#2022-06-24">https://betterprogramming.pub/understand-the-mysql-index-optimization-artifact-d4d7c6eb31f3?source=collection_archive---------3-----------------------#2022-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="233a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">MySQL索引优化教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8e5951e083440df9a441354e14313455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rVm88RA8NRTRkbWH"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@dose?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">剂量介质</a>拍摄</p></figure><p id="92fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着用户数量和数据量的增加，查询速度慢是一个不可避免的问题。一般来说，如果出现查询慢，说明接口响应慢，接口超时等问题。</p><p id="bb5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果是高并发场景，数据库连接可能会满，直接导致服务不可用。</p><p id="e53f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缓慢的查询确实会导致许多问题。如何优化慢速查询？</p><p id="7124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要的解决方案是:</p><ul class=""><li id="6588" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">监控SQL的执行，发送邮件和短信报警，快速识别查询缓慢的SQL。</li><li id="1830" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">启用数据库慢速查询日志功能。</li><li id="f33d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">简化业务逻辑。</li><li id="fbd3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">代码重构和优化。</li><li id="c5a9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">异步处理。</li><li id="8008" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">SQL优化。</li><li id="3023" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">索引优化。</li></ul><p id="e911" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天我重点讲一下索引优化，因为这是解决查询SQL慢的最有效的方法。</p><p id="128f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何检查一个SQL索引的执行状态？</p><p id="1a21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，通过在SQL前面加上<code class="fe mj mk ml mm b">explain</code>关键字，我们可以看到它的执行计划。通过执行计划，我们可以清楚的看到表和索引的执行情况，索引是否执行，索引执行的顺序，索引的类型<code class="fe mj mk ml mm b">Wait</code>。</p><p id="38fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">索引优化的步骤是:</p><ul class=""><li id="2f16" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用explain查看SQL执行计划。</li><li id="76bd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">确定哪些索引使用不当。</li><li id="3a5e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">优化SQL，SQL可能需要多次优化才能达到索引使用的最佳值。</li></ul><h1 id="3b57" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">什么是解释？</h1><p id="0382" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们来看看MySQL的官方文档是如何描述<code class="fe mj mk ml mm b">explain</code>的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/38084ef042f18ac1ff956a15d23715e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hU4zanS3lD5yeIu_mI8Irw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/explain.html" rel="noopener ugc nofollow" target="_blank">点击阅读文档</a></p></figure><h2 id="3ff7" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"/><code class="fe mj mk ml mm b"><strong class="ak">explain</strong></code><strong class="ak">:</strong>的语法</h2><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="38f9" class="nl mo it mm b gy ob oc l od oe">{EXPLAIN | DESCRIBE | DESC}<br/>    tbl_name [col_name | wild]<br/><br/>{EXPLAIN | DESCRIBE | DESC}<br/>    [explain_type]<br/>    {explainable_stmt | FORCONNECTION connection_id}<br/><br/>explain_type: {<br/>    EXTENDED<br/>  | PARTITIONS<br/>  | FORMAT = format_name<br/>}<br/><br/>format_name: {<br/>    TRADITIONAL<br/>  | JSON<br/>}<br/><br/>explainable_stmt: {<br/>    SELECTstatement<br/>  | DELETEstatement<br/>  | INSERTstatement<br/>  | REPLACEstatement<br/>  | UPDATEstatement<br/>}</span></pre><p id="3351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用一个简单的SQL来看看使用<code class="fe mj mk ml mm b">explain</code>关键字的效果:</p><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="1b9a" class="nl mo it mm b gy ob oc l od oe">explain select * from test1;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/d6c2b58cf0f28700de6975bbc013bdbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_f1q7fDAkjmACCAkEr9SaA.png"/></div></div></figure><p id="a241" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上图可以看出，执行结果中会显示12列信息。</p><p id="3337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个栏目的具体信息如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/00b8f4ce921dbae968624dd4c87a2b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SidKL7nzqAn_jUnb63uJ9A.png"/></div></div></figure><p id="594d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说白了，就是需要了解这些栏目的具体含义，才能正常判断指标的使用情况。</p><p id="8535" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，我们开始吧。</p><h1 id="d4a7" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated"><strong class="ak"/><code class="fe mj mk ml mm b"><strong class="ak">id</strong></code><strong class="ak">之列。</strong></h1><p id="314d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">该列的值是选择查询中的序列号，如1、2、3、4等。，它决定了表的执行顺序。</p><p id="cc5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SQL的执行计划中通常有三种情况:</p><ul class=""><li id="269b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">相同的id。</li><li id="6f9b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">不同的id。</li><li id="47c9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">拥有相同的id，同时拥有不同的id。</li></ul><p id="b479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，这三个案例表的执行顺序是什么呢？</p><h2 id="1fb2" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"> <em class="og"> 1。相同id </em> </strong></h2><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="5064" class="nl mo it mm b gy ob oc l od oe">explain select * from test1 t1 inner join test1 t2 on t1.id=t2.id</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/a1f202a3c76a532892b94843264364bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHiInKQbfbou5l455dW2UA.png"/></div></div></figure><p id="8d96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到执行结果中的两个数据id都是1，是一样的。</p><p id="0984" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个案例表的执行顺序是什么？</p><p id="f513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答:从上到下执行，先执行表<code class="fe mj mk ml mm b">t1</code>，再执行表<code class="fe mj mk ml mm b">t2</code>。</p><h2 id="b05e" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak">2<em class="og">2。</em>不同id</strong></h2><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="02d4" class="nl mo it mm b gy ob oc l od oe">explain select * from test1 t1 where t1.id = (select id from  test1 t2 where  t2.id=2);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/9d0ef85cd5e4e8724e42b097944aa9f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LMMbTbttklMhDcyYFJwA_w.png"/></div></div></figure><p id="c9c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到执行结果中两个数据的id不同，第一个数据是<code class="fe mj mk ml mm b">1</code>，第二个数据是<code class="fe mj mk ml mm b">2</code>。</p><p id="5015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个案例表的执行顺序是什么？</p><p id="bbb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答:将首先执行较大的序列号。这里将自下而上执行，首先执行表<code class="fe mj mk ml mm b">t2</code>，然后执行表<code class="fe mj mk ml mm b">t1</code>。</p><h2 id="0b96" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"> <em class="og"> 3。有相同的id同时又有不同的id</em>和</strong></h2><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="d5d5" class="nl mo it mm b gy ob oc l od oe">explain<br/>select t1.* from test1 t1<br/>inner join (select max(id) mid from test1 group by id) t2<br/>on t1.id=t2.mid</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/c6ee3f3e45244807602eeac0f001817e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJD8zkcRsQPdt8KL8DGPMQ.png"/></div></div></figure><p id="36fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在执行结果中看到三段数据。前两段数据具有相同的id，第三段数据与前一段数据具有不同的id。</p><p id="f95f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个案例表的执行顺序是什么？</p><p id="d2f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回答:先执行序号大的那个，自下而上执行。当序列号相同时，从上到下执行。因此，该列中表格的顺序是<code class="fe mj mk ml mm b">test1, t1</code>。</p><p id="610d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注</strong>:有一个特殊的表列表，内容是<code class="fe mj mk ml mm b">&lt;derived2&gt;</code>，代表一个派生表，后面会详细描述。</p><h2 id="363c" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"/>之列<code class="fe mj mk ml mm b"><strong class="ak">select_type</strong></code></h2><p id="ece6" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">该列表示<code class="fe mj mk ml mm b">select</code>的类型。具体包括以下11种类型:</p><ul class=""><li id="7e31" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">SIMPLE</code>:简单查询。</li><li id="4ac0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">PRIMARY</code>:最外层的查询。</li><li id="d2b4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">UNION</code>:在<code class="fe mj mk ml mm b">UNION</code>之后的第二次或以后的查询。</li><li id="60ab" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">DEPENDENT UNION</code>:在<code class="fe mj mk ml mm b">UNION</code>之后的第二次或以后的查询，取决于外部查询。</li><li id="6706" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">UNION RESULT</code>:并集的结果。</li><li id="73d1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">SUBQUERY</code>:第一个子查询。</li><li id="a3ee" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">DEPENDENT SUBQUERY</code>:第一个子查询依赖于外部查询。</li><li id="9078" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">DERIVED</code>:派生表。</li><li id="454f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">MATERIALIZED</code>:物化子查询。</li><li id="ff75" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">UNCACHEABLE SUBQUERY</code>:结果无法缓存的子查询。</li><li id="1238" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">UNCACHEABLE UNION</code>:无法缓存<code class="fe mj mk ml mm b">UNION</code>之后的第二次查询或以后的查询的结果。</li></ul><p id="96e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最常用的有以下几种。</p><ul class=""><li id="c7a0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">SIMPLE</code>:简单的<code class="fe mj mk ml mm b">SELECT</code>查询，没有子查询和<code class="fe mj mk ml mm b">UNION</code></li><li id="290a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">PRIMARY</code>:复杂查询中最外层的查询，代表主查询。</li><li id="7a96" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">SUBQUERY</code>:子查询包含在<code class="fe mj mk ml mm b">SELECT</code>或<code class="fe mj mk ml mm b">WHERE</code>列表中。</li><li id="e1b6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">DERIVED</code>:包含在<code class="fe mj mk ml mm b">FROM</code>列表中的子查询，即派生的子查询。</li><li id="d4f4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">UNION</code>:在<code class="fe mj mk ml mm b">UNION</code>关键字后查询</li><li id="ea0a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">UNION RESULT</code>:从<code class="fe mj mk ml mm b">UNION</code>后的表中获取结果集。</li></ul><p id="81dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看这些<code class="fe mj mk ml mm b">SELECT</code>类型是如何出现的。</p><h2 id="9851" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"> <em class="og"> 1。简单的</em> </strong></h2><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="2e8a" class="nl mo it mm b gy ob oc l od oe">explain select * from test1;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/f37be90cec71aa4d0ecba453f8783612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcbNwTznlsLT-DpJY4Pfew.png"/></div></div></figure><p id="7627" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只出现在简单的<code class="fe mj mk ml mm b">SELECT</code>查询中，不包含子查询和<code class="fe mj mk ml mm b">UNION</code> s，这种类型更直观，我就不多说了。</p><h2 id="df99" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi"><strong class="ak"><em class="og">2. PRIMARY 和 SUBQUERY.</em></strong></h2><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="f408" class="nl mo it mm b gy ob oc l od oe">explain select * from test1 t1 where t1.id = (select id from  test1 t2 where  t2.id=2);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/5ac0f50ecf1df545ced58782692d88d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jrd9l8wJrIW92qkqx9_XGg.png"/></div></div></figure><p id="778b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到，在这个嵌套查询的SQL中，最外面的<code class="fe mj mk ml mm b">t1</code>表属于类型<code class="fe mj mk ml mm b">PRIMARY</code>，最里面的子查询<code class="fe mj mk ml mm b">t2</code>表属于类型<code class="fe mj mk ml mm b">SUBQUERY</code>。</p><h2 id="26f0" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"> <em class="og"> 3。</em>衍生</strong></h2><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="e1aa" class="nl mo it mm b gy ob oc l od oe">explain<br/>select t1.* from test1 t1<br/>inner join (select max(id) mid from test1 group by id) t2<br/>on t1.id=t2.mid</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/2bdba31314a189ac27f8f5e4576f3684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XduCU99WUeczJZ3KkgOq7g.png"/></div></div></figure><p id="e963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一条记录是派生表，一般是包含在<code class="fe mj mk ml mm b">FROM</code>列表中的子查询，这里是SQL中的分组子查询。</p><h2 id="2665" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak">4<em class="og">。联合和联合结果</em>和</strong></h2><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="8fc8" class="nl mo it mm b gy ob oc l od oe">explain<br/>select * from test1<br/>union<br/>select* from test2</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/198c1e3c6e249b045870052981c725dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KFyTHlc7WER0Sv4AWnZRTA.png"/></div></div></figure><p id="1a76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">test2</code>表是<code class="fe mj mk ml mm b">UNION</code>关键字后的查询，所以标记为<code class="fe mj mk ml mm b">UNION</code>，<code class="fe mj mk ml mm b">test1</code>为主表，标记为<code class="fe mj mk ml mm b">primary</code>。而<code class="fe mj mk ml mm b">&lt;union1,2&gt;</code>代表与<code class="fe mj mk ml mm b">id=1</code>和<code class="fe mj mk ml mm b">id=2</code>的表并集，结果标记为<code class="fe mj mk ml mm b">UNION RESULT</code>。</p><p id="85e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，<code class="fe mj mk ml mm b">UNION</code>和<code class="fe mj mk ml mm b">UNION RESULT</code>通常是成对的。</p><h2 id="1d91" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"/>之列<code class="fe mj mk ml mm b"><strong class="ak">table</strong></code></h2><p id="dc27" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">该列的值表示输出行引用的表的名称，如previous: <code class="fe mj mk ml mm b">test1, test2</code>等。</p><p id="3685" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但它也可以是下列值之一:</p><ul class=""><li id="18b5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">&lt;unionM,N&gt;</code> : <code class="fe mj mk ml mm b">M</code>具有和id值的行的联合<code class="fe mj mk ml mm b">N</code>。</li><li id="42a6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">&lt;derivedN&gt;</code>:用于与该行相关联的派生表结果id的值<code class="fe mj mk ml mm b">N</code>。派生表可能来自<code class="fe mj mk ml mm b">FROM</code>子句中的子查询。</li><li id="45bb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">&lt;subqueryN&gt;</code>:子查询的结果，id值为<code class="fe mj mk ml mm b">N</code>。</li></ul><h2 id="0ed9" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"/>之列<code class="fe mj mk ml mm b"><strong class="ak">partitions</strong></code></h2><p id="34d1" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">该列的值表示查询将从中匹配记录的分区。</p><h2 id="fb06" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"/>之列<code class="fe mj mk ml mm b"><strong class="ak">type</strong></code></h2><p id="6909" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">该列的值指示连接<code class="fe mj mk ml mm b">type</code>，并且是索引执行情况的重要指标。</p><p id="29d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这包含以下类型:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/54211a10e4f986a09a858b65e8b5b69a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nFTltPPdxMeGazXDLykcWA.png"/></div></div></figure><p id="8834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行结果从最好到最差的顺序是从上到下。</p><p id="9d4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要关注以下类型:</p><p id="3788" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</code></p><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="7c81" class="nl mo it mm b gy ob oc l od oe"># test2 table structure<br/>id    code    name<br/>1     001     city1</span></pre><p id="e51a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且在<code class="fe mj mk ml mm b">code</code>字段上建立公共索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/66596dba611fbc2cf03c009e269c9b5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pdT6AlB0YYJNmHyRAIH2yw.png"/></div></div></figure><p id="fdb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看几种常见的连接类型是如何逐一出现的。</p><h2 id="028f" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"> <em class="og"> 1。系统</em> </strong></h2><p id="efee" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">这种类型只需要数据库表中的一段数据，这是const类型的一个特例，一般不会出现。</p><h2 id="2947" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak">T29】2。常量和</strong></h2><p id="71a5" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">可以通过一个索引找到数据，这个索引一般用在查询SQL中，以主键或唯一索引作为条件。</p><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="79c8" class="nl mo it mm b gy ob oc l od oe">explain select * from test2 where id=1;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/06565386c78a3cb9d05e9c17e980cd56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q6CzGdaeqkgbpL0cvEWz8Q.png"/></div></div></figure><h2 id="6ec0" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"> <em class="og"> 3。eq _ ref</em>T35】</strong></h2><p id="694d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">通常用于主键或唯一索引扫描。</p><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="7c74" class="nl mo it mm b gy ob oc l od oe">explain select * from test2 t1 inner join test2 t2 on t1.id=t2.id;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/cac96086d45cc78ab45128bfcbeab833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S0XsUro1enCcGaP7t68Cwg.png"/></div></div></figure><p id="6b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">const</code>和<code class="fe mj mk ml mm b">eq_ref</code>都是对主键或唯一索引的扫描，有什么区别？</p><p id="c0b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是:那个<code class="fe mj mk ml mm b">const</code>只被索引一次，<code class="fe mj mk ml mm b">eq_ref</code>的主键匹配主键。由于表中有多条数据，在正常情况下，需要对它们进行多次索引以匹配所有数据。</p><h2 id="c6fd" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"> <em class="og"> 4。参考</em> </strong></h2><p id="e133" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">通常用于非主键和唯一索引扫描。</p><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="9940" class="nl mo it mm b gy ob oc l od oe">explain select * from test2 where code = '001';</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/ed1ecd6e949ba3370fc961fba5998067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RbYmfeqSBiAUfz-IeLhAQg.png"/></div></div></figure><h2 id="08b8" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"> <em class="og"> 5。</em>范围</strong></h2><p id="4aaa" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">常用于范围查询，如:<code class="fe mj mk ml mm b">between...and</code>或<code class="fe mj mk ml mm b">in</code>操作。</p><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="5d74" class="nl mo it mm b gy ob oc l od oe">explain select * from test2 where id between 1 and 2;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/300577f542f1046691773964188110b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wb2I0f489RxZIcdM9WNUg.png"/></div></div></figure><h2 id="e310" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"> <em class="og"> 6。索引</em> </strong></h2><p id="3024" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">完全索引扫描。</p><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="261f" class="nl mo it mm b gy ob oc l od oe">explain select code from test2;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/2afc9d890e86529b84783612be950a73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C5T1xQgFcf8Kpi6JnqB9Kw.png"/></div></div></figure><h2 id="5097" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"> <em class="og"> 7。全部</em> </strong></h2><p id="0dc5" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">全表扫描。</p><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="9d3c" class="nl mo it mm b gy ob oc l od oe">explain select *  from test2;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/a7737a39491f770f9e6171be616d3e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UHDrgxCxPJOiP6JMFPTBeg.png"/></div></div></figure><h2 id="e674" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"/>之列<code class="fe mj mk ml mm b"><strong class="ak">possible_keys</strong></code></h2><p id="1a19" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">该列表示可能的索引选择。</p><p id="7aac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，该列完全独立于表的顺序，这意味着在实践中<code class="fe mj mk ml mm b">possible_keys</code>一些键可能无法处理结果表的顺序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/fb32dfb65fda709d490e42aa79a5772f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zIurdureexFabFVLT8G3TA.png"/></div></div></figure><p id="8252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果此列是<code class="fe mj mk ml mm b">NULL</code>，则没有关联的索引。在这种情况下，您可以通过检查<code class="fe mj mk ml mm b">WHERE</code>子句来查看它是否引用了一些适合索引的列，从而提高查询性能。</p><h2 id="c764" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"/>T4之列】</h2><p id="ef16" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">该列表示实际使用的索引。可能会出现<code class="fe mj mk ml mm b">possible_keys</code>列是<code class="fe mj mk ml mm b">NULL</code>，而键不是<code class="fe mj mk ml mm b">NULL</code>的情况。</p><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="e5e6" class="nl mo it mm b gy ob oc l od oe"># test1 table structure<br/>id(bigint)    code(varchar30)    name(varchar30)<br/>1             001                foo<br/>2             002                bar</span></pre><p id="289f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">code</code>和<code class="fe mj mk ml mm b">name</code>字段使用联合索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/c3e8485fef0c63bfe686f41808dfcc27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4gsKuq9PV50HO8OQrL9h0g.png"/></div></div></figure><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="82af" class="nl mo it mm b gy ob oc l od oe">explain select code  from test1;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/4bef762f9d5601cff75c737d8baf4f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1BUl-Qx16ET8xfy_k_V5Eg.png"/></div></div></figure><p id="52ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该SQL不需要使用索引，但实际上使用了全索引扫描索引。</p><h2 id="bc5e" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"/><code class="fe mj mk ml mm b"><strong class="ak">key_len</strong></code><strong class="ak">之列。</strong></h2><p id="be34" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">该列指示所用索引的长度。上面的关键列可以看出索引是否被使用，<code class="fe mj mk ml mm b">key_len</code>列可以进一步看出索引是否被充分使用。毫不奇怪，它是最重要的一栏。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/5306f14d251cc48da6e4b94c7a3287c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGouyfgXvI7ivmXeoadtLQ.png"/></div></div></figure><p id="6969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">key_len</code>是怎么算出来的？</p><p id="287b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">三个因素决定了<code class="fe mj mk ml mm b">key_len</code>的值:</p><p id="e6dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.字符集。</p><p id="e330" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.长度。</p><p id="ba62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.是空的吗？</p><p id="42ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">常用字符编码占用的字节数如下:</p><ul class=""><li id="fb82" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">GBK: 2字节。</li><li id="e46b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">UTF8: 3个字节。</li><li id="d8e8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">iso 8859–1:1字节。</li><li id="6760" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">GB2312: 2字节。</li><li id="5a5c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">UTF-16: 2字节。</li></ul><p id="2e4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MySQL公共字段占用的字节数:</p><ul class=""><li id="8ce2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">char(n)</code> : <code class="fe mj mk ml mm b">n</code>字节。</li><li id="829c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">varchar(n)</code> : <code class="fe mj mk ml mm b">n + 2</code>字节。</li><li id="d8cf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">tinyint</code> : 1字节。</li><li id="4f96" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">smallint</code> : 2字节。</li><li id="e0eb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">int</code> : 4字节。</li><li id="014e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">bigint</code> : 8字节。</li><li id="b289" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">date</code> : 3字节。</li><li id="14ed" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">timestamp</code> : 4字节。</li><li id="17e0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">datetime</code> : 8字节。</li></ul><p id="cb3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，如果字段类型允许<code class="fe mj mk ml mm b">null</code>，则增加一个字节。</p><p id="0ca8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图中<code class="fe mj mk ml mm b">184</code>的数值是怎么算出来的？</p><p id="d1c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我使用我的数据库的字符编码格式:UTF8占用三个字节。</p><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="1ae2" class="nl mo it mm b gy ob oc l od oe">184 = 30 * 3 + 2 + 30 * 3 + 2</span></pre><p id="ce60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，将<code class="fe mj mk ml mm b">test1</code>表的code字段类型改为char，更改为允许为空，然后再次测试。</p><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="7b84" class="nl mo it mm b gy ob oc l od oe">explain select code  from test1;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/5fcebadd3c95c43c20bb4a9fa19c0307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F26PM2l3oXNvqFY0zW-rBA.png"/></div></div></figure><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="341b" class="nl mo it mm b gy ob oc l od oe">183 = 30 * 3 + 1 + 30 * 3 + 2</span></pre><p id="24b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个问题:为什么这个列表示索引是否被完全使用？</p><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="a7c1" class="nl mo it mm b gy ob oc l od oe">explain select code  from test1 where code='001';</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/aa851d4d6fffd14eec1946152f91701f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQBgQNOyywi4N1GXNPW0pA.png"/></div></div></figure><p id="85d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图用的是关节指数:<code class="fe mj mk ml mm b">idx_code_name</code>。如果索引匹配所有的<code class="fe mj mk ml mm b">key_len</code>，应该是<code class="fe mj mk ml mm b">183</code>，但实际上是<code class="fe mj mk ml mm b">92</code>，说明没有使用所有的索引，索引没有完全使用。</p><h2 id="841d" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"/>之列<code class="fe mj mk ml mm b"><strong class="ak">ref</strong></code></h2><p id="9195" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">此列表示索引命中的列或常数。</p><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="f330" class="nl mo it mm b gy ob oc l od oe">explain select *  from test1 t1 inner join test1 t2 on t1.id=t2.id where t1.code='001';</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/e63c5dc804ec890c9c3c9dcfe194becd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gVSqtrqjk71vtTzVUXPN0A.png"/></div></div></figure><p id="b5fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到表<code class="fe mj mk ml mm b">t1</code>命中的索引是const(常量)，而<code class="fe mj mk ml mm b">t2</code>命中的索引是列<code class="fe mj mk ml mm b">sue</code>库的<code class="fe mj mk ml mm b">t1</code>表的id字段。</p><h2 id="b08f" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"/>之列<code class="fe mj mk ml mm b"><strong class="ak">rows</strong></code></h2><p id="7b66" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">该列表示MySQL认为执行查询必须检查的行数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/f5fce5f3c1119c218cf8defe6ed2cfac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QzSGmlrXw87jzh0-elP7Jw.png"/></div></div></figure><p id="305c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于InnoDB表，这个数字是一个估计值，可能并不总是准确的。</p><h2 id="2e45" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"/>之列<code class="fe mj mk ml mm b"><strong class="ak">filtered</strong></code></h2><p id="fd69" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">此列表示按表标准筛选的表行的估计百分比。最大值为<code class="fe mj mk ml mm b">100</code>，表示不过滤行。从<code class="fe mj mk ml mm b">100</code>开始减小数值表示过滤增加。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/9e072f5c3873d7c88936530b3f3d425f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6p8cg8Uwbpvc6bkKf9hag.png"/></div></div></figure><p id="cef9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rows显示检查的估计行数，rows × filtered显示连接到下表的行数。</p><p id="ad3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果<code class="fe mj mk ml mm b">rows</code>为<code class="fe mj mk ml mm b">1,000</code>且<code class="fe mj mk ml mm b">filtered</code>为<code class="fe mj mk ml mm b">50.00 (50%)</code>，则与下表连接的行数为1000 × 50% = 500。</p><h2 id="18e8" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"/>之列<code class="fe mj mk ml mm b"><strong class="ak">extra</strong></code></h2><p id="5e65" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">该字段包含关于MySQL如何解析查询的其他信息。这个栏目还是很重要的，但是里面的值太多了，就不一一介绍了，只列举几个常见的。</p><h2 id="899e" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"> <em class="og"> 1。不可能</em>在哪里</strong></h2><p id="cc6a" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">表示<code class="fe mj mk ml mm b">WHERE </code>之后的条件总是<code class="fe mj mk ml mm b">false</code>。</p><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="4a68" class="nl mo it mm b gy ob oc l od oe">explain select code  from test1 where 'a' = 'b';</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/2f02658df075f11dc666ed66b1e199a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dh6nDUipzZH7x-kRxop3PQ.png"/></div></div></figure><h2 id="5ae3" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak">2<em class="og">。使用文件排序</em>和</strong></h2><p id="1c7c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">指示按文件排序，这通常发生在指定的排序和索引排序不一致时。</p><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="5003" class="nl mo it mm b gy ob oc l od oe">explain select code  from test1 order by name desc;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/297c5b7e8765199624152aa8e9c11a9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXwloJisHVpnaUhqXCYedQ.png"/></div></div></figure><p id="6477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里建立了代码和名称的联合索引。顺序是代码在前，名字在后。这里的顺序是直接按名称降序排列的，与之前的联合索引顺序不同。</p><h2 id="757f" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"> <em class="og"> 3。使用索引</em> </strong></h2><p id="690a" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">表示是否使用了覆盖索引，说白了就是表示得到的所有列是否都经过了索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/1aca17032210ca9bc0509c8b23447cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3q5DAKaxML-Ft8fMQ-cHBw.png"/></div></div></figure><p id="c95f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，实际使用的是:使用index，因为只返回一列代码，所以对其字段进行索引。</p><h2 id="706f" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"> <em class="og"> 4。使用临时</em> </strong></h2><p id="89a6" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">指示是否使用临时表，通常在<code class="fe mj mk ml mm b">order by</code>和<code class="fe mj mk ml mm b">group by</code>语句中可以看到。</p><pre class="kj kk kl km gt nx mm ny nz aw oa bi"><span id="680c" class="nl mo it mm b gy ob oc l od oe">explain select name  from test1 group by name;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/db4e29fa2a87512bd55886d91bd20405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e__Adae3V0-PgkAiVRuVwg.png"/></div></div></figure><h2 id="3f9e" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak"> <em class="og"> 5。使用</em>哪里</strong></h2><p id="5b40" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">指示使用where条件筛选器。</p><h2 id="800c" class="nl mo it bd mp nm nn dn mt no np dp mx li nq nr mz lm ns nt nb lq nu nv nd nw bi translated"><strong class="ak">⑥<em class="og">⑥。使用连接缓冲区</em>和</strong></h2><p id="6165" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">指示是否使用连接缓冲。早期连接中的表被部分读入连接缓冲区，并且使用缓冲区中的行来执行与当前表的连接。</p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><p id="d49d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是索引优化的过程:</p><ol class=""><li id="307c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu oq mb mc md bi translated">首先，使用慢速查询日志来定位需要优化的特定SQL。</li><li id="8440" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oq mb mc md bi translated">使用<code class="fe mj mk ml mm b">explain</code>执行计划查看索引使用情况。</li><li id="2a4f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oq mb mc md bi translated">重点:<code class="fe mj mk ml mm b">key, key_len, type, extra</code>。一般来说，可以根据这四列找到索引问题。</li><li id="b1da" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oq mb mc md bi translated">根据第三步发现的索引问题优化SQL。</li><li id="3b8d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oq mb mc md bi translated">回到步骤2，再次执行。</li></ol></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><p id="174e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您阅读这篇文章。</p><p id="012c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="or">敬请期待更多。</em></p></div></div>    
</body>
</html>