<html>
<head>
<title>Top 40 C# Data Structure Questions for Interviews</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面试前40个C#数据结构问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/crack-the-top-40-c-data-structure-questions-5a71608f33ec?source=collection_archive---------1-----------------------#2021-03-12">https://betterprogramming.pub/crack-the-top-40-c-data-structure-questions-5a71608f33ec?source=collection_archive---------1-----------------------#2021-03-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="89e1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从数组和链表到堆和散列，提高你的数据结构技能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d6a75d077430cab540679dd2e312a29f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qh3TPo6t8FgylRlBH_AiQg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="cbe2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据结构问题是编码面试中最常见的问题。这些问题测试您实现、优化和调整数据结构以解决特殊情况的能力。在你的编码面试之前回顾一些常见的问题是很重要的，以确保你不会被一个不熟悉的问题弄得措手不及。</p><p id="3ca1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天，我们将帮助你复习数据结构技能，复习下一次面试前你应该练习的40个顶级数据结构问题。</p><p id="8626" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">这是我们今天要讲的内容:</strong></p><ul class=""><li id="7bc1" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">复杂性度量问题</li><li id="889b" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">C#数组</li><li id="d330" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">C#链表</li><li id="f103" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">C#堆栈和队列</li><li id="825f" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">C#树和尝试</li><li id="2643" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">C#堆和哈希</li><li id="bc38" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">C#编码面试的18个问题</li><li id="1b7b" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">接下来学什么</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="9821" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">复杂性度量问题</h1><h2 id="8874" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">1.大O复杂度:嵌套加法</h2><p id="0157" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">找出下面代码片段的复杂性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="d5d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案和说明</strong></p><p id="8ff8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">O(n)</p><p id="e78d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在外循环的第11行，<code class="fe oa ob oc od b">int i=0;</code>运行一次。</p><p id="de38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b">i&lt;n;</code>被执行(n/3)+1次，<code class="fe oa ob oc od b">i+=3</code>被执行n/3次<br/>。</p><p id="17e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在内部循环中，<code class="fe oa ob oc od b">int j=0;</code>总共被执行(n/3)次。<code class="fe oa ob oc od b">j&lt;n;</code>执行(n/3) * ((n/2) +1)次，<code class="fe oa ob oc od b">j+=2</code>执行(n/3) * (n/2)次。</p><h2 id="9d27" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">2.大O复杂度:嵌套乘法</h2><p id="ad65" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">找出下面代码片段的复杂性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9d11" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">O(n)</p><p id="f752" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将循环变量乘以/除以一个常数的循环语句需要logk n次，因为循环运行了那么多次。在外循环中，循环变量在每次迭代中乘以<code class="fe oa ob oc od b">2</code>。因此，外部循环运行O(log2 n)次。</p><p id="abbc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">内部循环运行<code class="fe oa ob oc od b">counter</code>次，而不是<code class="fe oa ob oc od b">n</code>次。在第一次迭代中，<code class="fe oa ob oc od b">counter</code>的值是1，然后是2，然后是4，然后是8，依此类推，直到2^k使得(2^k) &lt; n。当你对外部循环的所有迭代的<code class="fe oa ob oc od b">counter</code>值求和时，内部循环运行:</p><p id="cf37" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">1+2+4+8+ …+(2^k)次。</p><p id="7194" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你将使用一个几何级数来计算这个值。为了使计算更简单，你必须假设2^k = n</p><p id="6831" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(2⁰)+(2 )+(2 )…+(2^k) = 2^(k+1)-1</p><p id="dadb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(2^k)(2)——1</p><p id="7d47" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用n代替2^k，你得到:</p><p id="4a0e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">= 2n-1</p><p id="023d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">似乎内部循环总共运行了2n-1次(考虑到外部循环的所有迭代)，但是请记住，当n&gt;(2^k).实际上，内部循环运行的次数少于2n-1次，但是您可以认为这是上限。</p><h2 id="f27c" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">3.带嵌套乘法的大O(高级)</h2><p id="b578" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">找出以下代码片段的复杂性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2228" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">O(n)</p><p id="ec5d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">主函数中的外部循环在从<code class="fe oa ob oc od b">0</code>到<code class="fe oa ob oc od b">n-1</code>对<code class="fe oa ob oc od b">i</code>进行迭代时有<code class="fe oa ob oc od b">n</code>次迭代。如果条件<code class="fe oa ob oc od b">j &lt; i</code>为真，则进入内部循环。但是，<code class="fe oa ob oc od b">j</code>马上翻倍。请注意，代码中的<code class="fe oa ob oc od b">j</code>不会重置为<code class="fe oa ob oc od b">1</code>，因为<code class="fe oa ob oc od b">j</code>会立即加倍。</p><p id="dc29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，对于外部循环的所有迭代，内部<code class="fe oa ob oc od b">while</code>循环将运行O(log2 n)次。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="5267" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">C#数组</h1><h2 id="3e07" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">4.从数组中移除偶数整数</h2><p id="8f29" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">实现一个函数<code class="fe oa ob oc od b">removeEven( int[]Arr, int size )</code>，它接受一个数组<code class="fe oa ob oc od b">Arr</code>及其大小，并从给定的数组中移除所有偶数元素。</p><p id="1bc1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="cbcd" class="nh mq it od b gy oi oj l ok ol">// Input: Arr = [1,2,4,5,10,6,3]<br/>// Output: Arr = [1,5,3]</span></pre><p id="f45a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案和解释</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="75b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong> : O(n)</p><p id="006d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个解决方案首先检查<code class="fe oa ob oc od b">Arr</code>的第一个元素是否是奇数。然后，它将这个元素附加到数组<code class="fe oa ob oc od b">Arr</code>的开头；否则，它会跳到下一个元素。重复此过程，直到到达数组<code class="fe oa ob oc od b">Arr</code>的末尾，同时将奇数总数<code class="fe oa ob oc od b">m</code>的计数保存在<code class="fe oa ob oc od b">Arr</code>中。接下来，我们创建一个临时数组<code class="fe oa ob oc od b">temp</code>，用来存储所有奇数。</p><p id="a529" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从那里，我们删除分配给<code class="fe oa ob oc od b">Arr</code>的内存，并将其指向<code class="fe oa ob oc od b">temp</code>数组。最后，我们返回数组<code class="fe oa ob oc od b">Arr</code>也就是说，它现在只包含奇数元素。</p><h2 id="b7d4" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">5.查找数组中的最小值</h2><p id="709b" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">实现一个函数<code class="fe oa ob oc od b">findMinimum(int arr[], int size)</code>，它接受一个数组<code class="fe oa ob oc od b">arr</code>及其大小，并返回给定数组中的最小数字。</p><p id="5349" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="a249" class="nh mq it od b gy oi oj l ok ol">// Input: arr = [9,2,3,6]<br/>// Output: 2</span></pre><p id="eace" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案和解释</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7ad1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong> : O(n)</p><p id="04b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从第一个元素开始(在本例中是<code class="fe oa ob oc od b">9</code>)，将其保存为最小值。然后，迭代数组的其余部分。每当发现小于<code class="fe oa ob oc od b">minimum</code>的元素时，将<code class="fe oa ob oc od b">minimum</code>设置为该数字。</p><p id="80fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到数组结束时，<code class="fe oa ob oc od b">minimum</code>中存储的数字将是整个数组中最小的整数。</p><h2 id="3fe6" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">6.最大子阵列和</h2><p id="f121" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">给定一个未排序的数组<code class="fe oa ob oc od b">Arr</code>，找出相加得到最大值的连续元素的集合。</p><p id="55b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">提示</strong>:记住数组可以包含负数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/ed84f984c1518c03430c1b7dec23d454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z_PU_lho3LlzUvEb.PNG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="d2a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案和说明</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="d784" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">时间复杂度 : O(n)</p><p id="0cb6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个解决方案使用Kadane的算法来扫描整个阵列。</p><p id="d658" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看看Kadane的伪代码算法:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="0a8b" class="nh mq it od b gy oi oj l ok ol">currMax = A[0]<br/>globalMax = A[0]<br/>for i = 1 -&gt; size of A<br/>    if currMax is less than 0<br/>        then currMax = A[i]<br/>    otherwise <br/>        currMax = currMax + A[i]<br/>    if globalMax is less than currMax <br/>        then globalMax = currMax</span></pre><p id="8604" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在数组中的每个位置，我们找到结束于此的子数组的最大和。这是通过为当前数组索引保留一个<code class="fe oa ob oc od b">currMax</code>和一个<code class="fe oa ob oc od b">globalMax</code>来实现的。最后，我们知道<code class="fe oa ob oc od b">globalMax</code>的值将是最高的子阵列，而不考虑<code class="fe oa ob oc od b">currMax</code>的值。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="b0f7" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">C#链表</h1><p id="a54e" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">下面是您可以在本节中使用的<code class="fe oa ob oc od b">Node</code>和<code class="fe oa ob oc od b">LinkedList</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="a2a4" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">7.尾部插入</h2><p id="22ca" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">创建一个函数<code class="fe oa ob oc od b">insertAtTail()</code>，它接受一个整数，将该整数添加到一个链表的末尾，并返回更新后的链表。新节点将指向<code class="fe oa ob oc od b">null</code>。</p><p id="8a95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案和解释</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="77ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong> : O(n)</p><p id="1023" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果列表是空的，情况就像在开头插入一样。</p><p id="8369" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">否则，您可以简单地使用一个循环到达列表的尾部，并将您的新节点设置为最后一个节点的<code class="fe oa ob oc od b">nextElement</code>。</p><h2 id="d03c" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">8.从链接列表中删除重复项</h2><p id="2972" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">实现<code class="fe oa ob oc od b">removeDuplicates()</code>函数，该函数获取一个链表并返回没有重复节点的链表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/7dd19dc5a729d697230a4778df6d7af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8wsSRYwTutSW1aXY.PNG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="8446" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案和解释</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="c73e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong> : O(n)</p><p id="695d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个实现中，我们对照剩余的列表检查每个节点，看一个节点是否包含相同的值。</p><p id="6924" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b">start</code>遍历外部循环，而<code class="fe oa ob oc od b">startNext</code>检查<code class="fe oa ob oc od b">LinkedList.cs</code>中<strong class="la iu">行90 </strong>上的重复项。</p><p id="37ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无论何时发现重复，使用<strong class="la iu">行103 </strong>将其从列表中删除。</p><h2 id="c9e1" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">9.连接两个链表</h2><p id="1284" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">实现<code class="fe oa ob oc od b">Union()</code>函数，该函数接受两个链表并返回一个包含两个链表中所有唯一元素的链表。</p><p id="f8fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案和解释</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2904" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong> : O(m + n)其中<code class="fe oa ob oc od b">m</code>是第一个列表的大小<code class="fe oa ob oc od b">n</code>是第二个列表的大小。</p><p id="71fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">遍历第一个列表的尾部，链接到<code class="fe oa ob oc od b">LinkedList.cs</code>中<strong class="la iu">行125–131</strong>的第二个列表的第一个节点。现在，从组合列表中删除重复项。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="f936" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">C#堆栈和队列</h1><p id="8a63" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">下面是堆栈和队列的实现，供您在本节中使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="c21b" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">10.生成从1到N的二进制数</h2><p id="826f" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">实现一个函数<code class="fe oa ob oc od b">string [] findBin(int n)</code>，它使用一个队列生成从<code class="fe oa ob oc od b">1</code>到<code class="fe oa ob oc od b">n</code>的二进制数，并存储在一个字符串数组中。</p><p id="fc66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案和解释</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="058f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong> : O(n)</p><p id="5dc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第17 行，<code class="fe oa ob oc od b">1</code>作为起点排队。然后，一个数从队列中出队并存储在结果数组中，以生成一个二进制数序列。</p><p id="bb72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<strong class="la iu">行22-23</strong>、<code class="fe oa ob oc od b">0</code>和<code class="fe oa ob oc od b">1</code>被附加到它上面，以产生下一个数字，然后这些数字也被排队到<strong class="la iu">行24-25 </strong>的队列中。队列接受整数值。在排队之前，解决方案确保将字符串转换为整数。</p><p id="2541" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">队列的大小应该比<code class="fe oa ob oc od b">n</code>大1，因为每个数字有两种变化；一个追加<code class="fe oa ob oc od b">0 </code>，一个追加<code class="fe oa ob oc od b">1</code>。</p><h2 id="6446" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">11.使用堆栈实现队列</h2><p id="0230" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">使用<code class="fe oa ob oc od b">myStack</code>类实现<code class="fe oa ob oc od b">NewQueue</code>类中的<code class="fe oa ob oc od b">enqueue()</code>函数。<code class="fe oa ob oc od b">enqueue()</code>取一个整数，将值插入队列后返回<code class="fe oa ob oc od b">true</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/ecd394b7ed5a098122050d632182331a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/0*8x_x0Cd6j8PNCw6l.PNG"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="e62b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案和解释</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="87f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong> : O(n)</p><p id="f694" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法使用两个堆栈。<code class="fe oa ob oc od b">mainStack</code>存储队列元素，<code class="fe oa ob oc od b">tempStack</code>作为临时缓冲区提供队列功能。</p><p id="2c9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">确保在每个入队操作之后，新插入的值位于主堆栈的底部。</p><p id="b43c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在插入之前，所有其他元素都被转移到<code class="fe oa ob oc od b">tempStack</code>，自然，它们的顺序是相反的。新元素被添加到空的<code class="fe oa ob oc od b">mainStack</code>。最后，所有元素被推回到<code class="fe oa ob oc od b">mainStack</code>中，并且<code class="fe oa ob oc od b">tempStack</code>变为空。</p><h2 id="1083" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">12.查找堆栈中的最小值</h2><p id="0811" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">用函数<code class="fe oa ob oc od b">min()</code>实现<code class="fe oa ob oc od b">minStack</code>类，该函数返回堆栈中的最低值。<code class="fe oa ob oc od b">min()</code>一定有$O(1)$的复杂度。</p><p id="2b68" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">提示</strong>:元素返回，不弹出。</p><p id="d32a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案和解释</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="58f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong> : O(1)</p><p id="139f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">整个实现依赖于两个栈的存在:<code class="fe oa ob oc od b">minStack</code>和<code class="fe oa ob oc od b">mainStack</code>。</p><p id="3331" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b">mainStack</code>保存包含所有元素的实际堆栈，而<code class="fe oa ob oc od b">minStack</code>是一个堆栈，其顶部总是包含堆栈中的当前最小值。</p><p id="3d7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每当调用push时，<code class="fe oa ob oc od b">mainStack</code>简单地在顶部插入新值。</p><p id="2b56" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，<code class="fe oa ob oc od b">minStack</code>会检查被推送的值。如果<code class="fe oa ob oc od b">minStack</code>为空，该值被推入其中，成为当前最小值。如果<code class="fe oa ob oc od b">minStack</code>中已经有元素，则该值与顶部元素进行比较。</p><p id="8c95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果该值低于<code class="fe oa ob oc od b">minStack</code>的顶部，它将被推入并成为新的最小值。否则，顶部保持不变。</p><p id="a4cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于采取了所有这些保护措施，<code class="fe oa ob oc od b">min</code>函数只需要返回<code class="fe oa ob oc od b">minStack</code>顶部的值。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="db9f" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">C#树和尝试</h1><p id="a809" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">下面是二分搜索法树的一个实现，可供您在本节中使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="89b2" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">13.查找二叉查找树中的最小值</h2><p id="49e2" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">实现<code class="fe oa ob oc od b">int findMin(Node* rootNode)</code>，它接受一个二叉查找树并返回树中的最小值。</p><p id="9854" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记住</strong>:当前节点左子树中的节点总是较低的，而右子树中的节点总是较大的。</p><p id="9236" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案和解释</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="c23d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong> : O(h)</p><p id="36f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个解决方案是递归的，以提高效率。BST的排序结构使这个解决方案更容易，因为我们只需找到最左边的节点。</p><p id="d59f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们检查根是否是<code class="fe oa ob oc od b">null</code>。如果是，我们返回<code class="fe oa ob oc od b">-1</code> ( <strong class="la iu">第10-11行</strong>)。否则，我们检查当前节点的左子节点是否是<code class="fe oa ob oc od b">null</code>。如果是，那么这个根就是最左边的节点，你在那里返回值(<strong class="la iu">第12-13行</strong>)。</p><p id="d0e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果左节点存在，调用其上的<code class="fe oa ob oc od b">findMin()</code>函数(<strong class="la iu">第14-15行</strong>)。</p><h2 id="5ab1" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">14.求BST的高度</h2><p id="375d" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">实现<code class="fe oa ob oc od b">int findHeight(Node* rootNode)</code>，它接受一个二叉查找树并返回其高度。</p><p id="7502" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">树的高度等于根节点和最低节点之间的边数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/23b4fa568297c75a136cfebc0b31804e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bbe_qRBl-zyUlRrG.PNG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="43df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案和说明</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="cb66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong> : O(n)</p><p id="d8bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">树的高度等于左边或右边子树的最大高度。</p><p id="77b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以必须递归求左右子树的高度。首先，我们检查树是否为空，如果给定的节点是<code class="fe oa ob oc od b">null</code>，则返回<code class="fe oa ob oc od b">-1</code>。如果没有，我们调用左边和右边子树上的<code class="fe oa ob oc od b">findHeight()</code>函数并返回具有较大值加1的那个。</p><h2 id="a3f5" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">15.2–3棵树与BST</h2><p id="0e8b" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">2-3棵树和二分搜索法树有什么区别？</p><p id="1706" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2–3树是一种平衡有序的搜索树，它提供了非常高效的存储机制来保证快速操作。</p><p id="92c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在2-树中，每个节点最多只有两个子节点。对于三叉树，每个节点最多可以有三个子节点。子元素的排序是最低值在左边，最高值在右边。</p><p id="842f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与BST不同，无论插入还是删除，它总是保持平衡。这是为了确保高度不会增加到某一水平，因为所有操作的时间复杂度主要取决于它。</p><p id="8adb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理想情况下，您希望高度以对数表示，因为随着树越来越大，执行操作将需要更多的时间。</p><h2 id="677c" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">16.trie中的插入</h2><p id="b793" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">实现<code class="fe oa ob oc od b">insertNode(string key)</code>函数，该函数获取一个单词并将其插入到现有的trie中。</p><p id="5728" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记住</strong>:考虑插入的三种情况:无常用前缀、常用前缀、已有单词。</p><p id="761c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案和说明</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="c119" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">时间复杂度 : O(n)</p><p id="3325" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该函数采用一个字符串<code class="fe oa ob oc od b">key</code>，表示一个单词。<code class="fe oa ob oc od b">NULL</code>不允许使用键，所有键都以小写存储。</p><p id="9b60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们迭代键中的字符。对于每个字符，我们使用<code class="fe oa ob oc od b">getIndex()</code>生成一个索引。</p><p id="0f80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一步是在特定索引处检查<code class="fe oa ob oc od b">currentNode</code>的子节点。如果是<code class="fe oa ob oc od b">NULL</code>，那么我们在那个索引处创建一个新的<code class="fe oa ob oc od b">TrieNode</code>。</p><p id="ee5b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们将最后一个节点标记为叶子，因为单词已经结束。</p><h1 id="11c0" class="mp mq it bd mr ms oq mu mv mw or my mz jz os ka nb kc ot kd nd kf ou kg nf ng bi translated">17.一个trie中的总字数</h1><p id="f8d3" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">实现<code class="fe oa ob oc od b">totalWords()</code>函数，该函数将获取一个trie并返回trie中的单词总数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/258dc9b63b34bb33a7543cde9f16767d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/0*039HTtHfS-DLLT67.PNG"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="9493" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案和解释</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a1c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong> : $O(n)$</p><p id="1c71" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从根开始，我们递归地访问每个分支。每当发现一个节点的<code class="fe oa ob oc od b">isEndWord</code>设置为真时，<code class="fe oa ob oc od b">result</code>变量就增加1。</p><p id="6350" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们返回<code class="fe oa ob oc od b">result</code>来统计总字数。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="3703" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">C#堆和哈希</h1><h2 id="be78" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">18.实现最大堆</h2><p id="025b" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">最大堆是一个完整的二叉树，其中每个内部节点的值大于或等于该节点的子节点中的值。</p><p id="e676" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你的max-heap必须包含<code class="fe oa ob oc od b">insert()</code>和<code class="fe oa ob oc od b">delete()</code>函数，但也可以包含任何额外的功能。</p><p id="de66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案和解释</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2576" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong> : O(n)</p><p id="1f93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意你从堆的底部开始，也就是<code class="fe oa ob oc od b">i = size-1</code> ( <strong class="la iu"> line 78 </strong>)。如果堆的高度是<code class="fe oa ob oc od b">h</code>，那么层次从<code class="fe oa ob oc od b">0</code>(在根节点)到最深的叶节点<code class="fe oa ob oc od b">h</code>。通过在叶节点调用<code class="fe oa ob oc od b">maxHeapify()</code>，您将有一个常数时间操作。</p><p id="430d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe oa ob oc od b">h - 1h−1</code>级，对于每个节点，<code class="fe oa ob oc od b">maxHeapify()</code>最多进行一次比较和交换操作。在级别<code class="fe oa ob oc od b">h−2</code>，它对每个节点最多进行两次比较和交换。这一直持续到根节点，在那里它最多进行<code class="fe oa ob oc od b">h</code>比较，交换操作。</p><h2 id="9747" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">19.查找数组中的最小元素</h2><p id="d50c" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">实现一个函数<code class="fe oa ob oc od b">findKSmallest(int[] arr, int size, int k)</code>,该函数将一个未排序的整数数组作为输入，并使用堆返回数组中的最小元素<code class="fe oa ob oc od b">k</code>。</p><p id="3682" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用下面的<code class="fe oa ob oc od b">minHeap</code>实现作为起点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ccde" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案和解释</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ba44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong> : O(n + klog n)</p><p id="9044" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里创建一个堆，然后调用<code class="fe oa ob oc od b">buildHeap</code> ( <strong class="la iu"> line 12 </strong>)函数从给定的数组创建一个最小堆。要找到数组中的<code class="fe oa ob oc od b">k</code>最小元素:</p><p id="fe50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你从堆中得到最小值。</p><p id="7f3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将结果保存到矢量输出。</p><p id="3f22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从堆中移除最小值。</p><p id="d755" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">重复相同的步骤<code class="fe oa ob oc od b">k</code>次(提供<code class="fe oa ob oc od b">k &lt; size</code>)。</p><h2 id="7a23" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">20.Trie与哈希表</h2><p id="67b8" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">比较尝试和哈希表的使用和性能。</p><p id="cb97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两种数据结构都可以用于相同的工作，但是它们的性能会根据程序的性质而有所不同。</p><p id="4f03" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">平均来说，哈希表可以在常量时间内执行搜索、插入和删除，而trie通常在$O(n)$内工作。</p><p id="d52a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个有效的哈希表需要一个智能哈希函数，该函数可以将键分布在所有可用的空间中。trie实现起来更简单，因为它只在需要的时候访问额外的空间。</p><p id="dd27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，trie将证明对有序数据更有用，因为它的树结构有助于保持数据的顺序。</p><h2 id="e9cd" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">21.子集数组检查器</h2><p id="a2a2" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">实现<code class="fe oa ob oc od b">isSubset(int[] arr1, int[] arr2, int size1, int size2)</code>函数，该函数将两个数组及其大小作为输入，并检查一个数组是否是另一个数组的子集。</p><p id="94fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数组将不包含重复值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/47e03a0ebd6d9434226cca66b6e4d947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j8A25tDuBfVQO-08.PNG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="7c9f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案和说明</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2d59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong> : O(m+n)其中<em class="ow"> m </em>是<code class="fe oa ob oc od b">arr1</code>中的元素个数，<em class="ow"> n </em>是<code class="fe oa ob oc od b">arr2</code>中的元素个数。</p><p id="69b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">C#内置的<code class="fe oa ob oc od b">HashSet</code>让这个解决方案简单多了。首先，我们在第16行上迭代<code class="fe oa ob oc od b">arr1</code>。如果当前索引处的值不在<code class="fe oa ob oc od b">HashSet</code>中，我们将该值插入<strong class="la iu">行的<code class="fe oa ob oc od b">HashSet</code>中的第20-21行</strong>。然后，我们遍历<code class="fe oa ob oc od b">arr2</code>，看看它们的元素是否出现在<code class="fe oa ob oc od b">HashSet</code>中。</p><p id="88b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果<code class="fe oa ob oc od b">arr2</code>的所有元素都出现在<code class="fe oa ob oc od b">HashSet</code>中，那么你的函数将返回<code class="fe oa ob oc od b">true</code> <strong class="la iu">第25-32行</strong>。</p><h2 id="10a5" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">22.找出两个和相等的配对</h2><p id="938c" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">实现<code class="fe oa ob oc od b">string findPair(int[] arr, int size)</code>函数，该函数将获取一个数组，并在数组中找到两对<code class="fe oa ob oc od b">[a, b]</code>和<code class="fe oa ob oc od b">[c, d]</code>，使得:</p><p id="69ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">a+b = c+d</p><p id="f2df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记住</strong>:你只需要找到数组中的任意两对，而不是所有对。</p><p id="9229" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案和解释</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="28f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong> : O(n)</p><p id="5d2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了简单起见，这个解决方案使用了C#的内置<code class="fe oa ob oc od b">Dictionary</code>类。</p><p id="30cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<strong class="la iu">第23–33行</strong>上，<code class="fe oa ob oc od b">arr</code>中的每个元素与所有其他元素相加。总和成为<code class="fe oa ob oc od b">hMap</code>中的关键。在每个键上，存储其和生成该键的整数对。</p><p id="328a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每当发现一个和时，它在<code class="fe oa ob oc od b">hMap</code>中的键已经存储了一个整数对，您就可以得出结论，这个和可以由数组中的两个不同的对构成。这两对然后在第36-46 行的<strong class="la iu">上返回到<code class="fe oa ob oc od b">result</code>数组中。</strong></p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="7cb6" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">C#编码面试的18个问题</h1><ol class=""><li id="945d" class="lu lv it la b lb nt le nu lh ox ll oy lp oz lt pa ma mb mc bi translated">在C#中反转字符串</li><li id="a3a4" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">检查给定的字符串是否是回文</li><li id="0221" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">旋转数组</li><li id="5bd0" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">使用一个循环找出数组中第二大的整数</li><li id="e8e1" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">将2D数组转换为1D数组</li><li id="ed19" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">解释并实现合并排序算法</li><li id="834a" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">找出一个链表是否是循环的</li><li id="e7f8" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">平衡二叉查找树</li><li id="be12" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">以尽可能低的时间复杂度搜索排序后的数组</li><li id="5e5c" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">0-1背包问题</li><li id="fc7a" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">反转一个链表</li><li id="7d67" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">匹配字符串中的开始和结束括号</li><li id="0a12" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">将整数数组混洗到位</li><li id="b7f1" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">在BST中查找给定节点的祖先</li><li id="2a19" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">找出图中两个顶点之间的最短路径</li><li id="e011" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">计算无向图中的边数</li><li id="a279" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">使用堆栈检查平衡括号</li><li id="92c1" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">对堆栈中的值进行排序</li></ol></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="fff1" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">后续步骤</h1><p id="8687" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">在这些问题上做得很好！为下一次面试做准备的最好方法是不断地用这些常见的数据结构问题进行实践。</p><p id="3eac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ow">快乐学习！</em></p></div></div>    
</body>
</html>