<html>
<head>
<title>How To Use DRF Serializers Effectively in Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Django中有效使用DRF序列化器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-drf-serializers-effectively-dc58edc73998?source=collection_archive---------0-----------------------#2019-07-23">https://betterprogramming.pub/how-to-use-drf-serializers-effectively-dc58edc73998?source=collection_archive---------0-----------------------#2019-07-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9e6a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用源参数、SerializerMethodField和to_representation</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/cc9ebe8a7fb564d6ef23c6a2db32a32b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*N5Iep1wJY1iXgMzpHxzE8w.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">Django REST框架序列化程序</p></figure><p id="320e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章假设读者对Django REST框架有基本的了解。</p><p id="8c3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将讨论如何在读操作期间有效地使用序列化程序。我们将看看三个强大的特性，它们将帮助我们用更少的代码获得想要的结果。</p><p id="ebb0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将讨论:</p><ul class=""><li id="bae4" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">使用序列化程序的<code class="fe ma mb mc md b">source</code>参数的多种方式。</li><li id="20e2" class="lr ls it kw b kx me la mf ld mg lh mh ll mi lp lw lx ly lz bi translated">如何以及何时使用<code class="fe ma mb mc md b">SerializerMethodField</code>。</li><li id="e061" class="lr ls it kw b kx me la mf ld mg lh mh ll mi lp lw lx ly lz bi translated">如何以及何时使用<code class="fe ma mb mc md b">to_representation</code>。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="621c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">如何使用Source关键字参数</h1><p id="d187" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">DRF序列化器提供了一个名为<code class="fe ma mb mc md b">source</code>的关键字参数，它非常聪明，可以帮助避免许多常见的模式。</p><p id="e194" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们编写一个序列化程序，它可以创建一个<code class="fe ma mb mc md b">User</code>的序列化表示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="af6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们使用这个序列化程序来序列化一个用户:</p><pre class="kj kk kl km gt np md nq nr aw ns bi"><span id="bcf3" class="nt mr it md b gy nu nv l nw nx">In [1]: from accounts.serializers import UserSerializer</span><span id="f519" class="nt mr it md b gy ny nv l nw nx">In [2]: from django.contrib.auth.models import User</span><span id="41c2" class="nt mr it md b gy ny nv l nw nx">In [3]: user = User.objects.latest('pk')</span><span id="2389" class="nt mr it md b gy ny nv l nw nx">In [4]: serializer = UserSerializer(user)</span><span id="b462" class="nt mr it md b gy ny nv l nw nx">In [5]: serializer.data<br/>Out[5]: {'username': 'akshar', 'email': '<a class="ae lq" href="mailto:akshar@agiliq.com" rel="noopener ugc nofollow" target="_blank">akshar@agiliq.com</a>', 'first_name': '', 'last_name': ''}</span></pre><p id="0dca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设使用这个API的前端或移动应用程序希望序列化表示中的键是<code class="fe ma mb mc md b">user_name</code>而不是<code class="fe ma mb mc md b">username</code>。</p><p id="9402" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以在带有<code class="fe ma mb mc md b">source</code>属性的序列化器上添加一个<code class="fe ma mb mc md b">CharField</code>来实现这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f257" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">确保用<code class="fe ma mb mc md b">Meta.fields</code>中的<code class="fe ma mb mc md b">user_name</code>替换<code class="fe ma mb mc md b">username</code>。重新启动shell并实例化序列化程序。</p><pre class="kj kk kl km gt np md nq nr aw ns bi"><span id="eb17" class="nt mr it md b gy nu nv l nw nx">In [6]: serializer = UserSerializer(user)</span><span id="f9d6" class="nt mr it md b gy ny nv l nw nx">In [7]: serializer.data<br/>Out[7]: {'user_name': 'akshar', 'email': '<a class="ae lq" href="mailto:akshar@agiliq.com" rel="noopener ugc nofollow" target="_blank">akshar@agiliq.com</a>', 'first_name': '', 'last_name': ''}</span></pre><p id="79e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上一个例子中，我们看到了<code class="fe ma mb mc md b">source</code>如何处理<code class="fe ma mb mc md b">User</code>字段。<code class="fe ma mb mc md b">source</code>也可以使用<code class="fe ma mb mc md b">User</code>上的方法。</p><p id="e72b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ma mb mc md b">User</code>有一个方法叫做<code class="fe ma mb mc md b">get_full_name</code>。让我们设置<code class="fe ma mb mc md b">first_name</code>和<code class="fe ma mb mc md b">last_name</code>。</p><pre class="kj kk kl km gt np md nq nr aw ns bi"><span id="f77b" class="nt mr it md b gy nu nv l nw nx">In [8]: user.first_name = 'akshar'</span><span id="8fe0" class="nt mr it md b gy ny nv l nw nx">In [9]: user.last_name = 'raaj'</span><span id="6bf6" class="nt mr it md b gy ny nv l nw nx">In [10]: user.save()</span><span id="1592" class="nt mr it md b gy ny nv l nw nx">In [11]: user.get_full_name()<br/>Out[11]: 'akshar raaj'</span></pre><p id="2e96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们向序列化程序添加一个名为<code class="fe ma mb mc md b">full_name</code>的字段。设置其<code class="fe ma mb mc md b">source</code>使用<code class="fe ma mb mc md b">User.get_full_name</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5eaf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们重启shell并获取用户的序列化表示。</p><pre class="kj kk kl km gt np md nq nr aw ns bi"><span id="e398" class="nt mr it md b gy nu nv l nw nx">In [3]: user = User.objects.latest('pk')</span><span id="b349" class="nt mr it md b gy ny nv l nw nx">In [4]: serializer = UserSerializer(user)</span><span id="469e" class="nt mr it md b gy ny nv l nw nx">In [5]: serializer.data<br/>Out[5]: {'user_name': 'akshar', 'email': '<a class="ae lq" href="mailto:akshar@agiliq.com" rel="noopener ugc nofollow" target="_blank">akshar@agiliq.com</a>', 'first_name': 'akshar', 'last_name': 'raaj', 'full_name': 'akshar raaj'}</span></pre><p id="f943" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意<code class="fe ma mb mc md b">full_name</code>如何给出期望的结果。在引擎盖下，DRF使用<code class="fe ma mb mc md b">get_full_name</code>来填充<code class="fe ma mb mc md b">full_name</code>。</p><p id="7448" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ma mb mc md b">source</code>也可以无缝地处理关系，例如<code class="fe ma mb mc md b">ForeignKey</code>、<code class="fe ma mb mc md b">OneToOneField</code>和<code class="fe ma mb mc md b">ManyToMany</code>。</p><p id="9649" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设有一个与<code class="fe ma mb mc md b">User</code>有<code class="fe ma mb mc md b">OneToOne</code>关系的<code class="fe ma mb mc md b">Profile</code>模型。</p><p id="6375" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">概要文件模型如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7f93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们希望以序列化表示发送街道和城市。我们可以在序列化器上添加一个街道和城市字段，并设置适当的<code class="fe ma mb mc md b">source</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="e046" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们重启shell并序列化用户。</p><pre class="kj kk kl km gt np md nq nr aw ns bi"><span id="482e" class="nt mr it md b gy nu nv l nw nx">In [4]: user = User.objects.latest('pk')</span><span id="7909" class="nt mr it md b gy ny nv l nw nx">In [5]: serializer = UserSerializer(user)</span><span id="1228" class="nt mr it md b gy ny nv l nw nx">In [6]: serializer.data<br/>Out[6]: {'email': '<a class="ae lq" href="mailto:akshar@agiliq.com" rel="noopener ugc nofollow" target="_blank">akshar@agiliq.com</a>', 'first_name': 'akshar', 'last_name': 'raaj', 'street': 'Pennsylvania Avenue', 'city': 'Washington'}</span></pre><p id="c826" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ma mb mc md b">source</code>也可以无缝地处理相关对象的方法，就像它处理对象的方法一样。</p><p id="d06b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们希望获得用户的完整地址，可以使用<code class="fe ma mb mc md b">user.profile.get_full_address()</code>访问。</p><p id="27b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，我们可以将source设置为<code class="fe ma mb mc md b">profile.get_full_address</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="6ce4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再次序列化用户:</p><pre class="kj kk kl km gt np md nq nr aw ns bi"><span id="8636" class="nt mr it md b gy nu nv l nw nx">In [3]: user = User.objects.latest('pk')</span><span id="3fb2" class="nt mr it md b gy ny nv l nw nx">In [4]: serializer = UserSerializer(user)</span><span id="8ecc" class="nt mr it md b gy ny nv l nw nx">In [5]: serializer.data<br/>Out[5]: {'email': '<a class="ae lq" href="mailto:akshar@agiliq.com" rel="noopener ugc nofollow" target="_blank">akshar@agiliq.com</a>', 'first_name': 'akshar', 'last_name': 'raaj', 'full_address': 'Pennsylvania Avenue, Washington'}</span></pre><p id="8ed6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看<code class="fe ma mb mc md b">source</code>和<code class="fe ma mb mc md b">ManyToManyField</code>是如何毫不费力地配合工作的。</p><p id="20fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还希望在序列化表示中获得相关的用户组。让我们先给用户添加几个组。</p><pre class="kj kk kl km gt np md nq nr aw ns bi"><span id="0214" class="nt mr it md b gy nu nv l nw nx">In [12]: g1 = Group.objects.create(name='BBC')</span><span id="842e" class="nt mr it md b gy ny nv l nw nx">In [13]: g2 = Group.objects.create(name='Sony')</span><span id="a7b7" class="nt mr it md b gy ny nv l nw nx">In [15]: user.groups.add(*[g1, g2])</span></pre><p id="c0ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们想要与用户相关联的每个组的<code class="fe ma mb mc md b">id</code>和<code class="fe ma mb mc md b">name</code>。</p><p id="17e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要编写一个<code class="fe ma mb mc md b">GroupSerializer</code>来序列化一个组实例。</p><p id="b8ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="378e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">向序列化数据添加组的一个简单方法是定义一个<code class="fe ma mb mc md b">SerializerMethodField</code>并在方法中添加<code class="fe ma mb mc md b">user.groups.all()</code>。</p><p id="e7f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一种DRFish方法是在序列化器上添加一个<code class="fe ma mb mc md b">all_groups</code>字段，并将其设置为<code class="fe ma mb mc md b">GroupSerializer</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="30b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们序列化一个用户，并验证相关组的信息是否存在于序列化数据中。</p><pre class="kj kk kl km gt np md nq nr aw ns bi"><span id="119f" class="nt mr it md b gy nu nv l nw nx">In [1]: from accounts.serializers import UserSerializer</span><span id="e0a2" class="nt mr it md b gy ny nv l nw nx">In [2]: from django.contrib.auth.models import User</span><span id="fe54" class="nt mr it md b gy ny nv l nw nx">In [3]: user = User.objects.latest('pk')</span><span id="ece2" class="nt mr it md b gy ny nv l nw nx">In [5]: serializer = UserSerializer(user)</span><span id="727e" class="nt mr it md b gy ny nv l nw nx">In [6]: serializer.data<br/>Out[6]: {'email': '<a class="ae lq" href="mailto:akshar@agiliq.com" rel="noopener ugc nofollow" target="_blank">akshar@agiliq.com</a>', 'first_name': 'akshar', 'last_name': 'raaj', 'groups': [OrderedDict([('id', 2), ('name', 'BBC')]), OrderedDict([('id', 3), ('name', 'Sony')])]}</span></pre><p id="cd0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">DRF很聪明地调用了<code class="fe ma mb mc md b">user.groups.all()</code>，尽管我们刚刚设置了<code class="fe ma mb mc md b">source=groups</code>。DRF推断出<code class="fe ma mb mc md b">groups</code>是一个<code class="fe ma mb mc md b">ManyRelatedManager</code>，因此调用管理器上的<code class="fe ma mb mc md b">.all()</code>来获取所有相关的组。</p><p id="884b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们不想在<code class="fe ma mb mc md b">POST</code>通话期间提供群组信息，我们必须在<code class="fe ma mb mc md b">GroupSerializer</code>上添加关键字参数<code class="fe ma mb mc md b">read_only=True</code>。</p><p id="863d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设有一个型号叫<code class="fe ma mb mc md b">Article</code>，<code class="fe ma mb mc md b">Article</code>有一个<code class="fe ma mb mc md b">ForeignKey</code>到<code class="fe ma mb mc md b">User</code>。我们可以通过以下方式在序列化表示中添加用户的文章:</p><pre class="kj kk kl km gt np md nq nr aw ns bi"><span id="76a0" class="nt mr it md b gy nu nv l nw nx">articles = ArticleSerializer(source='article_set', many=True)</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3c3e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">如何使用SerializerMethodField</h1><p id="455f" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">在特定字段的序列化过程中，有时需要运行一些自定义代码。</p><p id="c3e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一些例子可能是:</p><ul class=""><li id="8b9e" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">在序列化期间将<code class="fe ma mb mc md b">first_name</code>转换为titlecase。</li><li id="7038" class="lr ls it kw b kx me la mf ld mg lh mh ll mi lp lw lx ly lz bi translated">将<code class="fe ma mb mc md b">full_name</code>转换成大写。</li><li id="71de" class="lr ls it kw b kx me la mf ld mg lh mh ll mi lp lw lx ly lz bi translated">如果没有组与用户相关联，则将<code class="fe ma mb mc md b">groups</code>设置为<code class="fe ma mb mc md b">None</code>而不是空列表。</li></ul><p id="db40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们考虑第一种情况。我们想在序列化期间将用户的<code class="fe ma mb mc md b">first_name</code>改为标题大小写。</p><p id="c84f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">直到现在，我们都不想为<code class="fe ma mb mc md b">first_name</code>运行任何自定义代码，所以在<code class="fe ma mb mc md b">Meta.fields</code>中有<code class="fe ma mb mc md b">first_name</code>就足够了。我们现在想运行一些自定义代码，所以我们必须显式地将<code class="fe ma mb mc md b">first_name</code>设置为<code class="fe ma mb mc md b">SerializerMethodField</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="582f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当一个字段被设置为<code class="fe ma mb mc md b">SerializerMethodField</code>时，DRF在计算该字段的值时调用一个名为<code class="fe ma mb mc md b">get_&lt;field_name&gt;</code>的方法。这里的<code class="fe ma mb mc md b">obj</code>指的是一个<code class="fe ma mb mc md b">user</code>实例。</p><p id="24ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">重启shell并序列化用户。</p><pre class="kj kk kl km gt np md nq nr aw ns bi"><span id="1efb" class="nt mr it md b gy nu nv l nw nx">In [4]: user = User.objects.latest('pk')</span><span id="2c0b" class="nt mr it md b gy ny nv l nw nx">In [5]: serializer = UserSerializer(user)</span><span id="a57e" class="nt mr it md b gy ny nv l nw nx">In [6]: serializer.data<br/>    Out[6]: {'email': '<a class="ae lq" href="mailto:akshar@agiliq.com" rel="noopener ugc nofollow" target="_blank">akshar@agiliq.com</a>', 'first_name': 'Akshar', 'last_name': 'raaj'}</span></pre><p id="43cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意<code class="fe ma mb mc md b">first_name</code>现在是如何序列化为标题案例的。</p><p id="c7c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们想将<code class="fe ma mb mc md b">full_name</code>改为大写，我们必须将序列化程序改为如下形式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="fd4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们再次序列化用户:</p><pre class="kj kk kl km gt np md nq nr aw ns bi"><span id="419f" class="nt mr it md b gy nu nv l nw nx">In [3]: user = User.objects.latest('pk')</span><span id="ed54" class="nt mr it md b gy ny nv l nw nx">In [4]: serializer = UserSerializer(user)</span><span id="c574" class="nt mr it md b gy ny nv l nw nx">In [5]: serializer.data<br/>Out[5]: {'email': '<a class="ae lq" href="mailto:akshar@agiliq.com" rel="noopener ugc nofollow" target="_blank">akshar@agiliq.com</a>', 'first_name': 'akshar', 'last_name': 'raaj', 'full_name': 'AKSHAR RAAJ'}</span></pre><p id="d63f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们想将<code class="fe ma mb mc md b">groups</code>作为<code class="fe ma mb mc md b">None</code>发送，而不是一个空列表，我们的序列化程序应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6c8b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">如何使用to_representation</h1><p id="fac2" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">序列化器提供了一个挂钩点，称为<code class="fe ma mb mc md b">to_representation</code>。</p><p id="e081" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们想在序列化数据中添加一个名为<code class="fe ma mb mc md b">admin</code>的键，只有当用户是超级用户时。对于非超级用户，键<code class="fe ma mb mc md b">admin</code>不应该出现在序列化数据中。</p><p id="042f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的序列化程序应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9950" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ma mb mc md b">instance</code>指用户实例序列化。</p><p id="31c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们序列化一个超级用户。</p><pre class="kj kk kl km gt np md nq nr aw ns bi"><span id="bde0" class="nt mr it md b gy nu nv l nw nx">In [2]: user = User.objects.latest('pk')</span><span id="cef7" class="nt mr it md b gy ny nv l nw nx">In [5]: serializer = UserSerializer(user)</span><span id="e4f0" class="nt mr it md b gy ny nv l nw nx">In [6]: serializer.data<br/>Out[6]: {'email': '<a class="ae lq" href="mailto:akshar@agiliq.com" rel="noopener ugc nofollow" target="_blank">akshar@agiliq.com</a>', 'first_name': 'akshar', 'last_name': 'raaj', 'admin': True}</span></pre><p id="a793" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们将用户标记为非超级用户并再次序列化。</p><pre class="kj kk kl km gt np md nq nr aw ns bi"><span id="41d4" class="nt mr it md b gy nu nv l nw nx">In [7]: user.is_superuser = False</span><span id="ef9f" class="nt mr it md b gy ny nv l nw nx">In [8]: user.save()</span><span id="2b84" class="nt mr it md b gy ny nv l nw nx">In [9]: serializer = UserSerializer(user)</span><span id="23e8" class="nt mr it md b gy ny nv l nw nx">In [10]: serializer.data<br/>Out[10]: {'email': '<a class="ae lq" href="mailto:akshar@agiliq.com" rel="noopener ugc nofollow" target="_blank">akshar@agiliq.com</a>', 'first_name': 'akshar', 'last_name': 'raaj'}</span></pre><p id="2729" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，非超级用户的序列化数据中缺少<code class="fe ma mb mc md b">admin</code>键。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="009f" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="5c7a" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">这篇文章讨论了序列化器的读取行为。如果您想了解如何在写操作期间有效地使用序列化器，<a class="ae lq" href="https://medium.com/@raaj.akshar/how-to-effectively-use-django-rest-framework-serializers-during-write-operations-dd73b62c26b5" rel="noopener">请参阅本文</a>。</p><p id="60a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<a class="ae lq" href="https://twitter.com/_akshar" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上与我联系，我<a class="ae lq" href="https://twitter.com/_akshar" rel="noopener ugc nofollow" target="_blank">在Twitter</a>上发布信息丰富且有价值的编程文章和建议。</p></div></div>    
</body>
</html>