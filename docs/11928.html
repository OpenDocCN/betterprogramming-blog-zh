<html>
<head>
<title>The Bridge Design Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的桥设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-bridge-design-pattern-in-javascript-5427dd1c8660?source=collection_archive---------11-----------------------#2022-04-27">https://betterprogramming.pub/the-bridge-design-pattern-in-javascript-5427dd1c8660?source=collection_archive---------11-----------------------#2022-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="03be" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用桥梁</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/081f240dca9672450913aed5467ed0b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kg6HaVIBmtmqYmh6v8Y-AA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源于<a class="ae ky" href="https://jsmanifest.com" rel="noopener ugc nofollow" target="_blank"> jsmanifest </a></p></figure><p id="501d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论JavaScript中的桥设计模式。这是在软件应用中产生重大影响的最常用模式之一。这是一种在其实现中容易促进关注点分离的模式，并且它是<em class="lv">可扩展的</em>。</p><p id="9097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图描述了这种模式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/61aa9ac269beb9016c3ddc63812cdd14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bOEHaliRT_v3bNGL.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源<a class="ae ky" href="https://jsmanifest.com" rel="noopener ugc nofollow" target="_blank"> jsmanifest </a></p></figure><p id="1a3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常有两个主要的<em class="lv">参与者</em>(或者<em class="lv">实体</em>，无论你想怎么称呼它都可以)参与到桥接模式中。</p><p id="7caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个也是最上面的部分是抽象层。这可以简单地实现为一个类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="4f62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在桥接模式中，抽象层声明基本接口方法和/或属性。然而，他们不关心实现细节，因为那不是他们的工作。为了能够获得这种模式的优势，必须保持这种方式，以便我们的代码不会变得紧密耦合，并保持可管理性。</p><p id="22bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">抽象层代替<em class="lv">打开桥</em>，然后导致模式的第二个主要部分:<em class="lv">实现</em>层(在实践中通常被实现为<em class="lv">类</em>)被附加到这些桥上，由<em class="lv">客户端</em>(或者<em class="lv">你</em>发号施令。“附加”一词是我的人类可读术语形式，用来理解代码术语，即<em class="lv">引用</em>或<em class="lv">指针</em>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/7f2812d590427a32e6c04cc5094be98b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CgKpyrmZfaXWk4fZ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源<a class="ae ky" href="https://jsmanifest.com" rel="noopener ugc nofollow" target="_blank"> jsmanifest </a></p></figure><p id="e520" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“桥”可以明显地出现在如下代码中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="4fc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你访问过像<code class="fe ma mb mc md b">https://dev.to</code>或<code class="fe ma mb mc md b">https://medium.com</code>这样的网站，它们有一个主题功能，你可以在你的个人资料中访问。通常有一个<em class="lv">拨动</em>主题按钮。主题是抽象层。在明暗之间切换的实际实现很可能位于实现层内抽象层位置的之外的<em class="lv">。</em></p><h1 id="b41d" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">应该在何时何地使用桥接模式？</h1><p id="24e5" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">现实世界中的一些实现是以一种方式编码的，其中“桥效应”在<em class="lv">运行时间</em>期间“活跃”。当您需要两个对象之间的这种类型的耦合/绑定时，这就是您可以利用桥接模式的时候。</p><p id="65b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个很好的例子就是<a class="ae ky" href="https://github.com/twilio/twilio-video.js" rel="noopener ugc nofollow" target="_blank"> twilio-video </a>，这是一个JavaScript库，可以让你将实时语音和视频添加到你的web应用程序中(比如Zoom)。在这个库中，<a class="ae ky" href="https://github.com/twilio/twilio-video.js/blob/master/lib/room.js" rel="noopener ugc nofollow" target="_blank">房间</a>总是实例化为一个空房间。这个类保存了一个指向<code class="fe ma mb mc md b">LocalParticipant</code>(当你加入一个视频聊天室<em class="lv">时，你</em>就是你屏幕上的<code class="fe ma mb mc md b">LocalParticipant</code>)的指针，但是<code class="fe ma mb mc md b">LocalParticipant</code>并没有真正运行，也没有被实例化<em class="lv">直到它连接并完成了房间的订阅，这只有在运行代码时才有可能。</em></p><p id="dad4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你浏览他们的代码，你会在很多地方发现桥梁。没有<code class="fe ma mb mc md b">Room</code>就无法创建视频聊天会话，房间直到至少有两个<code class="fe ma mb mc md b">Participant</code>才会开始。但是<code class="fe ma mb mc md b">Participant</code>直到他们开始本地音频/视频<code class="fe ma mb mc md b">MediaTrack</code>才能开始流式传输。这些类在自上而下的层次结构中协同工作。当您开始拥有多个耦合在一起的类时，这也是考虑桥接模式的好时机。</p><p id="22eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">桥接模式有用的另一个场景是当您想要与多个对象共享某个对象的实现时。</p><p id="2daa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack" rel="noopener ugc nofollow" target="_blank"> MediaStreamTrack </a>类代表一个流的媒体轨道。从中“搭桥”的两个最常见的实现是<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack/kind" rel="noopener ugc nofollow" target="_blank">音频和视频轨道</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/4c42fb7cd832dbaa817cd418f5105667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hLWktKmd1ORiZxid.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源<a class="ae ky" href="https://jsmanifest.com" rel="noopener ugc nofollow" target="_blank"> jsmanifest </a></p></figure><p id="3db4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，实现细节通常隐藏在派生类中。</p><h1 id="43a0" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">履行</h1><p id="e4aa" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">让我们实现我们自己的桥模式的变体，以便更好地理解问题和它带来的解决方案。</p><p id="3956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从一个通用的<code class="fe ma mb mc md b">Thing</code>类开始，它可以表示任何东西:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="93ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建一个扩展<code class="fe ma mb mc md b">Thing</code>的高级抽象类。我们可以称之为<code class="fe ma mb mc md b">LivingThing</code>，并将定义一个名为<code class="fe ma mb mc md b">eat</code>的方法。现实世界中的所有生物都生来就具有为了生存而进食的能力。我们可以在代码中模仿这一点。这将停留在高级抽象层:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="363d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，我们打开了通往<code class="fe ma mb mc md b">Mouth</code>类的桥梁。接下来让我们定义这个类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="cfdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在要考虑的事情(没有双关语)是我们的<code class="fe ma mb mc md b">Mouth</code>将是一个实现层，我们在其中编写嘴和食物之间的通信逻辑。</p><p id="7cae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个实现完全基于<code class="fe ma mb mc md b">Mouth</code>。<code class="fe ma mb mc md b">LivingThing</code>不关心这些实现细节，而是将这个角色完全委托给它的实现类，在我们的例子中是<code class="fe ma mb mc md b">Mouth</code>。</p><p id="91ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们暂停一下，讨论一下这一部分。如果<code class="fe ma mb mc md b">LivingThing</code>没有参与它的任何实现，这对我们来说实际上是一个有用的概念。如果我们可以制作其他只需要为实现提供接口的<code class="fe ma mb mc md b">LivingThing</code>,那么我们就可以为其他场景制作更广泛的类。</p><p id="43f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个MMORPG游戏中，我们可以使用<code class="fe ma mb mc md b">LivingThing</code>并制作更多的它们，它们都自动继承 a <em class="lv">指针</em> a <code class="fe ma mb mc md b">mouth</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="e2fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">众所周知，桥模式使开发人员能够构建跨平台的应用程序。我们已经可以在我们的例子中看到这种能力。我们可以通过在新的代码库上重用<code class="fe ma mb mc md b">LivingThing</code>来构建同样的MMORPG游戏。我们只需要重新实现像<code class="fe ma mb mc md b">Mouth</code>这样的实现层，就可以创建到不同平台的绑定。</p><p id="f094" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不局限于游戏。由于我们的<code class="fe ma mb mc md b">LivingThing</code>是通用的，对任何<em class="lv">移动</em>的东西都有意义，所以我们可以用它来创建完全不同的东西，比如作为<a class="ae ky" href="https://www.oracle.com/internet-of-things/what-is-iot/" rel="noopener ugc nofollow" target="_blank">物联网</a>设备程序的机器人，并用<code class="fe ma mb mc md b">LivingThing</code>模拟进食行为。</p><p id="f1bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的假装MMORPG游戏，桥可以用来创造更多的桥。MMORPG通常有一些个人资料页面，用户可以在那里编辑他们的设置。</p><p id="0467" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe ma mb mc md b">Profile</code>本身可以利用桥设计模式来定义一套片段，使其功能类似于profile API:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="7c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您读过我的一些其他文章，这可能与适配器或策略模式类似。</p><p id="daf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，解决不同问题的差异是明显的:</p><p id="a4da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在适配器模式中，它解决的问题从代码开始(或在运行时之前的代码),我们首先构建适配器，然后立即开始其余的部分:</p><p id="f95a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/ctimmerm/axios-mock-adapter" rel="noopener ugc nofollow" target="_blank"> axios模拟适配器</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="72f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与我们之前的片段比较，你会立刻感觉到不同。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="1753" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本帖到此结束！我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>