<html>
<head>
<title>View Layout and Presentation in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中查看布局和演示</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/view-layout-and-presentation-in-swiftui-705b7d81f03?source=collection_archive---------6-----------------------#2020-08-26">https://betterprogramming.pub/view-layout-and-presentation-in-swiftui-705b7d81f03?source=collection_archive---------6-----------------------#2020-08-26</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="c05d" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph">您期待已久的完整SwiftUI 2文档</h2><div class=""/><div class=""><h2 id="0d4d" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">针对iOS 14、iPadOS 14、WatchOS 7和MacOS Big Sur进行了更新</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/abf24758a6298ed331f78784ecffe1b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjUjuYsu7aqvIDTKxBAP3w.jpeg"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">图片由<a class="ae li" href="https://pixabay.com/users/PIRO4D-2707530/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4251894" rel="noopener ugc nofollow" target="_blank"> PIRO4D </a>来自<a class="ae li" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4251894" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="352c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">2020年初，我写了一篇名为“<a class="ae li" href="https://medium.com/better-programming/the-complete-swiftui-documentation-youve-been-waiting-for-fdfe7241add9" rel="noopener">您一直在等待的完整SwiftUI文档</a>”的中篇文章。</p><p id="145c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是我分享我在试图填补苹果公司提供的不充分文档所留下的空白时所学到的东西的方式。</p><p id="5898" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">虽然我的文章似乎帮助了很多人，但我也晚了八个月才写完。</p><p id="ea7c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在苹果2020年开发者大会已经结束，SwiftUI被赋予了一些新的功能，所以希望这次更新能让我的文档比以往任何时候都更有帮助。这将作为一个系列发布，每篇文章一章。这些章节的名称与苹果SwiftUI文档中的章节名称相对应。它们可以按任何顺序阅读，所以我没有给它们编号。</p><p id="e63e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">正如我所承诺的，当前章节没有“视图和控件”那么长，比我的原始文档还要长！</p><ul class=""><li id="3638" class="mf mg iu ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated"><strong class="ll je">查看布局和演示文稿</strong></li><li id="6214" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><a class="ae li" href="https://medium.com/better-programming/swiftui-views-and-controls-the-swift-2-documentation-youve-been-waiting-for-dfa32cba24f3" rel="noopener">视图和控件</a></li><li id="420c" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">应用程序结构和行为</li><li id="dcd6" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">绘画和动画</li><li id="5800" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">框架集成</li><li id="3591" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">状态和数据流</li><li id="4581" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">手势</li><li id="933e" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">试映</li></ul><p id="42af" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果您发现任何错误或您认为我应该更详细介绍的主题，我鼓励您在下面的回复中与我联系。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><pre class="kt ku kv kw gu na nb nc nd aw ne bi"><span id="6117" class="nf ng iu nb b gz nh ni l nj nk"><a class="ae li" href="#a04a" rel="noopener ugc nofollow">LazyHStack and LazyVStack (New in 2.0)</a><br/><a class="ae li" href="#b5f7" rel="noopener ugc nofollow">LazyVGrid (New in 2.0)</a><br/><a class="ae li" href="#d594" rel="noopener ugc nofollow">LazyHGrid (New in 2.0)</a><br/><a class="ae li" href="#9cac" rel="noopener ugc nofollow">GridItem (New in 2.0)</a><br/><a class="ae li" href="#51f2" rel="noopener ugc nofollow">List (Updated in 2.0)</a><br/><a class="ae li" href="#c1f5" rel="noopener ugc nofollow">ForEach &amp; DynamicViewContent (Updated in 2.0)</a><br/><a class="ae li" href="#6e57" rel="noopener ugc nofollow">ScrollViewReader (New in 2.0)</a><br/><a class="ae li" href="#1ae9" rel="noopener ugc nofollow">ScrollViewProxy (New in 2.0)</a><br/><a class="ae li" href="#7373" rel="noopener ugc nofollow">Group (Updated in 2.0)</a><br/><a class="ae li" href="#6348" rel="noopener ugc nofollow">Groupbox (Updated), OutlineGroup (NEW), &amp; DisclosureGroup (NEW)</a><br/><a class="ae li" href="#3320" rel="noopener ugc nofollow">NavigationView (Updated in 2.0)</a><br/><a class="ae li" href="#5eb5" rel="noopener ugc nofollow">TabView (Updated in 2.0)</a></span></pre></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="a04a" class="nl ng iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">lazy stack和lazyv stack(2.0中的新功能)</h1><p id="1931" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated"><a class="ae li" href="#6117" rel="noopener ugc nofollow"> <em class="oh">回目录↑ </em> </a></p><p id="f21b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在SwiftUI的第一次迭代中，有一点非常模糊，那就是<code class="fe oi oj ok nb b">List</code>的行是否排队。</p><p id="5999" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当您滚动<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/uikit/uitableview" rel="noopener ugc nofollow" target="_blank">UITableView</a></code>时，离开屏幕底部或顶部的单元格被添加到一个队列中，这意味着表格中的每个单元格不必一次存储在内存中。当一个单元格将要被滚动到视图中时，一个类似于<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/uikit/uitableview/1614891-dequeuereusablecell" rel="noopener ugc nofollow" target="_blank">func dequeueReusableCell(withIdentifier: String) -&gt; UITableViewCell?</a></code>的方法被调用。信元被认为是可重用的，因为它们可以被销毁和重新创建，将它们从队列中移除被称为<em class="oh">出列</em>。</p><p id="b45e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">总之，事实证明<code class="fe oi oj ok nb b"><a class="ae li" href="https://stackoverflow.com/a/56656890" rel="noopener ugc nofollow" target="_blank">List</a></code> <a class="ae li" href="https://stackoverflow.com/a/56656890" rel="noopener ugc nofollow" target="_blank">确实重用了细胞</a>。但是如果你想用一个<code class="fe oi oj ok nb b">ScrollView</code>来代替，当它们离开屏幕的顶部或底部时，你会立刻回到所有的加载，而不是排队。你可能不介意使用<code class="fe oi oj ok nb b">List</code>而不是垂直的<code class="fe oi oj ok nb b">ScrollView</code>，但是如果你想水平滚动会发生什么呢？</p><p id="b30f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你尝试一下，你会注意到<code class="fe oi oj ok nb b">List</code>没有水平滚动的选项。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ol om l"/></div></figure><p id="113f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在我的例子中，我们有一个名为<code class="fe oi oj ok nb b">WhatJustHappenedView</code>的函数，它打印最近的排队事件。如果栈不是偷懒的话，里面的每个<code class="fe oi oj ok nb b">Text</code>细胞一开始都会出现一次，排队的时候就再也不会消失了。</p><p id="49e5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">相反，我们看到的事件证明我们的内存是动态分配的，而不是一次性分配的。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="b5f7" class="nl ng iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">lazy vgrid(2.0中的新功能)</h1><p id="3eb2" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated"><a class="ae li" href="#6117" rel="noopener ugc nofollow"> <em class="oh">回目录↑ </em> </a></p><p id="ace8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">您可以将上述<code class="fe oi oj ok nb b">LazyVStack</code>和<code class="fe oi oj ok nb b">LazyHStack</code>部分的相同逻辑应用于网格。如果我们想在SwiftUI中以行和列的形式显示视图，该怎么办？当然，在最初的版本中，除了手动编写自己的逻辑之外，没有别的办法。<code class="fe oi oj ok nb b">LazyVGrid</code>与UIKit的<code class="fe oi oj ok nb b">UICollectionView</code>在视觉上有很多相似之处，但实现起来要容易得多。您可以使用一组<code class="fe oi oj ok nb b">GridItem</code>对象构建这些网格，这些对象可以作为布局中的行。</p><p id="4531" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">为了更容易地看到改变网格属性的效果，我创建了一种方便的方法来布置六个步进器，称为<a class="ae li" href="https://gist.github.com/sturdysturge/eed04e007cef3222729663d9eed0d7d6" rel="noopener ugc nofollow" target="_blank">步进器视图</a>。我将提供使用<code class="fe oi oj ok nb b">.fixed</code>、<code class="fe oi oj ok nb b">.adaptive</code>和<code class="fe oi oj ok nb b">.relative</code>调整类型进行调整的示例。这些都是枚举<code class="fe oi oj ok nb b">GridItem.Size</code>的情况，而<code class="fe oi oj ok nb b">.fixed</code>只需要一个<code class="fe oi oj ok nb b">CGFloat</code>值，其他两个需要最小和最大值，以便系统从中选择一个值。</p><p id="8273" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">首先我们有<code class="fe oi oj ok nb b">.fixed</code>，它给<code class="fe oi oj ok nb b">LazyVGrid</code>的列一个明确的宽度:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ol om l"/></div></figure><p id="70db" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在我们有了<code class="fe oi oj ok nb b">.flexible</code>，它允许列增长到它们可用的最大宽度。这类似于在任何其他视图上使用<code class="fe oi oj ok nb b">.frame(maxWidth: .infinity)</code>修改器。尽管列可以根据周围列的要求而增长或收缩，但它们不能改变一行中的列数。这意味着我们最终仍会得到适当数量的行，如果您滚动到底部，会看到底部的行与前面所有的行具有相同的数量。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ol om l"/></div></figure><p id="496e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">GridItem.Size.adaptive</code>在一个简单的方面不同于<code class="fe oi oj ok nb b">.flexible</code>。虽然这些单元格仍有最小和最大宽度，但它们不会阻止下面一行的单元格向上移动以占据可用空间。当然，这是假设可用空间大于单元可以占据的最小宽度。当滚动到底部时，可以最清楚地观察到这种差异，因为很容易出现最后一行比前面几行包含的单元格少的情况。</p><p id="9ea6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是因为我们使用<code class="fe oi oj ok nb b">columns * rows</code>计算的单元格数量不再是单元格的准确表示，因为每行的项目比之前预期的要多。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ol om l"/></div></figure></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="d594" class="nl ng iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">lazy grid(2.0中的新功能)</h1><p id="ba3f" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated"><a class="ae li" href="#6117" rel="noopener ugc nofollow"> <em class="oh">回目录↑ </em> </a></p><p id="6771" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">像上面的<code class="fe oi oj ok nb b">LazyVGrid</code>一样，这里的例子需要控件，这样你可以在后面的例子中使用它们。所有的例子都使用了六种不同的步进器，所以我提供了<a class="ae li" href="https://gist.github.com/sturdysturge/eed04e007cef3222729663d9eed0d7d6" rel="noopener ugc nofollow" target="_blank">步进器视图</a>，它允许你为每个例子布置它们。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ol om l"/></div></figure><p id="d543" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在我们有了<code class="fe oi oj ok nb b">.flexible</code>，它允许行增长到它们可用的最大高度。这类似于在任何其他视图上使用<code class="fe oi oj ok nb b">.frame(maxHeight: .infinity)</code>修改器。尽管列可以根据周围列的要求而增长或收缩，但它们不能改变列中的行数。这意味着我们最终仍会得到适当数量的列，如果您向右滚动，就会看到最后一列与前面所有列的数量相同。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ol om l"/></div></figure><p id="faef" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">GridItem.Size.adaptive</code>在一个简单的方面不同于<code class="fe oi oj ok nb b">.flexible</code>。虽然这些单元格仍然有最小和最大高度，但它们不会阻止右边列中的单元格向左移动以占据可用空间。当然，这是假设可用空间大于单元格可以占据的最小高度。当向右滚动时，可以最清楚地观察到这里的差异，因为很容易实现最后一列比前面的列具有更少的单元格的情况。</p><p id="9321" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是因为我们使用<code class="fe oi oj ok nb b">columns * rows</code>计算的单元格数量不再是单元格的准确表示，因为每列的项目比之前预期的要多。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ol om l"/></div></figure></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="9cac" class="nl ng iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">grid item(2.0中的新功能)</h1><p id="ced8" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated"><a class="ae li" href="#6117" rel="noopener ugc nofollow"> <em class="oh">回目录↑ </em> </a></p><p id="4399" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在上面的<code class="fe oi oj ok nb b">LazyHGrid</code>和<code class="fe oi oj ok nb b">LazyVGrid</code>中，你可以看到一些很好的<code class="fe oi oj ok nb b">GridItem</code>的例子。</p><p id="5ae6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">必须给定一个尺寸，但是间距和对齐是可选的。</p><p id="9327" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">GridItem.Size</code>枚举有三种情况:</p><ul class=""><li id="c825" class="mf mg iu ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/griditem/size-swift.enum/adaptive(minimum:maximum:)" rel="noopener ugc nofollow" target="_blank">case adaptive(minimum: CGFloat, maximum: CGFloat)</a></code></li><li id="cac1" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/griditem/size-swift.enum/fixed(_:)" rel="noopener ugc nofollow" target="_blank">case fixed(CGFloat)</a></code></li><li id="517b" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/griditem/size-swift.enum/flexible(minimum:maximum:)" rel="noopener ugc nofollow" target="_blank">case flexible(minimum: CGFloat, maximum: CGFloat)</a></code></li></ul><p id="7f6e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">请记住，如果没有给定spacing属性的值，那么如果没有给定足够的空间，您的列(在<code class="fe oi oj ok nb b">LazyVGrid</code>中)或行(在<code class="fe oi oj ok nb b">LazyHGrid</code>中)可能会相互接触。</p><p id="fbe7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">假设给定的尺寸不是<code class="fe oi oj ok nb b">.fixed</code>类型，明确的间距可以让你更好地控制它们如何适应。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="51f2" class="nl ng iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">列表(在2.0中更新)</h1><p id="7dd8" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated"><a class="ae li" href="#6117" rel="noopener ugc nofollow"> <em class="oh">回目录↑ </em> </a></p><p id="f64c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">垂直的<code class="fe oi oj ok nb b">ScrollView</code>只有在屏幕上可见的时候才允许延迟加载内容，在2.0中有一些新的初始化器。</p><ul class=""><li id="3c3f" class="mf mg iu ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/list/init(_:children:selection:rowcontent:)-2pt7r?changes=latest_minor" rel="noopener ugc nofollow" target="_blank">init&lt;Data, RowContent&gt;(Data, children: KeyPath&lt;Data.Element, Data?&gt;, selection: Binding&lt;SelectionValue?&gt;?, rowContent: (Data.Element) -&gt; RowContent)</a></code></li><li id="cb5a" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/list/init(_:children:selection:rowcontent:)-qm74?changes=latest_minor" rel="noopener ugc nofollow" target="_blank">init&lt;Data, RowContent&gt;(Data, children: KeyPath&lt;Data.Element, Data?&gt;, selection: Binding&lt;Set&lt;SelectionValue&gt;&gt;?, rowContent: (Data.Element) -&gt; RowContent)</a></code></li><li id="79db" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/list/init(_:id:children:selection:rowcontent:)-234ke?changes=latest_minor" rel="noopener ugc nofollow" target="_blank">init&lt;Data, ID, RowContent&gt;(Data, id: KeyPath&lt;Data.Element, ID&gt;, children: KeyPath&lt;Data.Element, Data?&gt;, selection: Binding&lt;Set&lt;SelectionValue&gt;&gt;?, rowContent: (Data.Element) -&gt; RowContent)</a></code></li><li id="1876" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/list/init(_:id:children:selection:rowcontent:)-5ynav?changes=latest_minor" rel="noopener ugc nofollow" target="_blank">init&lt;Data, ID, RowContent&gt;(Data, id: KeyPath&lt;Data.Element, ID&gt;, children: KeyPath&lt;Data.Element, Data?&gt;, selection: Binding&lt;SelectionValue?&gt;?, rowContent: (Data.Element) -&gt; RowContent)</a></code></li></ul><p id="e81f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这些初始化器都有一个共同点。SwiftUI推出时都有，但只在tvOS和watchOS上有。</p><p id="61bd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">所有这些初始化程序现在都添加到了iOS、macOS和Mac Catalyst中。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="c1f5" class="nl ng iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">ForEach &amp; DynamicViewContent(在2.0中更新)</h1><p id="0ee5" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated"><a class="ae li" href="#6117" rel="noopener ugc nofollow"> <em class="oh">回目录↑ </em> </a></p><p id="1591" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在本文档的“<a class="ae li" href="https://medium.com/better-programming/swiftui-views-and-controls-the-swift-2-documentation-youve-been-waiting-for-dfa32cba24f3" rel="noopener">视图和控件</a>”一章中，我谈到了新的<code class="fe oi oj ok nb b">UTType</code>结构，它取代了一个相当混乱的方法。我们不能创建表示数据类型的对象，而是不得不求助于传递表示数据类型的字符串数组。</p><p id="cea6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这在<code class="fe oi oj ok nb b">ForEach</code>的初始化器中并不明显，但它符合<code class="fe oi oj ok nb b">DynamicViewContent</code>协议。当泛型<code class="fe oi oj ok nb b">Content</code>符合<code class="fe oi oj ok nb b">View</code>时就会发生这种情况，令人困惑的是<code class="fe oi oj ok nb b">ForEach</code>结构本身并不需要这种情况。每个初始化器都存在于一个扩展中，这个扩展要求<code class="fe oi oj ok nb b">Content</code>符合<code class="fe oi oj ok nb b">View</code>，所以不要认为你可以将<code class="fe oi oj ok nb b">ForEach</code>用于任何其他目的。</p><p id="cfcf" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">DynamicViewContent</code>需要一个<code class="fe oi oj ok nb b">Collection</code>数据，其具体类型由给定的数据推断。你会问，它是做什么的。它提供了像<code class="fe oi oj ok nb b">onDelete</code>这样的方法，当用户删除了<code class="fe oi oj ok nb b">List</code>中的一行时，您可以运行闭包。虽然<code class="fe oi oj ok nb b">onDelete</code>自去年以来没有变化，但<code class="fe oi oj ok nb b">onInsert</code>却发生了变化。当使用<code class="fe oi oj ok nb b">onDrag</code>修改器拖动项目时会出现这种情况，因为<code class="fe oi oj ok nb b">List</code>使用<code class="fe oi oj ok nb b">onInsert</code>而不是更传统的<code class="fe oi oj ok nb b">onDrop</code>修改器。</p><p id="e30e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">关于拖放的更多信息包含在“视图和控件”一章中，所以要指出的主要内容是,<code class="fe oi oj ok nb b">onInsert</code>现在采用了一个<code class="fe oi oj ok nb b">UTType</code>结构，而不是以前表示<code class="fe oi oj ok nb b">UTType</code>的字符串数组。这允许我们指定哪种数据可以拖放到<code class="fe oi oj ok nb b">List</code>中，否则我们不知道是否可以将该数据添加到底层的<code class="fe oi oj ok nb b">Collection</code>中。</p><p id="ed4f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">但这还不是改变的全部。</p><p id="a554" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你查看<code class="fe oi oj ok nb b">ForEach</code>的新初始化器，你可能会注意到一些不同:</p><pre class="kt ku kv kw gu na nb nc nd aw ne bi"><span id="7c2c" class="nf ng iu nb b gz nh ni l nj nk">init(_ data: Data, id: KeyPath&lt;Data.Element, ID&gt;, @ViewBuilder content: @escaping (Data.Element) -&gt; Content)</span></pre><p id="2751" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">像一个<code class="fe oi oj ok nb b">View</code>结构的<code class="fe oi oj ok nb b">body: some View</code>属性一样，初始化器现在接受一个<code class="fe oi oj ok nb b">@ViewBuilder</code>闭包。为什么这很重要？这实际上就像在SwiftUI的第一次迭代中将我们的布局包装在一个<code class="fe oi oj ok nb b">Group</code>中。我们这样做是因为我们希望能够返回一个符合视图协议的具体类型，而在闭包中添加多个值使得这样做变得不可能。</p><p id="aa28" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在你可以在一个<code class="fe oi oj ok nb b">ForEach</code>中添加任何你想要的东西，只要它的大小少于十个视图。</p><p id="fa3e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">很明显，这排除了底层数据，因此，举例来说，您可能有一个包含10个视图的<code class="fe oi oj ok nb b">List</code>行，但是该行是从数组或其他数据结构中获取数据的100行或更多行中的一行。</p><p id="16ee" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">ForEach</code>的强大之处在于能够有效地处理尽可能多的项目，就像它们是你的层次结构中的一个视图一样。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="6e57" class="nl ng iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated"><strong class="ak">ScrollViewReader(2.0中的新功能)</strong></h1><p id="303e" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated"><a class="ae li" href="#6117" rel="noopener ugc nofollow"> <em class="oh">回目录↑ </em> </a></p><p id="c12d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现有的<code class="fe oi oj ok nb b">GeometryReader</code>和新的<code class="fe oi oj ok nb b">ScrollViewReader</code>有一些相似之处。</p><p id="85c6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">它们都是传递单个参数的闭包。</p><p id="8471" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">一个<code class="fe oi oj ok nb b">GeometryReader</code>传递一个<code class="fe oi oj ok nb b">GeometryProxy</code>，它有两个属性:<code class="fe oi oj ok nb b">safeAreaInsets: EdgeInsets</code>和<code class="fe oi oj ok nb b">size: CGSize</code>。这个代理附带了一个方法，该方法将为框架返回一个<code class="fe oi oj ok nb b">CGRect</code>，但是它需要一个坐标空间来计算这个框架。最明显的一个是<code class="fe oi oj ok nb b">.global</code>，因为它给出了一个相对于整个屏幕的帧。但是您可以使用您指定的名称来<a class="ae li" href="https://www.hackingwithswift.com/books/ios-swiftui/understanding-frames-and-coordinates-inside-geometryreader" rel="noopener ugc nofollow" target="_blank">创建自定义的</a> <code class="fe oi oj ok nb b"><a class="ae li" href="https://www.hackingwithswift.com/books/ios-swiftui/understanding-frames-and-coordinates-inside-geometryreader" rel="noopener ugc nofollow" target="_blank">coordinateSpace</a></code> <a class="ae li" href="https://www.hackingwithswift.com/books/ios-swiftui/understanding-frames-and-coordinates-inside-geometryreader" rel="noopener ugc nofollow" target="_blank">，允许您获得相对于层次中另一个视图的帧。</a></p><p id="cd85" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">ScrollViewProxy</code>没有属性，但是它有一个执行动作而不是返回值的方法。当我们为<code class="fe oi oj ok nb b">ScrollView</code>中的视图指定一个<code class="fe oi oj ok nb b">id</code>时，我们可以提供任何<code class="fe oi oj ok nb b">Hashable</code>类型。这样我们就可以告诉Swift我们的类型的哪一部分是唯一的，这样它就可以区分该类型的实例。</p><p id="bd20" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在我的例子中，我只是使用我的<code class="fe oi oj ok nb b">List</code>中每一行的索引作为ID。</p><p id="8107" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">许多提供的Swift类型已经符合Hashable，所以这比自己创建一个Hashable类型更容易。如果你感兴趣的话，这里有<a class="ae li" href="https://www.hackingwithswift.com/example-code/language/how-to-conform-to-the-hashable-protocol" rel="noopener ugc nofollow" target="_blank">如何遵守哈希协议</a>，你会发现这根本不需要太多努力。现在我可以识别我的<code class="fe oi oj ok nb b">List</code>的行了，我提供了一个<code class="fe oi oj ok nb b">TextField</code>可以输入一个数字，还有一个<code class="fe oi oj ok nb b">Button</code>会自动将<code class="fe oi oj ok nb b">ScrollView</code>发送到那个行。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ol om l"/></div></figure><p id="38a3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我使用了一个<code class="fe oi oj ok nb b">NumberFormatter</code>，它使用了一个叫做<code class="fe oi oj ok nb b">spellOut</code>的<code class="fe oi oj ok nb b">numberStyle</code>，这使得我的例子更加难以使用。这需要你将数字拼写成小写单词，在像三十四这样的数字之间加一个连字符，省略像<em class="oh">和</em>这样的单词。玩一玩它，如果你厌倦了，你可以随时把<code class="fe oi oj ok nb b">NumberFormatter</code>换成更明智的。</p><p id="83bb" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">请注意，滚动是动画的，但是在<code class="fe oi oj ok nb b">List</code>的底部有一个按钮，上面写着“返回顶部”不像顶部的<code class="fe oi oj ok nb b">GoToButton</code>将它的<code class="fe oi oj ok nb b">proxy.scrollTo(_:)</code>放在一个<code class="fe oi oj ok nb b">withAnimation</code>块中，这个<code class="fe oi oj ok nb b">Button</code>没有添加一个明确的动画。这是<code class="fe oi oj ok nb b">scrollTo(_:)</code>动作的默认行为，即时滚动，没有任何动画。如果您希望动画显示对滚动位置的任何更改，请记住这一点。</p><p id="d1ad" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">注意我是如何将<code class="fe oi oj ok nb b">ScrollViewProxy</code>作为参数传递给<code class="fe oi oj ok nb b">GoToButton</code>的，这样就可以在视图之间传递改变滚动位置的能力。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="1ae9" class="nl ng iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">ScrollViewProxy(2.0中的新功能)</h1><p id="7b9b" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated"><a class="ae li" href="#6117" rel="noopener ugc nofollow"> <em class="oh">回目录↑ </em> </a></p><p id="fdf0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">参见上面的<code class="fe oi oj ok nb b">ScrollViewReader</code>，它将一个<code class="fe oi oj ok nb b">ScrollViewProxy</code>作为参数传递给它的闭包，就像<code class="fe oi oj ok nb b">GeometryReader</code>传递一个<code class="fe oi oj ok nb b">GeometryProxy</code>一样。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="7373" class="nl ng iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">组(在2.0中更新)</h1><p id="c054" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated"><a class="ae li" href="#6117" rel="noopener ugc nofollow"> <em class="oh">回目录↑ </em> </a></p><p id="1032" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在更多的结构采用了<code class="fe oi oj ok nb b">@ViewBuilder</code>闭包，因此返回一个包含多达10个符合视图的子元素的<code class="fe oi oj ok nb b">TupleView</code>，您可能会认为<code class="fe oi oj ok nb b">Group</code>不再有什么意义。</p><p id="2557" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">毕竟，苹果公司称之为“分组视图内容的启示”在当时几乎没有其他作用。</p><p id="2a42" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">但是现在我们有了新的可能性，因为我们现在也可以对符合这些协议的任何内容进行分组:</p><ul class=""><li id="d857" class="mf mg iu ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/scene" rel="noopener ugc nofollow" target="_blank">Scene</a></code></li><li id="459a" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/scene" rel="noopener ugc nofollow" target="_blank">Widget</a></code></li><li id="c327" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/commands" rel="noopener ugc nofollow" target="_blank">Commands</a></code></li><li id="c60c" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/toolbarcontent" rel="noopener ugc nofollow" target="_blank">ToolbarContent</a></code></li></ul><p id="7d0e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我将在后面的章节“应用程序结构和行为”中更详细地介绍这些内容，但重要的是要知道<code class="fe oi oj ok nb b">Group</code>有新的功能。</p><p id="92fd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">与<code class="fe oi oj ok nb b">@ViewBuilder</code>允许<code class="fe oi oj ok nb b">Group</code>组合多达10个视图类似，<code class="fe oi oj ok nb b">@_WidgetBuilder</code>允许组合多达10个小部件。当macOS有命令显示在屏幕顶部的菜单中时，使用<code class="fe oi oj ok nb b">@CommandBuilder</code>最多可以添加十个命令。</p><p id="dc4f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">构建工具栏？</p><p id="d8cd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你猜对了:<code class="fe oi oj ok nb b">@ToolbarBuilder</code>最多允许十个孩子。</p><p id="95dd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">既然SwiftUI应用程序可以在没有<code class="fe oi oj ok nb b">AppDelegate</code>的情况下创建，我们使用一个符合<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/app" rel="noopener ugc nofollow" target="_blank">App</a></code>协议的结构，这反过来需要一个符合<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/scene" rel="noopener ugc nofollow" target="_blank">Scene</a></code>协议的主体。</p><p id="ca59" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当在一个<code class="fe oi oj ok nb b">Group</code>中提供多个场景时，<code class="fe oi oj ok nb b">@SceneBuilder</code>允许我们添加多达十个孩子。</p><p id="c21c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这与<code class="fe oi oj ok nb b">WindowGroup</code>不同，后者专门提供了视图，这些视图将被给予相同结构但独立的窗口。因为<code class="fe oi oj ok nb b">WindowGroup</code>本身符合<code class="fe oi oj ok nb b">Scene</code>协议，所以它可以位于<code class="fe oi oj ok nb b">App</code>结构主体内部的层次结构的顶端。如果一个<code class="fe oi oj ok nb b">Group</code>只有符合<code class="fe oi oj ok nb b">View</code>协议的子节点，它就不能以同样的方式使用。</p><p id="4d1c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">换句话说，符合<code class="fe oi oj ok nb b">App</code>的结构可以包含:</p><ul class=""><li id="f41e" class="mf mg iu ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated">一个由十个孩子组成的<code class="fe oi oj ok nb b">Group</code></li><li id="ff47" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">一个由多达十个<code class="fe oi oj ok nb b">Scene</code>符合标准的孩子组成的小组</li><li id="a189" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">一个<code class="fe oi oj ok nb b">WindowGroup</code>由多达十个符合组或其他视图的孩子组成</li></ul><p id="0cac" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果这令人困惑，不要担心。在“应用程序结构和行为”一章中会有更详细的介绍。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="6348" class="nl ng iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">Groupbox，OutlineGroup，&amp; DisclosureGroup</h1><p id="f6ef" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated">这三个中，<code class="fe oi oj ok nb b">GroupBox</code>是唯一一个在2.0中不新的。</p><p id="16e9" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当<code class="fe oi oj ok nb b">Groupbox</code>在SwiftUI最初发布的时候是可用的，它只在macOS上可用，主要的变化是它现在是跨平台的。这是用可选标签将内容分组的简单方法。<code class="fe oi oj ok nb b">OutlineGroup</code>提供显示原本隐藏的项目附加信息的能力。<code class="fe oi oj ok nb b">DisclosureGroup</code>有类似的用途，增加了一个<code class="fe oi oj ok nb b">Binding&lt;Bool&gt;</code>，可以控制是否显示附加信息。</p><p id="4a15" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你可以在Anupam Chugh的“<a class="ae li" href="https://medium.com/better-programming/swiftuis-groupbox-outlinegroup-and-disclosuregroup-in-ios-14-cf9fb127cdc0" rel="noopener"> SwiftUI的GroupBox、OutlineGroup和iOS 14 </a>中的DisclosureGroup”中找到这样的例子，以及新的<code class="fe oi oj ok nb b">OutlineGroup</code>和<code class="fe oi oj ok nb b">DisclosureGroup</code>。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="3320" class="nl ng iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">导航视图(在2.0中更新)</h1><p id="9e0e" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated"><a class="ae li" href="#6117" rel="noopener ugc nofollow"> <em class="oh">回目录↑ </em> </a></p><p id="5616" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我以为这在watchOS上已经有了，因为我之前发布了一个watchOS应用程序，可以让你从<code class="fe oi oj ok nb b">List</code>中选择狗的照片。但事实证明，尽管在那个应用程序中使用了一个<code class="fe oi oj ok nb b">NavigationLink</code>，我并没有把它嵌入到一个<code class="fe oi oj ok nb b">NavigationView</code>中。这将为iOS和macOS编译，但由于缺少<code class="fe oi oj ok nb b">NavigationView</code>，它不允许导航。大概是watchOS总是基于堆叠导航的工作方式使得这没有必要，但其他平台并不期望会是这种情况。</p><p id="bbe0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">WatchOS现在有能力使用<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/text/navigationviewstyle(_:)" rel="noopener ugc nofollow" target="_blank">.navigationViewStyle</a></code>，但似乎唯一提供的价值是<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/stacknavigationviewstyle" rel="noopener ugc nofollow" target="_blank">StackNavigationViewStyle</a></code>。</p><p id="db4b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">任何平台上唯一的另一个选项是<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/doublecolumnnavigationviewstyle" rel="noopener ugc nofollow" target="_blank">DoubleColumnNavigationViewStyle</a></code>，你可以打赌这不会很快出现在WatchOS上！</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="5eb5" class="nl ng iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated"><strong class="ak"> TabView(在2.0中更新)</strong></h1><p id="37a3" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated"><a class="ae li" href="#6117" rel="noopener ugc nofollow"> <em class="oh">回目录↑ </em> </a></p><p id="c282" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我在“<a class="ae li" href="https://medium.com/better-programming/swiftui-views-and-controls-the-swift-2-documentation-youve-been-waiting-for-dfa32cba24f3" rel="noopener">视图和控件</a>”一章中浏览新的标准视图修饰符时已经提到了这一点。那是在我讨论<code class="fe oi oj ok nb b">.tabItem</code>修改器的时候，修改的方式和<code class="fe oi oj ok nb b">TabView</code>一样。</p><p id="b0c1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">为了重述我当时所说的，我将在顶部添加了<code class="fe oi oj ok nb b">@available</code>属性的苹果的例子。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ol om l"/></div></figure><p id="ebcd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">注意到什么了吗？</p><p id="b751" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">对于watchOS来说，<code class="fe oi oj ok nb b">TabView</code>以及允许您在标签栏上创建代表该页面的图标的修饰符<code class="fe oi oj ok nb b">.tabItem</code>都是新的。虽然它去年在Mac、iOS、iPadOS和tvOS上可用，但它今年才刚刚出现在手表上。你可能会问，它可能采取什么形式？它类似于UIKit的<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/uikit/uipageviewcontroller" rel="noopener ugc nofollow" target="_blank">UIPageViewController</a></code>,每一页都要求你从一页水平滑动到另一页。虽然<code class="fe oi oj ok nb b">.tabItem</code>修饰符存在，但是苹果示例中的<code class="fe oi oj ok nb b">Text</code>和<code class="fe oi oj ok nb b">Image</code>都是不可见的。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj on"><img src="../Images/b3658dd3882110ed63a0d4ef45eb5d3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/0*qsQPxX0lkNHVeL-3.gif"/></div></figure><p id="5279" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">相反，我们得到的是点，这与<code class="fe oi oj ok nb b">UIPageViewController</code>利用<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/uikit/uipagecontrol" rel="noopener ugc nofollow" target="_blank">UIPageControl</a></code>的方式非常相似，苹果将其描述为“一系列水平的点，每个点对应于应用程序文档或其他数据模型实体中的一个页面。”</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="027a" class="nl ng iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">后续步骤</h1><p id="a7f4" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated">在我写这篇文章的时候，SwiftUI才一岁，而且已经有了大量的资源。如果没有以下网站，我的写作是不可能的:</p><ul class=""><li id="b58f" class="mf mg iu ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated"><a class="ae li" href="https://lostmoa.com/blog" rel="noopener ugc nofollow" target="_blank"> LOSTMOA博客</a></li><li id="af30" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><a class="ae li" href="https://www.hackingwithswift.com/" rel="noopener ugc nofollow" target="_blank">利用Swift进行黑客攻击</a></li><li id="27f1" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><a class="ae li" href="https://swiftui-lab.com/" rel="noopener ugc nofollow" target="_blank"> Swift UI实验室</a></li><li id="1eec" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><a class="ae li" href="https://swiftwithmajid.com/" rel="noopener ugc nofollow" target="_blank">带Majid的Swift】</a></li><li id="3e6c" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><a class="ae li" href="https://wwdcbysundell.com/" rel="noopener ugc nofollow" target="_blank"> WWDC by Sundell </a></li><li id="6de0" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><a class="ae li" href="https://www.swiftbysundell.com/" rel="noopener ugc nofollow" target="_blank">斯威夫特by Sundell </a></li></ul><p id="b7e6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你有很棒的资源可以与社区分享，请告诉我，我会很乐意把它添加到这个列表中。</p><p id="10e2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">正如我在文章开头所说的，如果你对某个主题有更详细的要求，或者如果你认为我犯了一个错误，请在下面的回复中告诉我。</p><p id="1aba" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">感谢阅读！</p></div></div>    
</body>
</html>