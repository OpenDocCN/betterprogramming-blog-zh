<html>
<head>
<title>12 Vue.js Best Practices for Pro Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">12面向专业开发人员的Vue.js最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/12-vuejs-best-practices-for-pro-developers-28d1f629018c?source=collection_archive---------1-----------------------#2020-01-12">https://betterprogramming.pub/12-vuejs-best-practices-for-pro-developers-28d1f629018c?source=collection_archive---------1-----------------------#2020-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fae7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">改进您的Vue游戏</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/34f722110ba4b01975a00cb7dada7956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-yJeMP9UUR3Odkxn.jpg"/></div></div></figure><p id="778b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://learnvue.co/2019/12/what-you-need-to-know-about-vue3-in-2020/" rel="noopener ugc nofollow" target="_blank">随着VueJS继续变得越来越普遍</a>，出现了一些最佳实践并成为标准。</p><p id="b1bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这篇文章，我从一些很棒的资源中收集了一些技巧。</p><p id="2542" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望这些最佳实践能帮助你写出更好的Vue.js代码。这不仅会让你所有的开发伙伴都喜欢你，而且你肯定会感谢自己让你的生活变得更轻松。</p><p id="f501" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好了，介绍够了。让我们开始吧。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="e054" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">1.始终使用:v-for内部的键</h1><p id="47f5" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">将key属性与<code class="fe mv mw mx my b">v-for</code> <a class="ae lq" href="https://learnvue.co/2020/01/creating-your-first-vuejs-custom-directive/" rel="noopener ugc nofollow" target="_blank">指令</a>一起使用有助于您的应用程序在您想要操作数据时保持不变并具有可预测性。</p><p id="9bdf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是必要的，这样Vue就可以跟踪你的组件状态，并对你的不同元素有一个持续的引用。键非常有用的一个例子是当使用动画或<a class="ae lq" href="https://learnvue.co/2020/01/how-you-can-use-vue-transitions-right-now" rel="noopener ugc nofollow" target="_blank"> Vue过渡</a>时。</p><p id="d4ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果没有键，Vue将尽可能地提高DOM的效率。这可能意味着<code class="fe mv mw mx my b">v-for</code>中的元素可能出现无序，或者它们的行为不太可预测。如果我们对每个元素都有一个惟一的键引用，那么我们就可以更好地预测我们的Vue应用程序将如何处理DOM操作。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="04ff" class="nd lz it my b gy ne nf l ng nh">&lt;!-- BAD --&gt;<br/>&lt;div v-for='product in products'&gt;  &lt;/div&gt;<br/><br/>&lt;!-- GOOD! --&gt;<br/>&lt;div v-for='product in products' :key='product.id'&gt;</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="0640" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">2.在活动中使用烤肉串盒</h1><p id="47ea" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">当涉及到发射自定义事件时，最好使用kebab case。这是因为在父组件中，我们使用相同的语法来监听该事件。</p><p id="17c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以为了我们组件的一致性，也为了让你的代码更易读，坚持在两个地方都使用kebab case。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="797b" class="nd lz it my b gy ne nf l ng nh">this.$emit('close-window')</span><span id="7c25" class="nd lz it my b gy ni nf l ng nh">// then in the parent</span><span id="64fe" class="nd lz it my b gy ni nf l ng nh">&lt;popup-window @close-window='handleEvent()' /&gt;</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="b8f4" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">3.用camelCase声明道具，在模板中使用Kebab Case</h1><p id="c933" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">这种最佳实践只是简单地遵循每种语言的惯例。在JavaScript中，camelCase是标准的，在HTML中，它是kebab case。因此，我们相应地使用它们。</p><p id="9852" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">幸运的是，Vue.js为我们在kebab case和camelCase之间转换，所以除了实际声明它们之外，我们不必担心任何事情。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="808a" class="nd lz it my b gy ne nf l ng nh"><br/>BAD!<br/>&lt;PopupWindow titleText='hello world' /&gt; </span><span id="5438" class="nd lz it my b gy ni nf l ng nh">props: { 'title-text': String }</span><span id="12b2" class="nd lz it my b gy ni nf l ng nh"><br/>GOOD!<br/>&lt;PopupWindow title-text='hello world' /&gt; </span><span id="2f93" class="nd lz it my b gy ni nf l ng nh">props: { titleText: String }</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="421f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">4.数据应该总是返回一个函数</h1><p id="4b78" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">当声明组件数据时，数据选项应该总是返回一个函数。如果没有，我们只是简单地返回一个对象，那么这个数据将在组件的所有实例中共享。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="1909" class="nd lz it my b gy ne nf l ng nh">BAD!</span><span id="a2bf" class="nd lz it my b gy ni nf l ng nh">data: {<br/>  name: 'My Window',<br/>  articles: []<br/>}</span></pre><p id="4a47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，大多数时候，目标是构建可重用的组件，所以我们希望每个组件返回一个唯一的对象。我们通过在函数中返回数据对象来实现这一点。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="1116" class="nd lz it my b gy ne nf l ng nh">GOOD!</span><span id="647b" class="nd lz it my b gy ni nf l ng nh">data () {<br/>  return {<br/>    name: 'My Window',<br/>    articles: []<br/>  }<br/>}</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="293b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">5.不要将v-if与v-for元素一起使用</h1><p id="0cea" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">为了过滤数组的元素，很容易想把<code class="fe mv mw mx my b">v-if</code>和<code class="fe mv mw mx my b">v-for</code>一起使用。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="5e26" class="nd lz it my b gy ne nf l ng nh">BAD!</span><span id="3591" class="nd lz it my b gy ni nf l ng nh">&lt;div v-for='product in products' v-if='product.price &lt; 500'&gt;</span></pre><p id="a144" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样做的问题是Vue.js优先考虑<code class="fe mv mw mx my b">v-for</code>指令，而不是<code class="fe mv mw mx my b">v-if</code>指令。所以在引擎盖下，它循环遍历每个元素，然后<em class="nj">检查<code class="fe mv mw mx my b">v-if</code>条件。</em></p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="4e44" class="nd lz it my b gy ne nf l ng nh">this.products.map(function (product) {<br/>  if (product.price &lt; 500) {<br/>    return product<br/>  }<br/>})</span></pre><p id="6695" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着即使我们只想呈现列表中的一些元素，我们也必须遍历整个数组。</p><p id="f412" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这不好。</p><p id="95e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更聪明的解决方案是迭代一个<a class="ae lq" href="https://learnvue.co/2019/12/mastering-computed-properties-in-vuejs/" rel="noopener ugc nofollow" target="_blank">计算属性</a>。上面的例子看起来像这样。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="a5cc" class="nd lz it my b gy ne nf l ng nh">&lt;div v-for='product in cheapProducts'&gt;<br/><br/><br/>computed: {<br/>  cheapProducts: () =&gt; {<br/>    return this.products.filter(function (product) {<br/>      return product.price &lt; 100<br/>    })<br/>  }<br/>}</span></pre><p id="cf46" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这有几个好处。</p><ul class=""><li id="6b3b" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated">渲染的效率要高得多，因为我们不需要循环遍历每一个项目</li><li id="2b25" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">只有当依赖关系改变时，过滤列表才会被重新评估</li><li id="cf65" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">它有助于将我们的组件逻辑从模板中分离出来，使我们的组件更具可读性</li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="3947" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">6.用好的定义来验证你的道具</h1><p id="50ec" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">这可以说是最重要的最佳实践。</p><p id="5f7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么重要？</p><p id="cb1a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嗯，基本上是把未来的你从现在的你中拯救出来。设计大型项目时，很容易忘记道具的确切格式、类型和其他惯例。</p><p id="0ae0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你在一个更大的开发团队中，你的同事不会读心术，所以让他们明白如何使用你的组件。</p><p id="6a67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，省去了每个人不得不费力地跟踪组件以确定属性格式的麻烦，请只编写属性验证。</p><p id="f32b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">查看Vue文档中的这个例子。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="2734" class="nd lz it my b gy ne nf l ng nh">props: {<br/>  status: {<br/>    type: String,<br/>    required: true,<br/>    validator: function (value) {<br/>      return [<br/>        'syncing',<br/>        'synced',<br/>        'version-conflict',<br/>        'error'<br/>      ].indexOf(value) !== -1<br/>    }<br/>  }<br/>}</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="2a1f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">7.使用烤饼盒或烤肉串盒包装组件</h1><p id="16aa" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">组件的常见命名约定是使用PascalCase或kebab case。无论你为你的项目选择哪一个，最重要的是你始终保持一致。</p><p id="989a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我看来，PascalCase的效果最好，因为它得到了大多数IDE自动完成功能的支持。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="c25a" class="nd lz it my b gy ne nf l ng nh"># BAD<br/><br/>mycomponent.vue<br/>myComponent.vue<br/>Mycomponent.vue<br/><br/># GOOD<br/><br/>MyComponent.vue</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5b25" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">8.基本组件应该相应地加上前缀</h1><p id="4b4c" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">另一个命名惯例关注于命名基本组件——或者纯粹是表示性的组件，帮助在应用程序中建立通用的样式。</p><p id="4f5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据Vue样式指南，<em class="nj">基本组件</em>是仅包含以下内容的组件:</p><ul class=""><li id="7ae8" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated">HTML元素</li><li id="9d3e" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">附加基本组件</li><li id="b979" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">第三方用户界面组件</li></ul><p id="2c99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">命名这些组件的最佳实践是给它们加上前缀<code class="fe mv mw mx my b">Base</code>、<code class="fe mv mw mx my b">V</code>或<code class="fe mv mw mx my b">App</code>。再说一次，只要你在整个项目中保持一致，使用其中任何一个都是可以的。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="7b8b" class="nd lz it my b gy ne nf l ng nh">BaseButton.vue<br/>BaseIcon.vue<br/>BaseHeading.vue</span></pre><p id="0409" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种命名约定的目的是让您的基本组件在文件系统中按字母顺序分组。此外，通过使用webpack导入功能，您可以搜索与您的命名约定模式匹配的组件，并将它们作为全局组件自动导入到您的Vue项目中。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="91da" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">9.声明和使用一次的组件应该有前缀“the”</h1><p id="abcc" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">与基本组件类似，<em class="nj">单实例组件</em>(每页使用一次，不接受任何道具)有自己的命名约定。</p><p id="b95c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些组件特定于你的应用程序，通常是页眉、侧边栏或页脚。</p><p id="20e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该组件应该只有一个活动实例。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="0695" class="nd lz it my b gy ne nf l ng nh">TheHeader.vue<br/>TheFooter.vue<br/>TheSidebar.vue<br/>ThePopup.vue</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="2717" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">10.与你的指示速记保持一致</h1><p id="01f0" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Vue开发人员的一个常用技巧是使用简写指令。例如:</p><ul class=""><li id="cfee" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated"><code class="fe mv mw mx my b">@</code>是<code class="fe mv mw mx my b"> v-on</code>的简称</li><li id="fdf7" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><code class="fe mv mw mx my b">:</code>是<code class="fe mv mw mx my b">v-bind</code>的简称</li><li id="d84a" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><code class="fe mv mw mx my b">#</code>是<code class="fe mv mw mx my b"><a class="ae lq" href="https://learnvue.co/2019/12/using-component-slots-in-vuejs%e2%80%8a-%e2%80%8aan-overview/" rel="noopener ugc nofollow" target="_blank">v-slot</a></code>的简称</li></ul><p id="8eb5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在你的Vue项目中使用这些人手很棒。但是为了在你的项目中创造某种惯例，你要么总是使用它们，要么<strong class="kw iu">从不</strong>使用它们。这将使你的项目更有凝聚力和可读性。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="36ee" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">11.不要在“创建的”和“观察的”上调用方法</h1><p id="5aeb" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Vue开发人员常犯的一个错误(也许只有我犯了)是他们不必要地调用了<code class="fe mv mw mx my b">created</code>和<code class="fe mv mw mx my b">watch</code>中的方法。这背后的思想是我们希望在组件初始化后立即运行<code class="fe mv mw mx my b">watch</code>钩子。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="4b73" class="nd lz it my b gy ne nf l ng nh">BAD!</span><span id="44a2" class="nd lz it my b gy ni nf l ng nh">created: () {<br/>  this.handleChange()<br/>},<br/>methods: {<br/>  handleChange() {<br/>    // stuff happens<br/>  }<br/>},<br/>watch () {<br/>  property() {<br/>    this.handleChange()<br/>  }<br/>}</span></pre><p id="e8f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，Vue对此有一个内置的解决方案。这是我们经常忘记的观察者的特性。</p><p id="86be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们所要做的就是稍微重构一下我们的观察器，并声明两个属性:</p><ol class=""><li id="6825" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp ny nq nr ns bi translated"><code class="fe mv mw mx my b">handler (newVal, oldVal) </code> —这是我们的watcher方法本身。</li><li id="f1cc" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp ny nq nr ns bi translated"><code class="fe mv mw mx my b">immediate: true</code> —这使得我们的处理程序在实例创建时运行。</li></ol><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="3f24" class="nd lz it my b gy ne nf l ng nh">GOOD!</span><span id="0e22" class="nd lz it my b gy ni nf l ng nh">methods: {<br/>  handleChange() {<br/>    // stuff happens<br/>  }<br/>},<br/>watch () {<br/>  property {<br/>    immediate: true<br/>    handler() {<br/>      this.handleChange()<br/>    }<br/>  }<br/>}</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8cf8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">12.模板表达式应该只有基本的JavaScript表达式</h1><p id="da7f" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">想在模板中添加尽可能多的内联功能是很自然的。但是这使得我们的模板声明性更差，更加复杂。这意味着我们的模板变得非常混乱。</p><p id="de2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，让我们看看Vue风格指南中另一个规格化字符串的例子。看看这有多混乱。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="bead" class="nd lz it my b gy ne nf l ng nh">BAD!</span><span id="19ed" class="nd lz it my b gy ni nf l ng nh">{{<br/>  fullName.split(' ').map(function (word) {<br/>    return word[0].toUpperCase() + word.slice(1)<br/>  }).join(' ')<br/>}}</span></pre><p id="9ce7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基本上，我们希望模板中的所有内容都能直观地显示出来。为了保持这一点，我们应该将复杂的表达式重构为适当命名的组件选项。</p><p id="87a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">分离出复杂表达式的另一个好处是，这意味着这些值可以重用。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="d0c9" class="nd lz it my b gy ne nf l ng nh">GOOD!</span><span id="565c" class="nd lz it my b gy ni nf l ng nh">{{ normalizedFullName }}<br/><br/><br/>// The complex expression has been moved to a computed property<br/>computed: {<br/>  normalizedFullName: function () {<br/>    return this.fullName.split(' ').map(function (word) {<br/>      return word[0].toUpperCase() + word.slice(1)<br/>    }).join(' ')<br/>  }<br/>}</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="e713" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="8281" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">现在你知道了。</p><p id="7049" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是12个最常见的最佳实践，它们会让你的Vue代码更易维护、更易读、更专业。</p><p id="15ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望这些提示对你有用(因为它们绝对是我一直想要记住的东西)。</p><p id="a429" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想开始你的Vue.js开发，我整理了一个我一直在用的VueJS备忘单。它有我厌倦查找的重要信息，所以我把它编辑成一个整洁的三页小PDF。</p></div></div>    
</body>
</html>