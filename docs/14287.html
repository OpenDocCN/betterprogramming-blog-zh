<html>
<head>
<title>Interface Segregation Principle in Go — Explained Using Dragon Ball</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋的界面分离原理——用龙珠解释</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/interface-segregation-principle-in-golang-using-dragon-ball-example-43a26f367225?source=collection_archive---------4-----------------------#2022-11-24">https://betterprogramming.pub/interface-segregation-principle-in-golang-using-dragon-ball-example-43a26f367225?source=collection_archive---------4-----------------------#2022-11-24</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="eada" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">了解从代码中的接口客户端移除不必要责任的原则</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/b556143d8d5fccff6d62e02d9d2b0939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8LLFZalITE7xn0a54cw6gQ.jpeg"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">涉及</p></figure><h1 id="b6d3" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">为什么</h1><p id="e119" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">当使用接口时，你可能会发现你有一个由不同客户端实现的接口，但是我们并不是所有的客户端都需要实现接口的所有方法。这是不好的，因为你在强迫客户实现他们不需要的方法，留下这样的空方法:</p><pre class="kh ki kj kk gu mk ml mm bn mn mo bi"><span id="3598" class="mp kx ir ml b be mq mr l ms mt">func (c Client) MethodTheClientDontNeed() {  <br/>    panic("implement me") <br/>}</span></pre><h1 id="015f" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">什么</h1><p id="9e77" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">接口分离是坚实原则的一部分，它说的是接口的客户必须只实现他们需要的方法，否则你必须把你的接口分成更具体的接口，这样客户只实现他们需要的方法。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj mu"><img src="../Images/ca6760a34b2eed8ba74f82cde77b2104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBPpDxBzqMwq1CZHBpEPBg.png"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">界面分离原理</p></figure><h1 id="7c02" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">怎么做</h1><p id="de24" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">为了向您介绍这一原则，我将使用龙珠作为参考，所以让我们想象我们正在开发一个新的龙珠游戏，所以我们所做的是创建一个战士界面，该界面将由动画中的所有角色实现，在本例中是撒旦先生和小悟空:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj mv"><img src="../Images/dcdb7908b0694c84254cc320c106250f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*NpXBQkeaohYYxv8h536ubQ.png"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">Warrior界面</p></figure><p id="ec9f" class="pw-post-body-paragraph lo lp ir lq b lr mw js lt lu mx jv lw lx my lz ma mb mz md me mf na mh mi mj ik bi translated">如我们所见，撒旦先生和悟空都实现了<code class="fe nb nc nd ml b">Warrior</code>接口，但如果你看过动漫，就知道悟空可以实现三种方法，但撒旦先生没有，因为他不能<code class="fe nb nc nd ml b">Transform</code>。</p><p id="ad30" class="pw-post-body-paragraph lo lp ir lq b lr mw js lt lu mx jv lw lx my lz ma mb mz md me mf na mh mi mj ik bi translated">所以在这个例子中，他将实现一个他不需要的方法——在这个例子中，这个方法将是空的。</p><p id="8ba4" class="pw-post-body-paragraph lo lp ir lq b lr mw js lt lu mx jv lw lx my lz ma mb mz md me mf na mh mi mj ik bi translated">为了避免这种情况，我们将利用隔离原则，因此我们将创建一个<code class="fe nb nc nd ml b">Super Saiyan</code>接口，该接口将具有仅由悟空实现的<code class="fe nb nc nd ml b">Transform</code>方法，因此我们将以如下内容结束:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ne"><img src="../Images/5f48dea3c22a2cc73e43fa3e399bd392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XexgJFeS88wcllcxFFqklQ.png"/></div></div></figure><p id="27d9" class="pw-post-body-paragraph lo lp ir lq b lr mw js lt lu mx jv lw lx my lz ma mb mz md me mf na mh mi mj ik bi translated">现在，撒旦先生，只是实现了他需要的方法，这要感谢我们创造的新界面<code class="fe nb nc nd ml b">Super Saiyan</code>，它只由小悟空实现。</p><p id="7a0c" class="pw-post-body-paragraph lo lp ir lq b lr mw js lt lu mx jv lw lx my lz ma mb mz md me mf na mh mi mj ik bi translated">正如你所看到的，最后至少有一个接口将被所有客户端实现，这个接口将作为引用我们角色的类型。</p><h1 id="105e" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">代码时间！</h1><p id="c825" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">现在让我们将这些引用带入Golang，看看代码会是什么样子。但在此之前，让我们看看如果没有这个原则会是什么样子:</p><p id="800f" class="pw-post-body-paragraph lo lp ir lq b lr mw js lt lu mx jv lw lx my lz ma mb mz md me mf na mh mi mj ik bi translated">定义接口<code class="fe nb nc nd ml b">Warrior</code>:</p><pre class="kh ki kj kk gu mk ml mm bn mn mo bi"><span id="33cd" class="mp kx ir ml b be mq mr l ms mt">package main<br/><br/>type Warrior interface {<br/>   Kick()<br/>   Punch()<br/>   Transform()<br/>}<br/><br/>type Warriors []Warrior<br/><br/>func executeWithoutISP(warriors Warriors) {<br/>   for _, warrior := range warriors {<br/>      warrior.Kick()<br/>      warrior.Punch()<br/>      warrior.Transform()<br/>   }<br/>}</span></pre><p id="0608" class="pw-post-body-paragraph lo lp ir lq b lr mw js lt lu mx jv lw lx my lz ma mb mz md me mf na mh mi mj ik bi translated">添加将实现<code class="fe nb nc nd ml b">Warrior</code>接口的客户端:</p><pre class="kh ki kj kk gu mk ml mm bn mn mo bi"><span id="5e76" class="mp kx ir ml b be mq mr l ms mt">package main<br/><br/>type MRSatan struct{}<br/><br/>func NewMRSatan() *MRSatan {<br/>   return &amp;MRSatan{}<br/>}<br/><br/>func (m MRSatan) Kick() {<br/>   println("MRSatan kicks")<br/>}<br/><br/>func (m MRSatan) Punch() {<br/>   println("MRSatan punches")<br/>}<br/><br/>// The empty method that we want to avoid<br/>func (m MRSatan) Transform() {<br/>   // do nothing<br/>}</span></pre><pre class="nf mk ml mm bn mn mo bi"><span id="637d" class="mp kx ir ml b be mq mr l ms mt">package main<br/><br/>type Goku struct{}<br/><br/>func NewGoku() *Goku {<br/>   return &amp;Goku{}<br/>}<br/><br/>func (g Goku) Kick() {<br/>   println("Goku kicks")<br/>}<br/><br/>func (g Goku) Punch() {<br/>   println("Goku punches")<br/>}<br/><br/>func (g Goku) Transform() {<br/>   println("Goku transforms into a Super Saiyan")  <br/>}</span></pre><p id="cd35" class="pw-post-body-paragraph lo lp ir lq b lr mw js lt lu mx jv lw lx my lz ma mb mz md me mf na mh mi mj ik bi translated">我们发挥每个客户的能力:</p><pre class="kh ki kj kk gu mk ml mm bn mn mo bi"><span id="6706" class="mp kx ir ml b be mq mr l ms mt">package main<br/><br/>func main() {<br/>   var warriors = Warriors{}<br/>   warriors = append(warriors, NewMRSatan())<br/>   warriors = append(warriors, NewGoku())<br/>  <br/>   executeWithoutISP(warriors)<br/>}</span></pre><p id="7763" class="pw-post-body-paragraph lo lp ir lq b lr mw js lt lu mx jv lw lx my lz ma mb mz md me mf na mh mi mj ik bi translated">当我们运行程序时，我们得到以下输出:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ng"><img src="../Images/e06debaf273abd368a0c2b03ba7308ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*IwFc-o73kVgTyhXHopTAeg.gif"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae nh" href="https://asciinema.org/a/536786" rel="noopener ugc nofollow" target="_blank">https://asciinema.org/a/536786</a></p></figure><p id="161c" class="pw-post-body-paragraph lo lp ir lq b lr mw js lt lu mx jv lw lx my lz ma mb mz md me mf na mh mi mj ik bi translated">一切都运行良好，撒旦先生拳打脚踢，小悟空拳打脚踢，拳打脚踢，然后变身，但是底层代码并不尽如人意，因为撒旦先生的客户正在实现一个他并不需要的方法:</p><pre class="kh ki kj kk gu mk ml mm bn mn mo bi"><span id="44ad" class="mp kx ir ml b be mq mr l ms mt">// The empty method that we want to avoid<br/>func (m MRSatan) Transform() {<br/> // do nothing<br/>}</span></pre><p id="bec5" class="pw-post-body-paragraph lo lp ir lq b lr mw js lt lu mx jv lw lx my lz ma mb mz md me mf na mh mi mj ik bi translated">让我们通过应用接口分离原理来解决这个问题:</p><p id="1d4f" class="pw-post-body-paragraph lo lp ir lq b lr mw js lt lu mx jv lw lx my lz ma mb mz md me mf na mh mi mj ik bi translated">现在，我们创建了<code class="fe nb nc nd ml b">SuperSaiyan</code>接口，而不是只有一个接口，所以它只能由<code class="fe nb nc nd ml b">Goku</code>实现:</p><pre class="kh ki kj kk gu mk ml mm bn mn mo bi"><span id="c151" class="mp kx ir ml b be mq mr l ms mt">package main<br/><br/>type Warrior interface {<br/>   Kick()<br/>   Punch()<br/>}<br/><br/>type SuperSaiyan interface {<br/>   Transform()<br/>}<br/><br/>type Warriors []Warrior<br/><br/>func executeWithISP(warriors Warriors) {<br/>   for _, warrior := range warriors {<br/>      warrior.Kick()<br/>      warrior.Punch()<br/><br/>      // For each Warrior, we check if it is a SuperSaiyan<br/>      if superSaiyan, ok := warrior.(SuperSaiyan); ok {<br/>         superSaiyan.Transform()<br/>      }<br/>   }<br/>}</span></pre><p id="b104" class="pw-post-body-paragraph lo lp ir lq b lr mw js lt lu mx jv lw lx my lz ma mb mz md me mf na mh mi mj ik bi translated">现在，我们的<code class="fe nb nc nd ml b">MR. Satan</code>客户端将只实现<code class="fe nb nc nd ml b">Kick</code>和<code class="fe nb nc nd ml b">Pucnh</code>方法:</p><pre class="kh ki kj kk gu mk ml mm bn mn mo bi"><span id="5905" class="mp kx ir ml b be mq mr l ms mt">package main<br/><br/>type MRSatan struct{}<br/><br/>func NewMRSatan() *MRSatan {<br/>   return &amp;MRSatan{}<br/>}<br/><br/>func (m MRSatan) Kick() {<br/>   println("MRSatan kicks")<br/>}<br/><br/>func (m MRSatan) Punch() {<br/>   println("MRSatan punches")<br/>}</span></pre><p id="a4d4" class="pw-post-body-paragraph lo lp ir lq b lr mw js lt lu mx jv lw lx my lz ma mb mz md me mf na mh mi mj ik bi translated">我们的<code class="fe nb nc nd ml b">Goku</code>客户端仍然会实现这三个方法:</p><pre class="kh ki kj kk gu mk ml mm bn mn mo bi"><span id="2f3b" class="mp kx ir ml b be mq mr l ms mt">package main<br/><br/>type Goku struct{}<br/><br/>func NewGoku() *Goku {<br/>   return &amp;Goku{}<br/>}<br/><br/>func (g Goku) Kick() {<br/>   println("Goku kicks")<br/>}<br/><br/>func (g Goku) Punch() {<br/>   println("Goku punches")<br/>}<br/><br/>func (g Goku) Transform() {<br/>   println("Goku transforms into a Super Saiyan")<br/>}</span></pre><p id="596c" class="pw-post-body-paragraph lo lp ir lq b lr mw js lt lu mx jv lw lx my lz ma mb mz md me mf na mh mi mj ik bi translated">我们的主文件和以前一样:</p><pre class="kh ki kj kk gu mk ml mm bn mn mo bi"><span id="f389" class="mp kx ir ml b be mq mr l ms mt">func main() {<br/>   var warriors = Warriors{}<br/>   warriors = append(warriors, NewMRSatan())<br/>   warriors = append(warriors, NewGoku())<br/>  <br/>   executeWithISP(warriors)<br/>}</span></pre><p id="a416" class="pw-post-body-paragraph lo lp ir lq b lr mw js lt lu mx jv lw lx my lz ma mb mz md me mf na mh mi mj ik bi translated">如果我们运行这个程序，我们仍然会得到相同的响应，但是使用了更好的底层代码:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ng"><img src="../Images/582495ac0119121b6240914b77d03871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SeT0q--ER_K2LJAisb--lg.gif"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae nh" href="https://asciinema.org/a/536787" rel="noopener ugc nofollow" target="_blank">https://asciinema.org/a/536787</a></p></figure><h1 id="f79f" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">结论</h1><p id="f391" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">ISP是一个简单的原则，它可以帮助您在实现各种客户端使用的大型接口时，免除客户端不必要的责任，但这可能会导致您拥有无数个接口，具体取决于您要拆分的主接口有多大。在这方面，我非常小心，以我的经验来看，我只是用最多10种方法来分离接口，以最多3个对我很有效的接口结束。</p><h1 id="f3da" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">参考</h1><ol class=""><li id="2f6a" class="ni nj ir lq b lr ls lu lv lx nk mb nl mf nm mj nn no np nq bi translated"><a class="ae nh" href="https://refactoring.guru/design-patterns/book" rel="noopener ugc nofollow" target="_blank">深入设计模式</a></li><li id="299f" class="ni nj ir lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated"><a class="ae nh" href="https://asciinema.org/" rel="noopener ugc nofollow" target="_blank">asci NEMA</a>记录我的终端</li><li id="30c3" class="ni nj ir lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated"><a class="ae nh" href="https://excalidraw.com/" rel="noopener ugc nofollow" target="_blank"> Excalidraw </a>和<a class="ae nh" href="https://figma.com/" rel="noopener ugc nofollow" target="_blank"> Figma </a>查看图示</li><li id="93c2" class="ni nj ir lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated"><a class="ae nh" href="https://github.com/hernanhrm/interface-segregation-principal" rel="noopener ugc nofollow" target="_blank">储存库</a></li></ol></div></div>    
</body>
</html>