<html>
<head>
<title>Angular: Get Started With NgRx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">angular:NgRx入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-getting-started-with-ngrx-75b9139c23eb?source=collection_archive---------0-----------------------#2020-01-07">https://betterprogramming.pub/angular-getting-started-with-ngrx-75b9139c23eb?source=collection_archive---------0-----------------------#2020-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="de10" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">NgRx的基础知识，包括代码示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/26bc4eb27d84fb22daa71377aa3ba7a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Te6AUmIkPJQUnZ03GYvN3A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:Sarindu Udagepala</p></figure><p id="40fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我第一次开始使用NgRx时，我面临着一个陡峭的学习曲线。理解NgRx包含的基本元素需要大量的阅读和研究。这篇文章的主要目的是将我收集的知识传递给读者，让他们的NgRx生活更轻松。</p><p id="cd88" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我打算讨论以下主题:</p><ul class=""><li id="2b33" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">NgRx是什么？</li><li id="df90" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">NgRx的基本元素:存储、动作、缩减器、选择器、效果</li><li id="eb4b" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">NgRx组件之间的交互</li><li id="b237" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">NgRx的利与弊</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="45e7" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated"><strong class="ak">NgRx是什么？</strong></h1><p id="25ab" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">首先，<a class="ae nm" href="https://ngrx.io/" rel="noopener ugc nofollow" target="_blank"> NgRx </a>代表角度无功延伸。NgRx是一个基于<a class="ae nm" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>模式的状态管理系统。在我们深入讨论细节之前，让我们试着理解角度应用中的<em class="nn">状态</em>的概念。</p><h2 id="465b" class="no mq it bd mr np nq dn mv nr ns dp mz lh nt nu nb ll nv nw nd lp nx ny nf nz bi translated">状态</h2><p id="0ada" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">理论上，应用程序状态是应用程序的整个内存。简而言之，应用程序状态由API调用接收的数据、用户输入、呈现UI状态、应用程序首选项等组成。应用程序状态的一个简单、具体的例子是CRM应用程序中维护的客户列表。</p><p id="e90d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们试着在角度应用程序的上下文中理解应用程序状态。众所周知，角度应用通常由许多组件组成。这些组件中的每一个都有自己的状态，并且不知道其他组件的状态。为了在父子组件之间共享信息，我们使用了<code class="fe oa ob oc od b">@Input</code>和<code class="fe oa ob oc od b">@Output</code>装饰器。然而，只有当您的应用程序由几个组件组成时，这种方法才是实用的，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/a06c9ffdad5094f67311a7cf32cabf44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NEUhZVLdda4h_JGsN0YQbA.png"/></div></div></figure><p id="31e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当组件数量增加时，仅仅通过<code class="fe oa ob oc od b">@Input</code>和<code class="fe oa ob oc od b">@Output</code>装饰者在组件之间传递信息就成了一场噩梦。我们就拿下图来对此进行阐述吧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/481960b4148641c2147ef500455d3991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tc8j2S1sQOvn1HTuFDWQ7Q.png"/></div></div></figure><p id="fc08" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您必须将信息从组件3传递到组件6，您将必须跳四次并涉及其他三个组件。如您所见，这是一种非常麻烦且容易出错的状态管理方式。这就是Redux模式发挥作用的地方。</p><h2 id="f3c1" class="no mq it bd mr np nq dn mv nr ns dp mz lh nt nu nb ll nv nw nd lp nx ny nf nz bi translated">Redux</h2><p id="18c9" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">Redux是一种模式，用于简化JavaScript应用程序中的状态管理过程(不仅仅是Angular)。Redux主要基于三个主要原则。</p><p id="d1e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">真实的单一来源</strong>——这意味着应用程序的状态存储在一个<strong class="la iu"> </strong>单一存储中的对象树中。存储负责存储数据，并在需要时向组件提供数据。(我这里指的是角度应用。但是Redux通常可以应用于任何JavaScript应用程序。)根据这种体系结构，数据在存储和组件之间流动，而不是在组件之间流动。下图说明了这个概念。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/c426b9c69cbc437d0c4a2beee9dd5d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7oCgnY2PSeEXB1PK47syQ.png"/></div></div></figure><p id="dfa5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">只读状态</strong>——换句话说，状态是不可变的。这并不一定意味着状态总是不变的，不能改变。它只是暗示不允许你直接改变状态。为了改变状态，您必须将应用程序不同部分的<em class="nn">动作</em>(我们将在后面详细讨论)发送到商店。</p><p id="fd4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">状态用纯函数</strong>修改——调度动作将触发一组称为<em class="nn"> reducers </em>的纯函数。Reducers负责根据收到的动作以不同的方式修改状态。这里需要注意的一个关键点是，一个reducer总是会返回一个包含修改的新状态对象。</p><h2 id="f322" class="no mq it bd mr np nq dn mv nr ns dp mz lh nt nu nb ll nv nw nd lp nx ny nf nz bi translated">NgRx</h2><p id="fef9" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">NgRx是一组受Redux模式启发的库。顾名思义，NgRx是专门为Angular应用编写的状态管理解决方案。我们将在下一节深入研究NgRx库的基本构建块。请注意，我将对所有示例代码使用NgRx version 8。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="099a" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">NgRx的基本元素:存储、动作、缩减器、选择器、效果</h1><h2 id="580c" class="no mq it bd mr np nq dn mv nr ns dp mz lh nt nu nb ll nv nw nd lp nx ny nf nz bi translated">商店</h2><p id="2f89" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">商店是整个状态管理过程中的关键元素。它保存状态并促进组件和状态之间的交互。你可以通过角度依赖注入获得对外挂的引用，如下所示。</p><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="c659" class="no mq it od b gy ol om l on oo">constructor(private store: Store&lt;AppState&gt;) {}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/ebb2fa11c83e7d3274f276273900687e.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*eToWxwblvR9I7l-_OYnfvQ.png"/></div></figure><p id="dd5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该存储引用随后可用于两个主要操作:</p><ul class=""><li id="9d94" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">通过<code class="fe oa ob oc od b">store.dispatch(…)</code>方法向商店发送动作，这将依次触发减少器和效果</li><li id="0813" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">通过选择器检索应用程序状态</li></ul><p id="86af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">状态对象树的结构</strong></p><p id="31ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设您的应用程序包含两个名为User和Product的特性模块。这些模块中的每一个都处理整体状态的不同部分。产品信息将一直保持在状态中的<code class="fe oa ob oc od b">products</code>部分。用户信息将一直保持在<code class="fe oa ob oc od b">user</code>区的状态。这些切片也被称为<em class="nn">切片</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/652a64b19fb88b617e65dc6af8fe2efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gF8j4ZNldTYOdS-N180h-w.png"/></div></div></figure><h2 id="6f48" class="no mq it bd mr np nq dn mv nr ns dp mz lh nt nu nb ll nv nw nd lp nx ny nf nz bi translated">行动</h2><p id="e990" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">动作是您分派到存储区的指令，可选地带有一些元数据(有效负载)。根据操作类型，商店决定执行哪些操作。在代码中，一个动作由一个普通的旧JavaScript对象表示，该对象有两个主要属性，即<code class="fe oa ob oc od b">type</code>和<code class="fe oa ob oc od b">payload</code>。<code class="fe oa ob oc od b">payload</code>是一个可选属性，还原器将使用它来修改状态。下面的代码片段和图说明了这个概念。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/083782a8a93433f8585d1501f8632fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*fZUDdgwDbBW9zQD6TqRbpQ.png"/></div></figure><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="5c85" class="no mq it od b gy ol om l on oo">{</span><span id="efad" class="no mq it od b gy os om l on oo">  "type": "Login Action",</span><span id="d429" class="no mq it od b gy os om l on oo">  "payload": {</span><span id="e89d" class="no mq it od b gy os om l on oo">    userProfile: user</span><span id="a88f" class="no mq it od b gy os om l on oo">  }</span><span id="883f" class="no mq it od b gy os om l on oo">}</span></pre><p id="1e05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">NgRx版本8提供了一个名为<code class="fe oa ob oc od b">createAction</code>的实用函数来定义动作创建者(不是动作，而是动作创建者)。下面是这方面的示例代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="bd79" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，您可以使用<code class="fe oa ob oc od b">login</code>动作创建器(这是一个函数)来构建动作，并将其发送到商店，如下所示。<code class="fe oa ob oc od b">user</code>是你传入动作的<code class="fe oa ob oc od b">payload</code>对象。</p><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="2109" class="no mq it od b gy ol om l on oo">this.store.dispatch(login({user}));</span></pre><h2 id="4aa8" class="no mq it bd mr np nq dn mv nr ns dp mz lh nt nu nb ll nv nw nd lp nx ny nf nz bi translated">还原剂</h2><p id="bcbb" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">Reducers负责修改状态并返回带有修改的新状态对象。Reducers接受两个参数，当前状态和动作。基于接收到的动作类型，reducers将对当前状态执行某些修改，并产生新的状态。下图展示了这一概念。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/fa91f173221eebe5018b90dd2ffa4dcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJ-jxq0mpM18JOrtJzGPiw.png"/></div></div></figure><p id="047c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与actions类似，NgRx提供了一个名为<code class="fe oa ob oc od b">createReducer</code>的实用函数来创建reducers。典型的<code class="fe oa ob oc od b">createReducer</code>函数调用如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="8bb2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您所看到的，它接受初始状态(应用程序启动时的状态)和一对多状态改变函数，这些函数定义了如何对不同的操作做出反应。这些状态改变函数中的每一个都接收当前状态和动作作为参数，并返回新的状态。</p><h2 id="7b8c" class="no mq it bd mr np nq dn mv nr ns dp mz lh nt nu nb ll nv nw nd lp nx ny nf nz bi translated">效果</h2><p id="bb11" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">当一个动作被分派到商店时，效果允许你执行副作用。我们试着通过一个例子来理解这一点。当用户成功登录一个应用程序时，一个带有<code class="fe oa ob oc od b">type</code>和<code class="fe oa ob oc od b">Login Action</code>的动作将被发送到商店，用户信息在<code class="fe oa ob oc od b">payload</code>中。缩减器功能将监听该动作，并用用户信息修改状态。此外，作为一个副作用，您还希望将用户信息保存在浏览器的本地存储中。一个效果可以用来执行这个额外的任务(副作用)。</p><p id="25df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在NgRx中创建效果有多种方法。下面是一种简单明了的创造效果的方法。请注意，你一般不会用这种方法来创造效果。我仅以此为例来解释幕后发生的事情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><ul class=""><li id="fc89" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">actions$</code> observable会发出商店收到的动作。这些值将通过一个操作链。</li><li id="1266" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">ofType</code>是使用的第一个运算符。这是NgRx(不是RxJS)提供的一个特殊操作符，用于根据动作的类型过滤掉动作。在这种情况下，只有<code class="fe oa ob oc od b">login</code>类型的动作将被允许通过运营商链的其余部分。</li><li id="0491" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">tap</code>是链中用于在浏览器本地存储中存储用户信息的第二个操作符。<code class="fe oa ob oc od b">tap</code>操作符通常用于在操作符链中执行副作用。</li><li id="8cd0" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">最后，我们必须手动订阅<code class="fe oa ob oc od b">login$</code>观察值。</li></ul><p id="4aba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，这种方法有几个主要缺点。</p><ul class=""><li id="acd1" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">您必须手动订阅可观察对象，这不是一个好的做法。这样，您将总是不得不手动取消订阅，这会导致缺乏可维护性。</li><li id="ca67" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如果运算符链中出现错误，可观察对象将出错，并停止发出后续值(动作)。结果，副作用不会被执行。因此，您必须有一种机制来手动创建一个新的可观察实例，并在出现错误时重新订阅。</li></ul><p id="1d7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了克服这些问题，NgRx提供了一个名为<code class="fe oa ob oc od b">createEffect</code>的实用函数来创建效果。典型的<code class="fe oa ob oc od b">createEffect</code>函数调用如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="0c54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b">createEffect</code>方法接受一个函数，该函数返回一个可观察对象和(可选的)一个配置对象作为参数。</p><p id="97c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">NgRx处理由支持函数返回的可观察对象的订阅，因此您不必手动订阅或取消订阅。此外，如果操作链中出现任何错误，NgRx将创建一个新的可观察值并重新订阅，以确保副作用总是得到执行。</p><p id="3fc0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果<code class="fe oa ob oc od b">dispatch</code>在配置对象中是<code class="fe oa ob oc od b">true</code>(默认值)，<code class="fe oa ob oc od b">createEffect</code>方法返回一个<code class="fe oa ob oc od b">Observable&lt;Action&gt;</code>。否则，它返回一个<code class="fe oa ob oc od b">Observable&lt;Unknown&gt;</code>。如果<code class="fe oa ob oc od b">dispatch</code>属性为<code class="fe oa ob oc od b">true</code>，NgRx将订阅<code class="fe oa ob oc od b">type</code> <code class="fe oa ob oc od b">Observable&lt;Action&gt;</code>返回的可观察对象，并将收到的动作分派给商店。</p><p id="5b1d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您没有将接收到的动作映射到操作链中的不同类型的动作，那么您必须将<code class="fe oa ob oc od b">dispatch</code>设置为<code class="fe oa ob oc od b">false</code>。否则，执行将导致无限循环，因为相同的动作将在<code class="fe oa ob oc od b">actions$</code>流中一次又一次地被调度和接收。例如，您不必在下面的代码中将<code class="fe oa ob oc od b">dispatch</code>设置为<code class="fe oa ob oc od b">false</code>，因为您将原始动作映射到操作符链中的不同类型的动作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="2f74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的场景中，</p><ul class=""><li id="a1a1" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">效果接收<code class="fe oa ob oc od b">type</code>的动作<code class="fe oa ob oc od b">loadAllCourses</code>。</li><li id="7d49" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">作为副作用，API被调用，课程被加载。</li><li id="1a06" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">API对动作<code class="fe oa ob oc od b">type</code> <code class="fe oa ob oc od b">allCoursesLoaded</code>的响应被映射，加载的课程作为动作<code class="fe oa ob oc od b">payload</code>被传递。</li><li id="90fa" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">最后，已经创建的<code class="fe oa ob oc od b">allCoursesLoaded</code>动作被发送到商店。这是由NgRx在引擎盖下完成的。</li><li id="2635" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">缩减器将监听输入的<code class="fe oa ob oc od b">allCoursesLoaded</code>动作，并用加载的进程修改状态。</li></ul><h2 id="e491" class="no mq it bd mr np nq dn mv nr ns dp mz lh nt nu nb ll nv nw nd lp nx ny nf nz bi translated">选择器</h2><p id="ecaf" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">选择器是用于获取存储状态片段的纯函数。如下所示，即使不使用选择器，也可以查询状态。但是这种方法也有一些主要的缺点。</p><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="4341" class="no mq it od b gy ol om l on oo">const isLoggedIn$ = this.store.pipe(</span><span id="7b6b" class="no mq it od b gy os om l on oo">map(state =&gt; !!state.user)</span><span id="51cb" class="no mq it od b gy os om l on oo">);</span></pre><ul class=""><li id="4a30" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">store</code>是您可以订阅的观察值。每当商店收到一个动作，<code class="fe oa ob oc od b">store</code>就会将状态对象推送给它的订阅者。</li><li id="199d" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如果需要，您可以使用映射函数来获取状态片段并执行任何计算。在上面的例子中，我们正在获取状态对象树中的<code class="fe oa ob oc od b">user</code>片段，并将其转换为一个布尔值，以确定用户是否已经登录。</li><li id="4a26" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">您可以手动订阅<code class="fe oa ob oc od b">isLoggedIn$</code> observable，或者在带有异步管道的角度模板中使用它来读取发出的值。</li></ul><p id="97ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，这种方法有一个主要缺点。一般来说，商店经常从应用程序的不同部分接收动作。按照上面的实现，每次商店收到一个动作，商店就会发出一个状态对象。这个状态对象将再次通过映射函数并更新UI。</p><p id="59df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果映射函数的结果与上次相比没有变化，就没有必要再次更新UI。例如，如果<code class="fe oa ob oc od b">map(state =&gt; !!state.user)</code>的结果自上次执行以来没有改变，我们就不必再次将结果推送到UI/订阅者。为了实现这一点，NgRx(不是RxJS)引入了一个叫做<code class="fe oa ob oc od b">select</code>的特殊操作符。使用<code class="fe oa ob oc od b">select</code>操作符，上面的代码将会发生如下变化。</p><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="4d2f" class="no mq it od b gy ol om l on oo">const isLoggedIn$ = this.store.pipe(</span><span id="6602" class="no mq it od b gy os om l on oo">select(state =&gt; !!state.user)</span><span id="5ea6" class="no mq it od b gy os om l on oo">);</span></pre><p id="c4ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果映射函数的结果与上次相比没有变化，那么<code class="fe oa ob oc od b">select</code>操作符将阻止值被推送给UI/订户。</p><p id="5671" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法可以进一步改进。即使<code class="fe oa ob oc od b">select</code>操作符没有将未改变的值推送给UI/订户，它仍然必须每次都接受状态对象并进行计算以获得结果。</p><p id="3652" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如前所述，当商店收到来自应用程序的动作时，observable将发出一个<code class="fe oa ob oc od b">state</code>。一个动作并不总是更新状态。如果状态没有改变，映射函数计算的结果也不会改变。因此，如果发出的<code class="fe oa ob oc od b">state</code>对象与上次相比没有变化，我们不必再次计算。这就是选择器发挥作用的地方。</p><p id="a6f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">选择器是一个纯粹的函数，它维护对以前执行的记忆。只要输入没有改变，就不会重新计算输出。相反，输出将从内存返回。这个过程叫做<em class="nn">记忆</em> n</p><p id="b8b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">NgRx提供了一个名为<code class="fe oa ob oc od b">createSelector</code>的实用函数来构建具有记忆能力的选择器。以下是<code class="fe oa ob oc od b">createSelector</code>实用功能的一个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="4034" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b">createSelector</code>函数接受一对多映射函数，这些函数给出状态的不同部分，以及一个执行计算的投影函数。如果状态切片自上次执行以来没有改变，则不会调用投影仪功能。为了使用创建的选择器函数，您必须将它作为参数传递给<code class="fe oa ob oc od b">select</code>操作符。</p><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="d448" class="no mq it od b gy ol om l on oo">this.isLoggedIn$ = this.store</span><span id="1282" class="no mq it od b gy os om l on oo">  .pipe(</span><span id="51fd" class="no mq it od b gy os om l on oo">    select(isLoggedIn)</span><span id="eb9b" class="no mq it od b gy os om l on oo">  );</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="77a2" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">NgRx组件之间的交互</h1><p id="1df5" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">下图说明了NgRx生态系统中不同组件之间的交互方式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/a528049e3b567664008994ba8c3946c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ljMtJ-F-WXRO_B2KD-JOg.png"/></div></div></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="219f" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">NgRx的利与弊</h1><h2 id="f821" class="no mq it bd mr np nq dn mv nr ns dp mz lh nt nu nb ll nv nw nd lp nx ny nf nz bi translated">赞成的意见</h2><ul class=""><li id="8a7b" class="lu lv it la b lb nh le ni lh ox ll oy lp oz lt lz ma mb mc bi translated">单一事实来源的概念使得组件在角度应用程序中共享信息变得更加容易。</li><li id="b56c" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">组件不能直接更改应用程序状态。只有还原剂能够改变状态。这使得调试更加容易。</li></ul><h2 id="4c73" class="no mq it bd mr np nq dn mv nr ns dp mz lh nt nu nb ll nv nw nd lp nx ny nf nz bi translated">骗局</h2><ul class=""><li id="dd68" class="lu lv it la b lb nh le ni lh ox ll oy lp oz lt lz ma mb mc bi translated">当您第一次开始使用NgRx时，有一个陡峭的学习曲线。</li><li id="d025" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">应用程序将有点冗长，因为您必须引入几个新的工件，如reducers、选择器、效果等等。</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="ace3" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">结论</h1><p id="8dae" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">这篇文章的主要目的是向您介绍NgRx概念。我计划在下一篇文章中实现一个完整的基于NgRx的角度应用程序。</p></div></div>    
</body>
</html>