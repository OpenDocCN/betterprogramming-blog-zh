<html>
<head>
<title>Auto Layout in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的自动布局</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/auto-layout-in-swift-ffd918d4ec06?source=collection_archive---------4-----------------------#2019-10-22">https://betterprogramming.pub/auto-layout-in-swift-ffd918d4ec06?source=collection_archive---------4-----------------------#2019-10-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0b2c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以编程方式编写约束</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a0fd8a146c5f21f4894a57ee9da6d2b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jeYZXY-q_jGsCoQusMvhqQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@halgatewood?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">哈尔·盖特伍德</a>在<a class="ae ky" href="https://unsplash.com/s/photos/layout?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="3abe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自动布局约束允许我们创建动态调整到不同大小类别和位置的视图。这些约束将确保您的视图适应任何大小的变化，而不必手动更新框架或位置。</p><p id="a732" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能想象一个没有自动布局的世界吗？我们过去常常自己计算帧或者使用自动调整大小的遮罩(是的，这与<code class="fe lv lw lx ly b">translatesAutoresizingMaskIntoConstraints</code>属性有关)。只是从iOS 6开始，我们才可以依赖那些动态调整的约束。</p><p id="3635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用这些扩展，您可以避免编写大量样板代码。</p><p id="c967" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多内容需要介绍，但是在我开始之前，我想简单地讨论一下在代码中编写约束和使用接口构建器之间的区别。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5318" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">界面生成器与以编程方式编写自动布局约束</h1><p id="fc19" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">以编程方式编写自动布局约束与使用界面生成器(IB)相比一直是一个热门话题。我决定在Twitter上向我的粉丝发起一项民意调查，结果得到了851张投票和许多强烈意见的回复。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然有赢家，但结果非常接近，我对价差感到相当惊讶。它证实了一个事实，即这是一个热门话题，因为开发者显然不同意一个解决方案。你可能认为我们会对SwiftUI将最终解决这个问题的想法感到高兴。</p><p id="cb7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管怎样，我们还没有到完全依赖SwiftUI的地步。你仍然需要决定是用代码写布局，还是用故事板或xib。</p><p id="3aaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据个人经验和Twitter上的评论，用代码编写布局有一些优点和缺点。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f852" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">在代码中编写自动布局约束的利弊</h1><h2 id="2ea0" class="nf mh it bd mi ng nh dn mm ni nj dp mq li nk nl ms lm nm nn mu lq no np mw nq bi translated"><strong class="ak">优点</strong></h2><ul class=""><li id="3839" class="nr ns it lb b lc my lf mz li nt lm nu lq nv lu nw nx ny nz bi translated">在Git中更容易合并。</li><li id="d0df" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">代码更容易调试。</li><li id="87ac" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">约束可能更容易概述。</li></ul><h2 id="da6d" class="nf mh it bd mi ng nh dn mm ni nj dp mq li nk nl ms lm nm nn mu lq no np mw nq bi translated"><strong class="ak">缺点</strong></h2><ul class=""><li id="b1d7" class="nr ns it lb b lc my lf mz li nt lm nu lq nv lu nw nx ny nz bi translated">没有视觉表现。IB允许你在不同的大小级别中查看你的视图。</li><li id="0da1" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">您可能会在视图控制器中留下大量布局代码。</li></ul><p id="02e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种解决方案都有一个相当长的学习曲线，尽管如果你有在界面构建器中设置约束的经验，用代码编写约束可能更容易。因此，我个人建议，如果你刚刚开始构建应用程序，就从故事板开始。</p><p id="b688" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将界面构建器与代码中的约束结合起来也是一种解决方案。然而，请记住，这是不一致的，可能会使人们更难理解发生了什么。在使用界面构建器的同时编写约束也可以看作是编写自动布局的副作用。</p><p id="70f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在团队中工作，您可能希望通过以编程方式编写约束来避免解决大量合并冲突。最后多半还是个人口味。就像民意测验结果显示的那样，没有金科玉律。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e303" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">在代码中编写自动布局约束</h1><p id="000a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一旦你决定用代码编写约束，你就进入了一个充满各种可能性的世界。幸运的是，不再需要这些类型的约束:</p><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="0766" class="nf mh it ly b gy oj ok l ol om">NSLayoutConstraint.constraints(withVisualFormat: "H:|-[icon(==postDate)]-20-[titleLabel(120@250)]-20@750-[postDate(&gt;=50)]-|", metrics: nil, views: views)</span></pre><p id="4b5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个用自动布局可视化格式语言编写的示例约束。它仍然受到支持，并且可能是你在打开一个旧项目时遇到的问题，但这不是我在这篇博文中要讨论的内容。</p><p id="d986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们将专注于使用iOS 9中引入的布局锚。这是一个很棒的API，现在，它允许你很容易地在代码中编写约束。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="dbd3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用布局锚点编写约束</h1><p id="042b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先，我们需要将<code class="fe lv lw lx ly b">translatesAutoresizingMaskIntoConstraints</code>设置为false。这是为了防止视图的自动调整大小遮罩被转换为自动布局约束并影响您的约束。</p><p id="9378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，开始创建一组约束。在这个数组中，您定义了一组约束:</p><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="7cb7" class="nf mh it ly b gy oj ok l ol om">let constraints = [<br/>    view.centerXAnchor.constraint(equalTo: superview.centerXAnchor),<br/>    view.centerYAnchor.constraint(equalTo: superview.centerYAnchor),<br/>    view.widthAnchor.constraint(equalToConstant: 100),<br/>    view.heightAnchor.constraint(equalTo: view.widthAnchor)<br/>]<br/>NSLayoutConstraint.activate(constraints)</span></pre><p id="7dca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子展示了编写约束的基础，应该是可读和可理解的。</p><p id="241c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它创建了一个正方形，并将其置于其超级视图的中心。最后一行是实际激活约束所需要的，这样它们会使你的布局如预期的那样出现。</p><p id="7f97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个<code class="fe lv lw lx ly b">UIView</code>都有一个锚属性集合，允许您设置视图之间的关系:</p><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="ddeb" class="nf mh it ly b gy oj ok l ol om">extension UIView {<br/><br/>    /* Constraint creation conveniences. See NSLayoutAnchor.h for details.<br/>     */<br/>    open var leadingAnchor: NSLayoutXAxisAnchor { get }<br/><br/>    open var trailingAnchor: NSLayoutXAxisAnchor { get }<br/><br/>    open var leftAnchor: NSLayoutXAxisAnchor { get }<br/><br/>    open var rightAnchor: NSLayoutXAxisAnchor { get }<br/><br/>    open var topAnchor: NSLayoutYAxisAnchor { get }<br/><br/>    open var bottomAnchor: NSLayoutYAxisAnchor { get }<br/><br/>    open var widthAnchor: NSLayoutDimension { get }<br/><br/>    open var heightAnchor: NSLayoutDimension { get }<br/><br/>    open var centerXAnchor: NSLayoutXAxisAnchor { get }<br/><br/>    open var centerYAnchor: NSLayoutYAxisAnchor { get }<br/><br/>    open var firstBaselineAnchor: NSLayoutYAxisAnchor { get }<br/><br/>    open var lastBaselineAnchor: NSLayoutYAxisAnchor { get }<br/>}</span></pre><p id="c684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个锚点从<code class="fe lv lw lx ly b">NSLayoutAnchor</code>返回子类，这些子类带有一些设置关系的常用方法。</p><p id="530a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些关系包括等于、大于和小于或等于关系。最好研究一下<a class="ae ky" href="https://developer.apple.com/documentation/uikit/nslayoutanchor" rel="noopener ugc nofollow" target="_blank">的文档</a>，熟悉一下可用的API。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="117a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">约束的顺序</h1><p id="8a6d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一旦你开始写约束，如果你开始处理常量，记住约束的顺序是很重要的。</p><p id="3f78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">采用以下一组约束:</p><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="aaf9" class="nf mh it ly b gy oj ok l ol om">let constraints = [<br/>    innerSquare.topAnchor.constraint(equalTo: outerSquare.topAnchor),<br/>    innerSquare.leftAnchor.constraint(equalTo: outerSquare.leftAnchor, constant: 40),<br/>    outerSquare.bottomAnchor.constraint(equalTo: innerSquare.bottomAnchor),<br/>    outerSquare.rightAnchor.constraint(equalTo: innerSquare.rightAnchor, constant: 40)<br/>]<br/><br/>NSLayoutConstraint.activate(constraints)</span></pre><p id="761b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将产生以下图像，其中外部正方形为蓝色，内部正方形为红色:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/dec0b2c1b4da691b27d9c30619913d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/0*_9vkkWLEXCm4RS-I.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码示例中的简单自动布局</p></figure><p id="2055" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们要改变外方块和内方块的顺序，常数需要设置为负值:</p><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="75ef" class="nf mh it ly b gy oj ok l ol om">let constraints = [<br/>    innerSquare.topAnchor.constraint(equalTo: outerSquare.topAnchor),<br/>    outerSquare.leftAnchor.constraint(equalTo: innerSquare.leftAnchor, constant: -40),<br/>    outerSquare.bottomAnchor.constraint(equalTo: innerSquare.bottomAnchor),<br/>    innerSquare.rightAnchor.constraint(equalTo: outerSquare.rightAnchor, constant: -40)<br/>]<br/><br/>NSLayoutConstraint.activate(constraints)</span></pre><p id="6e14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顶部和底部约束的数量相同。因此，在设置约束并切换最后两个锚点的视图和超级视图时，请记住以下顺序:</p><ul class=""><li id="b6dc" class="nr ns it lb b lc ld lf lg li oo lm op lq oq lu nw nx ny nz bi translated">顶端</li><li id="9349" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">左边的</li><li id="60d1" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">底部</li><li id="ad42" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">对吧</li></ul><p id="3974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这基本上归结为逆时针方向。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="eebc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">可用的布局参考线</h1><p id="7bce" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">每个<code class="fe lv lw lx ly b">UIView</code>都有一些布局指南，也可以用作锚点。</p><ul class=""><li id="0f13" class="nr ns it lb b lc ld lf lg li oo lm op lq oq lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">layoutMarginsGuide</code>:设置约束，保持布局边距为间距。</li><li id="9e6f" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">readableContentGuide</code>:将宽度限制为便于用户阅读的大小。</li><li id="0319" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">safeAreaLayoutGuide</code>:表示视图中未被条形和其他内容遮挡的部分。</li></ul><p id="879f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用以下指南:</p><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="b51e" class="nf mh it ly b gy oj ok l ol om">let constraints = [<br/>    outerSquare.topAnchor.constraint(equalTo: viewController.view.safeAreaLayoutGuide.topAnchor),<br/>    outerSquare.leftAnchor.constraint(equalTo: viewController.view.safeAreaLayoutGuide.leftAnchor),<br/>    viewController.view.safeAreaLayoutGuide.bottomAnchor.constraint(equalTo: outerSquare.bottomAnchor),<br/>    viewController.view.safeAreaLayoutGuide.rightAnchor.constraint(equalTo: outerSquare.rightAnchor)<br/>]</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0eb8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">支持从右向左的语言</h1><p id="2082" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">虽然仅仅使用<code class="fe lv lw lx ly b">leftAnchor</code>和<code class="fe lv lw lx ly b">rightAnchor</code>看起来很明显，但是你可能想考虑使用<code class="fe lv lw lx ly b">leadingAnchor</code>和<code class="fe lv lw lx ly b">trailingAnchor</code>来代替。</p><p id="22c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做可以在视图中增加对从右向左语言的支持。这对于像标签这样的视图非常重要，在这些视图中，您希望确保它们能够从右向左语言翻转。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="171b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">动态启用和禁用约束的性能</h1><p id="51fe" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">性能和自动布局约束本身就是一个话题。因此，我想向您介绍一下<a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2018/220" rel="noopener ugc nofollow" target="_blank"> WWDC 2018:高性能汽车布局</a>的精彩演讲。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3879" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">有价值的扩展，让您的生活更轻松</h1><p id="f92e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您可以做很多事情来简化代码中的约束。通过使用这些扩展，您可以避免编写大量样板代码。</p><h2 id="2a5f" class="nf mh it bd mi ng nh dn mm ni nj dp mq li nk nl ms lm nm nn mu lq no np mw nq bi translated">将视图约束到它的超级视图</h2><p id="ac08" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一个常见的扩展是创建一个方法来轻松地将视图约束在其超级视图中:</p><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="6d14" class="nf mh it ly b gy oj ok l ol om">extension UIView {<br/><br/>    /// Returns a collection of constraints to anchor the bounds of the current view to the given view.<br/>    ///<br/>    /// - Parameter view: The view to anchor to.<br/>    /// - Returns: The layout constraints needed for this constraint.<br/>    func constraintsForAnchoringTo(boundsOf view: UIView) -&gt; [NSLayoutConstraint] {<br/>        return [<br/>            topAnchor.constraint(equalTo: view.topAnchor),<br/>            leadingAnchor.constraint(equalTo: view.leadingAnchor),<br/>            view.bottomAnchor.constraint(equalTo: bottomAnchor),<br/>            view.trailingAnchor.constraint(equalTo: trailingAnchor)<br/>        ]<br/>    }<br/>}</span></pre><h2 id="cd4d" class="nf mh it bd mi ng nh dn mm ni nj dp mq li nk nl ms lm nm nn mu lq no np mw nq bi translated">处理优先级</h2><p id="95f4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一旦必须为约束设置优先级以防止违反约束，您可能会对以下扩展感到满意:</p><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="577d" class="nf mh it ly b gy oj ok l ol om">extension NSLayoutConstraint {<br/>    <br/>    /// Returns the constraint sender with the passed priority.<br/>    ///<br/>    /// - Parameter priority: The priority to be set.<br/>    /// - Returns: The sended constraint adjusted with the new priority.<br/>    func usingPriority(_ priority: UILayoutPriority) -&gt; NSLayoutConstraint {<br/>        self.priority = priority<br/>        return self<br/>    }<br/>    <br/>}<br/><br/>extension UILayoutPriority {<br/>    <br/>    /// Creates a priority which is almost required, but not 100%.<br/>    static var almostRequired: UILayoutPriority {<br/>        return UILayoutPriority(rawValue: 999)<br/>    }<br/>    <br/>    /// Creates a priority which is not required at all.<br/>    static var notRequired: UILayoutPriority {<br/>        return UILayoutPriority(rawValue: 0)<br/>    }<br/>}</span></pre><h2 id="e20a" class="nf mh it bd mi ng nh dn mm ni nj dp mq li nk nl ms lm nm nn mu lq no np mw nq bi translated">自动布局属性包装</h2><p id="7f61" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">防止自己不停地写:</p><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="be6d" class="nf mh it ly b gy oj ok l ol om">translatesAutoresizingMaskIntoConstraints = false</span></pre><p id="35df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用以下属性包装:</p><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="c859" class="nf mh it ly b gy oj ok l ol om">@propertyWrapper<br/>public struct UsesAutoLayout&lt;T: UIView&gt; {<br/>    public var wrappedValue: T {<br/>        didSet {<br/>            wrappedValue.translatesAutoresizingMaskIntoConstraints = false<br/>        }<br/>    }<br/><br/>    public init(wrappedValue: T) {<br/>        self.wrappedValue = wrappedValue<br/>        wrappedValue.translatesAutoresizingMaskIntoConstraints = false<br/>    }<br/>}<br/><br/>final class MyViewController {<br/>    @UsesAutoLayout<br/>    var label = UILabel()<br/>}</span></pre><h2 id="2e0b" class="nf mh it bd mi ng nh dn mm ni nj dp mq li nk nl ms lm nm nn mu lq no np mw nq bi translated">调试自动布局约束</h2><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="6172" class="nf mh it ly b gy oj ok l ol om">[LayoutConstraints] Unable to simultaneously satisfy constraints.</span></pre><p id="8443" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您已经使用约束有一段时间了，这可能是一个常见的消息。</p><p id="c874" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我写过一篇关于用户界面调试工具的博文，可以帮助你解决自动布局问题:<a class="ae ky" href="https://www.avanderlee.com/debugging/ui-debugging-by-making-use-of-third-party-apps/" rel="noopener ugc nofollow" target="_blank">利用第三方应用程序进行UI调试</a>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a564" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">在代码中编写约束时需要外部依赖</h1><p id="0685" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有很多外部依赖说它们使编写约束变得更容易。</p><p id="c3dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望上面的例子表明，利用默认的API在代码中编写约束已经很容易了。外部框架引入了当前和未来的同事可能不熟悉的定制代码模式。</p><p id="9876" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我建议你使用布局锚，坚持使用苹果的默认API。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6d78" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="8fc2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">读完这篇文章后，用代码编写自动布局约束应该会容易一些。这是在界面构建器中设置约束的一个很好的替代方法。</p><p id="ca7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢！</p></div></div>    
</body>
</html>