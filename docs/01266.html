<html>
<head>
<title>Node.js Modules: Basics to Advanced</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js模块:基础到高级</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/node-js-modules-basics-to-advanced-2464001229b6?source=collection_archive---------0-----------------------#2019-08-28">https://betterprogramming.pub/node-js-modules-basics-to-advanced-2464001229b6?source=collection_archive---------0-----------------------#2019-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0d0f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解模块化如何工作以及我们可以使用的东西</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0343d3d5f1e787a10b373c3d6a076a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HDiJ4hL6sCnDj5PN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Markus Spiske </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f195" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank">节点</a>，模块化是一个一流的概念。在<code class="fe lv lw lx ly b">Node.js</code>模块系统中，每个文件被视为一个独立的模块。</p><p id="1f06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果您正在创建一个<code class="fe lv lw lx ly b">demo.js</code>文件，这意味着您正在Node中创建一个模块。基本上，模块帮助我们将代码封装成可管理的块。</p><p id="cff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在模块(即JavaScript文件)中定义的任何东西都仅限于该模块，除非我们想将它暴露给代码的其他部分。</p><p id="21d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们在模块中定义的任何东西都只对该模块是私有的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6ae2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">如何创建模块</h1><p id="dfb2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在Node中创建一个模块非常简单，只要创建一个文件就可以了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码1</p></figure><p id="09b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，现在你在Node中有了一个模块，没什么特别的，只是简单的创建了一个文件。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6653" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">模块类型</h1><ul class=""><li id="78cd" class="nf ng it lb b lc my lf mz li nh lm ni lq nj lu nk nl nm nn bi translated">核心模块:<code class="fe lv lw lx ly b">Node.js</code>自带的模块，如<code class="fe lv lw lx ly b">https</code>、<code class="fe lv lw lx ly b">os</code>、<code class="fe lv lw lx ly b">fs</code>、<code class="fe lv lw lx ly b">net</code>等。</li><li id="b356" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">第三方模块:从任何软件包管理器安装的模块。我们使用这些模块来完成或简化任何现有的任务。例如，为了简化我们的web API开发，我们使用<code class="fe lv lw lx ly b">express</code>，或者处理日期和时间，我们使用<code class="fe lv lw lx ly b">moment</code>。</li><li id="4e98" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">本地模块:<strong class="lb iu"> </strong>这些是我们自己创建的模块。这些模块基本上由我们代码的核心业务逻辑组成。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f8dc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">模块化以前是如何工作的</h1><p id="81e2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在<code class="fe lv lw lx ly b">Node.js</code>或ES5模块之前，JavaScript中的模块化是通过使用<code class="fe lv lw lx ly b">IIFE</code>(立即调用函数表达式)实现的，顾名思义，这是一个定义后立即调用的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码2</p></figure><p id="4692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们运行这段代码，我们将得到输出<code class="fe lv lw lx ly b">5</code>。</p><p id="39de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数<code class="fe lv lw lx ly b">sum</code>在这个生命中定义，如果该生命之外的任何代码试图访问<code class="fe lv lw lx ly b">sum </code>函数，将导致<code class="fe lv lw lx ly b">ReferenceError: sum is not defined</code>，即<code class="fe lv lw lx ly b">sum</code>函数是这个特定生命的私有函数。</p><p id="914d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何在生活之外访问这个<code class="fe lv lw lx ly b">sum</code>函数呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码3</p></figure><p id="e3fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在生活之外暴露我们的<code class="fe lv lw lx ly b">sum</code>函数，我们在生活之外创建一个对象(<code class="fe lv lw lx ly b">exportObj</code>)，然后，通过闭包，我们在生活之内访问那个对象，并将我们的<code class="fe lv lw lx ly b">sum</code>函数赋给它的一个属性。</p><p id="02a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们在生命之外的<code class="fe lv lw lx ly b">exportObj</code>对象上调用<code class="fe lv lw lx ly b">sum</code>函数。这一次，我们能够得到没有任何错误的结果。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c517" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">模块化如何在Node.js中工作</h1><p id="26a7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们在上面已经看到，为了在Node和ES5之前实现模块化，我们使用了函数。</p><p id="6347" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">Node.js</code>中，这与我们实现模块化的方式相同，即仅使用函数，但有一个问题——包装我们代码的包装函数不是由我们编写的，而是由Node自动为我们添加的。</p><p id="5179" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子来更好地理解它。</p><p id="2e7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们定义了一个名为<code class="fe lv lw lx ly b">sum.js</code>的文件，其内容如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码4</p></figure><p id="c6d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码，在<code class="fe lv lw lx ly b">sum.js</code>中，被<code class="fe lv lw lx ly b">Node.js</code>封装成一个函数。</p><p id="5342" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在<code class="fe lv lw lx ly b">Node.js</code>中，这段代码被包装，在我们的运行环境中看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码5</p></figure><p id="4241" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有东西都被包装了，就像我们在生活中包装的一样，但是在这里，这个包装函数有一些参数。我们将在本文后面详细讨论它们。</p><p id="559c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查你的代码是否被包装在一个函数中，我们是否收到这些参数。在JavaScript中，我们知道所有函数都接收一个名为<code class="fe lv lw lx ly b">arguments</code>的参数，所以，如果我们在代码中得到<code class="fe lv lw lx ly b">arguments</code>，它就确认我们的代码在函数内部。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码6</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/ffa46a8b65aa756ed811aa460c27f498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f_c3JthH2ZTnnO6EVo5fbA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码6的输出(图1)</p></figure><p id="37a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到我们得到了<code class="fe lv lw lx ly b">arguments</code>的输出(arguments是一个类似数组的对象，它的键是数字，默认情况下传递给每个函数)。因此，它确认了我们的代码被包装在一个函数中，并且该函数接收五个参数，这些参数由<code class="fe lv lw lx ly b">Node.js</code>给出。</p><p id="42a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们逐一讨论这五个论点。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6ce9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">出口</h1><p id="4d44" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这是一个用于在一个模块中公开我们的功能的对象，因此这些功能可以在其他模块中使用。</p><p id="ccac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以暴露任何东西，可以是函数、变量、常量、类等等。正如我们在前面的<em class="nu">模块性在</em> <strong class="lb iu"> </strong>之前是如何工作的一节中所做的，我们已经在<code class="fe lv lw lx ly b">exportObj</code>上创建了一个属性，然后给它赋值。</p><p id="ce55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和我们对<code class="fe lv lw lx ly b">exports</code>对象做的一样——我们在<code class="fe lv lw lx ly b">exports</code>对象上创建一个属性，然后给这个属性赋值，或者你想公开的任何东西(变量、函数、类、常量)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码7</p></figure><p id="fc07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们通过将函数引用分配给<code class="fe lv lw lx ly b">exports</code>对象上新创建的multiply属性来公开multiply函数，即multiply函数只在这个模块之外可用，而sum函数不可用。</p><p id="6822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:不要给这个<code class="fe lv lw lx ly b">exports</code>对象提供一个新的引用，也就是不要给<code class="fe lv lw lx ly b">exports</code>参数分配一个新的对象。(我们将讨论为什么不这样做。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码8</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f096" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">要求</strong></h1><p id="3a06" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这是一个我们用来从其他模块导入或要求功能的功能。它是对用于导出功能的<code class="fe lv lw lx ly b">exports</code>对象的补充。另一方面，<code class="fe lv lw lx ly b">require</code>用于导入这些功能。</p><p id="ad1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了需要一个模块，我们调用<code class="fe lv lw lx ly b">require</code>函数时，要么使用模块的路径(绝对路径或相对路径)，对于本地模块，以<code class="fe lv lw lx ly b">/</code>、<code class="fe lv lw lx ly b">./</code>或<code class="fe lv lw lx ly b">../</code>开头；对于核心模块和第三方模块，则使用模块的名称。</p><p id="c3af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，它返回我们需要的模块的导出内容。</p><p id="36bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:基本上我们在需要一个模块的时候，会得到对象<code class="fe lv lw lx ly b">module.exports</code> <strong class="lb iu"> </strong>(这个我们会讨论)的引用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码9</p></figure><p id="2b2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<em class="nu">代码7 </em>中，我们实现了两个函数<code class="fe lv lw lx ly b">sum</code>和<code class="fe lv lw lx ly b">multiply</code>，但是我们只导出了<code class="fe lv lw lx ly b">multiply</code>，所以在<code class="fe lv lw lx ly b">operations.js</code>模块之外只有那个可用。这就是为什么我们试图调用<code class="fe lv lw lx ly b">sum</code>时会得到一个错误。</p><p id="642f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Node的<code class="fe lv lw lx ly b">require</code>函数提供的不仅仅是导入功能，我们将对此进行更深入的探讨。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1b2b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">组件</h1><p id="ca97" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这是传递的第三个参数，<code class="fe lv lw lx ly b">module</code>变量是对代表当前模块的对象的引用。它有各种有用的属性，我们可以在任何模块的带有<code class="fe lv lw lx ly b">console.log(module)</code>的终端中看到。</p><p id="97da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们在<code class="fe lv lw lx ly b">app.js</code>(代码9)和<code class="fe lv lw lx ly b">operations.js</code>(代码7)中做<code class="fe lv lw lx ly b">console.log(module)</code>。我们得到以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/3a373e00d0b94b532796fe81c393b16f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*THa8K2pPFHdhTIjrMg0j_w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">operations.js中的console.log(模块)(图2)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/9b814bdf80a09efd2ed4f4818e6b3d52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*p6UGKnrHEFrYnAQPPQKkCQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">app.js中的console.log(模块)(图3)</p></figure><p id="155f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">module</code>对象包含关于我们模块的所有数据，例如:“谁是它的父模块？它的孩子是谁？解析第三方模块的所有途径是什么？是完全装了，还是没装？”</p><p id="2b9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是<code class="fe lv lw lx ly b">module</code>对象最重要的属性是<code class="fe lv lw lx ly b">exports</code>属性，我们也可以在模块上使用这个<code class="fe lv lw lx ly b">exports</code>属性来导出我们的数据，而不是使用包装函数的<code class="fe lv lw lx ly b">exports</code>参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码10</p></figure><p id="7dc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，这是从我们的模块中导出功能的第二种方式。</p><p id="75bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注:我们将看到<code class="fe lv lw lx ly b">exports</code>和<code class="fe lv lw lx ly b">module.exports</code>的区别，以及它们是如何相互连接的。</p><h2 id="a771" class="nx mh it bd mi ny nz dn mm oa ob dp mq li oc od ms lm oe of mu lq og oh mw oi bi translated"><code class="fe lv lw lx ly b">module</code>对象的概要</h2><ol class=""><li id="eaa6" class="nf ng it lb b lc my lf mz li nh lm ni lq nj lu oj nl nm nn bi translated"><code class="fe lv lw lx ly b">module.filename</code>是模块的完全解析文件名。</li><li id="9267" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu oj nl nm nn bi translated"><code class="fe lv lw lx ly b">module.id</code>是模块的标识符。通常，这是完全解析的文件名，除了主模块，它是'<code class="fe lv lw lx ly b">.</code>'(句号)，见图3。主模块是启动节点应用程序的模块，例如，如果我们在终端中写<code class="fe lv lw lx ly b">node app.js</code>，那么<code class="fe lv lw lx ly b">app.js</code>就是主模块。</li><li id="3819" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu oj nl nm nn bi translated"><code class="fe lv lw lx ly b">module.path</code>是您的名称模块的目录名。</li><li id="dfe9" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu oj nl nm nn bi translated"><code class="fe lv lw lx ly b">module.parent</code>是一个引用父模块的对象。</li><li id="6071" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu oj nl nm nn bi translated"><code class="fe lv lw lx ly b">module.children</code>是所有子模块对象的数组。</li><li id="faab" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu oj nl nm nn bi translated"><code class="fe lv lw lx ly b">module.loaded</code>是一个布尔属性，它告诉我们模块是否已经完成加载，或者正在加载过程中。</li><li id="4e23" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu oj nl nm nn bi translated"><code class="fe lv lw lx ly b">module.paths</code>是节点将查找以解析模块的所有路径的数组。</li></ol><p id="b6ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你们中的一些人可能已经注意到了图2和图3中，模块父属性或子属性中的这个奇怪的<code class="fe lv lw lx ly b">[Circular]</code>东西。那是什么？</p><p id="3464" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，<code class="fe lv lw lx ly b">[Circular]</code>定义了一个循环引用，如图2所示，它打印出了<code class="fe lv lw lx ly b">operations.js</code>的模块对象。<code class="fe lv lw lx ly b">operations.js</code>模块的父属性引用了<code class="fe lv lw lx ly b">app.js</code>模块。</p><p id="0c52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，<code class="fe lv lw lx ly b">operations.js</code>是<code class="fe lv lw lx ly b">app.js</code>的子模块，所以它的子属性应该有一个对<code class="fe lv lw lx ly b">operations.js</code>模块的引用。类似地，<code class="fe lv lw lx ly b">operations.js</code>模块的父属性再次引用了<code class="fe lv lw lx ly b">app.js</code>模块，因此它将进入这个无限循环。</p><p id="10cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止这个无限循环，Node发现，如果任何模块的父模块或子模块已经被加载，它将不再加载它们，而是显示这个<code class="fe lv lw lx ly b">[Circular]</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/9a16d395a01fc016b18c4b502602af70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*bDfNK47PZ2lmsVJl60fJiw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="dfef" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">_ _文件名</h1><p id="2ef8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这是一个包含当前模块绝对路径的变量。</p><p id="887c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定两个模块:<code class="fe lv lw lx ly b">a </code>和<code class="fe lv lw lx ly b">b</code>，其中<code class="fe lv lw lx ly b">b</code>是<code class="fe lv lw lx ly b">a</code>的依赖，有一个目录结构:</p><ul class=""><li id="a469" class="nf ng it lb b lc ld lf lg li ol lm om lq on lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">/User/home/node_blog/a.js</code></li><li id="ae54" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">/User/home/node_blog/node_modules/b/b.js</code></li></ul><p id="5720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果我们在<code class="fe lv lw lx ly b">b.js</code>内做<code class="fe lv lw lx ly b">console.log(__filename)</code>，就会得到<code class="fe lv lw lx ly b">/User/home/node_blog/node_modules/b/b.js</code>。如果我们在<code class="fe lv lw lx ly b">a.js</code>内做<code class="fe lv lw lx ly b"> console.log(__filename)</code>，就会得到<code class="fe lv lw lx ly b">/User/home/node_blog/a.js</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="efe1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">_ _目录名</h1><p id="fd3b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当前模块的目录名。这与<code class="fe lv lw lx ly b">__filename</code>的<code class="fe lv lw lx ly b">path.dirname()</code>相同。</p><p id="b572" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，对于以上模块，<code class="fe lv lw lx ly b">a.js</code>和<code class="fe lv lw lx ly b">b.js</code>。</p><p id="1c9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在<code class="fe lv lw lx ly b">b.js</code>内做<code class="fe lv lw lx ly b"> console.log(__dirname)</code>，我们会得到<code class="fe lv lw lx ly b">/User/home/node_blog/node_modules/b/</code>，在<code class="fe lv lw lx ly b">a.js</code>内，我们会得到<code class="fe lv lw lx ly b">/User/home/node_blog/</code>。</p><p id="631b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经学习了该模块的基础知识。从现在开始，我们将深入探讨这个话题。请再耐心听我说一会儿，因为我们要讨论各种有趣的事情</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2e12" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">模块导出和导出之间的区别</h1><p id="87f6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们使用<code class="fe lv lw lx ly b">module.exports</code>和<code class="fe lv lw lx ly b">exports</code>从模块中导出我们的功能。</p><p id="1046" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，它们之间有一点点不同。相反，我会说他们没有不同，但他们是相似的。<code class="fe lv lw lx ly b">exports</code>对象只是<code class="fe lv lw lx ly b">module.exports</code>的简写。</p><p id="ccbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在节点内部，<code class="fe lv lw lx ly b">exports</code>对象引用了<code class="fe lv lw lx ly b">module.exports</code>对象。这有点像:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="58f4" class="nx mh it ly b gy os ot l ou ov">const exports = module.exports;</span></pre><p id="abc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们在一个模块中<code class="fe lv lw lx ly b">require</code>时，这个<code class="fe lv lw lx ly b">module.exports</code>对象由<code class="fe lv lw lx ly b">require</code>函数返回。</p><p id="cc6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们不改变<code class="fe lv lw lx ly b">exports</code>对象的引用的原因，正如我们在代码8中所写的，因为如果我们改变<code class="fe lv lw lx ly b">exports</code>对象，它将不再引用<code class="fe lv lw lx ly b">module.exports</code>，导致功能不能从我们的模块中导出。</p><p id="ad10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在一个模块中同时使用<code class="fe lv lw lx ly b">module.exports</code>和<code class="fe lv lw lx ly b">exports</code>吗？</p><p id="1842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，我们可以，但是如果我们两个都用的话，有一些微妙的地方我们应该记住。</p><p id="ee54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那就是，当我们在任何模块中使用<code class="fe lv lw lx ly b">require</code>时，我们得到的是引用<code class="fe lv lw lx ly b">module.exports</code>的<code class="fe lv lw lx ly b">module.exports</code>对象和<code class="fe lv lw lx ly b">exports</code>对象，所以需要维护这个引用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码11</p></figure><p id="e47c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这段代码中，总和不会被导出，因为我们已经通过为其分配一个新对象来更改了对<code class="fe lv lw lx ly b">module.exports</code>的引用，但是<code class="fe lv lw lx ly b">exports</code>对象现在也引用了之前对<code class="fe lv lw lx ly b">module.exports</code>的引用。</p><p id="97cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了导出总和，我们需要将<code class="fe lv lw lx ly b">exports</code>对象的引用更新为<code class="fe lv lw lx ly b">module.exports</code>的当前引用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码12</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1a50" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">详细模块</h1><p id="e3ed" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">没有必要只有一个文件才能成为我们需要的模块。除了文件，我们还有文件夹作为模块，我们可以在中使用。</p><p id="6199" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，作为模块的文件夹是模块中的模块，即它包含实现功能的各种模块。这就是库所做的，它们被组织在一个自包含的目录中，然后它们提供了该目录的单一入口点。</p><p id="09ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种方式我们可以要求一个文件夹。</p><ol class=""><li id="6950" class="nf ng it lb b lc ld lf lg li ol lm om lq on lu oj nl nm nn bi translated">在文件夹的根目录下创建一个<code class="fe lv lw lx ly b">package.json </code>，指定一个<code class="fe lv lw lx ly b">main</code>模块。一个示例<code class="fe lv lw lx ly b">package.json</code>文件可能如下所示:</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码13</p></figure><p id="22eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这是在<code class="fe lv lw lx ly b">./some-library</code>的一个文件夹中，那么<code class="fe lv lw lx ly b">require('./some-library')</code>会尝试加载<code class="fe lv lw lx ly b">./some-library/lib/some-library.js</code>。</p><p id="19f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<code class="fe lv lw lx ly b">Node.js</code>对<code class="fe lv lw lx ly b">package.json</code>的认知程度。</p><p id="a12a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.如果节点在模块的根目录中找不到任何<code class="fe lv lw lx ly b">package.json</code>，或者如果<code class="fe lv lw lx ly b">main</code>条目丢失或无法解析，则在<code class="fe lv lw lx ly b">package.json</code>中找不到任何<code class="fe lv lw lx ly b">package.json</code>。然后，<code class="fe lv lw lx ly b">Node.js</code>将尝试从该目录加载<code class="fe lv lw lx ly b">index.js</code>或<code class="fe lv lw lx ly b">index.node</code>。例如，如果上面的例子中没有<code class="fe lv lw lx ly b">package.json</code>文件，那么<code class="fe lv lw lx ly b">require('./some-library')</code>将尝试加载:</p><ul class=""><li id="254e" class="nf ng it lb b lc ld lf lg li ol lm om lq on lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">./some-library/index.js</code></li><li id="cb06" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">./some-library/index.node</code></li></ul><p id="2e1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这些尝试失败，那么<code class="fe lv lw lx ly b">Node.js</code>将报告整个模块丢失，并显示默认错误:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="2bdc" class="nx mh it ly b gy os ot l ou ov">Error: Cannot find module ‘some-library’.</span></pre><p id="8962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在文件模块中，<code class="fe lv lw lx ly b">.js</code>文件也不是唯一的模块，我们还有<code class="fe lv lw lx ly b">.json</code>文件和<code class="fe lv lw lx ly b">.node</code>文件，它们也是节点中的模块。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="fd09" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">详细要求</h1><p id="732a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当我们需要一个模块时，没有必要给出文件扩展名。</p><p id="e3af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们需要一个<code class="fe lv lw lx ly b">some-file.js</code>文件，并且它在同一层，我们可以这样要求它:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="e457" class="nx mh it ly b gy os ot l ou ov">const someFile = require(‘./some-file’);</span></pre><p id="ab07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说没有指定扩展名。</p><p id="d4f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在解析该文件的路径时，Node遵循一个过程。</p><p id="d1c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它首先寻找<code class="fe lv lw lx ly b">some-file.js</code>，如果<code class="fe lv lw lx ly b">some-file.js</code>不存在，它将寻找<code class="fe lv lw lx ly b">some-file.json</code>，如果也不存在，它将寻找<code class="fe lv lw lx ly b">some-file.node</code>。</p><p id="23e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">.js</code>文件被解释为JavaScript文本文件，<code class="fe lv lw lx ly b">.json</code>文件被解析为JSON文本文件，即我们得到JavaScript对象。<code class="fe lv lw lx ly b">.node</code>文件被解释为编译后的附加模块。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9121" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">要求如何工作？</h1><p id="7213" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当我们使用<code class="fe lv lw lx ly b">require</code>功能需要一个模块时，它会通过不同的步骤导入所需的模块。</p><ol class=""><li id="f730" class="nf ng it lb b lc ld lf lg li ol lm om lq on lu oj nl nm nn bi translated">解析模块，即找到模块的绝对路径。</li><li id="08c4" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu oj nl nm nn bi translated">将模块加载到内存中，以便可以执行其代码。</li><li id="2198" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu oj nl nm nn bi translated">执行模块的代码。</li><li id="b305" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu oj nl nm nn bi translated">将模块的所有导出捆绑到一个对象中<code class="fe lv lw lx ly b">module.exports</code>。</li><li id="6767" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu oj nl nm nn bi translated">缓存模块，这样，当我们再次需要这个模块时，我们就不会一遍又一遍地重复所有这些步骤。</li></ol><p id="db47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解析模块经历一个顺序:</p><ol class=""><li id="ebf0" class="nf ng it lb b lc ld lf lg li ol lm om lq on lu oj nl nm nn bi translated">首先，它将查看resolve函数中指定的模块是否是核心模块。如果它是一个核心模块，它将返回它并仅在那里停止。</li><li id="ea20" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu oj nl nm nn bi translated">然后，它将查看指定模块的路径是否以<code class="fe lv lw lx ly b">/</code>、<code class="fe lv lw lx ly b">./</code>或<code class="fe lv lw lx ly b">../</code>开头，如果节点找到匹配，它将加载它。</li><li id="129d" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu oj nl nm nn bi translated">如果我们寻找的模块既不是核心模块，也不是以<code class="fe lv lw lx ly b">/</code>、<code class="fe lv lw lx ly b">./</code>或<code class="fe lv lw lx ly b">../</code>开头，那么Node将开始在<code class="fe lv lw lx ly b">module.paths</code>数组(见图2或图3)中指定的所有目录中逐一寻找我们的模块。即，节点将开始在我们的应用程序父目录<code class="fe lv lw lx ly b">node_modules</code>文件夹中查找，如果没有找到，它将移动到父目录，依此类推，直到到达文件系统的根目录。</li><li id="6cc2" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu oj nl nm nn bi translated">如果节点找不到我们的模块，它将抛出一个“找不到”错误。</li></ol><p id="4cdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在解析一个模块后，Node将加载它并执行它的代码，但是如果我们只想检查我们是否有一个特定的模块，也就是说，我们不想加载并执行它，我们只想解析它。</p><p id="4d35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们在<code class="fe lv lw lx ly b">require</code>上使用<code class="fe lv lw lx ly b">resolve</code>功能:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="2a3f" class="nx mh it ly b gy os ot l ou ov">const resolvedFilename = require.resolve(moduleToResolve);</span></pre><p id="03fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用内部的<code class="fe lv lw lx ly b">require()</code>机制来查找一个模块的位置，但是不加载模块，只返回解析后的文件名。</p><p id="4d92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经看到了order节点解析一个模块，并且，正如我们在上面的第3点中讨论的，它在解析一个模块的过程中搜索一个路径。</p><p id="924a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们如何以编程方式知道该节点搜索了哪些路径来解析我们的模块呢？为此，我们使用:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="9ca7" class="nx mh it ly b gy os ot l ou ov">const allPaths = require.resolve.paths(moduleToResolve);</span></pre><p id="19b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe lv lw lx ly b">moduleToResolve</code>字符串引用核心模块，例如<code class="fe lv lw lx ly b">http</code>或<code class="fe lv lw lx ly b">fs</code>，则返回包含在<code class="fe lv lw lx ly b">moduleToResolve</code>或<code class="fe lv lw lx ly b">null</code>解析期间搜索的路径的数组。</p><p id="62a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，对于以下目录结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/ba6aaeff31847e53eab1259c972cbb15.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*Vs7iYg6_M3mQyldLIOZSHQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">目录结构(图5)</p></figure><p id="cb31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们编写并执行以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码14</p></figure><p id="e156" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码14的输出将是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/6c7077f8c188381b2772c5419bf5d802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*2--dID7NNYXJr2X-crxJ7w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图6</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6880" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">节点模块的缓存</h1><p id="c487" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">模块在第一次加载后被缓存。这意味着(除了别的以外)如果解析到同一个文件，那么每次调用<code class="fe lv lw lx ly b">require('foo')</code>都会得到完全相同的对象。</p><p id="8a68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些模块缓存在一个键值对的对象中，我们可以使用<code class="fe lv lw lx ly b">require.cache</code>来引用这个对象。</p><p id="4720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果我们从这个对象中删除任何一个键，那么<code class="fe lv lw lx ly b">require</code>将会重新加载这个模块。本地插件也有例外。如果我们删除它们的密钥并尝试重新加载它们，将会导致错误。</p><p id="0ce9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们有两个文件:</p><p id="b57a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">cacheFile1.js</code></p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="1adf" class="nx mh it ly b gy os ot l ou ov">console.log(‘Inside cache file 1’);</span></pre><p id="1eab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">cacheFile2.js</code></p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="c87c" class="nx mh it ly b gy os ot l ou ov">console.log(‘Inside cache file 2’);</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码15</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/eff34ce675e71528ac755585bf03162c.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*ODGXPpVENPZOaAQZMZJiYg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码15的输出(图7)</p></figure><p id="c5c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的输出中，您可以看到我们只获得了一次“内部缓存文件2 ”,但是我们需要它两次。发生这种情况是因为，在第一次，只有<code class="fe lv lw lx ly b">cacheFile1.js</code>和<em class="nu"> </em> <code class="fe lv lw lx ly b">cacheFile2.js</code>被缓存。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ae1c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">检查模块是否为主模块</h1><p id="700c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">主模块是启动应用程序的模块。例如，如果我们通过编写<code class="fe lv lw lx ly b"><em class="nu"> </em>node app.js</code>来开始我们的应用程序，那么<code class="fe lv lw lx ly b">app.js</code>就是我的应用程序的主要模块。</p><p id="3fb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在require上还有一个属性，叫做<code class="fe lv lw lx ly b">require.main</code> <em class="nu">，</em>，它是一个引用我的主模块的<code class="fe lv lw lx ly b"><em class="nu"> </em>module</code>对象，所以如果在我们的代码中，我们需要检查这个模块是否是主模块，然后我们想要执行一些动作，我们可以这样做:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="5361" class="nx mh it ly b gy os ot l ou ov">if(require.main === module){</span><span id="9eaf" class="nx mh it ly b gy oz ot l ou ov">//Your Code goes here</span><span id="6508" class="nx mh it ly b gy oz ot l ou ov">}</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="63c8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">循环要求</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/1aea6deb020107a98809d2e3f3eabe31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*h2ADk39IG7arqVmLfZ9kfA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8</p></figure><p id="d106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当<code class="fe lv lw lx ly b">a.js</code> <em class="nu"> </em>要求<code class="fe lv lw lx ly b">b.js</code>而<code class="fe lv lw lx ly b">b.js</code>要求<code class="fe lv lw lx ly b">a.js</code>时，就会发生循环要求。</p><p id="6eff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当有循环<code class="fe lv lw lx ly b">require()</code>调用时，模块在返回时可能还没有执行完。让我们举个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码16</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码17</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码18</p></figure><p id="0283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe lv lw lx ly b">main.js</code>加载<code class="fe lv lw lx ly b">a.js</code>时，然后<code class="fe lv lw lx ly b">a.js</code>依次加载<code class="fe lv lw lx ly b">b.js</code>。此时，<code class="fe lv lw lx ly b">b.js</code>试图加载<code class="fe lv lw lx ly b">a.js</code>。</p><p id="8b9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止无限循环，未完成的<code class="fe lv lw lx ly b">a.js</code>导出对象的副本被返回到<code class="fe lv lw lx ly b">b.js</code>模块。<code class="fe lv lw lx ly b">b.js</code>然后完成加载，它的<code class="fe lv lw lx ly b">exports</code>对象被提供给<code class="fe lv lw lx ly b">a.js</code>模块。</p><p id="ee7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe lv lw lx ly b">main.js</code>加载完两个模块时，它们都已经完成了。因此，该程序的输出将是:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="24cb" class="nx mh it ly b gy os ot l ou ov">$ node main.js<br/>main starting<br/>a starting<br/>b starting<br/>in b, a.done = false<br/>b done<br/>in a, b.done = true<br/>a done<br/>in main, a.done = true, b.done = true </span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="48f4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Node.js中的模块模块</h1><p id="4196" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Node.js</code>中还有一个<code class="fe lv lw lx ly b">module</code>模块，与我们目前所学的模块对象不同。当我们与模块交互时，它提供了一些通用的实用方法。</p><p id="43a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，它提供了一个名为<code class="fe lv lw lx ly b">builtinModules</code>的实用属性，列出了<code class="fe lv lw lx ly b">Node.js</code>的所有核心模块的名称，我们可以用它来检查我们正在使用的模块是否是节点的核心模块，并相应地执行操作。</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="fe19" class="nx mh it ly b gy os ot l ou ov">const builtin = require('module').builtinModules;</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="af97" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">谢谢你</h1><p id="1285" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">谢谢你们一直忍耐到现在。我们在这里讨论的各种主题并没有被广泛使用，但是为了在Node中脱颖而出，我们需要知道事情实际上是如何工作的以及它们提供的不同功能。</p><p id="ca9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果你去构建一个应用程序，你会更好地理解模块化是如何工作的，以及我们可以使用的所有东西。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3554" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">参考</h1><div class="pb pc gp gr pd pe"><a href="https://nodejs.org/dist/latest-v12.x/docs/api/modules.html" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">Node.js v12.9.0文档</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">在Node.js模块系统中，每个文件都被视为一个单独的模块。例如，考虑一个名为foo.js的文件…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">nodejs.org</p></div></div></div></a></div></div></div>    
</body>
</html>