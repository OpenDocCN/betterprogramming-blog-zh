<html>
<head>
<title>A Practical Step-by-Step Guide to Understanding Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Kubernetes的实用分步指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-practical-step-by-step-guide-to-understanding-kubernetes-d8be7f82e533?source=collection_archive---------7-----------------------#2020-01-07">https://betterprogramming.pub/a-practical-step-by-step-guide-to-understanding-kubernetes-d8be7f82e533?source=collection_archive---------7-----------------------#2020-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f5a3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">部署分布式应用程序并理解关键的底层概念</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4358c837df9f3a397b89ff89276b5e41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LYK3QE22-yTCXwSthNLJ5Q.jpeg"/></div></div></figure><h2 id="846b" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">快速介绍</h2><p id="9c76" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">简言之，Kubernetes或K8S是一个运行容器化应用程序的开源平台。它广泛的功能使其成为容器编排者的首选。在本帖中，我们将通过实际部署一个应用程序，尝试从实用的角度来学习Kubernetes。在我看来，这样的练习只有在很好地掌握了背后的关键概念之后才会有所收获；因此，我将向您介绍几个概念，并解释它们与应用程序的关系。虽然这篇博客的重点是应用程序架构，但实用的介绍应该对软件架构师、软件开发人员和开发人员也有帮助。</p><p id="1bb7" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">我们将部署上一篇<a class="ae mo" href="https://medium.com/better-programming/building-a-massively-scalable-tinyurl-application-with-python-docker-compose-and-kubernetes-90ff5d4d7f91" rel="noopener">文章</a>中描述的Tinyurl应用程序，在这篇文章中我们简要地提到了Kubernetes。有必要介绍一下TinyURL应用程序的基础知识来建立上下文；现在，这个问题解决了，我们可以完全专注于Kubernetes。<a class="ae mo" href="https://github.com/irnlogic/tiny" rel="noopener ugc nofollow" target="_blank">这里的</a>是本教程的git repo。</p><p id="2bfe" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">对于本教程，我假设您对Docker映像、容器和微服务架构有所了解。如果不是这样，请阅读那篇<a class="ae mo" href="https://medium.com/better-programming/building-a-massively-scalable-tinyurl-application-with-python-docker-compose-and-kubernetes-90ff5d4d7f91" rel="noopener">文章</a>。</p><p id="e445" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">在这里，我们将涵盖Kubernetes的关键概念，跳过此时不重要的细节。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="ac4e" class="mw kv it bd kw mx my mz kz na nb nc lc jz nd ka lg kc ne kd lk kf nf kg lo ng bi translated">Kubernetes:行政观点</h1><p id="eba0" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">首先，快速介绍Kubernetes的机制:K8S集群由主节点和一个或多个工作节点(也称为minions)组成。作为应用程序开发人员，我们使用名为<code class="fe nh ni nj nk b">kubectl</code>的命令行工具与Kubernetes集群通信，该工具通过位于主节点的API服务器执行请求。Kubernetes集群中还有一个etcd分布式弹性键值存储，用于存储关于状态的关键信息和集群运行所需的其他信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/b7f5727170e48ce4bcf63cf914671efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2n7a_9paxCGgdTzaKqqJtA.png"/></div></div><p class="nm nn gj gh gi no np bd b be z dk translated">一个Kubernetes集群(来源:维基百科)</p></figure><p id="bda8" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">注意:为了与Kubernetes集群通信，<a class="ae mo" href="https://kubernetes.io/docs/reference/kubectl/overview/" rel="noopener ugc nofollow" target="_blank"> kubectl </a>命令行工具在$HOME/中查找名为<code class="fe nh ni nj nk b">config</code>的文件。kube目录或环境变量KUBECONFIG指向的文件中。这个配置文件包含您的凭证和要与之对话的集群端点。登录到您的Kubernetes提供商后，您应该能够下载这个文件。我们将使用预先配置了凭证的Google Cloud power shell。</p><p id="7d95" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">像谷歌Kubernetes引擎(GKE)，你应该能够轻松地在其他供应商<a class="ae mo" href="https://kubernetes.io/docs/concepts/cluster-administration/cloud-providers/" rel="noopener ugc nofollow" target="_blank">如微软Azure和亚马逊</a>上部署应用程序。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="4ac1" class="mw kv it bd kw mx my mz kz na nb nc lc jz nd ka lg kc ne kd lk kf nf kg lo ng bi translated">将您的应用程序映射到Kubernetes资源</h1><p id="dad6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">我们想在Kubernetes上部署TinyURL分布式应用程序。它由三个微服务组成:Django TinyURL，一个使用PostgreSQL数据库为最终用户服务的前端，以及一个Redis缓存。因此，如果您遵循最后一条，我们最终会在Docker注册表中获得三个Docker图像(或您自己的等效图像):</p><ul class=""><li id="8616" class="nq nr it ls b lt mj lw mk ld ns lh nt ll nu mi nv nw nx ny bi translated"><code class="fe nh ni nj nk b">irnlogic/djangotinyurl</code></li><li id="5745" class="nq nr it ls b lt nz lw oa ld ob lh oc ll od mi nv nw nx ny bi translated"><code class="fe nh ni nj nk b">irnlogic/postgres</code></li><li id="d4aa" class="nq nr it ls b lt nz lw oa ld ob lh oc ll od mi nv nw nx ny bi translated"><code class="fe nh ni nj nk b">irnlogic/redis</code></li></ul><p id="1ac7" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">在本练习的最后，这三个包含代码+操作系统的Docker映像将被包装在Kubernetes对象中并进行部署。</p><h2 id="b1b1" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">容器</h2><p id="8826" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">通过容器化我们的应用程序，我们有了一个良好的开端(例如，我们为每个服务的代码制作了Docker映像，并将其推送到<a class="ae mo" href="http://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker registry </a>)。我们能够使用Docker Compose在笔记本电脑上将这些图像作为一个单元一起运行。同样，Kubernetes可以在云环境中将图像作为网络容器运行。记住，容器本质上是一个在Docker映像中运行代码的操作系统进程。</p><h2 id="66f9" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">分离舱</h2><p id="ec20" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">容器必须在Kubernetes节点中运行。但是Kubernetes中最小的部署单元是一个Pod，它的行为就像一个虚拟主机，可以有一个或多个容器(固定数量)。pod中的容器共享对pod的相同文件系统和网络的访问。因此他们可以称呼对方为<code class="fe nh ni nj nk b">localhost</code>。</p><p id="8b67" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">例如，可以想象一个有两个容器的pod:一个容器用于应用程序，另一个容器用于收集日志并将其推到一个中心位置。</p><p id="3fe0" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">我们的服务将只有一个集装箱。</p><h2 id="5d9c" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">部署</h2><p id="8390" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">我们可以将Docker映像的单个实例作为pod运行，如下所示:</p><pre class="kj kk kl km gt oe nk of og aw oh bi"><span id="180e" class="ku kv it nk b gy oi oj l ok ol"><em class="om">kubectl run &lt;pod_name&gt; — image=&lt;docker_image_name&gt;</em></span></pre><p id="3ff5" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">为了支持更大的用户群，我们需要运行多个pods实例。我们该怎么做？我们要一个接一个地启动多个豆荚吗？当其中一个崩溃时会发生什么？这是不是意味着我们必须监控每个吊舱？这显然不切实际。因此Kubernetes的部署有助于同时运行多个pod。这里，请求的pod数量称为期望状态。虽然某个时间点的当前状态可能不同—例如，一些pod可能无法启动或已经崩溃— Kubernetes将持续监视部署的状态，并尝试使当前状态尽可能接近所需状态(在部署描述符中指定)。</p><p id="3e24" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">最后，部署只是Kubernetes支持的工作负载类型之一，它非常适合无状态的工作负载，比如我们的前端。</p><h2 id="7a3c" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">服务</h2><p id="ff57" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">接下来，Django web服务器必须与Redis缓存通信。一个部署背后通常有多个pod，因此通过维护一个pod IPs列表来单独处理pod是不切实际的。此外，pod的寿命很短，会被新的pod取代，从而导致以前的IP不再有效。</p><p id="c9f4" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">因此，Kubernetes有一个服务的概念，它通过部署建立可靠的端点，并将传入的请求路由到运行您的代码的pods。</p><p id="69b0" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">我们将创建ClusterIP类型的Kubernetes服务，它通过各自的主机/端口在集群内部公开Redis和PostgreSQL部署。因此，Kubernetes服务提供了一个端点来接收来自消费方的请求。</p><p id="239f" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">接下来，我们还将通过在Django web服务器上放置一个类型为<strong class="ls iu"> </strong>的负载平衡器<strong class="ls iu"> </strong>服务，在公共web上公开Django web服务器，这将创建一个公共IP。请注意，云提供商可能根本不提供负载平衡器。幸运的是，它使用了谷歌云。</p><p id="6521" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">有了它，我们的服务可以扩展、相互通信，并且应用程序可以通过公共IP访问。</p><h2 id="a14b" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">坚持</h2><p id="a896" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">Kubernetes Pods是短暂的，其文件系统上的数据不会在pod的生命周期内存活。因此，数据必须保存到外部存储器。我们可以直接在pod上安装文件系统，但是pod需要直接管理存储端点和凭据。这使得pod依赖于集群，消耗了我们的可移植性。因此，Kubernetes持久卷子系统有助于确保卷的供应/管理与它们在pod中的使用相分离。这就是工作原理。</p><ul class=""><li id="9c24" class="nq nr it ls b lt mj lw mk ld ns lh nt ll nu mi nv nw nx ny bi translated">永久卷(PV)是一个已配置的存储，其生命周期独立于pod。它还抽象出了存储的细节。它是一种群集资源，就像节点一样，只是它提供存储而不是CPU。</li><li id="34ce" class="nq nr it ls b lt nz lw oa ld ob lh oc ll od mi nv nw nx ny bi translated">PersistentVolumeClaim (PVC)是从PV请求特定数量的存储，就像pod从集群节点请求CPU和内存一样。</li></ul><p id="a01c" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">PVs可以由管理员手动调配，也可以由PVC中指定的存储类动态调配。PVC作为卷安装在机架上。当一个pod启动时，一个合格的PV专门与PVC匹配(在此之后，任何其他pod都不能要求它)。在我们的例子中，我们将利用Google Cloud的默认<a class="ae mo" href="https://cloud.google.com/storage/docs/storage-classes" rel="noopener ugc nofollow" target="_blank">存储类</a>为我们的PVC自动提供PV。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="128a" class="mw kv it bd kw mx my mz kz na nb nc lc jz nd ka lg kc ne kd lk kf nf kg lo ng bi translated">配置图</h1><p id="8cd3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">最后，服务必须能够发现彼此，并且是可配置的。例如，Django web服务器需要一个PostgreSQL数据库的主机/端口，它本身可以配置为启用特定的用户和密码。这是通过创建一个包含这些参数的<a class="ae mo" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/" rel="noopener ugc nofollow" target="_blank">配置图</a>并附加到相关部署来完成的。这些参数可以作为相关窗格中的环境变量进行访问。值得注意的是，配置图存储在Kubernetes的etcd服务器中。所以可以看做是一种坚持的形式。</p><p id="3443" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">在Kubernetes中有另一个非常相似的名称-值存储，叫做<a class="ae mo" href="https://kubernetes.io/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank">秘密</a>，适合存储密码。我暂时把那件事留给你。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="e8c0" class="mw kv it bd kw mx my mz kz na nb nc lc jz nd ka lg kc ne kd lk kf nf kg lo ng bi translated">部署工件</h1><p id="f263" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">有了这些信息，我们现在可以开始在Kubernetes上部署我们的应用程序了。这将需要以下条件:</p><ul class=""><li id="d089" class="nq nr it ls b lt mj lw mk ld ns lh nt ll nu mi nv nw nx ny bi translated">三个部署——Django Web server、PostgreSQL和Redis——每个微服务一个。</li><li id="03ad" class="nq nr it ls b lt nz lw oa ld ob lh oc ll od mi nv nw nx ny bi translated"><a class="ae mo" href="https://www.postgresql.org/docs/current/storage-file-layout.html" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>数据库的持久卷和持久卷声明</li><li id="bab0" class="nq nr it ls b lt nz lw oa ld ob lh oc ll od mi nv nw nx ny bi translated">两个ClusterIP类型的服务，使PostgreSQL和Redis对Django web服务器内部可见</li><li id="bc4b" class="nq nr it ls b lt nz lw oa ld ob lh oc ll od mi nv nw nx ny bi translated">一个LoadBalancer类型的服务，使前端Django web服务器可以从互联网访问</li><li id="2023" class="nq nr it ls b lt nz lw oa ld ob lh oc ll od mi nv nw nx ny bi translated">一个ConfigMap声明用于访问PostgreSQL的用户名和密码</li></ul><p id="eb03" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">如果您想知道pod和容器在哪里，部署会隐式地创建pod和容器。</p><p id="1b38" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">Kubernetes中的部署和服务是由单独的YAML文件实例化的，我们将一起研究其中的一些文件。</p><h2 id="0a7a" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">前端部署</strong></h2><p id="fe7c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">部署可以在一个<a class="ae mo" href="https://github.com/irnlogic/tiny/blob/master/kubernetes/frontend-deployment.yaml" rel="noopener ugc nofollow" target="_blank"> yaml </a>中声明。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="c9ad" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated"><code class="fe nh ni nj nk b">Kind: Deployment</code>表示这是一个<a class="ae mo" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">部署</a>。选择器下的<code class="fe nh ni nj nk b">matchLabels</code>(第7行)告诉deployment查找标签为app=tinywebsite和tier= frontend的所有pod，并将它们视为属于该部署。生产线<code class="fe nh ni nj nk b">replicas: 3</code>要求部署三个吊舱(期望的状态)。模板部分声明了组成部署的单元的结构。这里，请求了一个名为<code class="fe nh ni nj nk b">tinywebsite</code>的容器(第18行)。请注意，容器标记下面的项是可能数组的一部分；我们只是碰巧有一个项目，因此，一个容器。行图像<code class="fe nh ni nj nk b">irnlogic/djangotinyurl:1.0</code>指定了容器的docker图像。同样，这个容器监听端口8001，需要1个<a class="ae mo" href="https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#meaning-of-cpu" rel="noopener ugc nofollow" target="_blank"> CPU </a>和128 <a class="ae mo" href="https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#meaning-of-memory" rel="noopener ugc nofollow" target="_blank"> MB </a>内存。</p><p id="28eb" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated"><code class="fe nh ni nj nk b">metadata</code>部分(第12行)将标签分配给pods它们与部署中的窗格选择器完全匹配(第7行)。</p><p id="d358" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">您可能想知道为什么我们不能同时声明pod和deployment的标签。这有几个原因。首先，在template/metadata部分，您可能分配了比部署的pod选择器所需更多的标签(例如，出于可观察性的原因，language=python)。其次，Kubernetes遵循pods和其他资源(如部署和服务)之间的松散耦合原则，这提供了一些设计优势，我们暂时不会深入研究。</p><p id="518f" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">在我们继续之前，还有一个信息:前端服务将使用Redis和PostgreSQL服务。例如，与Redis的连接如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="92fc" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">在第18行，名称<code class="fe nh ni nj nk b">redis</code>被用作Redis服务的主机名。主机名是如何解析的？。这就是Kubernetes服务的美妙之处，它建立了一个带有<a class="ae mo" href="https://github.com/irnlogic/tiny/blob/master/kubernetes/redis-service.yaml" rel="noopener ugc nofollow" target="_blank">服务名</a>的内部DNS条目，服务名恰好是<code class="fe nh ni nj nk b">redis</code>(我们可以使用ConfigMaps来配置和读取Redis服务名，但是为了更容易读取，我没有这样做)。</p><h2 id="85a1" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">前端服务</h2><p id="ca4c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">frontend.yaml位于<a class="ae mo" href="https://github.com/irnlogic/tiny/blob/master/kubernetes/frontend-service.yaml" rel="noopener ugc nofollow" target="_blank">这里</a>并创建一个前端部署上的服务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="4f36" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">以下是该服务定义的关键要素</p><ul class=""><li id="b5f3" class="nq nr it ls b lt mj lw mk ld ns lh nt ll nu mi nv nw nx ny bi translated"><code class="fe nh ni nj nk b">kind: service</code>确定这是服务资源请求</li><li id="593f" class="nq nr it ls b lt nz lw oa ld ob lh oc ll od mi nv nw nx ny bi translated"><code class="fe nh ni nj nk b">metadata</code> / <code class="fe nh ni nj nk b">name</code>是服务的名称，<code class="fe nh ni nj nk b">metadata</code>/<strong class="ls iu">/</strong>/<code class="fe nh ni nj nk b">labels</code>给服务分配标签(您可以在这里提供任何标签)</li><li id="2e80" class="nq nr it ls b lt nz lw oa ld ob lh oc ll od mi nv nw nx ny bi translated"><code class="fe nh ni nj nk b">spec</code> / <code class="fe nh ni nj nk b">type</code>是<code class="fe nh ni nj nk b">LoadBalancer</code>；这将导致为此服务创建一个外部IP，使其可以公开访问</li><li id="cfb0" class="nq nr it ls b lt nz lw oa ld ob lh oc ll od mi nv nw nx ny bi translated"><code class="fe nh ni nj nk b">spec</code> / <code class="fe nh ni nj nk b">selector</code>声明选择器，这些选择器标识服务后面的pod，它们与<a class="ae mo" href="https://github.com/irnlogic/tiny/blob/master/kubernetes/frontend-deployment.yaml" rel="noopener ugc nofollow" target="_blank">部署</a>中指定的标签完全匹配。</li></ul><p id="5183" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">服务部署后，我们的应用程序就可以公开访问了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/4714a214c9d49c47c67296cfa85cbffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uqHfnC8CTcfLhr-6XAGK-Q.png"/></div></div><p class="nm nn gj gh gi no np bd b be z dk translated">前端微服务:Pod/部署/服务</p></figure><p id="5e09" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">此外，我们现在已经完全指定了我们的前端微服务，并且必须为其他服务做同样的事情。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="bbb2" class="mw kv it bd kw mx my mz kz na nb nc lc jz nd ka lg kc ne kd lk kf nf kg lo ng bi translated">用于PostgreSQL存储的PVC</h1><p id="9ed7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated"><a class="ae mo" href="https://github.com/irnlogic/tiny/blob/master/kubernetes/postgres-pvc.yaml" rel="noopener ugc nofollow" target="_blank">这个</a>是持久卷声明，请求存储我们的PostgreSQL数据库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="c2a0" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated"><code class="fe nh ni nj nk b">kind: PersistentVolumeClaim</code>表示Kubernetes资源类型，而<code class="fe nh ni nj nk b">ReadWriteOnce</code>表示只有一个pod可以访问这个pod。这就足够了；将来，我们将使用<a class="ae mo" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank">状态集</a>来改善这种情况。很明显，请求了10GB的存储，根据元数据，PVC的段名将是<code class="fe nh ni nj nk b">posgres-disk</code>。</p><p id="cad0" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">接下来，我们将在PostgreSQL pod中挂载请求的存储。</p><h2 id="d28b" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">PostgreSQL部署</h2><p id="90a8" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">这里的PostgreSQL部署类似于我们前面看到的前端部署，只是这个部署装载了一个卷。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><ul class=""><li id="88c2" class="nq nr it ls b lt mj lw mk ld ns lh nt ll nu mi nv nw nx ny bi translated">最底部的volumes部分引用了我们之前创建的<code class="fe nh ni nj nk b">postgres-disk</code> <strong class="ls iu"> </strong> PVC。</li><li id="f165" class="nq nr it ls b lt nz lw oa ld ob lh oc ll od mi nv nw nx ny bi translated">然后，卷在<code class="fe nh ni nj nk b">volumeMounts</code>部分安装到<code class="fe nh ni nj nk b">/var/lib/postgresql/</code>。<code class="fe nh ni nj nk b">postgres</code>被配置为在<code class="fe nh ni nj nk b">/var/lib/postgresql/data</code>保存数据，因此将根据需要在挂载位置创建一个数据文件夹。</li><li id="56e3" class="nq nr it ls b lt nz lw oa ld ob lh oc ll od mi nv nw nx ny bi translated"><code class="fe nh ni nj nk b">configMapRef</code>将<a class="ae mo" href="https://github.com/irnlogic/tiny/blob/master/kubernetes/postgres-configmap.yaml" rel="noopener ugc nofollow" target="_blank">postgres-config</a>config map中的名称-值对加载到<code class="fe nh ni nj nk b">postgres</code> pod的环境变量中，建立默认的数据库名称、用户名和密码。</li><li id="2b0c" class="nq nr it ls b lt nz lw oa ld ob lh oc ll od mi nv nw nx ny bi translated">请参见下面的配置映射定义；注意配置映射名称<code class="fe nh ni nj nk b">postgres-config</code>和<code class="fe nh ni nj nk b">data</code>部分下的名称-值对。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="0165" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">下图展示了预期的PostgreSQL服务及其部署和持久卷(PV)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/5639f096b92706e1ece54ddf8335b32e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S-s8RWvCKLZKTUeLBt57Jw.png"/></div></div><p class="nm nn gj gh gi no np bd b be z dk translated">PostgreSQL微服务:Pod/部署/服务</p></figure><p id="bdbf" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">其他服务和部署同样在这里声明<a class="ae mo" href="https://github.com/irnlogic/tiny/tree/master/kubernetes" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="fcba" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">部署完所有的应用程序服务和工作负载后，我们应该做出如下安排。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/4606343dc0af2f5250613ad27f00a2ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_5voVn8H3rogsnE5NHiuOQ.png"/></div></div><p class="nm nn gj gh gi no np bd b be z dk translated">部署的拓扑</p></figure><p id="18e8" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">用户可以通过公共IP地址访问应用前端。负载平衡器服务创建一个公共IP，将传入请求路由到一个前端pod。前端pod依次与Redis和PostgreSQL进行通信，如<service name=""> : <port>，例如redis:6379。回想一下，Redis和PostgreSQL服务的类型是ClusterIP(默认情况下)，它建立与它们的服务名相同的内部DNS条目。它们还向后面的pod请求负载平衡。</port></service></p><p id="16a1" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">最后，显示的所有三个应用程序工作负载都托管在集群节点中。同样，PostgreSQL pod上装载的PersistentVolumeRequest (PVC)映射到集群中的PersistentVolume (PV)。值得再次重申的是，相对于节点和PV等集群资源而言，pod等应用程序工作负载是短暂的。</p><p id="2826" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">还有另一种方式来查看上面展示的拓扑结构:容器(蓝框)中的代码已经嵌入到Kubernetes工件中，以进行部署和伸缩！</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="6470" class="mw kv it bd kw mx my mz kz na nb nc lc jz nd ka lg kc ne kd lk kf nf kg lo ng bi translated">部署应用程序</h1><p id="e033" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">一旦配置了Kubernetes集群，我们就可以开始部署了。参见此<a class="ae mo" href="https://github.com/irnlogic/tiny/blob/master/kubernetes/README.md" rel="noopener ugc nofollow" target="_blank">文档</a>查看先决条件，克隆<a class="ae mo" href="https://github.com/irnlogic/tiny.git" rel="noopener ugc nofollow" target="_blank">https://github.com/irnlogic/tiny.git</a>，然后转到<code class="fe nh ni nj nk b">kubernetes</code>文件夹。</p><p id="0d17" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">如果文件中指定的资源不存在，下面使用的<code class="fe nh ni nj nk b">kubectl</code>apply命令将创建该资源，并将任何已更改的配置应用于该资源。我们将逐一部署三项服务。</p><h2 id="358a" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">部署redis</h2><pre class="kj kk kl km gt oe nk of og aw oh bi"><span id="024c" class="ku kv it nk b gy oi oj l ok ol">kubectl apply -f redis-deployment.yaml<br/>kubectl apply -f redis-service.yaml</span></pre><h2 id="e147" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">部署postgres</h2><pre class="kj kk kl km gt oe nk of og aw oh bi"><span id="5cde" class="ku kv it nk b gy oi oj l ok ol">kubectl apply -f postgres-pvc.yaml<br/>kubectl apply -f postgres-configmap.yaml<br/>kubectl apply -f postgres-deployment.yaml<br/>kubectl apply -f postgres-service.yaml</span></pre><h2 id="dcff" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">部署前端</h2><pre class="kj kk kl km gt oe nk of og aw oh bi"><span id="4821" class="ku kv it nk b gy oi oj l ok ol">kubectl apply -f frontend-deployment.yaml<br/>kubectl apply -f frontend-service.yaml</span></pre><p id="8648" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">请求的部署和服务将在几分钟内创建，包括一个负载均衡器服务，它将TinyURL前端公开给公共互联网。</p><p id="3af7" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">现在列出在Kubernetes部署的服务:</p><pre class="kj kk kl km gt oe nk of og aw oh bi"><span id="c983" class="ku kv it nk b gy oi oj l ok ol">kubectl get services</span></pre><p id="213e" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">您应该会看到如下内容:</p><pre class="kj kk kl km gt oe nk of og aw oh bi"><span id="efc1" class="ku kv it nk b gy oi oj l ok ol">NAME         TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE<br/>frontend     LoadBalancer   10.38.14.217   37.230.9.73   8001:30080/TCP   58s<br/>kubernetes   ClusterIP      10.98.2.1      &lt;none&gt;        443/TCP          12m<br/>postgres     ClusterIP      10.98.8.269    &lt;none&gt;        5432/TCP         2m8s<br/>redis        ClusterIP      10.96.11.24    &lt;none&gt;        6379/TCP         3m57s</span></pre><p id="9bed" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">使用以下公共地址启动TinyURL应用程序:<a class="ae mo" href="http://external-ip:8001/" rel="noopener ugc nofollow" target="_blank"> http://EXTERNAL-IP:8001 </a>(用上面获得的IP替换EXTERNAL-IP)。万岁。我们完蛋了！</p><p id="bc8b" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">这里看到的是应用程序的示例浏览器屏幕截图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/731379bbc39bba30b8b96b87ca8284dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TKqD9vV_7N4sWR5fGZ6qiQ.png"/></div></div><p class="nm nn gj gh gi no np bd b be z dk translated">Tinyurl应用程序输出</p></figure><p id="e29e" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">稍后，我将发布一些有关基本故障排除和Kubernetes Cluster的进一步探索的提示。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="bf45" class="mw kv it bd kw mx my mz kz na nb nc lc jz nd ka lg kc ne kd lk kf nf kg lo ng bi translated">结论</h1><p id="aa32" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">有了这些，我们回顾了各种Kubernetes资源，将我们的应用程序服务连接到这些资源，并成功地部署了TinyURL应用程序！</p><p id="8002" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">一些瓶颈在我们的应用程序中是显而易见的，例如，我们有一个PostgreSQL数据库的实例。未来，我们应该计划一次性能测试，并逐个消除瓶颈。</p><p id="7e2c" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated"><strong class="ls iu">更新</strong>:如果你在运行应用程序的时候遇到了问题，我写了这个<a class="ae mo" href="https://medium.com/better-programming/5-easy-tips-for-troubleshooting-your-kubernetes-pods-34f594e03ba6" rel="noopener">帖子</a>来帮助你排除Pods的故障<a class="ae mo" href="https://medium.com/better-programming/debug-your-kubernetes-service-in-5-easy-steps-1457974f024c" rel="noopener">这个</a>的帖子要分配给调试服务部。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="bfaf" class="mw kv it bd kw mx my mz kz na nb nc lc jz nd ka lg kc ne kd lk kf nf kg lo ng bi translated">进一步参考</h1><ul class=""><li id="ce26" class="nq nr it ls b lt lu lw lx ld ot lh ou ll ov mi nv nw nx ny bi translated"><a class="ae mo" href="https://kubernetes.io/docs/home/" rel="noopener ugc nofollow" target="_blank">https://kubernetes.io/docs/home/</a></li><li id="7ee2" class="nq nr it ls b lt nz lw oa ld ob lh oc ll od mi nv nw nx ny bi translated"><a class="ae mo" href="https://github.com/kelseyhightower/kubernetes-the-hard-way" rel="noopener ugc nofollow" target="_blank">https://github.com/kelseyhightower/kubernetes-the-hard-way</a></li><li id="a965" class="nq nr it ls b lt nz lw oa ld ob lh oc ll od mi nv nw nx ny bi translated"><a class="ae mo" href="https://www.weave.works/blog/kubernetes-best-practices" rel="noopener ugc nofollow" target="_blank">https://www.weave.works/blog/kubernetes-best-practices</a></li></ul></div></div>    
</body>
</html>