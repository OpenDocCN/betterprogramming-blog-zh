<html>
<head>
<title>How To Integrate an Apollo GraphQL Server with MongoDB and TypeScript Code Generator (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将Apollo GraphQL服务器与MongoDB和TypeScript代码生成器集成在一起(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-integrate-an-apollo-graphql-server-with-mongodb-and-typescript-code-generator-b029d821591?source=collection_archive---------1-----------------------#2019-12-08">https://betterprogramming.pub/how-to-integrate-an-apollo-graphql-server-with-mongodb-and-typescript-code-generator-b029d821591?source=collection_archive---------1-----------------------#2019-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b6a9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Apollo GraphQL服务器与TypeScript系列的第二部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b5d23abe54af56d843adea234677cb05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LcLhmTD7obP5wmbk2zAdKQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Moanalua_Gardens" rel="noopener ugc nofollow" target="_blank">日立树</a>(图片来源:<a class="ae ky" href="http://derekfong.me" rel="noopener ugc nofollow" target="_blank">方志伟</a>)</p></figure><p id="be1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是<em class="lv"> Apollo GraphQL: How-To </em>系列的<strong class="lb iu">部分2 </strong>:</p><ul class=""><li id="76ff" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><strong class="lb iu">第1部分:</strong> <a class="ae ky" href="https://medium.com/free-code-camp/build-an-apollo-graphql-server-with-typescript-and-webpack-hot-module-replacement-hmr-3c339d05184f" rel="noopener">如何用TypeScript和Webpack热模块替换构建Apollo GraphQL服务器</a></li><li id="05fa" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">第2部分:</strong> <strong class="lb iu">如何将Apollo GraphQL服务器与MongoDB和TypeScript代码生成器集成在一起</strong></li><li id="4dfc" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">…更多即将推出！</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="a80a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将Apollo GraphQL Server与MongoDB和TypeScript Codegen集成起来！</p><p id="da25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的上一篇<a class="ae ky" href="https://medium.com/free-code-camp/build-an-apollo-graphql-server-with-typescript-and-webpack-hot-module-replacement-hmr-3c339d05184f" rel="noopener">文章</a>中，我展示了如何使用我在产品应用中使用的一套工具和设计概念来构建一个“Hello Word”Apollo服务器。在这篇文章中，我们将继续这个话题，配置Apollo服务器与MongoDB(或您选择的任何数据库)通信，并利用<a class="ae ky" href="https://graphql-code-generator.com" rel="noopener ugc nofollow" target="_blank"> GraphQL代码生成器</a>来改进开发工作流。</p><p id="7dd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，我们开始吧！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="53ed" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">1.召唤希腊神</h1><p id="0cda" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在这篇文章中，我们将使用我上一篇文章中的“Hello World”阿波罗服务器<a class="ae ky" href="https://medium.com/free-code-camp/build-an-apollo-graphql-server-with-typescript-and-webpack-hot-module-replacement-hmr-3c339d05184f" rel="noopener">作为起点。你可以</a><a class="ae ky" href="https://github.com/derek-fong/demo-apollo-server-webpack-hmr" rel="noopener ugc nofollow" target="_blank">从GitHub </a>克隆我的库，或者如果你需要任何设置的详细说明，请参考<a class="ae ky" href="https://github.com/derek-fong/demo-apollo-server-webpack-hmr" rel="noopener ugc nofollow" target="_blank">我的上一篇帖子</a>。</p><p id="d7aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦<a class="ae ky" href="https://github.com/derek-fong/demo-apollo-server-webpack-hmr" rel="noopener ugc nofollow" target="_blank">克隆了存储库</a>，快速测试“Hello World”Apollo服务器是否运行:</p><p id="dad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 1。安装包依赖项:</strong></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="a933" class="nt ms it np b gy nu nv l nw nx">$ npm install</span></pre><p id="9c63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.在项目根目录下添加一个新的<code class="fe ny nz oa np b">.env</code>文件:</p><p id="2c90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">.env</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="2dd9" class="nt ms it np b gy nu nv l nw nx">APOLLO_INTROSPECTION=true<br/>APOLLO_PLAYGROUND=true</span></pre><p id="9b7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.在<code class="fe ny nz oa np b">development</code>模式下构建应用程序:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="9a84" class="nt ms it np b gy nu nv l nw nx">$ NODE_ENV=development npm run build</span></pre><p id="653e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.打开一个新的终端，用<code class="fe ny nz oa np b">.env</code>启动Apollo服务器。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="4458" class="nt ms it np b gy nu nv l nw nx">$ npm run start:env</span></pre><p id="69ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.一旦服务器启动并运行，启动<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/testing/graphql-playground/" rel="noopener ugc nofollow" target="_blank"> GraphQL Playground </a>(默认为<a class="ae ky" href="http://localhost:4000" rel="noopener ugc nofollow" target="_blank"> http://localhost:4000 </a>)并运行一个测试查询。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="d79d" class="nt ms it np b gy nu nv l nw nx">{<br/>  testMessage<br/>}</span></pre><p id="3b40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该看到服务器返回查询结果:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="2bf1" class="nt ms it np b gy nu nv l nw nx">{<br/>  "data": {<br/>    "testMessage": "Hello World!"<br/>  }<br/>}</span></pre><p id="4755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">酷！我们现在已经确认我们的服务器已经启动并运行。但是它还没有做太多。</p><p id="83d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把它变得更有用，更有趣！</p><h1 id="a4c8" class="mr ms it bd mt mu ob mw mx my oc na nb jz od ka nd kc oe kd nf kf of kg nh ni bi translated">2.故事</h1><p id="fe84" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">目前，我们的Apollo服务器将总是为每个<code class="fe ny nz oa np b">testMessage</code>查询返回硬编码的<code class="fe ny nz oa np b">Hello World!</code>——这有点无聊。我们将把我们的“Hello Word”Apollo服务器转换成简化的<a class="ae ky" href="https://medium.com/" rel="noopener">中型</a>克隆:</p><ul class=""><li id="64b1" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><code class="fe ny nz oa np b">User</code>包含<code class="fe ny nz oa np b">first name</code>、<code class="fe ny nz oa np b">last name</code>、<code class="fe ny nz oa np b">e-mail address</code>等个人详细信息。</li><li id="b6d8" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ny nz oa np b">Post</code>包含一个<code class="fe ny nz oa np b">title</code>、<code class="fe ny nz oa np b">content</code>、<code class="fe ny nz oa np b">published date</code>和<code class="fe ny nz oa np b">author</code>。</li><li id="f341" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ny nz oa np b">User</code>可以发布任意数量的<code class="fe ny nz oa np b">posts</code>。</li><li id="fbd9" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ny nz oa np b">User</code>可以跟随其他<code class="fe ny nz oa np b">users</code>。</li><li id="cb9d" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ny nz oa np b">User</code>可以喜欢任何<code class="fe ny nz oa np b">posts</code>。</li></ul><p id="f02f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于上面的描述，我们可以开始围绕<code class="fe ny nz oa np b">Users</code>和<code class="fe ny nz oa np b">Posts</code>实体构建我们的Apollo服务器，有一组<code class="fe ny nz oa np b"><a class="ae ky" href="https://graphql.org/learn/queries/" rel="noopener ugc nofollow" target="_blank">queries</a></code> <a class="ae ky" href="https://graphql.org/learn/queries/" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe ny nz oa np b"><a class="ae ky" href="https://graphql.org/learn/queries/" rel="noopener ugc nofollow" target="_blank">mutations</a></code>可以与之交互。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/40980a9703145ce0f6d8aa593dbd0af2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KU5eA_PqdzPLHJU2qR7qyQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">人生是一段旅程(图片来源:<a class="ae ky" href="https://www.rawpixel.com" rel="noopener ugc nofollow" target="_blank"> rawpixel </a>)</p></figure><h1 id="01f4" class="mr ms it bd mt mu ob mw mx my oc na nb jz od ka nd kc oe kd nf kf of kg nh ni bi translated">3.模式优先！</h1><p id="bc4f" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">现在我们已经有了构建什么的想法，是时候将我们的想法收集到代码中了！</p><p id="1e0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">概括地说，GraphQL服务器由两个主要组件组成:</p><ul class=""><li id="415a" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/schema/schema" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">模式</strong> </a> : <em class="lv">什么类型的数据可用。</em></li><li id="b447" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/data/data" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">解析器</strong> </a> : <em class="lv">如何构造</em>数据。</li></ul><p id="11d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从定义服务器的<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/schema/schema" rel="noopener ugc nofollow" target="_blank">模式</a>开始。</p><p id="c62e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的上一篇文章中，我们在名为<code class="fe ny nz oa np b">type-defs.ts</code>的类型脚本文件中定义了我们的模式。在使用TypeScript编写模式的同时，我们也可以在<code class="fe ny nz oa np b">.graphql</code>文件中编写我们的模式，以获得更好的IDE支持，这要感谢使用 <code class="fe ny nz oa np b"><a class="ae ky" href="https://github.com/apollographql/graphql-tag#webpack-preprocessing-with-graphql-tagloader" rel="noopener ugc nofollow" target="_blank">graphql-tag/loader</a></code>的<a class="ae ky" href="https://github.com/apollographql/graphql-tag#webpack-preprocessing-with-graphql-tagloader" rel="noopener ugc nofollow" target="_blank"> Webpack处理。如果你跟随上一篇文章</a>中的<a class="ae ky" href="https://github.com/derek-fong/demo-apollo-server-webpack-hmr" rel="noopener ugc nofollow" target="_blank">我的示例代码，那么<code class="fe ny nz oa np b">.graphql</code> Webpack加载器</a><a class="ae ky" href="https://github.com/derek-fong/demo-apollo-server-webpack-hmr/blob/master/webpack.common.js#L11-L15" rel="noopener ugc nofollow" target="_blank">已经预先配置好了</a>。如果没有，只需遵循本指南中的几行代码就可以启用Webpack <code class="fe ny nz oa np b">.graphql</code>预处理。</p><p id="cc70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们删除<code class="fe ny nz oa np b">/src</code>文件夹中的<code class="fe ny nz oa np b">type-def.ts</code>和<code class="fe ny nz oa np b">resolvers.ts</code>，并创建一个名为<code class="fe ny nz oa np b">type-defs.graphql</code>的文件。</p><p id="c5d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">src/type-defs.graphql</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="17d6" class="nt ms it np b gy nu nv l nw nx">type User {<br/>  """<br/>  User ID.<br/>  """<br/>  id: ID!<br/><br/>  """<br/>  User's first name.<br/>  """<br/>  firstName: String!<br/><br/>  """<br/>  User's last name.<br/>  """<br/>  lastName: String!<br/><br/>  # User's e-mail address.<br/>  # email: TODO: Define type.<br/><br/>  """<br/>  Posts published by user.<br/>  """<br/>  posts: [Post]<br/><br/>  """<br/>  Users that this user is following.<br/>  """<br/>  following: [User]<br/><br/>  """<br/>  Users that this user is followed by.<br/>  """<br/>  followers: [User]<br/>}<br/><br/>type Post {<br/>  """<br/>  Post ID.<br/>  """<br/>  id: ID!<br/><br/>  """<br/>  Post title.<br/>  """<br/>  title: String!<br/><br/>  """<br/>  Post content.<br/>  """<br/>  content: String!<br/><br/>  """<br/>  Post Author.<br/>  """<br/>  author: User!<br/><br/>  # Post published timestamp.<br/>  # publishedAt: TODO: Define type.<br/><br/>  """<br/>  Users who like this post.<br/>  """<br/>  likedBy: [User]<br/>}<br/><br/>type Query {<br/>  """<br/>  Get post by ID.<br/>  """<br/>  post(id: ID!): Post<br/>}<br/><br/>"""<br/>Publish post input.<br/>"""<br/>input PublishPostInput {<br/>  """<br/>  Post title.<br/>  """<br/>  title: String!<br/><br/>  """<br/>  Post content.<br/>  """<br/>  content: String!<br/>}<br/><br/>type Mutation {<br/>  """<br/>  Publish post.<br/>  """<br/>  publishPost(input: PublishPostInput!): Post!<br/><br/>  """<br/>  Follow user.<br/>  Returns the updated number of followers.<br/>  """<br/>  followUser(<br/>    """<br/>    User's ID to follow.<br/>    """<br/>    userId: ID!<br/>  ): Int!<br/><br/>  """<br/>  Unfollow user.<br/>  Returns the updated number of followers.<br/>  """<br/>  unfollowUser(<br/>    """<br/>    User's ID to unfollow.<br/>    """<br/>    userId: ID!<br/>  ): Int!<br/><br/>  """<br/>  Like post.<br/>  Returns the updated number of likes received.<br/>  """<br/>  likePost(<br/>    """<br/>    Post's ID to like.<br/>    """<br/>    postId: ID!<br/>  ): Int!<br/>}</span></pre><p id="0ea1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后更新<code class="fe ny nz oa np b">main.ts</code>。</p><p id="63c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">src/main.ts</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="bb6d" class="nt ms it np b gy nu nv l nw nx">import { ApolloServer } from 'apollo-server';<br/><br/>import { environment } from './environment';<br/>import * as typeDefs from './type-defs.graphql';<br/><br/>const server = new ApolloServer({<br/>  typeDefs,<br/>  introspection: environment.apollo.introspection,<br/>  mocks: true, // TODO: Remove in PROD.<br/>  mockEntireSchema: false, // TODO: Remove in PROD.<br/>  playground: environment.apollo.playground,<br/>});<br/><br/>server<br/>  .listen(environment.port)<br/>  .then(({ url }) =&gt; console.log(`Server ready at ${url}. `));<br/><br/>if (module.hot) {<br/>  module.hot.accept();<br/>  module.hot.dispose(() =&gt; server.stop());<br/>}</span></pre><ul class=""><li id="6ad8" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">第4行:我们从一个<code class="fe ny nz oa np b">.graphql</code>文件中导入类型定义。</li><li id="7b91" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">第9行:</strong>我们从Apollo服务器启用了<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/testing/mocking/#default-mock-example" rel="noopener ugc nofollow" target="_blank">默认模仿</a>特性。当我们想快速测试我们的GraphQL模式而不需要编写一行解析器代码时，这非常方便！</li><li id="74cc" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">第10行:</strong>虽然我们已经启用了模拟，但是我们已经<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/api/apollo-server" rel="noopener ugc nofollow" target="_blank">禁用了模拟整个模式</a>。如果解析器被定义为完成一个查询(或变异)，Apollo Server将尝试返回这些值，并将只为无法解析的字段返回一个模拟值。这允许我们增量地实现我们的解析器(您将在本文的后面看到这一点)。</li></ul><p id="a0e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您尝试构建应用程序，将会遇到以下错误:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="af3c" class="nt ms it np b gy nu nv l nw nx">$ NODE_ENV=development npm run build</span><span id="198e" class="nt ms it np b gy oh nv l nw nx">&gt; TS2307: Cannot find module './type-defs.graphql'.</span></pre><p id="5ff8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，<a class="ae ky" href="https://dev.to/open-graphql/how-to-resolve-import-for-the-graphql-file-with-typescript-and-webpack-35lf" rel="noopener ugc nofollow" target="_blank">在</a> <code class="fe ny nz oa np b"><a class="ae ky" href="https://dev.to/open-graphql/how-to-resolve-import-for-the-graphql-file-with-typescript-and-webpack-35lf" rel="noopener ugc nofollow" target="_blank">/src</a></code> <a class="ae ky" href="https://dev.to/open-graphql/how-to-resolve-import-for-the-graphql-file-with-typescript-and-webpack-35lf" rel="noopener ugc nofollow" target="_blank">目录</a>中添加一个名为 <code class="fe ny nz oa np b"><a class="ae ky" href="https://dev.to/open-graphql/how-to-resolve-import-for-the-graphql-file-with-typescript-and-webpack-35lf" rel="noopener ugc nofollow" target="_blank">graphql.d.ts</a></code> <a class="ae ky" href="https://dev.to/open-graphql/how-to-resolve-import-for-the-graphql-file-with-typescript-and-webpack-35lf" rel="noopener ugc nofollow" target="_blank">的文件:</a></p><p id="2b6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">src/graphql.d.ts</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="1a44" class="nt ms it np b gy nu nv l nw nx">declare module '*.graphql' {<br/>  import { DocumentNode } from 'graphql';<br/><br/>  const value: DocumentNode;<br/>  export = value;<br/>}</span></pre><p id="c75d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你重新运行<code class="fe ny nz oa np b">NODE_ENV=development npm run build</code>和<code class="fe ny nz oa np b">npm run start:env</code>，阿波罗服务器应该再次启动并运行。</p><p id="1c74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们通过在Apollo服务器的<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/testing/graphql-playground" rel="noopener ugc nofollow" target="_blank"> GraphQL Playground </a>中运行以下查询来测试我们的模式:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="77ae" class="nt ms it np b gy nu nv l nw nx">{<br/>  post(id: "TEST_ID") {<br/>    id<br/>    title<br/>    content<br/>    author {<br/>      id<br/>      firstName<br/>      lastName<br/>      followers {<br/>        id<br/>        firstName<br/>        lastName<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="df15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它应该会返回类似如下的结果:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="f4da" class="nt ms it np b gy nu nv l nw nx">{<br/>  "data": {<br/>    "post": {<br/>      "id": "2e6530bc-aa08-4222-b666-9984dfcabbe5",<br/>      "title": "Hello World",<br/>      "content": "Hello World",<br/>      "author": {<br/>        "id": "92f90af0-3388-4c2b-8484-80a116cfe2a5",<br/>        "firstName": "Hello World",<br/>        "lastName": "Hello World",<br/>        "followers": [<br/>          {<br/>            "id": "0efca26d-6857-4af6-8373-79b406891992",<br/>            "firstName": "Hello World",<br/>            "lastName": "Hello World"<br/>          },<br/>          {<br/>            "id": "952fabad-cbdd-47cb-badd-ae3678ec3c4b",<br/>            "firstName": "Hello World",<br/>            "lastName": "Hello World"<br/>          }<br/>        ]<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="5c59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ny nz oa np b">String</code>字段由一些随机文本填充(在本例中为<em class="lv"> Hello World </em>)，而<code class="fe ny nz oa np b">id</code>字段由随机的<code class="fe ny nz oa np b"><a class="ae ky" href="https://tools.ietf.org/html/rfc4122" rel="noopener ugc nofollow" target="_blank">UUID</a></code>填充。我们通过启用Apollo Server的<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/testing/mocking" rel="noopener ugc nofollow" target="_blank">模仿</a>功能实现了这一点，甚至无需编写一行解析器代码。神奇！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="2ebe" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">4.添加自定义标量</h1><p id="16ea" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在这个阶段，我们的模式由具有GraphQL的<a class="ae ky" href="https://graphql.org/graphql-js/basic-types" rel="noopener ugc nofollow" target="_blank">基本类型</a>的字段组成。但是像<code class="fe ny nz oa np b">published date</code>、<code class="fe ny nz oa np b">e-mail address</code>等字段呢？</p><p id="1730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然您可以自己实现<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/schema/scalars-enums/#gatsby-focus-wrapper" rel="noopener ugc nofollow" target="_blank">自定义标量</a>，但是当有人已经为您做了艰苦的工作时，为什么还要重新发明轮子呢？</p><p id="e6be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看<code class="fe ny nz oa np b"><a class="ae ky" href="https://github.com/Urigo/graphql-scalars" rel="noopener ugc nofollow" target="_blank">graphql-scalars</a></code>—“<em class="lv">自定义GraphQL标量库，用于创建精确的类型安全GraphQL模式”</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/38d2afe9359de2e53a280da4f4e7853f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xQD89oYhWGEpPDTa0ejNTA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GraphQL标量(图片来源:<a class="ae ky" href="https://github.com/Urigo/graphql-scalars" rel="noopener ugc nofollow" target="_blank"> GitHub </a>)</p></figure><p id="f56f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用这个库中的一些标量。让我们安装这个包。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="939e" class="nt ms it np b gy nu nv l nw nx">$ npm install --save <!-- -->graphql-scalars</span></pre><p id="311c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该库的README非常简单明了，但是让我们一起完成这些步骤，以确保我们在同一页上。</p><h2 id="0b09" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 1。向模式添加标量</strong></h2><p id="fe6f" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在我们的模式文件<code class="fe ny nz oa np b">type-defs.graphql</code>中，用语法<code class="fe ny nz oa np b">scalar TypeName</code>声明<code class="fe ny nz oa np b">DateTime</code>和<code class="fe ny nz oa np b">EmailAddress</code>标量。然后我们可以在<code class="fe ny nz oa np b">User</code>的<code class="fe ny nz oa np b">email</code>字段和<code class="fe ny nz oa np b">Post</code>的<code class="fe ny nz oa np b">publishedAt</code>字段中使用标量类型。</p><p id="a2c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于突变，我们将<code class="fe ny nz oa np b">followUser</code>、<code class="fe ny nz oa np b">unfollowUser</code>和<code class="fe ny nz oa np b">likePost</code>的返回类型从<code class="fe ny nz oa np b">Int</code>替换为<code class="fe ny nz oa np b">UnsignedInt</code>，因为计数必须为非负整数。</p><p id="0ea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">src/type-defs.graphql</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="ad6c" class="nt ms it np b gy nu nv l nw nx">scalar DateTime<br/>scalar EmailAddress<br/>scalar UnsignedInt<br/><br/>type User {<br/>  """<br/>  User ID.<br/>  """<br/>  id: ID!<br/><br/>  """<br/>  User's first name.<br/>  """<br/>  firstName: String!<br/><br/>  """<br/>  User's last name.<br/>  """<br/>  lastName: String!<br/><br/>  """<br/>  User's e-mail address.<br/>  """<br/>  email: EmailAddress<br/><br/>  """<br/>  Posts published by user.<br/>  """<br/>  posts: [Post]<br/><br/>  """<br/>  Users that this user is following.<br/>  """<br/>  following: [User]<br/><br/>  """<br/>  Users that this user is followed by.<br/>  """<br/>  followers: [User]<br/>}<br/><br/>type Post {<br/>  """<br/>  Post ID.<br/>  """<br/>  id: ID!<br/><br/>  """<br/>  Post title.<br/>  """<br/>  title: String!<br/><br/>  """<br/>  Post content.<br/>  """<br/>  content: String!<br/><br/>  """<br/>  Post Author.<br/>  """<br/>  author: User!<br/><br/>  """<br/>  Post published timestamp.<br/>  """<br/>  publishedAt: DateTime<br/><br/>  """<br/>  Users who like this post.<br/>  """<br/>  likedBy: [User]<br/>}<br/><br/>type Query {<br/>  """<br/>  Get post by ID.<br/>  """<br/>  post(id: ID!): Post<br/>}<br/><br/>"""<br/>Publish post input.<br/>"""<br/>input PublishPostInput {<br/>  """<br/>  Post title.<br/>  """<br/>  title: String!<br/><br/>  """<br/>  Post content.<br/>  """<br/>  content: String!<br/>}<br/><br/>type Mutation {<br/>  """<br/>  Publish post.<br/>  """<br/>  publishPost(input: PublishPostInput!): Post!<br/><br/>  """<br/>  Follow user.<br/>  Returns the updated number of followers.<br/>  """<br/>  followUser(<br/>    """<br/>    User's ID to follow.<br/>    """<br/>    userId: ID!<br/>  ): UnsignedInt!<br/><br/>  """<br/>  Unfollow user.<br/>  Returns the updated number of followers.<br/>  """<br/>  unfollowUser(<br/>    """<br/>    User's ID to unfollow.<br/>    """<br/>    userId: ID!<br/>  ): UnsignedInt!<br/><br/>  """<br/>  Like post.<br/>  Returns the updated number of likes received.<br/>  """<br/>  likePost(<br/>    """<br/>    Post's ID to like.<br/>    """<br/>    postId: ID!<br/>  ): UnsignedInt!<br/>}</span></pre><h2 id="8300" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 2。向解析器映射添加标量</strong></h2><p id="2546" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在上一步中，我们声明了<em class="lv">模式上可用的</em>标量类型。现在我们需要告诉服务器<em class="lv">如何</em>解析这些标量类型。</p><p id="5378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe ny nz oa np b">/src</code>目录中创建一个解析器映射文件<code class="fe ny nz oa np b">resolvers.ts</code>。</p><p id="e7f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">src/resolvers.ts</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="3345" class="nt ms it np b gy nu nv l nw nx">import {<br/>  DateTimeResolver,<br/>  EmailAddressResolver,<br/>  UnsignedIntResolver,<br/>} from 'graphql-scalars';<br/><br/>export const resolvers = {<br/>  DateTime: DateTimeResolver,<br/>  EmailAddress: EmailAddressResolver,<br/>  UnsignedInt: UnsignedIntResolver,<br/>};</span></pre><h2 id="ec9f" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 3。给阿波罗服务器添加模拟</strong></h2><p id="7ba2" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">因为我们目前正在Apollo Server中使用<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/testing/mocking" rel="noopener ugc nofollow" target="_blank">模拟</a>，我们需要告诉Apollo Server <a class="ae ky" href="https://github.com/Urigo/graphql-scalars/blob/master/README.md#using-mocks-with-apollo-server" rel="noopener ugc nofollow" target="_blank">如何模拟标量</a>。一旦我们完成了所有必需的解析器的实现，我们将移除这些模拟。</p><p id="b300" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">src/main.ts</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0bbf" class="nt ms it np b gy nu nv l nw nx">import { ApolloServer } from 'apollo-server';<br/>import {<br/>  DateTimeMock,<br/>  EmailAddressMock,<br/>  UnsignedIntMock,<br/>} from 'graphql-scalars';<br/><br/>import { environment } from './environment';<br/>import { resolvers } from './resolvers';<br/>import * as typeDefs from './type-defs.graphql';<br/><br/>const server = new ApolloServer({<br/>  resolvers,<br/>  typeDefs,<br/>  introspection: environment.apollo.introspection,<br/>  mocks: {<br/>    DateTime: DateTimeMock,<br/>    EmailAddress: EmailAddressMock,<br/>    UnsignedInt: UnsignedIntMock,<br/>  }, // TODO: Remove in PROD.<br/>  mockEntireSchema: false, // TODO: Remove in PROD.<br/>  playground: environment.apollo.playground,<br/>});<br/><br/>server<br/>  .listen(environment.port)<br/>  .then(({ url }) =&gt; console.log(`Server ready at ${url}. `));<br/><br/>if (module.hot) {<br/>  module.hot.accept();<br/>  module.hot.dispose(() =&gt; server.stop());<br/>}</span></pre><p id="7307" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第17–19行:</strong>定义如何模拟标量。</p><h2 id="e7ef" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 4。测试行动中的标量模拟</strong></h2><p id="eae7" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">让我们用标量模拟来测试我们的阿波罗服务器！运行<code class="fe ny nz oa np b">NODE_ENV=development npm run build</code>和<code class="fe ny nz oa np b">npm run start:env</code>来启动阿波罗服务器，如果你还没有这么做的话。</p><p id="18c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您尝试在<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/testing/graphql-playground" rel="noopener ugc nofollow" target="_blank"> GraphQL Playground </a>中运行下面的<a class="ae ky" href="https://graphql.org/learn/queries" rel="noopener ugc nofollow" target="_blank">查询</a>:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0d29" class="nt ms it np b gy nu nv l nw nx">{<br/>  post(id:"TEST_POST_ID") {<br/>    title<br/>    content<br/>    publishedAt<br/>    author {<br/>      id<br/>      firstName<br/>      lastName<br/>      email<br/>    }<br/>  }<br/>}</span></pre><p id="8b1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它应该会返回类似如下的结果:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="689e" class="nt ms it np b gy nu nv l nw nx">{<br/>  "data": {<br/>    "post": {<br/>      "title": "Hello World",<br/>      "content": "Hello World",<br/>      "publishedAt": "2019-12-02T01:12:00.780Z",<br/>      "author": {<br/>        "id": "61ad57ab-2cb6-46f9-b35a-a54c5bf610c3",<br/>        "firstName": "Hello World",<br/>        "lastName": "Hello World",<br/>        "email": "<a class="ae ky" href="mailto:test@test.com" rel="noopener ugc nofollow" target="_blank">test@test.com</a>"<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="4609" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你试图运行一个<a class="ae ky" href="https://graphql.org/learn/queries/#mutations" rel="noopener ugc nofollow" target="_blank">突变</a>:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="c465" class="nt ms it np b gy nu nv l nw nx">mutation TestLikePost {<br/>  likePost(postId: "TEST_POST_ID") <br/>}</span></pre><p id="6533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它应该返回一个非负整数<a class="ae ky" href="https://github.com/Urigo/graphql-scalars#nonnegativeint" rel="noopener ugc nofollow" target="_blank">:</a></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="c781" class="nt ms it np b gy nu nv l nw nx">{<br/>  "data": {<br/>    "likePost": 123<br/>  }<br/>}</span></pre><p id="f7e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不错！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="db42" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">5.MongoDB简介</h1><p id="deb1" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">现在我们已经有了一个描述性的模式，是时候将<a class="ae ky" href="https://www.mongodb.com" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>添加进来并开始实现解析器了。</p><h2 id="9eef" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 1。安装MongoDB </strong></h2><p id="4cd5" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">如果您还没有安装MongoDB 到您的本地环境中，请安装它。或者，如果你喜欢云数据库解决方案，你可以使用<a class="ae ky" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank"> MongoDB Atlas </a>。MongoDB Atlas提供了一个<a class="ae ky" href="https://www.mongodb.com/cloud/atlas/pricing" rel="noopener ugc nofollow" target="_blank">免费等级</a>供试用。</p><h2 id="cac3" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 2。为Node.js安装</strong> <a class="ae ky" href="https://github.com/mongodb/node-mongodb-native" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> MongoDB驱动</strong> </a> <strong class="ak">。</strong></h2><p id="e14c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">这里没什么特别的。只需<a class="ae ky" href="https://github.com/mongodb/node-mongodb-native#installation" rel="noopener ugc nofollow" target="_blank">安装MongoDB NPM包</a>和MongoDB的<a class="ae ky" href="https://basarat.gitbooks.io/typescript/docs/types/@types.html" rel="noopener ugc nofollow" target="_blank">类型脚本类型</a>。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="dfe3" class="nt ms it np b gy nu nv l nw nx">$ npm install --save mongodb<br/>$ npm install --save-dev @types/mongodb</span></pre><h2 id="b9c4" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 3。在环境变量中指定数据库细节</strong></h2><p id="dd65" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">首先，让我们更新<code class="fe ny nz oa np b">environment.ts</code>来接受MongoDB连接细节。</p><p id="ca65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">src/environment.ts</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="253f" class="nt ms it np b gy nu nv l nw nx">const defaultPort = 4000;<br/><br/>interface Environment {<br/>  apollo: {<br/>    introspection: boolean;<br/>    playground: boolean;<br/>  };<br/>  mongoDb: {<br/>    databaseName: string;<br/>    url: string;<br/>  };<br/>  port: number | string;<br/>}<br/><br/>export const environment: Environment = {<br/>  apollo: {<br/>    introspection: process.env.APOLLO_INTROSPECTION === 'true',<br/>    playground: process.env.APOLLO_PLAYGROUND === 'true',<br/>  },<br/>  mongoDb: {<br/>    databaseName: process.env.MONGODB_DB_NAME as string,<br/>    url: process.env.MONGODB_URL as string,<br/>  },<br/>  port: process.env.PORT || defaultPort,<br/>};</span></pre><p id="38b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后将数据库名称和MongoDB的URL添加到<code class="fe ny nz oa np b">.env</code>的<code class="fe ny nz oa np b">MONGODB_DB_NAME</code>和<code class="fe ny nz oa np b">MONGODB_URL</code>中。</p><p id="fd4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">.env</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="d141" class="nt ms it np b gy nu nv l nw nx">APOLLO_INTROSPECTION=true<br/>APOLLO_PLAYGROUND=true<br/>MONGODB_DB_NAME=graphqlMongodbDemo<br/>MONGODB_URL=mongodb://localhost:27017</span></pre><h2 id="0e56" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 4。添加MongoDB提供者</strong></h2><p id="b55c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们将实现一个提供者(或助手)来帮助执行一些常见的数据库操作。</p><p id="4b90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将实现一个种子函数<code class="fe ny nz oa np b">addMockUsersAsync()</code>来将一些模拟用户插入到MongoDB的<code class="fe ny nz oa np b">users</code>集合中进行测试。</p><p id="960d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">src/mongodb.provider.ts</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="53b9" class="nt ms it np b gy nu nv l nw nx">import { Collection, Db, MongoClient, ObjectID } from 'mongodb';<br/><br/>import { environment } from './environment';<br/><br/>export class MongoDbProvider {<br/>  private database?: Db;<br/>  private mongoClient: MongoClient;<br/><br/>  constructor(url: string) {<br/>    this.mongoClient = new MongoClient(url, { useUnifiedTopology: true });<br/>  }<br/><br/>  get postsCollection(): Collection {<br/>    const postsCollection = this.getCollection('posts');<br/><br/>    if (!postsCollection) {<br/>      throw new Error('Posts collection is undefined');<br/>    }<br/><br/>    return postsCollection;<br/>  }<br/><br/>  get usersCollection(): Collection {<br/>    const usersCollection = this.getCollection('users');<br/><br/>    if (!usersCollection) {<br/>      throw new Error('Users collection is undefined');<br/>    }<br/><br/>    return usersCollection;<br/>  }<br/><br/>  /**<br/>   * Connect to MongoDB.<br/>   * @async<br/>   * @param databaseName - Database name.<br/>   */<br/>  async connectAsync(databaseName: string): Promise&lt;void&gt; {<br/>    await this.mongoClient.connect();<br/>    this.database = this.mongoClient.db(databaseName);<br/>  }<br/><br/>  /**<br/>   * Close the database and its underlying connections.<br/>   */<br/>  async closeAsync(): Promise&lt;void&gt; {<br/>    await this.mongoClient.close();<br/>  }<br/><br/>  /**<br/>   * Fetch a specific collection.<br/>   * @private<br/>   * @param collectionName - Collection name.<br/>   * @returns The collection instance.<br/>   */<br/>  private getCollection(collectionName: string): Collection {<br/>    if (!this.database) {<br/>      throw new Error('Database is undefined.');<br/>    }<br/><br/>    return this.database.collection(collectionName);<br/>  }<br/>}<br/><br/>export const mongoDbProvider = new MongoDbProvider(environment.mongoDb.url);<br/><br/>/**<br/> * Add mock users if `users` collection is empty.<br/> * TODO: Remove in Production.<br/> */<br/>export async function addMockUsersAsync(): Promise&lt;void&gt; {<br/>  const usersCount = await mongoDbProvider.usersCollection.countDocuments();<br/><br/>  if (usersCount === 0) {<br/>    await mongoDbProvider.usersCollection.insertMany([<br/>      {<br/>        _id: new ObjectID('0123456789abcdef01234567'),<br/>        firstName: 'Test',<br/>        lastName: 'User 1',<br/>        email: 'test.user1@test.com',<br/>      },<br/>      {<br/>        _id: new ObjectID('fedcba987654321098765432'),<br/>        firstName: 'Test',<br/>        lastName: 'User 2',<br/>        email: 'test.user2@test.com',<br/>        following: [new ObjectID('0123456789abcdef01234567')],<br/>      },<br/>    ]);<br/>  }<br/>}</span></pre><h2 id="8f53" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 5。在Apollo服务器启动时连接到MongoDB</strong></h2><p id="105b" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">更新<code class="fe ny nz oa np b">main.ts</code>在引导期间连接MongoDB。</p><p id="aa92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">src/main.ts</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="fc97" class="nt ms it np b gy nu nv l nw nx">import { ApolloServer } from 'apollo-server';<br/>import { DateTimeMock, EmailAddressMock } from 'graphql-scalars';<br/><br/>import { environment } from './environment';<br/>import { addMockUsersAsync, mongoDbProvider } from './mongodb.provider';<br/>import * as typeDefs from './type-defs.graphql';<br/><br/>(async function bootstrapAsync(): Promise&lt;void&gt; {<br/>  await mongoDbProvider.connectAsync(environment.mongoDb.databaseName);<br/>  await addMockUsersAsync(); // TODO: Remove in PROD.<br/><br/>  const server = new ApolloServer({<br/>    typeDefs,<br/>    introspection: environment.apollo.introspection,<br/>    mockEntireSchema: false, // TODO: Remove in PROD.<br/>    mocks: {<br/>      DateTime: DateTimeMock,<br/>      EmailAddress: EmailAddressMock,<br/>      UnsignedInt: UnsignedIntMock,<br/>    }, // TODO: Remove in PROD.<br/>    playground: environment.apollo.playground,<br/>  });<br/><br/>  server<br/>    .listen(environment.port)<br/>    .then(({ url }) =&gt; console.log(`Server ready at ${url}. `));<br/><br/>  if (module.hot) {<br/>    module.hot.accept();<br/>    module.hot.dispose(async () =&gt; {<br/>      server.stop();<br/>      await mongoDbProvider.closeAsync();<br/>    });<br/>  }<br/>})();</span></pre><ul class=""><li id="f8d1" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><strong class="lb iu">第8–34行</strong>:我们使用了<a class="ae ky" href="https://basarat.gitbooks.io/typescript/docs/async-await.html" rel="noopener ugc nofollow" target="_blank">异步/等待</a>，因此我们用异步函数和<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">生命周期</a>包装了引导动作。</li><li id="8020" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">第9行:</strong> <a class="ae ky" href="https://mongodb.github.io/node-mongodb-native/api-generated/mongoclient.html#connect" rel="noopener ugc nofollow" target="_blank">将</a> s连接到<code class="fe ny nz oa np b"><a class="ae ky" href="https://github.com/motdotla/dotenv" rel="noopener ugc nofollow" target="_blank">.env</a></code>环境变量文件中指定的MongoDB的数据库。</li><li id="2556" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">第10行:</strong>如果集合为空，则将模拟用户添加到MongoDB的<code class="fe ny nz oa np b">users</code>集合中。</li><li id="5d11" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">第31行:</strong>当Webpack的<a class="ae ky" href="https://webpack.js.org/concepts/hot-module-replacement" rel="noopener ugc nofollow" target="_blank"> HMR </a>启动时，优雅地关闭与MongoDB的连接。</li></ul><h2 id="5447" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 6。启动MongoDB守护进程</strong></h2><p id="a70c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在我们启动<a class="ae ky" href="https://docs.mongodb.com/manual/reference/program/mongod" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>之前，我们需要一个目录来存储数据库相关的文件，例如<code class="fe ny nz oa np b">tmp/db</code>:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="4f95" class="nt ms it np b gy nu nv l nw nx"># Create a folder to store database files. <br/>$ mkdir -p tmp/db</span><span id="fcfa" class="nt ms it np b gy oh nv l nw nx"># Start MongoDB daemon process. <br/>$ mongod --dbpath tmp/db</span></pre><h2 id="4936" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 7。构建并启动阿波罗服务器</strong></h2><p id="96a7" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">一旦MongoDB启动，以<code class="fe ny nz oa np b">development</code>模式构建并启动Apollo服务器。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="27bf" class="nt ms it np b gy nu nv l nw nx">$ NODE_ENV=development npm run build<br/>$ npm run start:env</span><span id="82d5" class="nt ms it np b gy oh nv l nw nx">&gt; Server ready at <a class="ae ky" href="http://localhost:4000/" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/</a>.</span></pre><h2 id="c5b6" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 8。测试直接查询MongoDB</strong></h2><p id="05fe" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">如果实现正确，应该有两个被模仿的用户对象被添加到MongoDB的<code class="fe ny nz oa np b">users</code>集合中(通过在服务器引导上执行<code class="fe ny nz oa np b">addMockUsersAsync()</code>)。然而，由于我们还没有在我们的Apollo服务器中实现任何解析器，我们还不能用Apollo服务器测试它。</p><p id="974d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了验证我们刚刚添加的代码正在工作，我们可以用<a class="ae ky" href="https://docs.mongodb.com/manual/mongo" rel="noopener ugc nofollow" target="_blank"> mongo shell </a>直接查询MongoDB。</p><p id="964f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开一个新命令行并运行以下命令:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="1311" class="nt ms it np b gy nu nv l nw nx"># Open mongo shell. <br/>$ mongo</span><span id="6381" class="nt ms it np b gy oh nv l nw nx"># Show available MongoDB databases. <br/>$ show databases</span><span id="e82a" class="nt ms it np b gy oh nv l nw nx">&gt; admin               0.000GB<br/>&gt; config              0.000GB<br/>&gt; graphqlMongodbDemo  0.000GB<br/>&gt; local               0.000GB</span><span id="b1bb" class="nt ms it np b gy oh nv l nw nx"># Use database `graphqlMongodbDemo`. <br/>$ use graphqlMongodbDemo</span><span id="0347" class="nt ms it np b gy oh nv l nw nx"># Get all users from `users` collection. <br/>$ db.users.find({})</span><span id="3db3" class="nt ms it np b gy oh nv l nw nx"># It should return two `users` objects if implemented correctly. <br/>&gt; { "_id" : ObjectId("0123456789abcdef01234567"), "firstName" : "Test", "lastName" : "User 1", "email" : "<a class="ae ky" href="mailto:test.user1@test.com" rel="noopener ugc nofollow" target="_blank">test.user1@test.com</a>" }<br/>{ "_id" : ObjectId("fedcba987654321098765432"), "firstName" : "Test", "lastName" : "User 2", "email" : "<a class="ae ky" href="mailto:test.user2@test.com" rel="noopener ugc nofollow" target="_blank">test.user2@test.com</a>", "following" : [ ObjectId("0123456789abcdef01234567") ] }</span><span id="97c5" class="nt ms it np b gy oh nv l nw nx"># Exit mongo shell. <br/>$ exit</span></pre><p id="a259" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:如果你喜欢用GUI管理MongoDBs，你也可以使用像<a class="ae ky" href="https://robomongo.org" rel="noopener ugc nofollow" target="_blank"> Robo 3T </a>这样的工具。</p><p id="67bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经成功地将Apollo服务器连接到MongoDB，我们的下一步就是开始实现解析器来处理“真实”数据。</p><p id="567b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在我们开始实现解析器之前，我们需要描述我们的实体(<code class="fe ny nz oa np b">Users</code>、<code class="fe ny nz oa np b">Posts</code>等等)。)中。我们已经用GraphQL模式描述了我们的类型。在TypeScript中编写类型定义不仅看起来工作量增加了一倍，而且更容易出错——可以在GraphQL模式中更新类型，但却忘记了更新TypeScript类型定义。</p><p id="84a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一定有更聪明的方法来处理这件事！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="464f" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">6.GraphQL代码生成器简介</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/a36054460937dc2abef6756ac5f3f9ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3v9Q1TKPgq4xV-HpbHtBlg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GraphQL代码生成器(图片来源:<a class="ae ky" href="https://github.com/dotansimha/graphql-code-generator" rel="noopener ugc nofollow" target="_blank"> GitHub </a>)</p></figure><p id="bed4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL代码生成器是一个<em class="lv"> CLI工具，可以从GraphQL模式</em>中生成打字稿。<a class="ae ky" href="https://graphql-code-generator.com" rel="noopener ugc nofollow" target="_blank"> GraphQL codegen </a>作为插件出现在<a class="ae ky" href="https://github.com/urigo/graphql-cli" rel="noopener ugc nofollow" target="_blank"> graphql-cli </a>工具集中。要使用<a class="ae ky" href="https://graphql-code-generator.com" rel="noopener ugc nofollow" target="_blank"> GraphQL codegen </a>:</p><h2 id="51af" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 1。安装graphql-cli </strong> 的 <a class="ae ky" href="https://github.com/Urigo/graphql-cli#install" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> <em class="ou">金丝雀</em>版本</strong></a></h2><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="2e07" class="nt ms it np b gy nu nv l nw nx">$ npm install --save graphql-cli@canary</span></pre><h2 id="c35e" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 2。为GraphQL codegen </strong> 安装<a class="ae ky" href="https://graphql-code-generator.com" rel="noopener ugc nofollow" target="_blank"><strong class="ak">graph QL codegen</strong></a><strong class="ak">插件和</strong> <a class="ae ky" href="https://www.npmjs.com/package/@graphql-codegen/typescript" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> TypeScript插件</strong></a></h2><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="882d" class="nt ms it np b gy nu nv l nw nx">$ npm install --save @test-graphql-cli/codegen@canary @graphql-codegen/typescript</span></pre><p id="b746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:除了<a class="ae ky" href="https://graphql-code-generator.com" rel="noopener ugc nofollow" target="_blank"> GraphQL codegen </a>，<a class="ae ky" href="https://github.com/Urigo/graphql-cli#plugin-system" rel="noopener ugc nofollow" target="_blank"> GraphQL CLI还附带了一个有用插件的列表</a>。请务必试用它们！</p><h2 id="316c" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 3。创建</strong> <a class="ae ky" href="https://graphql-config.com" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> GraphQL配置</strong> </a> <strong class="ak">文件</strong></h2><p id="4f98" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在项目根目录下创建一个名为<code class="fe ny nz oa np b">.graphqlrc.yml</code>的<a class="ae ky" href="https://graphql-config.com" rel="noopener ugc nofollow" target="_blank"> GraphQL配置</a>文件:</p><p id="5867" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">.graphqlrc.yml</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="031f" class="nt ms it np b gy nu nv l nw nx">schema: ./src/**/*.graphql<br/>extensions:<br/>  codegen:<br/>    ./src/graphql-codegen-typings.d.ts:<br/>      plugins:<br/>        - typescript</span></pre><ul class=""><li id="9a41" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><strong class="lb iu">第1行:</strong>包含<code class="fe ny nz oa np b">/src</code>目录中所有文件扩展名为<code class="fe ny nz oa np b">.graphql</code>的GraphQL模式文件。在本例中，我们只有一个模式文件:<code class="fe ny nz oa np b">typedefs.graphql</code>。</li><li id="c381" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">第3–6行:</strong>包含<a class="ae ky" href="https://graphql-code-generator.com" rel="noopener ugc nofollow" target="_blank"> codegen </a>插件，指定输出TypeScript类型定义文件为<code class="fe ny nz oa np b">src/graphql-codegen-typings.d.ts</code>。</li></ul><p id="80af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注</strong>:关于设置的更多细节，请参考<a class="ae ky" href="https://graphql-config.com/docs/introduction" rel="noopener ugc nofollow" target="_blank"> GraphQL配置文档</a>。</p><h2 id="792e" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 4。在构建和测试之前运行graph QL codegen</strong></h2><p id="320d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们添加了<a class="ae ky" href="https://docs.npmjs.com/misc/scripts" rel="noopener ugc nofollow" target="_blank"> NPM脚本</a>来在每个应用构建或测试之前运行GraphQL codegen。</p><p id="ea89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">package.json</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="f5a4" class="nt ms it np b gy nu nv l nw nx">{<br/>  ...<br/>  "scripts": {<br/>    "build": "webpack --config webpack.$NODE_ENV.js",<br/>    "graphql:codegen": "graphql codegen",<br/>    "prebuild": "npm run graphql:codegen",<br/>    "pretest": "npm run graphql:codegen",<br/>    "start": "node dist/server",<br/>    "start:env": "node --require dotenv/config dist/server",<br/>    "test": "jest"<br/>  },<br/>  "dependencies": { ... },<br/>  "devDependencies": { ... }<br/>}</span></pre><ul class=""><li id="a739" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><strong class="lb iu">第5行:</strong>定义<a class="ae ky" href="https://github.com/Urigo/graphql-cli#plugin-system" rel="noopener ugc nofollow" target="_blank"> GraphQL CLI </a>运行<code class="fe ny nz oa np b"><a class="ae ky" href="https://graphql-code-generator.com" rel="noopener ugc nofollow" target="_blank">codegen</a></code>。</li><li id="f839" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">第6行:</strong>利用<a class="ae ky" href="https://medium.com/yld-blog/using-npm-pre-and-post-hooks-d89dcf2d86cf" rel="noopener"> NPM的<em class="lv">前</em>钩</a>触发<code class="fe ny nz oa np b">graphql codegen</code>在<code class="fe ny nz oa np b">build</code>之前运行。</li><li id="d131" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">7线:</strong>与<code class="fe ny nz oa np b">prebuild</code>和<code class="fe ny nz oa np b">build</code>类似，<code class="fe ny nz oa np b">graphql codegen</code>会在<code class="fe ny nz oa np b">test</code>运行前触发。</li></ul><h2 id="3e3d" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 5。在操作中生成类型脚本类型定义</strong></h2><p id="afd5" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">通过这种设置，每次运行<code class="fe ny nz oa np b">npm run build</code>时，都会在<code class="fe ny nz oa np b">/src</code>目录中生成一个<code class="fe ny nz oa np b">graphql-codegen-typings.d.ts</code>文件。生成的文件包含与GraphQL模式中定义的所有类型相匹配的TypeScript类型定义。使用这种方法，我们可以确保我们的TypeScript类型与GraphQL模式一致。</p><p id="fa3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好……但是GraphQL模式中描述的生成类型并不总是反映数据是如何存储在数据库中的。当使用解析器时，我们需要处理类型与GraphQL模式紧密匹配的对象，以及数据库模型。我们如何实现这一点？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/e315edc9ba5c095613621d308b685cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*gYjRCnNy4dehuY6vqII1cA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片来源:你知道的——在亚马逊上)</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="70b9" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">7。使用GraphQL Codegen生成数据库对象类型</h1><p id="d480" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">幸运的是，MongoDB 有一个<a class="ae ky" href="https://graphql-code-generator.com/docs/plugins/typescript-mongodb" rel="noopener ugc nofollow" target="_blank"> GraphQL codegen插件可以用MongoDB模型生成TypeScript类型。</a></p><h2 id="d92f" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 1。安装</strong> <code class="fe ny nz oa np b"><strong class="ak">typescript-mongodb</strong></code> <strong class="ak">插件</strong></h2><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="f474" class="nt ms it np b gy nu nv l nw nx">$ npm install --save @graphql-codegen/typescript-mongodb</span></pre><h2 id="350c" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 2。将</strong> <code class="fe ny nz oa np b"><strong class="ak">typescript-mongodb</strong></code> <strong class="ak">添加到</strong> <a class="ae ky" href="https://graphql-config.com" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> GraphQL配置</strong> </a> <strong class="ak">文件</strong></h2><p id="a78f" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">.graphqlrc.yml</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="d5ee" class="nt ms it np b gy nu nv l nw nx">{<br/>  ...<br/>  "scripts": {<br/>    "build": "webpack --config webpack.$NODE_ENV.js",<br/>    "graphql:codegen": "graphql codegen",<br/>    "prebuild": "npm run graphql:codegen",<br/>    "pretest": "npm run graphql:codegen",<br/>    "start": "node dist/server",<br/>    "start:env": "node --require dotenv/config dist/server",<br/>    "test": "jest"<br/>  },<br/>  "dependencies": { ... },<br/>  "devDependencies": { ... }<br/>}</span></pre><h2 id="b5db" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 3。使用GraphQL模式指令描述MongoDB模型</strong></h2><p id="775e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated"><a class="ae ky" href="https://graphql-code-generator.com/docs/plugins/typescript-mongodb#usage" rel="noopener ugc nofollow" target="_blank">按照插件指令</a>用指令描述你的<code class="fe ny nz oa np b">Post</code>和<code class="fe ny nz oa np b">User</code>实体。</p><p id="811d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">src/type-defs.graphql</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="6977" class="nt ms it np b gy nu nv l nw nx">scalar DateTime<br/>scalar EmailAddress<br/>scalar UnsignedInt<br/><br/>type User @entity {<br/>  """<br/>  User ID.<br/>  """<br/>  id: ID! @id<br/><br/>  """<br/>  User's first name.<br/>  """<br/>  firstName: String! @column<br/><br/>  """<br/>  User's last name.<br/>  """<br/>  lastName: String! @column<br/><br/>  """<br/>  User's e-mail address.<br/>  """<br/>  email: EmailAddress @column(overrideType: "string")<br/><br/>  """<br/>  Posts published by user.<br/>  """<br/>  posts: [Post]<br/><br/>  """<br/>  Users that this user is following.<br/>  """<br/>  following: [User] @link<br/><br/>  """<br/>  Users that this user is followed by.<br/>  """<br/>  followers: [User]<br/>}<br/><br/>type Post @entity {<br/>  """<br/>  Post ID.<br/>  """<br/>  id: ID! @id<br/><br/>  """<br/>  Post title.<br/>  """<br/>  title: String! @column<br/><br/>  """<br/>  Post content.<br/>  """<br/>  content: String! @column<br/><br/>  """<br/>  Post Author.<br/>  """<br/>  author: User! @link<br/><br/>  """<br/>  Post published timestamp.<br/>  """<br/>  publishedAt: DateTime @column(overrideType: "Date")<br/><br/>  """<br/>  Users who like this post.<br/>  """<br/>  likedBy: [User] @link<br/>}<br/><br/>type Query {<br/>  """<br/>  Get post by ID.<br/>  """<br/>  post(id: ID!): Post<br/>}<br/><br/>"""<br/>Publish post input.<br/>"""<br/>input PublishPostInput {<br/>  """<br/>  Post title.<br/>  """<br/>  title: String!<br/><br/>  """<br/>  Post content.<br/>  """<br/>  content: String!<br/>}<br/><br/>type Mutation {<br/>  """<br/>  Publish post.<br/>  """<br/>  publishPost(input: PublishPostInput!): Post!<br/><br/>  """<br/>  Follow user.<br/>  Returns the updated number of followers.<br/>  """<br/>  followUser(<br/>    """<br/>    User's ID to follow.<br/>    """<br/>    userId: ID!<br/>  ): UnsignedInt!<br/><br/>  """<br/>  Unfollow user.<br/>  Returns the updated number of followers.<br/>  """<br/>  unfollowUser(<br/>    """<br/>    User's ID to unfollow.<br/>    """<br/>    userId: ID!<br/>  ): UnsignedInt!<br/><br/>  """<br/>  Like post.<br/>  Returns the updated number of likes received.<br/>  """<br/>  likePost(<br/>    """<br/>    Post's ID to like.<br/>    """<br/>    postId: ID!<br/>  ): UnsignedInt!<br/>}</span></pre><p id="3e13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要忘记<a class="ae ky" href="https://graphql-code-generator.com/docs/plugins/typescript-mongodb#usage" rel="noopener ugc nofollow" target="_blank">将指令声明</a>添加到GraphQL模式定义中。</p><p id="a6aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">src/main.ts</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="9b6e" class="nt ms it np b gy nu nv l nw nx">import { DIRECTIVES } from '@graphql-codegen/typescript-mongodb';<br/>import { ApolloServer } from 'apollo-server';<br/>import { DateTimeMock, EmailAddressMock } from 'graphql-scalars';<br/><br/>import { environment } from './environment';<br/>import { addMockUsersAsync, mongoDbProvider } from './mongodb.provider';<br/>import * as typeDefs from './type-defs.graphql';<br/><br/>(async function bootstrapAsync(): Promise&lt;void&gt; {<br/>  await mongoDbProvider.connectAsync(environment.mongoDb.databaseName);<br/>  await addMockUsersAsync(); // TODO: Remove in Production.<br/><br/>  const server = new ApolloServer({<br/>    typeDefs: [DIRECTIVES, typeDefs],<br/>    introspection: environment.apollo.introspection,<br/>    mockEntireSchema: false,<br/>    mocks: {<br/>      DateTime: DateTimeMock,<br/>      EmailAddress: EmailAddressMock,<br/>    },<br/>    playground: environment.apollo.playground,<br/>  });<br/><br/>  server<br/>    .listen(environment.port)<br/>    .then(({ url }) =&gt; console.log(`Server ready at ${url}. `));<br/><br/>  if (module.hot) {<br/>    module.hot.accept();<br/>    module.hot.dispose(async () =&gt; {<br/>      server.stop();<br/>      await mongoDbProvider.closeAsync();<br/>    });<br/>  }<br/>})();</span></pre><ul class=""><li id="de15" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><strong class="lb iu">第14行:</strong>向GraphQL模式定义添加自定义指令声明。</li></ul><h2 id="14c8" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 4。验证插件配置工作正常</strong></h2><p id="53c4" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">尝试用<code class="fe ny nz oa np b">NODE_ENV=development npm run build</code>构建app，检查生成的TypeScript类型定义文件<code class="fe ny nz oa np b">graphql-codegen-typings.d.ts</code>。给出了两种MongoDB模型类型<code class="fe ny nz oa np b">PostDbObject</code>和<code class="fe ny nz oa np b">UserDbObject</code>，以及匹配GraphQL模式类型的类型，如<code class="fe ny nz oa np b">Post</code>、<code class="fe ny nz oa np b">User</code>等。</p><p id="4de1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经做好了实现解析器的一切准备。我们开始吧！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="b71c" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">8.实施解析器</h1><p id="aa7c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">如果你还记得我上一篇文章中的<a class="ae ky" href="https://medium.com/free-code-camp/build-an-apollo-graphql-server-with-typescript-and-webpack-hot-module-replacement-hmr-3c339d05184f" rel="noopener">，Apollo服务器的</a><a class="ae ky" href="https://www.apollographql.com/docs/graphql-tools/resolvers/#resolver-function-signature" rel="noopener ugc nofollow" target="_blank">解析器函数签名</a>接受四个位置参数:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="823c" class="nt ms it np b gy nu nv l nw nx">fieldName(obj, args, context, info) { result }</span></pre><p id="e112" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解析器函数并没有什么奇特之处——只是纯粹的函数。换句话说，GraphQL允许您灵活地定义准备数据的步骤，只要返回的数据类型与GraphQL模式类型匹配，这些步骤就被认为是有效的。</p><h2 id="9fdf" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 1。实现</strong> <code class="fe ny nz oa np b"><strong class="ak">publishPost</strong></code> <strong class="ak">变异解析器</strong></h2><p id="468a" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">让我们从<code class="fe ny nz oa np b">publishPost</code>突变开始。它需要一个<code class="fe ny nz oa np b">input</code>参数，而输入是一个包含post的<code class="fe ny nz oa np b">title</code>和<code class="fe ny nz oa np b">content</code>的对象。如果发布成功，则返回新发布的<code class="fe ny nz oa np b">post</code>。</p><p id="a140" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将<code class="fe ny nz oa np b">publishPost</code>突变添加到现有的解析器文件中。</p><p id="de19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">src/resolvers.ts</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="9edc" class="nt ms it np b gy nu nv l nw nx">import {<br/>  DateTimeResolver,<br/>  EmailAddressResolver,<br/>  UnsignedIntResolver,<br/>} from 'graphql-scalars';<br/>import { ObjectID } from 'mongodb';<br/><br/>import { PostDbObject, PublishPostInput } from './graphql-codegen-typings';<br/>import { mongoDbProvider } from './mongodb.provider';<br/><br/>const mockCurrentUserId = '0123456789abcdef01234567';<br/><br/>export const resolvers = {<br/>  DateTime: DateTimeResolver,<br/>  EmailAddress: EmailAddressResolver,<br/>  UnsignedInt: UnsignedIntResolver,<br/>  Mutation: {<br/>    publishPost: async (<br/>      obj: any,<br/>      { input }: { input: PublishPostInput }<br/>    ): Promise&lt;PostDbObject&gt; =&gt; {<br/>      const result = await mongoDbProvider.postsCollection.insertOne({<br/>        title: input.title,<br/>        content: input.content,<br/>        publishedAt: new Date(),<br/>        author: new ObjectID(mockCurrentUserId),<br/>      });<br/><br/>      return result.ops[0] as PostDbObject;<br/>    },<br/>  },<br/>};</span></pre><ul class=""><li id="2713" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><strong class="lb iu">第11行:</strong>我们使用一个“硬编码”的ID来代表一个被模仿的当前用户，只是为了演示的目的。在现实世界的场景中，这可以从一个传入的令牌中获得，例如<a class="ae ky" href="https://jwt.io" rel="noopener ugc nofollow" target="_blank"> JWT </a>。</li><li id="fa7a" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">第18行:</strong>用上面提到的签名定义一个<code class="fe ny nz oa np b">publishPost</code>突变异步函数。</li><li id="0cee" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">第20行:</strong>获取从变异的<code class="fe ny nz oa np b">args</code>传来的<code class="fe ny nz oa np b">input</code>对象(此处<a class="ae ky" href="https://www.apollographql.com/docs/graphql-tools/resolvers/#resolver-function-signature" rel="noopener ugc nofollow" target="_blank">解释</a>)。TypeScript类型<code class="fe ny nz oa np b">PublishPostInput</code>是由GraphQL codegen基于我们的GraphQL模式自动生成的。</li><li id="8d96" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">第22行:</strong>我们正在使用一个helper方法form <code class="fe ny nz oa np b">MongoProvider</code>来获取MongoDB的<code class="fe ny nz oa np b">posts</code>集合，并调用集合的<code class="fe ny nz oa np b"><a class="ae ky" href="http://mongodb.github.io/node-mongodb-native/3.3/api/Collection.html#insertOne" rel="noopener ugc nofollow" target="_blank">insertOne()</a></code>方法向<code class="fe ny nz oa np b">posts</code>集合添加一个post。</li><li id="7644" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">第29行:</strong>返回新发布的<code class="fe ny nz oa np b">post</code>数据库对象，其中包含一个从MongoDB分配的ID(更多细节请参考MongoDB的<code class="fe ny nz oa np b"><a class="ae ky" href="http://mongodb.github.io/node-mongodb-native/3.3/api/Collection.html#~insertOneWriteOpResult" rel="noopener ugc nofollow" target="_blank">insertOneWriteOpResult</a></code> API)。</li></ul><p id="a9a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们试图在<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/testing/graphql-playground" rel="noopener ugc nofollow" target="_blank"> GraphQL Playground </a>中运行<code class="fe ny nz oa np b">publishPost</code>突变:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="a430" class="nt ms it np b gy nu nv l nw nx">mutation TestPublishPost($input: PublishPostInput!) {<br/>  publishPost(input:$input) {<br/>    id<br/>    title<br/>    content<br/>    publishedAt<br/>    author {<br/>      id<br/>      firstName<br/>      lastName<br/>      email<br/>    }<br/>  }<br/>}</span><span id="9304" class="nt ms it np b gy oh nv l nw nx"># Query variables. <br/>{<br/>  "input": {<br/>    "title": "Test 1 Title",<br/>    "content": "Test 1 content. "<br/>  }<br/>}</span></pre><p id="0e37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会得到类似如下的结果:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="5fc4" class="nt ms it np b gy nu nv l nw nx">{<br/>  "data": {<br/>    "publishPost": {<br/>      "id": "48c3929b-9ddc-4023-a0ed-6dd03e88afc3",<br/>      "title": "Test 1 Title",<br/>      "content": "Test 1 content. ",<br/>      "publishedAt": "2019-12-08T06:15:18.755Z",<br/>      "author": {<br/>        "id": "80f976ae-4d4e-4705-8d6c-f3452e2f8ae0",<br/>        "firstName": "Hello World",<br/>        "lastName": "Hello World",<br/>        "email": "<a class="ae ky" href="mailto:test@test.com" rel="noopener ugc nofollow" target="_blank">test@test.com</a>"<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="edb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发布的帖子的<code class="fe ny nz oa np b">title</code>、<code class="fe ny nz oa np b">content</code>和<code class="fe ny nz oa np b">publishedAt</code>显示正确。然而，作者的用户ID没有显示我们模拟的当前用户ID <code class="fe ny nz oa np b">0123456789abcdef01234567</code>,用户的详细信息在模拟值中提供。而且，如果你尝试用<a class="ae ky" href="https://docs.mongodb.com/manual/mongo" rel="noopener ugc nofollow" target="_blank"> mongo shell </a>(或者其他类似<a class="ae ky" href="https://robomongo.org" rel="noopener ugc nofollow" target="_blank"> Robo 3T </a>的工具)查询<code class="fe ny nz oa np b">posts</code>集合，你会注意到<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/testing/graphql-playground" rel="noopener ugc nofollow" target="_blank"> GraphQL Playground </a>中显示的发布帖子的<code class="fe ny nz oa np b">ID</code>与MongoDB中的【真实】<code class="fe ny nz oa np b">ID</code>并不匹配。</p><p id="c729" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么？！</p><p id="7859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为我们已经在Apollo服务器上启用了模拟，将<code class="fe ny nz oa np b">mockEntireSchema</code>设置为<code class="fe ny nz oa np b">false</code>。这意味着，如果我们的解析器能够完成传入的查询或变异，Apollo服务器将尝试返回“真实”数据。否则，它将向无法解析的字段返回一个模拟值。这实际上是一种健壮的方法——它允许开发人员基于商定的模式定义，增量地实现解析器。想象一下，当构建一个真实世界的应用程序时，后端团队可以逐步实现和微调解析器，而不会干扰前端团队在UI方面的进展。</p><p id="a337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的应用程序，我们的<code class="fe ny nz oa np b">publishPost</code>变异没有从MongoDB返回“真正的”ID的原因是，模式期望文章的ID存储在一个<code class="fe ny nz oa np b">id</code>字段中，而MongoDB中文档的ID表示在一个<code class="fe ny nz oa np b">_id</code>字段中。</p><p id="1db6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于<code class="fe ny nz oa np b">Post</code>对象，我们的Apollo服务器目前正在返回模拟的<code class="fe ny nz oa np b">author</code>细节，因为我们还没有为<code class="fe ny nz oa np b">User</code>类型实现任何解析器。</p><p id="bba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，为了解决<code class="fe ny nz oa np b">Post</code> ID问题，让我们为<code class="fe ny nz oa np b">Post</code>类型添加一个解析器。</p><p id="dea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">src/resolvers.ts</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="9846" class="nt ms it np b gy nu nv l nw nx">import {<br/>  DateTimeResolver,<br/>  EmailAddressResolver,<br/>  UnsignedIntResolver,<br/>} from 'graphql-scalars';<br/>import { ObjectID } from 'mongodb';<br/><br/>import {<br/>  Post,<br/>  PostDbObject,<br/>  PublishPostInput,<br/>} from './graphql-codegen-typings';<br/>import { mongoDbProvider } from './mongodb.provider';<br/><br/>const mockCurrentUserId = '0123456789abcdef01234567';<br/><br/>export const resolvers = {<br/>  DateTime: DateTimeResolver,<br/>  EmailAddress: EmailAddressResolver,<br/>  UnsignedInt: UnsignedIntResolver,<br/>  Mutation: {<br/>    publishPost: async (<br/>      obj: any,<br/>      { input }: { input: PublishPostInput }<br/>    ): Promise&lt;PostDbObject&gt; =&gt; {<br/>      const result = await mongoDbProvider.postsCollection.insertOne({<br/>        title: input.title,<br/>        content: input.content,<br/>        publishedAt: new Date(),<br/>        author: new ObjectID(mockCurrentUserId),<br/>      });<br/><br/>      return result.ops[0] as PostDbObject;<br/>    },<br/>  },<br/>  Post: {<br/>    id: (obj: Post | PostDbObject): string =&gt;<br/>      (obj as PostDbObject)._id<br/>        ? (obj as PostDbObject)._id.toString()<br/>        : (obj as Post).id,<br/>  },<br/>};</span></pre><ul class=""><li id="2326" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">第37行:为<code class="fe ny nz oa np b">Post</code>的<code class="fe ny nz oa np b">id</code>字段定义一个解析器。使用<a class="ae ky" href="https://www.apollographql.com/docs/graphql-tools/resolvers/#resolver-obj-argument" rel="noopener ugc nofollow" target="_blank">解析器的obj参数</a>，我们基本上告诉Apollo服务器返回当前对象的<code class="fe ny nz oa np b">id</code>值(如果存在的话)(即<code class="fe ny nz oa np b">obj</code>是一个<code class="fe ny nz oa np b">Post</code>类型)。否则，返回当前对象的<code class="fe ny nz oa np b">_id</code>字段(即<code class="fe ny nz oa np b">obj</code>是<code class="fe ny nz oa np b">PostDbObject</code>类型)。这种方法一开始可能会有点混乱。这篇文章可能会帮助你理解这些概念。</li></ul><p id="cd4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于帖子ID，解析帖子的<code class="fe ny nz oa np b">author</code>字段:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="fea1" class="nt ms it np b gy nu nv l nw nx">import {<br/>  DateTimeResolver,<br/>  EmailAddressResolver,<br/>  UnsignedIntResolver,<br/>} from 'graphql-scalars';<br/>import { ObjectID } from 'mongodb';<br/><br/>import {<br/>  Post,<br/>  PostDbObject,<br/>  PublishPostInput,<br/>  User,<br/>  UserDbObject,<br/>} from './graphql-codegen-typings';<br/>import { mongoDbProvider } from './mongodb.provider';<br/><br/>const mockCurrentUserId = '0123456789abcdef01234567';<br/><br/>export const resolvers = {<br/>  DateTime: DateTimeResolver,<br/>  EmailAddress: EmailAddressResolver,<br/>  UnsignedInt: UnsignedIntResolver,<br/>  Mutation: {<br/>    publishPost: async (<br/>      obj: any,<br/>      { input }: { input: PublishPostInput }<br/>    ): Promise&lt;PostDbObject&gt; =&gt; {<br/>      const result = await mongoDbProvider.postsCollection.insertOne({<br/>        title: input.title,<br/>        content: input.content,<br/>        publishedAt: new Date(),<br/>        author: new ObjectID(mockCurrentUserId),<br/>      });<br/><br/>      return result.ops[0] as PostDbObject;<br/>    },<br/>  },<br/>  Post: {<br/>    id: (obj: Post | PostDbObject): string =&gt;<br/>      (obj as PostDbObject)._id<br/>        ? (obj as PostDbObject)._id.toString()<br/>        : (obj as Post).id,<br/>    author: async (obj: Post | PostDbObject): Promise&lt;User | UserDbObject&gt; =&gt;<br/>      obj.author instanceof ObjectID<br/>        ? (mongoDbProvider.usersCollection.findOne({<br/>            _id: obj.author,<br/>          }) as Promise&lt;UserDbObject&gt;)<br/>        : obj.author,<br/>  },<br/>  User: {<br/>    id: (obj: User | UserDbObject): string =&gt;<br/>      (obj as UserDbObject)._id<br/>        ? (obj as UserDbObject)._id.toString()<br/>        : (obj as User).id,<br/>  },<br/>};</span></pre><ul class=""><li id="4088" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><strong class="lb iu">第43–48行:</strong>为post的<code class="fe ny nz oa np b">author</code>字段定义一个解析器。如果当前对象的<code class="fe ny nz oa np b">author</code>字段包含用户ID，则从<code class="fe ny nz oa np b">users</code>集合中检索作者的详细信息。否则，按原样返回当前对象的<code class="fe ny nz oa np b">author</code>字段(即<code class="fe ny nz oa np b">author</code>是<code class="fe ny nz oa np b">User</code>类型)。</li><li id="891b" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">第51–54行</strong>:类似于文章ID，我们使用相同的方法来规范化用户的<code class="fe ny nz oa np b">id</code>字段。</li></ul><p id="2d50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果你试图在GraphQL Playground 中再次运行相同的<code class="fe ny nz oa np b">publishPost</code>突变:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0da7" class="nt ms it np b gy nu nv l nw nx">mutation TestPublishPost($input: PublishPostInput!) {<br/>  publishPost(input:$input) {<br/>    id<br/>    title<br/>    content<br/>    publishedAt<br/>    author {<br/>      id<br/>      firstName<br/>      lastName<br/>      email<br/>    }<br/>  }<br/>}</span><span id="a8b4" class="nt ms it np b gy oh nv l nw nx"># Query variables. <br/>{<br/>  "input": {<br/>    "title": "Test 2 Title",<br/>    "content": "Test 2 content. "<br/>  }<br/>}</span></pre><p id="01a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该看到结果现在反映了来自MongoDB的“真实”数据。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="99ec" class="nt ms it np b gy nu nv l nw nx">{<br/>  "data": {<br/>    "publishPost": {<br/>      "id": "5deca77cd2f17a34441d5332",<br/>      "title": "Test 2 Title",<br/>      "content": "Test 2 content. ",<br/>      "publishedAt": "2019-12-08T07:34:20.298Z",<br/>      "author": {<br/>        "id": "0123456789abcdef01234567",<br/>        "firstName": "Test",<br/>        "lastName": "User 1",<br/>        "email": "<a class="ae ky" href="mailto:test.user1@test.com" rel="noopener ugc nofollow" target="_blank">test.user1@test.com</a>"<br/>      }<br/>    }<br/>  }<br/>}</span></pre><h2 id="6e24" class="nt ms it bd mt oj ok dn mx ol om dp nb li on oo nd lm op oq nf lq or os nh ot bi translated"><strong class="ak"> 2。实现</strong> <code class="fe ny nz oa np b"><strong class="ak">post</strong></code> <strong class="ak">查询解析器</strong></h2><p id="1a3c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们已经完成了最困难的部分。实现<code class="fe ny nz oa np b">post</code>查询应该相当简单。</p><p id="01ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">src/resolvers.ts</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="7ddf" class="nt ms it np b gy nu nv l nw nx">import {<br/>  DateTimeResolver,<br/>  EmailAddressResolver,<br/>  UnsignedIntResolver,<br/>} from 'graphql-scalars';<br/>import { ObjectID } from 'mongodb';<br/><br/>import {<br/>  Post,<br/>  PostDbObject,<br/>  PublishPostInput,<br/>  User,<br/>  UserDbObject,<br/>} from './graphql-codegen-typings';<br/>import { mongoDbProvider } from './mongodb.provider';<br/><br/>const mockCurrentUserId = '0123456789abcdef01234567';<br/><br/>export const resolvers = {<br/>  DateTime: DateTimeResolver,<br/>  EmailAddress: EmailAddressResolver,<br/>  UnsignedInt: UnsignedIntResolver,<br/>  Query: {<br/>    post: (obj: any, { id }: { id: string }): Promise&lt;PostDbObject | null&gt; =&gt;<br/>      mongoDbProvider.postsCollection.findOne({ _id: new ObjectID(id) }),<br/>  },<br/>  Mutation: {<br/>    publishPost: async (<br/>      obj: any,<br/>      { input }: { input: PublishPostInput }<br/>    ): Promise&lt;PostDbObject&gt; =&gt; {<br/>      const result = await mongoDbProvider.postsCollection.insertOne({<br/>        title: input.title,<br/>        content: input.content,<br/>        publishedAt: new Date(),<br/>        author: new ObjectID(mockCurrentUserId),<br/>      });<br/><br/>      return result.ops[0] as PostDbObject;<br/>    },<br/>  },<br/>  Post: {<br/>    id: (obj: Post | PostDbObject): string =&gt;<br/>      (obj as PostDbObject)._id<br/>        ? (obj as PostDbObject)._id.toString()<br/>        : (obj as Post).id,<br/>    author: async (obj: Post | PostDbObject): Promise&lt;User | UserDbObject&gt; =&gt;<br/>      obj.author instanceof ObjectID<br/>        ? (mongoDbProvider.usersCollection.findOne({<br/>            _id: obj.author,<br/>          }) as Promise&lt;UserDbObject&gt;)<br/>        : obj.author,<br/>  },<br/>  User: {<br/>    id: (obj: User | UserDbObject): string =&gt;<br/>      (obj as UserDbObject)._id<br/>        ? (obj as UserDbObject)._id.toString()<br/>        : (obj as User).id,<br/>  },<br/>};</span></pre><ul class=""><li id="cba0" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><strong class="lb iu">第24行:</strong>使用同样的老技巧，我们首先从resolver函数的第二个参数中获得一个post <code class="fe ny nz oa np b">id</code>，并从<code class="fe ny nz oa np b">posts</code>集合中找到具有匹配post ID的post。</li></ul><p id="87fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试<code class="fe ny nz oa np b">post</code>查询，在<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/testing/graphql-playground" rel="noopener ugc nofollow" target="_blank"> GraphQL Playground </a>中运行以下查询。使用先前<code class="fe ny nz oa np b">publishPost</code>突变的结果中的文章ID(例如，本例中的<code class="fe ny nz oa np b">5deca77cd2f17a34441d5332</code>—您的将会不同)。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="9f9c" class="nt ms it np b gy nu nv l nw nx">{<br/>  post(id: "5deca77cd2f17a34441d5332") {<br/>    id<br/>    title<br/>    content<br/>    publishedAt<br/>    author {<br/>      id<br/>      firstName<br/>      lastName<br/>      email<br/>    }<br/>  }<br/>}</span></pre><p id="8ff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它应该会返回类似如下的结果:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="a636" class="nt ms it np b gy nu nv l nw nx">{<br/>  "data": {<br/>    "post": {<br/>      "id": "5deca77cd2f17a34441d5332",<br/>      "title": "Test 1 Title",<br/>      "content": "Test 1 content. ",<br/>      "publishedAt": "2019-12-08T08:08:18.616Z",<br/>      "author": {<br/>        "id": "0123456789abcdef01234567",<br/>        "firstName": "Test",<br/>        "lastName": "User 1",<br/>        "email": "<a class="ae ky" href="mailto:test.user1@test.com" rel="noopener ugc nofollow" target="_blank">test.user1@test.com</a>"<br/>      }<br/>    }<br/>  }<br/>}</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="11e9" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">数据库中不存在的字段怎么办？</h1><p id="3577" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">到目前为止，我们已经实现了类似于<code class="fe ny nz oa np b">id</code>、<code class="fe ny nz oa np b">author</code>等字段的解析器，它们在GraphQL模式和数据库模型上都有定义。但是，在GraphQL模式中定义的、没有存储在数据库中的字段怎么办？(例如用户的<code class="fe ny nz oa np b">posts</code>、<code class="fe ny nz oa np b">followers</code>字段等。).</p><p id="82ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，GraphQL并不关心字段的数据是在哪里或者如何形成的。经验法则是:只要返回的字段类型与模式中定义的类型匹配，它们就被认为是有效的。</p><p id="6eed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到这一点，很容易实现用户的<code class="fe ny nz oa np b">posts</code>字段。只是用你的魔法来解决这个领域。</p><p id="b73d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件:<code class="fe ny nz oa np b">src/resolvers.ts</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="2668" class="nt ms it np b gy nu nv l nw nx">import {<br/>  DateTimeResolver,<br/>  EmailAddressResolver,<br/>  UnsignedIntResolver,<br/>} from 'graphql-scalars';<br/>import { ObjectID } from 'mongodb';<br/><br/>import {<br/>  Post,<br/>  PostDbObject,<br/>  PublishPostInput,<br/>  User,<br/>  UserDbObject,<br/>} from './graphql-codegen-typings';<br/>import { mongoDbProvider } from './mongodb.provider';<br/><br/>const mockCurrentUserId = '0123456789abcdef01234567';<br/><br/>export const resolvers = {<br/>  DateTime: DateTimeResolver,<br/>  EmailAddress: EmailAddressResolver,<br/>  UnsignedInt: UnsignedIntResolver,<br/>  Query: {<br/>    post: (obj: any, { id }: { id: string }): Promise&lt;PostDbObject | null&gt; =&gt;<br/>      mongoDbProvider.postsCollection.findOne({ _id: new ObjectID(id) }),<br/>  },<br/>  Mutation: {<br/>    publishPost: async (<br/>      obj: any,<br/>      { input }: { input: PublishPostInput }<br/>    ): Promise&lt;PostDbObject&gt; =&gt; {<br/>      const result = await mongoDbProvider.postsCollection.insertOne({<br/>        title: input.title,<br/>        content: input.content,<br/>        publishedAt: new Date(),<br/>        author: new ObjectID(mockCurrentUserId),<br/>      });<br/><br/>      return result.ops[0] as PostDbObject;<br/>    },<br/>  },<br/>  Post: {<br/>    id: (obj: Post | PostDbObject): string =&gt;<br/>      (obj as PostDbObject)._id<br/>        ? (obj as PostDbObject)._id.toString()<br/>        : (obj as Post).id,<br/>    author: async (obj: Post | PostDbObject): Promise&lt;User | UserDbObject&gt; =&gt;<br/>      obj.author instanceof ObjectID<br/>        ? (mongoDbProvider.usersCollection.findOne({<br/>            _id: obj.author,<br/>          }) as Promise&lt;UserDbObject&gt;)<br/>        : obj.author,<br/>  },<br/>  User: {<br/>    id: (obj: User | UserDbObject): string =&gt;<br/>      (obj as UserDbObject)._id<br/>        ? (obj as UserDbObject)._id.toString()<br/>        : (obj as User).id,<br/>    posts: (obj: User | UserDbObject): Promise&lt;Post[]&gt; =&gt;<br/>      mongoDbProvider.postsCollection<br/>        .find({<br/>          author: (obj as User).id<br/>            ? new ObjectID((obj as User).id)<br/>            : (obj as UserDbObject)._id,<br/>        })<br/>        .toArray(),<br/>  },<br/>};</span></pre><ul class=""><li id="8a31" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><strong class="lb iu">第59–66行:</strong>从解析器的第一个(<code class="fe ny nz oa np b">obj</code>)参数中获取“this”用户对象的ID。从<code class="fe ny nz oa np b">posts</code>集合中查找所有字段<code class="fe ny nz oa np b">author</code>等于“this”对象的用户ID的文章(记住作者在MongoDB的<code class="fe ny nz oa np b">posts</code>集合中存储为字符串ID)。</li></ul><p id="4a67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实现了一些解析器映射之后，您可能会发现解析器模式实际上非常相似。因此，我不会在这篇文章中讨论所有的类型字段——我留下了<code class="fe ny nz oa np b">followUser</code>、<code class="fe ny nz oa np b">unfollowUser</code>、<code class="fe ny nz oa np b">likePost</code>变异解析器以及<code class="fe ny nz oa np b">Post</code>和<code class="fe ny nz oa np b">User</code>类型中的一些字段作为练习。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="66b0" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">包扎</h1><p id="7453" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">自从今年早些时候我发表了上一篇文章以来，GraphQL生态系统已经真正成熟了。有了各种各样的工具集，开发工作流被大大简化了，用GraphQL开发已经成为一种乐趣。</p><p id="453b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这个应用程序展示了与数据库技术集成的GraphQL工具集，但为了保持设置简单，我们将GraphQL模式组合在一个文件中，并将解析器组合在一个对象中，这可能很难维护和扩展。</p><p id="5f95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的下一篇文章中，我将演示如何模块化一个可扩展的Apollo服务器——敬请期待！</p></div></div>    
</body>
</html>