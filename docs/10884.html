<html>
<head>
<title>Asynchronous JavaScript Patterns Working With Callbacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用回调的异步JavaScript模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/async-js-patterns-using-callback-5c388ac45ac5?source=collection_archive---------22-----------------------#2022-02-01">https://betterprogramming.pub/async-js-patterns-using-callback-5c388ac45ac5?source=collection_archive---------22-----------------------#2022-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e17d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看看回调设计模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/029ede3dd2db0a32024647c6c4218fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mM5PTRQWTs6eps7L"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Firmbee.com在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kv" href="https://unsplash.com/@firmbee?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍照</a></p></figure><p id="9d25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript是当今世界使用最多的计算编程语言之一[ <a class="ae kv" href="https://www.statista.com/statistics/793628/worldwide-developer-survey-most-used-languages/" rel="noopener ugc nofollow" target="_blank"> <em class="ls">参考</em> </a> ]，与Java或C++相比，它经常因简单而受到批评。但毫无疑问，这恰恰是使它如此强大和全球传播的特征之一。</p><p id="73c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这一系列管理JavaScript并发性的文章，我们将讨论一些我们在进行JavaScript开发时可能都应该拥有的工具<strong class="ky ir"> </strong>。这些系列的主要目的就是训练你在战场上使用这些武器。</p><p id="06c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要强调的是，即使有新的解决并发问题的奇特方法，每种机制都有自己的优点/缺点和用例。</p><p id="5645" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第一篇文章<em class="ls">，</em>中，我们将讨论回调，这是一种很好的解决并发任务的初始方法。</p><p id="48e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript引擎的行为与电力非常相似，它总是寻找阻力较小的路径，它会跳过任何看起来很慢的东西(<code class="fe lt lu lv lw b">setTimeouts</code>、API调用、渲染等)，并疯狂地执行最快的指令，除非我们使用机制来处理它(如回调、thunks、承诺、生成器函数、异步函数)。</p><h1 id="c66d" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated"><strong class="ak">回调</strong></h1><p id="12f8" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">这一切都来自于函数式编程，早在1930年，一些杰出的人就引入了现在所知的lambda演算——这个主题对于一篇独立的文章来说已经足够深入了。</p><p id="0b36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看下一个函数，它基本上需要两个参数并打印出它们的和，很简单，不是吗？</p><pre class="kg kh ki kj gt mu lw mv mw aw mx bi"><span id="bdcc" class="my ly iq lw b gy mz na l nb nc"><strong class="lw ir">function foo</strong>(a, b) {<br/> console.info(a + b); // 3<br/>}<br/><strong class="lw ir">foo</strong>(1,2);</span></pre><p id="4415" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是发送一个函数的引用而不是一些变量呢？—会发生什么？</p><pre class="kg kh ki kj gt mu lw mv mw aw mx bi"><span id="e615" class="my ly iq lw b gy mz na l nb nc"><strong class="lw ir">function sum</strong>(a, b){<br/> return a + b;<br/>}</span><span id="ed25" class="my ly iq lw b gy nd na l nb nc">// A function that orchestrates<br/><strong class="lw ir">function foo</strong>(callback, a , b){<br/> return callback(a,b) // this line will call our sum() <br/>}</span><span id="3a3c" class="my ly iq lw b gy nd na l nb nc"><br/>// we pass the reference of the function sum() and two numbers</span><span id="dfe0" class="my ly iq lw b gy nd na l nb nc"><strong class="lw ir">const resp </strong>= foo(sum, 1, 2)<br/>console.info(resp); // 3```</span></pre><p id="1a7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哦，我们刚刚以一种非常棒的方式链接了函数，所以我们也可以添加一个新函数<code class="fe lt lu lv lw b">subtract</code> <em class="ls"> </em>，这样只要改变对新函数的引用，我们就可以<code class="fe lt lu lv lw b">sum</code>或<code class="fe lt lu lv lw b">subtract</code>。</p><pre class="kg kh ki kj gt mu lw mv mw aw mx bi"><span id="aca6" class="my ly iq lw b gy mz na l nb nc"><strong class="lw ir">function </strong>sum(a, b){<br/> return a + b; <br/>}</span><span id="3de0" class="my ly iq lw b gy nd na l nb nc">// New Subtract function<br/><strong class="lw ir">function sub</strong>(a, b){<br/> return a — b; <br/>}</span><span id="6c54" class="my ly iq lw b gy nd na l nb nc"><strong class="lw ir">function foo</strong>(callback, a , b){<br/> return callback(a,b) // this line will call either sum() or sub()<br/>}</span><span id="7631" class="my ly iq lw b gy nd na l nb nc"><strong class="lw ir">const respSum </strong>= foo(sum, 1, 2);<br/><strong class="lw ir">const respSub </strong>= foo(sub, 1, 2); // We can now subtract too!</span><span id="09a2" class="my ly iq lw b gy nd na l nb nc">console.info(` Sum: ${respSum}` ); // 3<br/>console.info(` Sub: ${respSub}`); // -1<br/></span></pre><p id="c9ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回调模式非常常用，但在考虑异步性时，它甚至更强大。</p><p id="7d9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望我们的应用程序需要与其他API通信来获取、保存、更新数据，这给游戏带来了一些新玩家；当试图执行尽可能多的指令时，我们需要处理JavaScript引擎产生的混乱，而不用担心<br/>顺序/阻塞执行和人的合理性；亲爱的读者，这就是我所说的异步心碎。</p><p id="c317" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以复制、粘贴并执行下一段代码，你会看到JavaScript引擎如何先打印出<code class="fe lt lu lv lw b">Second Line</code>，再打印出<code class="fe lt lu lv lw b">First Line</code>；与我们真正想要的顺序相反。</p><pre class="kg kh ki kj gt mu lw mv mw aw mx bi"><span id="d8fb" class="my ly iq lw b gy mz na l nb nc"><br/><strong class="lw ir">function fetchFoo</strong>() {<br/> setTimeout(() =&gt; {<br/> console.info(‘First Line’)<br/> }, 2000)<br/> console.info(‘Second Line’)<br/>}<br/><strong class="lw ir">fetchFoo</strong>()<br/></span></pre><p id="3bfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">真正发生的是，当JavaScript引擎执行<code class="fe lt lu lv lw b"><strong class="ky ir">fetchFoo</strong>()</code>时，它将首先尝试读取并解决第一行，但是当<code class="fe lt lu lv lw b"><strong class="ky ir">setTimeout</strong></code>等待2秒时，它将<strong class="ky ir"> </strong>跳转到下一条指令并首先打印<code class="fe lt lu lv lw b">Second Line</code>。</p><p id="7654" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从理论上讲，解决这个难题的一种方法是手动传递异步任务，因为它们是同步的，这样JavaScript引擎就没有任何其他的代码分支需要优先处理，一旦完成，我们就传递新的任务，等等。让我们修改下一个代码。</p><pre class="kg kh ki kj gt mu lw mv mw aw mx bi"><span id="29b4" class="my ly iq lw b gy mz na l nb nc">// Chaining callbacks as a way of forcing sequential execution</span><span id="7164" class="my ly iq lw b gy nd na l nb nc"><strong class="lw ir">function fooBar</strong>() {<br/> cb1()<br/> function cb1() {</span><span id="6db7" class="my ly iq lw b gy nd na l nb nc">setTimeout(<strong class="lw ir">function</strong> () {<br/> console.info(‘First Line’)<br/> cb2()<br/> }, 1000)</span><span id="306d" class="my ly iq lw b gy nd na l nb nc"><strong class="lw ir">function cb2()</strong> {<br/> console.info(‘Second Line’)<br/>   }<br/> }<br/>}</span><span id="4c96" class="my ly iq lw b gy nd na l nb nc"><strong class="lw ir">fooBar()</strong><br/></span></pre><p id="46b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们基本上是强制一个连续指令的链接，这样JS引擎甚至不需要考虑一个更容易的路径，除了等待1秒钟并打印出我们最初想要的<code class="fe lt lu lv lw b">First Line</code>和<code class="fe lt lu lv lw b">Second Line</code>之外，它没有更多的选择。</p><p id="a50f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一段代码是使用相同原理的更干净、更漂亮的方法。</p><pre class="kg kh ki kj gt mu lw mv mw aw mx bi"><span id="c990" class="my ly iq lw b gy mz na l nb nc"><strong class="lw ir">function fooBar</strong>(cb1) {<br/> setTimeout(<strong class="lw ir">function </strong>() {<br/> // The function cb1() expects another callback — the cb2()<br/> cb1(function cb2 () {<br/> console.info(‘Second Line’)<br/> })<br/> }, 1000)<br/>}</span><span id="4845" class="my ly iq lw b gy nd na l nb nc">// The function cb1() will eventually read and execute another callback that is not still defined.<br/>// We will eventually define it with the next sequential instructions.</span><span id="2e40" class="my ly iq lw b gy nd na l nb nc"><strong class="lw ir">fooBar</strong>(function cb1 (cb2) {<br/> console.info(‘First Line’)<br/> cb2()<br/>})</span></pre><p id="79b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们基本上是在说:嘿，JavaScript引擎，你知道吗？我一会儿会把另一个函数传给你们，我现在不能传给你们，因为你们会试图用我不想要的方式执行它。</p><p id="ce71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以不要担心，只管做你的事，我稍后打电话给你。当计时器到达1秒并且打印出<code class="fe lt lu lv lw b">First Line</code>时，我们传递给它一个全新的代码(带有字符串<code class="fe lt lu lv lw b">Second Line</code>)来执行，这基本上被称为延迟执行。</p><blockquote class="ne nf ng"><p id="06ec" class="kw kx ls ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">回调是一种延迟执行的机制。</p></blockquote><p id="0c9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像生活中的几乎所有事情一样，有些事情需要仔细考虑。当使用回调时，我们需要同意控制反转，把程序的控制权交给别人。</p><p id="a347" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kyle Simpson在一次关于回调的谈话中说，我们可能都必须使用这种机制调用外部API，并生活在期待API不会失败的恐惧中，因为API没有办法通知我们，所以我们可以编写一个<em class="ls">紧急出口，</em>我们基本上失去了对程序的<em class="ls">控制</em>:</p><blockquote class="ne nf ng"><p id="0eb3" class="kw kx ls ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">“我的程序中有一部分是由我控制执行的。然后，我的代码中还有一部分我无法控制执行。”</p></blockquote><p id="db84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有另一个问题…信任，让我们想象一下，不知何故<code class="fe lt lu lv lw b">setTimeout</code>最终开始失败，有时不是计时1秒，而是持续100秒！—这是一个真正的痛苦—我们的程序将比我们最初预期的时间长得多，或者更糟，想象它永远不会停止—回调缺乏某种机制，当出现问题时通知我们，以便我们可以编写一个紧急出口并保护我们的计算能力。</p><p id="8f0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中的一部分。Kyle Simpson在他的一次演讲中说，回调还有另一个问题，它们不符合我们顺序阻塞的思维方式:</p><blockquote class="ne nf ng"><p id="5880" class="kw kx ls ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">当代码不像我们的大脑那样工作时，错误就会出现。</p></blockquote><p id="430c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们解决并发问题的自然方式不同于回调工作的方式，我们可能需要另一种模式来解决异步任务，这种模式不会迫使我们失去对程序的控制(控制反转),也不会在涉及第三方API时缺乏信任，顺便说一下，这是一种更合理的方法。</p><p id="be70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回调的真正问题不仅仅是回调地狱。</p><p id="f91a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一篇文章中，我们将讨论Thunks，一种稍微不同的回调模式。</p><h1 id="462b" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated"><strong class="ak">参考文献</strong></h1><ul class=""><li id="c827" class="nk nl iq ky b kz mp lc mq lf nm lj nn ln no lr np nq nr ns bi translated">〖书〗你不知道JS异步&amp;性能</li><li id="b5c7" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">MDN</li></ul></div></div>    
</body>
</html>