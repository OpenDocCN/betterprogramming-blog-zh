<html>
<head>
<title>Plot 3D Functions With Matplotlib and NumPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Matplotlib和NumPy绘制3D函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/plot-3d-functions-with-matplotlib-and-numpy-9ab0879d23b2?source=collection_archive---------8-----------------------#2020-03-03">https://betterprogramming.pub/plot-3d-functions-with-matplotlib-and-numpy-9ab0879d23b2?source=collection_archive---------8-----------------------#2020-03-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9eae" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">演示网格、矢量化和其他有用的工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2c1cd256bf36c433229fe80915acfb8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jh5ZwzdDeUcQXmZo8fN5Cg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@christianfregnan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯蒂安·弗雷南</a>在<a class="ae ky" href="https://unsplash.com/s/photos/cube?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="88bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数学是美丽的，我们手边的软件代表了探索这种美丽的无价之宝。我们以前从未能够以如此容易理解的方式可视化和实验数学对象。</p><p id="431d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我想分解使用Python绘制二元函数所需的步骤。</p><p id="6d05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此过程中，我们将学习一些NumPy过程，让您像向导一样操作矩阵。我将这个过程分解为三个概念性的步骤，这也有助于更新基础数学。</p><p id="00fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我把所有的东西都放在一个可以开箱即用的函数中，所以如果你只需要这个函数，你可以随意跳到这个函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9d87" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">定义功能域</h1><p id="b6b7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">数学函数是从一个集合中提取元素并将它们与另一个集合中的一个元素相关联的映射。第一组输入被称为函数的<em class="mz">域</em>。在我们的例子中，定义域将由实数元组组成。</p><p id="d3c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管在任何区间内都有无穷多个实数，但我们显然不能为我们的定义域存储一个无限集合。为了让我们的绘图看起来更好，在我们的域内采样足够多的点就足够了，这样最终的产品看起来会更平滑，不会有不自然的锯齿。</p><p id="76a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到这一点，我们可以分三步定义我们的域并将其存储在一组数组中。</p><ol class=""><li id="9491" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">决定我们领域中两个变量的边界:</li></ol><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="b6c2" class="no md it nk b gy np nq l nr ns">x_interval = (-2, 2)<br/>y_interval = (-2, 2)</span></pre><p id="745c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.每个间隔内的采样点:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="3578" class="no md it nk b gy np nq l nr ns">x_points = np.linspace(x_interval[0], x_interval[1], 100)<br/>y_points = np.linspace(y_interval[0], y_interval[1], 100)</span></pre><p id="800d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.取这两个采样集的<a class="ae ky" href="https://en.wikipedia.org/wiki/Cartesian_product" rel="noopener ugc nofollow" target="_blank">笛卡尔乘积</a>来产生两个数组，这两个数组(当堆叠时)形成一组有序对，我们可以在其上计算函数:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="f8bc" class="no md it nk b gy np nq l nr ns">X, Y = np.meshgrid(x_points, y_points)</span></pre><p id="4ae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在定义我们的领域时，我们使用了NumPy的一些有用的工具:</p><ul class=""><li id="d90f" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nt ng nh ni bi translated">这个函数产生一个均匀分布的实数序列。我还发现它的表亲<code class="fe nu nv nw nk b">np.logspace</code>，对于制作超参数值的网格来尝试建模之类的事情很有用。</li><li id="4299" class="na nb it lb b lc nx lf ny li nz lm oa lq ob lu nt ng nh ni bi translated">文档说它最好——mesh grid从坐标向量中产生坐标矩阵如果将坐标矩阵一个接一个地堆叠起来，就会得到一个元组网格，可以用作两个变量函数的输入。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="14c9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">计算函数值</h1><p id="4080" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下一步是将输出值与输入域中的每个点相关联。这是我们可以使用不同功能的地方。我发现Ben Joffe的<a class="ae ky" href="https://www.benjoffe.com/code/tools/functions3d/examples" rel="noopener ugc nofollow" target="_blank">“Functions 3D:Examples”</a>网页是一个很好的灵感来源。</p><p id="4a8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以再次用三个步骤来计算我们的输出集。</p><ol class=""><li id="f8ee" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">将我们的数学函数定义为两个标量输入的Python函数:</li></ol><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="819f" class="no md it nk b gy np nq l nr ns">def func3d(x, y):<br/>    return -np.sin(10 * (x**2 + y**2)) / 10</span></pre><p id="5819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.生成可在输入向量或矩阵上调用的函数的矢量化版本:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="9465" class="no md it nk b gy np nq l nr ns">func3d_vectorized = np.vectorize(func3d)</span></pre><p id="3db6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.从我们的两个域数组计算一个输出数组:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="0825" class="no md it nk b gy np nq l nr ns">Z = func3d_vectorized(X, Y)</span></pre><p id="504d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NumPy提供的<code class="fe nu nv nw nk b"><a class="ae ky" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.vectorize.html" rel="noopener ugc nofollow" target="_blank">vectorize</a></code>函数对于将Python编写的自定义函数扩展到<a class="ae ky" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html" rel="noopener ugc nofollow" target="_blank"> ndarray </a>矩阵和数组非常有用。它极大地增加了NumPy的灵活性，值得添加到您的工具包中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="251c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">绘制函数图</h1><p id="3168" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">从这一点来看，事情的进展几乎与他们用Matplotlib 制作2D图的方式相同。为了产生漂亮的3D可视化效果，只需要更改一些参数和方法名。</p><ol class=""><li id="fdcc" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">用<code class="fe nu nv nw nk b">projection='3d'</code>设置绘图图形和坐标轴:</li></ol><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="1989" class="no md it nk b gy np nq l nr ns">plt.figure(figsize=(20, 10))<br/>ax = plt.axes(projection=’3d’)</span></pre><p id="aa24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.选择轴对象的绘图方法，并在我们的函数数据上调用它:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="de2c" class="no md it nk b gy np nq l nr ns">ax.plot_surface(X, Y, Z, rstride=1, cstride=1,<br/>                cmap=’terrain’, edgecolor=None)</span></pre><p id="34c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.设置绘图的其他属性，如标题和轴标签:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="4cda" class="no md it nk b gy np nq l nr ns">ax.set(xlabel=”x”, ylabel=”y”, zlabel=”f(x, y)”, <br/>       title=”Cool Function”)</span></pre><p id="4b4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多绘图方法和参数，请参考<a class="ae ky" href="https://matplotlib.org/mpl_toolkits/mplot3d/tutorial.html" rel="noopener ugc nofollow" target="_blank"> mplot3d教程</a>。有关cmap参数的更多颜色图，请参考Matplotib <a class="ae ky" href="https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html" rel="noopener ugc nofollow" target="_blank">颜色图教程</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="056d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">综合考虑</strong></h1><p id="deb8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了使这个过程更具可重复性，我将所有这些步骤打包到一个Python函数中，用于快速生成表面图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/7cf140ef15581ef9f8e329a9fca51cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1lU6hV6xWJ3SGAPXYAO4g.png"/></div></div></figure><p id="ac61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，打包和模块化绘图工具仍然是一门艺术，它取决于个人喜好。特别是像Matplotlib这样的库，它是从一个主要用于交互使用的绘图工具发展而来的(<a class="ae ky" href="https://www.mathworks.com/help/matlab/ref/plot.html" rel="noopener ugc nofollow" target="_blank"> MATLAB plot </a>)，它可能会觉得有点不自然地将调用它们的副作用的代码序列改编成更具功能性的东西。</p><p id="128a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我在包装3D绘图代码时的主要考虑。在创建其他绘图工具时，我往往不得不做出类似的决定。</p><h2 id="4fcc" class="no md it bd me of og dn mi oh oi dp mm li oj ok mo lm ol om mq lq on oo ms op bi translated"><strong class="ak">参数暴露</strong></h2><p id="85a9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我希望能够调整的主要旋钮是功能域、创建域网格的粒度以及将用于产生输出的实际功能。因此，这是我的前三个论点。</p><p id="7e71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时我也喜欢暴露绘图方法的参数或图形或轴对象的属性设置。在本例中，我将title属性公开为可以在初始函数调用期间设置的内容。</p><h2 id="a9a6" class="no md it bd me of og dn mi oh oi dp mm li oj ok mo lm ol om mq lq on oo ms op bi translated"><strong class="ak">使用</strong> <code class="fe nu nv nw nk b"><strong class="ak">*args</strong></code> <strong class="ak">或</strong> <code class="fe nu nv nw nk b"><strong class="ak">**kwargs</strong></code></h2><p id="512d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我喜欢使用<code class="fe nu nv nw nk b"><a class="ae ky" href="https://www.geeksforgeeks.org/args-kwargs-python/" rel="noopener ugc nofollow" target="_blank">**kwargs</a></code>来传递绘图方法的参数，这样我就可以快速地试验可选的颜色图和其他美学参数。</p><p id="b992" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，<code class="fe nu nv nw nk b">**kwargs</code>这个名字只是一个约定，所以有时候我喜欢用更描述性的名字来命名。</p><h2 id="3a66" class="no md it bd me of og dn mi oh oi dp mm li oj ok mo lm ol om mq lq on oo ms op bi translated"><strong class="ak">返回对象</strong></h2><p id="6f8d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我偏爱<a class="ae ky" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>，所以我试着设计我的绘图函数，感觉它们没有<a class="ae ky" href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="noopener ugc nofollow" target="_blank">副作用</a>。通过使用<code class="fe nu nv nw nk b"><a class="ae ky" href="https://matplotlib.org/3.1.3/api/_as_gen/matplotlib.pyplot.close.html" rel="noopener ugc nofollow" target="_blank">plt.close()</a></code>并返回我的图形和轴对象，我有效地分离了我的情节的创建和可视化。</p><p id="f35f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然从技术上来说，这并没有消除Matplotlib的副作用，而是在它们可以做任何事情之前清理它们，但这仍然足以让我满意。</p><p id="ba26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回图形和轴对象允许进一步的定制或更改。例如，要改变图形大小，您可以调用<code class="fe nu nv nw nk b">fig.set_size_inches(&lt;new_width&gt;, &lt;new_height&gt;)</code>。要更改剧情标题，可以调用<code class="fe nu nv nw nk b">ax.set(title=&lt;new_title&gt;)</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5d53" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="7844" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，我们知道了生成3D可视化所需的步骤，因此数学之美更容易在我们的指尖获得。</p><p id="1793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要查看，步骤如下:</p><ol class=""><li id="bf3d" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">定义功能域:使用<code class="fe nu nv nw nk b"><a class="ae ky" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html" rel="noopener ugc nofollow" target="_blank">np.linspace</a></code>沿着我们的输入变量采样点，并使用<code class="fe nu nv nw nk b"><a class="ae ky" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.meshgrid.html" rel="noopener ugc nofollow" target="_blank">np.meshgrid</a></code>创建输入网格。</li><li id="cd22" class="na nb it lb b lc nx lf ny li nz lm oa lq ob lu nf ng nh ni bi translated">计算函数值:定义一个两变量的函数——然后使用<code class="fe nu nv nw nk b"><a class="ae ky" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.vectorize.html" rel="noopener ugc nofollow" target="_blank">np.vectorize</a></code>将其应用于我们的输入网格。</li><li id="cc74" class="na nb it lb b lc nx lf ny li nz lm oa lq ob lu nf ng nh ni bi translated">绘图功能:用<code class="fe nu nv nw nk b"><a class="ae ky" href="https://matplotlib.org/mpl_toolkits/mplot3d/index.html" rel="noopener ugc nofollow" target="_blank">projection=’3d’</a> </code>创建Matplotlib图形和轴–然后调用绘图方法，并设置附加参数。</li></ol><p id="90e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以看到我是如何将代码打包成可重用的东西的。我简要地讨论了接口设计，谈到了直接公开哪些参数，使用哪些内部方法来传递参数以使用<code class="fe nu nv nw nk b">*args</code>或<code class="fe nu nv nw nk b">**kwargs</code>，以及返回图形和轴对象<a class="ae ky" href="https://medium.com/@rayheberer/generating-matplotlib-subplots-programmatically-cc234629b648" rel="noopener">如何允许进一步的下游定制</a>，同时使代码感觉更有功能性。</p><p id="d4b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请随意分享你发现的最酷的功能。如果你包括你的代码，加分。密谋愉快！</p></div></div>    
</body>
</html>