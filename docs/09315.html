<html>
<head>
<title>How To Animate AutoLayout Constraints in MVVM With Combine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用联合收割机在MVVM设置自动布局约束的动画</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-animate-autolayout-constraints-in-mvvm-with-combine-c78519d73e3b?source=collection_archive---------8-----------------------#2021-08-10">https://betterprogramming.pub/how-to-animate-autolayout-constraints-in-mvvm-with-combine-c78519d73e3b?source=collection_archive---------8-----------------------#2021-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a3d2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在您的iOS应用程序中轻松制作视图动画</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0d5ef2990e7efe0c05091b52c7bfa914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rUBG8HXd0jRgPZen"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@raagesh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Raagesh C </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="df00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我上周的文章中，我们探索了如何使用AutoLayout编写应用程序的布局。</p><p id="96b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这项技术比操纵框架更具声明性。虽然比较冗长，但是我们可以很容易地创建一个小的<a class="ae ky" href="https://www.jetbrains.com/mps/concepts/domain-specific-languages/" rel="noopener ugc nofollow" target="_blank">域特定语言(DSL) </a>来简化它。它还会自动为我们处理许多事情，这是一个非常好的优势。</p><p id="0ac5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本周，我把探索推进了一点。我想学习如何在MVVM应用程序中设置布局变化的动画。在与这项技术斗争了一段时间后，我达到了我的目标，我对它的优雅感到惊讶。</p><p id="09a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天我想和大家分享我学到的东西。</p><h1 id="aae6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">目标</h1><p id="e92a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">作为一个实际例子，我决定实现一个简单的屏幕，有两个圆形视图和一个按钮。这两个视图代表两个球:一个红色的球和一个蓝色的球。这个动作的按钮允许我们交换他们的位置。</p><p id="b680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目标是使动作动画化，以便两个球在屏幕上移动。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/2dcad532c1e1b42fe8a19c6b56178363.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/1*ZXy2PXpHFZSv_zD3qxeiig.gif"/></div></figure><h1 id="1be6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">如何做</h1><p id="49fe" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">做这件事的理论很简单。首先，让我们定义我们需要的成分，并设置初始状态:</p><ol class=""><li id="0d2b" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">定义<strong class="lb iu">状态A </strong>的布局(红色球在屏幕顶部，蓝色球在底部)。</li><li id="c752" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">定义<strong class="lb iu">状态B </strong>的布局(蓝色球在屏幕顶部，红色球在底部)。</li><li id="4781" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">设置<strong class="lb iu">状态A </strong>为初始状态。</li></ol><p id="d864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们就可以实施行动了。点击按钮后，我们只需要:</p><ol class=""><li id="a38b" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">取消两个球的所有约束(我们可以保留不变量:宽度和高度约束)。</li><li id="be8b" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">激活最终布局(如果我们处于<strong class="lb iu">状态A </strong>，我们想激活<strong class="lb iu">状态B </strong>，反之亦然)。</li><li id="dce0" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">在<code class="fe nh ni nj nk b">UIView.animate()</code>块内调用<code class="fe nh ni nj nk b">self.layoutIfNeeded()</code>函数。</li></ol><p id="7dcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这些简单的步骤，我们将看到视图在你的眼睛下面活动。现在，让我们把理论转化为代码！</p><h1 id="386d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">ViewModel</h1><p id="2c51" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们小屏幕的视图模型如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1bb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们只有一个<code class="fe nh ni nj nk b">Bool</code>来跟踪当前状态:无论<code class="fe nh ni nj nk b">redBall</code>是否在屏幕的顶部。<code class="fe nh ni nj nk b">Bool</code>是<code class="fe nh ni nj nk b">@Published</code>，所以我们可以对它的变化做出反应。然后我们有一个小函数在<code class="fe nh ni nj nk b">Bool</code>的两种状态之间移动。</p><p id="7f9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:在一个复杂的应用程序中，bool可以用一个代表应用程序状态的enum来代替。这种方法可以使基于当前状态激活正确的布局变得非常容易。</p><h1 id="a6e4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">视角</h1><p id="1049" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个视图与我的另一篇文章中的模式相同，所以我不会说太多细节。为了总结这种方法，我们必须:</p><ol class=""><li id="e4f2" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">定义子视图。</li><li id="a998" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">用<code class="fe nh ni nj nk b">setup()</code>方法将它们添加到超级视图中。</li><li id="f5ae" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">用一种<code class="fe nh ni nj nk b">style()</code>方法来设计它们。</li><li id="6548" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">用一种<code class="fe nh ni nj nk b">setupConstraints()</code>的方法来布局它们。这里我们将定义视图初始状态的约束。</li><li id="064f" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">用<code class="fe nh ni nj nk b">setupBindings()</code>方法观察视图模型的变化。</li></ol><p id="b386" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动画逻辑由<code class="fe nh ni nj nk b">setupBindings()</code>方法启动。当视图模型改变时，我们必须更新我们的布局，我们必须动画它。完成此任务的代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2db4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的逻辑都发生在<code class="fe nh ni nj nk b">sink</code>方法的<code class="fe nh ni nj nk b">receiveValue</code>闭包内:</p><ol class=""><li id="03d9" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">我们使当前的约束无效。</li><li id="b398" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">我们激活最终状态的约束。</li><li id="6231" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">我们将变化动画化。</li></ol><h1 id="5a47" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使约束无效</h1><p id="cb2d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要使约束无效，我们首先需要检索当前活动的约束。</p><p id="ef23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过一番调查，我发现:</p><ul class=""><li id="e739" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu nn mz na nb bi translated">绑定两个视图的约束由超级视图持有。</li><li id="53df" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu nn mz na nb bi translated">与单个视图相关的约束由视图本身持有。</li></ul><p id="c760" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们有以下内容:</p><ul class=""><li id="676b" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu nn mz na nb bi translated">约束<code class="fe nh ni nj nk b">self.redBall.topAnchor.constraint(equalTo: self.safeAreaLayoutGuide.topAnchor</code>由<code class="fe nh ni nj nk b">redBall</code>的主管持有；它连接<code class="fe nh ni nj nk b">redBall</code>和超级视图。</li><li id="eee8" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu nn mz na nb bi translated">约束<code class="fe nh ni nj nk b">self.redBall.widthAnchor.constraint(equalToConstant: 100)</code>由<code class="fe nh ni nj nk b">redBall</code>自身持有；它仅引用当前视图。</li></ul><p id="ba0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我创建了这个小函数来从<code class="fe nh ni nj nk b">superview.constraints</code>属性中提取给定视图的所有约束:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="8a0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong><code class="fe nh ni nj nk b">constraints</code>属性只包含<code class="fe nh ni nj nk b">active</code>约束。一旦我们将<code class="fe nh ni nj nk b">isActive</code>属性设置为<code class="fe nh ni nj nk b">false</code>，约束就会被数组清除。</p><h1 id="f68b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">激活最终状态</h1><p id="0e50" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这一步中，我们实现逻辑来决定最终状态。然后，我们必须激活与之相关的约束。在我们的例子中有两种状态:<code class="fe nh ni nj nk b">redBall</code>可以在屏幕的顶部或底部。下面是展示视图的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="db18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码片段显示了两个函数，它们根据我们想要表示的状态激活正确的约束集。</p><p id="08c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有复杂的决策逻辑，我们可以只在视图模型上写逻辑。</p><h1 id="c933" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">将变化制成动画</h1><p id="b6f0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后，我们使用标准的<code class="fe nh ni nj nk b">UIView.animate</code>函数将这些变化制作成动画，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7f69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到动画闭包的主体是单个系统调用，我惊呆了！</p><p id="e91a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注:</strong>我陷入的一个陷阱就是用<code class="fe nh ni nj nk b">self.updateConstraints()</code>而不是用<code class="fe nh ni nj nk b">self.layoutIfNeeded()</code>。前一个函数使用最终状态强制立即渲染。系统忽略了<code class="fe nh ni nj nk b">animate</code>功能，导致从一种状态突然切换到另一种状态。</p><h1 id="42ab" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="02a9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在今天的文章中，我们在之前所学的<a class="ae ky" href="https://medium.com/nerd-for-tech/programmatic-autolayout-in-mvvm-a06cc9e52890" rel="noopener">的基础上进行了构建。我们学习了如何使用</a><a class="ae ky" href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="noopener ugc nofollow" target="_blank">有限状态机(FSM) </a>模型在MVVM架构中制作布局动画，其中机器的每个状态都可以映射到视图的特定布局。</p><p id="528b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://gist.github.com/cipolleschi/a1251fbbfb82b7970bd4f1e3893b8b11" rel="noopener ugc nofollow" target="_blank">这个链接</a>找到视图的完整代码。</p><p id="9325" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，实现动画的步骤如下:</p><ol class=""><li id="3b0b" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">取消激活当前约束。</li><li id="eb80" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">激活最后几个。</li><li id="0b48" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">调用<code class="fe nh ni nj nk b">UIView.animate</code>动画块中的<code class="fe nh ni nj nk b">self.layoutIfNeeded()</code>函数。</li></ol><p id="e961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要取消激活当前的约束，我们必须知道约束存储在哪里。在本例中，我们必须在父节点的<code class="fe nh ni nj nk b">constraints</code>属性中搜索它们。</p><p id="9504" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种选择是为约束保留局部变量，这样我们可以很容易地激活和停用它们。在一个非常复杂的视图中，这可能比过滤所有可用的约束更容易和更有效。这种方法的缺点是它引入了一些需要维护的状态变量。</p><p id="dbf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个优化决策，需要具体情况具体分析。留意你的选择，选择能带来最好结果的那一个。</p></div></div>    
</body>
</html>