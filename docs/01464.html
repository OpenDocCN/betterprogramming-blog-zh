<html>
<head>
<title>Containers and Virtual Machines: A Process Perspective</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">容器和虚拟机:流程视角</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/containers-and-virtual-machines-a-process-perspective-309c395d868c?source=collection_archive---------10-----------------------#2019-09-12">https://betterprogramming.pub/containers-and-virtual-machines-a-process-perspective-309c395d868c?source=collection_archive---------10-----------------------#2019-09-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c30801a05245ee4b95529975f1dadcdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ1vXC3aVnLpJAXy20Wdg.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">弗兰克·麦肯纳在Unsplash<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">上的照片</a></p></figure><p id="1ac1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在之前的一篇文章中概述了容器和虚拟机之间的区别。首先<a class="ae kf" href="https://medium.com/better-programming/containers-and-virtual-machines-an-overview-94c558905b6" rel="noopener">阅读那篇文章</a>会有助于更好地理解我们将在这里做什么。</p><p id="a71d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">容器和虚拟机之间的关键区别在于，容器实际上与容器主机共享内核并在其上运行，而虚拟机是完整的操作系统安装。</p><p id="5fd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">说明这一点的最佳方式是在一些不同的场景中实际运行和监控进程，并查看机器上发生了什么。</p><p id="8623" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我进行这个小实验的动机是因为我试图更好地理解容器和虚拟机是如何工作的，这时我在Stack Exchange上发现了一个帖子，它让我清楚地认识到:</p><div class="le lf gp gr lg lh"><a href="https://unix.stackexchange.com/questions/216618/what-do-the-processes-inside-a-docker-container-look-like" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">Docker容器中的进程看起来像什么？</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">Unix &amp; Linux Stack Exchange是一个问答网站，面向Linux、FreeBSD和其他类似Un*x的操作系统的用户</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">unix.stackexchange.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv jz lh"/></div></div></a></div><p id="d28f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将经历一系列类似的步骤，并希望在这个普遍了解甚少的领域中发出更多的光芒。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6ee4" class="md me it bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">锻炼</h1><p id="6be3" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">我想在不同的上下文中运行相同的过程，以说明这些环境隔离技术之间的确切区别。对于所有情况，我将执行<code class="fe ng nh ni nj b">sleep &amp; sleep &amp;</code>，它在后台运行两个sleep (delay)进程。</p><h2 id="7dfe" class="nk me it bd mf nl nm dn mj nn no dp mn kr np nq mr kv nr ns mv kz nt nu mz nv bi translated">拓扑学</h2><p id="5694" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">下图描述了我们将在笔记本电脑上检查的每个案例的架构逻辑层次。</p><figure class="nx ny nz oa gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/5fcffd40fb1ecec37d9bd87bd61292fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7_fb3pdzm6vlW_mA7p5B8Q.png"/></div></div></figure><h2 id="9794" class="nk me it bd mf nl nm dn mj nn no dp mn kr np nq mr kv nr ns mv kz nt nu mz nv bi translated">案例1:在我的笔记本电脑操作系统上执行</h2><p id="211d" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">在我的笔记本电脑上，我运行了这个命令，并返回了两个进程id。</p><figure class="nx ny nz oa gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/f3b9e5eb85fe23d86adf89c518b4fc3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4z8AjffGlAmqMocP5g9MSw.png"/></div></div></figure><p id="04f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在进程中搜索“sleep ”,我可以看到两个刚刚产生的进程，它们正在我的Mac OS上运行并受其控制。</p><figure class="nx ny nz oa gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/6a10ae17a983aaa9f5529e9e33045ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0y75bMJK2KQ364PkRIZLjw.png"/></div></div></figure><h2 id="30a8" class="nk me it bd mf nl nm dn mj nn no dp mn kr np nq mr kv nr ns mv kz nt nu mz nv bi translated">案例2:在虚拟机中执行</h2><p id="5566" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">我启动了一个Ubuntu虚拟机。现在，这是一个运行在type-2 VirtualBox虚拟机管理程序上的客户操作系统，而虚拟机管理程序又运行在主机(我的电脑)上。</p><figure class="nx ny nz oa gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/c50616d0f04e64b2ebc9cf0d2386e1d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cDqDv4ifOTSiZVYso2IMLA.png"/></div></div></figure><p id="1f78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，在VM中，我执行sleep命令，并再次返回两个进程id。</p><figure class="nx ny nz oa gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/52f834ddc0be2c4dff7656ca298f55c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cN2HoSy7tz5nAGaxoFyaLg.png"/></div></div></figure><p id="f958" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我搜索正在运行的睡眠命令，并看到我刚刚生成的命令。</p><p id="af58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:在客户操作系统中，你看不到主机操作系统的进程。</p><figure class="nx ny nz oa gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/c112ea5a9676824f01fddd67c260bd46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5z_7u1w4DiIvCsnX0F2YdA.png"/></div></div></figure><p id="28df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们回到主机操作系统时，请注意我们现在看不到来宾操作系统进程。这是因为来宾操作系统是一个管理自己进程的完全操作系统。</p><figure class="nx ny nz oa gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/342cd9a632e9efa70194eed1854bbb6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9zQL4J5sKsMj8vDVBFOgNQ.png"/></div></div></figure><h2 id="9d8f" class="nk me it bd mf nl nm dn mj nn no dp mn kr np nq mr kv nr ns mv kz nt nu mz nv bi translated"><strong class="ak">案例3:在容器内执行</strong></h2><p id="22ba" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">我需要在虚拟机内部运行docker，因为它是Linux自带的。因此，虚拟机是<em class="oh"> c </em>容器主机/停靠器主机<em class="oh">T5】，即使它本身是一个客户操作系统。为了清楚起见，请参考拓扑图。</em></p><p id="e98b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我运行了一个Ubuntu容器，在容器内的<em class="oh">和其他情况一样，我执行睡眠命令。然后我搜索睡眠进程，我只能在容器中看到我刚刚生成的进程。</em></p><figure class="nx ny nz oa gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/42859ea9db8976be7713a659842c23e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Li2mMJouz67Eujm9UrF_A.png"/></div></div></figure><p id="4d24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">注意:</strong>然而，现在当我返回VM并查看哪些睡眠进程正在运行时，我看到两个新进程:10440和10441。这些是在容器中运行的进程。</p><figure class="nx ny nz oa gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/f6d5b1557502bde61845074c291cf845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yLLbb3CjPQFRxsGeaFwQ3w.png"/></div></div></figure><p id="bb9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以做一些检测工作，沿着流程ID树向上搜索，直到到达顶级容器执行流程。这表明容器在逻辑上是隔离的，但实际上它是作为Docker主机上的一个进程运行的，而不是一个单独的操作系统。</p><figure class="nx ny nz oa gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/ff3235b27d2b62ac7868f22eab6eabb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CR81hY3No3Opiu0wKR5k8g.png"/></div></div></figure><p id="fd31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些案例对我个人理解这些工作负载隔离技术实际上是如何工作的以及为什么它们感觉如此不同非常有用。希望这对你也有同样的效果。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="05f1" class="md me it bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">资源</h1><div class="le lf gp gr lg lh"><a href="https://linuxhint.com/sleep_command_linux/" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">Linux中的睡眠命令</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">Sleep命令用于在任何脚本执行期间延迟固定的时间。当编码者需要…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">linuxhint.com</p></div></div><div class="lq l"><div class="ol l ls lt lu lq lv jz lh"/></div></div></a></div></div></div>    
</body>
</html>