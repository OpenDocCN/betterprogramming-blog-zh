# 了解 IDORs 以保护您的 Python Web 应用程序

> 原文：<https://betterprogramming.pub/understand-idors-to-secure-your-python-web-applications-250217b92d48>

## 以加密货币代码为例，深入探讨最流行的网络攻击技术之一

![](img/7028edbcad7b44ccd5fd044617e963f5.png)

利亚姆·塔克在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

作为一名安全人员和开发人员，有时我会被问到，我作为安全研究人员的经历是否对我编写 web 和移动应用程序有所帮助。事实是是的，写代码的时候确实帮了我很多。在我的开发工作流程中，我通常会测试到目前为止我构建的每一个特性，并且我非常自信地说，我编写的大部分都是安全的代码。然而，每个人都会犯错误，最近，我在我正在构建的 API 中遇到了一些错误，我将在稍后的时间讨论这些错误。

## 从开发人员的角度来看，IDORs 是什么？

在直接跳到代码示例之前，让我简单地向您介绍一下 IDORs。顾名思义，不安全的直接对象引用告诉我们，当 web 应用程序具有不安全的对象引用结构时，就会出现这种漏洞。简而言之，当用户试图直接访问/修改对象(例如，待办事项列表)时，应用程序不检查认证/授权。这意味着任何未被认证为该待办事项列表所有者的用户都可以访问/修改该待办事项列表，这导致了一个很大的安全问题。

## 简单的第一个场景

为了更好地理解乍一看的东西，最有效的技术是将理论内容与实际材料相结合。那么，让我们看看一个简单的 IDOR 是什么样子的。

让我们继续使用待办事项应用程序，假设用户 A 创建了一个待办事项列表。创建该对象时，有三个 API 调用:

*   一个到端点`api/v1/todolist/new`，返回一个 JSON 响应，看起来像这样`{"created":true, "ownerUUID":"somelonguuid", "listID":123456, "listName":"Test To-Do-List"}`
*   在第一次调用之后，应用程序使用以下 JSON 数据调用端点【T2:】
*   最后，为了呈现列表中的内容，我们看到一个对`api/v1/todolist/123456`的调用，它用一些 JSON(listcontent，listname，等等)来响应。)

现在，您可能会想，通过最后两个 API 端点，有两种可能的 IDOR 场景。

`**GET api/v1/todolist/123456**`

在这个例子中，我们可以通过在用户 B 的浏览器上打开`[https://example.com/api/v1/todolist/123456](https://example.com/api/v1/todolist/123456)`进行测试，看看我们是否可以访问用户 A 的待办事项列表。这是一个例子，说明应用程序**如何在没有检查认证的情况下不安全地将`123456`待办事项列表引用给用户 B(在这种情况下，问题是认证，但也可能是授权)。在现代 WebApps 中很难找到这样一个低悬的 IDOR，但它仍然让您了解了 IDOR 是如何工作的。**

## 第二个简单的场景

`**PUT api/v1/todolist/edit/123456**`

这与第一个场景类似。这里的 IDOR 可以通过向该端点发出 PUT 请求来编辑`123456`待办事项列表，而不是列表的所有者。

现在，我最近在一个大型应用程序中遇到的一个问题是，该应用程序安全地引用了 POST 和 GET 请求，而不安全地引用了 PUT 请求。这让您大致了解了错过那些使您能够安全引用对象的代码行是多么容易。

# 代码示例

既然您已经了解了 IDORs 是如何工作的，那么让我们深入研究一下我刚才谈到的代码示例。这些帮助我创建了一个有效的方法来在编写代码时处理所有这些 IDORs。

在本文中，我将使用 Django 框架，但如果您不是在您的应用程序中使用它，请不要担心，查找和修复这些 bug 的过程是相同的。

## 认证问题—案例 1

**尝试在上面的代码中找出问题。**

你可能已经找到了。看一眼之后，你就能看出哪里出了问题。`index_object`函数有两个参数:

*   response，这是让 Django 显示响应并从请求中获取数据的请求
*   id，该对象的 id，稍后将用于获取我们的`ObjectModel`中与那个`id`匹配的对象。

然后函数`gets()`调用请求的对象，并在响应中将它作为`"object"`变量返回。

考虑到被请求的对象是用户私有的，这意味着任何用户只要知道`id`就可以请求另一个用户私有`object`。

**为什么？**

这是因为在请求`object`时缺少认证。首先，根据模型(对象)数据库，您需要检查请求`id`对象的用户实际上是否可以访问它。

你如何解决这个问题？

添加身份验证控制层:

在这个简单的例子中，一个`if`语句将完成这项工作。在第 3 行，我检查了`requested_object`是否包含在`users`中。如果满足条件，app 会在响应中包含`requested_object`；如果不是，响应将包含一个到登录页面的重定向。

## 认证问题—案例 2

现在，我将向您展示一个稍微复杂一些的情况，其中 API 在 URL 中接收两个或更多参数。例:`api/v1/portfolio/1/crypto/1`。现在，你可能已经猜到我们在谈论一个加密投资组合应用程序。

在这个请求中发生的事情是，用户正在请求带有`id=1`的投资组合，而带有`id=1`的加密存储了那个投资组合。

因此，我们的安全API 处理函数将如下所示:

**注意:**这里我使用一个序列化器来处理 Django Rest 框架(DRF)

使用以下代码，代码看起来相当安全:

1.  如果用户“拥有”它，就用`id=1`获得投资组合
2.  使用`id1=1`获取属于该投资组合的加密

但这是可能的，因为 **Crypto** ( `crypto_set`)模型(它是 Django 模型)“**”属于 **Portfolio** 模型(使用`models.ForeignKey`)，这意味着您可以获得绑定到特定 Portfolio 的所有加密，而不需要另一个认证控制(`portfolio.crypto_set.get()`)。**

我在其他代码片段中看到的一个错误是，在这种情况下，没有将加密模型链接到投资组合模型**和**仅在访问投资组合时执行认证控制。

这样说似乎有些含糊，所以让我们深入代码看看到底发生了什么:

你现在明白了吗？

该函数仅验证该用户是否拥有所请求的投资组合，但无法检查该用户是否也拥有所请求的加密，因为它与已经请求的投资组合无关。

**影响**

假设以下情况:

*   受害者拥有投资组合`1`和密码`3`
*   攻击者拥有投资组合`2`和密码`2`
*   `api/v1/portfolio/{id}/crypto/{id1}`的处理函数是上面代码片段中的函数，端点返回受害者拥有多少个特定硬币的密码(`id1=2`

攻击者可以请求以下内容:`api/v1/portfolio/2/crypto/3`

该函数将验证攻击者拥有 portfolio 2，然后呈现与 crypto `3`相关的信息:攻击者刚刚获得了受害者信息的访问权。

注意，查找和修复 IDORs 的过程与 POST、PUT、DELETE 和 GET 请求完全相同(至少对于 Django 是这样)。

## 授权问题

IDORs 还可以处理应用不当的授权控制。让我们从一个例子开始:受害者以查看者权限与攻击者共享一个文档，但攻击者可以利用某个漏洞(可以是各种 bug)以任何方式编辑该文件。这是一个授权问题。

但是如何将这些应用于 IDOR 呢？

让我们坚持使用加密组合的例子。投资组合的所有者可以与其他用户共享该投资组合，但只有查看者权限。

向投资组合添加加密的 PUT 请求如下所示:

```
PUT api/v1/portfolios/{"portfolioID":"12345", "crypto":"MANA"}
```

现在，我想让你快速看一下处理函数是什么样子的:

在这个五行代码片段中，我们正在执行我们通常的身份验证控制，如果请求方法被放置，我们就用`id=id`将 crypto 添加到组合中。

如果这个文件夹与攻击者共享了查看权限，这意味着攻击者不能将密码添加到该文件夹中，会怎么样？如果`api/v1/portfolios`端点使用了上面的函数，攻击者可以在不是编辑者的情况下向该文件夹添加加密。这是因为缺少授权控制。该函数不检查请求 PUT 请求的用户是否具有编辑权限；它只检查该用户是否有权访问所请求的投资组合。

修复将如下所示:

在第 5 行，我们检查用户是否有编辑权限。如果是，创建添加加密；如果不是，则返回一个授权错误。

# 结论

我写这篇文章是为了帮助开发者理解他们也应该注意开发一个安全的应用程序。而且开发一个功能性应用和一个**安全**功能性应用是完全不同的两件事。此外，清楚地了解最流行的网络攻击技术是如何工作的，并知道如何预防这些技术，在找工作时会非常有价值，这对你的投资组合也很有帮助。