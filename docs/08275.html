<html>
<head>
<title>5 Tips To Write Clean Swift Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写干净Swift代码的5个技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-tips-to-write-clean-swift-code-2ef287a11500?source=collection_archive---------1-----------------------#2021-04-13">https://betterprogramming.pub/5-tips-to-write-clean-swift-code-2ef287a11500?source=collection_archive---------1-----------------------#2021-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="32d6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高我们代码编写技能的快速技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1393b36fe0388da76a4a9cef59f2f776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5oq9QSnTRAZoqkYm"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马克斯维尔·纳尔逊在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e2e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个好的软件工程师不仅仅是一个能写软件高效解决问题的人。他们比编写聪明的单行解决方案更能写出健壮、易读、易维护的代码。</p><p id="8d3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优秀的软件工程师会发现他们可以在哪里简化代码，使用模式，或者重构代码片段以使它们变得更好。</p><p id="07ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们探索我最喜欢的五种方法，在Swift中编写更干净、更有意义的代码。</p><h1 id="48d2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用正面防护装置</h1><p id="6b4e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe ms mt mu mv b">guard</code>关键字是Swift编程语言中最具定义性的语言之一。我们每天都在使用它，它有两个主要用途:</p><ol class=""><li id="f9da" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">展开一些计算所需的选项。</li><li id="e9c1" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">陈述我们功能的先决条件。</li></ol><p id="abd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我要分享的技巧对第二种用法更有意义。</p><p id="ae77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想想我们在算法中写的前提条件:<code class="fe ms mt mu mv b">!set.isEmpty</code>、<code class="fe ms mt mu mv b">!name.isEmpty</code>、<code class="fe ms mt mu mv b">num != nil</code>等等。你写了多少次下面的代码？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="351f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想了很多次。这段代码，连同上面所有的例子，至少有两个缺点:</p><ol class=""><li id="a549" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">这很容易出错——很容易忘记<code class="fe ms mt mu mv b">!</code>。</li><li id="4906" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">很难内化。当阅读条件时，我们必须颠倒我们阅读的单词的语义，以正确理解代码的意思。</li></ol><p id="b5f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我们可以通过在<code class="fe ms mt mu mv b">Collection</code>协议中添加一个小助手来轻松解决这个问题。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ec85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用这个简单的方法一次性解决了这两个缺点，并且使我们的代码变得简单明了。</p><p id="df38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当一些逻辑被否定表达时，我们就可以应用这个原则。这是给你的一个练习:检查你的代码，找到相似的例子。用积极的方式重写它们。</p><h1 id="da45" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">杠杆式推理</h1><p id="ba66" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Swift是一种智能语言。Swift编译器可以推断类型，这为我们节省了一些输入。我们不必写出所有的类型；编译器可以为我们做到这一点。</p><p id="8bd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt nm mv nn no aw np bi"><span id="4bf6" class="nq lw it mv b gy nr ns l nt nu">let num = 0 // this is an Int<br/>let pi = 3.14 // this is a Double<br/>let greetings = "Hello" // this is a String</span></pre><p id="918c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用自己的类型，尤其是枚举时，这个特性真的大放异彩。例如，让我们考虑一个返回<code class="fe ms mt mu mv b">Result&lt;Int, Myerror&gt;</code>的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="36b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个简单的代码中，我们打包了多个层次的推理:</p><ul class=""><li id="f36a" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nv nc nd ne bi translated">在第8行，编译器正在推断返回类型(<code class="fe ms mt mu mv b">Result.failure</code>)和<code class="fe ms mt mu mv b">Error</code> ( <code class="fe ms mt mu mv b">CustomModule.Error</code>)。</li><li id="a406" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nv nc nd ne bi translated">在第10行，编译器正在推断返回类型的<code class="fe ms mt mu mv b">success</code>值。</li><li id="7fc2" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nv nc nd ne bi translated">在第16行的开关中，我们正在推断两个<code class="fe ms mt mu mv b">case</code>的类型。</li></ul><p id="43b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译器足够聪明，即使在屏蔽系统类型时也能正确解析类型。第2行的<code class="fe ms mt mu mv b">Error</code>与<code class="fe ms mt mu mv b">Swift.Error</code>型同名。然而，由于特殊性规则，<code class="fe ms mt mu mv b">doubleEven</code>函数会自动推断出正确的错误类型。</p><p id="920c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些机制允许我们编写有意义和可读的代码，而不会不必要地冗长。</p><h1 id="3680" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用协议见证</h1><p id="3441" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://riccardocipolleschi.medium.com/stop-using-protocols-cd63744a3261?source=your_stories_page-------------------------------------" rel="noopener">协议见证人</a>是协议的一个有趣替代方案。他们可以用面向值的方法取代标准的面向协议的编程(POP)。</p><p id="c4d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们有几个优点:</p><ol class=""><li id="026e" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">它们减少了实现协议所需的结构数量。</li><li id="bd77" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">他们简化了泛型。</li><li id="98b4" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">它们简化了带有关联类型的协议(PAT)。</li></ol><p id="a5d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们需要为一个特定的、<code class="fe ms mt mu mv b">Codable</code>数据类型编写一个管理器，并假设我们希望将它存储在某个持久层中。典型的POP方法如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3fcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是你已经知道会发生什么了，对吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/7f0ff72ea28967ee1505397e3166731a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xeFtDKsha01a4-bq9QzzpA.png"/></div></div></figure><p id="2715" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们必须为<code class="fe ms mt mu mv b">Storage</code>协议创建一个特定的实现。或许，我们可以实现一个<code class="fe ms mt mu mv b">KeyValueStorage</code>来保存内存中的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9fa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个协议实现，我们可以修改管理器来使用它并解决我们的问题。</p><p id="dfcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您的经理找到您，要求将内存与另一个使用<code class="fe ms mt mu mv b">UserDefaults</code>的内存进行交换，会发生什么情况？</p><p id="741e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">突然间，你不仅要实现一个继承自<code class="fe ms mt mu mv b">Storage</code>协议的新结构。您还需要改变<code class="fe ms mt mu mv b">Manager</code>的内部结构来使用新的协议实现！这明显违反了<a class="ae ky" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank">开闭原则</a>:<code class="fe ms mt mu mv b">Manager</code>没有接近修改，那是因为协议。</p><p id="c903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用证人，我们可以克服所有这些问题。见证只是一个带有一些闭包的结构。您可以将闭包视为协议函数定义。当我们为这个结构创建一个值时，我们必须提供一个实现。这是我们实现接口的步骤。</p><p id="f8ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何使用它们来解决我们经理的问题。首先，下面我们来定义一个<code class="fe ms mt mu mv b">Storage</code>证人:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="36e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码在很少的几行中包含了很多含义。见证的典型结构如下:</p><ol class=""><li id="52fe" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">见证服务器提供的闭包定义了API。</li><li id="6a45" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">为见证提供不同实现的初始值设定项。</li><li id="b67b" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">一组调用闭包的函数。这一步是可选的，但是为被调用者提供更好的API是有用的。例如，我们可以使用这些函数为参数添加标签。</li></ol><p id="9682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们简单地通过用适当的闭包初始化<code class="fe ms mt mu mv b">Storage</code>结构来实现新的<code class="fe ms mt mu mv b">KeyValueStorage</code>。我们甚至可以准备一个<code class="fe ms mt mu mv b">UserDefaultStorage</code>，用不同的闭包创建另一个变量。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8bf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子显示了在不定义不同结构的情况下，我们可以多么容易地创建不同的存储和不同的管理器。</p><p id="83be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使内存存储发生变化，管理器定义也不会改变。它保留了开闭原则。唯一改变的是传递给管理器的存储类型。这种方法是<a class="ae ky" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>的基础，为此我们可以向管理器注入不同的依赖，而不必担心管理器的实现。</p><p id="8e74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法遵循干净代码的另一个重要原则:依赖倒置原则。尽管使用协议来抽象功能，第一个例子依赖于<code class="fe ms mt mu mv b">KeyValueStorage</code>实现，而不是依赖于协议。使用协议见证方法，<code class="fe ms mt mu mv b">Manager</code>只依赖于提供<code class="fe ms mt mu mv b">get</code>和<code class="fe ms mt mu mv b">set</code>原语的结构，但是它不关心这些原语是如何实现的。</p><h1 id="9391" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用工厂方法</h1><p id="f44b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">尽管协议见证很酷，让我们应用开闭原则、依赖倒置原则和依赖注入，但我们可以说代码并不真正干净。也许它比标准的面向协议的方法更难理解。</p><p id="fe1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，这个问题有一个简单的解决方法:我们可以重构代码，利用一些静态工厂方法。<a class="ae ky" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank">工厂方法</a>是我最喜欢的设计模式之一，它可以整理我们的代码。</p><p id="af8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要思想是使用<code class="fe ms mt mu mv b">extension</code>特性来创建我们的结构的一些默认实现。然后，我们可以在代码的不同部分重用它们。让我们看看如何利用前面的例子来做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5359" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这段代码中，您可以看到如何用很少的几行代码创建不同的<code class="fe ms mt mu mv b">Storage</code>见证实现。<code class="fe ms mt mu mv b">memory</code>字典是在<code class="fe ms mt mu mv b">static</code>工厂内捕获的。依赖注入也可以应用于<code class="fe ms mt mu mv b">UserDefaults</code>。在将<code class="fe ms mt mu mv b">userDefaults</code>参数传递给<code class="fe ms mt mu mv b">manager</code>的同时，我们可以将一个依赖注入到一个注入的依赖中！</p><p id="9bb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到它的用法，我们可以通过不同的<code class="fe ms mt mu mv b">Storage</code>实现来初始化不同的管理器。我们甚至可以利用类型推断来减少样板文件！代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="0b3e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用高阶函数和关键路径</h1><p id="abb8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">没有什么比循环更冗长、更难阅读或理解了。</p><p id="25ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时我们最终会写出这样的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="dade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快速忽略第一行，它只包含一些给出上下文的代码。让我们更关注后者，从第18行到第32行。代码循环遍历所有SDK，并尝试提取最高版本的移动平台模拟器。</p><p id="5807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能用不到十行的代码来描述这个用简单英语写了几行的想法吗？</p><p id="f13f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是啊！我们可以在函数式编程方法中更明确地利用函数和关键路径。</p><p id="08d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要给我们的结构添加一些特性。我们可以利用Swift extensions来实现这一目标。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c62e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以利用集合的<code class="fe ms mt mu mv b">filter</code>和<code class="fe ms mt mu mv b">max</code>函数来重写那个糟糕的<code class="fe ms mt mu mv b">for-loop</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8f34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">搞定了。四行超级简单的代码(出于可读性的考虑，只有四行)达到了同样的效果。此外，它们是描述性的。即使是软件开发知识浅薄的人也能理解发生了什么；它们是英语动词，到处都有一些符号！</p><h1 id="c7a3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="8c98" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">今天，我想分享我在Swift中编写代码时遵循的一些原则。他们帮助我和我的团队编写简洁而富有表现力的代码。</p><p id="b37c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自其他团队的人可以很快投入到我们的项目中，并在他们身上实现一个新的特性或修复一个bug。我们尽可能保持代码的可读性和整洁性。</p></div></div>    
</body>
</html>