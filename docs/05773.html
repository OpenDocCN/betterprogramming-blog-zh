<html>
<head>
<title>How to Add Relations to Your GraphQL Schema</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何向GraphQL模式添加关系</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-add-relations-to-your-graphql-schema-295dd45cc62d?source=collection_archive---------1-----------------------#2020-08-05">https://betterprogramming.pub/how-to-add-relations-to-your-graphql-schema-295dd45cc62d?source=collection_archive---------1-----------------------#2020-08-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b64b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">GraphQL和MongoDB中的关系入门</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a00f6aa3d549d4dac4824359899ca938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gOq_icVPqVvbh3HmE09Ncw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">罗马家庭纪念馆——由大英博物馆提供</p></figure><p id="4310" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们将添加对象类型之间的关系，并研究一些基本的模式定义语言语法。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="c252" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">出发点</h1><p id="67cf" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">我们构建在本系列的前一篇文章中建立的<a class="ae mv" href="https://medium.com/better-programming/creating-a-graphql-server-basic-setup-73710ddf657e" rel="noopener">基本GraphQL服务器之上。如果你只是想要这个</a><a class="ae mv" href="https://github.com/bjdixon/graphql-server/tree/setup" rel="noopener ugc nofollow" target="_blank">的代码，从这里下载</a>或者:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="ee48" class="nb lz iq mx b gy nc nd l ne nf">git clone --branch setup <a class="ae mv" href="https://github.com/bjdixon/graphql-server.git`" rel="noopener ugc nofollow" target="_blank">https://github.com/bjdixon/graphql-server.git</a></span></pre><p id="9ac2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果此时您只是克隆或下载，那么您需要创建一个MongoDB实例并替换<code class="fe ng nh ni mx b">./index.js</code>文件中的连接字符串。</p><p id="d247" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">确保安装了依赖项:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="a241" class="nb lz iq mx b gy nc nd l ne nf">npm install</span></pre><p id="47bf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后启动服务器:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="5d04" class="nb lz iq mx b gy nc nd l ne nf">npm start</span></pre><p id="d74d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们准备好潜水了！</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="cee8" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">我们正在建造的东西</h1><p id="2699" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">现在我们有两个可以交互的模型——我们可以创建并列出作者和书籍。这些模型有我们想要定义的自然关系，我们也应该能够查看单个作者和书籍，以及他们的相关对象。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="a019" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">扩展模式</h1><p id="c86a" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">到目前为止，在我们的<code class="fe ng nh ni mx b">./schema/index.js</code>文件中，我们已经使用模式定义语言(SDL)定义了两种对象类型，<code class="fe ng nh ni mx b">Author</code>和<code class="fe ng nh ni mx b">Book</code>。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="1371" class="nb lz iq mx b gy nc nd l ne nf">type Author {<br/>  id: ID!<br/>  name: String!<br/>}<br/>type Book {<br/>  id: ID!<br/>  name: String!<br/>  pages: Int<br/>}</span></pre><p id="f5d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个对象类型都有一个属性列表以及每个属性的关联类型。在我们的例子中，我们有一个<code class="fe ng nh ni mx b">Book</code>类型，它有三个属性:</p><ul class=""><li id="1e3b" class="nj nk iq kx b ky kz lb lc le nl li nm lm nn lq no np nq nr bi translated"><code class="fe ng nh ni mx b">id</code>这是一种特殊的ID类型。</li><li id="0541" class="nj nk iq kx b ky ns lb nt le nu li nv lm nw lq no np nq nr bi translated"><code class="fe ng nh ni mx b">name</code>这是一个字符串类型。</li><li id="03ad" class="nj nk iq kx b ky ns lb nt le nu li nv lm nw lq no np nq nr bi translated"><code class="fe ng nh ni mx b">pages</code>这是一个int类型。</li></ul><p id="ea42" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有支持类型的列表<a class="ae mv" href="https://www.apollographql.com/docs/apollo-server/schema/schema/#supported-types" rel="noopener ugc nofollow" target="_blank">可以在这里找到</a>。</p><p id="edd9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可能会注意到一些类型定义末尾的<code class="fe ng nh ni mx b">!</code>。这表明该属性是必需的。我们的<code class="fe ng nh ni mx b">Query</code>类型可以很好地说明这一点:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="f588" class="nb lz iq mx b gy nc nd l ne nf">type Query {<br/>  message: String!<br/>  authors: [Author!]!<br/>  books: [Book!]!<br/>}</span></pre><p id="1712" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ng nh ni mx b">message</code>属性需要一个字符串，<code class="fe ng nh ni mx b">authors</code>属性需要一个列表(列表用方括号表示)，列表中的值需要是<code class="fe ng nh ni mx b">Author</code>类型，尽管返回一个空列表也是有效的。现在，我们希望<code class="fe ng nh ni mx b">authors</code>属性要么为空，要么为列表，并确保如果它返回一个非空列表，那么它只包含<code class="fe ng nh ni mx b">Author</code>类型的数据。让我们也摆脱静态消息查询，我们不会再使用它:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="82bf" class="nb lz iq mx b gy nc nd l ne nf">type Query {<br/>  authors: [Author!]<br/>  books: [Book!]!<br/>}</span></pre><p id="a6fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您也可以删除消息解析器。只需删除下面一行:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="f233" class="nb lz iq mx b gy nc nd l ne nf">message: () =&gt; 'hello world',</span></pre><p id="f13e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了删除消息之外，我们的查询还有细微的不同。作者的文章不再以感叹号结尾。在上面的例子中，<code class="fe ng nh ni mx b">authors</code>属性可以返回null或者一个列表，但是如果它返回一个非空的列表，那么这个列表只能包含作者。属性必须返回一个列表(可以是空的),这个列表只能包含书籍。</p><p id="de03" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了这些知识，我们将在模式中创建几个关系。对于我们的<code class="fe ng nh ni mx b">Book</code>类型，我们将添加一个必需的author属性(我们假设只有一个人可以是一本书的作者)，并且该值必须是一个<code class="fe ng nh ni mx b">Author</code>类型。对于我们的<code class="fe ng nh ni mx b">Author</code>类型，我们将添加一个<code class="fe ng nh ni mx b">books</code>属性，该属性可以是null或列表，如果列表不为空，则值必须是<code class="fe ng nh ni mx b">Book</code>类型。在<code class="fe ng nh ni mx b">./schema/index.js</code>中编辑以下内容:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="a248" class="nb lz iq mx b gy nc nd l ne nf">type Author {<br/>  id: ID!<br/>  name: String!<br/>  books: [Book!]<br/>}<br/>type Book {<br/>  id: ID!<br/>  name: String!<br/>  pages: Int<br/>  author: Author!<br/>}</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="2b96" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">测试模式更新</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/ed84695999d7986f0461c6e6a2fed568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-R48JnTFn9YSM509bpSstQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">访问localhost:4000/graphql来测试更新后的模式</p></figure><p id="6c35" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们仍然可以列出作者并返回他们的名字，但是对于他们的书，我们只能得到null。如果我们试图列出书籍并返回这些书籍的作者，我们会得到一个错误——书籍现在需要有一个类型为<code class="fe ng nh ni mx b">Author</code>的作者，而我们的book实例还没有任何作者。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/4018d97316276df2bb2920d5491760a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_nzES0V6JBMPTQZALO7vJA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试新模式时出错</p></figure><p id="3c66" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们仍然需要更新创造我们的书和作者的基础模型和突变。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="9daa" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">扩展模型</h1><p id="9670" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">我们将首先通过添加books数组来扩展<code class="fe ng nh ni mx b">Author</code>模型。我们实际上只是要存储一个Mongo <code class="fe ng nh ni mx b">ObjectId</code>的列表(你可以在书籍的<code class="fe ng nh ni mx b">type</code>属性中看到)并使用ref属性让Mongo知道我们希望它与哪个模型相关。编辑<code class="fe ng nh ni mx b">./models/Author.js</code>:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="701a" class="nb lz iq mx b gy nc nd l ne nf">import mongoose from 'mongoose'</span><span id="d68a" class="nb lz iq mx b gy nz nd l ne nf">const Schema = mongoose.Schema</span><span id="44fb" class="nb lz iq mx b gy nz nd l ne nf">export const Author = mongoose.model('Author', {<br/>  name: String,<br/>  books: [{<br/>    type: Schema.Types.ObjectId,<br/>    ref: 'Book'<br/>  }]<br/>})</span></pre><p id="f2d1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类似地，我们需要更新<code class="fe ng nh ni mx b">Book</code>模型，但是我们添加了一个与单个作者的关系，而不是一组作者。编辑此文件<code class="fe ng nh ni mx b">./models/Book.js</code>:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="f969" class="nb lz iq mx b gy nc nd l ne nf">import mongoose from 'mongoose'</span><span id="16b8" class="nb lz iq mx b gy nz nd l ne nf">const Schema = mongoose.Schema</span><span id="8788" class="nb lz iq mx b gy nz nd l ne nf">export const Book = mongoose.model('Book', {<br/>  name: String,<br/>  pages: Number,<br/>  author: {<br/>    type: Schema.Types.ObjectId,<br/>    ref: 'Author'<br/>  }<br/>})</span></pre><p id="41fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们可以更改模式中的三行，并且能够创建我们的第一个关系。</p><p id="cb75" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，在我们的<code class="fe ng nh ni mx b">Mutation</code>类型中，我们在创建一本新书时添加一个作者。这将是一个字符串，因为Mongo存储了作者的ID，并将它作为一个字符串接受。在<code class="fe ng nh ni mx b">./schema/index.js</code>编辑<code class="fe ng nh ni mx b">createBook</code>中的<code class="fe ng nh ni mx b">Mutation</code>类型中添加新的<code class="fe ng nh ni mx b">Author</code>参数:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="be2e" class="nb lz iq mx b gy nc nd l ne nf">  type Mutation {<br/>    createAuthor(name: String!): Author!<br/>    createBook(name: String!, pages: Int, author: String!): Book!<br/>  }</span></pre><p id="5a9b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，在同一个文件中，我们将对<code class="fe ng nh ni mx b">createBook</code>解析器做一个小小的修改，将作者参数添加到函数中，并作为参数添加到<code class="fe ng nh ni mx b">Book</code>构造函数中:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="76c5" class="nb lz iq mx b gy nc nd l ne nf">const resolvers = {<br/>  Query: {<br/>    authors: () =&gt; Author.find(),<br/>    books: () =&gt; Book.find()<br/>  },<br/>  Mutation: {<br/>    createAuthor: async (_, { name }) =&gt; {<br/>      const author = new Author({ name });<br/>      await author.save();<br/>      return author;<br/>    },<br/>    createBook: async (_, { name, pages, author }) =&gt; {<br/>      const book = new Book({ name, pages, author });<br/>      await book.save();<br/>      return book;<br/>    }<br/>  }<br/>}</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="2ae0" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">测试更新的模型和变化</h1><p id="bcd2" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">删除MongoDB中任何旧的<code class="fe ng nh ni mx b">Book</code>和<code class="fe ng nh ni mx b">Author</code>实例——它们不再反映更新的模式。然后创建一个新的<code class="fe ng nh ni mx b">Author</code>。在<code class="fe ng nh ni mx b">Author</code>上运行一个查询来获得它的ID——我们将在创建<code class="fe ng nh ni mx b">Book</code>时需要它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/5380e7edf6dbd3d7e016d334882f4036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vuZTkjmyJSdsXXfGliv6tg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">记录作者的id</p></figure><p id="67de" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在创建一个新的<code class="fe ng nh ni mx b">Book</code>，使用新创建的作者ID作为作者参数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/ddb9e49a713e1fbe3e0ace9320d6fdb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NiV9AhEulrmY8vPi9k8QdA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用作者id创建一本书</p></figure><p id="39eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如你所见，我们没有任何错误地创作了这本新书。如果我们查看Mongo数据库，我们可以看到book实例有一个带有作者的<code class="fe ng nh ni mx b">ObjectId</code>的<code class="fe ng nh ni mx b">Author</code>属性。</p><p id="371d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而不幸的是，如果我们试图使用books查询来获取新书的作者详细信息，我们就会遇到麻烦。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/b1c395f00bad8fead22bcdb826820234.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5yNJhAxoi6GpB5pmGstyow.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">试图查看某本书的作者详细信息时出错</p></figure><p id="0300" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们希望<em class="od">看到</em>关系，而不仅仅是创造它们，所以我们接下来会解决这个问题。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="1b21" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">解析器中的连接关系</h1><p id="d0b8" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">这一部分相当复杂，但也相当令人兴奋，我们将最终使用递归。</p><p id="bf15" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我们所知，在MongoDB中，我们将每本书的作者属性存储为一个<code class="fe ng nh ni mx b">ObjectId</code>字符串，每个作者的书籍数组是一个<code class="fe ng nh ni mx b">Book</code> <code class="fe ng nh ni mx b">ObjectId</code>列表。让我们将这些<code class="fe ng nh ni mx b">ObjectId</code>转化为更有用的东西。</p><p id="3cd4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将创建两个助手函数，用于将一本书的作者<code class="fe ng nh ni mx b">ObjectId</code>扩展成一个<code class="fe ng nh ni mx b">Author</code>对象，将一个<code class="fe ng nh ni mx b">Author</code>的书的数组<code class="fe ng nh ni mx b">ObjectId</code>扩展成一个<code class="fe ng nh ni mx b">Book</code>对象的数组。我在<code class="fe ng nh ni mx b">./schema/index.js</code>文件中定义了这些函数，就在将要使用它们的解析器之前:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="740f" class="nb lz iq mx b gy nc nd l ne nf">const books = async bookIds =&gt; {<br/>  try {<br/>    const books = await Book.find({_id: { $in: bookIds }})<br/>    return books.map(book =&gt; ({<br/>      ...book._doc,<br/>      author: author.bind(this, book._doc.author)<br/>    }))<br/>  } catch {<br/>    throw err<br/>  }<br/>}</span><span id="8fca" class="nb lz iq mx b gy nz nd l ne nf">const author = async authorId =&gt; {<br/>  try {<br/>    const author = await Author.findById(authorId)<br/>    return {<br/>      ...author._doc,<br/>      books: books.bind(this, author._doc.books)<br/>    }<br/>  } catch (err) {<br/>    throw err<br/>  }<br/>}</span></pre><p id="dc78" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，books函数接受一个由<code class="fe ng nh ni mx b">Book</code> <code class="fe ng nh ni mx b">ObjectId</code>组成的数组作为参数，然后查找所有带有这些id的<code class="fe ng nh ni mx b">Book</code>文档。然后返回映射到它们的<code class="fe ng nh ni mx b">Book</code> s，每个<code class="fe ng nh ni mx b">Book</code>返回其所有属性——除了<code class="fe ng nh ni mx b">Author</code>属性。我们通过调用已经绑定到<code class="fe ng nh ni mx b">Book</code>作者的<code class="fe ng nh ni mx b">ObjectId</code>的<code class="fe ng nh ni mx b">Author</code>函数，在请求时覆盖<code class="fe ng nh ni mx b">Author</code>属性。</p><p id="b352" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接受一个<code class="fe ng nh ni mx b">Author</code> <code class="fe ng nh ni mx b">ObjectId</code>的author函数找到与那个<code class="fe ng nh ni mx b">ObjectId</code>相关联的<code class="fe ng nh ni mx b">Author</code>文档，并返回它的所有属性，除了books数组。当通过调用<code class="fe ng nh ni mx b">Books</code>函数请求该属性时，books数组被覆盖，该函数返回在<code class="fe ng nh ni mx b">Author</code>的books数组中有关联的<code class="fe ng nh ni mx b">ObjectId</code>的每本书的所有属性。</p><p id="b419" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们绑定这些函数供以后使用。如果我们立即调用它们，这将导致一个无限循环，其中<code class="fe ng nh ni mx b">Books</code>函数调用<code class="fe ng nh ni mx b">Author</code>函数，然后后者调用<code class="fe ng nh ni mx b">Books</code>函数，依此类推。</p><p id="c5da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在可以使用这些方便的函数来重写我们的<code class="fe ng nh ni mx b">Query</code>解析器，以膨胀一个<code class="fe ng nh ni mx b">Book</code>的相关<code class="fe ng nh ni mx b">Author</code>和一个<code class="fe ng nh ni mx b">Author</code>的相关<code class="fe ng nh ni mx b">Book</code>:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="6ade" class="nb lz iq mx b gy nc nd l ne nf">const resolvers = {<br/>  Query: {<br/>    authors: async () =&gt; {<br/>      try {<br/>        const authors = await Author.find()<br/>        return authors.map(author =&gt; ({<br/>          ...author._doc,<br/>          books: books.bind(this, author._doc.books)<br/>        }))<br/>      } catch (err) {<br/>        throw err<br/>      }<br/>    },<br/>    books: async () =&gt; {<br/>      try {<br/>        const books = await Book.find()<br/>        return books.map(book =&gt; ({<br/>          ...book._doc,<br/>          author: author.bind(this, book._doc.author)<br/>        }))<br/>      } catch (err) {<br/>        throw err<br/>      }<br/>    }<br/>  },</span></pre><p id="a293" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些查询彼此之间以及与助手函数之间有很多相似之处。与helper函数的主要区别在于，我们列出了所有书籍和所有作者，并使用helper函数按需扩展它们的相关属性。</p><p id="9b81" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将通过重写<code class="fe ng nh ni mx b">Mutation</code>解析器来完成解析器的更改:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="a6ff" class="nb lz iq mx b gy nc nd l ne nf">Const resolvers = {<br/>  Query: {<br/>    ...<br/>   },<br/>   Mutation: {<br/>    createAuthor: async (_, { name }) =&gt; {<br/>      try {<br/>        const author = new Author({ name })<br/>        await author.save()<br/>        return author;<br/>      } catch (err) {<br/>        throw err<br/>      }<br/>    },<br/>    createBook: async (_, { name, pages, author: authorId }) =&gt; {<br/>      const book = new Book({ name, pages, author: authorId })<br/>      try {<br/>        const savedBook = await book.save()<br/>        const authorRecord = await Author.findById(authorId)<br/>        authorRecord.books.push(book)<br/>        await authorRecord.save()<br/>        return {<br/>          ...savedBook._doc,<br/>          author: author.bind(this, authorId)<br/>        }<br/>      } catch (err) {<br/>        throw err<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="0722" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了添加try/catch块之外，<code class="fe ng nh ni mx b">createAuthor</code>突变保持不变。</p><p id="8251" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe ng nh ni mx b">createBook</code> <strong class="kx ir"> </strong>变异中，我们需要将我们作为参数提供的作者参数从<code class="fe ng nh ni mx b">author</code>重命名为<code class="fe ng nh ni mx b">authorId</code>，因为我们将使用<code class="fe ng nh ni mx b">author</code>函数，并且名称冲突。我们在这里所做的最重要的改变是在新的<code class="fe ng nh ni mx b">Book</code>被保存后，我们通过找到相关的<code class="fe ng nh ni mx b">Author</code>的文档来更新它，将新的<code class="fe ng nh ni mx b">Book</code> s <code class="fe ng nh ni mx b">ObjectId</code>推入<code class="fe ng nh ni mx b">Author</code>的books数组，然后保存记录。为了更好的测量，当新的<code class="fe ng nh ni mx b">Book</code>返回时，我们使用我们的帮助函数按需膨胀<code class="fe ng nh ni mx b">Author</code>属性。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="cb9f" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">测试最终版本</h1><p id="02fb" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">自从上次测试以来，我们已经做了相当多的改变，所以请删除您的MongoDB中任何以前创建的<code class="fe ng nh ni mx b">Author</code>和<code class="fe ng nh ni mx b">Book</code>，然后使用<code class="fe ng nh ni mx b">createAuthor</code>突变创建一个新的<code class="fe ng nh ni mx b">Author</code>。别忘了保存作者ID。我们在创建<code class="fe ng nh ni mx b">Book</code> s时会用到它。</p><p id="4d41" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦完成，我们就可以通过使用突变<code class="fe ng nh ni mx b">createBook</code>并请求返回<code class="fe ng nh ni mx b">Author</code>属性来看到变化:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/3a29f0f9033339be4accb9b7579bdc77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Sgqh7meb7e2lgXX-lX6Ag.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建一本书并查看作者的详细信息</p></figure><p id="8c60" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们使用同一个作者创建另一个<code class="fe ng nh ni mx b">Book</code>，但是这一次在返回新<code class="fe ng nh ni mx b">Book</code>的作者时，也返回该作者所有书籍的名称:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/271710112a451641e61f2bebf19b1596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qi3k2pgOP5VI9gr4R1htFQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建另一本书并获得同一作者的书</p></figure><p id="4d4e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了证明这一切都是可行的，让我们使用<code class="fe ng nh ni mx b">Author</code>的查询来列出所有的<code class="fe ng nh ni mx b">Author</code>和他们的书名:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/376c40ef7b1da0c7e53d0cdd2fa26167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-JNe_Q2kFbVAUZvKQABYZw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">列出所有作者及其书籍</p></figure><p id="854a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，为了说明这里可能的递归，您可以这样做:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/cb7bbec3fb2c73ddbdf65f9617d9580e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IG5sCStc0jHkDWAYD2ztHA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">这是缓慢的，不要这样做</p></figure><p id="adf1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，我不推荐这样做，因为除了毫无意义之外，它还相当慢。</p><p id="28c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">作为证明扩展相关属性的魔术是在代码中而不是在后台完成的最后一个测试，您可以在MongoDB中查看。您应该有一个带有包含<code class="fe ng nh ni mx b">ObjectId</code> s的<code class="fe ng nh ni mx b">Books</code>数组的<code class="fe ng nh ni mx b">Author</code>文档和一些带有同样是<code class="fe ng nh ni mx b">ObjectId</code> s的<code class="fe ng nh ni mx b">Author</code>属性的<code class="fe ng nh ni mx b">Book</code>文档</p><p id="2a77" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这篇文章<a class="ae mv" href="https://github.com/bjdixon/graphql-server/tree/relations" rel="noopener ugc nofollow" target="_blank">的完整工作代码可以在这里找到</a>。</p></div></div>    
</body>
</html>