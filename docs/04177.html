<html>
<head>
<title>What Are Generators, Yields, and Streams in Python?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的生成器、产量、流是什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-are-generators-yields-and-streams-in-python-a94072b3eb93?source=collection_archive---------3-----------------------#2020-03-28">https://betterprogramming.pub/what-are-generators-yields-and-streams-in-python-a94072b3eb93?source=collection_archive---------3-----------------------#2020-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2dad" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">中级Python</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6bf26928d13258eee4b2d7a8a95611ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F0IazIcNkW3zEIR0vLgXaQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Markus Spiske </a>在<a class="ae ky" href="https://unsplash.com/s/photos/items?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8e5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">generator</code>和<code class="fe lv lw lx ly b">yield</code>在Python中使用频率很高。在本文中，让我们讨论一下<code class="fe lv lw lx ly b">generator</code>的一些基础知识，使用<code class="fe lv lw lx ly b">generator</code>的好处，以及我们如何使用<code class="fe lv lw lx ly b">yield</code>来创建一个<code class="fe lv lw lx ly b">generator</code>。</p><p id="632a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，我们将学习计算机科学中的另外两个概念:惰性求值和流。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="26bb" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">可重复的</h1><p id="0fc1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先，在理解如何使用<code class="fe lv lw lx ly b">generator </code>之前，我们需要知道什么是<em class="nd">iterables</em>——因为<code class="fe lv lw lx ly b">generator</code>本质上也是一个迭代器。</p><p id="1120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，iterable是一个可以迭代的对象，比如在一个<code class="fe lv lw lx ly b">for</code>循环中。</p><p id="0ca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数集合数据结构都是可迭代的，比如列表、元组和集合。例如，下面我们将创建一个列表并逐个迭代它:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="72a0" class="ni mh it ly b gy nj nk l nl nm">lst = [1, 2, 3]<br/>for i in lst:<br/>    print(i)</span><span id="0b61" class="ni mh it ly b gy nn nk l nl nm"># 1<br/># 2<br/># 3</span><span id="eebe" class="ni mh it ly b gy nn nk l nl nm">lst = [x+x for x in range(3)]<br/>for x in lst:<br/>    print(x)<br/># 0<br/># 2<br/># 4</span></pre><p id="99b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以迭代字符串中的字符:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="c2b7" class="ni mh it ly b gy nj nk l nl nm">string = "cat"<br/>for c in string:<br/>    print(c)</span><span id="a50c" class="ni mh it ly b gy nn nk l nl nm"># c<br/># a<br/># t</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cd5c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">可迭代的极限</h1><p id="4bbd" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">iterables的限制是，在开始迭代之前，我们需要将所有的值存储在内存中。在某些情况下，这将耗费太多的内存。一个典型的场景是从文件中读取行:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="8069" class="ni mh it ly b gy nj nk l nl nm">def file_reader(file_path):<br/>    fp = open(file_path)<br/>    return fp.read().split("\n")</span></pre><p id="2e4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想想如果我们读取一个大文件，比如一个大小为6 GB的文件，会发生什么？</p><p id="bc8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当从文件中加载内容时，我们需要将所有的行保存在内存中。</p><p id="41ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，在大多数情况下，我们只想逐行迭代来完成一些数据处理任务。我们可能会提前打破循环——没有必要将所有行都加载到内存中。</p><p id="e0b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能有一个按需读取数据的策略吗？Python引入了<code class="fe lv lw lx ly b">generator</code>来解决这个问题。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ddde" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">发电机</h1><p id="7074" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">generator</code>也是一个迭代器，但是它的关键特性是<a class="ae ky" href="https://en.wikipedia.org/wiki/Lazy_evaluation" rel="noopener ugc nofollow" target="_blank"><em class="nd"/></a><em class="nd">。</em>懒求值是计算机科学中的一个经典概念，已经被很多编程语言采用，比如Haskell。懒惰评估的核心思想是<em class="nd">按需调用。</em>懒惰求值会导致内存占用的减少。</p><p id="2710" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器是一种按需迭代风格的迭代器。我们不会立刻计算和存储这些值，而是在迭代时动态生成它们。</p><p id="7bd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有两种创建<code class="fe lv lw lx ly b">generator</code>的方法:通过生成器表达式或生成器函数。</p><p id="c5f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器表达式类似于列表理解——除了我们使用<code class="fe lv lw lx ly b">()</code>。由于<code class="fe lv lw lx ly b">generator</code>是一个迭代器，我们使用<code class="fe lv lw lx ly b">next</code>函数来获取下一项:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="c5a3" class="ni mh it ly b gy nj nk l nl nm">g1 = (x*x for x in range(10))<br/>print(type(g1))<br/>print(next(g1))<br/>print(next(g1))</span><span id="3618" class="ni mh it ly b gy nn nk l nl nm"># &lt;type 'generator'&gt;<br/># 0<br/># 1</span></pre><p id="9397" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的区别在于，我们在创建<code class="fe lv lw lx ly b">generator</code>时并不计算所有的值。<code class="fe lv lw lx ly b">x*x</code>是在我们迭代<code class="fe lv lw lx ly b">generator</code>时计算的。</p><p id="b99b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解区别，让我们运行下面的代码片段:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="e1eb" class="ni mh it ly b gy nj nk l nl nm">&gt;&gt;&gt; import timeit<br/>&gt;&gt;&gt; timeit.timeit('lst = [time.sleep(1) for x in range(5)]', number=2)<br/>10.032547950744629</span><span id="cd11" class="ni mh it ly b gy nn nk l nl nm">&gt;&gt;&gt; timeit.timeit('lst = (time.sleep(1) for x in range(5))', number=2)<br/>1.0013580322265625e-05</span></pre><p id="4dad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从结果可以看出，当我们创建一个iterable时，大约需要10秒钟(因为我们执行了10次<code class="fe lv lw lx ly b">time.sleep(1)</code>)。</p><p id="e1f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在我们创建<code class="fe lv lw lx ly b">generator</code>的时候<code class="fe lv lw lx ly b">time.sleep(1)</code>实际上并没有运行。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a082" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">产量</h1><p id="67ee" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">创建<code class="fe lv lw lx ly b">generator</code>的另一种方法是使用生成器函数。我们使用关键字<code class="fe lv lw lx ly b">yield</code>在函数中返回一个<code class="fe lv lw lx ly b">generator</code>。</p><p id="33a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看<code class="fe lv lw lx ly b">fib</code>的这个函数，它返回一个带有<em class="nd"> n </em>个斐波那契数的<code class="fe lv lw lx ly b">generator</code>:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="81b3" class="ni mh it ly b gy nj nk l nl nm">def fib(cnt):<br/>    n, a, b = 0, 0, 1<br/>    while n &lt; cnt:<br/>        yield a<br/>        a, b = b, a + b<br/>        n = n + 1</span><span id="ae7e" class="ni mh it ly b gy nn nk l nl nm">g = fib(10)<br/>for i in range(10):<br/>    print g.next(),</span><span id="2bad" class="ni mh it ly b gy nn nk l nl nm"># 0 1 1 2 3 5 8 13 21 34</span></pre><p id="80c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用<code class="fe lv lw lx ly b">yield</code>重写上面的文件读取程序:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="051d" class="ni mh it ly b gy nj nk l nl nm">def file_reader(file_path):<br/>    for row in open(file_path, "r"):<br/>        yield row</span><span id="cb59" class="ni mh it ly b gy nn nk l nl nm">for row in file_reader('./demo.txt'):<br/>    print(row),</span></pre><p id="0724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这种方式，我们不会将所有内容加载到内存中，而是通过读取行来加载。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cc83" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">溪流</h1><p id="6b78" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有了生成器，我们可以构建一个包含无限项的数据结构。这种数据元素序列在计算机科学中被称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Stream_(computing)" rel="noopener ugc nofollow" target="_blank">T21流 </a>。这很奇妙，因为我们可以用数学来表达无限的概念。</p><p id="174c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想要一个包含所有斐波那契数列的序列。我们如何实现这一目标？</p><p id="5287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需要从上面的函数中删除count参数。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="c920" class="ni mh it ly b gy nj nk l nl nm">def all_fib():<br/>    a, b = 0, 1<br/>    while True:<br/>        yield a<br/>        a, b = b, a + b</span><span id="b7ab" class="ni mh it ly b gy nn nk l nl nm">all_fib_numbers = all_fib()</span></pre><p id="2eab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是啊！我们得到了一个可以代表所有斐波那契数列的变量。让我们编写一个通用函数，从任何流中获取n个条目。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="296e" class="ni mh it ly b gy nj nk l nl nm">def take(n, seq):<br/>    result = []<br/>    try:<br/>        for i in range(n):<br/>            result.append(next(seq))<br/>    except StopIteration:<br/>        pass<br/>    return result</span></pre><p id="5a7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此<code class="fe lv lw lx ly b">take(10, all_fib_numbers)</code>将返回前10个斐波那契数作为结果。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0226" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="8c10" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">generator</code>在Python中是一个延迟计算、节省时间和空间的强大工具。</p><p id="4c1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">懒求值的核心思想是计算值，直到你真正需要它。这也有助于我们表达无限序列的概念。</p></div></div>    
</body>
</html>