<html>
<head>
<title>Performance Analysis of JavaScript Functions With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中JavaScript函数的性能分析</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/performance-analysis-of-javascript-functions-with-python-ccef6b4c15b0?source=collection_archive---------5-----------------------#2021-11-04">https://betterprogramming.pub/performance-analysis-of-javascript-functions-with-python-ccef6b4c15b0?source=collection_archive---------5-----------------------#2021-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="abd2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用WebSockets记录静态网站的功能持续时间</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bc4713dca2684305e5173b075444da34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AZTyXfHr1s_y77_B"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@slavudin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Slejven Djurakovic </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="1a4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，我们对脚本中单个函数的执行时间感兴趣。有很多方法可以做到这一点，但是使用内置的performance JavaScript <code class="fe lv lw lx ly b">performance</code>库仍然是最简单的解释。</p><p id="517a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管可以手动计时函数，并从开发人员控制台获取结果，但使用任何数据分析工具的组合在Python中处理数据通常更简洁、更高效。在本教程中，我们将描述如何做到这一点。</p><h1 id="9739" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">设置Python代码</h1><p id="c9b0" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">为了在Python和浏览器之间进行通信，我们依赖于一种叫做<code class="fe lv lw lx ly b">WebSockets</code>的东西。本质上，这些是客户端(例如，浏览器)和后台服务(例如，服务器或Python脚本)之间的持久双向通信信道。</p><p id="de77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们使用了<code class="fe lv lw lx ly b">asyncio</code>和<code class="fe lv lw lx ly b">websockets</code> Python库。因为我可能想要保存输出，所以我也以“追加”模式打开一个文件，如下所示:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="710b" class="na ma it ly b gy nb nc l nd ne">import asyncio<br/>import websockets<br/>import datetime</span><span id="c782" class="na ma it ly b gy nf nc l nd ne">f = <strong class="ly iu">open</strong>('debug.txt','a')</span></pre><p id="46ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们想设置一个函数，一旦数据流连接上就运行。这包含一个无限循环，不断检查是否收到新消息。如果是，则将其打印到屏幕上或写入文件。代码如下:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="2a77" class="na ma it ly b gy nb nc l nd ne">async def <strong class="ly iu">start</strong>(websocket, path):</span><span id="e9ee" class="na ma it ly b gy nf nc l nd ne">    print("connected")<br/>    while True:</span><span id="15c0" class="na ma it ly b gy nf nc l nd ne">       data = <strong class="ly iu">await</strong> websocket.recv()</span><span id="a369" class="na ma it ly b gy nf nc l nd ne">       print(f"&lt; {data}",datetime.datetime.now().__str__())<br/>       f.write('%s: %s\n'%(datetime.datetime.now().__str__(),data))</span></pre><p id="9188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们希望定义主服务器进程并异步执行它，如下所示:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="4f17" class="na ma it ly b gy nb nc l nd ne">async def <strong class="ly iu">main</strong>():<br/>    server = <strong class="ly iu">await</strong> websockets.serve(start, 'localhost', 5001)<br/>    await server.wait_closed()</span><span id="8ca8" class="na ma it ly b gy nf nc l nd ne"><strong class="ly iu">asyncio.run</strong>(<strong class="ly iu">main</strong>())</span></pre><h1 id="aaa7" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">创建可导入的JS概要分析模块</h1><p id="0191" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">现在我们有了后端监听脚本，我们需要创建我们的分析工具和两者之间的通信通道(WebSocket)。</p><h2 id="b7b3" class="na ma it bd mb ng nh dn mf ni nj dp mj li nk nl ml lm nm nn mn lq no np mp nq bi translated">创建WebSocket</h2><p id="4c20" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">创建初始WebSocket相对容易，但是，在发送任何信息之前，我们需要确保连接到后台服务。</p><p id="89a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过承诺来实现，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="7ed0" class="na ma it bd mb ng nh dn mf ni nj dp mj li nk nl ml lm nm nn mn lq no np mp nq bi translated">包装现有代码</h2><p id="576a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">现在剩下的就是计时并发回结果。计时本身是通过获取两个<code class="fe lv lw lx ly b">performance.now()</code>块之间的差值，将任何执行代码封装在其中来完成的。</p><p id="844b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是通过创建一个包装函数来完成的。执行之后，它使用我们新创建的WebSocket将输出发送给Python，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="cc9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们也可以通过添加附加的print语句在开发人员控制台中查看结果，如下所示:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="d8f9" class="na ma it ly b gy nb nc l nd ne">console.warn('DEBUG profile',`${fn.name}: ${end-start}`)</span></pre><h2 id="f3cc" class="na ma it bd mb ng nh dn mf ni nj dp mj li nk nl ml lm nm nn mn lq no np mp nq bi translated">异步函数呢？</h2><p id="5799" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如果我们有一个异步函数，并且我们想知道返回一个结果需要多长时间呢？</p><p id="ba6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，有两种方法可以解决这个问题:</p><ul class=""><li id="e28c" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">最简单的是用我们现有的函数包装当前的执行，如下所示:</li></ul><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="4c83" class="na ma it ly b gy nb nc l nd ne">timer_as( function <strong class="ly iu">customWrapper</strong> () {</span><span id="9835" class="na ma it ly b gy nf nc l nd ne">asyncfn(arguments).then(d=&gt; // do something //})</span><span id="07e4" class="na ma it ly b gy nf nc l nd ne">});</span></pre><p id="919a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oc">注意，虽然可以使用简写定义</em> <code class="fe lv lw lx ly b"><em class="oc">()=&gt;{fn}</em></code> <em class="oc">，但是它不包含名称属性，因此在我们的调试日志中不会被命名。</em></p><ul class=""><li id="3472" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">或者更好的是，我们可以调整计时器包装器来执行并等待代码结果，如下所示:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="b562" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">最后一步</h1><p id="dd08" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">最后，我们需要的只是一些代码来导入它，以及一个Python脚本来查看结果。下面是代码:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="0540" class="na ma it ly b gy nb nc l nd ne"><strong class="ly iu">import</strong> {timer,timer_as,connect} <strong class="ly iu">from</strong> './debug_ws.js'</span></pre><h2 id="c951" class="na ma it bd mb ng nh dn mf ni nj dp mj li nk nl ml lm nm nn mn lq no np mp nq bi translated">示例输出:</h2><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="542c" class="na ma it ly b gy nb nc l nd ne">2021–11–02 14:37:15.275944: <strong class="ly iu">get_data</strong>: 345.8999999985099<br/>2021–11–02 14:37:45.801908: <strong class="ly iu">check_value</strong>: 39.79999999701977</span></pre><h1 id="dd4f" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">其他JS分析技术</h1><p id="ca1c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">还有一系列其他的方法来分析代码。以下是一些建议:</p><ul class=""><li id="520c" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">Chrome开发工具中的灯塔/性能分析器/网络</li><li id="6a4d" class="nt nu it lb b lc od lf oe li of lm og lq oh lu ny nz oa ob bi translated">性能库(更详细)</li><li id="fb83" class="nt nu it lb b lc od lf oe li of lm og lq oh lu ny nz oa ob bi translated">对于动态站点，服务器日志可以指示加载时间</li><li id="ea99" class="nt nu it lb b lc od lf oe li of lm og lq oh lu ny nz oa ob bi translated">GNU性能</li></ul><p id="2e98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已。快乐剖析！</p></div></div>    
</body>
</html>