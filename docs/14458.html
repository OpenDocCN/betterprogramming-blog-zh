<html>
<head>
<title>How To Structure API Calls for Automation Tests in Playwright and JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在剧作家和JavaScript中构造自动化测试的API调用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-structure-api-calls-for-automation-tests-in-playwright-javascript-d3bf9cb670e1?source=collection_archive---------3-----------------------#2022-12-19">https://betterprogramming.pub/how-to-structure-api-calls-for-automation-tests-in-playwright-javascript-d3bf9cb670e1?source=collection_archive---------3-----------------------#2022-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aefb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建可读和灵活的API</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a769dcaa9d2dd9af29194f9e98bc2f0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*66iJ3ZAKW-Q5ZJpQ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">托拜厄斯·凯勒在Unsplash<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><p id="842f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为复杂系统创建e2e自动化测试有许多困难。其中之一就是处在一个“完美”的环境中。这个环境必须完全在您的控制之下，并且包括开发或生产环境的许多(如果不是全部)特征。实际情况往往并非如此。这种环境需要定期监督、数据重置和对每个测试要求的动态配置。</p><p id="686e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使用REST架构和API请求的在线应用程序的情况下，我们可以避开这个问题，并在每个测试或测试套件之前在必要的条件下设置系统。</p><p id="bb7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个例子，我将使用<a class="ae kv" href="https://playwright.dev/" rel="noopener ugc nofollow" target="_blank">剧作家</a>和它提供的用于发送API请求的请求模块。</p><p id="a892" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们正在测试的应用程序是一个简单的产品商店。JWT(JSON Web Token)技术用于授权。因此，登录后的每个后续调用都必须包含给定的令牌。</p><p id="c466" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">特定产品必须有库存，某些测试才能进行。因此，用户在收到令牌并使用它来增加某个产品的库存之前，必须首先进行身份验证。</p><h1 id="272d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">“快速和肮脏”的方法</h1><p id="9f1a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在指定文件或测试套件中的所有测试之前运行的<code class="fe mp mq mr ms b">beforeAll</code>部分中发送调用，是显而易见的做法。下面是如何做到这一点:</p><pre class="kg kh ki kj gt mt ms mu bn mv mw bi"><span id="9dd8" class="mx lt iq ms b be my mz l na nb">test.beforeAll(async (request) =&gt; {<br/> let response = await request.post(`https://someapp.com/api/login`, {<br/>  headers: this.standardHeaders,<br/>  data: {<br/>   username: "USERNAME",<br/>   password: "PASSWORD",<br/>  },<br/> })<br/><br/> let { accessToken, refreshToken } = JSON.parse(await response.text())<br/><br/> let setupCall = await request.post(`https://someapp.com/product/00001`, {<br/>  headers: {<br/>   authorization: `Bearer ${accessToken}`,<br/>  },<br/>  data: {<br/>   stock: 10,<br/>  },<br/> })<br/><br/> if (setupCall.status() == 200) {<br/>  console.log("Product is now setup correctly")<br/> }<br/>})<br/><br/>test("Test that requires product with id 00001 in stock", async (request) =&gt; {<br/> // TEST ITSELF RUNS HERE<br/>})</span></pre><p id="95e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种策略有几个缺点。最明显的一个是代码可读性，因为测试中充满了与其主要操作无关的不必要的代码。第二个是代码冗余，因为产品设置功能将要求每次测试都重复代码。对于十次测试，用户必须登录十次，浪费时间和资源并导致性能问题。</p><h1 id="7af2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">经典OOP方法和异步问题</h1><p id="9c84" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">像许多其他架构问题一样，这个问题可以通过利用OOP概念来解决。通过开发一个类来为测试构建数据，提供了一种访问API的方式，这种方式是标准化的、可重复的和可伸缩的。</p><p id="407f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个类看起来会像这样:</p><pre class="kg kh ki kj gt mt ms mu bn mv mw bi"><span id="669c" class="mx lt iq ms b be my mz l na nb">class SetupCalls {<br/> constructor(request) {<br/>  this.baseUrl = "https://someapp.com"<br/>  this.accessToken = null<br/>  this.refreshToken = null<br/> }<br/><br/> async getToken(username, password) {<br/>  this.request = await request.newContext()<br/>  let response = await this.request.post(`${this.baseUrl}/api/login`, {<br/>   headers: this.standardHeaders,<br/>   data: {<br/>    username: username,<br/>    password: password,<br/>   },<br/>  })<br/>  let { accessToken, refreshToken } = JSON.parse(await response.text())<br/>  this.accessToken = accessToken<br/>  this.refreshToken = refreshToken<br/> }<br/><br/> async setStock(productId) {<br/>  let setupCall = await this.request.post(`${this.baseUrl}/product/${productId}`, {<br/>   headers: {<br/>    authorization: `Bearer ${this.accessToken}`,<br/>   },<br/>   data: {<br/>    stock: 10,<br/>   },<br/>  })<br/><br/>  if (setupCall.status() == 200) {<br/>   console.log("Product is now setup correctly")<br/>  }<br/> }<br/>}I</span></pre><p id="a2e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在这些函数已经被有效地封装了，理解每个函数的功能是非常简单的。可以使用同一个令牌进行多次调用，因为它是在类本身中共享的，这样可以节省重复登录的时间。让我们看看测试当前的样子:</p><pre class="kg kh ki kj gt mt ms mu bn mv mw bi"><span id="ef11" class="mx lt iq ms b be my mz l na nb">test.beforeAll(async () =&gt; {<br/>   let setupCalls = new SetupCalls()<br/>   await setupCalls.getToken('John', 'john123')<br/>   await setupCalls.setStock("00001")<br/>   await setupCalls.setStock("00002")<br/>   await setupCalls.setStock("00003")<br/>})<br/><br/>test("Test that requires product with id 00001 in stock", async (request) =&gt; {<br/> // TEST ITSELF BEGINS<br/>})</span></pre><p id="41ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管实施情况看起来很好，但仍存在一些问题。在使用安装类之前，用户必须了解它的具体工作方式。如果在调用所有其他方法之前没有调用<code class="fe mp mq mr ms b">getToken</code>方法，测试将会失败，因为令牌将不会被填充。</p><p id="5377" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对令牌<code class="fe mp mq mr ms b">getToken</code>的调用最好在构造函数中进行，然而，构造函数不能是异步函数。因此，使用<code class="fe mp mq mr ms b">Promises</code>似乎是答案。</p><pre class="kg kh ki kj gt mt ms mu bn mv mw bi"><span id="bc21" class="mx lt iq ms b be my mz l na nb">constructor() {<br/>  this.baseUrl = "https://someapp.com"<br/>  let {accessToken, refreshToken} = Promise.resolve(getToken()).then(res =&gt; {<br/>       // do something with the token<br/>    });<br/> }j</span></pre><p id="6a35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这改变了构造函数的正常行为，需要仔细保存这个上下文。这种方法破坏了使用异步等待的目标，即保持代码可读和简单。</p><h1 id="e2b9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">解决方案—具有工厂功能的面向对象程序设计</h1><p id="9188" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">代替传统的构造函数，我们可以用<a class="ae kv" href="https://dev.to/somedood/the-proper-way-to-write-async-constructors-in-javascript-1o8c" rel="noopener ugc nofollow" target="_blank">标准静态函数/方法</a>初始化一个对象，并在其中使用异步方法，而不会失去后者提供给我们的任何优势。</p><p id="d245" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">静态方法不是在类的实例上调用，而是在类本身上调用。将构造函数设为私有可以确保用户使用init而不是默认构造函数初始化对象。类的init方法只给了该类必要的信息，如访问令牌，该方法创建了一个新的类实例。</p><p id="7bd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看代码:</p><pre class="kg kh ki kj gt mt ms mu bn mv mw bi"><span id="432a" class="mx lt iq ms b be my mz l na nb">class SetupCalls {<br/> /**<br/>  * @private<br/>  */<br/> constructor(config) {<br/>  this.baseUrl = "https://someapp.com"<br/>  this.accessToken = config.accessToken<br/>  this.refreshToken = config.refreshToken<br/> }<br/><br/> static async init(username, password) {<br/>  let config = await this.getToken(username, password)<br/>  return new SetupCalls(config)<br/> }<br/><br/> async getToken(username, password) {<br/>  this.request = await request.newContext()<br/>  let response = await this.request.post(`https://someapp.com/api/login`, {<br/>   data: {<br/>    username: username,<br/>    password: password,<br/>   },<br/>  })<br/>  return JSON.parse(await response.text())<br/> }<br/><br/> async setStock(productId) {....}<br/>}</span></pre><p id="3ee6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，测试更加简化，在任何情况下都采用异步/等待:</p><pre class="kg kh ki kj gt mt ms mu bn mv mw bi"><span id="e65a" class="mx lt iq ms b be my mz l na nb">test.beforeAll(async () =&gt; {<br/> let setupCalls = await SetupCalls.init("John", "John1213!")<br/> await setupCalls.setStock("00001")<br/>})<br/><br/>test("Test that requires product with id 00001 in stock", async (request) =&gt; {<br/> // TEST ITSELF BEGINS<br/>})</span></pre><h1 id="137e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最后的润色和改进</h1><p id="27db" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在测试运行之前设置数据通常是可能的。<code class="fe mp mq mr ms b">playwright.config.js</code>配置文件中的<code class="fe mp mq mr ms b">globalSetup</code>标志允许我们为处理全局设置的文件指定一个位置:</p><pre class="kg kh ki kj gt mt ms mu bn mv mw bi"><span id="19e2" class="mx lt iq ms b be my mz l na nb">const config = {<br/> globalSetup: require.resolve("./globalSetup"),<br/> testDir: "./tests",<br/> timeout: 80 * 1000,<br/> expect: {<br/>  timeout: 5000,<br/> },<br/>...<br/>}</span></pre><p id="1603" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经构建了类，文件可以调用它，并在一个函数中设置整个数据集。我们甚至可以将所有的调用设置为并行运行，以加快测试速度，因为发布产品的调用是不相关的。这就是<code class="fe mp mq mr ms b">globalConfig.js</code>文件的样子:</p><pre class="kg kh ki kj gt mt ms mu bn mv mw bi"><span id="50c1" class="mx lt iq ms b be my mz l na nb">module.exports = async (config) =&gt; {<br/> let setupCalls = await SetupCalls.init(config.username, config.password)<br/> let dataset = ["00001", "00002", "00003", "00004"]<br/><br/> const responses = await Promise.all(<br/>  dataset.map(async (id) =&gt; {<br/>   const res = await setupCalls.setStock(id)<br/>  })<br/> )<br/><br/> console.log(responses)<br/>}</span></pre><h1 id="067a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="54d7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果您正在进行API测试，或者只是利用API进行数据准备或其他自动化，那么最好是在提供可读性和结构的同时，以支持灵活性的方式来安排调用。</p><p id="2255" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于其异步特性，JavaScript有时可能会令人困惑。因此，在保持性能的同时保持事情的简单明了可能是合格代码和优秀代码之间的区别。</p></div></div>    
</body>
</html>