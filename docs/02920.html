<html>
<head>
<title>Look for Code Smells in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中寻找代码味道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/looking-for-code-smells-in-javascript-677f1a312f29?source=collection_archive---------16-----------------------#2020-01-08">https://betterprogramming.pub/looking-for-code-smells-in-javascript-677f1a312f29?source=collection_archive---------16-----------------------#2020-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7a5c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这总是清理重复代码、复杂代码和更多反模式的好时机</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/143f7d29be3b171c60d08ac68924ee43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M6pqRvGrTR-0UJWNezmJ_A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@4themorningshoot?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">奥利弗·黑尔</a>在<a class="ae ky" href="https://unsplash.com/s/photos/cleaning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="dff8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编程中，代码气味是一段代码的特征，表明可能有更深层次的问题。这是一种主观特征，用于通过观察代码来判断代码是否质量良好。</p><p id="6192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，代码味道仍然适用。因为有旧的构造应该被消除，所以查看旧代码可能会产生额外的问题。</p><p id="953e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将使用JavaScript代码作为例子来研究一些代码味道。我们看到的代码味道包括重复代码、复杂代码、猎枪手术和太大的类。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3126" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">常见代码气味</h1><h2 id="549a" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">重复代码</h2><p id="cb93" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">重复代码是在不同地方重复做同一件事的代码。非常相似的代码段也可能被认为是重复的。</p><p id="e697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个问题，因为当我们必须改变重复的代码时，我们必须改变多段代码。此外，很容易忘记其他开发人员也在那里。</p><p id="2cf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是为什么不重复自己(干)原则被强调很多的原因。它节省了开发人员的时间。</p><p id="423a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="05ec" class="mu md it nm b gy nq nr l ns nt">let numApples = 1;</span></pre><p id="e44f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个代码文件中，如果我们想得到苹果的数量，我们可以在任何地方使用它。</p><p id="8089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有重复运行多次的代码，那么我们使用一个循环。如果我们想在多个地方运行一段代码，但不重复，那么我们可以编写一个函数并运行它。</p><p id="0627" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有这样的东西:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="3b77" class="mu md it nm b gy nq nr l ns nt">let str = '';<br/>str += 'foo';<br/>str += 'bar';<br/>str += 'baz';</span></pre><p id="96a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该改为写:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="053e" class="mu md it nm b gy nq nr l ns nt">const arr = ['foo', 'bar', 'baz'];<br/>let str = '';<br/>for (let word of arr) {<br/>  str += word;<br/>}</span></pre><p id="206b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想让代码在多个模块中可用，我们导出它，然后导入到其他地方。</p><p id="44e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以在一个名为<code class="fe nu nv nw nm b">module.js </code>的JavaScript模块中编写以下代码，并在其他地方导入<code class="fe nu nv nw nm b">foo</code>函数:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="e218" class="mu md it nm b gy nq nr l ns nt">export foo = () =&gt; 'foo';</span></pre><p id="23c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并将其命名为:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="047e" class="mu md it nm b gy nq nr l ns nt">import { foo } from 'module';<br/>const bar = foo();</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2db5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">太复杂的代码</h1><p id="da02" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">如果有更简单的解决方案，我们应该去做，而不是写一些更复杂的东西。</p><p id="2cd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单的解决方案易于阅读和更改。</p><p id="8f54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="e5eb" class="mu md it nm b gy nq nr l ns nt">let str = '';<br/>str += 'foo';<br/>str += 'bar';<br/>str += 'baz';</span></pre><p id="ab81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建字符串<code class="fe nu nv nw nm b">'foobarbaz'</code>，我们可以将其简化为:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="8f58" class="mu md it nm b gy nq nr l ns nt">let str = ['foo', 'bar', 'baz'].join('');</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="00b4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">猎枪手术</h1><p id="34f5" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">霰弹枪手术是一种改变，需要代码是多段代码才能改变。</p><p id="f9c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个问题，因为需要在多个地方进行更改，这使得更改变得困难。也很容易错过多个地方。</p><p id="2b5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这通常是由于在错误的地方添加了在多个地方运行的代码。通常有比编写在多个地方使用的代码更好的方法来修改代码。</p><p id="5878" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有一个Express应用程序，我们想在其中添加日志记录，我们不应该执行以下操作:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="74ac" class="mu md it nm b gy nq nr l ns nt">const express = require('express');<br/>const bodyParser = require('body-parser');</span><span id="68bd" class="mu md it nm b gy nx nr l ns nt">const app = express();</span><span id="3787" class="mu md it nm b gy nx nr l ns nt">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="727d" class="mu md it nm b gy nx nr l ns nt">app.get('/foo', (req, res) =&gt; {<br/>  console.log('foo called');<br/>  res.json({ message: 'foo' });<br/>});</span><span id="8170" class="mu md it nm b gy nx nr l ns nt">app.get('/bar', (req, res) =&gt; {<br/>  console.log('bar called');<br/>  res.json({ message: 'bar' });<br/>});</span><span id="6ef1" class="mu md it nm b gy nx nr l ns nt">app.get('/baz', (req, res) =&gt; {<br/>  console.log('baz called');<br/>  res.json({ message: 'baz' });<br/>});</span><span id="26c3" class="mu md it nm b gy nx nr l ns nt">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="1762" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码不好，因为我们必须给每条路线添加<code class="fe nu nv nw nm b">console.log</code>。</p><p id="5d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们应该将<code class="fe nu nv nw nm b">console.log</code>重构为一个路由中间件，它在代码路由代码运行之前运行:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="1735" class="mu md it nm b gy nq nr l ns nt">const express = require('express');<br/>const bodyParser = require('body-parser');</span><span id="92a0" class="mu md it nm b gy nx nr l ns nt">const app = express();</span><span id="51d2" class="mu md it nm b gy nx nr l ns nt">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="8426" class="mu md it nm b gy nx nr l ns nt">app.use((req, res, next) =&gt; {<br/>  if (req.path.substring(1)) {<br/>    console.log(`${req.path.substring(1)} called`);<br/>  }<br/>  next();<br/>});</span><span id="1ebb" class="mu md it nm b gy nx nr l ns nt">app.get('/foo', (req, res) =&gt; res.json({ message: 'foo' }));</span><span id="9cca" class="mu md it nm b gy nx nr l ns nt">app.get('/bar', (req, res) =&gt; res.json({ message: 'bar' }));</span><span id="8189" class="mu md it nm b gy nx nr l ns nt">app.get('/baz', (req, res) =&gt; res.json({ message: 'baz' }));</span><span id="a766" class="mu md it nm b gy nx nr l ns nt">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="4701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，上面的代码更加简洁，它实现了和以前一样的东西，除了我们只有一个<code class="fe nu nv nw nm b">console.log</code>，而不是每条路线一个。</p><p id="1f3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有更多的路由，那么更改日志代码将会更加困难。例如，如果我们想用某个日志库替换<code class="fe nu nv nw nm b">console.log</code>，那么如果我们将日志代码放入每条路由中，就会变得更加困难。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e64d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">大班</h1><p id="d6a7" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">任何大的类都很难维护。类应该创建只做一件事的对象。我们不希望班级太大，以至于他们要做很多事情。</p><p id="35e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个太大的物体被称为上帝物体。上帝是一个做得太多的物体。它非常大，而且它做许多事情。</p><p id="1003" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每堂课只应该解决小问题。如果他们很大，那么他们可能做得太多了。</p><p id="9299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个可能由过大的类引起的问题是类的不同部分相互依赖。在整理代码时，这种紧密耦合会带来很多麻烦。</p><p id="46e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们应该把大班分成做不同事情的小班。它们之间的通用功能可以被重构到一个父类中。</p><p id="54a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有下面的<code class="fe nu nv nw nm b">Employee</code>类:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="82cb" class="mu md it nm b gy nq nr l ns nt">class Employee {<br/>  eat() {<br/>    //...<br/>  }<br/>  drink() {<br/>    //...<br/>  }<br/>  work() {<br/>    //...<br/>  }<br/>  sleep() {<br/>    ///...<br/>  }<br/>  walk() {<br/>    //...<br/>  }<br/>}</span></pre><p id="8264" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个做得太多的类的例子，因为它有与雇员不直接相关的方法。</p><p id="6a71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们可以将该类分为两个类，如下所示:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="f94d" class="mu md it nm b gy nq nr l ns nt">class Person {<br/>  eat() {<br/>    //...<br/>  }<br/>  drink() {<br/>    //...<br/>  }<br/>  sleep() {<br/>    ///...<br/>  }<br/>  walk() {<br/>    //...<br/>  }<br/>}</span><span id="49b8" class="mu md it nm b gy nx nr l ns nt">class Employee extends Person {<br/>  work() {<br/>    //...<br/>  }<br/>}</span></pre><p id="1b63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在<code class="fe nu nv nw nm b">Employee</code>只有与员工相关的方法，那就是<code class="fe nu nv nw nm b">work</code>方法。我们将所有人通用的方法移到了<code class="fe nu nv nw nm b">Person</code>类中，这样我们就可以重用它们并清理<code class="fe nu nv nw nm b">Employee</code>类。</p><p id="3595" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遵循一些基本原则，清理代码并使其易于阅读和更改是很容易的。首先，将重复的代码移动到一个公共位置，并重用公共位置的代码。第二，不要创建做太多事情的类。第三，如果我们需要一次在许多地方修改代码，可能有更好的方法。最后，不要做太复杂的代码。</p></div></div>    
</body>
</html>