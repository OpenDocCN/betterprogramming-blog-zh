# JavaScript 中的生成器模式

> 原文：<https://betterprogramming.pub/the-builder-pattern-in-javascript-6f3d85c3ae4a>

## 用构建器模式构建代码

![](img/393bb499c5610da13fd2e43195c14892.png)

照片由 [Iker Urteaga](https://unsplash.com/@iurte?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄

当你用 JavaScript 开发应用程序时，你有时会发现构造复杂的对象很困难。一旦它在你的代码中达到这一点，它就变得更加重要，因为随着你的应用程序变大，它会变得更加复杂。

好消息是，有办法将这种复杂性分解成简单和更小的步骤，这就是我们今天要讨论的内容。

在本文中，我们将介绍一种在这些情况下会对您有所帮助的设计模式。

# 生成器设计模式

我们将要学习的设计模式通常被称为生成器设计模式，这是一种用于帮助构造复杂对象的模式。它有助于将对象构造从其表示中分离出来，这将有助于我们重用它来创建不同的表示。

它规划了以下步骤:

## *基类*包含业务逻辑

它还接收已创建的对象，并继续设置值。

## 将负责创建对象的代码分成*构建器、*构建器，它们最终也只是对象/类

所有这些构建者将负责定义构建复杂对象的步骤。

## 可以使用一个可选的类，叫做 *Director*

指导者参与定义方法，确保步骤以特定的顺序执行，以构建通常构造的对象。

# 构建器模式还解决了其他什么问题？

如前所述，当我们需要一种方法来帮助简化复杂对象的构造时，通常最需要构建器模式，所以在您的代码中引入这种模式的最佳时机是当您达到这一点时(或者当它们变大时)。

让我们看一下下面的示例代码，看看为什么它在将来会难以管理:

这里我们有一个`Frog`类。看上面的例子，你能想到什么问题？

你可能会也可能不会想到的一个问题是参数。我特别指的是这一行:

```
constructor(name, weight, height, gender) {
```

我们的`Frog`类定义看起来很容易理解，因为我们只消耗了很少的行。然而，当我们试图实例化`Frog`实例时，情况就不同了:

```
const bob = new Frog('Bob', 9, 2.2, 'male')
```

如果你决定去加勒比海度假六个月，你认为你会记得中间那两个参数指的是什么吗？你将被迫回去检查源代码，以便能够清楚地理解它们的真正含义。

当这两个参数是同一类型时，这尤其是一个问题。任何开发人员在实例化真实场景中的`Frog.`时，都可能很容易混淆`weight`或`height`参数的位置，这些情况在医疗行业等行业中尤其重要，因为一个数据不匹配可能会让公司损失惨重。

那么这是如何简化的呢？你猜对了，使用构建器模式。

下面是按照模式简化后的代码:

我们现在可以清楚地看到创建`Frog`实例时发生了什么。

让我们来看看构造函数，看看我们从返工中获得了什么:

```
constructor(name, gender) {
    this.name = name
    this.gender = gender
  }
```

当从`4`实例化到`2`时，`FrogBuilder`减少了参数的数量，因为它将它们移到了它的实现细节中。这不仅更容易理解，而且在实例化时看起来更自然:

```
const sally = new FrogBuilder('Sally', 'female')
```

以前，我们很容易忘记在哪里、何时或者如何在一个`Frog`上设置`weight`和`height`属性:

```
const bob = new Frog('Bob', 9, 2.2, 'male')
```

有了新的方法，构建者(`FrogBuilder`)通过鼓励更多的开放机会来解决这个问题，从而简化了这个问题:

就这样，我们得到了同样的结果，只是现在它对我们人类来说更容易管理和阅读。

另一个例子:让我们想象一下，有一个复杂的对象，需要对大量的字段和嵌套的对象进行大规模、系统化的逐步初始化。这可能隐藏在具有许多参数的巨大构造函数中，甚至分散在代码中。

例如，让我们继续考虑如何创建一个汽车对象。为了制造一辆简单的汽车，你需要制造四个轮子，一个方向盘，刹车和油门踏板。但是，如果你想要一辆有附加功能的卡车，比如天窗和空调呢？

这个任务看起来最简单的解决方案是扩展基本的 car 类，并创建一组子类，每个子类包含一些参数。但是如果你仔细想想，你最终会面临这样的问题，每次你遇到新的参数，比如有有色的窗户，你都必须创建新的子类。而每一次这种情况发生，你的等级就会增长更多。

另一种方法是在基本的`Car`类中创建一个巨大的构造函数，处理控制汽车对象的所有可能的参数变化。虽然这消除了对子类的任何需求，但它仍然引入了一个新问题。

当你有一个试图处理每个参数的巨大构造函数时，在大多数情况下，这是一个坏主意，因为大多数参数实际上不会被使用。这使得构造函数块不必要的难以理解和维护。

例如，大多数汽车甚至不需要天窗，因此与天窗相关的参数在 99%的时间里都会变得相当无用。

这篇文章到此结束。我希望你发现这是有价值的。