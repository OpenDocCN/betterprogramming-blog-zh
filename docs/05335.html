<html>
<head>
<title>Automated Netlify Builds Only When You Need Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">仅当您需要时，才自动构建网络</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/automated-netlify-builds-only-when-you-need-them-723a14ad3dfb?source=collection_archive---------10-----------------------#2020-06-30">https://betterprogramming.pub/automated-netlify-builds-only-when-you-need-them-723a14ad3dfb?source=collection_archive---------10-----------------------#2020-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0773" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将AWS与Netlify构建挂钩一起使用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bd7d276433ac7658c8e168bcc309f4d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hFdUKBJaexRsvUebpNnWOQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="0e1a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以前，<a class="ae lu" href="https://medium.com/better-programming/getting-gatsby-wrong-836c198eb6ea" rel="noopener">我写过关于</a>更新我的Gatsby网站以在构建时而不是运行时获取数据。这意味着站点只在构建过程中从外部API获取数据，而不是在每次用户访问站点时获取。</p><p id="eea2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我这样做是因为我的数据是相当静态的——这是一个<a class="ae lu" href="https://cpv123.netlify.app/coffee/" rel="noopener ugc nofollow" target="_blank">咖啡店列表</a>,每周只变化一次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/a88fb1fc6f27b0a96d10ce69a3b2faa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRdHMxB5p1ZomGwyR7Rzfg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">先睹为快名单本身。这里有些高分者。</p></figure><p id="978d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">构建时抓取带来了改进的UX，甚至可以节省一些成本。但是构建时抓取的缺点是当数据改变时——比如增加了一个新商店——更新的数据不会出现在站点上，直到它被重新构建和重新部署。</p><p id="4dd6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着每增加一家新咖啡店，我都必须:</p><ol class=""><li id="7751" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt mb mc md me bi translated">通过我的网站添加新的商店(这将对数据库说)。</li><li id="0c01" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">登录Netlify控制台并触发站点的构建和部署。</li></ol><p id="96fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这并不是一个很长的过程，但是只要有一个以上的步骤，就为自动化留下了空间。输入<a class="ae lu" href="https://docs.netlify.com/configure-builds/build-hooks/" rel="noopener ugc nofollow" target="_blank"> Netlify构建钩子</a>。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="6756" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">用Netlify构建钩子自动化构建</h1><p id="86a0" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">构建挂钩是一个唯一的URL端点，您可以使用它来触发站点的构建和部署。您可以从Netlify控制台的站点构建和部署设置下生成构建挂钩URL:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/e24c3053fa85aefaff6c9621e2ee62be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-3hzHWiZlcgcUd2I7Lsddg.png"/></div></div></figure><p id="613b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦您有了URL，只需向它发送一个POST请求，您的站点将从您选择的分支部署。</p><p id="4615" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我已经有一个AWS lambda函数负责将咖啡店保存到AWS <a class="ae lu" href="https://aws.amazon.com/dynamodb/" rel="noopener ugc nofollow" target="_blank"> DynamoDB </a>表中，所以我更新了这个lambda，以便在我想要重新部署时也向构建钩子发送POST请求(如果我在通过我的网站添加新商店时选中了“应该触发部署”框)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/0fbe4e983ee371c6ec7e0c24ea13f3c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*W6Mw9SYYO0kwjkRcg8nckw.png"/></div></figure><h2 id="1ac1" class="nq ms it bd mt nr ns dn mx nt nu dp nb lh nv nw nd ll nx ny nf lp nz oa nh ob bi translated">通过AWS无服务器应用程序更进一步</h2><p id="3139" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">我最初的系统运行得很完美，但有时过度开发一个辅助项目也很有趣。</p><p id="d5f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望每个职责都有一个lambda函数，而不是用一个lambda函数来拯救商店并触发构建。</p><p id="261c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一个lambda将拯救商店，第二个lambda将触发构建(如果需要的话)。使用AWS <a class="ae lu" href="https://aws.amazon.com/sns/" rel="noopener ugc nofollow" target="_blank">简单通知服务</a> (SNS)，使这些lambda函数相互通信变得“简单”。</p><p id="aec2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这给我留下了以下架构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/aa39681b11816921687dbfa2eff93cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*69oxscwyyc2S4t2HwFS2uw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="9786" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当通过网站添加商店时，它会启动整个AWS无服务器应用程序:</p><ol class=""><li id="d671" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt mb mc md me bi translated">API网关接收表单数据并触发<code class="fe od oe of og b">PostShopLambda</code>函数。</li><li id="4a31" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><code class="fe od oe of og b">PostShopLambda</code>函数接收表单数据并总是将商店保存到DynamoDB表中。</li><li id="0e4c" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">如果表单数据的<code class="fe od oe of og b">triggerDeploy</code>参数为真(表单上的复选框已被勾选)，那么<code class="fe od oe of og b">PostShopLambda</code>也会向特定的SNS主题发布消息。</li><li id="638b" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">一旦消息到达SNS主题，订阅的<code class="fe od oe of og b">TriggerDeployLambda</code>将会看到消息，并且知道使用Netlify webhook重新触发站点的构建和部署。</li></ol><p id="9f58" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大部分工作由<code class="fe od oe of og b">PostShopLambda</code>函数完成。它总是将商店保存到数据库中，如果需要，还可能发布SNS消息来触发部署。</p><p id="d49f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该函数的核心部分如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="a9de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果一条消息发布到SNS主题，订阅功能<code class="fe od oe of og b">TriggerDeployLambda</code>将被调用。</p><p id="0d66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我前面提到的，构建钩子只是一个可以发送POST请求的URL，这意味着<code class="fe od oe of og b">TriggerDeployLambda</code>函数非常简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="86b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，该URL还有一个触发器标题，它出现在站点的构建列表中，这使得将这些自动化部署与其他部署区分开来变得很容易。</p><h2 id="fdcb" class="nq ms it bd mt nr ns dn mx nt nu dp nb lh nv nw nd ll nx ny nf lp nz oa nh ob bi translated">AWS无服务器应用程序模型(SAM)</h2><p id="947d" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">所有这些都是使用<a class="ae lu" href="https://aws.amazon.com/serverless/sam/" rel="noopener ugc nofollow" target="_blank">无服务器应用程序模型(SAM) </a>构建的，这使得在AWS上设置无服务器应用程序变得很容易。</p><p id="b12b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">整个应用程序在一个<code class="fe od oe of og b">template.yaml</code>文件中描述。这列出了应用程序的所有AWS资源(lambda函数、DynamoDB表等。)并且还描述了这些资源如何通过订阅、许可等相互交互。</p><p id="83a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个例子的完整代码可以在GitHub 上找到<a class="ae lu" href="https://github.com/cpv123/serverless-application-coffee-shops" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>