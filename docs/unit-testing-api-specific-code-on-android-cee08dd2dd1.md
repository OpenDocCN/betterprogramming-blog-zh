# Android 上特定于 API 的代码的单元测试

> 原文：<https://betterprogramming.pub/unit-testing-api-specific-code-on-android-cee08dd2dd1>

## 经过几次失败的尝试后，一本完善的指南

![](img/ab883edee6a67a9b96cdeae7a755e9a9.png)

你是否曾经长时间盯着某件事，以至于你觉得已经用尽了所有可能的解决方法？最后，当你到达你的最后一个技巧时，它让你困惑，为什么它没有早点出现在你面前？这是我在 Android 上对特定于 API 的代码进行单元测试的经历。

对项目的这些部分进行单元测试可能具有挑战性，并且通常容易被认为“太难测试”我解决这个问题的大部分尝试都感觉站不住脚，不合时宜，但不足以让我用它来换取更少的单元测试覆盖率。

怎样做才能使项目代码的测试变得容易，并且感觉是集成的和经过深思熟虑的？也许你不会惊讶于 Dagger 在这个解决方案中扮演的核心角色。

# 了解编译器

在深入探讨我称之为合适的解决方案之前，让我们先看看为什么这不是一个容易解决的问题。首先，Kotlin 编译器在构建 Android 应用时考虑了优化。在大多数情况下，工程师会笑着说这是个好消息。事实证明，这种优化使我们的工作更加困难。

假设您有这段代码来解码 Android 上的位图:

一个跨越多个 API 版本来解码位图的函数

Android 9 (Pie、P、API 28 等)或更高版本推荐使用一个`ImageDecoder`来完成这项工作。在低于这个级别的 API 上它是不可用的，所以我们求助于`MediaStore`来完成相同的任务。可惜的是，`MediaStore`上的`getBitmap()`已经弃用。这使我们陷入了一个尴尬的境地，不可用的 API 和不推荐的 API，这取决于您的版本。使用版本检查有助于平滑那些粗糙的边缘。

在这种情况下，您可以在单元测试过程中使用运行时反射闯入`Build.VERSION`对象并重写`SDK_INT`值:

更改 Build 值的函数。版本

老实说，这是最好的笨重，最差的不可靠。由于`SDK_INT`只是一个`public static final`(kot Lin 术语中的`const val`)，我希望其他具有类似访问器和作用域的对象也能以同样的方式工作。假设我们在`BuildConfig`对象上使用了不同的属性。在这个例子中，我使用了`BUILD_TYPE`标志:

为发布版本设置安全标志的活动

使用反射方法应该以同样的方式工作，并允许我切换这个布尔值。然而，事实并非如此。在单元测试期间，两个对象上的两个`public static final`属性表现不同。这是因为编译器优化了字符串，使其读起来像这样:

常量被内联后，编译后的代码看起来更加真实

在某些情况下，编译器内联这些值，而在其他情况下，它保留对对象的引用。没有办法访问内联值，所以我们显然不能依赖这种技术。我们的基础并不稳固，因为在测试静态属性时，我们需要两种不同的方法。

# 匕首拯救世界

Dagger 通常通过观察一个请求来工作，该请求通过查看一个类的唯一类型来填充构造函数或字段中的特定参数。只要匹配类型在其对象图中可用，它就会提供该对象的实例。

然而，当我们在 API 级别上使用整数或者在构建类型上使用字符串时，我们非常相信在我们的整个对象图中再也不会有另一个整数或者字符串了。当从您的应用程序或另一个库中提供自定义的、完全限定的类时，这种想法是可以理解的，但对于构建这些语言的基础、原始类型来说，这种想法是不可理解的。

我们可以不用依赖类型，而是使用标签。当您用`@Named("my unique name")`注释 Dagger 模块中的函数时，Dagger 使用它作为匹配条件。这种方法更适合匹配字符串、整数、布尔和其他原语等类型。

我已经从`Build`和`BuildConfig`对象中取出了每一个有问题的静态属性，并将它们移动到一个适当注释的 Dagger 模块中:

Dagger 在 Build 和 BuildConfig 对象上提供静态值

现在，我可以将这些属性注入到我的类中，而不用担心不必要的编译器优化。当需要对这些类进行单元测试时，我可以直接向构造函数或字段提供我想要的值:

支持测试 API 相关代码的图像解码器

Dagger 将构建类型注入 MainActivity

# 结论

了解`@Named()`注释对于解决我项目中的一个长期问题至关重要。在生活中，我没有多少次可以说我遇到了银弹。然而，这种解决方案可能就是其中一种情况。

它为`Build`和`BuildConfig`对象提出的问题提供了统一的解决方案。我的项目现在可以采取一致的方法来解决这个问题，并删除所有我超时设计的创造性解决方案，以通过几行来提升我的覆盖度量。

如果你不知道这种技术，我希望这对你来说是一个启发性的时刻，并且会用更少的努力在你的测试中解锁更健壮的覆盖率。现在，在这种情况下，我们遵循艾伦·f·莫根森的智慧，这是人类在伟大的时间大厅中推崇的。“更聪明地工作，而不是更努力。”

# 喜欢你读的东西吗？

本文最初发表于[https://oliverspryn.com/](https://go.oliverspryn.com/unit-testing-api-specific-code-on-android)。