<html>
<head>
<title>Create a Custom SwiftUI Property Wrapper to Combine Storing and Publishing Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个自定义SwiftUI属性包装器来组合存储和发布值</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-property-wrapper-to-combine-storing-and-publishing-values-578c1c6bee88?source=collection_archive---------0-----------------------#2021-11-18">https://betterprogramming.pub/how-to-create-a-property-wrapper-to-combine-storing-and-publishing-values-578c1c6bee88?source=collection_archive---------0-----------------------#2021-11-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0b3b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为您自己的用例构建一个属性包装</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cae500f1e65735a39e754352c691bd6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lehMEkv3_bl9mXsZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">格伦·卡斯滕斯-彼得斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="40d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2019年引入了属性包装器。从那以后，我们学会了如何使用它们，如何创建它们，苹果也在不断地发布它们。</p><p id="a48d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，它们不能轻易结合。每当我们应用属性包装时，属性的实际类型都会改变。组合包装器将导致难以使用的奇怪类型。</p><p id="5a4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天的文章中，我们将尝试通过创建一个自定义属性包装器来克服这个限制。</p><h1 id="0cc4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用案例</h1><p id="f5c7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">将引入的<code class="fe ms mt mu mv b"><a class="ae ky" href="https://developer.apple.com/documentation/combine/publisher" rel="noopener ugc nofollow" target="_blank">Publisher</a></code>通知其他组件的变化。这种机制在SwiftUI中广泛使用，通过<code class="fe ms mt mu mv b">@<a class="ae ky" href="https://developer.apple.com/documentation/combine/published" rel="noopener ugc nofollow" target="_blank">Published</a></code>属性包装器通知UI状态的变化。</p><p id="b24e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了SwiftUI之外,<code class="fe ms mt mu mv b">@Published</code>属性包装器可以用在许多上下文中。例如，我们可以有一个<code class="fe ms mt mu mv b">UserPreferencesManager</code>来跟踪用户偏好。我们可以使用<code class="fe ms mt mu mv b">@Published</code>将偏好的改变传播到应用程序的其他部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="382f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处理用户首选项时，我们希望将它们存储在本地。我们想到的第一个存储选择是<code class="fe ms mt mu mv b"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/userdefaults" rel="noopener ugc nofollow" target="_blank">UserDefaults</a></code>:一种存储键值对的简单方法。</p><p id="d71e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI引入了<code class="fe ms mt mu mv b">@<a class="ae ky" href="https://developer.apple.com/documentation/swiftui/appstorage" rel="noopener ugc nofollow" target="_blank">AppStorage</a></code>属性包装器来简化来自<code class="fe ms mt mu mv b">UserDefaults</code>的信息的存储和检索。通过这个属性包装器，变量被自动存储在<code class="fe ms mt mu mv b">UserDefaults</code>的一个实例中，并从该实例中检索。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="bf8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个代码片段中，我们指定了一个键，这个键将被<code class="fe ms mt mu mv b">@AppStorage</code>属性包装器用来存储和检索<code class="fe ms mt mu mv b">name</code>首选项。</p><p id="7cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，并不是所有闪光的东西都是金子。通过研究<code class="fe ms mt mu mv b">@AppStorage</code>属性包装器的签名，我们可以看到它依赖于<code class="fe ms mt mu mv b">UserDefaults</code>的具体实现，而不是它的接口，因此它违反了<a class="ae ky" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank">依赖倒置</a>原则。</p><p id="adb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何将这两个属性包装器结合起来。我们将从一个手动解决方案开始，我们将实现一个基于自定义属性包装的可扩展解决方案。</p><h1 id="b6ac" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基本场景</h1><p id="e806" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们来刷新一下需求。我们希望:</p><ol class=""><li id="fc35" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">从存储器中存储和检索一段数据。</li><li id="cd28" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">当数据更新时，发布新值。</li></ol><p id="f953" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为软需求，我们希望避免代码重复，允许依赖注入和可测试性。</p><p id="91aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个好的心态是开始实现一个可行的解决方案，然后重构它以实现我们所有的目标。下面是一个基本的手动工作解决方案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="04da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个片段中，我们定义了<code class="fe ms mt mu mv b">Storage</code>协议:一个用于任何类型存储的接口。为了简单起见，我们将开始只存储<code class="fe ms mt mu mv b">String</code>类型，但是我们可以将解决方案扩展为通用的。这个协议使我们能够使用任何符合它的<code class="fe ms mt mu mv b">Storage</code>，而不仅仅是<code class="fe ms mt mu mv b">UserDefaults</code>。有了这个协议，我们已经克服了<code class="fe ms mt mu mv b">@AppStorage</code>的一个限制。</p><p id="6bd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们上<code class="fe ms mt mu mv b">UserPreferenceManager</code>课。在那个类中，我们为键创建了一个抽象，以避免输入错误，并且我们定义了一个<code class="fe ms mt mu mv b">name</code>属性。<code class="fe ms mt mu mv b">name</code>属性是<code class="fe ms mt mu mv b">@Published</code>，所以app的其他部分可以在它发生变化时做出反应。</p><p id="2e71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们需要存储和检索它。我们不能用一个以上的属性包装器来注释同一个变量。理论上，这是可能的，但是每个属性包装器都会改变变量的实际类型。例如，像这样的属性的发布者</p><pre class="kj kk kl km gt nm mv nn no aw np bi"><span id="0c78" class="nq lw it mv b gy nr ns l nt nu">@Published @AppStorage("name") var name: String </span></pre><p id="c28b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不是一个<code class="fe ms mt mu mv b">Publisher&lt;String&gt;</code>而是一个<code class="fe ms mt mu mv b">Publisher&lt;AppStorage&lt;String&gt;&gt;</code>。这将使使用<code class="fe ms mt mu mv b">name</code>变量变得更加困难。</p><p id="495b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们开始通过使用<code class="fe ms mt mu mv b">willSet</code>属性观察器和保存<code class="fe ms mt mu mv b">UserDefaults</code>中的值来解决存储问题。</p><p id="e724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须做出的决定是关于使用<code class="fe ms mt mu mv b">willSet</code>还是<code class="fe ms mt mu mv b">didSet</code>属性观察器。<code class="fe ms mt mu mv b">@AppStorage</code>属性包装器文档没有指定值何时存储在磁盘上。我们更喜欢在更新内存之前更新存储，以便为用户提供一致的体验。如果我们在磁盘之前更新内存，我们可能会达到不一致的状态，其中:</p><ul class=""><li id="268e" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nv ne nf ng bi translated">用户看到更新的版本，</li><li id="a3df" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nv ne nf ng bi translated">应用程序在存储值之前崩溃，</li><li id="0d42" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nv ne nf ng bi translated">用户重新启动应用程序，</li><li id="7b4f" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nv ne nf ng bi translated">用户会看到旧值。</li></ul><p id="40fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用<code class="fe ms mt mu mv b">willSet</code>，这种情况就不会发生。在最坏的情况下，应用程序崩溃，用户看到新的值，这是他们必须看到的正确值。</p><p id="a16c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存储问题的最后一步是何时从磁盘中检索值。初始化器为我们做了这项工作。</p><p id="3211" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法很好，但是扩展性不好。如果我们需要添加多个<code class="fe ms mt mu mv b">@Published</code>值，我们需要复制并粘贴属性观察器，我们还需要一个接一个地初始化<code class="fe ms mt mu mv b">init</code>中的所有属性。</p><h1 id="18d6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">统一的解决方案</h1><p id="1785" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个问题的正确解决方案是将两个属性包装器结合在一起。然而，我们没有任何API可以让我们真正地将它们结合在一起。</p><p id="3f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方法是创建我们自己的属性包装器。使用定制的属性包装器，我们可以实现我们需要支持的用例，并且可以避免代码重复。</p><p id="204e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了安全地重构代码，我们需要一个测试套件来确保实现的行为不会改变。一旦我们有了单元测试，我们就可以创建属性包装器并在实现中使用它。</p><h2 id="6cad" class="nq lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">添加测试套件</h2><p id="a56e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们想要实施的行为是:</p><ol class=""><li id="01d5" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">当<code class="fe ms mt mu mv b">name</code>改变时发布一个值。</li><li id="6214" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">验证当我们更新<code class="fe ms mt mu mv b">name</code>时，新值是否被保存。</li><li id="ff59" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">在启动时，验证<code class="fe ms mt mu mv b">name</code>包含正确的值。</li></ol><p id="0110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些测试将帮助我们保留我们想要的接口。事实上，如果我们不得不更新一些测试代码，我们就会知道有问题。</p><p id="8303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢<strong class="lb iu">依赖注入</strong>，我们可以从实际的存储实现中抽象出来。首先，让我们为我们的测试创建一个<code class="fe ms mt mu mv b">MockedStorage</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="18bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个用来存储所有值的字典。它使用一些<code class="fe ms mt mu mv b">String</code>键。它用下标实现<code class="fe ms mt mu mv b">Storage</code>协议方法。</p><p id="beaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以设置测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0e40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该片段概述了测试的结构。我们在<code class="fe ms mt mu mv b">setUpWithError</code>方法中初始化了几个强制展开的属性。注意，<code class="fe ms mt mu mv b">storage</code>是<code class="fe ms mt mu mv b">Storage</code>类型的，所以我们可以使用我们想要的任何实现。</p><p id="c3c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe ms mt mu mv b">tearDownWithError</code>中，我们释放这些值的内存。</p><p id="0325" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在编写测试时学到的一个小技巧是，开始只编写签名:这有助于我在更高的抽象层次上思考，专注于我想要测试的东西。这有助于我了解我是否涵盖了所有的边缘案例。</p><p id="2d99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我对测试用例的签名感到满意时，我开始填充实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2b93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">花几分钟时间阅读测试。它们并不复杂:</p><ol class=""><li id="1d19" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">在第一个测试中，我们创建了<code class="fe ms mt mu mv b">sut</code>，我们订阅了<code class="fe ms mt mu mv b">@Published</code>属性，然后我们断言属性如我们预期的那样发生了变化。我们需要删除在<code class="fe ms mt mu mv b">init</code>之后发出的第一个发布值。</li><li id="e4f2" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">在第二个测试中，我们创建了<code class="fe ms mt mu mv b">sut</code>，并检查存储器中的值是否从<code class="fe ms mt mu mv b">nil</code>传递到给定值。</li><li id="386f" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">在最后一个测试中，我们通过设置<code class="fe ms mt mu mv b">sut</code>的初始值来准备测试。然后我们创建<code class="fe ms mt mu mv b">sut</code>，并确保第一个值是正确的。</li></ol><p id="d24c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们按下<code class="fe ms mt mu mv b">⌘+U</code>，我们应该会看到测试通过。我们有一个坚实的工作基础。</p><h1 id="59c0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><code class="fe ms mt mu mv b">Create the Custom Property Wrapper</code></h1><p id="a529" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接下来，我们创建属性包装器。为此，我们创建了一个用<code class="fe ms mt mu mv b">@propertyWrapper</code>关键字注释的类型。</p><p id="eb16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该关键字要求该类型具有一个<code class="fe ms mt mu mv b">wrappedValue</code>属性。它可以是任何类型，可以是计算的或存储的属性。</p><p id="4db4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们希望有一个存储在<code class="fe ms mt mu mv b">Storage</code>中并从中检索的<code class="fe ms mt mu mv b">wrappedValue</code>。我们将把<code class="fe ms mt mu mv b">Storage</code>注入到<code class="fe ms mt mu mv b">propertyWrapper</code>中。为了存储和检索对象，我们需要一个<code class="fe ms mt mu mv b">key</code>属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这个片段，我们重新实现了<code class="fe ms mt mu mv b">@AppStorage</code>属性包装器。属性<code class="fe ms mt mu mv b">storage</code>被隐式展开以支持<strong class="lb iu">属性注入</strong>。在编写的时候，属性包装器语法不能访问<code class="fe ms mt mu mv b">self</code>实例，即使在闭包或惰性变量中也不能。这意味着尚不支持以下语法:</p><pre class="kj kk kl km gt nm mv nn no aw np bi"><span id="13cd" class="nq lw it mv b gy nr ns l nt nu">class AClass {<br/>  let storage: Storage</span><span id="a96a" class="nq lw it mv b gy oh ns l nt nu">  // invalid  <br/>  @StoredPublished(key: "a-key", storage: self.storage) var name: String</span><span id="3218" class="nq lw it mv b gy oh ns l nt nu">  // also this is invalid<br/>  @StoredPublished(key: "a-key", storage: { self.storage }) var name: String</span><span id="4746" class="nq lw it mv b gy oh ns l nt nu">}</span></pre><p id="027d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们不能在注释语法中注入依赖关系。将依赖项注入到由属性包装器支持的变量中的唯一方法是使用包装的属性将其注入到类型的<code class="fe ms mt mu mv b">init</code>中。</p><p id="d9b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，我们需要使用一个隐式展开的属性。请注意，如果我们忘记设置它，这可能会导致运行时崩溃。我们可以通过为<code class="fe ms mt mu mv b">storage</code>属性提供默认值来防止这种情况。尽管如此，我更喜欢崩溃:在这种情况下，这是一个系统化的开发错误，测试会立即捕捉到，并且修复非常快。</p><p id="7235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来实现<code class="fe ms mt mu mv b">publisher</code>。有许多方法可以实现这一点，但最简单的方法是使用一个<code class="fe ms mt mu mv b">PassthroughSubject</code>。一个<code class="fe ms mt mu mv b">Subject</code>支持一个<code class="fe ms mt mu mv b">send</code>方法将它的值传播给所有的订阅者。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f23d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个代码片段只包含了我们需要的<code class="fe ms mt mu mv b">Publisher</code>的代码行以及清晰的上下文。</p><p id="452c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第12行，我们声明了私有的<code class="fe ms mt mu mv b">publisher</code>，并用<code class="fe ms mt mu mv b">PassthroughSubject</code>初始化它。在第7行，我们发布了新值，在我们把它存储在<code class="fe ms mt mu mv b">storage</code>中之后。</p><p id="5f99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第16行，我们声明了一个名为<code class="fe ms mt mu mv b">projectedValue</code>的计算属性。这个属性启用了我们在绑定变量和观察<code class="fe ms mt mu mv b">@Published</code>变量时使用的<code class="fe ms mt mu mv b">$</code>语法。</p><h1 id="ff13" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">连接属性包装</h1><p id="0f2a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们现在已经在属性包装器中实现了我们需要的所有行为，让我们用它来更新代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">改变真的很容易。</p><ol class=""><li id="4022" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">用<code class="fe ms mt mu mv b">@StoredPublished</code>替换<code class="fe ms mt mu mv b">@Published</code>属性包装器。新的属性包装器需要一个键，我们可以像以前一样使用<code class="fe ms mt mu mv b">StorageKeys.name.rawValue</code>键。</li><li id="99c6" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">移除<code class="fe ms mt mu mv b">willSet</code>属性观察器。</li><li id="bb20" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">用第12行替换对初始值的检索，我们在这里设置存储。</li></ol><p id="8539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以按<code class="fe ms mt mu mv b">⌘+U</code>来查看测试是否通过。</p><h2 id="4e78" class="nq lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">可量测性</h2><p id="7190" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这种解决方案比基本解决方案的伸缩性更好。当我们添加一个新变量时，我们只需要添加一个键，一个属性，并且我们需要设置属性包装器的<code class="fe ms mt mu mv b">storage</code>属性。</p><p id="d663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这最后一步是令人讨厌的部分:由于有许多<code class="fe ms mt mu mv b">@StoredPublished</code>属性，我们的<code class="fe ms mt mu mv b">init</code>最终会有许多这样的行:</p><pre class="kj kk kl km gt nm mv nn no aw np bi"><span id="8709" class="nq lw it mv b gy nr ns l nt nu"><strong class="mv iu">self</strong>._property1.storage = <strong class="mv iu">self</strong>.storage</span><span id="67b3" class="nq lw it mv b gy oh ns l nt nu"><strong class="mv iu">self</strong>._property2.storage = <strong class="mv iu">self</strong>.storage</span><span id="f96b" class="nq lw it mv b gy oh ns l nt nu">...</span><span id="fa35" class="nq lw it mv b gy oh ns l nt nu"><strong class="mv iu">self</strong>._propertyN.storage = <strong class="mv iu">self</strong>.storage</span></pre><p id="d5ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是最糟糕的，但也不好。</p><p id="6479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用<code class="fe ms mt mu mv b"><a class="ae ky" href="https://developer.apple.com/documentation/swift/mirror" rel="noopener ugc nofollow" target="_blank">MirrorAPI</a></code>做得更好。这些API让我们检查一个类型来探究它的属性。在我们的例子中，我们可以搜索所有用<code class="fe ms mt mu mv b">@StoredPublished</code>属性包装器标注的属性。这是可能的，因为属性包装隐式地改变了属性的实际类型。</p><p id="23b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，所有标注了<code class="fe ms mt mu mv b">@StoredPublished</code>的属性都变成了<code class="fe ms mt mu mv b">StoredPublished</code>类型。有了这些知识，我们可以编写这个助手函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c1fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数带有一个我们需要设置的<code class="fe ms mt mu mv b">Storage</code>，以及一个我们需要检查的实例。然后，它创建实例的<code class="fe ms mt mu mv b">Mirror</code>并检查其内容。每当有类型为<code class="fe ms mt mu mv b">StoredPublished</code>的属性时，我们就设置它的<code class="fe ms mt mu mv b">storage</code>属性</p><p id="7618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要在<code class="fe ms mt mu mv b">init</code>中调用这个函数，替换<code class="fe ms mt mu mv b">self._name.storage = self.storage</code>行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c6ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行测试，我们会看到他们崩溃。发生这种情况是因为<code class="fe ms mt mu mv b">StoredPublished</code>属性包装器是一个<code class="fe ms mt mu mv b">struct</code>。对于值类型，当我们用镜像检查包装时，我们会得到它的一个副本。我们需要更新它，因此我们宁愿有一个参考。</p><p id="196a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们把<code class="fe ms mt mu mv b">StoredPublished</code>的类型从<code class="fe ms mt mu mv b">struct</code>改成<code class="fe ms mt mu mv b">class</code>。让我们再次运行测试，看看他们是否通过。</p><p id="77e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在解决了所有的问题:每次我们添加一个新的<code class="fe ms mt mu mv b">@StoredPublished</code>属性时，我们不再需要更新<code class="fe ms mt mu mv b">init</code>。</p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><h1 id="bbda" class="lv lw it bd lx ly op ma mb mc oq me mf jz or ka mh kc os kd mj kf ot kg ml mm bi translated"><strong class="ak">结论</strong></h1><p id="4fe0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在今天的文章中，我们探索了几个非常有用的属性包装器，我们看到了它们在可组合性和可测试性方面的局限性。</p><p id="3e09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们实现了一个定制的属性包装器，来处理发布一个值并将其存储在抽象中的复杂用例<code class="fe ms mt mu mv b">Storage</code>。</p><p id="8164" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们解决了可伸缩性问题，使用<code class="fe ms mt mu mv b">MirrorAPI</code>将存储设置为用<code class="fe ms mt mu mv b">StoredPublished</code>属性包装器注释的所有类型。</p><p id="91f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对读者来说，一个很好的练习是将<code class="fe ms mt mu mv b">StoredPublished</code>转换成一个通用的，并相应地更新代码。</p></div></div>    
</body>
</html>