<html>
<head>
<title>How To Use Async/Await In Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Flutter中使用异步/等待</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-async-await-in-flutter-the-flutter-event-loop-97c696caf912?source=collection_archive---------2-----------------------#2021-08-16">https://betterprogramming.pub/how-to-use-async-await-in-flutter-the-flutter-event-loop-97c696caf912?source=collection_archive---------2-----------------------#2021-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="37f7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">颤振事件循环的观察</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/80c43df65a060e8099323c218743af99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iZ6iyQSdvX0cebpUEL1Qgg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="227e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我以前很讨厌Flutter里的async。我的意思是，如果你认真考虑一下，异步的函数/方法只是一个需要很长时间的函数/方法。那么为什么我必须使用<code class="fe lu lv lw lx b">async</code>关键字呢？为什么我不能正常地将异步代码与其他代码集成在一起？</p><p id="2333" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的意思是，如果我让我的<code class="fe lu lv lw lx b">build()</code>方法异步，这可能是一个非常糟糕的主意。但是仅仅因为这是一个坏主意并不意味着我不应该被允许这样做。这就是你学习的方式。因为做了错误的决定。</p><p id="a1e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我基本上已经走出了这个阶段。Async在Flutter上并不完美，后面我会解释原因，但也没有我想象的那么差。</p><h1 id="bde2" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">首先是一些基础知识——使用棉绒和期货</h1><p id="c860" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">所以首先使用棉绒。我的意思是用一个<code class="fe lu lv lw lx b">analysis_options.yaml</code>。这里有一个来自<a class="ae mv" href="https://github.com/flutter/flutter/blob/master/analysis_options.yaml" rel="noopener ugc nofollow" target="_blank">颤振回购</a>。虽然就我个人而言，我觉得这有点太固执己见了，所以我在这里做了自己的<a class="ae mv" href="https://gitlab.com/azuredown/state_groups/-/blob/6eba97cf2033bb8cbdb8e6cbe74b2b50e9654d4a/analysis_options.yaml" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="efdf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为默认情况下，颤振，或者我应该说，飞镖，让你逃脱最疯狂的事情。以前更糟糕的是，它让你不能从一个函数中返回任何东西，而这个函数显然应该返回一些东西。但是零安全解决了这个问题。</p><p id="4cb7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我总是假设Flutter会让它默认每个项目都有一个<code class="fe lu lv lw lx b">analysis_options.yaml</code>。但到目前为止还没有发生。</p><p id="75ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，当你读到这篇文章的时候，Flutter团队可能终于开始添加它了。与此同时你自己做一个<code class="fe lu lv lw lx b">analysis_options.yaml</code>档案。</p><p id="3eee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我告诉你使用linter文件的原因是因为一个特别的规则:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="0378" class="na lz it lx b gy nb nc l nd ne">- avoid_void_async</span></pre><p id="167e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，在Dart中，您可以使用:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="cfc6" class="na lz it lx b gy nb nc l nd ne">void foo() async {<br/>  // Do some stuff here<br/>}</span></pre><p id="6fff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那会运行得非常好。但是它返回void，这很好，但是为了正确使用await和async，我们需要像这样返回一个<code class="fe lu lv lw lx b">Future</code>:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="cdc5" class="na lz it lx b gy nb nc l nd ne"><strong class="lx iu">Future&lt;void&gt;</strong> foo() async {<br/>  // Do some stuff here<br/>}</span></pre><p id="3289" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将让我们用async和await做所有有趣的事情。如果你不小心使用了void，linter规则会自动警告你。</p><h1 id="3b17" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">现在你开始考虑期货了</h1><p id="14bb" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">那么现在我们在使用期货，我们如何利用它们做一些有用的事情呢？嗯，有几种使用它们的方法:</p><ol class=""><li id="f8b3" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">正常给他们打电话就行了</li><li id="c329" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">等待未来</li><li id="8559" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">连锁期货利用<code class="fe lu lv lw lx b">.then()</code></li></ol><h2 id="3c96" class="na lz it bd ma nt nu dn me nv nw dp mi lh nx ny mk ll nz oa mm lp ob oc mo od bi translated">1.正常给他们打电话</h2><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="c57e" class="na lz it lx b gy nb nc l nd ne">analyticsInstance.logEvent(name: “All Your Base Are Belong To Us!”)</span></pre><p id="48f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从技术上讲，这是一个未来，它将在自己的时间执行。</p><p id="1726" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这不是多线程。以前没有听说过异步的程序员有一种倾向，认为一切都是多线程的。Async使用事件循环。<a class="ae mv" href="https://www.youtube.com/watch?time_continue=1&amp;v=vl_AaCgudcY&amp;feature=emb_title" rel="noopener ugc nofollow" target="_blank">这个视频</a>解释的最好(跳到2:17左右)。</p><p id="c49b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以不是多线程。这只是魔法。</p><p id="dc2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，视频中有一个推论。一个事件不可能一次做太多工作。否则，它将阻塞事件循环，什么都不会发生。</p><p id="62c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果正在播放动画，这一点尤其明显。这是我自己的应用程序中的一个大问题。我不得不使用隔离物来处理它——即使这样，它也不是非常平滑。也许我以后会谈到分离株。</p><p id="536e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当他说“尽管Dart是一种单线程语言，但它提供了对未来、流、后台工作和所有其他你需要以现代、异步和(在flutter的情况下)反应式方式编写的东西的支持。”在<a class="ae mv" href="https://www.youtube.com/watch?v=vl_AaCgudcY&amp;t=14s" rel="noopener ugc nofollow" target="_blank">0:14左右</a>——我想他是在挖苦当时不支持异步的Swift但这只是我的看法。</p><h2 id="40ee" class="na lz it bd ma nt nu dn me nv nw dp mi lh nx ny mk ll nz oa mm lp ob oc mo od bi translated">2.手动等待期货是我以前使用的</h2><p id="d99d" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">因为是寄生所以很棘手。这意味着如果你<code class="fe lu lv lw lx b">await</code>一个异步函数或方法，那么这个函数或方法也必须是<code class="fe lu lv lw lx b">async</code>。</p><p id="a4c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以如果你有这个:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="37c5" class="na lz it lx b gy nb nc l nd ne">void foo() {<br/>  someAsyncFunction();<br/>}</span></pre><p id="6818" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这很好。但是现在让我们假设你是一个控制狂(就像我一样)，你想知道《T2》什么时候结束。所以你像这样使用一个<code class="fe lu lv lw lx b">await</code>:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="73e2" class="na lz it lx b gy nb nc l nd ne">void foo() {<br/>  await someAsyncFunction();<br/>}</span></pre><p id="a6e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是这会给你一个错误。因为你需要<code class="fe lu lv lw lx b">async</code>关键词:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="6eea" class="na lz it lx b gy nb nc l nd ne">void foo() async {<br/>  await someAsyncFunction();<br/>}</span></pre><p id="0005" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，如前所述，您应该将返回类型更改为<code class="fe lu lv lw lx b">Future</code>:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="5c4b" class="na lz it lx b gy nb nc l nd ne"><strong class="lx iu">Future&lt;void&gt;</strong> foo() async {<br/> await someAsyncFunction();<br/>}</span></pre><p id="39b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，这听起来没那么糟糕。但是随后你意识到如果你想让一些父母等待这个新特性，它也必须使用<code class="fe lu lv lw lx b">async</code>关键字。它就冒泡了。</p><p id="fe05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如已经讨论过的，我从来没有真正理解这是为什么。为什么你不能不添加关键字<code class="fe lu lv lw lx b">async</code>并且你的函数需要很长时间？</p><p id="2ab5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我对这种方法非常失望。这就是我不喜欢使用期货的原因。</p><h2 id="528d" class="na lz it bd ma nt nu dn me nv nw dp mi lh nx ny mk ll nz oa mm lp ob oc mo od bi translated">3.直到我意识到你可以用。then()方法</h2><p id="36f7" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">这就是魔法。假设您有<code class="fe lu lv lw lx b">task1</code>和<code class="fe lu lv lw lx b">task2</code>，其中<code class="fe lu lv lw lx b">task1</code>是异步的，<code class="fe lu lv lw lx b">task2</code>依赖于<code class="fe lu lv lw lx b">task1</code>。然后使用等待你去:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="b639" class="na lz it lx b gy nb nc l nd ne">Future&lt;void&gt; foo() async {<br/>  await task1();<br/>  task2();<br/>}</span></pre><p id="39bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它相当笨重。但是让我们假设你使用如下所示的<code class="fe lu lv lw lx b">.then()</code>关键字；</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="1b9d" class="na lz it lx b gy nb nc l nd ne">void foo() {<br/>  task1().then((_) {<br/>    task2();<br/>  });<br/>}</span></pre><p id="70f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在<code class="fe lu lv lw lx b">foo()</code>不再需要异步。相当神奇。最重要的是，有些你没想到会成为未来的东西实际上是。因为未来只是在未来有一个起点和一个终点的一些操作。</p><p id="967f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，显示一个对话框。实现这一点的标准方式如下:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="602f" class="na lz it lx b gy nb nc l nd ne">showDialog(<br/>  context: context,<br/>  builder: (_) =&gt; /* ??? */,<br/>  barrierDismissible: true,<br/>);</span></pre><p id="de14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但这实际上有一个起点，当你运行代码显示对话框时，它有一个终点，当你关闭对话框时。那么为什么不把它作为未来来实现呢？这正是Flutter所做的。因为它是作为未来实现的，所以你可以像这样使用<code class="fe lu lv lw lx b">.then()</code>方法:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="3051" class="na lz it lx b gy nb nc l nd ne">showDialog(<br/>  context: context,<br/>  builder: (_) =&gt; /* ??? */,<br/>  barrierDismissible: true,<br/>).then((_) {<br/>  setState(() {<br/>    loading = false;<br/>  });<br/>});</span></pre><p id="a467" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这告诉Flutter，一旦对话框关闭，就应该调用<code class="fe lu lv lw lx b">setState()</code>，重建小部件并允许任何加载的动画更新。</p><p id="719d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我一直用这个。另一种使用方法是在可能还没有初始化的对象上调用方法。</p><p id="2941" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，我有以下代码:</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="2197" class="na lz it lx b gy nb nc l nd ne">gamesServicesSignIn?.then((_) {<br/>  GamesServices.unlock(…)<br/>    .onError((Object error, StackTrace stack) {<br/>      crashlyticsRecordError(“Encountered errors in GameState 292: $error”, stack);<br/>  });<br/>});</span></pre><p id="0b52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这只会在<code class="fe lu lv lw lx b">GamesService</code>已经初始化时解锁成就，而不必手动等待未来，你可能不想这样做，以防它抛出一堆错误。</p><p id="4002" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然<code class="fe lu lv lw lx b">.then()</code>有点像<code class="fe lu lv lw lx b">await</code>所以你必须这样做来适当地抑制错误。</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="aaf7" class="na lz it lx b gy nb nc l nd ne">gamesServicesSignIn = GamesServices.signIn().onError((_, __) {<br/>  gamesServicesSignIn = null;<br/>});</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h1 id="effc" class="ly lz it bd ma mb on md me mf oo mh mi jz op ka mk kc oq kd mm kf or kg mo mp bi translated">最后的想法</h1><p id="38ce" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">所以异步并不完美。我主要担心的是仍然太容易忘记在它上面调用<code class="fe lu lv lw lx b">await</code>。</p><p id="3338" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就像在Unity中，如果你想启动一个协程，你必须进入<code class="fe lu lv lw lx b">StartCoroutine(Foo())</code>。我的意思是，技术上你仍然可以去<code class="fe lu lv lw lx b">Foo()</code>，但是IDE会提前指出来。</p><p id="20e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Flutter不会这样做。可能是因为它不能告诉你是真的想输入<code class="fe lu lv lw lx b">Foo()</code>还是真的想输入<code class="fe lu lv lw lx b">await Foo()</code>。这是我在Dart中真正喜欢的东西。类似于<code class="fe lu lv lw lx b">runFuture(Foo())</code>和<code class="fe lu lv lw lx b">awaitFuture(Foo())</code>的东西。它有点笨重，但更冗长。</p><p id="10c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除此之外，我在异步方面没有任何问题。我仍然不明白为什么它们是必要的，但是我猜它们会告诉程序员，“嘿，看，这段代码可能需要一段时间才能运行。”并允许他们运行代码，而无需显式等待。</p><p id="1ed8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以它们是一个强大的工具。我的意思是，我仍然更喜欢多线程，但我不得不承认，异步代码非常有用。</p></div></div>    
</body>
</html>