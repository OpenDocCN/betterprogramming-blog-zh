<html>
<head>
<title>Using Xcode’s Memory Graph to Find Memory Leaks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Xcode的内存图查找内存泄漏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-xcodes-memory-graph-to-find-memory-leaks-f6650cf69ade?source=collection_archive---------19-----------------------#2019-12-09">https://betterprogramming.pub/using-xcodes-memory-graph-to-find-memory-leaks-f6650cf69ade?source=collection_archive---------19-----------------------#2019-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="866e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">查找和打破保留周期</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e02dc2f6c5808ae9914120f65ef4deb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r7OEAPMimxllDtFXwgMqEg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@invictar1997?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Soragrit Wongsa </a>在<a class="ae ky" href="https://unsplash.com/s/photos/memory?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c5f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码运行不理想有很多原因。在一篇文章中，我向您展示了如何使用<a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2016/418/" rel="noopener ugc nofollow" target="_blank">时间分析器</a>来测量代码中每个方法花费的时间，以及如何分析结果。</p><p id="bdc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然使用这些工具可以发现、分析和修复许多与性能相关的问题，但是内存使用情况通常必须进行稍微不同的调试。尤其是和内存泄漏有关的时候。</p><p id="32be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天的帖子中，我将向您展示如何使用Xcode中的内存图工具来分析为您的应用程序保留在内存中的对象，以及如何使用该工具来发现内存泄漏。今天，我将特别关注保留周期。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2cf0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">激活内存图</h1><p id="62e8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当您使用Xcode运行应用程序时，您可以点按位于您的代码和控制台之间的内存调试器图标，或者如果您没有打开控制台，可以点按Xcode窗口底部的图标:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/5975bd7fec74270b9891426dc09f563c.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*bbE57UK3tRjmSGNKIKa_bA.png"/></div></figure><p id="e6f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您点按此图标时，Xcode会对您的应用程序的内存图以及每个对象与其他对象的关系进行快照。</p><p id="c879" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的应用程序的执行将被暂停，Xcode将向您显示当前在内存中的所有对象。请注意，这可能需要一点时间，具体取决于您的应用程序有多大。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/3ce5724dae0d1b195197800045d77e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AFtIdaB4SOTNeYhZZH7FnA.jpeg"/></div></div></figure><p id="9075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在左侧的边栏中，Xcode显示了它发现的所有对象的完整列表。</p><p id="6f99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您在侧边栏中选择一个对象时，中间部分将显示您选择的对象，以及它与其他对象的关系。有时候，是大图，就像截图里那样。其他时候，它是一个只有几个对象的小图。</p><p id="1e88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果Xcode发现它怀疑是内存泄漏或保留循环的关系，它会在边栏中的对象后面添加一个带问号的紫色正方形。</p><p id="a283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在你刚刚看到的截图中，紫色方块在哪里是相当明显的。如果它们更隐蔽，或者您只想过滤内存泄漏，您可以使用侧边栏底部的filter菜单，如下面的屏幕截图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/839918241acdac37dbe4caaf5a1e401b.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*gkLn0IKOBItIUC6v0Vvj0A.png"/></div></figure><p id="2399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的截图显示，两个不同对象的实例被保存在内存中，而Xcode认为它们不应该被保存。当您单击其中一个时，问题会立即显现出来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/92a82a0be7abd1f210451cec72d3b3c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bf2Cxa15FGwyecpSHmgxtw.png"/></div></div></figure><p id="15e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本例中的<code class="fe nd ne nf ng b">DataProvider</code>和<code class="fe nd ne nf ng b">DetailPage</code>相互指向对方。保留周期的经典例子。让我们看看这是如何发生的，以及您可以做些什么来修复它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1784" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">了解保留周期是如何发生的以及如何修复它们</h1><p id="c9ea" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在iOS中，当没有其他对象保持对对象的强引用时，对象将从内存中删除。您在应用程序中创建的每个对象实例都有一个保留计数。</p><p id="16f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当您将对对象的引用传递到代码中的不同位置时，它的保留计数都会增加，因为现在又有一个对象指向该对象在内存中的位置。</p><p id="b846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个保留计数的原则主要适用于类。因为，当你在代码中传递一个类的实例时，你实际上是在传递一个内存引用，这意味着多个对象指向同一个内存地址。</p><p id="265e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你传递值类型时，值在传递时被复制。这意味着值类型的保留计数通常总是1；永远不会有一个以上的对象指向值类型的内存地址。</p><p id="e38e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了从内存中移除一个对象，它的引用计数必须为零；内存中不应有任何对象引用该地址。</p><p id="f374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当两个对象相互引用时，这是使用代理时经常出现的情况，有可能这两个对象的引用计数从未达到过零，因为它们相互引用。</p><p id="2b66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我在本节开始时提到了一个<code class="fe nd ne nf ng b">strong</code>参考。我是故意这样做的，如果我们有一个强引用，肯定有一个像<code class="fe nd ne nf ng b">weak</code>引用这样的东西，对吗？有！</p><p id="5ad9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">弱引用是对引用类型的实例的引用，这些引用不会增加引用所指向的对象的引用计数。这里应用的原则与在闭包中使用<a class="ae ky" href="https://www.donnywals.com/when-to-use-weak-self-and-why/" rel="noopener ugc nofollow" target="_blank">弱自</a>完全相同。</p><p id="0092" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使委托成为一个对象的属性<code class="fe nd ne nf ng b">weak</code>，委托和它的拥有者不再互相存活，两个对象都可以被解除分配。在我们看到的示例中，这意味着我们需要更改以下代码:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="5e2e" class="nl md it ng b gy nm nn l no np">class DataProvider { <br/>  var delegate: DataDelegate? <br/>  // rest of the code <br/>}</span></pre><p id="8ace" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变成以下内容:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="48d5" class="nl md it ng b gy nm nn l no np">class DataProvider { <br/>  weak var delegate: DataDelegate? <br/>  // rest of the code <br/>}</span></pre><p id="79a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要做到这一点，<code class="fe nd ne nf ng b">DataDelegate</code>必须被约束为一个类，您可以通过将<code class="fe nd ne nf ng b">: AnyObject</code>添加到您的协议声明中来做到这一点。例如:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="96b5" class="nl md it ng b gy nm nn l no np">protocol DataDelegate: AnyObject { <br/>  // requirements <br/>}</span></pre><p id="612e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您再次运行应用程序并使用内存图来查找保留周期时，您会注意到不再有紫色方块，内存图看起来与您预期的完全一样。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4030" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">概括起来</h1><p id="5306" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我向您展示了您可以使用Xcode来可视化和探索您的应用程序的内存图。这有助于您找到内存泄漏并保留周期。</p><p id="3c99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当单击内存中的一个对象时，您可以探索它与其他对象的关系，最终您可以跟踪保留周期。您还了解了什么是保留周期，它们是如何发生的，以及如何打破它们。</p></div></div>    
</body>
</html>