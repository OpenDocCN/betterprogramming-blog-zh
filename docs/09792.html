<html>
<head>
<title>Core Data and Async Await — Thread Safe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">核心数据和异步等待—线程安全</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/core-data-and-async-await-thread-safe-f96b6dbbb7c4?source=collection_archive---------4-----------------------#2021-10-12">https://betterprogramming.pub/core-data-and-async-await-thread-safe-f96b6dbbb7c4?source=collection_archive---------4-----------------------#2021-10-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0875" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用核心数据，使用异步/等待线程安全</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c8b1ae20e76afddd63fbbc2eecc8fd88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dtBjY56wnUoigjL-MS4aUw.jpeg"/></div></div></figure><p id="a021" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">随着Async/Await的引入，iOS开发人员使用后台队列工作变得更加容易。在后台获取数据可以极大地提高应用程序的性能。</p><p id="4d46" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在后台执行所有核心数据获取是一个好主意，这样可以让主线程空闲下来执行UI任务。一个类似下面的<code class="fe ln lo lp lq b">async</code> <em class="lr"> </em> <code class="fe ln lo lp lq b">get</code> <em class="lr"> </em>函数将是理想的:</p><pre class="kg kh ki kj gt ls lq lt lu aw lv bi"><span id="acae" class="lw lx iq lq b gy ly lz l ma mb">func get(request: NSFetchRequest&lt;NSManagedObject&gt;) async -&gt; [NSManagedObject]</span></pre><p id="687a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">GCD将为我们做所有的工作，并在后台线程中获取数据。不幸的是，核心数据不是线程安全的。</p><p id="77ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我不想说核心数据不好，事实恰恰相反。核心数据速度极快，维护良好，从iOS 3.0开始就一直伴随着我们。</p><p id="7c69" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">问题是CoreData需要小心处理，尤其是现在使用并发变得更加容易。</p><p id="7994" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了确保我们在<code class="fe ln lo lp lq b">NSManagedObject</code>上进行的每个访问都是线程安全的，我们需要在对象的<code class="fe ln lo lp lq b">NSManagedObjectContext</code>中进行。建议的方法是使用上下文的<code class="fe ln lo lp lq b"><a class="ae mc" href="https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/1506578-perform" rel="noopener ugc nofollow" target="_blank">perform</a></code>方法。</p><pre class="kg kh ki kj gt ls lq lt lu aw lv bi"><span id="3b32" class="lw lx iq lq b gy ly lz l ma mb">func perform(_ block: @escaping () -&gt; <a class="ae mc" href="https://developer.apple.com/documentation/swift/void" rel="noopener ugc nofollow" target="_blank">Void</a>)</span></pre><p id="d84b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每次在不同于其上下文线程的线程中访问<code class="fe ln lo lp lq b">NSManagedObject</code>时，都可能导致崩溃。要检查这种情况，只需添加以下启动参数。</p><pre class="kg kh ki kj gt ls lq lt lu aw lv bi"><span id="6a24" class="lw lx iq lq b gy ly lz l ma mb">-com.apple.CoreData.ConcurrencyDebug 1</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi md"><img src="../Images/ba0fc3ae55811906f611ab00aa0b5412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zXlqj6EiWa75DZSJaTwNOg.png"/></div></div></figure><p id="dfaf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在<a class="me mf ep" href="https://medium.com/u/ce30a039c112?source=post_page-----f96b6dbbb7c4--------------------------------" rel="noopener" target="_blank"> UXMA德国</a>如何避免这样的问题？我们使用NSManagedObjects只是为了存储和检索数据，而不是在代码中的其他地方。一旦执行了<code class="fe ln lo lp lq b">FetchRequest</code>，我们就将核心数据实体转换成一个不可变的、线程安全的对象。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="e754" class="mn lx iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">例子</h1><p id="99ad" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">我们有一个名为<code class="fe ln lo lp lq b">Item</code>的<code class="fe ln lo lp lq b">NSManagedObject</code>，与<code class="fe ln lo lp lq b">Item</code> <em class="lr"> </em>一起，我们定义了一个不可变的对象——在本例中，是一个具有相同结构的线程安全结构——名为<code class="fe ln lo lp lq b">SItem</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="095f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们定义协议<code class="fe ln lo lp lq b"><em class="lr">ToSafeObject</em></code> <em class="lr">。</em>项目<em class="lr">符合这个协议，我们使用它的<code class="fe ln lo lp lq b">safeObject()</code>方法将不安全的<code class="fe ln lo lp lq b">Item</code>对象转换成安全的<code class="fe ln lo lp lq b">SItem</code>结构。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="dd77" class="mn lx iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">获取数据</h1><p id="0bd3" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">在<code class="fe ln lo lp lq b">NSManagedObjectContext</code>类上的一个简单的扩展函数，它接受一个<code class="fe ln lo lp lq b">NSFetchRequest&lt;E&gt;</code>，其中E是一个符合<code class="fe ln lo lp lq b">ToSafeObject</code>协议的<code class="fe ln lo lp lq b">NSManagedObject</code>。这个get函数是异步的，为给定的<code class="fe ln lo lp lq b">NSFetchRequest</code>的<code class="fe ln lo lp lq b">NSManagedObject</code>返回一个<code class="fe ln lo lp lq b">SafeObjects</code>数组。</p><p id="4e0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用这种技术，我们总是线程安全的，我们实际上可以使用后台上下文来检索后台线程中的所有核心数据实体。</p><p id="8b86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">新的get函数是异步的，所以我们需要使用await来测试它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="00ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果在这个单元测试中，我们添加了<code class="fe ln lo lp lq b">-com.apple.CoreData.ConcurrencyDebug 1</code> <em class="lr"> </em> launch参数并注释掉第26行，我们会注意到应用程序崩溃了。正是因为我们在错误的线程上获取数据。</p><p id="82a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样的小技巧帮助我们，在UXMA，为我们的客户提供更高质量的应用，当然也减少了崩溃报告。</p><p id="f389" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一如既往，编码快乐！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/2cb6e5389563241d8addbfaea8af64e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eS5S8HPAerb39iUYBI8j5g.jpeg"/></div></div></figure><p id="e255" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="me mf ep" href="https://medium.com/u/c35708a6758c?source=post_page-----f96b6dbbb7c4--------------------------------" rel="noopener" target="_blank">阿波斯托洛斯·乔卡斯</a>，开发者<a class="me mf ep" href="https://medium.com/u/ce30a039c112?source=post_page-----f96b6dbbb7c4--------------------------------" rel="noopener" target="_blank"> UXMA德国</a></p><p id="b8cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">克里斯蒂安·K的荣誉</p></div></div>    
</body>
</html>