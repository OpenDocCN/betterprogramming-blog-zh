<html>
<head>
<title>Using JavaScript Sets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript集</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-javascript-sets-12b526edf729?source=collection_archive---------11-----------------------#2019-11-05">https://betterprogramming.pub/using-javascript-sets-12b526edf729?source=collection_archive---------11-----------------------#2019-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="947e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种有用的数据结构，用于模拟数学集合的属性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5beda802d6284ee0c9a75ea9eed776f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NPkbZB2PoBBDl6z7"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">萨姆·麦克格在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9b11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，<code class="fe lv lw lx ly b">Set</code>对象是保存值集合的对象。它们可以按照插入的顺序进行迭代。<code class="fe lv lw lx ly b">Set</code>中的每个值只能出现一次。这意味着JavaScript中的<code class="fe lv lw lx ly b">Set</code>与数学中的集合是一致的。</p><p id="b90f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe lv lw lx ly b">Set</code>中的每个值必须是唯一的，所以将检查它们的值是否相等。这是通过使用三等运算符进行比较来实现的；意思是-0和+0是不同的值。</p><p id="c498" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<code class="fe lv lw lx ly b">NaN</code>被认为是等同于自身的，尽管在JavaScript的其他部分并不是这样。<code class="fe lv lw lx ly b">undefined</code>也可以存储在<code class="fe lv lw lx ly b">Set</code> s中。</p><p id="c935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个<code class="fe lv lw lx ly b">Set</code>都可以用一个构造函数来创建，并有<code class="fe lv lw lx ly b">size</code>属性来获取每个<code class="fe lv lw lx ly b">Set</code>中的项目数。<code class="fe lv lw lx ly b">Set</code>可以通过多种方法操作。</p><p id="de58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中包括:</p><ul class=""><li id="9522" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">add</code>:向<code class="fe lv lw lx ly b">Set</code>添加新元素，并返回插入新元素的<code class="fe lv lw lx ly b">Set</code>。</li><li id="96bb" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">clear</code>:从<code class="fe lv lw lx ly b">Set</code>中删除所有元素。</li><li id="caab" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">delete(value)</code>:从<code class="fe lv lw lx ly b">Set</code>中删除给定的<code class="fe lv lw lx ly b">value</code>，并返回<code class="fe lv lw lx ly b">has</code>函数本应返回的<code class="fe lv lw lx ly b">value</code>。</li><li id="10ba" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">entries()</code>:返回一个新的迭代器，包含<code class="fe lv lw lx ly b">Set</code>对象中每一项的<code class="fe lv lw lx ly b">value</code>，按照插入顺序排序。每个条目都有一个带有<code class="fe lv lw lx ly b">key</code>和<code class="fe lv lw lx ly b">value</code>的<code class="fe lv lw lx ly b">array</code>。<code class="fe lv lw lx ly b">key</code>将被设置为<code class="fe lv lw lx ly b">Set</code>条目的<code class="fe lv lw lx ly b">value</code>。</li><li id="851b" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">forEach(callbackFn, thisArg)</code>:允许遍历<code class="fe lv lw lx ly b">Set</code>的条目，并处理传入的回调函数中的数据。通过为参数<code class="fe lv lw lx ly b">thisArg</code>传入一个变量，回调中<code class="fe lv lw lx ly b">this</code>的值。</li><li id="f823" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">keys()</code>:获取一个新的迭代器对象中<code class="fe lv lw lx ly b">Set</code>的<code class="fe lv lw lx ly b">keys</code>，这个迭代器对象拥有每个元素的<code class="fe lv lw lx ly b">value</code>。</li><li id="b346" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">values()</code>:获取每个<code class="fe lv lw lx ly b">Set</code>的插入顺序的<code class="fe lv lw lx ly b">values</code>。</li><li id="bb3c" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Set.prototype[Symbol.iterator]</code>:返回一个新的迭代器对象，该对象按照插入顺序拥有<code class="fe lv lw lx ly b">Set</code>中每个元素的<code class="fe lv lw lx ly b">value</code>。</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="85aa" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">定义和操作集合</h1><p id="ef87" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">为了定义一个<code class="fe lv lw lx ly b">Set</code>对象，我们编写:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="e08c" class="nv mv it ly b gy nw nx l ny nz">let set = new Set();<br/>set.add(1); <br/>set.add(5);<br/>set.add(5);</span></pre><p id="5cf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在对<code class="fe lv lw lx ly b">add</code>函数的三次调用之后，当我们记录<code class="fe lv lw lx ly b">Set</code>变量的值时，我们应该得到<code class="fe lv lw lx ly b">[1,5]</code>，因为在一个<code class="fe lv lw lx ly b">Set</code>对象中我们不能有重复的。</p><p id="29bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只适用于基本类型。因此，如果我们插入两个具有相同内容的对象，两者都将在<code class="fe lv lw lx ly b">Set.</code>中，只有在将项目插入到<code class="fe lv lw lx ly b">Set</code>中时才检查引用，与三重等于检查一致。</p><p id="bea8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们写:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="9e95" class="nv mv it ly b gy nw nx l ny nz">let set = new Set();for (let i = 0; i &lt; 5; i++){<br/>  set.add({a: 1, b: 2});<br/>}</span></pre><p id="8244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将在<code class="fe lv lw lx ly b">Set</code>中得到<code class="fe lv lw lx ly b">{a: 1, b: 2}</code>五次，因为每个对象在内存中没有相同的引用。</p><p id="9535" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用<code class="fe lv lw lx ly b">has</code>函数检查一个元素是否存在于<code class="fe lv lw lx ly b">Set</code>中。例如，如果我们有:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="5062" class="nv mv it ly b gy nw nx l ny nz">let set = new Set();<br/>set.add(1); <br/>set.add(2);<br/>set.add(3);<br/>set.add(4);<br/>set.add(5);<br/>set.add(6);<br/>set.add(7);<br/>set.add(8);</span></pre><p id="1f03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么如果我们调用<code class="fe lv lw lx ly b">has</code>函数:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="898c" class="nv mv it ly b gy nw nx l ny nz">set.has(1)</span></pre><p id="1dbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它会返回<code class="fe lv lw lx ly b">true</code>。如果我们打电话:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="bfb1" class="nv mv it ly b gy nw nx l ny nz">set.has(10)</span></pre><p id="3e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后它将返回<code class="fe lv lw lx ly b">false</code>，因为这个元素在<code class="fe lv lw lx ly b">Set</code>中不存在。我们也可以将表达式放入一个<code class="fe lv lw lx ly b">Set</code>函数中。如果我们像下面的代码那样调用<code class="fe lv lw lx ly b">has</code>:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="f8dd" class="nv mv it ly b gy nw nx l ny nz">set.has(Math.sqrt(25));</span></pre><p id="9c85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们仍然得到<code class="fe lv lw lx ly b">true</code>，因为表达式是在传递给<code class="fe lv lw lx ly b">has</code>函数的参数之前计算的，所以它与<code class="fe lv lw lx ly b">set.has(5)</code>相同。</p><p id="9141" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要获得<code class="fe lv lw lx ly b">Set</code>的<code class="fe lv lw lx ly b">size</code>，我们可以使用<code class="fe lv lw lx ly b">size</code>属性，如下所示:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="c243" class="nv mv it ly b gy nw nx l ny nz">set.size</span></pre><p id="da45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是<code class="fe lv lw lx ly b">8</code>，因为<code class="fe lv lw lx ly b">Set</code>中有八个元素。</p><p id="bb84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要从<code class="fe lv lw lx ly b">Set</code>中删除一个项目，我们可以使用<code class="fe lv lw lx ly b">delete</code>函数，如下所示:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="c163" class="nv mv it ly b gy nw nx l ny nz">set.delete(8)</span></pre><p id="e682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后<code class="fe lv lw lx ly b">8</code>会从集合中移除。如果我们调用<code class="fe lv lw lx ly b">set.has(8)</code>，它将是<code class="fe lv lw lx ly b">false</code>，因为<code class="fe lv lw lx ly b">8</code>不再在<code class="fe lv lw lx ly b">Set</code>中。</p><p id="26af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了遍历一个<code class="fe lv lw lx ly b">set</code>的值，我们可以使用<code class="fe lv lw lx ly b">for...of</code>循环。在下面的示例中，我们将遍历条目:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="ec54" class="nv mv it ly b gy nw nx l ny nz">let set = new Set();<br/>set.add(1); <br/>set.add(2);<br/>set.add(3);<br/>set.add(4);<br/>set.add(5);<br/>set.add(6);<br/>set.add(7);<br/>set.add(8);for (let item of set){<br/>  console.log(item)<br/>}</span></pre><p id="8c3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的循环中，我们按照插入<code class="fe lv lw lx ly b">add</code>的顺序记录<code class="fe lv lw lx ly b">1</code>到<code class="fe lv lw lx ly b">8</code>。</p><p id="27ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了遍历<code class="fe lv lw lx ly b">Set</code>的<code class="fe lv lw lx ly b">keys</code>，我们可以使用<code class="fe lv lw lx ly b">keys()</code>方法从<code class="fe lv lw lx ly b">Set</code>对象中获取<code class="fe lv lw lx ly b">key</code> s。例如，我们可以编写以下代码:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="6bd2" class="nv mv it ly b gy nw nx l ny nz">let set = new Set();<br/>set.add(1); <br/>set.add(2);<br/>set.add(3);<br/>set.add(4);<br/>set.add(5);<br/>set.add(6);<br/>set.add(7);<br/>set.add(8);for (let key of set.keys()){<br/>  console.log(key)<br/>}</span></pre><p id="9eee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">Set</code>对象的情况下，<code class="fe lv lw lx ly b">key</code>将与值相同，因此当我们运行上面的代码时，我们仍然会在控制台中记录<code class="fe lv lw lx ly b">1</code>到<code class="fe lv lw lx ly b">8</code>。要循环遍历这些值，我们可以在<code class="fe lv lw lx ly b">Set</code>对象上调用<code class="fe lv lw lx ly b">values</code>方法，如以下代码所示:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="027d" class="nv mv it ly b gy nw nx l ny nz">let set = new Set();<br/>set.add(1); <br/>set.add(2);<br/>set.add(3);<br/>set.add(4);<br/>set.add(5);<br/>set.add(6);<br/>set.add(7);<br/>set.add(8);for (let value of set.values()){<br/>  console.log(value)<br/>}</span></pre><p id="2c99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，我们从<code class="fe lv lw lx ly b">keys</code>方法中获得了相同的值。这是因为对于<code class="fe lv lw lx ly b">Set</code> s，<code class="fe lv lw lx ly b">keys</code>和<code class="fe lv lw lx ly b">values</code>总是相同的。为了同时获得<code class="fe lv lw lx ly b">keys</code>和<code class="fe lv lw lx ly b">values</code>，我们可以使用<code class="fe lv lw lx ly b">entries</code>方法和析构赋值操作符将<code class="fe lv lw lx ly b">key</code>和<code class="fe lv lw lx ly b">value</code>分解到每个条目中它们自己的变量中，如下面的代码所示:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="417e" class="nv mv it ly b gy nw nx l ny nz">let set = new Set();<br/>set.add(1); <br/>set.add(2);<br/>set.add(3);<br/>set.add(4);<br/>set.add(5);<br/>set.add(6);<br/>set.add(7);<br/>set.add(8);for (let [key, value] of set.entries()){<br/>  console.log(key, value)<br/>}</span></pre><p id="ef54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到一个<code class="fe lv lw lx ly b">Set</code>的每个条目的<code class="fe lv lw lx ly b">key</code>和<code class="fe lv lw lx ly b">value</code>是相同的，正如我们所料。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="266c" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">将集合转换为数组</h1><p id="ead4" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">要将一个<code class="fe lv lw lx ly b">Set</code>转换成一个<code class="fe lv lw lx ly b">array</code>，我们可以使用<code class="fe lv lw lx ly b">Array.from</code>方法。我们将<code class="fe lv lw lx ly b">Set</code>作为<code class="fe lv lw lx ly b">from</code>方法的一个参数传入。例如，我们可以写:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="1fe9" class="nv mv it ly b gy nw nx l ny nz">let set = new Set();<br/>set.add(1); <br/>set.add(2);<br/>set.add(3);<br/>set.add(4);<br/>set.add(5);<br/>set.add(6);<br/>set.add(7);<br/>set.add(8);const arr = Array.from(set);<br/>console.log(arr)</span></pre><p id="5343" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过运行上面的代码，我们看到<code class="fe lv lw lx ly b">arr</code>是一个<code class="fe lv lw lx ly b">array</code>，其元素的顺序与<code class="fe lv lw lx ly b">Set</code>相同。这对于从<code class="fe lv lw lx ly b">array</code>中删除重复元素很方便。为了从一个<code class="fe lv lw lx ly b">array</code>中删除重复项，我们可以通过使用<code class="fe lv lw lx ly b">Set</code>的构造函数将其转换为一个<code class="fe lv lw lx ly b">Set</code>，然后用<code class="fe lv lw lx ly b">Array.from</code>将其转换回一个<code class="fe lv lw lx ly b">array</code>。我们可以这样写:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="04c3" class="nv mv it ly b gy nw nx l ny nz">let arr = [1,1,1,1,1,2,2,2,3,4,5,5,6,7,8];<br/>const set = new Set(arr);<br/>arr = Array.from(set);<br/>console.log(arr);</span></pre><p id="670c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在上面代码的最后一行使用<code class="fe lv lw lx ly b">log</code> <code class="fe lv lw lx ly b">arr</code>时，我们得到<code class="fe lv lw lx ly b">[1, 2, 3, 4, 5, 6, 7, 8]</code>。这是因为我们将<code class="fe lv lw lx ly b">arr</code>传递给了<code class="fe lv lw lx ly b">Set</code>的构造函数，它创建了<code class="fe lv lw lx ly b">Set</code>，在这里重复的值被自动删除。然后我们用<code class="fe lv lw lx ly b">set</code>作为参数调用<code class="fe lv lw lx ly b">Array.from</code>函数，所以我们把它转换回一个<code class="fe lv lw lx ly b">array</code>。<code class="fe lv lw lx ly b">Array.from</code>函数返回一个<code class="fe lv lw lx ly b">array</code>，所以我们可以将它赋回<code class="fe lv lw lx ly b">arr</code>并返回一个删除了重复项的<code class="fe lv lw lx ly b">array</code>。</p><p id="c8ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe lv lw lx ly b">Set</code>转换成<code class="fe lv lw lx ly b">array</code>的另一种方法是使用扩展运算符。例如，我们可以使用spread运算符重写上面的示例:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="1cdd" class="nv mv it ly b gy nw nx l ny nz">let arr = [1,1,1,1,1,2,2,2,3,4,5,5,6,7,8];<br/>const set = new Set(arr);<br/>arr = [...set];<br/>console.log(arr);</span></pre><p id="c34a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到完全相同的结果。这个函数稍微短一点，做的事情和<code class="fe lv lw lx ly b">Array.from</code>函数一样，因为扩展操作符会复制它正在扩展的对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/dd8a7069952c0313c863e158c7e567b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*spI0KFeUu4XlrZGe"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@crissyjarvis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯·贾维斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="7bff" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">对JavaScript集合进行数学集合运算</h1><p id="f463" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">因为我们可以在<code class="fe lv lw lx ly b">arrays</code>和<code class="fe lv lw lx ly b">Set</code> s之间转换，所以我们可以对它们应用<code class="fe lv lw lx ly b">array</code>操作。<code class="fe lv lw lx ly b">Set</code> s没有任何方法来做类似于与其他<code class="fe lv lw lx ly b">Set</code> s求交集、差集或并集的事情。然而，由于我们可以在<code class="fe lv lw lx ly b">array</code> s和<code class="fe lv lw lx ly b">Set</code> s之间转换，我们可以使用<code class="fe lv lw lx ly b">array</code>函数来做同样的事情。例如，如果我们想得到两个<code class="fe lv lw lx ly b">Set</code>之间的交集，我们可以写:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="595a" class="nv mv it ly b gy nw nx l ny nz">let set1 = new Set();<br/>set1.add(1); <br/>set1.add(2);<br/>set1.add(3);<br/>set1.add(4);let set2 = new Set();<br/>set2.add(1);<br/>set2.add(2);<br/>set2.add(7);<br/>set2.add(8);const intersectionBetweenSet1and2 = new Set([...set1].filter(item =&gt; set2.has(item)))console.log(intersectionBetweenSet1and2);</span></pre><p id="0215" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们记录<code class="fe lv lw lx ly b">intersectionBetweenSet1and2</code>时，我们在<code class="fe lv lw lx ly b">Set</code>中得到<code class="fe lv lw lx ly b">1</code>和<code class="fe lv lw lx ly b">2</code>，这是我们所期望的，因为<code class="fe lv lw lx ly b">1</code>和<code class="fe lv lw lx ly b">2</code>是两个<code class="fe lv lw lx ly b">Set</code>中仅有的元素。在<code class="fe lv lw lx ly b">Set</code>构造函数中，我们用spread操作符将<code class="fe lv lw lx ly b">set1</code>转换为<code class="fe lv lw lx ly b">array</code>，然后在其上调用<code class="fe lv lw lx ly b">filter</code>，以仅包含<code class="fe lv lw lx ly b">set1</code>中的项目，这些项目在<code class="fe lv lw lx ly b">set2</code>上调用<code class="fe lv lw lx ly b">has</code>方法后位于<code class="fe lv lw lx ly b">set2</code>中。</p><p id="16e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要得到两个<code class="fe lv lw lx ly b">Set</code>的集合并集，我们只需在两个集合上调用spread运算符，如下面的代码所示:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="1d61" class="nv mv it ly b gy nw nx l ny nz">let set1 = new Set();<br/>set1.add(1); <br/>set1.add(2);<br/>set1.add(3);<br/>set1.add(4);let set2 = new Set();<br/>set2.add(1);<br/>set2.add(2);<br/>set2.add(7);<br/>set2.add(8);const unionBetweenSet1and2 = new Set([...set1,...set2])console.log(unionBetweenSet1and2);</span></pre><p id="0d53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的代码时，我们应该看到<code class="fe lv lw lx ly b">unionBetweenSet1and2</code>的值是<code class="fe lv lw lx ly b">[1,2,3,4,7,8]</code>。因为我们将两个<code class="fe lv lw lx ly b">Set</code>都传递到了<code class="fe lv lw lx ly b">array</code>中，并用spread操作符将它们展开，所以我们用<code class="fe lv lw lx ly b">array</code>中的所有元素创建了一个<code class="fe lv lw lx ly b">array</code>。然后，集合构造函数消除了重复的元素，剩下两个<code class="fe lv lw lx ly b">set</code>中的元素，这是两个<code class="fe lv lw lx ly b">set</code>的并集。</p><p id="4358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想得到两个<code class="fe lv lw lx ly b">Set</code>之间的集合差，我们可以将一个<code class="fe lv lw lx ly b">Set</code>转换成一个<code class="fe lv lw lx ly b">array</code>，然后对其使用<code class="fe lv lw lx ly b">filter</code>函数来排除另一个<code class="fe lv lw lx ly b">Set</code>中的元素。例如，我们可以写:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="d005" class="nv mv it ly b gy nw nx l ny nz">let set1 = new Set();<br/>set1.add(1); <br/>set1.add(2);<br/>set1.add(3);<br/>set1.add(4);let set2 = new Set();<br/>set2.add(1);<br/>set2.add(2);<br/>set2.add(7);<br/>set2.add(8);const differenceBetweenSet1and2 = new Set([...set1].filter(item =&gt; !set2.has(item)))console.log(differenceBetweenSet1and2);</span></pre><p id="f41c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们记录<code class="fe lv lw lx ly b">differenceBetweenSet1and2</code>的值时，我们应该得到<code class="fe lv lw lx ly b">[3,4]</code>,因为我们用spread操作符将<code class="fe lv lw lx ly b">set1</code>转换成了<code class="fe lv lw lx ly b">array</code>,并在上面调用了<code class="fe lv lw lx ly b">filter</code>。在<code class="fe lv lw lx ly b">filter</code>的回调函数中，我们返回了<code class="fe lv lw lx ly b">!set2.has(item)</code>来排除<code class="fe lv lw lx ly b">set2</code>中也在<code class="fe lv lw lx ly b">set1</code>中的元素，所以我们只剩下了<code class="fe lv lw lx ly b">set1</code>中的元素。</p><p id="d735" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得两个<code class="fe lv lw lx ly b">Set</code>之间的对称差，即仅在一个<code class="fe lv lw lx ly b">Set</code>或另一个<code class="fe lv lw lx ly b">Set</code>中的元素集合，我们可以获得两个<code class="fe lv lw lx ly b">Set</code>之间的交集，然后排除交集中的元素。例如，我们可以这样写:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="4a84" class="nv mv it ly b gy nw nx l ny nz">let set1 = new Set();<br/>set1.add(1); <br/>set1.add(2);<br/>set1.add(3);<br/>set1.add(4);let set2 = new Set();<br/>set2.add(1);<br/>set2.add(2);<br/>set2.add(7);<br/>set2.add(8);const intersectionBetweenSet1and2 = new Set([...set1].filter(item =&gt; set2.has(item)))const symDiffBetweenSet1and2 = new Set([...set1,...set2].filter(item =&gt; !intersectionBetweenSet1and2.has(item)))console.log(symDiffBetweenSet1and2);</span></pre><p id="dd5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们获得了<code class="fe lv lw lx ly b">set1</code>和<code class="fe lv lw lx ly b">set2</code>之间的交集。一旦我们得到了<code class="fe lv lw lx ly b">intersectionBetweenSet1and2</code>，我们通过使用spread操作符将<code class="fe lv lw lx ly b">set1</code>和<code class="fe lv lw lx ly b">set2</code>中的所有内容放在同一个<code class="fe lv lw lx ly b">array</code>中，然后在那个数组上调用<code class="fe lv lw lx ly b">filter</code>并在回调函数中返回<code class="fe lv lw lx ly b">!intersectionBetweenSet1and2.has(item)</code>以排除交集中的元素。这就是我们想要从<code class="fe lv lw lx ly b">array</code>中消除的，以获得对称差。然后，我们用<code class="fe lv lw lx ly b">Set</code>构造函数将结果转换回<code class="fe lv lw lx ly b">Set</code>。最后，当我们记录<code class="fe lv lw lx ly b">symDiffBetweenSet1and2</code>时，我们应该得到<code class="fe lv lw lx ly b">[3,4,7,8]</code>，它们是只存在于某个<code class="fe lv lw lx ly b">Set</code>中的元素。</p><p id="d16e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了检查一个元素是否是另一个<code class="fe lv lw lx ly b">set</code>的<code class="fe lv lw lx ly b">Superset</code>，我们可以再次将它转换成一个<code class="fe lv lw lx ly b">array</code>并使用它来检查。例如，如果我们有:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="9746" class="nv mv it ly b gy nw nx l ny nz">let superSet = new Set();<br/>superSet.add(1); <br/>superSet.add(2);<br/>superSet.add(3);<br/>superSet.add(4);let set = new Set();<br/>set.add(1);<br/>set.add(2);const isSuperset = [...set].every(item =&gt; superSet.has(item));console.log(isSuperset);</span></pre><p id="1988" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们将<code class="fe lv lw lx ly b">set</code>转换为<code class="fe lv lw lx ly b">array</code>，然后用<code class="fe lv lw lx ly b">has</code>函数检查<code class="fe lv lw lx ly b">set</code>的每个元素是否都包含在<code class="fe lv lw lx ly b">Superset</code>中。<code class="fe lv lw lx ly b">every</code>方法是一个数组方法，它检查<code class="fe lv lw lx ly b">array</code>中的每个元素是否满足指定的条件。</p><p id="06d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以从字符串创建<code class="fe lv lw lx ly b">Set</code>对象。我们可以将一个字符串直接传递给<code class="fe lv lw lx ly b">Set</code>构造函数。结果将是一个<code class="fe lv lw lx ly b">Set</code>,其中删除了重复条目的字符串的单个字符。例如，如果我们有以下代码:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="fcc9" class="nv mv it ly b gy nw nx l ny nz">const letterSet = new Set('element');</span></pre><p id="da29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后当我们运行<code class="fe lv lw lx ly b">console.log(letterSet)</code>时，我们返回<code class="fe lv lw lx ly b">{“e”, “l”, “m”, “n”, “t”}</code>。请注意，如果有重复，稍后插入的与任何现有字符相同的字符将被忽略，因此较早插入的字符将保留。</p><p id="be9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript <code class="fe lv lw lx ly b">Sets</code>是一种有用的数据结构，它对数学集合的属性进行建模。<code class="fe lv lw lx ly b">Set</code>可以转换成<code class="fe lv lw lx ly b">array</code>的，所以我们可以把它们当作<code class="fe lv lw lx ly b">array</code>来操作，然后再把它们变回<code class="fe lv lw lx ly b">Set</code>的。这对于处理它们来说非常方便，因为<code class="fe lv lw lx ly b">Set</code>没有<code class="fe lv lw lx ly b">array</code>那么多的方法。</p></div></div>    
</body>
</html>