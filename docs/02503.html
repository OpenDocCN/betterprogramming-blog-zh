<html>
<head>
<title>How To Efficiently Load Images in UITableViews and UICollectionViews</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何有效地在UITableViews和UICollectionViews中加载图像</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-efficiently-load-images-in-uitableviews-and-uicollectionviews-a39afd608b1a?source=collection_archive---------11-----------------------#2019-12-04">https://betterprogramming.pub/how-to-efficiently-load-images-in-uitableviews-and-uicollectionviews-a39afd608b1a?source=collection_archive---------11-----------------------#2019-12-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7700" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实现一个您现在可以在项目中使用的方便的API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/16873df0d05f75a90793064479d2e7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kOR6NZ3BFoAeTfiSWJmvcQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">雅各布·欧文斯在<a class="ae ky" href="https://unsplash.com/s/photos/pictures?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7c23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您的应用程序在表格视图或集合视图中显示来自网络的图像时，您需要异步加载图像以确保您的列表平滑滚动。更重要的是，您需要以某种方式将您正在加载的图像连接到列表中的正确单元格(从现在开始，我将说<em class="lv">列表</em>而不是<em class="lv">表格视图</em>或<em class="lv">集合视图</em>)。如果单元格不在视图中，并被重新用于显示带有新图像的新数据，您需要取消正在进行的图像加载，以确保新图像被立即加载。此外，为了确保我们不会过于频繁地访问网络，我们需要某种方式将图像缓存在内存或磁盘上，这样，如果我们过去已经获取了图像，就可以使用图像的本地版本。</p><p id="11a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于此，我们可以确定在为我们的单元异步加载图像时需要解决的三个核心问题:</p><ol class=""><li id="7469" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">将加载的图像设置在正确的单元格上。</li><li id="a02a" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">重用单元时取消正在进行的加载。</li><li id="5f20" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">缓存加载的图像以避免不必要的网络调用。</li></ol><p id="266e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将向您展示如何构建一个简单的图像加载器类，并编写一个表格视图单元格来帮助我们解决所有这些问题。我还将向您展示如何使用相同的图像加载器，通过一些奇特的助手来增强<code class="fe mk ml mm mn b">UIImage</code>。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="1793" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">构建一个简单的图像加载器</h1><p id="16ac" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">当使用<code class="fe mk ml mm mn b">URLSession</code>发出GET请求时，通常会通过数据任务来完成。通常情况下，你不会保留那个数据任务，因为你不需要它。但是如果您保留了对数据任务的引用，您可以在以后取消它。</p><p id="0064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将在我们正在构建的图像加载器中使用<code class="fe mk ml mm mn b">[UUID: URLSessionDataTask]</code>的字典，因为这将允许我跟踪正在运行的下载，并在以后取消它们。我还将使用一个字典<code class="fe mk ml mm mn b">[URL: UIImage]</code>作为加载图像的简单内存缓存。</p><p id="1e35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于此，我们可以开始编写图像加载器了:</p><pre class="kj kk kl km gt ns mn nt nu aw nv bi"><span id="6b21" class="nw mw it mn b gy nx ny l nz oa">class ImageLoader { <br/>  private var loadedImages = [URL: UIImage]() <br/>  private var runningRequests = [UUID: URLSessionDataTask]() <br/>}</span></pre><p id="2043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以实现一个<code class="fe mk ml mm mn b">loadImage(_:completion:)</code>方法。这个方法将接受一个URL和一个完成处理程序，它将返回一个UUID，用于在以后唯一地标识每个数据任务。实现如下所示:</p><pre class="kj kk kl km gt ns mn nt nu aw nv bi"><span id="a341" class="nw mw it mn b gy nx ny l nz oa">func loadImage(_ url: URL, _ completion: @escaping (Result&lt;UIImage, Error&gt;) -&gt; Void) -&gt; UUID? { <br/>  // 1 <br/>  if let image = loadedImages[url] { <br/>    completion(.success(image)) <br/>    return nil <br/>  } </span><span id="94de" class="nw mw it mn b gy ob ny l nz oa">  // 2 <br/>  let uuid = UUID() </span><span id="924f" class="nw mw it mn b gy ob ny l nz oa">  let task = URLSession.shared.dataTask(with: url) { data, response, error in </span><span id="e140" class="nw mw it mn b gy ob ny l nz oa">    // 3 <br/>    defer {self.runningRequests.removeValue(forKey: uuid) } </span><span id="6853" class="nw mw it mn b gy ob ny l nz oa">    // 4 <br/>    if let data = data, let image = UIImage(data: data) { <br/>      self.loadedImages[url] = image <br/>      completion(.success(image)) <br/>      return <br/>    } </span><span id="50ab" class="nw mw it mn b gy ob ny l nz oa">    // 5 <br/>    guard let error = error else { <br/>      // without an image or an error, we'll just ignore this for now <br/>      // you could add your own special error cases for this scenario <br/>      return <br/>    } </span><span id="1743" class="nw mw it mn b gy ob ny l nz oa">    guard (error as NSError).code == NSURLErrorCancelled else { <br/>      completion(.failure(error)) <br/>      return <br/>    } </span><span id="2ed1" class="nw mw it mn b gy ob ny l nz oa">    // the request was cancelled, no need to call the callback <br/>  } </span><span id="6649" class="nw mw it mn b gy ob ny l nz oa">  task.resume() </span><span id="0f36" class="nw mw it mn b gy ob ny l nz oa">  // 6 <br/>  runningRequests[uuid] = task <br/>  return uuid <br/>}</span></pre><p id="862d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们按照编号的注释一步一步地检查前面的代码。</p><ol class=""><li id="d4c3" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">如果URL已经作为一个键存在于内存缓存中，我们可以立即调用完成处理程序。因为没有活动的任务，也没有要取消的任务，所以我们可以返回<code class="fe mk ml mm mn b">nil</code>而不是<code class="fe mk ml mm mn b">UUID</code>实例。</li><li id="1f71" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">我们创建一个<code class="fe mk ml mm mn b">UUID</code>实例，用于标识我们将要创建的数据任务。</li><li id="3466" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">当数据任务完成时，它应该从正在运行的请求字典中删除。在我们离开数据任务的完成处理程序的范围之前，我们在这里使用一个<code class="fe mk ml mm mn b">defer</code>语句来删除正在运行的任务。</li><li id="91c7" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">当数据任务完成时，我们可以从数据任务的结果中提取一个图像，它被缓存在内存缓存中，并使用加载的图像调用完成处理程序。在此之后，我们可以从数据任务的完成处理程序返回。</li><li id="8c74" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">如果我们收到一个错误，我们检查错误是否是由于任务被取消。如果错误不是取消任务，我们会将其转发给<code class="fe mk ml mm mn b">loadImage(_:completion:)</code>的调用者。</li><li id="46ea" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">使用在步骤2中创建的<code class="fe mk ml mm mn b">UUID</code>将数据任务存储在运行请求字典中。然后将这个<code class="fe mk ml mm mn b">UUID</code>返回给调用者。</li></ol><p id="9f7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意步骤3。通过5。所有这些都发生在数据任务的完成处理程序中。这意味着所列步骤的执行顺序不是线性的。第一步。第二。首先执行，然后执行步骤6。，然后是3。通过5。</p><p id="b84b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了加载图像的逻辑，让我们看看允许我们取消正在进行的图像下载的一些逻辑:</p><pre class="kj kk kl km gt ns mn nt nu aw nv bi"><span id="0219" class="nw mw it mn b gy nx ny l nz oa">func cancelLoad(_ uuid: UUID) { <br/>  runningRequests[uuid]?.cancel() <br/>  runningRequests.removeValue(forKey: uuid) <br/>}</span></pre><p id="d121" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法接收一个<code class="fe mk ml mm mn b">UUID</code>，用它来查找一个正在运行的数据任务，并取消该任务。如果任务存在，它还会从正在运行的任务字典中删除任务。相当简单，对吧？</p><p id="4944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何在表格视图的<code class="fe mk ml mm mn b">cellForRowAtIndexPath</code>方法中使用这个加载器:</p><pre class="kj kk kl km gt ns mn nt nu aw nv bi"><span id="673a" class="nw mw it mn b gy nx ny l nz oa">// 1 <br/>let token = loader.loadImage(imageUrl) { result in <br/>  do { <br/>    // 2 <br/>    let image = try result.get() </span><span id="8315" class="nw mw it mn b gy ob ny l nz oa">    // 3 <br/>    DispatchQueue.main.async { <br/>      cell.cellImageView.image = image <br/>    } <br/>  } catch { <br/>    // 4 <br/>    print(error) <br/>  } <br/>} </span><span id="c2ee" class="nw mw it mn b gy ob ny l nz oa">// 5 <br/>cell.onReuse = { <br/>  if let token = token { <br/>    self.loader.cancelLoad(token) <br/>  } <br/>}</span></pre><p id="e9dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一步一步地重复前面的代码:</p><ol class=""><li id="3182" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">调用图像加载器的<code class="fe mk ml mm mn b">loadImage(_:completion:)</code>方法，加载器返回的UUID存储在一个常量中。</li><li id="0c0c" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">在<code class="fe mk ml mm mn b">loadImage(_:completion:)</code>的完成处理程序中，我们从完成的结果参数中提取结果。</li><li id="8ac0" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">如果我们成功提取了一个图像，我们将分派到主队列，并在单元格的<code class="fe mk ml mm mn b">imageView</code>属性上设置提取的图像。不确定什么是主队列调度？在<a class="ae ky" href="https://www.donnywals.com/appropriately-using-dispatchqueue-main/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中阅读更多内容。</li><li id="3535" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">如果出错了，打印错误。你可能需要在你的应用中做些别的事情。</li><li id="2890" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">我很快会给你们看一个细胞子类的例子。重要的一点是，我们使用从<code class="fe mk ml mm mn b">loadImage(_:completion:)</code>收到的UUID来取消加载程序对该UUID的加载操作。</li></ol><p id="cac7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们在<code class="fe mk ml mm mn b">cellForRowAt</code>方法中这样做。这意味着每当我们被要求在列表中显示一个单元格时，这个方法就会被调用。因此，加载和取消与细胞的生命周期紧密相关，这正是我们在这种情况下想要的。让我们看看样本单元格中的<code class="fe mk ml mm mn b">onReuse</code>是什么:</p><pre class="kj kk kl km gt ns mn nt nu aw nv bi"><span id="b06f" class="nw mw it mn b gy nx ny l nz oa">class ImageCell: UITableViewCell {</span><span id="ee4a" class="nw mw it mn b gy ob ny l nz oa">  @IBOutlet var cellImageView: UIImageView! <br/>  var onReuse: () -&gt; Void = {} </span><span id="7125" class="nw mw it mn b gy ob ny l nz oa">  override func prepareForReuse() { <br/>    super.prepareForReuse() <br/>    onReuse() <br/>    cellImageView.image = nil <br/>  } <br/>}</span></pre><p id="eeff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当单元格的<code class="fe mk ml mm mn b">prepareForReuse</code>方法被调用时，<code class="fe mk ml mm mn b">onReuse</code>属性是一个闭包。我们还从<code class="fe mk ml mm mn b">prepareForReuse</code>的单元格中移除了当前图像，这样在加载新图像时就不会显示旧图像。单元格经常被重用，所以在<code class="fe mk ml mm mn b">prepareForReuse</code>中进行适当的清理对于防止单元格中的旧数据在您不希望的时候出现是至关重要的。</p><p id="2f96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在你的应用程序中实现了所有这些，你就有了一个不错的加载图片的策略。您可能希望添加一个监听器来监听应用程序通知中心发出的内存警告，也可能希望将图像缓存到磁盘和内存中，但我认为这不太适合本文的讨论范围。但是，如果您想实现自己的图像加载器，请记住这两个特性。监听内存警告尤其重要，因为如果你的应用程序在内存缓存中存储图像，消耗了太多内存，它可能会被操作系统杀死。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="808c" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">增强UIImageView以创建漂亮的图像加载API</h1><p id="238a" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在我们实现花哨的助手之前，让我们重构我们的单元和<code class="fe mk ml mm mn b">cellForRowAt</code>方法，这样它们已经包含了我们想要编写的代码。<code class="fe mk ml mm mn b">prepareForReuse</code>方法将如下所示:</p><pre class="kj kk kl km gt ns mn nt nu aw nv bi"><span id="eaa5" class="nw mw it mn b gy nx ny l nz oa">override func prepareForReuse() {<br/>  cellImageView.image = nil <br/>  cellImageView.cancelImageLoad() <br/>}</span></pre><p id="277f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会将当前图像设置为<code class="fe mk ml mm mn b">nil</code>，并告诉图像视图停止加载它正在加载的图像。<code class="fe mk ml mm mn b">cellForRowAt</code>中的所有图像加载代码应替换为以下内容:</p><pre class="kj kk kl km gt ns mn nt nu aw nv bi"><span id="fa31" class="nw mw it mn b gy nx ny l nz oa">cell.cellImageView.loadImage(at: imageUrl)</span></pre><p id="7c70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，我们以前所有的代码现在都是一行。</p><p id="eddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让这种新的加载和取消方式发挥作用，我们将实现一个名为<code class="fe mk ml mm mn b">UIImageLoader</code>的特殊图像加载器类。它将是一个单一对象，管理应用程序中所有<code class="fe mk ml mm mn b">UIImageView</code>实例的加载，这意味着您最终将为整个应用程序使用一个缓存。通常你可能不希望这样，但在这种情况下，我认为这是有意义的。以下代码概述了<code class="fe mk ml mm mn b">UIImageLoader</code>的框架:</p><pre class="kj kk kl km gt ns mn nt nu aw nv bi"><span id="b02d" class="nw mw it mn b gy nx ny l nz oa">class UIImageLoader { <br/>  static let loader = UIImageLoader() <br/>  private let imageLoader = ImageLoader()  <br/>  private var uuidMap = [UIImageView: UUID]() </span><span id="89d0" class="nw mw it mn b gy ob ny l nz oa">  private init() {} </span><span id="5f97" class="nw mw it mn b gy ob ny l nz oa">  func load(_ url: URL, for imageView: UIImageView) { </span><span id="226a" class="nw mw it mn b gy ob ny l nz oa">  } <br/>  <br/>  func cancel(for imageView: UIImageView) { </span><span id="dd93" class="nw mw it mn b gy ob ny l nz oa">  } <br/>}</span></pre><p id="7ccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">加载器本身是一个静态实例，它使用前一节中的<code class="fe mk ml mm mn b">ImageLoader</code>来实际加载图像并缓存它们。我们还有一个<code class="fe mk ml mm mn b">[UIImageView: UUID]</code>字典来跟踪当前活动的图像加载任务。我们基于<code class="fe mk ml mm mn b">UIImageView</code>映射这些，这样我们可以将单个任务标识符连接到<code class="fe mk ml mm mn b">UIImageView</code>实例。</p><p id="75c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mk ml mm mn b">load(_:for:)</code>方法的实现如下所示:</p><pre class="kj kk kl km gt ns mn nt nu aw nv bi"><span id="3fc4" class="nw mw it mn b gy nx ny l nz oa">func load(_ url: URL, for imageView: UIImageView) { <br/>  // 1 <br/>  let token = imageLoader.loadImage(url) { result in <br/>    // 2 <br/>    defer { self.uuidMap.removeValue(forKey: imageView) } <br/>    <br/>    do { <br/>      // 3 <br/>      let image = try result.get() <br/>      DispatchQueue.main.async { <br/>        imageView.image = image <br/>      } <br/>    } catch { <br/>      // handle the error <br/>    } <br/>  } <br/>  <br/>  // 4 <br/>  if let token = token { <br/>    uuidMap[imageView] = token <br/>  } <br/>}</span></pre><p id="da84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该代码逐步执行以下操作:</p><ol class=""><li id="84e2" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">我们使用传递的URL启动图像加载<code class="fe mk ml mm mn b">load(_:for:)</code>。</li><li id="9ea1" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">当加载完成时，我们需要通过移除从字典中加载图像的<code class="fe mk ml mm mn b">UIImageView</code>来清理<code class="fe mk ml mm mn b">uuidMap</code>。</li><li id="1979" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">这个和之前在<code class="fe mk ml mm mn b">cellForRowAt</code>里做的差不多。图像从结果中提取出来，并设置在图像视图本身上。</li><li id="d569" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">最后，如果我们从图像加载器接收到一个令牌，我们将它保存在<code class="fe mk ml mm mn b">[UIImageView: UUID]</code>字典中，这样我们可以在以后需要取消加载时引用它。</li></ol><p id="a6bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mk ml mm mn b">cancel(for:)</code>方法有以下实现:</p><pre class="kj kk kl km gt ns mn nt nu aw nv bi"><span id="c8fd" class="nw mw it mn b gy nx ny l nz oa">func cancel(for imageView: UIImageView) { <br/>  if let uuid = uuidMap[imageView] { <br/>    imageLoader.cancelLoad(uuid) <br/>    uuidMap.removeValue(forKey: imageView) <br/>  } <br/>}</span></pre><p id="004a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们对传递的图像视图有一个活动的下载，它将被取消并从<code class="fe mk ml mm mn b">uuidMap</code>中删除。和你之前看到的非常相似。</p><p id="c1e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在需要做的就是为<code class="fe mk ml mm mn b">UIImageView</code>添加一个扩展，以添加您之前看到的<code class="fe mk ml mm mn b">loadImage(at:)</code>和<code class="fe mk ml mm mn b">cancelImageLoad()</code>方法:</p><pre class="kj kk kl km gt ns mn nt nu aw nv bi"><span id="a842" class="nw mw it mn b gy nx ny l nz oa">extension UIImageView { <br/>  func loadImage(at url: URL) { <br/>    UIImageLoader.loader.load(url, for: self) <br/>  } </span><span id="abbc" class="nw mw it mn b gy ob ny l nz oa">  func cancelImageLoad() { <br/>    UIImageLoader.loader.cancel(for: self) <br/>  } <br/>}</span></pre><p id="79c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两种方法都将<code class="fe mk ml mm mn b">self</code>传递给图像加载器。由于扩展方法被添加到了<code class="fe mk ml mm mn b">UIImageView</code>的实例中，这有助于图像加载器将它加载的URL连接到我们想要显示图像的<code class="fe mk ml mm mn b">UIImageView</code>实例，从而为我们留下了一个非常简单易用的API！很酷的东西，对吧？</p><p id="b627" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的是，这种新策略还可以用于不在表格视图单元格或集合视图单元格中的图像。它可以用于你的应用程序中的任何图像视图！</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="3b13" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">概括起来</h1><p id="1cc3" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">异步加载数据本身就是一个棘手的问题。当与表格视图(和集合视图)单元格转瞬即逝的特性相结合时，您会遇到一系列全新的问题。在这篇文章中，您看到了如何使用<code class="fe mk ml mm mn b">URLSession</code>和一个非常简单的内存缓存实现一个智能机制来启动、完成和取消图像下载。</p><p id="414d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在创建了一个简单的机制之后，您看到了如何创建一个额外的loader对象和一些对<code class="fe mk ml mm mn b">UIImageView</code>的扩展来创建一个非常简单易用的API，将图像从URL直接加载到您的图像视图中。</p><p id="e434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，我在这里向您展示的实现还不能用于生产。您需要在内存管理方面做一些工作，并可能添加一个磁盘缓存来使这些对象为黄金时间做好准备。</p></div></div>    
</body>
</html>