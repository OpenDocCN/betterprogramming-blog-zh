<html>
<head>
<title>Write More Robust JavaScript: 7 Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更健壮的JavaScript: 7个最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/write-more-robust-javascript-7-best-practices-8346ed5ab5c7?source=collection_archive---------8-----------------------#2020-01-16">https://betterprogramming.pub/write-more-robust-javascript-7-best-practices-8346ed5ab5c7?source=collection_archive---------8-----------------------#2020-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7487" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">希望编写不太可能崩溃的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6ed13d1f5581d22a9b7140a3ee71a611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*16ERzhMs-korDd1o2RbHxQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">法尔扎德·纳兹菲在Unsplash上的照片</em></p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="36af" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">更健壮的JavaScript的最佳实践</h1><h2 id="792b" class="ly lh it bd li lz ma dn lm mb mc dp lq md me mf ls mg mh mi lu mj mk ml lw mm bi translated">1.使用工厂功能</h2><p id="520a" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv md mw mx my mg mz na nb mj nc nd ne nf im bi translated">如果你不知道工厂函数是什么，它只是一个返回对象的函数(不是类或构造函数)。这个简单的概念允许我们利用JavaScript及其特性来创建强大的健壮应用程序。</p><p id="a534" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">重要的是要知道，当用关键字<code class="fe nl nm nn no b">new</code>调用它们时，它们不再是工厂函数。</p><p id="62b7" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated"><strong class="mp iu">为什么是工厂职能？</strong></p><p id="5435" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">工厂函数可以用来轻松地生成对象的实例，而与类或<code class="fe nl nm nn no b">new</code>关键字没有任何关系。</p><p id="f645" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">它本质上的意思是，它们最终被当作仅仅是函数，这意味着它们可以用来组成对象、函数，甚至是承诺。这意味着您可以混合和匹配工厂函数来创建一个增强的工厂函数，然后继续与其他函数或对象组合来创建进一步增强的工厂函数。可能性是无限的。</p><p id="bf2c" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">当我们考虑到这一点并将其与良好的代码实践相结合时，它真的开始发光了。</p><p id="b7f9" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">下面是一个简单的工厂函数示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="f5b7" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">当你使用工厂函数足够多的时候，你开始意识到与它的类构造函数相比，它促进了更强的可重用性。这导致代码更少，重构更容易，因为工厂函数最终会返回任意对象，并且更容易管理一个代码到另一个代码。</p><h2 id="6216" class="ly lh it bd li lz ma dn lm mb mc dp lq md me mf ls mg mh mi lu mj mk ml lw mm bi translated">2.上添加方法。编写构造函数时的原型</h2><p id="0762" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv md mw mx my mg mz na nb mj nc nd ne nf im bi translated">如果您是JavaScript新手，这一节可能对您来说有点陌生，因为这是我使用JavaScript的头两年的经历。</p><p id="95bc" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">(请记住，这不适用于类，因为类已经将方法附加到了它们的原型上。)</p><p id="4d98" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">下面是一个构造函数的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="39ae" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">为什么这样做而不是直接附加<code class="fe nl nm nn no b">leap</code>方法，如下例所示？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6aac" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">当我们直接在<code class="fe nl nm nn no b">prototype</code>上附加方法时，它们在由构造函数创建的所有实例中共享。</p><p id="abe5" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">换句话说，使用最后一个例子，如果我们创建了三个单独的<code class="fe nl nm nn no b">Frog</code>(来自<code class="fe nl nm nn no b">this.leap = function() {...}</code>，那么我们最终会创建三个单独的副本。这是一个问题，因为<code class="fe nl nm nn no b">leap</code>方法将一直保持不变，不需要有自己的实例副本。</p><p id="6de9" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">最终，这会降低性能，而这本来是可以避免的。需要在实例上定义<code class="fe nl nm nn no b">this.name</code>和<code class="fe nl nm nn no b">this.gender</code>属性，因为在现实生活中，青蛙可能有自己的名字和性别，所以在实例级别上创建它们是有意义的。</p><p id="79b3" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated"><a class="ae nr" href="https://github.com/request/request/blob/master/lib/querystring.js" rel="noopener ugc nofollow" target="_blank">这里有一个GitHub </a>上的例子，流行的<a class="ae nr" href="https://github.com/request/request" rel="noopener ugc nofollow" target="_blank">请求</a>包使用了这种方法。</p><h2 id="68a5" class="ly lh it bd li lz ma dn lm mb mc dp lq md me mf ls mg mh mi lu mj mk ml lw mm bi translated">3.使用常规的。区分时的类型属性</h2><p id="0ef3" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv md mw mx my mg mz na nb mj nc nd ne nf im bi translated">这种做法非常有效，以至于今天被广泛使用。如果你是一名React开发人员，你可能已经每天都看到这种情况了，尤其是当你使用<a class="ae nr" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>的时候。</p><p id="b9ef" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">使用类似的方法也使您在开发流程中变得非常容易，因为它甚至非常好地记录了自己:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="bfa0" class="ly lh it bd li lz ma dn lm mb mc dp lq md me mf ls mg mh mi lu mj mk ml lw mm bi translated">4.使用类型脚本</h2><p id="cced" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv md mw mx my mg mz na nb mj nc nd ne nf im bi translated">TypeScript 已经在JavaScript社区中被广泛采用，因为它能够为类型安全提供强大的保护，并且能够帮助我们在错误发生之前就将其捕获。</p><p id="efb5" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">使用TypeScript将使您的编译器能够在代码运行之前检测并显示有关代码中任何潜在错误的警告。</p><p id="da7a" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">但是这还不是为什么采用TypeScript对任何情况都有好处的原因的完整列表。TypeScript最棒的一点是，它允许您在主流浏览器支持之前使用JavaScript中的新特性，因为它们会被编译为早期版本的JavaScript，最终能够在旧浏览器中运行。</p><h2 id="5cb1" class="ly lh it bd li lz ma dn lm mb mc dp lq md me mf ls mg mh mi lu mj mk ml lw mm bi translated">5.编写测试</h2><p id="fca7" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv md mw mx my mg mz na nb mj nc nd ne nf im bi translated">如果你正在做一个项目，并打算认真对待它，那么几乎必须进行测试，以便你的应用程序变得更可预测，更不容易出错，并对未来的变化具有弹性。换句话说，如果您计划让您的项目经得起未来考验，没有比在整个代码中建立测试更好的方法了。您在代码中进行的测试越多，当它被部署到现实世界的生产中时，您就越有信心。</p><p id="f436" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">考试最大的好处是什么？事实上，它们可以帮助你在错误出现之前就抓住错误——难道没有人想要这种能力吗？我肯定我有！这就是我在项目中编写单元测试的原因。</p><p id="d688" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">通过阅读这篇关于测试<a class="ae nr" href="https://geekflare.com/javascript-unit-testing/" rel="noopener ugc nofollow" target="_blank">框架和工具</a>的文章，你可以开始使用今天正在使用的工具类型。</p><h2 id="8747" class="ly lh it bd li lz ma dn lm mb mc dp lq md me mf ls mg mh mi lu mj mk ml lw mm bi translated">6.尽可能保持功能简单</h2><p id="05a3" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv md mw mx my mg mz na nb mj nc nd ne nf im bi translated">众所周知，在JavaScript中，很明显有可能使用巨大的函数来做不止一件事。</p><p id="ec5e" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">当你是编程新手时，这可能感觉像是一件好事——我知道当我写了大量有效的代码时，我对自己感觉非常好。这基本上对我来说是最重要的，给了我很多信心，让我看到我的任何代码都没有问题地运行，更不用说是我写的巨大的代码块了。哦，天啊，那时我是不是太天真了！</p><p id="c0c7" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">如果您想编写更易维护、更简单、更不容易出错的代码，那么最好尽可能保持代码的简单性和小巧性。越简单越容易单独测试。</p><p id="50ae" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">如果您更喜欢函数式编程范式，这一点尤其重要。众所周知，函数应该做一件事，而且必须做好。</p><h2 id="1216" class="ly lh it bd li lz ma dn lm mb mc dp lq md me mf ls mg mh mi lu mj mk ml lw mm bi translated">7.使用<code class="fe nl nm nn no b">JSON.parse </code>或<code class="fe nl nm nn no b">JSON.stringify</code>时，请务必考虑使用<code class="fe nl nm nn no b">try/catch</code></h2><p id="7a78" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv md mw mx my mg mz na nb mj nc nd ne nf im bi translated">在JavaScript中，当我们将JSON作为输入传递给<code class="fe nl nm nn no b">JSON.parse</code>方法时，它期望一个正确格式化的JSON作为第一个参数。如果格式不正确，它将抛出一个JSON解析错误。</p><p id="0d71" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">JSON解析错误带来的危险是收到无效的JSON会使应用程序崩溃。我最近在工作中遇到过这样的情况，我们的一个web项目失败了，因为另一个内部包没有将<code class="fe nl nm nn no b">JSON.parse</code>包装在<code class="fe nl nm nn no b">try/catch</code>中。这导致了一个web页面的失败，并且没有办法克服这个错误，除非内部包修复它。这是因为JavaScript运行时被破坏了。</p><pre class="kj kk kl km gt ns no nt nu aw nv bi"><span id="d503" class="ly lh it no b gy nw nx l ny nz">SyntaxError: Unexpected token } in JSON at position 107</span></pre><p id="8e14" class="pw-post-body-paragraph mn mo it mp b mq ng ju ms mt nh jx mv md ni mx my mg nj na nb mj nk nd ne nf im bi translated">您不应该总是期望有效的JSON输入，因为它可以接收像<code class="fe nl nm nn no b">&gt;</code>字符这样的奇怪字符，这在今天并不罕见。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="be25" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="792c" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv md mw mx my mg mz na nb mj nc nd ne nf im bi translated">这就是这篇文章的结尾。我希望你发现这是有价值的。以后多多关注！</p></div></div>    
</body>
</html>