<html>
<head>
<title>How Are You Structuring Your Go Microservices?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您如何构建您的Go微服务？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-are-you-structuring-your-go-microservices-a355d6293932?source=collection_archive---------2-----------------------#2022-06-15">https://betterprogramming.pub/how-are-you-structuring-your-go-microservices-a355d6293932?source=collection_archive---------2-----------------------#2022-06-15</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="bae3" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">以下是我基于真实项目提出的解决方案</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/a4765262089b10012350b12ad4748d35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e_EhbsyNw6tJbYjwwbjVVg.png"/></div></figure><p id="ff9e" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">微服务这个术语无疑是这些天来唯一飞速发展的趋势。许多公司已经将他们难以改变的大块转化为许多名为微服务的更小的移动部件。为此，Golang无疑是目前最可行的选择之一。它可以帮助开发者快速构建微小但强大的服务。</p><p id="107b" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">过去，我们常常关注如何用许多抽象层来构建一个管理良好的应用程序。现在，我们可以把它们分成许多小的可部署单元。许多团队可以从事许多较小的项目，任何个人都可以通过开发较小规模的项目来做出贡献和成长。他们所有人都将相互交流以解决更大的问题。</p><p id="3e0d" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">因此，现在的问题已经从如何创建和设计一个大项目转移到创建和保持设计良好的小项目，并且对于开发和扩展足够灵活。</p><p id="341d" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">最近，我参加了一个公司的小任务，要求我实现一个API服务器。我必须提出一个易于理解、可组织和可维护的合适的架构。</p><p id="4549" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">经过一段时间对我在当前公司所做的一切进行操作后，我起草了一个基于样板gRPC服务的解决方案，它可以部署在任何平台上。它可能有许多地方需要改进，但我很乐意分享这个项目。</p><div class="lk ll gq gs lm ln"><a href="https://github.com/vchitai/togo" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab fp"><div class="lp ab lq cl cj lr"><h2 class="bd is gz z fq ls fs ft lt fv fx iq bi translated">GitHub-vchi tai/多哥</h2><div class="lu l"><h3 class="bd b gz z fq ls fs ft lt fv fx dk translated">如何在本地运行你的代码？要运行服务器，使用一个简单的命令:$ make run一个示例“curl”命令来调用…</h3></div><div class="lv l"><p class="bd b dl z fq ls fs ft lt fv fx dk translated">github.com</p></div></div><div class="lw l"><div class="lx l ly lz ma lw mb km ln"/></div></div></a></div><p id="4a51" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">项目结构受到项目标准Go项目布局的启发。我也加入了我自己基于干净架构原则的创新。</p><h1 id="8e07" class="mc md ir bd me mf mg mh mi mj mk ml mm jx mn jy mo ka mp kb mq kd mr ke ms mt bi translated">项目结构</h1><p id="6e86" class="pw-post-body-paragraph ko kp ir kq b kr mu js kt ku mv jv kw kx mw kz la lb mx ld le lf my lh li lj ik bi translated">总的来说，在Golang项目中，我们有许多服务于许多用例的包。只有少数几个存储Go代码实现，如<code class="fe mz na nb nc b">cmd</code>、<code class="fe mz na nb nc b">configs</code>、<code class="fe mz na nb nc b">internal</code>、<code class="fe mz na nb nc b">pkg</code>，其他的用于测试<code class="fe mz na nb nc b">mocks</code>、<code class="fe mz na nb nc b">test</code>、记录<code class="fe mz na nb nc b">docs</code>和集成:<code class="fe mz na nb nc b">proto</code>、<code class="fe mz na nb nc b">pb</code>、本地开发:<code class="fe mz na nb nc b">local</code></p><ul class=""><li id="41b2" class="nd ne ir kq b kr ks ku kv kx nf lb ng lf nh lj ni nj nk nl bi translated"><code class="fe mz na nb nc b">cmd</code>:包含应用程序的所有入口点</li><li id="9fe9" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><code class="fe mz na nb nc b">configs</code>:存储应用的所有配置</li><li id="8e7a" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><code class="fe mz na nb nc b">docs</code>:申请的所有可用文件</li><li id="f38c" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><code class="fe mz na nb nc b">internal</code>:项目私人包</li><li id="c0ef" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><code class="fe mz na nb nc b">pkg</code>:项目公共包</li><li id="04b9" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated">允许每个人在本地环境中运行你的代码的所有额外的东西。</li><li id="ba55" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><code class="fe mz na nb nc b">mocks</code>:模拟对你的应用程序进行单元测试的东西</li><li id="d410" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><code class="fe mz na nb nc b">proto</code> : <code class="fe mz na nb nc b">protobuf </code>为您的微服务定义(我与gRPC通信方法一起用于我公司的内部服务通信，您可以像<code class="fe mz na nb nc b">jsonschema, graphQL or SOAP contract)</code>一样存储另一个合同)</li><li id="4f21" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><code class="fe mz na nb nc b">pb</code> <strong class="kq is">(可能是</strong> <code class="fe mz na nb nc b">api</code> <strong class="kq is"> ) </strong>:由protobuf生成的代码</li><li id="0400" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><code class="fe mz na nb nc b">test</code>:为您的微服务集成</li></ul><p id="7200" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated"><strong class="kq is">生产就绪型微服务的额外灵丹妙药</strong></p><p id="7c58" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">对于准备在生产环境中发布的微服务，我们工程师不能仅仅构建一些可运行的二进制文件。生产环境是混沌环境，数据变化速度远远高于实验环境，到处都是坑坑洼洼的障碍物。这些事情可能会彻底破坏你的应用程序。</p><p id="5370" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">为了处理这些问题，我们需要一种方法来监控我们的服务，并迅速采取行动进行故障排除。源代码必须是可维护的、可扩展的，并且满足大量的非功能性需求。</p><ul class=""><li id="ae80" class="nd ne ir kq b kr ks ku kv kx nf lb ng lf nh lj ni nj nk nl bi translated">对于版本控制选项，我建议使用git，因为它是这个领域最明显的选择之一。你不能独自开发这个项目。迟早，你会需要更多的人加入你。为了转移目的和新成员的加入，保持项目的良好文档记录，命令行缩写程序的Makefile(也是如何安装和运行项目的好指南)是一个好的选择，ReadmeMD是必须的。</li><li id="02bc" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated">对于任何项目来说，单元测试都应该集中在保持道路畅通和降低风险上。实现良好的单元测试可以降低修改源代码的风险，尤其是当项目规模以指数速度增长时。我一直在使用linter的<code class="fe mz na nb nc b">golang-ci-lint</code>工具(检查源代码是实现该语言的最佳实践，这将有助于我们更容易地关注其他方面)。<code class="fe mz na nb nc b">Go test </code>是一个完美的工具，在go 1.18中引入模糊时会更好，现在你只需要一个mock工具来更容易地实现项目包层分离，实现干净的架构师。</li><li id="ef1f" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated">对于构建和部署您的微服务，目前最简单的解决方案是通过集装箱技术运输。您的应用程序将被保存在一个非常小的、隔离的环境中，这样当一个服务失败时，您的另一个服务不会受到影响。目前最常用的堆栈是via Docker和k8s技术。保持部署流程的精益是最大限度地降低推广和替换服务的风险的关键。此外，最小化的流程有助于您的应用程序以更高的速度启动修补程序，从而减少事件的规模。</li></ul><p id="5afc" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">所以我把所有这些东西都放在了项目中:</p><ul class=""><li id="3906" class="nd ne ir kq b kr ks ku kv kx nf lb ng lf nh lj ni nj nk nl bi translated"><code class="fe mz na nb nc b">Dockerfile </code> &amp; <code class="fe mz na nb nc b">.dockerignore</code>:将你的应用程序容器化，使其可以在任何现有的基础设施上运行。</li><li id="4f6c" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><code class="fe mz na nb nc b">.git</code> &amp; <code class="fe mz na nb nc b"> .gitignore</code> : git版本控制是目前管理你的项目的最佳选择。</li><li id="3987" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><code class="fe mz na nb nc b">.golangci.yaml</code>:T5的指导方针，是目前可用于Go的最好的棉绒之一。</li><li id="0939" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated">为了单元测试的目的，生成你的模拟材料。</li><li id="2432" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated">创建一个非常方便的快捷命令。</li><li id="f50b" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><code class="fe mz na nb nc b">README.md</code>:绝对是你项目的灵魂。</li><li id="6400" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><code class="fe mz na nb nc b">buf.gen.yaml</code> &amp; <code class="fe mz na nb nc b">buf.work.yaml</code>:使用buf.build进行原型代码生成。</li><li id="1a16" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><code class="fe mz na nb nc b">tools.go</code>:添加您的<code class="fe mz na nb nc b">go build </code>工具依赖。</li><li id="52b2" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><code class="fe mz na nb nc b">go.mod</code> &amp; <code class="fe mz na nb nc b">go.sum</code> : go模块文件</li></ul><h2 id="937b" class="nr md ir bd me ns nt dn mi nu nv dp mm kx nw nx mo lb ny nz mq lf oa ob ms oc bi translated">通用架构</h2><p id="2861" class="pw-post-body-paragraph ko kp ir kq b kr mu js kt ku mv jv kw kx mw kz la lb mx ld le lf my lh li lj ik bi translated">在work Clean Architecture中，我们已经了解了软件应该如何设计。在最典型的用例中，我们将需要实体、用例以及许多支持的实用程序包。在微服务生态系统中，我们仍然使用具有扩展上下文的相同术语。领域实体和用例不仅包含在一个服务中，而且可以跨服务共享。但是每个微服务内部的层的设计仍然是相同的。</p><p id="b40e" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">在最常见的用例中，我通常会实现:</p><ul class=""><li id="b701" class="nd ne ir kq b kr ks ku kv kx nf lb ng lf nh lj ni nj nk nl bi translated">实体:服务的核心域对象。没有业务实体，服务就没有存在的意义。</li><li id="9877" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated">用例:涵盖交互的业务方面和每个实体的行为。</li><li id="b816" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated">框架和驱动程序:服务于一般情况的实用程序，不仅仅是提到的服务</li><li id="420a" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated">存储库:包装存储和管理实体状态的行为。通常，我看到许多服务是用错误的视点实现的。存储库可以是另一个外部微服务或DB引擎。在存储库中处理的事务应该被视为全局分布式事务。</li><li id="eb54" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated">API:其他外部服务为了熟悉服务而需要知道的唯一接口。</li><li id="bdc7" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated">入口点:将所有组件集成到一个可运行的二进制服务特性中的地方，比如服务器监听和处理或者</li></ul><p id="b17a" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">我设计并实现了许多微服务，从商业模式相关的服务到技术服务。我设计的任何东西都不会使用除了这些层分类之外的任何东西，并且遵循Clean Architecture中陈述的依赖规则真正使它们以一种可爱的方式合作。</p><p id="0577" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">微服务生态系统让我从在任何微小的微服务内部设计如此复杂和复杂的架构师中解放出来，而是更加专注于如何从更高的角度解决问题，许多可替换的移动部件形成更大的管道。</p><h2 id="2b6c" class="nr md ir bd me ns nt dn mi nu nv dp mm kx nw nx mo lb ny nz mq lf oa ob ms oc bi translated"><strong class="ak">集成水平</strong></h2><p id="0b53" class="pw-post-body-paragraph ko kp ir kq b kr mu js kt ku mv jv kw kx mw kz la lb mx ld le lf my lh li lj ik bi translated">一般来说，每个微服务代表一个有意从更大的画面中分离出来的模块。那个模块必须有自己的业务领域(它存在的目的)，必须有相应的层和架构(足够的灵活性可以修改)。</p><p id="c0cf" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">考虑到需要一种方法来灵活地插入和播放模块，在最方便的情况下，我们可以假装它是本机插入的部件。gRPC目前为我们提供了许多最大的优势。</p><ul class=""><li id="f250" class="nd ne ir kq b kr ks ku kv kx nf lb ng lf nh lj ni nj nk nl bi translated">处理向后和向前兼容性的解决方案。</li><li id="dbbd" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated">您可以用许多不同的语言生成gRPC客户端，并且可以在您的代码库中将它作为本机插件使用。(较低的网络协议已悄悄完成)</li><li id="532e" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated">HTTP/2是一个很好的面向未来的协议。</li><li id="09cb" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated">精心设计的原则和广泛开放的社区支持资源。</li></ul><p id="3080" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">在过去，我经历了许多关于服务沟通的问题。大部分来自于通信合同中的不匹配。JSON schema(或GraphQL)的发展历史表明了解决问题的努力。另一个是试图编写提供稳定通信方法(带有重试、网络池等)的最佳HTTP客户端的工作成本。在那里,<code class="fe mz na nb nc b">gRPC </code>和<code class="fe mz na nb nc b">protobuf </code>继续以一种极其简单的方式解决这些问题。对于任何不需要立即处理请求的用例，您也可以将它们<code class="fe mz na nb nc b">protobuf </code>作为一种在排队、轮询或流系统中序列化的方式。</p><p id="6857" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">有了清晰的沟通方式，生态系统中的活动部分现在只剩下:</p><ul class=""><li id="e277" class="nd ne ir kq b kr ks ku kv kx nf lb ng lf nh lj ni nj nk nl bi translated">API服务器:提供与服务域对象的交互。</li><li id="26e6" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated">Cron jobs:在一天中的某个时刻完成工作的人。</li><li id="5c22" class="nd ne ir kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated">轮询作业:用于处理应用程序产生的数据的消费者或循环到世界尽头的作业。</li></ul><h1 id="7a58" class="mc md ir bd me mf mg mh mi mj mk ml mm jx mn jy mo ka mp kb mq kd mr ke ms mt bi translated">结论</h1><p id="f6f3" class="pw-post-body-paragraph ko kp ir kq b kr mu js kt ku mv jv kw kx mw kz la lb mx ld le lf my lh li lj ik bi translated">通过一次招聘挑战，我有机会在多年后总结我对后端软件设计的观点。我喜欢与每个使用Go后端服务的人分享我的想法。希望我能从其他人那里听到并改进它。</p></div></div>    
</body>
</html>