<html>
<head>
<title>How Git Stores Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git如何存储数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-git-stores-data-dd1107debcb6?source=collection_archive---------8-----------------------#2022-05-04">https://betterprogramming.pub/how-git-stores-data-dd1107debcb6?source=collection_archive---------8-----------------------#2022-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4393" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Blob、树和提交</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c5e1bd877543460eb85de4e89dd3492c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sd21i9IT4cxnRBWqA8VFLQ.jpeg"/></div></div></figure><p id="ad9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我开始使用Git时，我做了大多数人做的事情。我记住了完成工作的命令，但并没有真正理解引擎盖下发生了什么。在大多数情况下，我得到了我想要的结果。但我仍然感到沮丧，因为我偶尔会“破坏”回购协议——让它进入我没有预料到的状态，而且不知道如何修复它。</p><p id="7d07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你们的经历相似吗？</p><p id="bc13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用存储库的捷径是尝试使用一个工具，而不做必要的功课去了解它是如何工作的。在我的例子中，当我读到Git使用的内部数据模型时，一切都“点击”了。你看，Git是一种数据库，例如，如果不知道什么是表、记录等等，你就永远无法使用SQL。是。让我们来填补知识空白，了解一下Git存储库的内部情况。</p><p id="5c70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Git是一个分布式版本控制软件，这意味着您不需要外部服务器来使用它。Git需要的所有数据都存储在<code class="fe lq lr ls lt b">.git</code>文件夹中。作为Git用户，您无权更改这些文件，但是出于本文的目的，我们将深入了解Git是如何存储数据的。</p><p id="9f66" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在用<code class="fe lq lr ls lt b">git init</code>创建存储库之后，您会发现:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="ec39" class="ly lz it lt b gy ma mb l mc md">$ ls -R .git<br/>HEAD            config          description     hooks           info            objects         refs<br/><br/>.git/hooks:<br/>applypatch-msg.sample           pre-applypatch.sample           pre-rebase.sample               update.sample<br/>commit-msg.sample               pre-commit.sample               pre-receive.sample<br/>fsmonitor-watchman.sample       pre-merge-commit.sample         prepare-commit-msg.sample<br/>post-update.sample              pre-push.sample                 push-to-checkout.sample<br/><br/>.git/info:<br/>exclude<br/><br/>.git/objects:<br/>info    pack<br/><br/>.git/objects/info:<br/><br/>.git/objects/pack:<br/><br/>.git/refs:<br/>heads   tags<br/><br/>.git/refs/heads:<br/><br/>.git/refs/tags:</span></pre><p id="ea72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，它几乎是空的:我们有几个文件夹，大部分是钩子的示例文件。我们会忽略这些；在本文中，我们将主要关注<code class="fe lq lr ls lt b">.git/objects</code>内容Git中的主要数据存储。</p><h1 id="3d42" class="me lz it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">一滴</h1><p id="d8d1" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">Git将它跟踪的每个文件的每个版本都存储为一个blob。Git通过blobss内容的散列来识别blob，并将它们保存在<code class="fe lq lr ls lt b">.git/objects</code>中。对文件内容的任何更改都会生成一个全新的blob对象。</p><p id="a4c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建对象最简单的方法是将对象添加到<em class="na">阶段</em>。该阶段中的内容将是下一次提交的一部分。Staging是git中的“预提交”状态。它是我们保存尚未提交但已经被Git跟踪的文件的地方。</p><h1 id="4883" class="me lz it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">例子</h1><p id="d8a4" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">让我们创建一个简单的文件，并用一个blob来表示它:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="52f5" class="ly lz it lt b gy ma mb l mc md">$ echo "Test" &gt; test.txt</span></pre><p id="c094" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用这个命令，我们将“测试”写到<code class="fe lq lr ls lt b">test.txt</code>文件中。要使它成为blob，我们只需通过运行以下命令将其添加到舞台:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="aa39" class="ly lz it lt b gy ma mb l mc md">$ git add .</span></pre><p id="3a4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在将我们的新文件添加到stage之后，在<code class="fe lq lr ls lt b">.git/objects</code>中，我们有:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="2f90" class="ly lz it lt b gy ma mb l mc md">$ ls -R .git/objects<br/>34      info    pack<br/><br/>.git/objects/34:<br/>5e6aef713208c8d50cdea23b85e6ad831f0449<br/><br/>.git/objects/info:<br/><br/>.git/objects/pack:</span></pre><p id="57b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们有一个新文件夹<code class="fe lq lr ls lt b">34</code>，在这个文件夹中有一个文件<code class="fe lq lr ls lt b">5e6aef713208c8d50cdea23b85e6ad831f0449</code>。这是因为内容散列是<code class="fe lq lr ls lt b">345e....</code>:前面的两个字符被用作目录。这个文件的内容是:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="3101" class="ly lz it lt b gy ma mb l mc md">$ cat .git/objects/34/5e6aef713208c8d50cdea23b85e6ad831f0449<br/>xKOR0I-.</span></pre><p id="e21b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它被压缩以提高存储效率。我们可以通过运行以下Git命令来查看里面的内容:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="7509" class="ly lz it lt b gy ma mb l mc md">$ git cat-file blob 345e6aef713208c8d50cdea23b85e6ad831f0449<br/>Test</span></pre><p id="3526" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们只有<em class="na">里面的</em>内容——没有文件的元数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ce95ff0d3660b86962f1f0359d872082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0gHxzt_lKfFIYjww"/></div></div></figure><h1 id="1073" class="me lz it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">修改示例</h1><p id="a654" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">让我们看看如果我们对文件进行一些更改并添加更新版本会发生什么:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="1116" class="ly lz it lt b gy ma mb l mc md">$ echo "Test 2" &gt;&gt; test.txt</span></pre><p id="05d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该命令向现有文件<code class="fe lq lr ls lt b">test.txt</code>添加一个新行“测试2”。</p><p id="2bc2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们将当前版本添加到舞台:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="dca7" class="ly lz it lt b gy ma mb l mc md">$ git add .</span></pre><p id="701c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看看<code class="fe lq lr ls lt b">.git/objects</code>文件夹里有什么:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="095d" class="ly lz it lt b gy ma mb l mc md">$ ls -R .git/objects<br/>34      d2      info    pack<br/><br/>.git/objects/34:<br/>5e6aef713208c8d50cdea23b85e6ad831f0449<br/><br/>.git/objects/d2:<br/>77ba2806ce99d418b0b5d6c28643deca0e36dc<br/><br/>...</span></pre><p id="8c78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有两个对象，第二个在<code class="fe lq lr ls lt b">d2</code>子文件夹中。其内容是:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="0fc5" class="ly lz it lt b gy ma mb l mc md">$ git cat-file blob d277ba2806ce99d418b0b5d6c28643deca0e36dc<br/>Test<br/>Test 2</span></pre><p id="54ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">和我们更新的<code class="fe lq lr ls lt b">text.txt</code>一样:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="33d3" class="ly lz it lt b gy ma mb l mc md">$ cat test.txt<br/>Test<br/>Test 2</span></pre><p id="80c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我们所看到的，Git存储了每个版本的完整文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d1878f41e96274ee566049feb4c96ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WEDJmC0Mmeu5N3KF"/></div></div></figure><h1 id="4e5f" class="me lz it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">树</h1><p id="a2c1" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">树对象是Git存储文件夹的方式。他们引用其他东西作为他们的内容:</p><ul class=""><li id="e7ab" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">文件是通过它们的blob添加的</li><li id="95c2" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">子文件夹按其树添加</li></ul><p id="f687" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于每个引用，树存储:</p><ul class=""><li id="2473" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">文件或文件夹名称</li><li id="973c" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">blob或树哈希</li><li id="7115" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">对象类型</li><li id="fed3" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">许可</li></ul><p id="f869" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">和blobs一样，Git通过内容的散列来识别每棵树。因为树引用它所包含的每个文件的散列，所以对文件内容的任何更改都将导致创建一个全新的树对象。</p><p id="b49e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类似地，因为同一个文件的不同版本将有多个blobs，Git将为每个文件夹版本创建另一个树对象。</p><h1 id="61e7" class="me lz it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">创建树</h1><p id="270e" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">通常，在提交过程中会创建一棵树。我们将在本文稍后讨论提交，但同时，让我们使用<code class="fe lq lr ls lt b">git write-tree</code>——一个<em class="na">管道</em>命令，它基于我们的staging中的内容创建一个树。</p><p id="2e42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">管道和瓷器命令来自Git中的一个类比:</p><ul class=""><li id="c6ec" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">瓷器——面向最终用户的用户友好命令。与浴室的淋浴头或水龙头一样。</li><li id="64f4" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">管道——让瓷器工作所需的内部命令。和你家的水管一样。</li></ul><p id="fcf5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除非你在做高级的东西，否则你不需要知道管道命令。</p><h1 id="148a" class="me lz it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">例子</h1><p id="c607" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">和以前一样，我们运行:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="5afb" class="ly lz it lt b gy ma mb l mc md">$ git write-tree<br/>fd4f9947de2805e460bfeeca3346e3d36d617d37</span></pre><p id="8e68" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">返回值是新树对象的ID。要查看内部，您可以运行:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="d671" class="ly lz it lt b gy ma mb l mc md">$ git cat-file -p fd4f9947de2805e460bfeeca3346e3d36d617d37<br/>100644 blob d277ba2806ce99d418b0b5d6c28643deca0e36dc    test.txt</span></pre><p id="2d2b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管它与blobs是不同的数据类型，但它们的值存储在相同的位置:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="2d35" class="ly lz it lt b gy ma mb l mc md">$ ls -R .git/objects<br/>34      d2      fd      info    pack<br/><br/>.git/objects/34:<br/>5e6aef713208c8d50cdea23b85e6ad831f0449<br/><br/>.git/objects/d2:<br/>77ba2806ce99d418b0b5d6c28643deca0e36dc<br/><br/>.git/objects/fd:<br/>4f9947de2805e460bfeeca3346e3d36d617d37<br/><br/>…</span></pre><p id="1f6e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有数据都在同一个文件夹结构中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ec1b9a393f5948769cfae133c9e696ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AxXdIOM5PDPuN6dd"/></div></div></figure><h1 id="7d91" class="me lz it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">嵌套示例</h1><p id="11a0" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">现在，我们将在其中添加另一个文件夹，以查看嵌套树是如何存储的:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="228f" class="ly lz it lt b gy ma mb l mc md"># <!-- -->create a new folder<br/>$ mkdir nested #</span><span id="8316" class="ly lz it lt b gy np mb l mc md"># add a file &amp; it’s content<br/>$ echo 'lorem' &gt; nested/ipsum</span><span id="25cf" class="ly lz it lt b gy np mb l mc md"># <!-- -->adding it to the stage<br/>$ git add .</span></pre><p id="5889" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在创建一棵树会给我们一个新的ID:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="dd10" class="ly lz it lt b gy ma mb l mc md">$ git write-tree<br/>25517090ae5d0eb08f694de6d38d613615fe99e4</span></pre><p id="5315" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其内容:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="8f2a" class="ly lz it lt b gy ma mb l mc md">$ git ls-tree 25517090ae5d0eb08f694de6d38d613615fe99e4<br/>040000 tree bc9a36d27aa303a3b1cab543b64c6944fea5ce8b    nested<br/>100644 blob d277ba2806ce99d418b0b5d6c28643deca0e36dc    test.txt</span></pre><p id="f17a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以看到<code class="fe lq lr ls lt b">nested</code>是作为树引用添加的。让我们看看里面是什么:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="e6e6" class="ly lz it lt b gy ma mb l mc md">$ git ls-tree bc9a36d27aa303a3b1cab543b64c6944fea5ce8b<br/>100644 blob 3e9ffe066cd7b2ce4c6fb5c8f858496194e1c251    ipsum</span></pre><p id="1b8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，这是另一个描述文件夹内容的树对象。使用许多树对象，您可以描述任何嵌套的文件夹结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d066363bc362060176e600263426b90c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Aj6vSHk_TbOWzF3N"/></div></div></figure><h1 id="9448" class="me lz it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">承诺</h1><p id="fc86" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">提交是对存储库状态的完整描述。它包含以下信息:</p><ul class=""><li id="200b" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">描述最顶层文件夹的树对象的引用</li><li id="9b8a" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">提交作者、提交者和时间</li><li id="e5a8" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">父提交-我们提交所基于的提交</li></ul><p id="c21c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大多数提交只有一个父级，以下情况除外:</p><ul class=""><li id="2b05" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">历史上第一次提交没有父级</li><li id="3c13" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">合并提交有多个</li></ul><p id="2e13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">和以前一样，Git通过内容的散列来识别每个提交。因此，对文件、文件夹或提交元数据的任何更改都将创建新的提交。</p><h1 id="9451" class="me lz it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">第一次提交</h1><p id="4fe4" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">我们可以使用标准提交命令创建第一个提交:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="e774" class="ly lz it lt b gy ma mb l mc md">$ git commit -m 'first commit'<br/>[main (root-commit) 26349a2] first commit<br/> 2 files changed, 3 insertions(+)<br/> create mode 100644 nested/ipsum<br/> create mode 100644 test.txt</span></pre><p id="855a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出显示了截断的提交ID。让我们找到一个完整的值:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="0824" class="ly lz it lt b gy ma mb l mc md">$ git show<br/>commit 26349a25253f9b316db1a5d3c3f23c1ca5ca4e0e (HEAD -&gt; main)<br/>Author: Marcin Wosinek &lt;marcin.wosinek@gmail.com&gt;<br/>Date:   Thu Apr 28 18:18:07 2022 +0200<br/><br/>    first commit<br/>…</span></pre><p id="1ba8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要查看提交对象的内容，我们可以使用:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="8947" class="ly lz it lt b gy ma mb l mc md">$ git cat-file -p 26349a25253f9b316db1a5d3c3f23c1ca5ca4e0e<br/>tree 25517090ae5d0eb08f694de6d38d613615fe99e4<br/>author Marcin Wosinek &lt;marcin.wosinek@gmail.com&gt; 1651162687 +0200<br/>committer Marcin Wosinek &lt;marcin.wosinek@gmail.com&gt; 1651162687 +0200<br/><br/>first commit</span></pre><p id="2ee8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">树引用与我们在前一个例子中的树引用相同。我们可以看到提交与其他对象位于同一个文件夹中:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="578f" class="ly lz it lt b gy ma mb l mc md">$ ls -R .git/objects<br/>25      26      34      3e      bc      d2      fd      info    pack<br/><br/>…<br/><br/>.git/objects/26:<br/>349a25253f9b316db1a5d3c3f23c1ca5ca4e0e<br/><br/>…</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/458b4ba1854aabf6e694843180c3c237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3tbbVEAotdbsOz5a"/></div></div></figure><h1 id="f473" class="me lz it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">下一次提交</h1><p id="6a00" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">让我们恢复第一个版本的<code class="fe lq lr ls lt b">test.txt</code>文件:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="6bbc" class="ly lz it lt b gy ma mb l mc md">$ echo "Test" &gt; test.txt</span></pre><p id="49f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该命令用“Test”覆盖现有文件。</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="d279" class="ly lz it lt b gy ma mb l mc md">$ git add .</span></pre><p id="29fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将更新版本添加到暂存中。</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="5ee7" class="ly lz it lt b gy ma mb l mc md">$ git commit -m 'second commit'<br/>[main 7f54a43] second commit<br/> 1 file changed, 1 deletion(-)</span></pre><p id="736f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">提交更改。</p><p id="77a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们找到完整的ID:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="9462" class="ly lz it lt b gy ma mb l mc md">$ git show<br/>commit 7f54a437d87cd1f241cfb893c4823bc7e60c19ec (HEAD -&gt; main)<br/>Author: Marcin Wosinek &lt;marcin.wosinek@gmail.com&gt;<br/>Date:   Thu Apr 28 18:37:55 2022 +0200<br/><br/>    second commit<br/>…</span></pre><p id="2c44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，提交内容是:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="3677" class="ly lz it lt b gy ma mb l mc md">$ git cat-file -p 7f54a437d87cd1f241cfb893c4823bc7e60c19ec<br/>tree 04b0192c1c88ac1c1a96f386e84e5388ef8a509a<br/>parent 26349a25253f9b316db1a5d3c3f23c1ca5ca4e0e<br/>author Marcin Wosinek &lt;marcin.wosinek@gmail.com&gt; 1651163875 +0200<br/>committer Marcin Wosinek &lt;marcin.wosinek@gmail.com&gt; 1651163875 +0200<br/><br/>second commit</span></pre><p id="2115" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Git已经添加了<em class="na">父</em>行，因为我们在另一个提交的之上提交<em class="na">。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/71d643937af9fb2f6fd652c46df0bea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r3WAX2es74hZ4DmT"/></div></div></figure><p id="e71c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Git保存的其他重要数据只是对最近一次提交的引用。所以我的<em class="na">主</em>分支存储在<code class="fe lq lr ls lt b">.git/refs/heads/main</code>中，它的内容是</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="2d10" class="ly lz it lt b gy ma mb l mc md">$ cat .git/refs/heads/main<br/>7f54a437d87cd1f241cfb893c4823bc7e60c19ec</span></pre><p id="7f4d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或其最顶层提交的ID。我们可以从不断扩展的提交树中找到所有相关信息:</p><ul class=""><li id="c3ac" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">提交消息告知的分支历史</li><li id="a098" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">谁做了更改，何时做的</li><li id="f6af" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">不同分支和标签之间的关系</li></ul><p id="dc9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我创建一个简单的标签时:</p><p id="8cc8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe lq lr ls lt b">.git/refs/tags</code>创建一个文件:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="6a70" class="ly lz it lt b gy ma mb l mc md">$ cat .git/refs/tags/v1<br/>7f54a437d87cd1f241cfb893c4823bc7e60c19ec</span></pre><p id="828a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，标记和分支都是对提交的显式引用。它们之间唯一的区别是当我们创建一个新的提交时Git如何对待它们:</p><ul class=""><li id="4ad7" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">当前分支被移动到新提交</li><li id="d3c4" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">标签保持不变</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/973865d9cfd61852cffbe1c3ebb84c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z7GJvEsLn7ZK6go2"/></div></div></figure><h1 id="77fc" class="me lz it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">摘要</h1><p id="9703" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">blob、树和提交是Git存储存储库完整历史的方式。它通过对象散列进行所有的引用:没有办法在不破坏关系的情况下操作存储库中跟踪的历史或文件。</p><p id="aeef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你觉得这篇文章有帮助吗？订阅以便在我发布关于编程和JavaScript的新文章时得到通知。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="15c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="na">最初发布于</em><a class="ae nx" href="https://how-to.dev/how-git-stores-data" rel="noopener ugc nofollow" target="_blank"><em class="na">https://how-to . dev</em></a><em class="na">。</em></p></div></div>    
</body>
</html>