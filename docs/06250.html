<html>
<head>
<title>How to Detect an Android App Update</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何检测Android应用程序更新</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-detect-an-android-app-update-7ded8560af31?source=collection_archive---------10-----------------------#2020-09-14">https://betterprogramming.pub/how-to-detect-an-android-app-update-7ded8560af31?source=collection_archive---------10-----------------------#2020-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cdfd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">优雅地在两个版本之间执行迁移代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/649960302a2f03ce0668053d9c14e44d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Shs4hhNSCUj7FdDt"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@danielkcheung?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张家瑜</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="d59e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您正在重新访问应用程序中的一个现有特性。有时，它与以前的版本有很大的不同，你会想就此进行交流。您可能想让您的用户拥有这一更新的功能。</p><p id="43d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您希望在发布此功能时触发这样的事件。然而，通知升级你的应用的用户才是最重要的。它不会给机上新用户带来重温体验的价值。</p><p id="1138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Android SDK没有提供区分用户如何获得应用程序的机制。他们可能通过以下方式做到了这一点:</p><ul class=""><li id="6c18" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">从头开始下载您的应用程序。</li><li id="e00d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">从现有版本更新。</li></ul><p id="95bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有一个比较两个版本的机制，那会很有帮助。让我们看看如何实现这一点。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="fed1" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">比较两个不同的版本</h1><p id="2914" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">不同公司的命名版本可能有所不同。我假设你赞同<code class="fe nn no np nq b">MAJOR.MINOR.PATCH</code>命名约定。如果是这样，我推荐使用下面的<a class="ae ky" href="https://github.com/G00fY2/version-compare" rel="noopener ugc nofollow" target="_blank">库</a>。</p><p id="499b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这个依赖项添加到您的<code class="fe nn no np nq b">build.gradle</code>文件中:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="ca30" class="nv mr it nq b gy nw nx l ny nz">dependencies {<br/>  implementation 'com.g00fy2:versioncompare:1.3.4'// latest version<br/>}</span></pre><p id="3678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个库嵌入了版本比较。它们处理<code class="fe nn no np nq b">MAJOR.MINOR.PATCH</code>命名约定以及预发布后缀。</p><p id="01b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您的版本命名约定，您可以自由设置您的版本比较机制。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3606" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">检测更新</h1><p id="b1cb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">使用您的版本比较机制，您可以创建一个<code class="fe nn no np nq b">UpdateDetector</code>类。</p><p id="6720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类将负责存储当前版本。对于这样的数据，<code class="fe nn no np nq b">SharedPreferences</code>似乎足够了，尽管<code class="fe nn no np nq b"><a class="ae ky" href="https://android-developers.googleblog.com/2020/09/prefer-storing-data-with-jetpack.html" rel="noopener ugc nofollow" target="_blank">DataStore</a></code>的到来可能会很快成为更好的候选。</p><p id="d4e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还需要将当前版本保存在RAM中。这样，您可以在整个用户会话期间处理迁移。</p><p id="f15c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，该类应该公开一个回调来执行迁移。</p><p id="f50f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是您可以想到的实现。出于方便的原因，接下来的类依赖于带有<a class="ae ky" href="https://developer.android.com/training/dependency-injection/hilt-android" rel="noopener ugc nofollow" target="_blank">句柄</a>的依赖注入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="fbe1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且处理版本的类存储:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="fcfd" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">处理迁移</h1><p id="32fe" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">既然您已经实现了更新检测器，那么您就拥有了运行迁移的所有工具。你可以触发任何你想要的代码给所有来自任何版本的用户到一个专用版本。</p><p id="4ddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保您在您的<code class="fe nn no np nq b">Application</code>类中确认了版本更新。您仍然可以访问以前的版本，并将其与当前版本进行比较，因为检测器将它存储在RAM中。</p><p id="242f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，您可以在代码中的任何地方注入检测器(这是一个单例)。以您想要的方式处理从一个版本到另一个版本的迁移。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0422" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">关于应用程序更新检测的思考</h1><p id="c9fb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这种更新机制在概念上仍然是基本的。更好的存储系统将防止更新事件的丢失。到目前为止，您的用户可能永远不会触及您的迁移处理。</p><p id="5f1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下，在到达我们想让他们上车的地方之前，他们决定退出应用程序。下次您的用户启动应用程序时，应用程序会将您的用户视为已更新。</p><p id="96d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，你可能已经意识到，只要你预料到这一点，这一机制就能很好地发挥作用。越早发布，越多的用户会在他们的设备上存储以前的版本。</p><p id="6cbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在开始使用它之前没有交付很长时间，你将无法区分新用户和现有用户。</p><p id="91a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想长期发展，我强烈建议尽早加入这样的机制。</p></div></div>    
</body>
</html>