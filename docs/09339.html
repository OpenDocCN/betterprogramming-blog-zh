<html>
<head>
<title>Getting Started With Swift Concurrency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速并发入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-swift-concurrency-b6b3040362d7?source=collection_archive---------19-----------------------#2021-08-11">https://betterprogramming.pub/getting-started-with-swift-concurrency-b6b3040362d7?source=collection_archive---------19-----------------------#2021-08-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0103" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">快速概述<em class="ki">异步/等待</em>、<em class="ki">结构化并发</em>和<em class="ki">参与者</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/692967ccb53631eaea28fdb016c43c6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_JjD6QO4D5mK69Ya"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">弗兰克·麦肯纳在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ea80" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于开发人员来说，编写异步代码一直是一项具有挑战性的任务。多年来，Apple提供了各种工具，如grand central dispatch (GCD)、Operations和dispatch queue，帮助开发人员编写异步代码。所有这些工具都很棒，但是它们都有各自的优缺点。</p><p id="ef01" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在今年的WWDC上，苹果将这一点提升到了一个新的水平，推出了Swift concurrency，内置语言支持，承诺异步代码易于编写，易于理解，最重要的是，不受竞争条件的影响。</p><p id="0250" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在本文中，我将向您简要介绍async/waits、结构化并发和actor，这是Swift并发的三个主要特性。</p><p id="fa05" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">希望在本文结束时，您能够很好地理解什么是Swift concurrency，以及如何在自己的项目中使用它。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f0a7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">异步/等待</h1><p id="dea0" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">那么什么是async/await？我们总是听到人们说我们可以使用async/await来使我们的代码并发运行，然而这并不是100%正确的。仅使用async/await不会使您的代码并发运行，它们只是Swift 5.5中引入的关键字，告诉编译器某个代码块应该异步运行。</p><p id="c15a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">假设我们有一个函数执行一些需要一段时间才能完成的繁重任务，我们可以将该函数标记为<code class="fe na nb nc nd b">async</code>,如下所示:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f2a3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">异步函数是一种特殊类型的函数，它可以在执行过程中被挂起。然而，就像普通函数一样，异步函数也可以返回值并抛出错误。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="91f4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果一个函数被标记为<code class="fe na nb nc nd b">async</code>，那么我们必须像这样使用<code class="fe na nb nc nd b">await</code>关键字来调用它:</p><pre class="kk kl km kn gt ng nd nh ni aw nj bi"><span id="5168" class="nk me it nd b gy nl nm l nn no">await performHeavyTask()</span></pre><p id="6b1d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe na nb nc nd b">await</code>关键字表示<code class="fe na nb nc nd b">performHeavyTask()</code>功能可能会由于其异步特性而被挂起。如果我们试图像调用普通(同步)函数一样调用<code class="fe na nb nc nd b">performHeavyTask()</code>函数，我们将会得到一个编译错误，说明在一个不支持并发的函数中调用了–<em class="np">‘async’</em>。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nq"><img src="../Images/9bfc26a958ce3d37ce40d00026c58d67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CPkYyxfnS_NtMbTQ"/></div></div></figure><p id="c9f6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为什么我们会得到这个错误是因为我们试图在同步上下文中调用异步函数。为了在同步和异步世界之间架起桥梁，我们必须创建一个<code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.apple.com/documentation/swift/task" rel="noopener ugc nofollow" target="_blank">Task</a></code>。</p><p id="7f01" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe na nb nc nd b">Task</code>在Swift 5.5中引入。苹果公司称，<code class="fe na nb nc nd b">Task</code>是异步工作的单位。在任务的上下文中，代码可以被挂起并异步运行。因此，我们可以创建一个任务，并用它来调用我们的<code class="fe na nb nc nd b">performHeavyTask()</code>函数。方法如下:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b47e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">上面的代码将为我们提供类似于使用全局调度队列的行为:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6222" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然而，他们如何在幕后工作实际上是很不一样的。</p><h2 id="b3d4" class="nk me it bd mf nr ns dn mj nt nu dp mn lj nv nw mp ln nx ny mr lr nz oa mt ob bi translated">异步/等待与调度队列</h2><p id="14fa" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">当我们创建一个任务时，该任务将在任意线程上运行。当线程到达一个暂停点(代码标记为<code class="fe na nb nc nd b">await</code>)时，系统将暂停代码并解锁线程，以便线程在等待<code class="fe na nb nc nd b">performHeavyTask()</code>结束时可以继续进行其他工作。一旦<code class="fe na nb nc nd b">performHeavyTask()</code>完成，任务将重新获得对线程的控制，代码将继续执行。</p><p id="dc0e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">就像任务一样，全局调度队列也运行在任意线程上。然而，线程在等待<code class="fe na nb nc nd b">performAnotherHeavyTask()</code>完成时被阻塞。因此，在<code class="fe na nb nc nd b">performAnotherHeavyTask()</code>返回之前，被阻塞的线程将不能做任何其他事情。这使得它与async/await方法相比效率较低。</p><p id="64d8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下图显示了<code class="fe na nb nc nd b">DispatchQueue</code>和<code class="fe na nb nc nd b">Task</code>的程序流程:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nq"><img src="../Images/8c0658b8e34cfd330a439ef760c06ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hLkG1yq5IIuRtkRV"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">比较任务和调度队列</p></figure><h2 id="04ce" class="nk me it bd mf nr ns dn mj nt nu dp mn lj nv nw mp ln nx ny mr lr nz oa mt ob bi translated">模拟长期运行任务</h2><p id="eeca" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">如果您想尝试async/await关键字并亲自查看它们的运行情况，您可以使用<code class="fe na nb nc nd b">Task.sleep(_:)</code>方法来模拟一个长时间运行的任务。这个方法什么也不做，只是在返回之前等待给定的纳秒数。这是一个可行的方法，因此你可以这样称呼它:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1079" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">注意，调用<code class="fe na nb nc nd b">Task.sleep(_:)</code>方法时不需要创建任务，因为<code class="fe na nb nc nd b">performHeavyTask()</code>被标记为<code class="fe na nb nc nd b">async</code>，这意味着它将在异步上下文中运行，因此不需要创建任务。</p><p id="0549" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这就是async/await，接下来我们将看看什么是结构化并发。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6141" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结构化并发</h1><p id="a8fb" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">假设我们有两个返回整数值的异步函数，如下所示:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="8d80" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们想得到这两个函数返回值的和，我们可以这样做:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b6e9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">上述代码需要5秒钟才能完成，因为<code class="fe na nb nc nd b">performTaskA()</code>和<code class="fe na nb nc nd b">performTaskB()</code>按顺序运行，<code class="fe na nb nc nd b">performTaskA()</code>必须先完成，然后<code class="fe na nb nc nd b">performTaskB()</code>才能开始运行。</p><p id="19f1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您可能已经注意到了，上面的代码并不是最佳的。由于<code class="fe na nb nc nd b">performTaskA()</code>和<code class="fe na nb nc nd b">performTaskB()</code>是相互独立的，我们可以通过同时运行<code class="fe na nb nc nd b">performTaskA()</code>和<code class="fe na nb nc nd b">performTaskB()</code>来提高执行时间，使得只需要3秒钟就可以完成。这就是结构化并发的用武之地。</p><p id="98c5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">结构化并发的工作原理是，我们将创建两个子任务，同时执行<code class="fe na nb nc nd b">performTaskA()</code>和<code class="fe na nb nc nd b">performTaskB()</code>。在Swift 5.5中，创建子任务有两种主要方式:</p><ol class=""><li id="9b77" class="oc od it lc b ld le lg lh lj oe ln of lr og lv oh oi oj ok bi translated">使用异步let绑定</li><li id="8878" class="oc od it lc b ld ol lg om lj on ln oo lr op lv oh oi oj ok bi translated">使用任务组</li></ol><p id="ebae" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于本文，让我们关注更简单的方法——使用async-let绑定。</p><h2 id="4e4d" class="nk me it bd mf nr ns dn mj nt nu dp mn lj nv nw mp ln nx ny mr lr nz oa mt ob bi translated">异步let绑定</h2><p id="3d69" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">以下代码演示了如何将async-let绑定应用到我们之前的示例中:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7f6d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在上面的代码中，注意我们如何结合<code class="fe na nb nc nd b">async</code>和<code class="fe na nb nc nd b">let</code>关键字来创建一个在<code class="fe na nb nc nd b">performTaskA()</code>和<code class="fe na nb nc nd b">performTaskB()</code>函数上的async-let绑定。这样做将创建两个子任务，同时执行这两个功能。</p><p id="862f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">由于<code class="fe na nb nc nd b">performTaskA()</code>和<code class="fe na nb nc nd b">performTaskB()</code>都被标记为<code class="fe na nb nc nd b">async</code>，我们需要等待这两个函数都完成，以便获得<code class="fe na nb nc nd b">a</code>和<code class="fe na nb nc nd b">b</code>的值。因此，在获取<code class="fe na nb nc nd b">a</code>和<code class="fe na nb nc nd b">b</code>的值时，我们必须使用<code class="fe na nb nc nd b">await</code>关键字来表示代码可能会暂停，同时等待<code class="fe na nb nc nd b">performTaskA()</code>和<code class="fe na nb nc nd b">performTaskB()</code>完成。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nq"><img src="../Images/0b3bfe8d5143f60855c1ae2e3551ebaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OamRmq0sj-I1VDPF"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">使用async-let并发运行任务</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5094" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">行动者</h1><p id="a1cf" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">当处理异步和并发代码时，我们可能遇到的最常见的问题是数据竞争和死锁。这类问题很难调试，也很难修复。由于Swift 5.5中包含了actors，我们现在可以依靠编译器来标记代码中任何潜在的竞争情况。那么演员是怎么工作的呢？</p><h2 id="2d60" class="nk me it bd mf nr ns dn mj nt nu dp mn lj nv nw mp ln nx ny mr lr nz oa mt ob bi translated">它是如何工作的？</h2><p id="7590" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">参与者是引用类型，其工作方式类似于类。然而，与类不同，actors将确保一次只有一个任务可以改变actors的状态，从而消除了竞争条件的根本原因——多个任务同时访问/更改同一个对象状态。</p><p id="71cc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了创建一个actor，我们需要使用关键字<code class="fe na nb nc nd b">actor</code>对它进行注释。这里有一个示例<code class="fe na nb nc nd b">Counter</code> actor，它有一个<code class="fe na nb nc nd b">count</code>可变状态，可以使用<code class="fe na nb nc nd b">addCount()</code>方法进行变异:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9f46" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以像实例化一个类一样实例化一个actor:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0613" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，如果我们试图在<code class="fe na nb nc nd b">Counter</code> actor之外调用<code class="fe na nb nc nd b">addCount()</code>方法，我们将得到一个编译器错误，说明–<em class="np">Actor隔离的实例方法‘add count()’不能从非隔离的上下文</em>中引用。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nq"><img src="../Images/36c87b420767bafa063d84e0520b7ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4e-yH8eADBA4eSvD"/></div></div></figure><p id="082b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们得到这个错误的原因是编译器试图保护<code class="fe na nb nc nd b">Counter</code> actor的状态。假设有多个线程同时调用<code class="fe na nb nc nd b">addCount()</code>，那么就会出现竞争情况。因此，我们不能像调用普通的实例方法一样简单地调用actor的方法。</p><p id="c252" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了避开这个限制，我们必须用关键字<code class="fe na nb nc nd b">await</code>标记调用位置，表明<code class="fe na nb nc nd b">addCount()</code>方法在被调用时可能会挂起。这实际上很有意义，因为为了保持对<code class="fe na nb nc nd b">count</code>变量的互斥，<code class="fe na nb nc nd b">addCount()</code>的调用点可能需要暂停，以便它可以等待其他任务完成后再继续。</p><p id="eb89" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">记住这一点，我们可以应用我们在async/await部分学到的知识，并像这样调用<code class="fe na nb nc nd b">addCount()</code>:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="58e4" class="nk me it bd mf nr ns dn mj nt nu dp mn lj nv nw mp ln nx ny mr lr nz oa mt ob bi translated">非隔离关键字</h2><p id="d237" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">现在，我想请大家注意一下<code class="fe na nb nc nd b">Counter</code>演员的<code class="fe na nb nc nd b">getName()</code>方法。就像<code class="fe na nb nc nd b">addCount()</code>方法一样，调用<code class="fe na nb nc nd b">getName()</code>方法也需要<code class="fe na nb nc nd b">await</code>注释。</p><p id="e730" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然而，如果你仔细观察，<code class="fe na nb nc nd b">getName()</code>方法只是访问<code class="fe na nb nc nd b">Counter</code>的<code class="fe na nb nc nd b">name</code>常量，它并不匹配<code class="fe na nb nc nd b">Counter</code>的状态，因此不可能创建竞争条件。</p><p id="a37f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这种情况下，我们可以通过将<code class="fe na nb nc nd b">getName()</code>方法标记为<code class="fe na nb nc nd b">nonisolated</code>来将其排除在行为人的保护之外。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3ef2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这样，我们现在可以像普通的实例方法一样调用<code class="fe na nb nc nd b">getName()</code>方法:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="cbae" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在结束这篇文章之前，我还想介绍一下关于演员的最后一点，那就是<code class="fe na nb nc nd b">MainActor</code>。</p><h1 id="d61b" class="md me it bd mf mg oq mi mj mk or mm mn jz os ka mp kc ot kd mr kf ou kg mt mu bi translated">主要演员</h1><p id="1d80" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated"><code class="fe na nb nc nd b">MainActor</code>是一种特殊的演员，总是在主线上运行。在Swift 5.5中，所有的UIKit和SwiftUI组件都标记为<code class="fe na nb nc nd b">MainActor</code>。由于所有与UI相关的组件都是主要参与者，所以当我们想要在后台操作完成后更新UI时，我们不再需要担心忘记分派给主线程。</p><p id="3af3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果你有一个应该一直在主线程上运行的类，你可以用<code class="fe na nb nc nd b">@MainActor</code>关键字来注释它，如下所示:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3e74" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但是，如果您只想让您的类中的某个特定函数总是在主线程上运行，您可以使用<code class="fe na nb nc nd b">@MainActor</code>关键字来注释该函数:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3cbf" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">包扎</h1><p id="abc9" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">我对Swift并发感到非常兴奋，我可以预见，在不久的将来，Swift并发肯定会成为编写异步Swift代码的标准。</p><p id="68ec" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我在这篇文章中提到的只是冰山一角，如果你想了解更多，我强烈推荐你看看《WWDC 21》的这些视频。</p><p id="4db7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您喜欢这篇文章，并且不想错过任何与Swift并发相关的未来文章，请随时关注我的<a class="ae kz" href="https://twitter.com/Lee_Kah_Seng" rel="noopener ugc nofollow" target="_blank"> Twitter </a>。</p><p id="2f5f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">感谢阅读。</p></div></div>    
</body>
</html>