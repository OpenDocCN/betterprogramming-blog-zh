<html>
<head>
<title>Cloud Native Patterns Illustrated: Fan-in and Fan-out</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图解云本机模式:扇入和扇出</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cloud-native-patterns-illustrated-fan-in-and-fan-out-daf77455703c?source=collection_archive---------2-----------------------#2022-10-30">https://betterprogramming.pub/cloud-native-patterns-illustrated-fan-in-and-fan-out-daf77455703c?source=collection_archive---------2-----------------------#2022-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8eb9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">单处理器的数据管道最终会遇到瓶颈。让我们使用带有扇入/扇出队列的并发处理器！</h2></div><p id="b990" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我从cs毕业后开始阅读技术书籍，以拓宽我在许多主题上的知识，如系统设计、低级CS、云原生等。现在我正在读<a class="ae lb" href="https://www.oreilly.com/library/view/cloud-native-go/9781492076322/" rel="noopener ugc nofollow" target="_blank">云原生Go </a>，它用Go的好处流畅地介绍了云原生世界。这本书从Go基础知识和云原生模式开始，这就是我认为“我应该写这些模式的地方！”。</p><p id="26e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一系列的博客文章中，我将写下我所学到的云的原生模式——还会用<a class="ae lb" href="https://www.manim.community/" rel="noopener ugc nofollow" target="_blank"> Manim </a>来举例说明。</p><h1 id="099a" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">问题是</h1><p id="6bea" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">假设我们有一个常量数据源(比如一个Go <a class="ae lb" href="https://go.dev/tour/concurrency/2" rel="noopener ugc nofollow" target="_blank">通道</a>，我们需要处理数据，并将处理后的数据放入一个延迟尽可能低的目的通道。</p><p id="040e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在一般情况下，我们有一个位于源和目的地中间的处理器功能，它一个接一个地处理数据包(为简单起见，这里的数据包是一个抽象)。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/139da10e4523d62fa3aa7dd83ad0ead6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xCwlJeRJsFeZK1Ju.gif"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">单处理器数据流水线动画</p></figure><p id="faa4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，每个处理功能都有延迟。这可能是因为网络或CPU的使用、阻塞系统调用等。如果我们每秒向处理器函数发送足够多的数据包，瞧！我们现在有一个瓶颈！</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/e5db286c56120bdd3ee5559796b52531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oJfWdO4kE8PLUfsD.gif"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">具有拥塞的单处理器数据流水线的动画</p></figure><h1 id="b6fd" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">解决办法</h1><p id="a546" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">这个问题有一个相当简单的解决方案:在数据管道中使用多个处理器。这样，我们可以同时处理数据流，从而降低整体延迟并减少管道拥塞。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/44f3d39f8d3316483d3559db36e6d8bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aOaoWxEL3DDDeTTi.gif"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">多处理器数据流水线动画</p></figure><h1 id="ab1e" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">这就是扇入和扇出的由来…</h1><p id="6074" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们可以通过利用共享内存(比如消息队列)来实现这个解决方案。</p><p id="bafe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这种方法，我们将把传入的数据包分成不同的输入队列。然后，每个队列自己的处理器将逐个获取数据包，处理数据，并将处理后的数据放入其相关的输出队列中。最后，目的地(另一个处理器、队列或一些其他系统)将从每个输出队列中获取处理过的数据包，并将它们聚合到单个数据源中。</p><p id="344a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一种方法，将数据源(输入)分割成多个数据源(输入队列)，称为<code class="fe mp mq mr ms b">Fan-out</code>模式。第二种，将多个数据源(输出队列)聚合成一个数据源(目的地)称为<code class="fe mp mq mr ms b">Fan-in</code>模式。</p><blockquote class="mt mu mv"><p id="29fa" class="kf kg mw kh b ki kj jr kk kl km ju kn mx kp kq kr my kt ku kv mz kx ky kz la ij bi translated"><em class="iq">为了简单起见，我们为管道中的每个处理器指定了一个输入队列和一个输出队列。根据整个系统的需求，我们可以在每个处理器上使用多个输入/输出队列，或者在几个处理器之间使用一个共享队列。</em></p></blockquote><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/9905a6e6387723495a3b17d46537bbcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FU8PtgiXZZq_3s6M.gif"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">具有输入和输出队列(通道)的多处理器数据流水线的动画</p></figure><h1 id="b866" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">Go实现</h1><p id="b157" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">让我们用一些并行的Go弄脏我们的手！首先，让我们定义我们的数据源:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="6ba5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数<code class="fe mp mq mr ms b">stringGenerator</code>创建一个只接收字符串的通道，创建一个<a class="ae lb" href="https://go.dev/tour/concurrency/1" rel="noopener ugc nofollow" target="_blank"> goroutine </a>将前缀字符串放入通道，并返回通道。我们在后面的扇出代码中读到了这个通道。</p><p id="b005" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的处理器功能也相当简单:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="eac6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在处理器函数内部，我们将随机等待一段时间来模拟处理器延迟。</p><h1 id="f1cc" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">扇出实现</h1><p id="d760" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在扇出实现中，我们将采用一个只收通道，并返回一部分只收通道:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ede6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mp mq mr ms b">Splitter</code>函数中创建的Goroutines将处理数据路由逻辑。注意，在goroutines中，我们使用了一个单一的<code class="fe mp mq mr ms b">range</code>语句来从<code class="fe mp mq mr ms b">source</code>通道接收:</p><pre class="ma mb mc md gt nc ms nd bn ne nf bi"><span id="b836" class="ng ld iq ms b be nh ni l nj nk">for data := range source {<br/> dest &lt;- data<br/>}</span></pre><p id="c699" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着每个goroutine将尝试从循环中的通道读取，第一个读取的将接收下一个项目。换句话说，<strong class="kh ir">每个goroutine将争夺下一个数据实例</strong>。</p><p id="7af5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用一个集中的解决方案来实现扇出，而不是相互竞争的goroutines。在这种情况下，我们将定义一个<code class="fe mp mq mr ms b">master process</code>在所有输出通道中分配每个输入数据实例(在我们的例子中是<code class="fe mp mq mr ms b">string</code>)。</p><h1 id="d645" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">扇入实现</h1><p id="bb9a" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在扇入中，我们将基本上执行与扇出相反的操作，有一些不同之处:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="da67" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mp mq mr ms b">Aggregator</code>函数获取一部分只接收输入源，并返回一个只接收输出通道。在内部，我们为每个输入源创建了一个goroutine，它不断地从源读取数据，并用接收到的数据填充输出通道(<code class="fe mp mq mr ms b">destination</code>)。</p><p id="2307" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我们使用了一个<code class="fe mp mq mr ms b">sync.WaitGroup</code>来等待聚合器goroutines完成。输入源(<code class="fe mp mq mr ms b">channel</code>)关闭后，各goroutine内的for循环将结束，并完成其工作。</p><p id="a51d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关闭所有输入源后，我们就完成了聚合，现在可以关闭目标通道了。<strong class="kh ir">这是至关重要的一步</strong>，如果我们不关闭我们创建的通道，Go运行时将报错一个致命错误:</p><pre class="ma mb mc md gt nc ms nd bn ne nf bi"><span id="7308" class="ng ld iq ms b be nh ni l nl nk">fatal error: all goroutines are asleep - deadlock!</span></pre><h1 id="52f2" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">主()</h1><p id="6846" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">把我们所有的函数放在一起，我们准备运行我们的代码:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="8338" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="5bd2" class="nm nn iq kh b ki lu kl lv ko no ks np kw nq la nr ns nt nu bi translated">单处理器的数据流水线最终会遇到瓶颈</li><li id="2e20" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated">将输入源分成几个队列并同时处理是很有帮助的</li><li id="6fed" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated">这种拆分-处理-聚合模式称为扇入/扇出</li></ul><p id="adaf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读。</p><pre class="ma mb mc md gt nc ms nd bn ne nf bi"><span id="0753" class="ng ld iq ms b be nh ni l nl nk"><strong class="ms ir">Want to Connect?</strong><br/><br/>This story was originally posted at https://www.sazak.io/cloud-native-patterns-illustrated-fan-in-and-fan-out/</span></pre></div></div>    
</body>
</html>