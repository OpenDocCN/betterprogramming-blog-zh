<html>
<head>
<title>Random Numbers and Card Shuffling Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">随机数和洗牌算法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/random-numbers-and-card-shuffling-algorithms-f05e527d65f5?source=collection_archive---------13-----------------------#2020-02-20">https://betterprogramming.pub/random-numbers-and-card-shuffling-algorithms-f05e527d65f5?source=collection_archive---------13-----------------------#2020-02-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b79b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">伪随机数与真随机数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/adc2ffc9fb0581b1a6c65acac20879eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gtLUeOMnS1uFeblgkbCQkw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">unsplash.com<a class="ae ky" href="https://unsplash.com/@originspoker" rel="noopener ugc nofollow" target="_blank">@ origin spoker</a></p></figure><p id="d0cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随机数代表不确定性，在计算世界中广泛使用——在加密密钥、密码生成、模拟和游戏中。一些经典的随机化算法(如<a class="ae ky" href="https://en.wikipedia.org/wiki/Monte_Carlo_algorithm" rel="noopener ugc nofollow" target="_blank">蒙特卡罗算法</a>)也依赖于随机数生成。</p><p id="1f8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将讨论随机数是如何产生的，以及如何使用随机数洗牌。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8424" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">随机数生成</h1><p id="089f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">实际上，仅通过计算机生成随机数存在一些困难。</p><p id="bfcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算机擅长执行确定的任务，并根据程序运行编码指令。</p><p id="08ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算机生成的随机数有两种:真随机数和伪随机数，各有优缺点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="df2b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">伪随机数发生器(PRNG)</h1><p id="cd0a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">顾名思义，一个伪随机数<em class="mz">在严格的数学意义上并不是真正的随机</em>，一般是通过某种数学公式(或计算表)生成的。</p><p id="4f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，一个简单的<a class="ae ky" href="https://en.wikipedia.org/wiki/Linear_congruential_generator" rel="noopener ugc nofollow" target="_blank">线性同余发生器</a>可以用来产生伪随机数。</p><p id="440f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看Borland的随机数生成器:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="83f4" class="nf md it nb b gy ng nh l ni nj">long long RandSeed = 0xdeadbeaf ; // initialize a random seed<br/>unsigned long Random(long max)<br/>{<br/>    long long x ;<br/>    double i ;<br/>    unsigned long final ;<br/>    x = 0xffffffff;<br/>    x += 1 ;</span><span id="dea1" class="nf md it nb b gy nk nh l ni nj">    RandSeed *= ((long long)134775813);<br/>    RandSeed += 1 ;<br/>    RandSeed = RandSeed % x ;<br/>    i = ((double)RandSeed) / (double)0xffffffff ;<br/>    final = (long) (max * i) ;</span><span id="3756" class="nf md it nb b gy nk nh l ni nj">    return (unsigned long)final;<br/>}</span></pre><p id="b85e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe nl nm nn nb b">RandSeed</code>每一代都会更新。</p><p id="26ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PRNG的结果在统计意义上是随机的。伪随机数的行为是<em class="mz">可预测的</em>，这意味着如果我们知道PRNG的当前状态，我们就可以得到下一个随机数。</p><p id="380c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，伪随机数可以具有固定的周期。比如下面两张位图，分别是Windows下的一个真随机数生成器和一个PHP伪随机数生成器生成的。用伪随机发生器产生的右边一个具有明显的图案。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/d2ed850bb52229664aa9ff0f5f4d298d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/0*tidYRuZgUkahniD7.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">random.org</p></figure><p id="ddd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于它的上述特性，伪随机生成的使用受到限制——它主要被用于仿真等程序中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6294" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">真随机数发生器(RNG)</h1><p id="6f62" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">“真正的”随机数发生器(RNG)是通过向计算机引入一些真正不可预测的物理噪声，如键盘敲击或鼠标移动而制成的。这就是所谓的<code class="fe nl nm nn nb b">entropy</code>。真正的随机数很难预测或者根本不可预测。</p><p id="4a14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个操作系统的实现是不同的。在Linux上，所有随机性的根源是一种叫做<code class="fe nl nm nn nb b">kernel entropy pool</code>的东西。</p><p id="5123" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<a class="ae ky" href="https://www.apple.com/" rel="noopener ugc nofollow" target="_blank"> MAC </a>地址可用于初始化熵池，其他随机来源包括中断时间、硬盘寻址时间等。</p><p id="251c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接口有<code class="fe nl nm nn nb b">/dev/random</code>、<code class="fe nl nm nn nb b">/dev/urandom</code>、<code class="fe nl nm nn nb b">get_random_bytes</code>。<code class="fe nl nm nn nb b">/dev/random</code>和<code class="fe nl nm nn nb b">/dev/urandom</code>的区别在于<code class="fe nl nm nn nb b">/dev/random</code>更强，阻挡更多，因为需要收集更多的熵。而<code class="fe nl nm nn nb b">get_random_bytes</code>用在内核代码中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ce9b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">随机数的使用</h1><p id="e2bc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">涉及随机数的程序需要特别小心。</p><p id="bca7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们写一个简单的程序。我们知道C编程语言中<code class="fe nl nm nn nb b">rand()</code>产生的随机数有一个范围<code class="fe nl nm nn nb b">0~32767</code>。我们怎么写一个函数在<code class="fe nl nm nn nb b">0~10</code>的范围内生成一个随机数？</p><p id="ebd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许你干脆想出这个解决方案:<code class="fe nl nm nn nb b">rand()%10</code>。我以前也用过这种方法，但它真的是随机的吗？</p><p id="22b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果用<code class="fe nl nm nn nb b">%10</code>的运算把0到32767的所有数字放在一起，可以看到有些数字出现的频率更高，所以有些数字出现在最后的概率相应更大。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="15c2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">洗牌算法</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/9d56f1c4d6ffb59abf6c38d1bc13bf99.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/0*7LQ7XNdPPv4m-xrS.png"/></div></figure><p id="975a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写一个合适的洗牌程序似乎很容易，但事实并非如此。</p><blockquote class="nq nr ns"><p id="7980" class="kz la mz lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated"><em class="it">如果你正在实施在线扑克游戏，这是一件非常困难的事情。你可能要确保，如果你在广告中说你在随机洗牌，你会继续这样做。</em></p><p id="d868" class="kz la mz lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated"><em class="it"> —罗伯特·塞奇威克，计算机科学教授</em></p></blockquote><p id="8258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ASF Software在多年前编写了一个流行的在线扑克游戏，其中的洗牌程序是这样的Pascal代码:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9cd4" class="nf md it nb b gy ng nh l ni nj">procedure TDeck.Shuffle;<br/>var<br/>   ctr: Byte;<br/>   tmp: Byte;<br/>   random_number: Byte;<br/>begin<br/>   { Fill the deck with unique cards }<br/>   for ctr := 1 to 52 do<br/>      Card[ctr] := ctr;<br/>   { Generate a new seed based on the system clock }<br/>   randomize;<br/>   { Randomly rearrange each card }<br/>   for ctr := 1 to 52 do begin<br/>      random_number := random(51)+1;<br/>      tmp := card[random_number];<br/>      card[random_number] := card[ctr];<br/>      card[ctr] := tmp;<br/>   end;<br/>   CurrentCard := 1;<br/>   JustShuffled := True;<br/>end;</span></pre><p id="414b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们只看核心洗牌算法(注意数组的索引在Pascal中从1开始):</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="3e7c" class="nf md it nb b gy ng nh l ni nj">for (i is 1 to N)<br/>  j = random integer that 1 &lt;= j &lt;= N<br/>  Swap a[i] with a[j]</span></pre><p id="b542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的洗牌算法有一个问题——<code class="fe nl nm nn nb b">52!</code>排列的概率不同。</p><p id="b453" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们以1、2、3三张卡为例。这是三次迭代后的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/ab07cf3b6f2b3b838ce65d37ebd31cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/0*Zv0vgYMUqcpofs7d.gif"/></div></figure><p id="cd72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到<code class="fe nl nm nn nb b">231</code>、<code class="fe nl nm nn nb b">213</code>、<code class="fe nl nm nn nb b">132</code>出现的频率更高，所以对应的概率也更大。</p><p id="d4d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种简单而优雅的洗牌算法被称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" rel="noopener ugc nofollow" target="_blank"> Fisher-Yates </a>算法:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9b09" class="nf md it nb b gy ng nh l ni nj">for (i is 1 to N)<br/>  j = random integer that i &lt;= j &lt;= N // (not 1 &lt;= j &lt;= N here!)<br/>  Swap a[i] with a[j]</span></pre><p id="0d48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述程序中的另一个问题很难发现。用作种子的32位数字对于伪随机发生器是有问题的，因为给定伪随机发生器的行为是可预测的。</p><p id="455f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">32个种子的可能值的数量是<code class="fe nl nm nn nb b">2^32</code>，比<code class="fe nl nm nn nb b">52!(8.0658 * 10^67)</code>小得多。所以你甚至可以用蛮力破解一个32位的种子。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="176f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">一些随机数练习</h1><h2 id="429a" class="nf md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">1.生成一个范围内的随机数</h2><p id="735d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">给你一个<code class="fe nl nm nn nb b">rand()</code>，它可以在<code class="fe nl nm nn nb b">[1, 5]</code>之间生成随机整数。如何用这个函数生成<code class="fe nl nm nn nb b">[1, 7]</code>之间的随机整数？</p><h2 id="a986" class="nf md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">2.彩票计划</h2><p id="55c2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">写一个抽奖程序，从30w用户中随机抽取10w中奖用户。</p><h2 id="4a7f" class="nf md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">3.平均工资(开放式问题)</h2><p id="073b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有10个人围坐在一张桌子旁，他们想知道平均年薪，但他们都不愿意向别人透露自己的薪水。</p><p id="8ae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有没有办法让他们得到答案，而不把任何人的工资暴露给别人？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="60ce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><p id="39f6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Random_number_generation" rel="noopener ugc nofollow" target="_blank"> Wiki:随机数生成。</a></p><p id="0d8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们是如何学会在网上扑克中作弊的:一项软件安全研究。</p><p id="f007" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">罗伯特·塞奇威克的算法。</p></div></div>    
</body>
</html>