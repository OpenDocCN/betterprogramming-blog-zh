<html>
<head>
<title>Sorting and Filtering Records Using Room DataBase and Kotlin Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用房间数据库和Kotlin流程对记录进行分类和过滤</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sorting-and-filtering-records-using-room-database-and-kotlin-flow-c64ccdb39deb?source=collection_archive---------3-----------------------#2021-10-12">https://betterprogramming.pub/sorting-and-filtering-records-using-room-database-and-kotlin-flow-c64ccdb39deb?source=collection_archive---------3-----------------------#2021-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5c8c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">轻松构建反应式Android应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8b8edfd3eb29bdd224c2941a9e1cc092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9vszp4UUwikMRcxI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="cfb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，您将学习如何对本地存储记录实现排序和过滤功能。在这里，我们使用科特林流使事情反应和高效。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="27a0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">介绍</h1><p id="246e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在2021年的android开发中，使用Room library进行本地存储是非常标准的做法。房间数据库很酷的一点是它支持跨协程和Rxjava，我最喜欢的是带有Kotlin流的房间数据库。一个简单的方法，使Android应用程序简洁和反应。</p><p id="5275" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是房间数据库的新手，我强烈推荐您阅读下面的文章，从基础到高级了解您需要了解的一切:</p><ul class=""><li id="28c1" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><a class="ae ky" href="https://medium.com/@sgkantamani/android-room-persistence-library-kotlin-coroutines-26d53a09d384" rel="noopener">《安卓房间持久性库》🔗科特林协程</a><strong class="lb iu"/></li><li id="825c" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" href="https://medium.com/better-programming/how-to-use-the-room-persistence-library-with-kotlin-flow-c73f461a0819" rel="noopener">“如何通过Kotlin流使用房间持久性库”</a></li></ul><p id="7c79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然您是房间数据库方面的专家，那么是时候探索实现一些高级但常见的功能了，比如通过房间数据库进行排序和过滤。使代码高效和可维护的四件事。</p><ol class=""><li id="a989" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu nn nf ng nh bi translated">排序和过滤应该由房间数据库完成，我们的视图模型或repos不应该有任何相关的逻辑。</li><li id="2c64" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu nn nf ng nh bi translated">事情可以是任意组合——用户可能想要过滤和排序或者只排序或者只过滤。实现应该支持所有可能的情况。</li><li id="b75f" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu nn nf ng nh bi translated">实现应该简洁明了。</li><li id="72eb" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu nn nf ng nh bi translated">UI应该一直与数据库同步。假设如果添加或删除任何新记录，它应该反映在UI上，而不需要考虑现有条件的任何额外工作。</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7b03" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">房间实体</h1><p id="509a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">就本文而言，假设我们正在构建一个订阅应用程序，用户可以在其中保存他们的订阅列表，包括名称、金额、类别等细节(从现在开始我们称之为标签)。所以我们有两个实体类— <code class="fe no np nq nr b">Subscription</code>和<code class="fe no np nq nr b">Label</code>。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f832" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">房间叠纸</h1><p id="6e7a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">数据访问对象(Dao)是我们编写SQL可以理解的与房间数据库相关的查询的地方。这里我们需要实现与过滤和排序相关的查询。排序有两种变体:升序和降序。</p><h2 id="b3ff" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">过滤器</h2><p id="e4a0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，让我们创建一个简单的过滤查询，我们使用房间提供的<code class="fe no np nq nr b">WHERE</code>和<code class="fe no np nq nr b">IN</code>操作符:</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="017b" class="nu md it nr b gy ok ol l om on">@Query("SELECT * FROM Subscription WHERE lableId IN (:lableID)")<br/>fun getLabledSubscriptions(lableID : Int): Flow&lt;List&lt;Subscription&gt;&gt;</span></pre><p id="f9c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将返回类型保持为flow会使您的android应用程序对房间数据库中的更改做出反应。</p><h2 id="3a09" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">分类</h2><p id="0342" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来，我们将讨论简单排序，正如我所说，排序有两种变体。所以我们有两个函数——一个用于名称，另一个用于数量。为了方便起见，每个函数都将Int作为输入。</p><ul class=""><li id="cea7" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">如果输入是1，那么我们将按升序排序。</li><li id="3dfa" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">如果输入是2，那么我们将降序排列。</li></ul><p id="35a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用<code class="fe no np nq nr b">ORDER BY</code>与<code class="fe no np nq nr b">CASE</code>和<code class="fe no np nq nr b">WHEN</code>的组合:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">排序查询</p></figure><h2 id="c451" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">过滤和排序组合</h2><p id="8d38" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这很简单，我们将上面的两个查询组合起来，再创建两个查询，对名称和金额进行过滤和排序。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用排序查询进行筛选</p></figure><p id="71c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们对复杂事物的第一部分所做的全部工作，接下来是流程和视图模型的复杂性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b6f3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">视图-模型+流程</h1><p id="7ce7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">非常重要的是，在进一步学习之前，你要对这两件事有一个基本的了解。因此，如果您是第一次接触它们，请在继续之前阅读以下文章:</p><ul class=""><li id="f320" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/introducing-coroutines-stateflow-ca1b13133265">“协程StateFlow简介”</a></li><li id="eec3" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/best-practices-for-using-viewmodels-in-android-e986b25dc78f">“在Android中使用视图模型的最佳实践”</a></li></ul><p id="9f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们进入逻辑部分:</p><h2 id="2e20" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">分类</h2><p id="5f77" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我们有两个枚举类来表示</p><ul class=""><li id="b01f" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">排序类型(升序、降序或无)</li><li id="8560" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">排序字段(名称、金额或无)</li></ul><p id="6184" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一看:</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="0610" class="nu md it nr b gy ok ol l om on">enum class SortType {<br/>    <em class="oo">ASCENDING</em>, <em class="oo">DESCENDNG</em>, <em class="oo">NONE<br/></em>}<br/><br/>enum class SortField {<br/>    <em class="oo">NAME</em>, <em class="oo">AMOUNT</em>, <em class="oo">NONE<br/></em>}</span></pre><h2 id="ed28" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">可变状态流和实时数据</h2><p id="0279" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们必须创建一个科特林<code class="fe no np nq nr b">triple</code>类型的<code class="fe no np nq nr b">MutableStateFlow</code> <em class="oo"> </em>。科特林三元组只不过是价值的三元组。这里，值的类型将是<code class="fe no np nq nr b">SortField</code>、SortType和Int(要过滤的标签id)。看一看</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="64bf" class="nu md it nr b gy ok ol l om on">var lbaleID : Int? = null<br/>val sortFlow = <em class="oo">MutableStateFlow</em>(Triple(SortField.<em class="oo">NONE</em>,SortType.<em class="oo">NONE</em>,lbaleID))</span></pre><p id="6054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我个人觉得不太喜欢用<code class="fe no np nq nr b">MutableStateFlow</code>来连接UI，所以用<em class="oo"> </em> <code class="fe no np nq nr b">asLiveData</code> <em class="oo"> </em>扩展函数把<code class="fe no np nq nr b">MutableStateFlow</code> <em class="oo"> </em>转换成<em class="oo"> </em> <code class="fe no np nq nr b">LiveData</code> <em class="oo">。一旦你完成了视图模型中的逻辑，就会看到其中的编码部分。</em></p><h2 id="0272" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">平面地图最新</h2><p id="722d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe no np nq nr b">flatMapLatest</code>返回一个流，每当原始流发出一个值时，该流切换到由转换函数产生的新流。当原始流发出新值时，由转换块产生的前一个流被取消。</p><p id="1246" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，原始流是— <code class="fe no np nq nr b">sortFlow</code>，转换函数将是房间数据库查询的执行。因此，当我们对<code class="fe no np nq nr b">sortFlow</code>应用<code class="fe no np nq nr b">flatMapLatest</code>时，在lambda中，你将始终获得三个字段的最新值。这是我们相应地执行查询和恢复列表的地方。返回类型将是带有<code class="fe no np nq nr b">Subscription</code>列表类型的<code class="fe no np nq nr b">Flow</code>。</p><p id="eede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来到lambda逻辑，使用第一个参数，我们确定需要确定哪一个字段是哪种过滤器。然后第二个参数用于定义排序类型，最后，第三个参数指示我们是否需要过滤带有任何标签<code class="fe no np nq nr b">id</code>的列表。看一下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">filter map用于排序和筛选列表的最新逻辑</p></figure><p id="3abf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们处理从房间获得数据和更新条件的流动时，几乎所有的东西都是反应性的。现在是时候从视图中观察这一点了，正如我说过的，我不喜欢视图中的流，所以它被转换为实时数据。</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="99b7" class="nu md it nr b gy ok ol l om on">@ExperimentalCoroutinesApi<br/>val subscriptionsList = subscriptionsListFlow.<em class="oo">asLiveData</em>()</span></pre><h2 id="209a" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">从视野中观察</h2><p id="e045" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">基本上最难的部分已经完成了，如果你正在使用Jetpack Compose，我推荐使用<code class="fe no np nq nr b">observeAsState</code>来让事情变得更有反应性。如果你使用传统的用户界面，那么你可以观察来自android组件的实时数据。</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="6df7" class="nu md it nr b gy ok ol l om on">val data  = subscriptionsListViewmodel<br/>    .subscriptionsList.<strong class="nr iu"><em class="oo">observeAsState</em></strong>(<em class="oo">emptyList</em>&lt;Subscription&gt;())</span></pre><h2 id="fad4" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">Lambda更新排序</h2><p id="6c43" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要根据用户选择更新排序或过滤器，您可以在视图模型中创建一个简单的lambda，并更新sortFlow，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更新排序和筛选选项</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1962" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="42fc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读。如果你喜欢看这篇文章的视频格式，这里是YouTube视频:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op nt l"/></div></figure></div></div>    
</body>
</html>