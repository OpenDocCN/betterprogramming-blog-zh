<html>
<head>
<title>Stop Using “or” to Check Multiple Conditions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中停止使用“或”来检查多个条件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stop-using-or-to-check-multiple-conditions-in-python-404d31f2b569?source=collection_archive---------0-----------------------#2021-12-24">https://betterprogramming.pub/stop-using-or-to-check-multiple-conditions-in-python-404d31f2b569?source=collection_archive---------0-----------------------#2021-12-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6b79" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有一个更复杂的解决方案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/61dd4b58f26be29897ca89864eb99d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jnbER5LOJP5R5Fr0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@karsten116?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡斯滕·怀恩吉尔特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="75db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们都熟悉使用这两条线来检查一个变量是否满足一个或多个等式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="ba87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有比这种编码方式更自然的了，也就是说，用<code class="fe lx ly lz ma b">or</code>逻辑运算符分隔每个条件。但这并不是故事的全部。</p><p id="d73e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我在文章开头所说，有一个复杂的解决方案。这也可能是一个更好的解决方案，或者不是。这取决于你的方面和你如何定义‘更好’。我将给出几种方法，并分析它们的优缺点。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="ad52" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">Python中的“in”运算符</h1><p id="ab72" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated"><code class="fe lx ly lz ma b">in</code>关键字在Python中主要有两种用法:</p><p id="4410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1:遍历序列:</p><p id="387c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例如:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="d7c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结果:</strong></p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="8844" class="nj mj it ma b gy nk nl l nm nn">winter<br/>spring<br/>summer<br/>autumn</span></pre><p id="32fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2: <strong class="lb iu"> </strong>检查一个值是否存在于一个序列(字符串、元组、列表等)中。)还是没有。根据一个值的存在，返回<code class="fe lx ly lz ma b">True</code>或<code class="fe lx ly lz ma b">False</code>。</p><p id="de0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例1: </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="4c56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结果:</strong></p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="1128" class="nj mj it ma b gy nk nl l nm nn">True<br/>False</span></pre><p id="de86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例二:</strong></p><p id="8456" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们来看看这一节的副标题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="4bac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结果:</strong></p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="4f9c" class="nj mj it ma b gy nk nl l nm nn">True</span></pre><p id="9fff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把目前为止学到的所有东西放在一起，看看优雅的解决方案。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="9c89" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">用“in”代替“or”</h1><p id="b34c" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">这是我们的第一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="8b4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将用<code class="fe lx ly lz ma b">in</code>关键字来改进这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="1c98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着如果列表中存在<code class="fe lx ly lz ma b">number</code>，则满足条件并执行<code class="fe lx ly lz ma b">do_smt()</code>。换句话说，如果<code class="fe lx ly lz ma b">number</code>等于<strong class="lb iu">列表中的任意一个</strong>值，<code class="fe lx ly lz ma b">do_smt()</code>就会运行。请注意，最后一句中的<strong class="lb iu">【任何】</strong>与<strong class="lb iu">或</strong>具有完全相同的含义和功能。这就是为什么可以用<code class="fe lx ly lz ma b">in</code>代替<code class="fe lx ly lz ma b">or</code>——两者的目的相同。</p><p id="5d47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我能听到你。你说，等一下！</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="a650" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">为什么以及何时我们应该选择“in”而不是“or”</h1><p id="ff84" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">复杂的解决方案不是很容易理解吗？是的，它是！看那，我们能容易地跟随条件。在多条件的情况下，使用<code class="fe lx ly lz ma b">in</code>关键字会大大增加可读性。</p><p id="ecd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如在<a class="ae ky" href="https://www.django-rest-framework.org/" rel="noopener ugc nofollow" target="_blank">Django REST Framework(DRF)</a>中，如果要测试一个请求是否是只读操作，只要检查请求的HTTP方法(<code class="fe lx ly lz ma b">request.method</code>)是否存在于<code class="fe lx ly lz ma b">SAFE_METHODS</code>中就可以了，T1不过是一个包含<code class="fe lx ly lz ma b">"GET"</code>、<code class="fe lx ly lz ma b">"HEAD"</code>、<code class="fe lx ly lz ma b">"OPTIONS"</code>的元组。</p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="9419" class="nj mj it ma b gy nk nl l nm nn"><strong class="ma iu">if</strong> request.method <strong class="ma iu">in</strong> permissions.SAFE_METHODS:<br/>    # Whether it is a read-only request</span></pre><p id="7657" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们显式地编写<code class="fe lx ly lz ma b">permissions.SAFE_METHODS</code>以便更好地理解:</p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="7877" class="nj mj it ma b gy nk nl l nm nn"><strong class="ma iu">if</strong> request.method <strong class="ma iu">in</strong> ("GET", "HEAD", "OPTIONS"):<br/>    # Whether it is a read-only request</span></pre><p id="3d1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阅读和遵循条件的目的是如此简单。我们很容易看出有多少个条件，它们是什么。如果我问你这里检查哪些条件，你可以很容易地回答这个问题。</p><p id="5dc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用<code class="fe lx ly lz ma b">or</code>的情况下，我们需要这样写:</p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="e061" class="nj mj it ma b gy nk nl l nm nn"><strong class="ma iu">if</strong> request.method == "GET" <strong class="ma iu">or</strong> request.method == "HEAD" <strong class="ma iu">or</strong> request.method == "OPTIONS":<br/>    # Whether it is a read-only request</span></pre><p id="4cc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就可读性而言，最后一个好像不太友好，因为有重复，而且是很长的一行！现在，我问你前一个问题，你再回答这个问题，但是要多花一点时间。对吗？</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="e34f" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">这个解决方案真的是最好的吗？</h1><p id="4bf1" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">看你怎么定义<strong class="lb iu">“最好”</strong>。如果你在寻找可读性，很明显<code class="fe lx ly lz ma b">in</code>是这里最好的<strong class="lb iu"/>。如果您追求的是性能或内存呢？</p><p id="fd54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在使用<code class="fe lx ly lz ma b">in</code>时，我们不应该只局限于一种数据类型。我们来看看<code class="fe lx ly lz ma b">list</code>、<code class="fe lx ly lz ma b">tuple</code>、<code class="fe lx ly lz ma b">set</code>。</p><h2 id="c4b9" class="nj mj it bd mk no np dn mo nq nr dp ms li ns nt mu lm nu nv mw lq nw nx my ny bi translated">比较执行时间</h2><p id="6b5d" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我将使用<a class="ae ky" href="https://docs.python.org/3/library/timeit.html" rel="noopener ugc nofollow" target="_blank"> timeit </a>模块来测量执行时间。我们将比较4种不同的用法。所以这将是<strong class="lb iu"> 1 </strong> ( <code class="fe lx ly lz ma b">or</code> ) <strong class="lb iu">对3 </strong> ( <code class="fe lx ly lz ma b">in</code>代表<code class="fe lx ly lz ma b">list</code>、<code class="fe lx ly lz ma b">tuple</code>和<code class="fe lx ly lz ma b">set</code>)。</p><p id="1062" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文其余部分的顺序也是一样的:</p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="ad3e" class="nj mj it ma b gy nk nl l nm nn">in [] - list<br/>in () - tuple<br/>in {} - set<br/>or</span></pre><p id="d15b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我会执行每一个<code class="fe lx ly lz ma b">100000</code>次。此外，我决定重命名请求的HTTP方法<code class="fe lx ly lz ma b">method</code>，因为它更短。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="9bd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结果:</strong></p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="4a8e" class="nj mj it ma b gy nk nl l nm nn">0.0018657920008990914<br/>0.0018152919947169721<br/>0.00212829202064313<br/>0.0020830420253332704</span></pre><p id="0c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使我执行了语句<code class="fe lx ly lz ma b">100000</code>次，仍然很难决定哪个更好，但是我们可以说元组稍微好一点。</p><p id="9f8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:<code class="fe lx ly lz ma b">timeit.timeit</code>内的</strong> <code class="fe lx ly lz ma b">globals</code>参数用于访问全局命名空间中定义的变量。这样，我们就不会评估将<code class="fe lx ly lz ma b">"GET”</code>值赋给<code class="fe lx ly lz ma b">method</code>变量所需的时间。否则，我们需要修改它:</p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="b09a" class="nj mj it ma b gy nk nl l nm nn">print(timeit.timeit('method = "GET"; method in ["GET", "HEAD", "OPTIONS"]', globals=globals(), number=100000))</span></pre><p id="830a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想评估一个最坏的情况。这时会满足最后一个条件而不是第一个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="c14e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结果:</strong></p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="ebbb" class="nj mj it ma b gy nk nl l nm nn">0.0035216250689700246<br/>0.0032744579948484898<br/>0.002372542046941817<br/>0.007088540936820209</span></pre><p id="9eaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，<code class="fe lx ly lz ma b">sets</code>处于优势，<code class="fe lx ly lz ma b">or</code>表现最差。事实上，<code class="fe lx ly lz ma b">sets</code>与之前的结果相比没有太大的变化，因为<code class="fe lx ly lz ma b">sets</code>对于这个过程有<code class="fe lx ly lz ma b">O(1)</code>的时间复杂度:</p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="2b9d" class="nj mj it ma b gy nk nl l nm nn">x <strong class="ma iu">in</strong> list   ---&gt; O(n)<br/>x <strong class="ma iu">in</strong> tuple  ---&gt; O(n)<br/>x <strong class="ma iu">in</strong> set    ---&gt; O(1)</span></pre><p id="187a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，<code class="fe lx ly lz ma b">tuples</code>和<code class="fe lx ly lz ma b">lists</code>都有<code class="fe lx ly lz ma b">O(n)</code>时间复杂度来检查一个项目的存在。因此，如果我们真的关心时间，使用<code class="fe lx ly lz ma b">set</code>作为数据收集是有益的。它在一天结束时具有<code class="fe lx ly lz ma b">O(1)</code>时间复杂性。</p><h2 id="4b5c" class="nj mj it bd mk no np dn mo nq nr dp ms li ns nt mu lm nu nv mw lq nw nx my ny bi translated">比较内存使用情况</h2><p id="ff74" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们可以使用<code class="fe lx ly lz ma b">sys.getsizeof()</code>来计算对象的内存消耗。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="fdbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结果:</strong></p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="1abe" class="nj mj it ma b gy nk nl l nm nn">120<br/>64<br/>216</span></pre><p id="15bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就内存而言，元组比其他数据容器更好。然而，当我们使用<code class="fe lx ly lz ma b">or</code>时，我们不创建任何序列，所以<code class="fe lx ly lz ma b">or</code>是内存竞争的赢家！</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="fc66" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结论</h1><p id="82ae" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">使用<code class="fe lx ly lz ma b">in</code>是检查多个条件的时髦方式。它使您的代码更具可读性和可维护性。我更喜欢将<code class="fe lx ly lz ma b">in</code>与<code class="fe lx ly lz ma b">sets</code>一起使用，因为在考虑性能时<code class="fe lx ly lz ma b">in</code>关键字更有优势。这也向其他程序员表明，您有时间顾虑，所以您决定使用具有<code class="fe lx ly lz ma b">O(1)</code>时间复杂性的数据类型。如果您的项目(如嵌入式系统)内存有限，在这种情况下使用<code class="fe lx ly lz ma b">tuple</code>是有意义的。让我们从现在开始去掉<code class="fe lx ly lz ma b">or</code>用<code class="fe lx ly lz ma b">in</code>！</p><p id="3e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢我的文章。您可能也会对这个感兴趣:</p><div class="nz oa gp gr ob oc"><a rel="noopener  ugc nofollow" target="_blank" href="/3-essential-decorators-in-python-you-need-to-know-654650bd5c36"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">你需要知道的Python中的3个基本装饰器</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">更擅长装饰</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">better编程. pub</p></div></div><div class="ol l"><div class="om l on oo op ol oq ks oc"/></div></div></a></div></div></div>    
</body>
</html>