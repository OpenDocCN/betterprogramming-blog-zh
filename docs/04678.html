<html>
<head>
<title>Consume Messages From Kafka Topics Using Python and Avro Consumer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和Avro Consumer消费来自Kafka主题的消息</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/consume-messages-from-kafka-topic-using-python-and-avro-consumer-eda5aad64230?source=collection_archive---------5-----------------------#2020-04-29">https://betterprogramming.pub/consume-messages-from-kafka-topic-using-python-and-avro-consumer-eda5aad64230?source=collection_archive---------5-----------------------#2020-04-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="33f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Kafka和Avro进行轮询和反序列化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5f98c9ab952a0e59bff23ec378cfbe69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-Ni0TGDTWtNYEQK2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安内特·lūsiņa在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a6d9" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">概观</h1><p id="d754" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这篇教程是对我最近写的另一篇关于如何为Kafka主题制作Avro唱片的教程<a class="ae ky" href="https://medium.com/@billydharmawan/avro-producer-with-python-and-confluent-kafka-library-4a1a2ed91a24" rel="noopener">的补充。</a></p><p id="62ba" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在本教程中，我们将学习如何编写一个Avro消费者，它能够轮询来自Kafka主题的消息，并根据Avro模式反序列化它们。</p><p id="5e6a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">你可以从这个GitHub <a class="ae ky" href="https://github.com/billydh/python-avro-producer/" rel="noopener ugc nofollow" target="_blank"> repo </a>下载代码。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ceee" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">Avro消费者</h1><p id="1b63" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">由于我们已经为Avro生产者在上述<a class="ae ky" href="https://github.com/billydh/python-avro-producer/" rel="noopener ugc nofollow" target="_blank">回购</a>的初始提交中做了大量工作，编写消费者相当简单。我们的生产者代码已经涵盖了所有的依赖项，所以我们可以马上开始。</p><p id="c682" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">当我们为Kafka主题生成Avro记录时，我们的生成器需要将Avro模式编码到其中，并将其序列化为一个字节数组。另一方面，当我们使用Avro记录时，我们的使用者需要对字节数组进行反序列化，并使用Avro模式将其解码为人眼可以阅读的文本或对象。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5317" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">从Kafka主题消费记录的函数</h1><p id="1584" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">好吧，让我们继续写我们的Avro消费者。新建一个名为<code class="fe mz na nb nc b">consumer_record.py</code>的Python文件，其内容如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">消费_记录. py</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="de04" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们看一下上面的代码，这样我们都明白发生了什么:</p><ul class=""><li id="a8ea" class="nf ng it ma b mb mu me mv mh nh ml ni mp nj mt nk nl nm nn bi translated">第7-14行:这里，我们基本上为我们的消费者设置了配置值——即引导服务器、模式注册URL、消费者组ID和自动偏移重置属性。auto-offset reset属性实际上是告诉我们的使用者应该从何时开始轮询记录。我们将它设置为<code class="fe mz na nb nc b">earliest</code>，这样它将从卡夫卡主题的开头开始消耗。如果我们将它设置为<code class="fe mz na nb nc b">latest</code>，并且在这个消费者初始化并订阅主题之前，主题中已经有一些消息，那么这些消息将被跳过。</li><li id="c148" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt nk nl nm nn bi translated">第16行:这是不言自明的。它告诉我们的消费者开始订阅给定的主题，以便稍后可以轮询消息。</li><li id="95b7" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt nk nl nm nn bi translated">第18-31行:这是我们告诉消费者从订阅的主题中轮询消息的地方。我们还设置了5秒的轮询超时(第19行)，这意味着如果5秒后没有消息，它将停止轮询。我们检查是否有消息，如果有，我们打印消息的键和值以及我们轮询它的分区号和偏移量。最后，我们提交偏移量，以便下一次运行同一个消费者时，它不会从偏移量0开始，而是从最后提交的偏移量开始。</li><li id="8898" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt nk nl nm nn bi translated">最后，如果没有消息，我们打印该信息并关闭消费者，因为不再需要它了。</li></ul><p id="3b67" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">注意:我们可以用不同的方式编写这部分代码，比如使用一个<code class="fe mz na nb nc b">while</code>循环，这样消费者就可以一直轮询和打印消息，直到没有消息为止。现在的编写方式意味着我们需要执行这个脚本的次数与主题中的消息总数一样多。同样，这只是为了演示如何编写Avro消费者，而不是编写生产级代码。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5026" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">修改函数以解析命令行参数</h1><p id="31cb" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">为了能够使用相同的<code class="fe mz na nb nc b">util</code>函数来解析命令行参数，我们需要对它进行一些调整。这是因为当最初编写它时，它需要传递以下参数:<code class="fe mz na nb nc b">--schema-file</code>和<code class="fe mz na nb nc b">--record-value</code>。我们的消费者代码不需要这两者。</p><p id="6fc7" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">对于我们的消费者，我们不需要<code class="fe mz na nb nc b">--schema-file</code>参数的原因是因为Avro模式是在模式注册表中注册的。这是我们的消费者获取模式的地方，因此它能够解码和反序列化来自主题的Avro记录。</p><p id="66a8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">对于<code class="fe mz na nb nc b">--record-value</code>，很明显，我们的消费者代码不需要它，因为我们没有为这个主题生产任何东西。</p><p id="b99b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">所以，这是我们最后的<code class="fe mz na nb nc b">parse_command_line_args.py</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">parse_command_line_args.py —已调整</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="98a9" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">调整Avro生产商代码</h1><p id="3611" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">由于<code class="fe mz na nb nc b">parse_command_line_args</code>函数的变化，我们需要对现有的生产者代码做一点调整。</p><p id="182b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">本质上，我们只需要在开始时添加检查，以确保提供了<code class="fe mz na nb nc b">--schema-file</code>和<code class="fe mz na nb nc b">--record-value</code>的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">send_record.py —已调整</p></figure><p id="028b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">好了，这就是我们需要做的。在下一节中，我们将测试我们的Avro消费者。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7e5d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">来自卡夫卡主题的消费记录</h1><p id="adf5" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">为了测试我们的消费者，我们需要做的第一件事是启动Docker容器，它将托管我们的Kafka引导服务器和模式注册表。你可以按照这个<a class="ae ky" href="https://medium.com/better-programming/your-local-event-driven-environment-using-dockerised-kafka-cluster-6e84af09cd95" rel="noopener">教程</a>和<a class="ae ky" href="https://medium.com/better-programming/adding-schema-registry-to-kafka-in-your-local-docker-environment-49ada28c8a9b" rel="noopener">这个</a>来设置Docker容器。</p><p id="eb8b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">一旦容器开始运行，我们就可以继续使用我们的生产者代码向Kafka主题发送一些记录。跟随这个<a class="ae ky" href="https://medium.com/@billydharmawan/avro-producer-with-python-and-confluent-kafka-library-4a1a2ed91a24'" rel="noopener">教程</a>了解如何做的细节。</p><p id="eac3" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们执行以下命令，将两条<em class="nt"> x </em>记录发送到<code class="fe mz na nb nc b">create-user-request</code>主题:</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="cce4" class="ny lh it nc b gy nz oa l ob oc">~/python-avro-producer ❯ python send_record.py --topic create-user-request --schema-file create-user-request.avsc --record-value '{"email": "<a class="ae ky" href="mailto:email@email.com" rel="noopener ugc nofollow" target="_blank">email@email.com</a>", "firstName": "Bob", "lastName": "Jones"}'<br/>Successfully producing record value - {'email': '<a class="ae ky" href="mailto:email@email.com" rel="noopener ugc nofollow" target="_blank">email@email.com</a>', 'firstName': 'Bob', 'lastName': 'Jones'} to topic - create-user-request</span><span id="3547" class="ny lh it nc b gy od oa l ob oc">~/python-avro-producer ❯ python send_record.py --topic create-user-request --schema-file create-user-request.avsc --record-value '{"email": "<a class="ae ky" href="mailto:email2@email.com" rel="noopener ugc nofollow" target="_blank">email2@email.com</a>", "firstName": "Jane", "lastName": "Smith"}'<br/>Successfully producing record value - {'email': '<a class="ae ky" href="mailto:email2@email.com" rel="noopener ugc nofollow" target="_blank">email2@email.com</a>', 'firstName': 'Jane', 'lastName': 'Smith'} to topic - create-user-request</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="24e0" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">酷毙了。现在，让我们执行我们的消费者代码，看看我们能否从Kafka主题中检索到这两条<em class="nt"> x </em>记录:</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="58cc" class="ny lh it nc b gy nz oa l ob oc">~/python-avro-producer ❯ python consume_record.py --topic create-user-request --schema-file create-user-request.avsc<br/>                                                          <br/>Successfully poll a record from Kafka topic: create-user-request, partition: 0, offset: 0<br/>message key: e76a0f7e-c6c1-4809-a562-da50b9126ef1 || message value: {'email': '<a class="ae ky" href="mailto:email@email.com" rel="noopener ugc nofollow" target="_blank">email@email.com</a>', 'firstName': 'Bob', 'lastName': 'Jones'}</span><span id="7c65" class="ny lh it nc b gy od oa l ob oc">~/python-avro-producer ❯ python consume_record.py --topic create-user-request --schema-file create-user-request.avsc</span><span id="b9d7" class="ny lh it nc b gy od oa l ob oc">Successfully poll a record from Kafka topic: create-user-request, partition: 0, offset: 1<br/>message key: 11142acb-d986-4570-9b16-b28b50accc46 || message value: {'email': '<a class="ae ky" href="mailto:email2@email.com" rel="noopener ugc nofollow" target="_blank">email2@email.com</a>', 'firstName': 'Jane', 'lastName': 'Smith'}</span></pre><p id="0d3a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">非常好。我们的Avro消费者工作正常。</p><p id="3e57" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在，如果我们再次尝试运行它，我们应该看不到任何消息，因为主题中只有两条消息:</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="aef5" class="ny lh it nc b gy nz oa l ob oc">~/python-avro-producer ❯ python consume_record.py --topic create-user-request --schema-file create-user-request.avsc</span><span id="d83b" class="ny lh it nc b gy od oa l ob oc">No messages at this point. Try again later.</span></pre><p id="2f04" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">干得好，各位。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="cbc6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">总结</h1><p id="9f8c" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">通过阅读本教程和<a class="ae ky" href="https://medium.com/@billydharmawan/avro-producer-with-python-and-confluent-kafka-library-4a1a2ed91a24" rel="noopener">上一篇</a>，我们将了解卡夫卡生产者和消费者是如何工作的。我希望这能鼓励你去探索更多关于卡夫卡和事件驱动架构的知识。</p></div></div>    
</body>
</html>