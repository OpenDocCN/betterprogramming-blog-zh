# 简介和应对缓存挑战的策略

> 原文：<https://betterprogramming.pub/introduction-and-strategies-to-handle-challenges-in-caching-c619d51882c0>

## 什么是缓存，它是如何工作的，以及您应该如何考虑它

![](img/37b116928aa26eaf4535ae04b0ccbb3a.png)

[自由股票](https://unsplash.com/@freestocks?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

# 什么是缓存？

在计算世界中，*缓存*是将数据子集存储在一个高度可访问的高速层中的过程，称为*缓存*。这样做是为了快速访问更频繁的数据，并避免为获取和存储以前的数据而进行的任何额外计算。缓存将数据存储很短一段时间，这是一种有利于高速的容量权衡。

缓存层下面的硬件是一种快速访问材料，如 RAM 和内存引擎，通常与软件层一起使用来访问数据。

缓存主要分为两种类型:本地缓存和远程缓存。本地缓存使用 JVM 堆进行存储，远程(或集群)缓存使用内存存储，如 [Redis](https://redis.io/) 或 [Memcached](https://memcached.org/) 。

## 什么是堆上本地缓存？

*堆上缓存*指的是将数据存储在 Java 堆中，由垃圾收集器(GC)自动管理。

## 什么是堆外本地缓存？

*堆外缓存*指的是将数据存储在堆外。GC 不会自动处理这些数据。因为它存储在 Java 堆之外，所以数据需要存储为字节数组。因此，序列化和反序列化数据会有额外的开销。

## 什么是远程缓存？

*远程缓存*是指将数据存储在云中的缓存中。由于可以从云中检索数据，它有助于构建一个具有增强性能的更强大的持久层。Redis 和 Memcached 是目前流行的两种内存缓存解决方案。

# 堆上和堆外缓存的优势

## 堆上优势

*   由于 GC，对象被自动分配和取消分配
*   更快地访问数据

## 堆上的弊

*   GC 暂停次数增加
*   由于数据存储在 JVM 内存中，如果 JVM 崩溃，数据就会丢失，因此不可能有长期存活的缓存

## 堆外优势

*   允许缓存大量数据，而不用担心 GC 暂停
*   支持在内存中添加一个持久层，以便从 JVM 崩溃中恢复
*   几个 JVM 可以共享缓存的数据

## 堆外的缺点

*   使用堆外缓存的最大缺点是数据的序列化/反序列化。这是底层程序的开销。由于没有通用的数据结构，将序列化数据转换成各自的对象需要额外的成本。
*   短期数据更适合堆上缓存，因为它允许自动 GC。因此，识别可以放入堆上的数据是一种开销。
*   手动内存管理(内存碎片等问题！)

简而言之，堆外缓存是存储数据的更好方式，因为它们提供了存储大量数据的长期解决方案，并且对于大型磁盘子系统，您可以实现高 IOPS(每秒输入/输出请求)。

# 远程缓存的优势

*   远程缓存集群可以按需扩展。
*   远程缓存并不局限于一种数据结构，因此由于多语言编程支持，提供了易用性。
*   与通过磁盘进行的较慢访问相比，性能得到了提高(因为数据存储在内存中，所以可以快速访问数据)。

# 如何确定您的系统/服务是否需要缓存

1.  **缓存命中率**:如果您的服务提供的数据不需要频繁刷新，并且在频繁检索的数据中，那么您应该考虑缓存。
2.  **对最终一致性的容忍度**:考虑源数据变化的速率以及缓存刷新间隔。您还应该考虑获取最近的数据对于您的服务的消费者来说有多重要。

# 缓存策略的类型及其挑战

## 本地缓存

*   通过在服务中提供某种存储(比如说散列表)，本地缓存更容易实现，但是会导致**缓存一致性问题**。即作为本地缓存，每台服务器会不一样，导致数据不一致。例如，假设服务器 S1 用数据 D1 响应了请求 R1，并将其存储在本地缓存中。如果数据库中的数据被更新为 D2 版本，并且在此之后，R1 发出相同的请求，那么根据请求到达的服务器，将有可能返回 D1 或 D2。
*   **冷启动**也是内存缓存的主要问题之一。随着每个新服务器的添加，甚至在部署期间，由于每个服务器启动时都没有缓存，因此对下游依赖项的请求数量可能会增加。这可以使用请求合并来解决。

## 外部缓存

1.  解决了上述问题，因为它是单独存储的，例如 Redis 或 Memcached。
2.  提供更多存储并减少因容量而导致的缓存回收。
3.  挑战包括增加整个系统的复杂性和维护额外缓存服务器的更多负载。
4.  始终在服务中添加代码，以处理缓存可能不可用的情况:

*   在此期间，您可以开始调用下游服务。但是，如果缓存中断持续更长时间，这可能会导致它们的负载增加。
*   或者，您可以将外部内存与内部内存一起使用，以避免完全依赖下游。
*   您还可以考虑负载削减技术，通过限制对服务的请求数量来避免使下游服务不堪重负。

5.要处理高速缓存的扩展和弹性问题:

*   如果缓存达到其容量，那么我们需要通过向其添加更多节点来进行扩展。更深入地了解系统及其在达到容量时的行为(例如，如果缓存达到容量，每个容器的内存利用率是否会上升)可以帮助您设置准确的警报。这些警报可用于扩大缓存服务。在扩展服务时，需要记住几件事情，即，您的缓存集群是否支持在不停机的情况下添加节点，或者是否支持一致的哈希算法来平均分配流量。务必通过模拟故障来测试扩展策略。

6.要处理数据的健壮性:

*   缓存的数据应该能够读取较新的代码格式，较新的代码应该能够处理从缓存中提供的数据的旧版本。

# 关键高速缓存实施注意事项

## 缓存大小

根据流经服务的数据类型，您可以确定缓存的大小，以便能够提高缓存命中率。

## 缓存回收

这是指当缓存达到容量上限时，将数据移出缓存。最常用的缓存回收模式是 LRU(最近最少使用)。

## 缓存过期

这是根据数据刷新频率或客户能够处理多少陈旧数据来确定我们可以将数据保留在缓存中多长时间的策略。

## 下游服务不可用

如果下游服务由于某种原因不可用，缓存服务应该能够在更长的时间内保护缓存，而不是向下游发送更新数据的请求，直到它恢复。根据您可以与客户进行的权衡，要么报告缓存中的陈旧数据并避免请求中断下游服务，要么建立一种机制来存储来自下游服务的错误响应并相应地进行翻译。

## 安全性

缓存集群的一个问题是被缓存的敏感数据或客户数据的安全性。敏感数据在存储之前应该加密，并且在向缓存传输数据和从缓存传输数据时应该提供安全性。

此外，由于缓存数据的返回速度比从数据库获取数据的调用快，攻击者可以根据服务的响应时间来识别服务发出的请求的类型。这叫做 ***旁道定时攻击*** 。

## “雷群”问题

在下游服务不可用期间，如果发出多个请求以从下游服务获取未缓存的数据，可能会导致多次重试，这反过来可能会使服务停止运行。我们可以结合一些策略来缓解这个问题，例如每个客户/请求节流、请求合并(即，对于相同的未缓存数据只发送一个请求)等等。

# 结论

缓存是一种提供更快的数据访问和提高下游服务可用性的方法，但它的代价是增加了处理缓存节点的复杂性。通过明智地理解下游服务的需求，我们可以提出一个缓存解决方案，应该对其进行认真监控，以根据不同的场景(如流量峰值、缓存不可用、下游服务中断等)调整参数。

我希望本文能够让您先睹为快，了解在为您的服务部署缓存解决方案时需要记住的一些核心考虑事项。