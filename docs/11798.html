<html>
<head>
<title>Top 7 Subtle Swift Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">7大微妙的Swift特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/top-7-subtle-swift-features-1b8d191293a0?source=collection_archive---------8-----------------------#2022-04-18">https://betterprogramming.pub/top-7-subtle-swift-features-1b8d191293a0?source=collection_archive---------8-----------------------#2022-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d228" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">枚举作为命名空间，可动态调用，等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ed6f3a17ca705c93036c604c7d3d5d9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hwTAQrtqH-AAokNeKF6Sg.png"/></div></div></figure><h1 id="6074" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">1.关键词<code class="fe lj lk ll lm b">indirect</code></h1><p id="f804" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">它只和枚举一起使用。如你所知，枚举是值类型，存储在堆栈中。因此，编译器需要知道每个枚举占用多少内存。</p><p id="0f6a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">由于在任何时候只有一个选项是可能的，enum占用了最大case的内存加上一些操作信息。</p><pre class="kg kh ki kj gt mo lm mp mq aw mr bi"><span id="d07e" class="ms ks iq lm b gy mt mu l mv mw">// Just a general enum, nothing fancy<br/>enum Foo {<br/>    case bizz(String)<br/>    case fizz(Int)<br/>}</span></pre><p id="015b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">但是如果我们让enum依赖于它自己呢？</p><pre class="kg kh ki kj gt mo lm mp mq aw mr bi"><span id="604e" class="ms ks iq lm b gy mt mu l mv mw">// Infinite size??<br/>enum Foo {<br/>    case bizz(Foo)<br/>    case fizz<br/>}</span></pre><p id="563a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这个定义会产生编译器错误。</p><blockquote class="mx my mz"><p id="6f53" class="ln lo na lp b lq mj jr ls lt mk ju lv nb ml ly lz nc mm mc md nd mn mg mh mi ij bi translated">递归枚举<code class="fe lj lk ll lm b">Foo</code>未标记<code class="fe lj lk ll lm b">indirect</code></p></blockquote><p id="b021" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这个错误是有意义的:编译器不能计算<code class="fe lj lk ll lm b">Foo</code>的大小，因为它趋向于无穷大。<code class="fe lj lk ll lm b">indirect</code>关键词来了。</p><pre class="kg kh ki kj gt mo lm mp mq aw mr bi"><span id="28fe" class="ms ks iq lm b gy mt mu l mv mw">// Oh, fine<br/>enum Foo {<br/>    indirect case bizz(Foo)<br/>    case fizz<br/>}</span></pre><ul class=""><li id="af95" class="ne nf iq lp b lq mj lt mk lw ng ma nh me ni mi nj nk nl nm bi translated"><strong class="lp ir">简单:</strong>修改enum内存结构，解决递归问题。</li><li id="e41a" class="ne nf iq lp b lq nn lt no lw np ma nq me nr mi nj nk nl nm bi translated"><strong class="lp ir">详细:</strong>T5】不再内联存储在内存中。实际上，使用<code class="fe lj lk ll lm b">indirect</code>修饰符，数据现在被存储在一个指针后面(间接)。</li></ul><p id="0658" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">问题解决了！此外，我们可以将整个枚举修改为间接枚举</p><pre class="kg kh ki kj gt mo lm mp mq aw mr bi"><span id="e282" class="ms ks iq lm b gy mt mu l mv mw">// Every case is indirect now<br/>indirect enum Foo {<br/>    case bizz(Foo?)<br/>    case fizz(Foo?)<br/>}</span></pre></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="0a8d" class="kr ks iq bd kt ku nz kw kx ky oa la lb jw ob jx ld jz oc ka lf kc od kd lh li bi translated">2.属性<code class="fe lj lk ll lm b">@autoclosure</code></h1><p id="a740" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">Swift的<code class="fe lj lk ll lm b">@autoclosure</code>属性使您能够定义一个自动包装在闭包中的参数。它主要用于将表达式的执行推迟到真正需要的时候。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="d247" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然后，计算可以这样调用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="4b99" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">所以，在这种情况下，当<code class="fe lj lk ll lm b">zero: true</code>时，<code class="fe lj lk ll lm b">calculate</code>的调用根本不计算表达式，提高代码性能。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="a153" class="kr ks iq bd kt ku nz kw kx ky oa la lb jw ob jx ld jz oc ka lf kc od kd lh li bi translated">3.懒惰的</h1><p id="a196" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe lj lk ll lm b">lazy</code>存储属性是直到第一次使用时才计算初始值的属性。惰性属性必须始终声明为变量。注意，如果在<code class="fe lj lk ll lm b">struct</code>中使用<code class="fe lj lk ll lm b">lazy</code>，那么使用它的函数必须标记为<code class="fe lj lk ll lm b">mutating</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="b928" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们已经讨论过<code class="fe lj lk ll lm b">@autoclosure</code>，它也有助于推迟表达式求值。那个可以和<code class="fe lj lk ll lm b">lazy</code>一起用！考虑一下依赖注入这个常见的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="6630" class="kr ks iq bd kt ku nz kw kx ky oa la lb jw ob jx ld jz oc ka lf kc od kd lh li bi translated">4.枚举作为命名空间</h1><p id="d5b1" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">Swift没有名称空间，这在大项目中可能是个问题。这很容易用枚举来解决。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="df59" class="kr ks iq bd kt ku nz kw kx ky oa la lb jw ob jx ld jz oc ka lf kc od kd lh li bi translated">5.动态成员查找</h1><p id="49eb" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">本节描述了<code class="fe lj lk ll lm b">@dynamicMemberLookup</code>属性。它可以与结构和类一起使用。</p><p id="c8eb" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">仅仅将<code class="fe lj lk ll lm b">@dynamicMemberLookup</code>添加到定义中会产生一个错误</p><blockquote class="mx my mz"><p id="a529" class="ln lo na lp b lq mj jr ls lt mk ju lv nb ml ly lz nc mm mc md nd mn mg mh mi ij bi translated"><code class="fe lj lk ll lm b">@dynamicMemberLookup</code>属性要求<code class="fe lj lk ll lm b">Foo</code>有一个接受<code class="fe lj lk ll lm b">ExpressibleByStringLiteral</code>或<code class="fe lj lk ll lm b">key path</code>的<code class="fe lj lk ll lm b">subscript(dynamicMember:)</code>方法</p></blockquote><p id="9949" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">因此，需要定义这样的下标</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="5ec5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在<code class="fe lj lk ll lm b">subscript</code>中，您可以实现更复杂的逻辑来检索数据。但是您可以看到这种实现仅限于字符串，并不真正安全。这可以用<code class="fe lj lk ll lm b">key path</code>来修改。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="1abe" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">即使您知道这个特性，也不意味着它应该在任何地方使用。什么更具可读性和表现力，就看你了:<code class="fe lj lk ll lm b">a.himself.age</code>还是<code class="fe lj lk ll lm b">a.age</code>。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="1be5" class="kr ks iq bd kt ku nz kw kx ky oa la lb jw ob jx ld jz oc ka lf kc od kd lh li bi translated">6.可动态调用</h1><p id="bd67" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">还有一个编译器特性，允许你调用对象。可应用于<code class="fe lj lk ll lm b">struct</code>、<code class="fe lj lk ll lm b">enum</code>和<code class="fe lj lk ll lm b">class</code>。</p><p id="c3b3" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">添加属性后，会生成错误:</p><blockquote class="mx my mz"><p id="e99f" class="ln lo na lp b lq mj jr ls lt mk ju lv nb ml ly lz nc mm mc md nd mn mg mh mi ij bi translated"><code class="fe lj lk ll lm b">@dynamicCallable</code>属性要求<code class="fe lj lk ll lm b">RangeGenerator</code>具有有效的<code class="fe lj lk ll lm b">dynamicallyCall(withArguments:)</code>方法或<code class="fe lj lk ll lm b">dynamicallyCall(withKeywordArguments:)</code>方法</p></blockquote><p id="4d23" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">方法签名与<code class="fe lj lk ll lm b">@dynamicMemberLookup</code>类似。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="a0ee" class="kr ks iq bd kt ku nz kw kx ky oa la lb jw ob jx ld jz oc ka lf kc od kd lh li bi translated">7.内嵌</h1><p id="7f82" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">有时你想给出关于编译器可以使用的优化的附加信息。内联代码是最重要的优化特性之一。那么，<code class="fe lj lk ll lm b">‌@inlinable</code>、<code class="fe lj lk ll lm b">@inline(__always)</code>、<code class="fe lj lk ll lm b">@usableFromInline</code>怎么用呢？</p><p id="b481" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">属性将函数体作为模块接口的一部分导出，使它在被其他模块引用时对优化器可用。</p><p id="e578" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">因此，<code class="fe lj lk ll lm b">@inlinable</code>使得该方法的实现成为公共的，并且能够被内联到调用者中。其次，它强迫你做出它所谓的一切<code class="fe lj lk ll lm b">@usableFromInline</code>。</p><p id="0c3f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe lj lk ll lm b">@inline(__always)</code>告诉编译器忽略内联试探法，总是(几乎)内联函数。</p><p id="eeb2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">一个是<code class="fe lj lk ll lm b">@inline(__always)</code>而不是<code class="fe lj lk ll lm b">@inlinable</code>的函数将不可用于在其模块外的内联，因为该函数的代码不可用。</p><blockquote class="mx my mz"><p id="accf" class="ln lo na lp b lq mj jr ls lt mk ju lv nb ml ly lz nc mm mc md nd mn mg mh mi ij bi translated"><code class="fe lj lk ll lm b">@inline(__always)</code>可能对性能有益，但是由于代码大小的增加，它也可能对宏性能产生灾难性的影响。</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="e528" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这对实现有更多的影响，如果你想深入了解这个问题，请查看这个<a class="ae og" href="https://forums.swift.org/t/when-should-both-inlinable-and-inline-always-be-used/37375" rel="noopener ugc nofollow" target="_blank">论坛</a>上的讨论:</p><pre class="kg kh ki kj gt mo lm mp mq aw mr bi"><span id="7a48" class="ms ks iq lm b gy mt mu l mv mw"><strong class="lm ir">Want to Connect?</strong></span><span id="a9a0" class="ms ks iq lm b gy oh mu l mv mw">This post was originally published on my website. <a class="ae og" href="https://alexdremov.me/quick-guide-to-async-await-in-swift/" rel="noopener ugc nofollow" target="_blank">Check it out!</a> </span><span id="697c" class="ms ks iq lm b gy oh mu l mv mw"><a class="ae og" href="https://alexdremov.me/#/portal/signup" rel="noopener ugc nofollow" target="_blank"><em class="na">Subscribe to my newsletter and don’t miss other useful Swift tips</em></a></span></pre><h1 id="6383" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">参考</h1><ol class=""><li id="fbb7" class="ne nf iq lp b lq lr lt lu lw oi ma oj me ok mi ol nk nl nm bi translated"><a class="ae og" href="https://www.swiftbysundell.com/articles/using-autoclosure-when-designing-swift-apis/" rel="noopener ugc nofollow" target="_blank">https://www . swiftbysundell . com/articles/using-auto closure-when-design-swift-APIs/</a></li><li id="6608" class="ne nf iq lp b lq nn lt no lw np ma nq me nr mi ol nk nl nm bi translated"><a class="ae og" href="https://www.swiftbysundell.com/articles/powerful-ways-to-use-swift-enums/" rel="noopener ugc nofollow" target="_blank">https://www . swiftbysundell . com/articles/powerful-ways-to-use-swift-enum/</a></li><li id="d992" class="ne nf iq lp b lq nn lt no lw np ma nq me nr mi ol nk nl nm bi translated"><a class="ae og" href="https://www.hackingwithswift.com/articles/134/how-to-use-dynamiccallable-in-swift" rel="noopener ugc nofollow" target="_blank">https://www . hacking with swift . com/articles/134/how-to-use-dynamic call-in-swift</a></li><li id="ab50" class="ne nf iq lp b lq nn lt no lw np ma nq me nr mi ol nk nl nm bi translated"><a class="ae og" href="https://www.hackingwithswift.com/example-code/language/what-are-lazy-variables" rel="noopener ugc nofollow" target="_blank">https://www . hacking with swift . com/example-code/language/what-are-lazy-variables</a></li><li id="d2fc" class="ne nf iq lp b lq nn lt no lw np ma nq me nr mi ol nk nl nm bi translated"><a class="ae og" href="https://forums.swift.org/t/who-benefits-from-the-indirect-keyword/20167" rel="noopener ugc nofollow" target="_blank">https://forums . swift . org/t/who-benefits-from-the-indirect-keyword/20167</a></li><li id="28a7" class="ne nf iq lp b lq nn lt no lw np ma nq me nr mi ol nk nl nm bi translated"><a class="ae og" href="https://www.tothenew.com/blog/recursive-enumerations-in-swift/" rel="noopener ugc nofollow" target="_blank">https://www . tothenew . com/blog/recursive-enumerations-in-swift/</a></li><li id="8aa6" class="ne nf iq lp b lq nn lt no lw np ma nq me nr mi ol nk nl nm bi translated"><a class="ae og" href="https://www.avanderlee.com/swift/dynamic-member-lookup/" rel="noopener ugc nofollow" target="_blank">https://www.avanderlee.com/swift/dynamic-member-lookup/</a></li></ol></div></div>    
</body>
</html>