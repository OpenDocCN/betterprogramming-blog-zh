<html>
<head>
<title>Git Commands to Live By</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git命令赖以生存</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/git-commands-to-live-by-349ab1fe3139?source=collection_archive---------1-----------------------#2020-12-30">https://betterprogramming.pub/git-commands-to-live-by-349ab1fe3139?source=collection_archive---------1-----------------------#2020-12-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6acd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">超出Git基础的备忘单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d0b1b8ebe1564fa4fd7ad70ee70abe95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jDDDzcjb2blWLSN68q3l2A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我的一个项目的Git图</p></figure><p id="14c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一段时间以来，我已经自己记下了从命令行工作时必须查找的每个Git命令。每当我这样做时，我都会记下正确的语法、最常见的选项以及我从哪里获得的信息。随着时间的推移，随着我的列表越来越多，我开始越来越少地依赖谷歌，更多地依赖我的列表来快速查阅。</p><p id="9f3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">典型用例(想想普通的<code class="fe lv lw lx ly b">git add</code>或<code class="fe lv lw lx ly b">git commit</code>)不会在这里出现，而是选择一些不太经常出现但却很重要的用例。</p><p id="f38d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>链接的参考资料通常会提到稍有不同的、更简洁的Git新版本命令。所以如果你想要最新最棒的，一定要给他们看看。</p><h2 id="f578" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">概观</h2><pre class="kj kk kl km gt ms ly mt mu aw mv bi"><span id="e65a" class="lz ma it ly b gy mw mx l my mz">1. <a class="ae ky" href="#e221" rel="noopener ugc nofollow">Check Out Remote Branches</a><br/>2. <a class="ae ky" href="#d201" rel="noopener ugc nofollow">Delete Remote Branches</a><br/>3. <a class="ae ky" href="#1ef3" rel="noopener ugc nofollow">Change Remote URL</a><br/>4. <a class="ae ky" href="#6a0c" rel="noopener ugc nofollow">Stash Individual Files</a><br/>5. <a class="ae ky" href="#203c" rel="noopener ugc nofollow">Show Content of Most Recent Stash</a><br/>6. <a class="ae ky" href="#bde6" rel="noopener ugc nofollow">Apply a Stash Without Deleting It From the Stash List</a><br/>7. <a class="ae ky" href="#5036" rel="noopener ugc nofollow">Check Out File From Another Branch</a><br/>8. <a class="ae ky" href="#df30" rel="noopener ugc nofollow">Work With Multiple Branches Simultaneously</a><br/>9. <a class="ae ky" href="#80a5" rel="noopener ugc nofollow">Show Commit Content</a><br/>10. <a class="ae ky" href="#e2ef" rel="noopener ugc nofollow">Compare Files Between Branches/Commits</a><br/>11. <a class="ae ky" href="#691a" rel="noopener ugc nofollow">Reset a Single File to Most Recent Commit</a><br/>12. <a class="ae ky" href="#a59f" rel="noopener ugc nofollow">Change Last Commit Message</a><br/>13. <a class="ae ky" href="#8065" rel="noopener ugc nofollow">Change a Specific Commit Message</a><br/>14. <a class="ae ky" href="#708c" rel="noopener ugc nofollow">Delete Last Commit but Keep the Changes</a><br/>15. <a class="ae ky" href="#07ff" rel="noopener ugc nofollow">Unstage a File</a><br/>16. <a class="ae ky" href="#9807" rel="noopener ugc nofollow">Remove Ignored Files From Remote</a><br/>17. <a class="ae ky" href="#c0f6" rel="noopener ugc nofollow">Create GitHub Releases</a></span></pre><h2 id="ff50" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">关于语法的快速注释</h2><ul class=""><li id="b872" class="na nb it lb b lc nc lf nd li ne lm nf lq ng lu nh ni nj nk bi translated"><code class="fe lv lw lx ly b">[]</code>:可选内容</li><li id="10b0" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><code class="fe lv lw lx ly b">&lt;&gt;</code>:运行命令时应替换为实际值</li></ul></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="e221" class="nx ma it bd mb ny nz oa me ob oc od mh jz oe ka mk kc of kd mn kf og kg mq oh bi translated">查看远程分支机构</h1><p id="3789" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">我们可能都很熟悉<code class="fe lv lw lx ly b">git pull</code>,它能让我们当地的分支机构跟上远程分支机构的速度。然而，如果这是我们第一次使用远程分支——也就是说，它没有被本地存储库中的任何分支跟踪——我们首先需要设置它。</p><p id="1487" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>运行<code class="fe lv lw lx ly b">git fetch </code>来确保我们使用的是最新版本的<code class="fe lv lw lx ly b">remote</code>是个好主意。</p><ul class=""><li id="067b" class="na nb it lb b lc ld lf lg li ol lm om lq on lu nh ni nj nk bi translated"><strong class="lb iu">命令:</strong>T7】</li><li id="568c" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">举例:</strong> <code class="fe lv lw lx ly b">git checkout -t origin/my-awesome-feature</code></li><li id="102a" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">解释:</strong>这将把<code class="fe lv lw lx ly b">origin/my-awesome-feature</code>拉入一个同名的新本地分支，并将其设置为跟踪<code class="fe lv lw lx ly b">origin/my-awesome-feature</code>。<code class="fe lv lw lx ly b">-b</code>将做同样的事情，只是本地分支的名称将被设置为指定的名称。</li></ul><h2 id="a5a7" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated"><strong class="ak">资源</strong></h2><ul class=""><li id="8ce1" class="na nb it lb b lc nc lf nd li ne lm nf lq ng lu nh ni nj nk bi translated">“我如何签出一个远程Git分支？”|堆栈溢出</li></ul><p id="43cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#f578" rel="noopener ugc nofollow"> ⬆ </a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="d201" class="nx ma it bd mb ny nz oa me ob oc od mh jz oe ka mk kc of kd mn kf og kg mq oh bi translated">删除远程分支</h1><p id="78ec" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">删除本地分支就像写<code class="fe lv lw lx ly b">git branch -d &lt;branch&gt;</code>一样简单。但是删除远程分支需要不同的命令。</p><ul class=""><li id="e72d" class="na nb it lb b lc ld lf lg li ol lm om lq on lu nh ni nj nk bi translated"><strong class="lb iu">命令:</strong> <code class="fe lv lw lx ly b">git push &lt;remote&gt; -d &lt;branch&gt;</code>或<code class="fe lv lw lx ly b">git push &lt;remote&gt; :&lt;branch&gt;</code></li><li id="92c3" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">例如:</strong>T2】</li></ul><h2 id="430a" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">资源</h2><ul class=""><li id="7fa4" class="na nb it lb b lc nc lf nd li ne lm nf lq ng lu nh ni nj nk bi translated"><a class="ae ky" href="https://stackoverflow.com/a/2003515/4348037" rel="noopener ugc nofollow" target="_blank">“如何在本地和远程删除Git分支？”|堆栈溢出</a></li></ul><p id="138c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#f578" rel="noopener ugc nofollow"> ⬆ </a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="1ef3" class="nx ma it bd mb ny nz oa me ob oc od mh jz oe ka mk kc of kd mn kf og kg mq oh bi translated">更改远程URL</h1><p id="7863" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">这是为了当你需要改变URL <code class="fe lv lw lx ly b">&lt;remote&gt;</code>实际指向的时候。例如，如果您更改了存储库的名称，Git会要求您这样做。以下是方法。</p><ul class=""><li id="ec35" class="na nb it lb b lc ld lf lg li ol lm om lq on lu nh ni nj nk bi translated"><strong class="lb iu">命令:</strong>T4】</li><li id="35f8" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">举例:</strong>T5】</li></ul><h2 id="189f" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">资源</h2><ul class=""><li id="ccac" class="na nb it lb b lc nc lf nd li ne lm nf lq ng lu nh ni nj nk bi translated">git-remote | Git </li></ul><p id="211e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#f578" rel="noopener ugc nofollow"> ⬆ </a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="6a0c" class="nx ma it bd mb ny nz oa me ob oc od mh jz oe ka mk kc of kd mn kf og kg mq oh bi translated">隐藏单个文件</h1><p id="59cf" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated"><code class="fe lv lw lx ly b">git stash</code>经常用于暂时搁置所有<strong class="lb iu"> </strong>未提交的更改，并将分支重置为最近的提交。但是如果您只想隐藏特定的文件呢？</p><ul class=""><li id="2f70" class="na nb it lb b lc ld lf lg li ol lm om lq on lu nh ni nj nk bi translated"><strong class="lb iu">命令:</strong>T7】</li><li id="bce4" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">举例:</strong> <code class="fe lv lw lx ly b">git stash push -- src/index.js README.md</code></li></ul><h2 id="19d4" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">资源</h2><ul class=""><li id="3431" class="na nb it lb b lc nc lf nd li ne lm nf lq ng lu nh ni nj nk bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/3040833/stash-only-one-file-out-of-multiple-files-that-have-changed-with-git#comment78345399_3040833" rel="noopener ugc nofollow" target="_blank">“只隐藏用Git修改过的多个文件中的一个吗？”|堆栈溢出</a></li></ul><p id="19f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#f578" rel="noopener ugc nofollow"> ⬆ </a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="203c" class="nx ma it bd mb ny nz oa me ob oc od mh jz oe ka mk kc of kd mn kf og kg mq oh bi translated">显示最近收藏的内容</h1><p id="5555" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">如果您想在应用更改之前查看一个存储库将应用的更改，这个选项很有用。</p><ul class=""><li id="fae4" class="na nb it lb b lc ld lf lg li ol lm om lq on lu nh ni nj nk bi translated"><strong class="lb iu">命令:</strong> <code class="fe lv lw lx ly b">git stash show -p [stash@{&lt;n&gt;}]</code></li><li id="9591" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">解释:<br/> </strong> <code class="fe lv lw lx ly b">-p</code>表示我们希望看到隐藏的实际内容。省略它将只显示文件名。<br/> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://git-scm.com/docs/git-stash#Documentation/git-stash.txt-ltstashgt" rel="noopener ugc nofollow" target="_blank">stash@{&lt;n&gt;}</a></code>允许我们指定某个藏匿点，用<code class="fe lv lw lx ly b">n</code>表示(0是最近的一个)。</li><li id="452c" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">举例:</strong> <code class="fe lv lw lx ly b">git stash show -p stash@{1}</code></li><li id="fae7" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">效果:</strong>显示第二个最新存储的内容</li></ul><h2 id="90a6" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">资源</h2><ul class=""><li id="fe22" class="na nb it lb b lc nc lf nd li ne lm nf lq ng lu nh ni nj nk bi translated"><a class="ae ky" href="https://stackoverflow.com/a/10726185/4348037" rel="noopener ugc nofollow" target="_blank">“查看存储中的内容而不应用它”|存储溢出</a></li><li id="d5e1" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">git-stash | Git </li></ul><p id="5221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#f578" rel="noopener ugc nofollow"> ⬆ </a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="bde6" class="nx ma it bd mb ny nz oa me ob oc od mh jz oe ka mk kc of kd mn kf og kg mq oh bi translated">应用存储，而不从存储列表中删除它</h1><p id="7f59" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">说到应用存储，<code class="fe lv lw lx ly b">git stash pop</code>通常是这个and的首选命令，它将应用存储列表上的第一个存储(用<code class="fe lv lw lx ly b">git stash list</code>查看)。然而，副作用是，在这个过程中，隐藏的内容被从列表中删除了。但如果你想留着它，Git会帮你搞定的。</p><ul class=""><li id="a3a0" class="na nb it lb b lc ld lf lg li ol lm om lq on lu nh ni nj nk bi translated"><strong class="lb iu">命令:</strong>T2】</li><li id="74ca" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">效果:</strong>应用列表中的第一个隐藏而不移除它</li><li id="9672" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">提示:</strong>就像<code class="fe lv lw lx ly b">git stash show</code>一样，你可以通过添加<code class="fe lv lw lx ly b">stash@{&lt;n&gt;}</code>来指定应用哪个隐藏</li></ul><h2 id="e416" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">资源</h2><ul class=""><li id="4f7b" class="na nb it lb b lc nc lf nd li ne lm nf lq ng lu nh ni nj nk bi translated">git-stash | Git</li></ul><p id="0577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#f578" rel="noopener ugc nofollow"> ⬆ </a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="5036" class="nx ma it bd mb ny nz oa me ob oc od mh jz oe ka mk kc of kd mn kf og kg mq oh bi translated">从另一个分支签出文件</h1><p id="cba5" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated"><code class="fe lv lw lx ly b">git checkout &lt;branch&gt;</code>对于大多数Git用户来说并不陌生。它确实如它所说的那样，检查一个特定的分支。但是如果需要，同样的命令也可以用来签出单个文件。</p><ul class=""><li id="603e" class="na nb it lb b lc ld lf lg li ol lm om lq on lu nh ni nj nk bi translated"><strong class="lb iu">命令:</strong>T6】</li><li id="7d7a" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">举例:</strong> <code class="fe lv lw lx ly b">git checkout my-awesome-feature src/lasers.js</code></li><li id="1770" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">效果:</strong>从<code class="fe lv lw lx ly b">my-awesome-feature</code>中检出<code class="fe lv lw lx ly b">src/lasers.js</code></li><li id="a7bc" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">提示:</strong>你可能也很熟悉<code class="fe lv lw lx ly b">git checkout &lt;commit&gt;</code>。这种变体可以以同样的方式从特定的提交而不是特定的分支中签出文件。</li></ul><h2 id="bf43" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">资源</h2><ul class=""><li id="60d8" class="na nb it lb b lc nc lf nd li ne lm nf lq ng lu nh ni nj nk bi translated"><a class="ae ky" href="https://jasonrudolph.com/blog/2009/02/25/git-tip-how-to-merge-specific-files-from-another-branch/" rel="noopener ugc nofollow" target="_blank">“Git提示:如何从另一个分支‘合并’特定文件</a>”</li></ul><p id="c151" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#f578" rel="noopener ugc nofollow"> ⬆ </a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="df30" class="nx ma it bd mb ny nz oa me ob oc od mh jz oe ka mk kc of kd mn kf og kg mq oh bi translated">同时处理多个分支</h1><p id="e81b" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">如果你发现自己经常不得不检查一个特定的分支，例如在另一个分支上工作时作为参考，<code class="fe lv lw lx ly b">git worktree</code>提供了一个更好的选择。</p><ul class=""><li id="9245" class="na nb it lb b lc ld lf lg li ol lm om lq on lu nh ni nj nk bi translated"><strong class="lb iu">命令:</strong> <code class="fe lv lw lx ly b">git worktree add &lt;path&gt; &lt;branch&gt;</code> <br/>当你不再需要它的时候，运行:<br/> <code class="fe lv lw lx ly b">git worktree remove [-f] &lt;path&gt;</code></li><li id="58cb" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">举例:<br/> </strong> 1。<code class="fe lv lw lx ly b">git worktree add my-other-awesome-feature ../my-other-awesome-feature</code> <br/> 2。<code class="fe lv lw lx ly b">git worktree remove ../my-other-awesome-feature</code></li><li id="93e4" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">解释:</strong>创建一个<a class="ae ky" href="https://git-scm.com/docs/git-worktree#_description" rel="noopener ugc nofollow" target="_blank">链接的工作树</a>(即文件系统上与回购相关联的另一个目录)，名为<code class="fe lv lw lx ly b">my-other-awesome-feature</code>，在你当前工作目录的上一级，指定的分支被检出。例如，您可以在另一个代码编辑器实例中打开这个目录，或者在当前实例中打开其中的单个文件。<br/>一旦你完成了链接的工作树，用<br/> <code class="fe lv lw lx ly b">-f</code>移除它将强制移除带有未提交变更的工作树。</li></ul><h2 id="70ef" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">资源</h2><ul class=""><li id="bd87" class="na nb it lb b lc nc lf nd li ne lm nf lq ng lu nh ni nj nk bi translated"><a class="ae ky" href="https://stackoverflow.com/a/30186843/4348037" rel="noopener ugc nofollow" target="_blank">“git同时处理两个分支”|堆栈溢出</a></li><li id="994f" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><a class="ae ky" href="https://git-scm.com/docs/git-worktree" rel="noopener ugc nofollow" target="_blank"> git-worktree | Git </a></li></ul><p id="ff8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#f578" rel="noopener ugc nofollow"> ⬆ </a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="80a5" class="nx ma it bd mb ny nz oa me ob oc od mh jz oe ka mk kc of kd mn kf og kg mq oh bi translated">显示提交内容</h1><p id="1b14" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">与<code class="fe lv lw lx ly b">git stash show</code>有些类似，查看特定提交引入的更改通常很有用。</p><ul class=""><li id="5d38" class="na nb it lb b lc ld lf lg li ol lm om lq on lu nh ni nj nk bi translated"><strong class="lb iu">命令:</strong> <code class="fe lv lw lx ly b">git show &lt;commit&gt;</code> <br/>或者，运行<br/> <code class="fe lv lw lx ly b">git diff &lt;commit-a&gt; &lt;commit-b&gt;</code>来查看两个具体提交之间的变化</li><li id="898b" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">举例:</strong>T10】</li><li id="feee" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">效果:</strong>显示<code class="fe lv lw lx ly b">HEAD</code>与其直接祖先的区别，相当于<code class="fe lv lw lx ly b">git show</code></li></ul><h2 id="43ed" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">资源</h2><ul class=""><li id="06e3" class="na nb it lb b lc nc lf nd li ne lm nf lq ng lu nh ni nj nk bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/17563726/how-to-see-the-changes-in-a-git-commit/" rel="noopener ugc nofollow" target="_blank">“如何查看Git提交中的变化？”堆栈溢出</a></li><li id="ce97" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><a class="ae ky" href="https://github.blog/2020-12-17-commits-are-snapshots-not-diffs" rel="noopener ugc nofollow" target="_blank">“提交是快照，不是差异”GitHub博客</a></li><li id="2dc2" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><a class="ae ky" href="https://git-scm.com/docs/git-log" rel="noopener ugc nofollow" target="_blank"> git-log | Git </a></li><li id="39de" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><a class="ae ky" href="https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History" rel="noopener ugc nofollow" target="_blank">“Git基础知识—查看提交历史”| Git </a></li></ul><p id="f67e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#f578" rel="noopener ugc nofollow"> ⬆ </a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="e2ef" class="nx ma it bd mb ny nz oa me ob oc od mh jz oe ka mk kc of kd mn kf og kg mq oh bi translated">比较分支/提交之间的文件</h1><p id="d87f" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">正如我们刚刚看到的,<code class="fe lv lw lx ly b">git diff</code>的威力不仅仅局限于整个提交，还可以用于针对单个文件。</p><ul class=""><li id="f21c" class="na nb it lb b lc ld lf lg li ol lm om lq on lu nh ni nj nk bi translated"><strong class="lb iu">命令:</strong>T1】</li><li id="dffa" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">例如:</strong>T2】</li><li id="68b4" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">效果:</strong>显示一次提交的文件与另一次提交的文件有何不同。<br/>这里也可以使用分支名称来代替提交，以便跨分支比较文件。</li><li id="2559" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">提示:</strong>要比较不同的文件，使用<br/>T3】</li></ul><h2 id="c2d9" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">资源</h2><ul class=""><li id="0e0f" class="na nb it lb b lc nc lf nd li ne lm nf lq ng lu nh ni nj nk bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/4099742/how-to-compare-files-from-two-different-branches" rel="noopener ugc nofollow" target="_blank">“如何比较两个不同分支的文件？”|堆栈溢出</a></li></ul><p id="b36c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#f578" rel="noopener ugc nofollow"> ⬆ </a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="691a" class="nx ma it bd mb ny nz oa me ob oc od mh jz oe ka mk kc of kd mn kf og kg mq oh bi translated">将单个文件重置为最近提交的文件</h1><p id="c5c8" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated"><code class="fe lv lw lx ly b">git reset --hard</code>是一个天赐良机，当你需要回到上一个稳定的状态时，例如在一些不想要的或意想不到的变化之后，但是它影响了整个工作树。不过，实现相同效果但本地化到一个文件的命令应该并不陌生。</p><ul class=""><li id="685a" class="na nb it lb b lc ld lf lg li ol lm om lq on lu nh ni nj nk bi translated"><strong class="lb iu">命令:</strong>T5】</li><li id="5839" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">举例:</strong> <code class="fe lv lw lx ly b">git checkout -- README.md</code></li><li id="83dc" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">效果:</strong>这将把<code class="fe lv lw lx ly b">README.md</code>重置为最近一次提交的版本(或者一次特定的提交，如果指定的话)</li></ul><h2 id="089e" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">资源</h2><ul class=""><li id="606a" class="na nb it lb b lc nc lf nd li ne lm nf lq ng lu nh ni nj nk bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/7147270/hard-reset-of-a-single-file" rel="noopener ugc nofollow" target="_blank">“单个文件的硬复位”|堆栈溢出</a></li></ul><p id="3410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#f578" rel="noopener ugc nofollow"> ⬆ </a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="a59f" class="nx ma it bd mb ny nz oa me ob oc od mh jz oe ka mk kc of kd mn kf og kg mq oh bi translated">更改上次提交的消息</h1><p id="36c0" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">曾经提交的更改只是为了以后想要编辑提交消息吗？</p><ul class=""><li id="dcbd" class="na nb it lb b lc ld lf lg li ol lm om lq on lu nh ni nj nk bi translated"><strong class="lb iu">命令:</strong> <code class="fe lv lw lx ly b">git commit --amend [-m '&lt;message&gt;']</code> <br/>如果已经推送了旧的提交，则需要额外运行<br/> <code class="fe lv lw lx ly b">git push --force-with-lease &lt;remote&gt; &lt;branch&gt;</code>。<code class="fe lv lw lx ly b"><br/></code> <strong class="lb iu">注意:</strong>作为一般规则，尤其是如果你正在和别人一起工作，对已经提交的提交进行任何更改时，小心是很重要的。</li><li id="4899" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">效果:</strong>将任何暂存的更改添加到最后一次提交。如果消息包含在<code class="fe lv lw lx ly b">-m</code>选项中，则最后一次提交的消息将被替换。否则，这将在最后一条提交消息时打开编辑器。</li><li id="9e37" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">提示:</strong>您可能已经知道，<code class="fe lv lw lx ly b">git commit --amend</code>不仅仅可以用来改变提交的消息。例如，进行更改并用<code class="fe lv lw lx ly b">--amend</code>选项提交它们会导致这些更改被添加到最后一次提交中，而不是创建一个新的。</li></ul><h2 id="58cc" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">资源</h2><ul class=""><li id="4ebd" class="na nb it lb b lc nc lf nd li ne lm nf lq ng lu nh ni nj nk bi translated">git提交| Git </li><li id="622e" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><a class="ae ky" href="https://stackoverflow.com/a/8981216/4348037" rel="noopener ugc nofollow" target="_blank">“推送后更改git提交消息(假设无人从远程拉取)”|堆栈溢出</a></li></ul><p id="9c2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#f578" rel="noopener ugc nofollow"> ⬆ </a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="8065" class="nx ma it bd mb ny nz oa me ob oc od mh jz oe ka mk kc of kd mn kf og kg mq oh bi translated">更改特定的提交消息</h1><p id="ab85" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">改变一个特定的<strong class="lb iu"> </strong>提交消息怎么样？</p><ul class=""><li id="ee08" class="na nb it lb b lc ld lf lg li ol lm om lq on lu nh ni nj nk bi translated"><strong class="lb iu">命令:</strong>T6】</li><li id="9010" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">示例(见下面演示):</strong> <code class="fe lv lw lx ly b">git rebase -i HEAD~3</code></li><li id="c39b" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">效果:</strong>打开一个编辑器，列出提交的内容，从指定的内容开始，一直到当前的内容。在上面的例子中，这个列表将由最后三个提交组成。<br/>将<code class="fe lv lw lx ly b">pick</code>替换为<code class="fe lv lw lx ly b">reword</code>对于那些您希望更改消息并保存的提交，这将允许您这样做。<br/> <strong class="lb iu">注:</strong>实际变化在下一步进行。此时更改消息将不会有任何效果！</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/35484ddb607e3c1eecdf0ca4cb70a399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iZvhBr9v2EeQ_IYuAww7uw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用Git Rebase更改特定的提交消息</p></figure><h2 id="d1d6" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">资源</h2><ul class=""><li id="a846" class="na nb it lb b lc nc lf nd li ne lm nf lq ng lu nh ni nj nk bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/1884474/change-old-commit-message-on-git" rel="noopener ugc nofollow" target="_blank">“更改Git上的旧提交消息”|堆栈溢出</a></li></ul><p id="3a09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#f578" rel="noopener ugc nofollow"> ⬆ </a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="708c" class="nx ma it bd mb ny nz oa me ob oc od mh jz oe ka mk kc of kd mn kf og kg mq oh bi translated">删除上次提交，但保留更改</h1><p id="e4de" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">您已经提交了想要保留的更改，但是出于某种原因，您不想提交它本身。不要烦恼！</p><ul class=""><li id="631f" class="na nb it lb b lc ld lf lg li ol lm om lq on lu nh ni nj nk bi translated"><strong class="lb iu">命令:</strong> <code class="fe lv lw lx ly b">git reset HEAD^<br/></code> <strong class="lb iu">注意:</strong>关于对已经推送的内容进行更改的警告在这里也同样有效！</li><li id="273a" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">效果:</strong>移动<code class="fe lv lw lx ly b">HEAD</code>指向先前的提交，而不做任何文件更改，有效地删除当前的提交</li><li id="898d" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">提示:</strong>这种方法的另一种选择是等到你准备好下一次提交，而不是像通常的<code class="fe lv lw lx ly b">git commit</code>那样，使用我们的老朋友<code class="fe lv lw lx ly b">git commit --amend</code>。这将具有相同的预期效果。</li></ul><h2 id="3e4a" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">资源</h2><ul class=""><li id="947b" class="na nb it lb b lc nc lf nd li ne lm nf lq ng lu nh ni nj nk bi translated"><a class="ae ky" href="https://stackoverflow.com/a/15772171/4348037" rel="noopener ugc nofollow" target="_blank">“我可以删除git提交但保留更改吗？”|堆栈溢出</a></li></ul><p id="d3d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#f578" rel="noopener ugc nofollow"> ⬆ </a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="07ff" class="nx ma it bd mb ny nz oa me ob oc od mh jz oe ka mk kc of kd mn kf og kg mq oh bi translated">取消文件暂存</h1><p id="071d" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated"><code class="fe lv lw lx ly b">git add</code>的反义词是什么？我给你一个提示。不是<code class="fe lv lw lx ly b">git remove</code>。</p><ul class=""><li id="5927" class="na nb it lb b lc ld lf lg li ol lm om lq on lu nh ni nj nk bi translated"><strong class="lb iu">命令:</strong>T6】</li><li id="4e18" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">效果:</strong>从索引中删除给定的文件。当您准备下一次提交并决定之前用<code class="fe lv lw lx ly b">git add</code>暂存的文件不再是它的一部分时，这很有用。这个<em class="op">不影响</em>文件本身。所以你不用担心弄坏什么东西。</li></ul><h2 id="d657" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">资源:</h2><ul class=""><li id="f41c" class="na nb it lb b lc nc lf nd li ne lm nf lq ng lu nh ni nj nk bi translated"><a class="ae ky" href="https://docs.gitlab.com/ee/university/training/topics/unstage.html" rel="noopener ugc nofollow" target="_blank"> Unstage | GitLab </a></li><li id="64c3" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><a class="ae ky" href="https://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified" rel="noopener ugc nofollow" target="_blank">“Git工具—重置解密”| Git </a></li></ul><p id="bf8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#f578" rel="noopener ugc nofollow"> ⬆ </a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="9807" class="nx ma it bd mb ny nz oa me ob oc od mh jz oe ka mk kc of kd mn kf og kg mq oh bi translated">从远程删除忽略的文件</h1><p id="f04a" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">如果您已经推送了文件，然后决定<code class="fe lv lw lx ly b">.gitignore</code>它们，这些文件仍然会保存在您的远程存储库中。为了补救这一点，<code class="fe lv lw lx ly b">git rm</code>是这项工作的工具。</p><ul class=""><li id="f742" class="na nb it lb b lc ld lf lg li ol lm om lq on lu nh ni nj nk bi translated"><strong class="lb iu">命令:</strong> <code class="fe lv lw lx ly b">git rm [-r] [-n] --cached &lt;path(s)&gt;</code>。<br/>然后，简单的说<code class="fe lv lw lx ly b">add</code>、<code class="fe lv lw lx ly b">commit</code>、<code class="fe lv lw lx ly b">push</code>。</li><li id="3260" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">说明:</strong> <br/> <code class="fe lv lw lx ly b">--cached</code>确保文件保留在工作树中。<br/> <code class="fe lv lw lx ly b">-n</code>执行一次试运行，本质上是一次健全性检查，允许您在实际执行命令之前首先查看哪些文件将受到影响。如果您对结果满意，只需在没有它的情况下再次运行该命令。<br/> <code class="fe lv lw lx ly b">-r</code>用于文件夹被移除的情况，允许递归移除。</li><li id="a25b" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">举例:<br/> </strong> (1) <code class="fe lv lw lx ly b">git rm -r -n --cached .</code>(检查受影响的文件)<br/>(2)<code class="fe lv lw lx ly b">git rm -r --cached .</code><br/>(3)<code class="fe lv lw lx ly b">git add .</code><br/>(4)<code class="fe lv lw lx ly b">git commit -m "Remove ignored files"</code><br/>(5)<code class="fe lv lw lx ly b">git push</code></li><li id="5380" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">效果:这是一种积极但有用的命令形式。结果是，您的repo将清除包含在您的<code class="fe lv lw lx ly b">.gitignore</code>中的任何文件，而无需您明确列出每一个文件。</li></ul><h2 id="6aa0" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">资源</h2><ul class=""><li id="0443" class="na nb it lb b lc nc lf nd li ne lm nf lq ng lu nh ni nj nk bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/1274057/how-to-make-git-forget-about-a-file-that-was-tracked-but-is-now-in-gitignore" rel="noopener ugc nofollow" target="_blank">“如何让Git忘记’一个曾经被跟踪但现在还在的文件。gitignore？”|堆栈溢出</a></li><li id="bb72" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><a class="ae ky" href="https://www.codeblocq.com/2016/01/Untrack-files-already-added-to-git-repository-based-on-gitignore" rel="noopener ugc nofollow" target="_blank">"已基于将取消跟踪文件添加到git仓库。gitignore" | CodeBlocQ </a></li><li id="292b" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/5798930/git-rm-cached-x-vs-git-reset-head-x" rel="noopener ugc nofollow" target="_blank">“‘git RM-cached x’vs‘git reset head-x’？”|堆栈溢出</a></li></ul><p id="c31e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#f578" rel="noopener ugc nofollow"> ⬆ </a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="c0f6" class="nx ma it bd mb ny nz oa me ob oc od mh jz oe ka mk kc of kd mn kf og kg mq oh bi translated">创建GitHub版本</h1><p id="68d7" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">最后，这里有一个我最近开始使用的宝石。严格来说，这个命令本身不是Git命令，而是GitHub CLI提供的。所以如果你还没有下载的话，你必须先下载。</p><ul class=""><li id="16d1" class="na nb it lb b lc ld lf lg li ol lm om lq on lu nh ni nj nk bi translated"><strong class="lb iu">命令:</strong>命令:<code class="fe lv lw lx ly b">gh release create &lt;version&gt;</code></li><li id="7972" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">示例(见下面演示):</strong> <code class="fe lv lw lx ly b">gh release create v0.3</code></li><li id="789c" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><strong class="lb iu">效果:</strong>这将打开一个交互式命令行菜单，引导您完成创建您的发布的过程。结果将是从提供的版本<a class="ae ky" href="https://git-scm.com/book/en/v2/Git-Basics-Tagging" rel="noopener ugc nofollow" target="_blank">标签</a>创建的GitHub版本(如果您的repo中不存在这样的标签，将创建一个新标签)。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/0438240016979ecf92486e004b088bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*S0hB89j6uvEWjK0opVlwtg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用GitHub CLI从命令行创建GitHub版本</p></figure><ul class=""><li id="e419" class="na nb it lb b lc ld lf lg li ol lm om lq on lu nh ni nj nk bi translated"><strong class="lb iu">提示:</strong>在<code class="fe lv lw lx ly b">Release notes</code> <em class="op"> </em>提示<em class="op">，</em>选择<code class="fe lv lw lx ly b">Write using commit log as template</code>为有意义的发行说明提供一个良好的起点。最好事先运行<code class="fe lv lw lx ly b">git fetch --all --tags</code>来确保模板中只包含最后一个标签之后的提交。<br/>如果打开了非默认的编辑器，使用<code class="fe lv lw lx ly b">gh config set editor &lt;editor&gt;</code>将其设置为您选择的一个，例如<code class="fe lv lw lx ly b">gh config set editor nano</code>。</li></ul><p id="9b62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是最近<a class="ae ky" href="https://github.com/osharaki/travel_regions/releases/tag/v0.3" rel="noopener ugc nofollow" target="_blank">版本</a>的发行说明示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/5b2683f46f3af722519ce59cbc92a523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WUbSMMj8SIy-nfTyY8dfQA.png"/></div></div></figure><h2 id="de5b" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">资源</h2><ul class=""><li id="44fb" class="na nb it lb b lc nc lf nd li ne lm nf lq ng lu nh ni nj nk bi translated"><a class="ae ky" href="https://cli.github.com/manual/gh_release_create" rel="noopener ugc nofollow" target="_blank"> gh发布创建| GitHub CLI </a></li><li id="cd65" class="na nb it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated"><a class="ae ky" href="https://cli.github.com/manual/gh_config_set" rel="noopener ugc nofollow" target="_blank"> gh配置集| GitHub CLI </a></li></ul><p id="2f76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#f578" rel="noopener ugc nofollow"> ⬆ </a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="98ee" class="nx ma it bd mb ny nz oa me ob oc od mh jz oe ka mk kc of kd mn kf og kg mq oh bi translated">结论</h1><p id="1b0d" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">现在你知道了。这些命令中有多少是你能不假思索就知道的，你还使用过哪些不太为人知但却很强大的命令？</p><p id="e9e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往，很高兴听到你的想法，回答任何问题！</p></div></div>    
</body>
</html>