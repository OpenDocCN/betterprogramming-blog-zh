<html>
<head>
<title>What’s New in Swift 5.3?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 5.3有什么新功能？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-swift-5-3-142d89d4d1f7?source=collection_archive---------5-----------------------#2020-05-18">https://betterprogramming.pub/whats-new-in-swift-5-3-142d89d4d1f7?source=collection_archive---------5-----------------------#2020-05-18</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="a97e" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">跨平台支持、多结尾闭包、多模式catch子句等等</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/ead29813e8b2e63495f641ad35a75ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FYXrss0agbTq1JVx"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@kadh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">基拉·奥德海德</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="ee3d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Swift 5.3发布流程始于3月底，最近才进入开发的最后阶段。扩展跨平台的语言支持，如Windows和Linux发行版，是这个版本的主要目标之一。</p><p id="0f90" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但苹果也非常关注改善整体语言及其性能，以促进iOS的SwiftUI和机器学习。让我们深入了解一下我们将在即将发布的更新中看到的主要变化和功能。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="9fa8" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">多重尾随闭包</h1><p id="b0e1" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">SE-0279 提案为尾随闭包带来了一种新的语法，让您可以以更易读的方式调用多个闭包作为函数的参数。这是更多的语法糖，最小化了函数签名中过多括号的使用。</p><p id="2a37" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">相反，它允许您在最初的未标记闭包之后附加几个标记闭包。以下示例演示了这种情况的一个使用案例:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="e55d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的更改将使我们的SwiftUI视图更容易编写。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="0f3e" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">多模式捕获条款</h1><p id="c5b2" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">目前，do-catch语句中的每个catch子句只能包含一个模式。为了解决这个问题，开发人员最好使用switch cases的功能在catch语句体中包含模式匹配，从而增加嵌套和重复的代码。</p><p id="94f0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SE-0276 是在catch子句中引入模式匹配的另一个改进。Catch子句现在允许用户指定一个逗号分隔的模式列表，能够将变量与catch主体绑定在一起——就像switch语句一样。这里有一个例子:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="ffda" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">多模式catch子句将有助于使我们的代码库清晰简洁。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="1e18" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">枚举的综合可比一致性</h1><p id="04bf" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">到目前为止，比较两个enum案例并不简单。你必须遵守<code class="fe nc nd ne nf b">Comparable</code>并写一个<code class="fe nc nd ne nf b">static fun &lt;</code>来确定一个案例的原始价值是否低于另一个案例(或者反之亦然<code class="fe nc nd ne nf b">&gt;</code>)。</p><p id="4c33" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">幸运的是，<a class="ae kz" href="https://github.com/apple/swift-evolution/blob/master/proposals/0266-synthesized-comparable-for-enumerations.md" rel="noopener ugc nofollow" target="_blank"> SE-0266 </a>允许我们选择与枚举的<code class="fe nc nd ne nf b">Comparable</code>一致，只要你的枚举有合适的类型，你就不需要显式地实现协议。如果没有设置关联值，<code class="fe nc nd ne nf b">enums</code>将按照声明的语义顺序进行比较。</p><p id="2254" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是一个对它们进行排序的枚举示例:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="15a1" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">将病例枚举为方案见证</h1><p id="4aec" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Swift有一个非常严格的协议见证匹配模型，其中使用与协议相同的名称和参数编写enum案例不被视为匹配。我们被迫转而依靠手动实现，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="f9b1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://github.com/apple/swift-evolution/blob/master/proposals/0280-enum-cases-as-protocol-witnesses.md" rel="noopener ugc nofollow" target="_blank"> SE-0280 </a>取消了这一限制，因此如果enum病例提供了与方案要求相同的病例名称和参数，它们就可以成为方案见证。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="dddf" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">自我并不是到处都需要的</h1><p id="e041" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">SE-0269 提案允许我们在不再需要的地方省略<code class="fe nc nd ne nf b">self</code>。早先，当我们从外部范围获取值时，在闭包中使用<code class="fe nc nd ne nf b">self</code>是必要的。现在，当参考周期不太可能发生时，<code class="fe nc nd ne nf b">self</code>将隐含地存在。</p><p id="1f02" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面的例子说明了这种变化:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="dbfa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用SwiftUI的开发人员会欣然接受这一点。由于视图保存在<code class="fe nc nd ne nf b">structs</code>中，这是值类型，引用周期不能发生。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="9d14" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">基于类型的程序入口点</h1><p id="7514" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated"><a class="ae kz" href="https://github.com/apple/swift-evolution/blob/master/proposals/0281-main-attribute.md" rel="noopener ugc nofollow" target="_blank"> SE-0281 </a>赋予了我们一个新的<code class="fe nc nd ne nf b">@main</code>属性，让我们定义应用的入口点。您不必再手动调用<code class="fe nc nd ne nf b">AppDelegate.main()</code>方法，因为用属性标记结构或类可以确保它是您程序的起点。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="7c1f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以假设旧的特定领域提供的属性<code class="fe nc nd ne nf b">@UIApplicationMain</code>和<code class="fe nc nd ne nf b">@NSApplicationMain</code>将在未来的版本中被弃用，而支持<code class="fe nc nd ne nf b">@main</code>。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="f382" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">上下文泛型声明上的where子句</h1><p id="76b5" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">到目前为止，<code class="fe nc nd ne nf b">where</code>子句不能放在嵌套在泛型上下文中的声明上。例如，如果您试图在一个函数上设置一个<code class="fe nc nd ne nf b">where</code>约束，编译器会抛出一个错误。作为一种变通方法，我们必须创建单独的扩展来处理特定的<code class="fe nc nd ne nf b">where</code>子句。</p><p id="a382" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有了<a class="ae kz" href="https://github.com/apple/swift-evolution/blob/master/proposals/0267-where-on-contextually-generic.md" rel="noopener ugc nofollow" target="_blank"> SE-0267 </a>，只要我们引用通用参数，我们就可以用<code class="fe nc nd ne nf b">where</code>子句实现函数。下面是一段代码片段，可以让我们对它有所了解:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="5a77" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过允许在成员声明中使用<code class="fe nc nd ne nf b">where</code>子句，我们可以轻松地创建更短、更简洁的通用接口，避免创建单独的扩展。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="d837" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">非连续元素的新集合操作</h1><p id="9aad" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">目前，访问集合中连续范围的元素非常简单。对于数组，你需要做的就是<code class="fe nc nd ne nf b">[startIndex...endIndex]</code>。</p><p id="1f6a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://github.com/apple/swift-evolution/blob/master/proposals/0270-rangeset-and-collection-operations.md" rel="noopener ugc nofollow" target="_blank"> SE-0270 </a>引入了一个新的优化的<code class="fe nc nd ne nf b">RangeSet</code>类型，它允许我们获取一个可以不连续的索引子范围。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="7826" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用<code class="fe nc nd ne nf b">RangeSet</code>，我们可以对集合进行大量的计算和操作。例如，通过使用<code class="fe nc nd ne nf b">moveSubranges</code>函数，我们可以移动数组中的一系列索引。看看通过将所有偶数移到开头来调整数组是多么容易:</p><pre class="kk kl km kn gu ng nf nh ni aw nj bi"><span id="b32a" class="nk me iu nf b gz nl nm l nn no">let rangeOfEvens = numbers.moveSubranges(indicesOfEvens, to: numbers.startIndex)<br/>// numbers == [2, 4, 6, 8, 10, 12, 14, 1, 3, 5, 7, 9, 11, 13, 15]</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="2dda" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">提炼didSet语义</h1><p id="ba5c" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">以前，<code class="fe nc nd ne nf b">didSet</code>属性观察者的getter总是被调用来检索<code class="fe nc nd ne nf b">oldValue</code>,不管引用是否首先被赋值。</p><p id="4e1a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于变量来说，这可能不是一个大问题，但是对于大型数组来说，分配存储和加载一个不使用的值很容易影响应用程序的性能。</p><p id="05ba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SE-0268 通过只在需要时加载<code class="fe nc nd ne nf b">oldValue</code>来提高<code class="fe nc nd ne nf b">didSet</code>属性观察器的效率。此外，如果我们有一个简单的<code class="fe nc nd ne nf b">didSet</code>而没有<code class="fe nc nd ne nf b">willSet</code>，那么修改现在将在适当的位置发生。</p><p id="0358" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里有一个精炼的例子<code class="fe nc nd ne nf b">didSet</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="0aae" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">一种新型浮子16</h1><p id="b35d" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated"><a class="ae kz" href="https://github.com/apple/swift-evolution/blob/master/proposals/0277-float16.md" rel="noopener ugc nofollow" target="_blank"> SE-0277 </a>介绍了<code class="fe nc nd ne nf b">Float16</code> —一种半精度浮点。随着近年来机器学习在移动设备上的出现，这只能表明苹果公司进一步推进这一目标的雄心。A <code class="fe nc nd ne nf b">Float16</code>通常在移动GPU上用于计算，并作为ML应用中权重的压缩格式。</p><pre class="kk kl km kn gu ng nf nh ni aw nj bi"><span id="8435" class="nk me iu nf b gz nl nm l nn no">let f16: Float16 = 7.29</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="ab33" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结束语</h1><p id="c31b" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">以上总结了重要的Swift 5.3语言功能，同时Swift Package Manager也有许多改进。让我们快速浏览一下:</p><ul class=""><li id="a912" class="np nq iu lc b ld le lg lh lj nr ln ns lr nt lv nu nv nw nx bi translated"><a class="ae kz" href="https://github.com/apple/swift-evolution/blob/master/proposals/0271-package-manager-resources.md" rel="noopener ugc nofollow" target="_blank"> SE-0271 </a>允许您添加资源(图像、数据文件等。)到您的Swift包裹。</li><li id="ee77" class="np nq iu lc b ld ny lg nz lj oa ln ob lr oc lv nu nv nw nx bi translated"><a class="ae kz" href="https://github.com/apple/swift-evolution/blob/master/proposals/0278-package-manager-localized-resources.md" rel="noopener ugc nofollow" target="_blank"> SE-0278 </a>可以添加本地化资源。</li><li id="e24b" class="np nq iu lc b ld ny lg nz lj oa ln ob lr oc lv nu nv nw nx bi translated">SE-0272 允许你在你的包管理器中集成闭源依赖，比如二进制格式的Firebase。</li><li id="3805" class="np nq iu lc b ld ny lg nz lj oa ln ob lr oc lv nu nv nw nx bi translated"><a class="ae kz" href="https://github.com/apple/swift-evolution/blob/master/proposals/0273-swiftpm-conditional-target-dependencies.md" rel="noopener ugc nofollow" target="_blank"> SE-0273 </a>允许您有条件地为不同的目标平台指定依赖关系管理器。</li></ul><p id="54a9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以从这篇博文中下载Swift的Linux发行版。或者你可以前往<a class="ae kz" href="https://swift.org/download/#snapshots" rel="noopener ugc nofollow" target="_blank"> Swift的网站</a>先睹为快Swift 5.3的快照版本。</p><p id="829b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一次到此为止。感谢阅读。</p></div></div>    
</body>
</html>