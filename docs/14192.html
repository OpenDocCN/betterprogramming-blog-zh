<html>
<head>
<title>How To Implement Generic as Possible Methods in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Rust中尽可能实现泛型方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-a-generic-as-possible-method-in-rust-ad445c0e226d?source=collection_archive---------9-----------------------#2022-11-15">https://betterprogramming.pub/how-to-implement-a-generic-as-possible-method-in-rust-ad445c0e226d?source=collection_archive---------9-----------------------#2022-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="85e1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用科学计算示例的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/87f514ae55ec55594fa27ad7a861abf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aPeQCA8IoOL-mw0DBXWY_Q.png"/></div></div></figure><div class="ku kv gp gr kw kx"><a href="https://medium.com/@applied-math-coding/membership" rel="noopener follow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd iu gy z fp lc fr fs ld fu fw is bi translated">通过我的推荐链接加入Medium-applied . math . coding</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">获得我所有的故事，以及其他作家在媒体上发表的成千上万的故事。我坚信，媒介是…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">medium.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll ks kx"/></div></div></a></div><p id="22bd" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在这篇短文中，我想介绍一种有用的方法，当您需要实现一个方法并尽可能保持类型限制的通用性时。我们正在看一个简单实现的例子，欧拉方法，以解决一个常微分方程。在你耸耸肩之前，理解这个故事不需要任何常微分方程或欧拉方法的知识。只有在这种情况下，它提供了一个特别合适的例子，因为，特别是在科学计算中，人们常常希望尽可能少地限制自己的类型。</p><p id="d233" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">有时，这甚至导致动态语言比静态类型语言更受青睐。尽管众所周知，动态语言的性能远不如它们的类型化对应物。</p><p id="59df" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们将看到Rust提供了通用性、安全性和性能解决方案。</p><p id="bb56" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">对于那些需要对Rust做一个小总结的人，我推荐<a class="ae mi" href="https://applied-math-coding.medium.com/list/an-introduction-into-rust-22c99777c5e5" rel="noopener">这个</a>我的文章阅读列表。</p><h1 id="2653" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">欧拉方法</h1><p id="1625" class="pw-post-body-paragraph lm ln it lo b lp nb ju lr ls nc jx lu lv nd lx ly lz ne mb mc md nf mf mg mh im bi translated">欧拉法是求解常微分方程最简单的方法之一。后者是以下形式的方程</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="c01b" class="nl mk it nh b be nm nn l no np">y'(t) = f(t, y)<br/><br/>with y(a) = y_a</span></pre><p id="bde3" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">其中映射区间<code class="fe nq nr ns nh b">[a,b] -&gt; X</code>的函数<code class="fe nq nr ns nh b">y(t)</code>是未知的。<code class="fe nq nr ns nh b">X</code>可能是一个非常普通的空间，但就像真实的线条<code class="fe nq nr ns nh b">R</code>一样“简单”。</p><p id="4f31" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">一个例子是</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="44dd" class="nl mk it nh b be nm nn l no np">y'(t) = y(t) * sin(t)<br/><br/>f: (t, y) |-&gt; y * sin(t)</span></pre><p id="61e2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">解决这个问题的方法是<code class="fe nq nr ns nh b">y(t) = exp(-cos(t))</code>。但是，一般来说，并不总是可能找到一个“封闭形式”的解决方案。对于这种情况，我们需要使用一种方法来在数值上找到<code class="fe nq nr ns nh b">y(t)</code>。</p><p id="d9ab" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">一种这样的方法是简单的欧拉方法:</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="16cf" class="nl mk it nh b be nm nn l nt np">y_0 := a<br/><br/>y_{i+1} = y_i + h * f(t_i, y_i)</span></pre><p id="ea27" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这个想法是通过一个宽度为<code class="fe nq nr ns nh b">h</code>的网格来分割间隔:</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="779e" class="nl mk it nh b be nm nn l no np">a = t_0 &lt; t_1 &lt; t_2 &lt; ... &lt; t_n = b<br/><br/>t_1 - t_0 = h<br/>t_2 - t_1 = h<br/>...</span></pre><p id="062d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">然后通过迭代上面的模式找到<code class="fe nq nr ns nh b">y(b)</code>。</p><h1 id="5613" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">履行</h1><p id="0876" class="pw-post-body-paragraph lm ln it lo b lp nb ju lr ls nc jx lu lv nd lx ly lz ne mb mc md nf mf mg mh im bi translated">如上所述，<code class="fe nq nr ns nh b">y(t)</code>映射到的空间<code class="fe nq nr ns nh b">X</code>可以是非常通用的类型。因此，例如，<code class="fe nq nr ns nh b">X</code>可以是空间<code class="fe nq nr ns nh b">R^n</code>，即所有的n元组。也可能是<code class="fe nq nr ns nh b">C</code>，复数。</p><p id="b9bf" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">可以看出，欧拉方法对所有这些情况都同样适用。因此，我们希望只实现一次该方法，以避免代码重复。但是，问题在于类型！我们可以只用<code class="fe nq nr ns nh b">f64</code>来表示<code class="fe nq nr ns nh b">R</code>，<code class="fe nq nr ns nh b">R^n</code>可能需要类似<code class="fe nq nr ns nh b">Vec&lt;f64&gt;</code>的东西。</p><p id="6d8e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">以下方法将有助于产生能够处理所有合适空间的实施<code class="fe nq nr ns nh b">X</code>:</p><blockquote class="nu nv nw"><p id="3f89" class="lm ln nx lo b lp lq ju lr ls lt jx lu ny lw lx ly nz ma mb mc oa me mf mg mh im bi translated">从只使用泛型类型实现开始:</p></blockquote><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="d05f" class="nl mk it nh b be nm nn l nt np">fn solve&lt;T, Y&gt;(a: T, b: T, h: T, y_a: Y, f: fn(t: T, y: &amp;Y) -&gt; Y) -&gt; Vec&lt;Y&gt; {<br/><br/>  let mut y = vec![y_a];<br/>  let mut t_i = a;         // y(a) = y_a<br/><br/>  while t_i &lt; b {<br/>    let y_i = y.last().unwrap();<br/>    y.push(y_i + f(t_i, y_i) * h);   // y_{i+1} = y_i + h * f(t_i, y_i)<br/>    t_i = t_i + h;<br/>  }<br/>  y<br/>}</span></pre><p id="208e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">编译器立即开始对我们大喊大叫。你会看到这样的东西</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="e61d" class="nl mk it nh b be nm nn l nt np">error[E0369]: cannot add `T` to `T`<br/>  --&gt; src\main.rs:47:15<br/>   |<br/>47 |     t_i = t_i + h;<br/>   |           --- ^ - T<br/>   |           |<br/>   |           T<br/>   |<br/>help: consider restricting type parameter `T`</span></pre><p id="4084" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这使我们自动进入下一步。</p><blockquote class="nu nv nw"><p id="ff68" class="lm ln nx lo b lp lq ju lr ls lt jx lu ny lw lx ly nz ma mb mc oa me mf mg mh im bi translated">R <!-- -->通过尽可能弱的特征界限来限制泛型类型:</p></blockquote><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="df26" class="nl mk it nh b be nm nn l nt np">use std::ops::{Add, Mul};<br/><br/>fn solve&lt;T, Y&gt;(a: T, b: T, h: T, y_a: Y, f: fn(t: T, y: &amp;Y) -&gt; Y) -&gt; Vec&lt;Y&gt;<br/>where<br/>    T: Copy + Add&lt;T, Output = T&gt; + PartialOrd,<br/>    Y: Mul&lt;T, Output = Y&gt;,<br/>    for&lt;'a&gt; &amp;'a Y: Add&lt;Y, Output = Y&gt;,<br/>{<br/>    let mut y = vec![y_a];<br/>    let mut t_i = a;<br/>    while t_i &lt; b {<br/>        let y_i = y.last().unwrap();<br/>        y.push(y_i + f(t_i, y_i) * h);<br/>        t_i = t_i + h;<br/>    }<br/>    y<br/>}</span></pre><p id="e14b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们只是增加了以下<code class="fe nq nr ns nh b">where</code>条款:</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="176a" class="nl mk it nh b be nm nn l nt np">where<br/>    T: Copy + Add&lt;T, Output = T&gt; + PartialOrd,<br/>    Y: Mul&lt;T, Output = Y&gt;,<br/>    for&lt;'a&gt; &amp;'a Y: Add&lt;Y, Output = Y&gt;,</span></pre><p id="4251" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这本质上描述了我们需要能够做<code class="fe nq nr ns nh b">T + T</code>、<code class="fe nq nr ns nh b">T &lt; T</code>、<code class="fe nq nr ns nh b">&amp;Y + Y</code>和<code class="fe nq nr ns nh b">Y * T</code>。换句话说，这些是使用的算术运算和顺序关系。您可能会考虑如何记住所有这些晦涩的语法，但实际情况是,<code class="fe nq nr ns nh b">where</code>子句中的上面几行几乎是从编译器输出中复制粘贴的。</p><h1 id="a44c" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">使用该方法</h1><p id="05f5" class="pw-post-body-paragraph lm ln it lo b lp nb ju lr ls nc jx lu lv nd lx ly lz ne mb mc md nf mf mg mh im bi translated">让我们尝试数值求解上面给出的例子，并将结果与封闭形式的解进行比较:</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="f373" class="nl mk it nh b be nm nn l nt np">let f = |t: f64, y: &amp;f64| y * f64::sin(t);<br/>let y = |t: f64| f64::exp(-f64::cos(t));<br/>let [a, b] = [0.0, 1.0];<br/>let y_a = y(a);<br/>    <br/>println!(<br/>   "{} {}",<br/>   y(b),<br/>   solve(a, b, 0.001, y_a, f).last().unwrap()<br/>);</span></pre><p id="161d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这个打印<code class="fe nq nr ns nh b">0.5825721107833085 0.582247781180181</code>。或者可以在这里看到自己<a class="ae mi" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=59fa6f43dfa79d411a2d207658ec3765" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="0bd2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如你所见，我们将我们的方法(求解器)用于由<code class="fe nq nr ns nh b">f64</code>表示的<code class="fe nq nr ns nh b">X</code>的情况。您可以通过使用<code class="fe nq nr ns nh b">f32</code>来做同样的事情，由于是通用实现，<code class="fe nq nr ns nh b">solve</code>的工作方式也是一样的:</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="81d1" class="nl mk it nh b be nm nn l nt np">let f = |t: f32, y: &amp;f32| y * f32::sin(t);<br/>let y = |t: f32| f32::exp(-f32::cos(t));<br/>let [a, b] = [0.0, 1.0];<br/>let y_a = y(a);<br/>    <br/>println!(<br/>   "{} {}",<br/>   y(b),<br/>   solve(a, b, 0.001, y_a, f).last().unwrap()<br/>);</span></pre><p id="f88d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">然而真正令人震惊的是。我们可以使用<code class="fe nq nr ns nh b">f64</code>任何实现<code class="fe nq nr ns nh b">where</code>中给出的特征界限的结构。例如，如果<code class="fe nq nr ns nh b">X</code>是一个复数，你可以使用crate <a class="ae mi" href="https://crates.io/crates/complex_algebra" rel="noopener ugc nofollow" target="_blank"> complex_algebra </a>提供的struct <code class="fe nq nr ns nh b">c</code>。或者如果<code class="fe nq nr ns nh b">X</code>是实值矩阵，你可以使用机箱<a class="ae mi" href="https://crates.io/crates/matrix_algebra" rel="noopener ugc nofollow" target="_blank">矩阵代数</a>。更好的是，您可以为它提供您自己的实现所需特征的结构(这真的很简单！)并且只使用求解器。</p><p id="cce1" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">上面的教程使用了欧拉方法作为例子，但是你应该很容易在你自己的研究/编码领域找到应用。如果您对所有方法都使用上述模式，那么您就有了一个通用库。根据逻辑功能和关系进行各种限制的人。</p><p id="0a09" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo iu">注意:</strong>你不应该在后端编码这样的环境中使用上面的模式，在那里特定的类型是给定的。你会给你的代码增加不必要的复杂性。</p><p id="6551" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">感谢阅读！</p></div></div>    
</body>
</html>