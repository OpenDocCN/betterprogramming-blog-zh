<html>
<head>
<title>Solidity Tutorial: All About Imports</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实度教程:关于导入的所有内容</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solidity-tutorial-all-about-imports-c65110e41f3a?source=collection_archive---------1-----------------------#2022-03-21">https://betterprogramming.pub/solidity-tutorial-all-about-imports-c65110e41f3a?source=collection_archive---------1-----------------------#2022-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a330" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入分析具有可靠性的重要陈述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c8ac81f080adc73f89b37478c6ebbf00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hzDe6qsXf5HzDSRQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@timschmidbauer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂姆·施密德鲍尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="99df" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">目录</h1><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="a8c6" class="lw la it ls b gy lx ly l lz ma">Modules and Code Modularity.</span><span id="25dd" class="lw la it ls b gy mb ly l lz ma">Solidity Imports.</span><span id="048f" class="lw la it ls b gy mb ly l lz ma">Types of Solidity Import Syntax.<br/>* Global Import<br/>* Specific Imports</span><span id="47e8" class="lw la it ls b gy mb ly l lz ma">Import Aliases.<br/>* Global Alias<br/>* Alias Specific</span><span id="0ade" class="lw la it ls b gy mb ly l lz ma">Which import syntax to use?</span><span id="0280" class="lw la it ls b gy mb ly l lz ma">What can you import from a Solidity file?</span><span id="e111" class="lw la it ls b gy mb ly l lz ma">Solidity Import Syntax Cheatsheet</span></pre><h1 id="3c31" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">模块和代码模块化</h1><p id="162f" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">在深入Solidity中的Import语句之前，我们先来了解一下模块化编程。模块的概念非常古老。44年前，随着编程语言Modula-2和Pascal的出现，它首次出现。</p><p id="8bfd" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">模块背后的想法是将代码分解成可重用的组件。您将功能分组到一个模块文件中，并将它们暴露给其他文件，以便这些其他文件可以使用它们。</p><p id="0973" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">模块系统通过将有意义的变量和函数组合在一个文件中来帮助组织你的代码。</p><p id="5494" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">让我们以Javascript (ES6)中的模块为例。在ES6中，模块是导出一个或多个值(对象、函数或变量)的文件。然后，任何其他Javascript模块都可以通过导入它来使用这个文件提供的功能(Copes，<em class="nd"> 2018 </em>)。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="d95b" class="kz la it bd lb lc nl le lf lg nm li lj jz nn ka ll kc no kd ln kf np kg lp lq bi translated">坚固性进口</h1><p id="df87" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">Solidity中导入文件的思路与上面描述的模块概念非常相似。它通过以下方式帮助模块化您的智能合同:</p><ul class=""><li id="a129" class="nq nr it me b mf my mi mz ml ns mp nt mt nu mx nv nw nx ny bi translated">创建其他文件可以导入的可重用片段。</li><li id="bc57" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated">更容易理解和消化你的项目的整个Solidity代码库。</li><li id="af19" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated">通过关注更小的文件，使使用<em class="nd">【实体模块】</em>更容易(在调试时有用)。</li></ul><p id="b6df" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">您可以将变量(如文件级定义的<code class="fe oe of og ls b">constant</code>、<code class="fe oe of og ls b">enum</code>、<code class="fe oe of og ls b">struct</code>)和其他实体对象(如<code class="fe oe of og ls b">contract</code>、<code class="fe oe of og ls b">interface</code>或<code class="fe oe of og ls b">library</code>)分组并定义到一个文件中。只有一次。然后您可以导入它们，并使用<code class="fe oe of og ls b">import</code> <em class="nd"> </em>语法在其他实体文件中使用它们。</p><p id="6724" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">与Javascript或<a class="ae ky" href="https://en.cppreference.com/w/cpp/language/modules" rel="noopener ugc nofollow" target="_blank"> C++ </a>等其他编程语言的唯一区别是，你不需要用<code class="fe oe of og ls b">export</code> <em class="nd"> </em>关键字直接(显式)定义这些变量或Solidity对象。</p><blockquote class="oh oi oj"><p id="a66b" class="mc md nd me b mf my ju mh mi mz jx mk ok na mn mo ol nb mr ms om nc mv mw mx im bi translated"><strong class="me iu">注意:</strong>注意，Solidity不支持默认导出。</p></blockquote><p id="5742" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">让我们来看看Solidity中的一个<code class="fe oe of og ls b">import</code>语句，它受到了t <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank"> he ES6导入语法</a>的启发，并且与Python导入语法也非常相似(<code class="fe oe of og ls b">from X import *</code> <em class="nd"> </em>)。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="916a" class="lw la it ls b gy lx ly l lz ma">import “./MySolidityFile.sol”;</span></pre><p id="b0ca" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">上面的代码片段展示了大多数开源Solidity项目中经典且最广泛使用的导入语法。在这里，<code class="fe oe of og ls b"><em class="nd">“./MySolidityFile.sol”</em></code> <em class="nd"> </em>是指向我们要导入的文件的路径。这个路径是相对于的<strong class="me iu">，意思是基于我们从</strong> (=当前文件)导入的位置的<strong class="me iu">。</strong></p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="bc98" class="kz la it bd lb lc nl le lf lg nm li lj jz nn ka ll kc no kd ln kf np kg lp lq bi translated">实体导入语法的类型</h1><h2 id="e005" class="lw la it bd lb on oo dn lf op oq dp lj ml or os ll mp ot ou ln mt ov ow lp ox bi translated">全球进口</h2><p id="e2a2" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">下面的语句将导入在<code class="fe oe of og ls b">“./MySolidityFile.sol”</code>中找到的所有<strong class="me iu"> <em class="nd">实体对象</em> </strong></p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="a97d" class="lw la it ls b gy lx ly l lz ma">import “./MySolidityFile.sol”;</span></pre><p id="e602" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">我使用术语<em class="nd">“实体对象”</em>来描述任何<code class="fe oe of og ls b">contract</code>、<code class="fe oe of og ls b">library</code>、<code class="fe oe of og ls b">interface</code>或其他<code class="fe oe of og ls b">constant</code>或你可以在文件级定义的变量(<code class="fe oe of og ls b">struct</code>、<code class="fe oe of og ls b">enum</code>等)。)</p><blockquote class="oh oi oj"><p id="6863" class="mc md nd me b mf my ju mh mi mz jx mk ok na mn mo ol nb mr ms om nc mv mw mx im bi translated"><em class="it">注意:这相当于ES6中的</em> <code class="fe oe of og ls b"><em class="it">import * from “./MySolidityFile.sol” </em></code> <em class="it">，但是Solidity不允许这种语法。</em></p></blockquote><p id="f43e" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">当Solidity编译器遇到这个语句时，会发生两件事。</p><ol class=""><li id="d2c9" class="nq nr it me b mf my mi mz ml ns mp nt mt nu mx oy nw nx ny bi translated">在<code class="fe oe of og ls b">“./MySolidityFile<em class="nd">.sol”</em></code> <em class="nd"> </em>中定义的所有全局符号(我称之为"<em class="nd">实体对象"</em>)被导入到当前的全局范围中。</li><li id="f4d4" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx oy nw nx ny bi translated">所有导入到<code class="fe oe of og ls b">“./MySolidityFile<em class="nd">.sol”</em></code> <em class="nd"> </em>内的全局符号也被导入到当前的全局范围内。</li></ol><p id="89bb" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">这和ES6很不一样！在ES6中，当你导入一个模块时，你导入的是这个模块中定义的东西，<em class="nd">不是这个模块中导入的所有东西。</em></p><p id="9a05" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">我们举个简单的例子来了解一下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="12a1" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">文件<code class="fe oe of og ls b">“<em class="nd">GPS.sol”</em></code> <em class="nd"> </em>中的第一行导入了在<code class="fe oe of og ls b"><em class="nd">“Endpoints.sol”</em></code> <em class="nd">中定义的三个<code class="fe oe of og ls b">address</code>常量。</em>文件<code class="fe oe of og ls b">“<em class="nd">CarGPS.sol”</em></code> <em class="nd"> </em>可以使用它们，尽管它不会直接导入文件<code class="fe oe of og ls b"><em class="nd">“Endpoint.sol” </em></code> <em class="nd">。</em></p><p id="5c64" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">在Solidity中，文件A中导入的所有内容随后都可以在导入A的其他文件中使用。</p><p id="4253" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">下面举一个实际例子来更好地理解这些<strong class="me iu"> <em class="nd">后续进口</em> </strong> <em class="nd"> </em>如何工作<em class="nd">。</em>如果我注释掉行<code class="fe oe of og ls b"><em class="nd">import “./Endpoints.sol”;</em></code> <em class="nd"> i </em> nside <code class="fe oe of og ls b"><em class="nd">“GPS.sol”</em></code> <em class="nd">，</em>编译器就再也找不到常量了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/adc22d0cc98cb5c1be91b1521ff73d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*py9JeW_QxR6BiJ6Ah149uA.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/a084ce307e03afae41a64467187c3e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*6pQTwaojiIawCr2aWfnfpw.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/f2a46f89decd183abcca8ff2f946e026.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*p9XE7HNQSOI5ykfJ4Zwkkw.png"/></div></figure><p id="3fa5" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">这种全局导入语法的问题在于，即使常量<code class="fe oe of og ls b"> SIGNAL_TOWER_A</code>是在<code class="fe oe of og ls b"><em class="nd">“GPS.sol”</em></code> <em class="nd"> </em>文件中导入的，也很难知道它来自<code class="fe oe of og ls b"><em class="nd">“./Endpoint.sol”</em></code> <em class="nd">。</em>对<code class="fe oe of og ls b"><em class="nd">“./GPS.sol”</em></code> <em class="nd"> </em>中导入定义的一个小更新会破坏它并使它停止编译。</p><p id="08c5" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">不推荐使用这种全局导入语法，因为它很难理解<strong class="me iu">模块从哪里来</strong>或者<strong class="me iu">模块在哪里被定义。</strong></p><p id="f91e" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">在Solidity文档中甚至提到了这一点:</p><blockquote class="pe"><p id="3431" class="pf pg it bd ph pi pj pk pl pm pn mx dk translated"><em class="po">“不推荐使用这种形式，因为它会不可预知地污染名称空间。”</em></p><p id="9339" class="pf pg it bd ph pi pj pk pl pm pn mx dk translated"><em class="po">如果您在“文件名”中添加了新的顶层项目，它们会自动出现在所有从“文件名”导入的文件中。</em></p></blockquote><p id="6b64" class="pw-post-body-paragraph mc md it me b mf pp ju mh mi pq jx mk ml pr mn mo mp ps mr ms mt pt mv mw mx im bi translated">相反，Solidity文档建议显式指定导入的符号。</p><h2 id="e7c0" class="lw la it bd lb on oo dn lf op oq dp lj ml or os ll mp ot ou ln mt ov ow lp ox bi translated">特定进口</h2><p id="f089" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">特定的导入更接近于ES6语法。您可以更具体地从实体文件中导入您需要的内容。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="9d78" class="lw la it ls b gy lx ly l lz ma">Import { Something } from “./MySolidityFile.sol”;</span></pre><p id="d4b7" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">然后，您可以在花括号<code class="fe oe of og ls b">{ }</code>中提到您想要导入和使用的特定符号/对象。例如，如果导入路径中指定的文件包含多个<code class="fe oe of og ls b">contract</code>，那么您可以使用该语法来确定您希望导入的合同。</p><p id="77fb" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">让我们来看看下面这个来自<a class="ae ky" href="https://github.com/Rari-Capital/solmate" rel="noopener ugc nofollow" target="_blank"> <strong class="me iu"> Solmate </strong> </a> <strong class="me iu">，</strong>的例子，这是一个正在开发中的智能合同库，可用于构建现代的和gas优化的合同。</p><p id="12f7" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">专门看一下<code class="fe oe of og ls b"><em class="nd">RoleAuthority.sol</em></code> <em class="nd"> </em>合同。它定义了下面的import语句。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/e7a07a63be027847c49d4c8060436b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*1Idw6cp7OvUWM6QHY8QCRw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://github.com/Rari-Capital/solmate/blob/main/src/auth/authorities/RolesAuthority.sol" rel="noopener ugc nofollow" target="_blank">https://github . com/Rari-Capital/sol mate/blob/main/src/auth/authorities/roles authority . sol</a></p></figure><p id="be63" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">从上面可以看出，在花括号中指定契约或其他符号有助于定位它们。</p><p id="302e" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated"><em class="nd"> Auth </em>合同更容易找到，因为它与文件名<code class="fe oe of og ls b">“<em class="nd">Auth.sol”</em>.</code>同名，但是对于<code class="fe oe of og ls b">Authority</code> <em class="nd"> </em>(尽管名称是<code class="fe oe of og ls b">interface</code>)，如果进口声明是<code class="fe oe of og ls b">Import “../Auth.sol”</code> <em class="nd">，就不会找到它。</em></p><p id="d341" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">带花括号的导入语法有助于定位构建智能契约的构件(<code class="fe oe of og ls b">abstract contract</code>、<code class="fe oe of og ls b">interface</code>、<code class="fe oe of og ls b">library</code>等)。)来自哪些文件以及它们是哪些文件<strong class="me iu">实际定义了</strong>。</p><p id="4163" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">让我们重写上面来自<strong class="me iu">“全局导入”</strong>部分的代码示例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="e64e" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">我们的代码重构增加了一个额外的导入行，帮助定位常量<code class="fe oe of og ls b">SIGNAL_TOWER_A</code> <em class="nd">来自</em>(而不是<em class="nd">“埋葬它”</em>)。</p><p id="a86f" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">我们的可靠性代码在另一方面也更干净，这可能不会被注意到:T9。我们以前使用全局导入功能导入它，但没有使用它。<code class="fe oe of og ls b">Point</code>结构用一个我们不需要的对象“污染了源代码”,因为我们不需要它。这打破了模块化和模块化编程的规则:</p><blockquote class="pe"><p id="90d0" class="pf pg it bd ph pi pj pk pl pm pn mx dk translated"><em class="po">“只导入你需要的东西”</em></p></blockquote><p id="0ecd" class="pw-post-body-paragraph mc md it me b mf pp ju mh mi pq jx mk ml pr mn mo mp ps mr ms mt pt mv mw mx im bi translated">带花括号的特定导入允许我们更好地应用这条规则。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="7967" class="kz la it bd lb lc nl le lf lg nm li lj jz nn ka ll kc no kd ln kf np kg lp lq bi translated">导入别名</h1><p id="d963" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">导入别名在可靠性方面非常古老，可以追溯到<a class="ae ky" href="https://github.com/ethereum/solidity/blob/develop/Changelog.md#021-2016-01-30" rel="noopener ugc nofollow" target="_blank">发布版本0.2.1。</a>导入别名可用于两种类型的导入:</p><ul class=""><li id="d8ab" class="nq nr it me b mf my mi mz ml ns mp nt mt nu mx nv nw nx ny bi translated"><strong class="me iu"/><strong class="me iu">全局导入的别名:</strong>可以用来引用文件中定义的特定对象，使用点“.”语法(如对象属性)。</li><li id="22a6" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated"><strong class="me iu">特定导入的别名:</strong>启用重命名从实体文件导入的对象或符号，例如，以避免命名冲突(或如果需要，为更好的代码清晰度给出更好的名称)。</li></ul><h2 id="f4e4" class="lw la it bd lb on oo dn lf op oq dp lj ml or os ll mp ot ou ln mt ov ow lp ox bi translated">全局别名</h2><p id="d177" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">可以使用通配符运算符<code class="fe oe of og ls b">*</code>和别名<code class="fe oe of og ls b">as</code> <em class="nd">创建包含导入文件中定义的所有内容的全局别名。</em></p><p id="0f54" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">在下面的代码片段中，创建了一个新的全局符号<code class="fe oe of og ls b"><em class="nd">Endpoints</em></code> <em class="nd"> </em>，并且<em class="nd"> </em>在文件的上下文中变得可用。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="6fb4" class="lw la it ls b gy lx ly l lz ma">// longer syntax<br/>import * as Endpoints from “./Endpoints.sol”.</span><span id="f848" class="lw la it ls b gy mb ly l lz ma">// shorter syntax<br/>import “./Endpoints.sol” as Endpoints;</span></pre><blockquote class="oh oi oj"><p id="69ec" class="mc md nd me b mf my ju mh mi mz jx mk ok na mn mo ol nb mr ms om nc mv mw mx im bi translated">注意，第二条语句(可选语法)在ES6中没有对等的语句。在ES6模块中，可以使用第一种语法创建模块别名，但第二种语法不存在。</p></blockquote><p id="484c" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">在<code class="fe oe of og ls b">“./Endpoints.sol”</code>(以及在<code class="fe oe of og ls b">“./Endpoints.sol”</code>中导入的)中定义的所有符号和对象现在都可以以格式<code class="fe oe of og ls b">Endpoints.TOWER_ADDRESS_A.</code>获得。它们现在是这个全局符号的成员，可以像访问JavaScript对象的属性(或引用Solidity中的结构成员)一样使用点符号进行访问。</p><h2 id="f48f" class="lw la it bd lb on oo dn lf op oq dp lj ml or os ll mp ot ou ln mt ov ow lp ox bi translated"><strong class="ak">具体别名</strong></h2><p id="7c34" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">如果您使用之前介绍的特定导入来仅导入您的Solidity文件中需要的内容，您也可以为导入的内容指定一个别名。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="5396" class="lw la it ls b gy lx ly l lz ma">import { Point as Coordinate, GPS } from “./Endpoints.sol”;</span></pre><p id="9b50" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">在上面的导入语句中，GPS库被原样导入，而<code class="fe oe of og ls b">struct Point</code>也被导入但被重命名为<code class="fe oe of og ls b">Coordinates</code>。Solidity导入语句创建了一个新的符号<code class="fe oe of og ls b">Coordinates</code>，它引用了<code class="fe oe of og ls b">struct Point</code>。</p><p id="c9ae" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">这种别名在两种情况下很有用:</p><ul class=""><li id="505a" class="nq nr it me b mf my mi mz ml ns mp nt mt nu mx nv nw nx ny bi translated"><strong class="me iu">避免命名冲突:</strong>如果您要导入的内容已经被其他文件导入。如果在导入时遇到命名冲突，请使用别名来解决这个问题。</li><li id="f099" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated"><strong class="me iu">防止意外行为</strong>(如果编译器没有标记它，并且您正在使用的变量引用了从别处导入的错误变量)。</li><li id="81af" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated"><strong class="me iu">重命名您正在导入的内容:</strong>如果您想在您的上下文中使用更有意义的名称，并且为了代码清晰起见。</li></ul></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="767f" class="kz la it bd lb lc nl le lf lg nm li lj jz nn ka ll kc no kd ln kf np kg lp lq bi translated">使用哪种导入语法？</h1><p id="61bc" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">以下是引用自<strong class="me iu"> SonarSource </strong>文档中关于进口的内容。</p><blockquote class="pe"><p id="bb1f" class="pf pg it bd ph pi pj pk pl pm pn mx dk translated"><em class="po">“本着代码越清晰越好的原则，你应该把你想用的东西导入到一个模块里。”</em></p></blockquote><p id="8484" class="pw-post-body-paragraph mc md it me b mf pp ju mh mi pq jx mk ml pr mn mo mp ps mr ms mt pt mv mw mx im bi translated">你可以将这一原则应用于Solidity中的智能合约。虽然大多数在Github上有源代码的开源Solidity项目都使用了<code class="fe oe of og ls b">import ” ./File.sol”</code> <em class="nd"> </em>语法，但这并没有遵循SonarSource提到的最佳实践。</p><p id="60f4" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">PEP8文档也阻碍了Python的全球导入。</p><blockquote class="pe"><p id="46d6" class="pf pg it bd ph pi pj pk pl pm pn mx dk translated"><em class="po">“通配符导入(来自&lt;模块&gt; import *)应该被避免，因为它们使得命名空间中出现的名字变得不清楚，混淆了读者和许多自动化工具。”</em></p></blockquote><p id="6e48" class="pw-post-body-paragraph mc md it me b mf pp ju mh mi pq jx mk ml pr mn mo mp ps mr ms mt pt mv mw mx im bi translated">这个问题的主要原因是，如<strong class="me iu">全局导入部分所述，</strong> <code class="fe oe of og ls b">import “./MySolidityFile.sol”</code> <em class="nd"> </em>从实体文件(在路径中提到)→ <em class="nd">导入所有的<em class="nd">到实体文件</em>(在此声明导入语句)<em class="nd">。</em></em></p><p id="0ea8" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">多年来，我已经习惯了这种Soldity全局导入语法。然而，我现在已经得出结论，从一个Solidity文件导入所有东西会导致几个问题。这些问题分为两大类:可读性和与名称空间相关的错误。</p><h2 id="b314" class="lw la it bd lb on oo dn lf op oq dp lj ml or os ll mp ot ou ln mt ov ow lp ox bi translated"><strong class="ak">可读性</strong></h2><ul class=""><li id="b54c" class="nq nr it me b mf mg mi mj ml pv mp pw mt px mx nv nw nx ny bi translated"><strong class="me iu">冒着混淆Solidity契约或库的维护者</strong> <strong class="me iu">和用户</strong>的风险。</li><li id="1658" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated"><strong class="me iu">降低代码可读性</strong>。使用Solidity契约或库的开发人员可能很难知道导入的名字来自哪里。</li></ul><h2 id="78fb" class="lw la it bd lb on oo dn lf op oq dp lj ml or os ll mp ot ou ln mt ov ow lp ox bi translated"><strong class="ak">与名称空间相关的错误</strong></h2><ul class=""><li id="49cb" class="nq nr it me b mf mg mi mj ml pv mp pw mt px mx nv nw nx ny bi translated">导入所有东西会使本地“名称空间”变得混乱，使调试更加困难。</li><li id="0e18" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated"><strong class="me iu">更新依赖关系时，导入的名称会改变</strong>。因此，今天有效的通配符导入可能明天就会失效。</li></ul><p id="4759" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated"><strong class="me iu">有两种方法可以避免通配符导入:</strong></p><p id="0906" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">-替换为<code class="fe oe of og ls b">import mySolidityModule</code>，访问模块成员为<code class="fe oe of og ls b">mySolidityModule.MyContract</code>。</p><p id="f9d9" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">-列出每个导入的名称。如果需要，可以使用括号(首选解决方案)或反斜杠将import语句拆分成多行。</p><blockquote class="oh oi oj"><p id="779a" class="mc md nd me b mf my ju mh mi mz jx mk ok na mn mo ol nb mr ms om nc mv mw mx im bi translated"><strong class="me iu"> <em class="it">类比:</em> </strong> <em class="it">进口一切相当于两个机械师在车库里修车，其中一个机械师问另一个，“给我一把内六角扳手”，另一个机械师给他带来整个工具箱，而不是从工具箱里拿出内六角扳手递给他。</em></p><p id="07a5" class="mc md nd me b mf my ju mh mi mz jx mk ok na mn mo ol nb mr ms om nc mv mw mx im bi translated"><em class="it">把这个类比想成你和Solidity编译器。您希望通过精确地提供编译器将契约编译成字节码所需的代码来简化编译器的工作。你不希望编译器中塞满不需要的代码，比如“让它搜索整个工具箱”。</em></p></blockquote></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="cc61" class="kz la it bd lb lc nl le lf lg nm li lj jz nn ka ll kc no kd ln kf np kg lp lq bi translated">从实体文件中可以导入什么？</h1><p id="c107" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">可以在实体文件中导入以下元素。</p><ul class=""><li id="ef26" class="nq nr it me b mf my mi mz ml ns mp nt mt nu mx nv nw nx ny bi translated"><code class="fe oe of og ls b">contract</code></li><li id="86b2" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated"><code class="fe oe of og ls b">library</code></li><li id="bf77" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated"><code class="fe oe of og ls b">interface</code></li><li id="c364" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated"><code class="fe oe of og ls b">enum</code>(文件级定义)</li><li id="715a" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated"><code class="fe oe of og ls b">struct</code>(在文件级定义)</li><li id="6c8c" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated"><code class="fe oe of og ls b">error</code>定义(在文件级定义)</li><li id="e32c" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated"><code class="fe oe of og ls b">function</code> s(在文件级定义，从Solidity 0.7.1开始)</li><li id="6f53" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated"><a class="ae ky" href="https://docs.soliditylang.org/en/v0.8.13/types.html#user-defined-value-types" rel="noopener ugc nofollow" target="_blank">用户定义的值类型</a>(自从在Solidity 0.8.8中引入以来)</li></ul></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="324a" class="kz la it bd lb lc nl le lf lg nm li lj jz nn ka ll kc no kd ln kf np kg lp lq bi translated">可靠性导入语法备忘单</h1><p id="8706" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">下面是Solidity中可用的不同导入语句的汇总。我根据<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#description" rel="noopener ugc nofollow" target="_blank"> Javascript ES6文档中提供的关于导入语句的例子编写了这些例子。</a></p><p id="9ba9" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">为了清楚、简单，并使其像ES6文档一样，我称“实体模块”为实体文件，它包含不同的对象/符号，在“你能从实体文件导入什么？”。</p><p id="87ad" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated"><strong class="me iu">导入整个实体模块内容。</strong></p><p id="613f" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">这是最常见的语法。我认为应该尽可能避免使用这种语法，因为它会在不知道导入内容的情况下导入所有内容。以太坊StackExchange的这个回答(参考同题PEP8风格文档)提到它<em class="nd">杂乱且“污染命名空间”。</em></p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="2b22" class="lw la it ls b gy lx ly l lz ma">import "./modules/MySolidityFile.sol";</span></pre><p id="dbab" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated"><strong class="me iu">导入整个实体模块内容，并为其分配一个全局别名。</strong></p><p id="23b6" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">导入所有内容的不同语法。在<em class="nd"> MySolidityFile.sol </em>中定义的内容，可以通过<code class="fe oe of og ls b">mySolidityModule.MyContract</code> <em class="nd">、</em> <code class="fe oe of og ls b">mySolidityModule.MyLibrary</code> <em class="nd"> </em>或<code class="fe oe of og ls b">mySolidityModule.MyStruct</code> <em class="nd">引用。</em></p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="9a14" class="lw la it ls b gy lx ly l lz ma">import * as mySolidityModule from "./modules/MySolidityFile.sol";</span></pre><p id="5a78" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated">第二种语法稍微简短一些。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="1a7b" class="lw la it ls b gy lx ly l lz ma">import "./modules/MySolidityFile.sol" as mySolidityModule;</span></pre><p id="2bf6" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated"><strong class="me iu">从实体模块导入单个导出</strong></p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="2517" class="lw la it ls b gy lx ly l lz ma">import { MyContract } from "./modules/MySolidityFile.sol";</span></pre><p id="fa70" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated"><strong class="me iu">从一个模块导入多个导出</strong></p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="6675" class="lw la it ls b gy lx ly l lz ma">import { <br/>    MyContract, <br/>    MyLibrary, <br/>    MyStruct, <br/>    customFunction <br/>} from "./modules/MySolidityFile.sol";</span></pre><p id="bae4" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated"><strong class="me iu">用更方便的别名</strong>导入导出</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="47cd" class="lw la it ls b gy lx ly l lz ma">import { <br/>    reallyReallyLongSolidityModuleExportName as solidityModule <br/>} from "./modules/MySolidityFile.sol";</span></pre><p id="5fcb" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk ml na mn mo mp nb mr ms mt nc mv mw mx im bi translated"><strong class="me iu">在导入过程中重命名多个导出</strong></p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="99ec" class="lw la it ls b gy lx ly l lz ma">import {<br/>    reallyReallyLongSolidityModuleExportName as solidityModule,<br/>    anotherLongSolidityStructName as MyStruct<br/>} from "/modules/my-module.js";</span></pre></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="e157" class="kz la it bd lb lc nl le lf lg nm li lj jz nn ka ll kc no kd ln kf np kg lp lq bi translated">参考</h1><ul class=""><li id="b90c" class="nq nr it me b mf mg mi mj ml pv mp pw mt px mx nv nw nx ny bi translated">JavaScript导入语法:<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Statements/import</a></li><li id="e459" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated">stack overflow——为什么许多Solidity项目更喜欢导入特定的名字而不是整个模块？<a class="ae ky" href="https://ethereum.stackexchange.com/questions/117100/why-do-many-solidity-projects-prefer-importing-specific-names-over-whole-modules" rel="noopener ugc nofollow" target="_blank">https://ether eum . stack exchange . com/questions/117100/why-do-many-solidity-projects-prefere-importing-specific-names-over-all-modules</a></li><li id="054c" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated">PEP8风格指南—进口:【https://peps.python.org/pep-0008/#imports T4】</li><li id="770d" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated">以太坊栈交换- <em class="nd">应该如何在Solidity中设置导入路径:</em><a class="ae ky" href="https://ethereum.stackexchange.com/questions/2137/how-should-we-set-a-import-path-in-solidity" rel="noopener ugc nofollow" target="_blank">https://ether eum . Stack Exchange . com/questions/2137/How-should-we-set-a-import-path-in-Solidity</a></li><li id="cecd" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated">Solidity Docs —导入其他源文件:<a class="ae ky" href="https://docs.soliditylang.org/en/latest/layout-of-source-files.html?highlight=import#importing-other-source-files" rel="noopener ugc nofollow" target="_blank">https://Docs . solidity lang . org/en/latest/layout-of-source-files . html？highlight = import # importing-其他源文件</a></li><li id="16b7" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated">Solidity-by-example.com—进口:<a class="ae ky" href="https://solidity-by-example.org/import/" rel="noopener ugc nofollow" target="_blank">https://solidity-by-example.org/import/</a></li><li id="9e94" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated">声纳源——关于Python的进口:<a class="ae ky" href="https://rules.sonarsource.com/python/RSPEC-2208" rel="noopener ugc nofollow" target="_blank">https://rules.sonarsource.com/python/RSPEC-2208</a></li><li id="e727" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated">声纳源码—关于Javascript的进口:<a class="ae ky" href="https://rules.sonarsource.com/javascript/RSPEC-2208" rel="noopener ugc nofollow" target="_blank">https://rules.sonarsource.com/javascript/RSPEC-2208</a></li><li id="4105" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated">黑客。Mozilla.org—ES模块a卡通深潜:<a class="ae ky" href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" rel="noopener ugc nofollow" target="_blank">https://hacks . Mozilla . org/2018/03/ES-Modules-a-cartoon-deep-dive/</a></li><li id="5ef0" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated">奇异的编程思想:第一部分(模块系统)(Stephen Diel博客):<a class="ae ky" href="https://www.stephendiehl.com/posts/exotic01.html" rel="noopener ugc nofollow" target="_blank">https://www.stephendiehl.com/posts/exotic01.html</a></li><li id="12e9" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated"><a class="ae ky" href="https://github.com/ethereum/solidity/blob/develop/Changelog.md#021-2016-01-30" rel="noopener ugc nofollow" target="_blank">坚固性变更日志发布</a></li><li id="b4c2" class="nq nr it me b mf nz mi oa ml ob mp oc mt od mx nv nw nx ny bi translated"><a class="ae ky" href="https://github.com/Rari-Capital/solmate/blob/main/src/auth/authorities/MultiRolesAuthority.sol" rel="noopener ugc nofollow" target="_blank"> Solmate —多角色权限</a></li></ul></div></div>    
</body>
</html>