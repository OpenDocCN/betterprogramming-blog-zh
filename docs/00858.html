<html>
<head>
<title>Making a Real World Application With SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI制作真实世界的应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/making-a-real-world-application-with-swiftui-54e71d9e6042?source=collection_archive---------7-----------------------#2019-07-22">https://betterprogramming.pub/making-a-real-world-application-with-swiftui-54e71d9e6042?source=collection_archive---------7-----------------------#2019-07-22</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="60b3" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">第五部分:提示和技巧，剖析，以及我所学到的</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj kj"><img src="../Images/2d5847e20aa1140bfc1b7bd5f91929bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*PeFnya42mpOiCvdgm49ifQ.png"/></div><p class="kr ks gk gi gj kt ku bd b be z dk translated">苹果的SwiftUI标志</p></figure><p id="8eb3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我想在过去几周的空闲时间里，用这篇文章作为对用<a class="ae lr" href="https://developer.apple.com/xcode/swiftui/" rel="noopener ugc nofollow" target="_blank"> SwiftUI </a>编程的一种回顾。这是一个很好的机会来写下并让你知道我对SwiftUI的想法，并分享我在这里和那里写的小代码片段，以使一切都能一起工作。</p><p id="5b06" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><a class="ae lr" href="https://github.com/Dimillian/MovieSwiftUI" rel="noopener ugc nofollow" target="_blank">应用</a>远未完成。我想在9月份与iOS 13一起在App Store上发布——如果SwiftUI同时退出测试的话。我还有很多功能需要改进，还有一些UI需要改进。但是主SwiftUI工作了，演示方面大部分完成了。</p><p id="1eb5" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我对社区感激不尽。我现在有将近2800颗恒星在资料库里。我从没想过它会长那么大。这更激励我制作SwiftUI代码并与大家分享，并向应用程序添加功能，使其成为一个真正的产品，并成为一个漂亮的SwiftUI演示。</p><p id="e0ae" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我已经添加了自定义动画(手势)。我广泛使用了导航和演示系统。我使用表单组件创建了一些表单。我使用Redux作为定制架构。我获取异步数据并加载远程图像。我认为该应用程序覆盖了SwiftUI现有组件的90%,满足了一般开发人员制作真实应用程序的需求。</p><p id="e69f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">现在让我们来看看这个应用程序中我最纠结的几个部分。然后，我们将深入剖析和优化您的SwiftUI代码。在本文的最后一部分，我将比较SwiftUI和UIKit。</p></div><div class="ab cl ls lt hy lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="in io ip iq ir"><h1 id="8073" class="lz ma iu bd mb mc md me mf mg mh mi mj ka mk kb ml kd mm ke mn kg mo kh mp mq bi translated">页码</h1><p id="6a04" class="pw-post-body-paragraph kv kw iu kx b ky mr jv la lb ms jy ld le mt lg lh li mu lk ll lm mv lo lp lq in bi translated">我经常听到这样的问题:如何在我的<code class="fe mw mx my mz b">List</code>上分页？这是一种相当粗糙的方法，但是，到目前为止，我不知道更好的方法。</p><p id="f21d" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">做好准备——你会大吃一惊的。</p><p id="c0b3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">如果您在<a class="ae lr" href="https://github.com/Dimillian/MovieSwiftUI" rel="noopener ugc nofollow" target="_blank">存储库</a>上查看<code class="fe mw mx my mz b">MoviesList.swift</code>，您可能会看到类似这样的内容:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="8634" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">是的，没错，我在我的行后面添加了一个不可见的<code class="fe mw mx my mz b"><a class="ae lr" href="https://developer.apple.com/documentation/swiftui/rectangle" rel="noopener ugc nofollow" target="_blank">Rectangle</a></code>。向下滚动时，会触发<code class="fe mw mx my mz b">onAppear</code>。从那里，它触发所需的任何逻辑，将下一页追加到数据源。</p><p id="c3c4" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在我使用Redux架构的情况下，我分派了一个动作来获取下一个页面，并将其添加到我的reducer中的datasource。当我的<code class="fe mw mx my mz b">MoviesList</code>连接到我的商店时，它会优雅地添加行，用户将能够继续下一页。</p><p id="5555" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我想花时间研究一种更好的方法来使用<code class="fe mw mx my mz b"><a class="ae lr" href="https://developer.apple.com/documentation/swiftui/geometryreader" rel="noopener ugc nofollow" target="_blank">GeometryReader</a></code></p><p id="6ee9" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">额外的好处是在到达<code class="fe mw mx my mz b">List</code>的末尾之前触发下一页的获取。现在，您必须让最底部的不可见视图出现，以便触发获取。而且，有点太晚了。</p></div><div class="ab cl ls lt hy lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="in io ip iq ir"><h1 id="4950" class="lz ma iu bd mb mc md me mf mg mh mi mj ka mk kb ml kd mm ke mn kg mo kh mp mq bi translated">实时搜索</h1><p id="59c7" class="pw-post-body-paragraph kv kw iu kx b ky mr jv la lb ms jy ld le mt lg lh li mu lk ll lm mv lo lp lq in bi translated">我很早就着手解决的事情之一就是搜索。我在live search上做了很多努力，因为我需要读取作为绑定传递给<code class="fe mw mx my mz b">TextField</code>的值。现在，你不能在<code class="fe mw mx my mz b">@State</code>属性上使用<code class="fe mw mx my mz b">didSet</code>。因此，我对传递的值进行了包装，以便在更新时读取文本值。它可以这样使用:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="c90d" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">现在，我们来看看<code class="fe mw mx my mz b">SearchTextWrapper</code> <code class="fe mw mx my mz b"><a class="ae lr" href="https://developer.apple.com/documentation/swiftui/bindableobject" rel="noopener ugc nofollow" target="_blank">BindableObject</a></code>类。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="a668" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">如果你看上面的代码，你会看到我在内部使用了一个<code class="fe mw mx my mz b"><a class="ae lr" href="https://developer.apple.com/documentation/combine/passthroughsubject" rel="noopener ugc nofollow" target="_blank">PassthroughSubject</a></code>，并在我的类的<code class="fe mw mx my mz b">init</code>中订阅了它的发布者。所以当my <code class="fe mw mx my mz b">searchText</code>发布它的<code class="fe mw mx my mz b">newValue</code>时，它在<code class="fe mw mx my mz b">TextField</code>中接收它作为用户类型。然后，使用Combine操作符，我首先去抖，然后删除重复项，最后过滤任何空字符串。一旦我在<code class="fe mw mx my mz b">.sink</code>操作符中收到值，我就可以分派一个函数调用。</p><p id="31d2" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在这里，我叫<code class="fe mw mx my mz b">onUpdateTextDebounced()</code>。我还在设置值时立即调用了一个<code class="fe mw mx my mz b">onUpdateText()</code>，因此该类也提供了一个实时回调。</p><p id="1181" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">有了基类，就很好用了。让我们看看我是如何在应用程序的主搜索中使用它的。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="d28a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我在文本更新时获取关键字，没有任何抖动。这是一个非常轻量级的<code class="fe mw mx my mz b">[String]</code>调用和响应，您可以将其视为自动完成助手。然后，当用户停止输入至少500毫秒后，我会发送电影和人物搜索。</p><p id="6e62" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">让我们来看看它的实际应用:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nc"><img src="../Images/67a051df2dc2428e6494acde06c10466.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*dxs5fBkyy_xt_AhXvO1nUQ.gif"/></div></figure></div><div class="ab cl ls lt hy lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="in io ip iq ir"><h1 id="f2f0" class="lz ma iu bd mb mc md me mf mg mh mi mj ka mk kb ml kd mm ke mn kg mo kh mp mq bi translated">分析和优化</h1><p id="1d5e" class="pw-post-body-paragraph kv kw iu kx b ky mr jv la lb ms jy ld le mt lg lh li mu lk ll lm mv lo lp lq in bi translated">我在仪器上花费的时间比我预期的多得多，一方面是因为我想看看我所做的是否足够有效，另一方面是因为这是一个很好的了解SwiftUI内部工作的方式。</p><p id="9854" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">您可以看到系统调用堆栈，并了解视图体是如何以及何时被渲染或重新渲染的，例如，<code class="fe mw mx my mz b">@State</code>或<code class="fe mw mx my mz b">@ObjectBinding</code>发生了变化。</p><p id="4af9" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">苹果专门为SwiftUI引入了一个新的工具模板</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gi gj nd"><img src="../Images/f4b645ab3e7305ef98860803c63dcae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BXN6PjFRxh7hG_943ttw1g.png"/></div></div></figure><p id="2fbe" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">如果您点击它，然后点击记录按钮，您的应用程序将启动，您将开始有一些数据。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gi gj ni"><img src="../Images/905f3abb3c2974b3749cbfc784440258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iDHj25uKhkxbxQG38WteFw.png"/></div></div></figure><p id="29f9" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">第一部分将向您展示在这段时间内创建了多少个视图，更重要的是，创建它们花费了多长时间。</p><p id="f535" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">SwiftUI看起来很有趣，但你应该更多地关注你自己的视图类型，因为如果有瓶颈，那也是在你自己的视图结构中。我的建议是按照总时长对它们进行排序。在列表视图的顶部，您会看到哪些创建时间最长(或者刷新/渲染时间最长)。如果您看到总持续时间与计数相比异常地高，那么您应该开始查看这个视图的主体，看看是什么占用了时间。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gi gj ni"><img src="../Images/7b168e452b7a0c70fd1da7382f3dc0c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rI46Na2GvHpR_J46o09lcQ.png"/></div></div></figure><p id="13cd" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">数据的第二部分是关于属性更新的。你的观点所依赖的都是<code class="fe mw mx my mz b">@State</code>、<code class="fe mw mx my mz b">BindableObject</code>等等。它将显示哪个视图类型与哪个属性类型相关联。它会随着您的属性的更新而更新。</p><p id="ce18" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">尝试在应用程序中显示您的一个视图。您将看到仪器中的属性得到更新。如果您看到对一个属性的调用太多，或者更新太多，深入探究原因是一个好的开始。</p><p id="6019" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">您可以添加过滤器来过滤特定的视图类型、属性类型等。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gi gj nj"><img src="../Images/aadad5096c2051f34a141864cf3fef6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g8o5gMJlvfNVOgUIMkm_Vw.png"/></div></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nk"><img src="../Images/a364b0acc597b394306f8f20addaa202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*1Mcn8DZSR2QpYQuYfefAqw.png"/></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gi gj nl"><img src="../Images/b11e0f74233796bba47c409cfcc9b5d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rCn1YNFm-WCXgLye8y5HuA.png"/></div></div></figure><p id="7534" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">上面，我在过滤我的<code class="fe mw mx my mz b">EnvironmentObject</code>，这是我的整个Redux <code class="fe mw mx my mz b">AppState</code>。</p><p id="4e7b" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我从那里优化了很多东西。我把我的观点束缚得太紧了。因此，在某些视图中，我已经删除了对<code class="fe mw mx my mz b">@EnvironmentObject <strong class="kx iv">var</strong> store: Store&lt;AppState&gt;</code>的引用，直接将最终对象作为构造函数参数传递，而不仅仅是对象id。</p><p id="4eec" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在这种情况下，这是可以的，因为这个视图不需要获得后来传递的对象的更新引用。所以，如果我在我的AppState中更新一些东西，它不会触发更新。</p><p id="4340" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">第三段数据是关于CoreAnimation的，我还没有深入挖掘，所以我不能告诉你任何关于它的事情。</p><p id="5587" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">最有趣的部分是大家熟悉的时间分析器部分。它在任何其他乐器模板中都能正常工作。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gi gj nm"><img src="../Images/f07e33a7bf7a2ae5efa7686a909ffaa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dlf9_CyijDBtEUwFOOKFsQ.png"/></div></div></figure><p id="31cc" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">你可以很容易地在你的应用中看到在主线程上花费太多时间执行的代码。根据权重对行进行排序，然后在您的调用堆栈中挖掘。您可以过滤掉系统库，只调试您自己的函数调用。</p><p id="a535" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在这里，我展示了当我在macOS上滚动我的电影列表时，有太多的重新渲染。这是文本组件的一个bug，我已经向苹果公司报告了。</p><p id="61ce" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">通过查看调用堆栈，双击该行就可以转到代码。仪器甚至会向您显示罪魁祸首行。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gi gj nn"><img src="../Images/8b8819b8dc5554b81724d40e3e01576d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bJT73a65QRQdPIedErH33w.png"/></div></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gi gj no"><img src="../Images/6927ed2def374dc279336c6899648cea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSyys3nO3rPFYZWryiUB0A.png"/></div></div></figure><p id="f6ed" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我不会在这里打扰，因为这是一个两毫秒的事情。</p><p id="5051" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我希望这将有助于你用SwiftUI使用仪器。这是一个相当短的介绍，但如果你熟悉乐器，开始分析你的SwiftUI应用程序只是一个很少的新事物的问题。</p></div><div class="ab cl ls lt hy lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="in io ip iq ir"><h1 id="7d45" class="lz ma iu bd mb mc md me mf mg mh mi mj ka mk kb ml kd mm ke mn kg mo kh mp mq bi translated">与UIKit相比</h1><p id="e5ed" class="pw-post-body-paragraph kv kw iu kx b ky mr jv la lb ms jy ld le mt lg lh li mu lk ll lm mv lo lp lq in bi translated">这对UIKit意味着什么？我应该停止用UIKit编写我的应用程序吗？比UIKit好吗？比UIKit快吗？</p><p id="3e31" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">所有这些问题的答案都是视情况而定。您的应用程序需要实现什么？你的目标是什么？只支持iOS 13和macOS 10.15就足够好了吗？</p><p id="69eb" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">SwiftUI肯定更快。一旦你开始精通，它比UIKit迭代起来要快得多。但是我再怎么强调这一点也不为过——达到熟练需要时间。如果你做了一些反应，或者使用了一些其他的声明性框架，它一点也不会感到陌生。但是如果你所做的只是命令式编程，那么在编写UI代码时，你需要改变你的整个思路。</p><p id="48e3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">但是为什么用SwiftUI构建应用程序实际上更快呢？我们来看一个具体的例子。</p><p id="4068" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在UIKit中，假设我们制作了一个<code class="fe mw mx my mz b">UITableView</code>，它显示电影列表。然后，稍后，我们决定在一些单元格中添加一些电影的水平交叉线，同时在其他一些行中保持每个单元格一部电影。</p><p id="640a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">所以，我们创建一个<code class="fe mw mx my mz b">MovieCrosslineTableViewCell</code>，然后在里面放一个带有<code class="fe mw mx my mz b">UICollectionViewFlowLayout</code>的<code class="fe mw mx my mz b">UICollectionView</code>。我们将它的<code class="fe mw mx my mz b">delegate</code>和<code class="fe mw mx my mz b">datasource</code>连接到我们的单元并实现它们。我们还需要创建一个<code class="fe mw mx my mz b">MovieCollectionViewReusableCell</code>。</p><p id="2531" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">现在，几天后，你意识到这是一个垃圾UX，所以你想重构它完全是别的东西。也许是一个纯粹的<code class="fe mw mx my mz b">UITableView</code>，也许是一个纯粹的<code class="fe mw mx my mz b">UICollectionView</code>，或者也许是一个里面有一些自定义视图的<code class="fe mw mx my mz b">UIViewPager</code>。</p><p id="5409" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">所以你写的所有布局和意大利面代码现在大部分都没用了，你需要重新开始。当然，也许你很聪明，你写了漂亮的、可重用的组件。嗯，你仍然有很多代码需要修改，因为你很多组件都与<code class="fe mw mx my mz b">UITableViewCell</code>或<code class="fe mw mx my mz b">UICollectionViewCell</code>实现相关联。</p><p id="0f37" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在SwiftUI中，上面所有的布局都需要大约十行代码，你可以随意试验和重构/预览它。</p><p id="8067" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">它看起来像一个<code class="fe mw mx my mz b">List</code>，里面有一些<code class="fe mw mx my mz b">MovieRow</code>，还有一些<code class="fe mw mx my mz b">ScrollView</code>，包裹着一个<code class="fe mw mx my mz b">HStack</code>，显示着一个<code class="fe mw mx my mz b">MovieRow</code>的<code class="fe mw mx my mz b">ForEach</code>。你想用标题显示吗？你只要把你的<code class="fe mw mx my mz b">List</code>包在<code class="fe mw mx my mz b">VStack</code>里，然后加上你的<code class="fe mw mx my mz b">HeaderView</code>，再加上你的<code class="fe mw mx my mz b">List</code>。</p><p id="c49a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">您可以将其全部包装在NavigationView中，也可以不包装。只需要添加或删除一行。如果您想在顶行添加一个<code class="fe mw mx my mz b">SegmentedControl</code>，只需<code class="fe mw mx my mz b">List { SegmentedControl() }</code>即可。</p><p id="7623" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><a class="ae lr" href="https://twitter.com/Dimillian/status/1152906349069709312?s=20" rel="noopener ugc nofollow" target="_blank">我这里还有一个例子。</a></p><p id="b537" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我无法告诉你我在MovieSwiftUI中重构了多少次用户界面。我做了很多实验。使用UIKit，我可能会使用其他工具来完成。</p><p id="811a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我真的希望这个例子能和我一样引起你的共鸣，我在UIKit有将近十年的包袱。</p><p id="8c3a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">不管你喜不喜欢，SwiftUI是苹果的未来。这将是一个统一的UI框架，在未来几年我们会越来越多地使用它。</p><p id="9c8b" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">当然，它还没有准备好投入生产，而且实际上，它与UIKit弃用或类似的事情没有任何关系。在这次WWDC上，苹果在UIKit中添加了令人敬畏的API，SwiftUI由许多UIKit组件支持。</p><p id="c6d3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">苹果已经使得在SwiftUI应用中导入和使用任何UIKit组件变得非常容易。我们将在未来几年利用这一点，因为SwiftUI仍然缺乏相当多的原生高阶组件。</p><p id="94b5" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">至于我个人的看法，我迫不及待地想在我的商业UIKit应用程序中发布SwiftUI中的一些iOS 13专用功能，在未来几年中，我仍然需要支持iOS 10，然后是11和12。</p><p id="bde4" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">希望这篇作品能让你对SwiftUI <strong class="kx iv">更加炒作。</strong>感谢阅读！</p></div></div>    
</body>
</html>