<html>
<head>
<title>The Power of Flyweight Design Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中Flyweight设计模式的威力</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-of-flyweight-design-pattern-in-javascript-5593ae9fa858?source=collection_archive---------16-----------------------#2022-06-15">https://betterprogramming.pub/the-power-of-flyweight-design-pattern-in-javascript-5593ae9fa858?source=collection_archive---------16-----------------------#2022-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3726" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在JavaScript中，分享也是关心</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/60e1d95eb8422f4fee96c1c172304ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*dEMEvgK_qpwuTkQ8R670KQ.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><em class="ku">Lukas拍摄的照片:</em><a class="ae kv" href="https://www.pexels.com/photo/laptop-computer-showing-c-application-574069/" rel="noopener ugc nofollow" target="_blank"><em class="ku">https://www . pexels . com/Photo/laptop-computer-showing-c-application-574069/</em></a></p></figure><p id="15ae" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在JavaScript中，我们很幸运在语言中内置了自动垃圾收集机制。在某些情况下，我们自己管理内存是非常必要的。这就是Flyweight设计模式可以派上用场的地方，因为它旨在将共性分享给客户可以从中受益的对象。这是一种编写可伸缩应用程序的有效方式，因为它有利于我们允许用户消耗尽可能少的内存。</p><p id="c084" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在本文中，我们将介绍JavaScript中Flyweight设计模式的强大功能，并利用它来创建更节省内存的应用程序。我们将回顾出现的问题，并展示flyweight模式是如何将这些问题全部解决的。</p><p id="cc1f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果您以前使用过JavaScript库，那么无论是通过JavaScript库、框架，甚至是DOM，您都很有可能直接处理过提供给您的某种flyweight模式的变体。</p><p id="d942" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们来看看这个将对象表示为DOM元素的对象数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="2cbf" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果您查看<code class="fe lv lw lx ly b">children</code>数组，请注意有三个结构相同的对象:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lz"><img src="../Images/b340c9e10c67bea8cb7a22d77e2edf6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ry1MjiVA0Lu7CiTa.png"/></div></div></figure><p id="4b2a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这已经是一个问题，因为如果我们继续这种做法，我们的项目变得更大，我们的程序将在性能上受到很大的影响，因为它将在内存中创建三个独立的对象，尽管它们在结构上是等效的。想象一下如果有1000个呢？</p><p id="39ff" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">当我们回顾flyweight设计模式的真实例子时，这基本上是flyweight打算在幕后做的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="b819" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">注意<code class="fe lv lw lx ly b">inputElement</code>是如何被多次提及的。</p><p id="2a6d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们将回顾不同对象结构中的例子(例如类)，但最终这个概念总是适用的。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="e722" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">思考flyweight模式的一个好方法是“共享事物”在前面的例子中，我们共享了三次<code class="fe lv lw lx ly b">inputElement</code>对象。我们至少在三种情况下最小化了内存的使用。</p><p id="5c2a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">您可能经常遇到的一个常见实现是实现某种get方法来检索内存中某个缓存中的对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="14db" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这是一个很好的技术，可以重用和共享以前创建的、不需要重新创建的对象，因为它保留了用户的记忆。</p><p id="a594" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">它被用在许多库中，比如<a class="ae kv" href="https://github.com/dsherret/ts-morph/blob/latest/packages/common/src/collections/KeyValueCache.ts#L29" rel="noopener ugc nofollow" target="_blank"> ts-morph </a>，它们通常在这些方法前面加上类似<code class="fe lv lw lx ly b">"getOrCreate&lt;the rest of the variable's name&gt;"</code>的前缀</p><h1 id="ab61" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">内在状态</h1><p id="46bf" class="pw-post-body-paragraph kw kx it ky b kz nd ju lb lc ne jx le lf nf lh li lj ng ll lm ln nh lp lq lr im bi translated">当我们向Flyweight中添加一些内在状态时，我们可以利用它来做出节省内存的决策，这时flyweight实现通常会变得很有用。</p><p id="b67b" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在我们之前的例子中，如果我们看一下我们的<code class="fe lv lw lx ly b">CoinCollege</code>类，我们可以在这里发现我们的内在状态:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi ni"><img src="../Images/b57a2c1a584ade66ac70737883796fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pTtA-a4ug0YOtUR-.png"/></div></div></figure><p id="404c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们首先尝试用请求的<code class="fe lv lw lx ly b">value</code>获取先前创建的<code class="fe lv lw lx ly b">Coin</code>实例。如果我们的应用程序先前创建了它，我们可以避免不必要的重新创建，只返回我们存储的先前的<code class="fe lv lw lx ly b">Coin</code>。</p><p id="3efc" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这是库作者最常寻求的好处。</p><h1 id="0263" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">外在状态</h1><p id="1352" class="pw-post-body-paragraph kw kx it ky b kz nd ju lb lc ne jx le lf nf lh li lj ng ll lm ln nh lp lq lr im bi translated">轻量级模式中的另一个重要角色是外在状态。这些状态存在于flyweight实现之外，但是希望使用flyweight。一个常见的用例是回调函数观察到的状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lt lu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi nj"><img src="../Images/48ce8312f4a0316bc4386dd7943b2274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7wnpCCZ8mD3G8rI9.png"/></div></div></figure><p id="05cf" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">有了这个功能，如果我们的业务逻辑只适用于前五个硬币，我们就可以停止进一步创建<code class="fe lv lw lx ly b">Coin</code>。这是我们内在状态的伟大伴侣！</p><h1 id="fc38" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">原型遗传</h1><p id="9579" class="pw-post-body-paragraph kw kx it ky b kz nd ju lb lc ne jx le lf nf lh li lj ng ll lm ln nh lp lq lr im bi translated">在我JavaScript开发生涯的早期阶段，我很难理解在原型继承和工厂函数之间做出决策。困扰我太久的一个谜是弄清楚为什么我经常看到函数是这样创建的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="7ad7" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">与以这种方式创建对象相反:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="743a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在第一个例子中，我们的<code class="fe lv lw lx ly b">Calculator</code>类的新实例化将继承和重用在其原型上定义的相同属性/方法。这意味着这些将会发生:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi nk"><img src="../Images/222d543013ecd6d185cd6adb4950e4a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kkCPdrdyIg02kvmc.png"/></div></div></figure><p id="3b69" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在第二个例子中，我们的<code class="fe lv lw lx ly b">makeCalculator</code>工厂的新实例化将不会继承和重用<code class="fe lv lw lx ly b">add</code>和<code class="fe lv lw lx ly b">subtract</code>，而是接收一个全新的<code class="fe lv lw lx ly b">add</code>和<code class="fe lv lw lx ly b">subtract</code>函数，即使它们在形状和代码大小上是相同的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi nl"><img src="../Images/f14b6eef78b13e3ff96e356e79c1f8d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zHVGfGXkwXiLYflk.png"/></div></div></figure><p id="8086" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">总的来说，它们各有利弊。但是在flyweight的上下文中，推荐原型继承。然而，对于所有其他的，我总是使用工厂函数，但是这超出了这篇文章的范围。</p><h1 id="9df3" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">真实世界的代码示例</h1><p id="5ffa" class="pw-post-body-paragraph kw kx it ky b kz nd ju lb lc ne jx le lf nf lh li lj ng ll lm ln nh lp lq lr im bi translated"><a class="ae kv" href="https://github.com/visionmedia/superagent" rel="noopener ugc nofollow" target="_blank"> superagent </a>库展示了在实践中使用<a class="ae kv" href="https://github.com/visionmedia/superagent/blob/master/src/client.js" rel="noopener ugc nofollow" target="_blank"> Request </a>类中的原型继承的flyweight设计模式。现代程序会频繁地请求执行像数据获取这样的任务。问题是，这些请求不能在后续请求中重用。</p><p id="d7d7" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">他们需要实例化某个<code class="fe lv lw lx ly b">Request</code>对象的新实例。当程序处理<code class="fe lv lw lx ly b">Request</code>对象时，没有必要复制不依赖于当前状态的方法和属性。</p><p id="3956" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">一个例子是对<code class="fe lv lw lx ly b">Request</code>对象的<a class="ae kv" href="https://github.com/visionmedia/superagent/blob/master/src/client.js#L580" rel="noopener ugc nofollow" target="_blank">查询方法</a>。实现细节几乎不会改变，所以没有必要创建副本并把副本带到新对象中。</p><h1 id="ec71" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">结论</h1><p id="4bbd" class="pw-post-body-paragraph kw kx it ky b kz nd ju lb lc ne jx le lf nf lh li lj ng ll lm ln nh lp lq lr im bi translated">我希望你发现这是有价值的。以后多多关照！</p></div></div>    
</body>
</html>