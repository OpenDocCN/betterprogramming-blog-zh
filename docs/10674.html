<html>
<head>
<title>How to Retry Network Requests Using Swift’s Combine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Swift的Combine重试网络请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-retry-network-requests-using-swifts-combine-5ac3f093adc5?source=collection_archive---------4-----------------------#2022-01-21">https://betterprogramming.pub/how-to-retry-network-requests-using-swifts-combine-5ac3f093adc5?source=collection_archive---------4-----------------------#2022-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9a62" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用简单的方法解决复杂的任务</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fb8dede1e56c2a5c79b9bd85b66120b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hYCue9Nv_vPk32P_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@mok4?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mohamed Kerroudj </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="624b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探讨如何利用Combine来促进网络请求的重试。我们将通过使用一个强大的<code class="fe lv lw lx ly b">.retry(_:)</code>操作符来做到这一点。</p><p id="5f99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，完成教程后，您将会知道:</p><ul class=""><li id="44be" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">如何使用<code class="fe lv lw lx ly b">.retry(_:)</code>运算符？</li><li id="1dc0" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">如何安排每次请求失败后的延迟时间？</li><li id="ba53" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">如何根据网络运行的状态和结果设计一个样本<code class="fe lv lw lx ly b">UIViewController</code>。</li></ul><p id="ee82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成的项目的源代码可以在文章的底部找到。</p><h1 id="a00b" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">我们开始吧</h1><p id="0850" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们从一个简单的项目开始，在屏幕中央显示一个<code class="fe lv lw lx ly b">UIImageView</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/516f7ecd36a443647a12064a1bdb2dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tqooFRAjp8IbFiEGMVWrhw.png"/></div></div></figure><p id="e3e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">ViewController</code>的代码也很简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e787" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本结构完成后，让我们创建一个自定义的<code class="fe lv lw lx ly b">Error</code> enum来表示错误，并创建一个<code class="fe lv lw lx ly b">cancellables</code>属性来存储我们的订阅:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="fe00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以开始创建网络请求了。让我们按如下方式调整文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><ol class=""><li id="64a2" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu nn mf mg mh bi translated"><code class="fe lv lw lx ly b">url</code>为我们提供了一个随机的图像。</li><li id="76f3" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nn mf mg mh bi translated"><code class="fe lv lw lx ly b">Future</code>产生单个事件，然后结束或失败。然而，我们希望能够重试请求，因此我们将<code class="fe lv lw lx ly b">Future</code>包装在<code class="fe lv lw lx ly b">Deferred</code>发布器中。</li><li id="73ac" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nn mf mg mh bi translated">如果我们不能从响应中提取出<code class="fe lv lw lx ly b">Data</code>和<code class="fe lv lw lx ly b">UIImage</code>，我们就发送一个<code class="fe lv lw lx ly b">.failure(CustomError.dataCorrupted)</code>事件。</li><li id="81d3" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nn mf mg mh bi translated">如果我们成功地获得了一个<code class="fe lv lw lx ly b">UIImage</code>，则发送一个<code class="fe lv lw lx ly b">.success(image)</code>事件。</li></ol><p id="c9be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在<code class="fe lv lw lx ly b">ViewController</code>的<code class="fe lv lw lx ly b">viewDidLoad()</code>方法中调用实现的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e5a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们实现了以下目标:</p><ol class=""><li id="5b07" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu nn mf mg mh bi translated">监控并打印<code class="fe lv lw lx ly b">.handleEvents</code>操作器内部发生的事件。</li><li id="277b" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nn mf mg mh bi translated">通过使用<code class="fe lv lw lx ly b">.receive(on:)</code>操作符，发出我们想要在主线程上获得操作结果的信号。</li><li id="4ad2" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nn mf mg mh bi translated">一旦整个序列终止，在控制台中打印一条消息。这将在所有重试尝试之后，或者在成功的映像加载任务之后发生。</li><li id="6d9e" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nn mf mg mh bi translated">一旦获得图像，在<code class="fe lv lw lx ly b">UIImageView</code>中显示。</li></ol><p id="d119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止看起来不错，但是如果我们的请求失败了呢？让我们通过在<code class="fe lv lw lx ly b">.handleEvents</code>和<code class="fe lv lw lx ly b">.receive</code>之间添加<code class="fe lv lw lx ly b">.retry(_:)</code>操作符来实现重试功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们说，如果出现错误，我们最多可以重试请求三次。让我们故意修改<code class="fe lv lw lx ly b">getAvatarFromTheServer()</code>方法中的<code class="fe lv lw lx ly b">URL</code>，使其失败:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="151a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们运行应用程序，我们将看到四次加载映像的尝试(因为重试计数参数会添加到初始尝试中):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/2ff97c3b3cbc736e7daed3652a774ce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IPDjAQ7KKMyAY15Y9d1-4A.png"/></div></div></figure><p id="6dc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">又完成了一项任务，现在让我们看看是否可以优化操作。目前，重试尝试在失败后立即开始，而理想情况下，我们希望在后续尝试之间有一个小的延迟。这就是<code class="fe lv lw lx ly b">.delay</code>来拯救我们的地方。让我们将它添加到<code class="fe lv lw lx ly b">.handleEvents</code>和<code class="fe lv lw lx ly b">.retry</code>操作符之间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们指定要将每次重试延迟1秒。如果操作由于互联网连接缓慢而失败，这种延迟给用户更多的机会来恢复连接并获得最终结果，即图像。</p><p id="59c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以将损坏的URL恢复到正确的状态，并再次运行应用程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/f00737e61b949d9f75a7a3c3fd928447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vaYDDoEyJG6Xv8VtBoZFnQ.png"/></div></div></figure><p id="d3e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，映像是按需加载的，没有发生重试下载的尝试。现在我们的目标是在我们的UI中反映图像加载任务的状态。为了简单起见，我们将状态绑定到<code class="fe lv lw lx ly b">ViewController</code>的<code class="fe lv lw lx ly b">UINavigationItem</code>的标题上。</p><p id="a854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将下面的<code class="fe lv lw lx ly b">State</code>枚举添加到文件中，并用<code class="fe lv lw lx ly b">.initial</code> case初始化<code class="fe lv lw lx ly b">Published</code>属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="8d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们在图像加载任务中相应地设置<code class="fe lv lw lx ly b">state</code>。注意，我们将绑定过程移到了一个名为<code class="fe lv lw lx ly b">bindAvatarToImageView()</code>的方法中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><ol class=""><li id="ff4e" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu nn mf mg mh bi translated">在<code class="fe lv lw lx ly b">.handleEvents(receiveSubscription:)</code>闭包内部，我们将<code class="fe lv lw lx ly b">state</code>设置为<code class="fe lv lw lx ly b">.loading</code>。</li><li id="e329" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nn mf mg mh bi translated">当镜像加载任务出错完成时(如果需要，可以重试)，在<code class="fe lv lw lx ly b">.sink(receiveCompletion:)</code>闭包内，我们将状态设置为<code class="fe lv lw lx ly b">.loadingFailed</code>。类似地，在<code class="fe lv lw lx ly b">.sink(receiveValue:)</code>闭合内，<code class="fe lv lw lx ly b">state</code>被设置为<code class="fe lv lw lx ly b">.loadedSuccessfully</code>。</li></ol><p id="83ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以将<code class="fe lv lw lx ly b">state</code>属性绑定到<code class="fe lv lw lx ly b">UINavigationItem</code>标题。让我们加上一个<code class="fe lv lw lx ly b">bindStateToTitle()</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><ol class=""><li id="f84f" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu nn mf mg mh bi translated">我们在主线程上接收<code class="fe lv lw lx ly b">state</code>更新。</li><li id="79bf" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nn mf mg mh bi translated">从获得的<code class="fe lv lw lx ly b">state</code>中获得一个<code class="fe lv lw lx ly b">String</code>值，因为<code class="fe lv lw lx ly b">state</code>属性是一个<code class="fe lv lw lx ly b">enum</code>。</li><li id="701c" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nn mf mg mh bi translated">给<code class="fe lv lw lx ly b">UINavigationItem</code>的标题赋值。</li></ol><p id="d595" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！既然我们已经完成了逻辑，让我们在<code class="fe lv lw lx ly b">viewDidLoad()</code>方法内部调用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><ol class=""><li id="d814" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu nn mf mg mh bi translated">我们通过启动<code class="fe lv lw lx ly b">bindStateToTitle()</code>方法来订阅状态更新。</li><li id="6f32" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nn mf mg mh bi translated">运行<code class="fe lv lw lx ly b">viewDidLoad()</code>2秒后启动图像加载和绑定方法，因为我们想先看到导航项目中显示的“初始”标题。</li></ol><p id="176b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，考虑到任务成功，用户将会看到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/211385aa6bf0e1a3fa10b1cea1a2816d.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/1*iqhElCu5GmttlYoK3oolOA.gif"/></div></figure><p id="8799" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经成功地实现了网络请求的重试功能，并将状态绑定到UI。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="9a7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果上面的逻辑不够，并且您希望提供一个占位符图像，以防所有网络请求失败，该怎么办？联合收割机再次为您提供保障！我们使用<code class="fe lv lw lx ly b">.replaceError</code>操作符来实现这一点。我们将它添加在<code class="fe lv lw lx ly b">.retry</code>和<code class="fe lv lw lx ly b">.receive</code>运算符之间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="090f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/dc1ccff2095b6ccf3cb1f4ad4a019c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/1*7aMSDfZ6aZzI2smneJfQ1Q.gif"/></div></figure><p id="a5b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，现在<code class="fe lv lw lx ly b">state</code>将不再得到<code class="fe lv lw lx ly b">.loadingFailed</code>案例，因为操作总是成功得到一个图像。</p><h1 id="3203" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">资源</h1><p id="3260" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">源代码可在<a class="ae ky" href="https://github.com/zafarivaev/combine-retry-network-requests" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><h1 id="d160" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">包扎</h1><p id="2ad2" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们已经看到通过利用Combine来实现一个不那么简单的逻辑是多么容易。要了解更多关于联合收割机操作员的信息，请访问官方文档。希望这篇教程对你有用，感谢阅读！</p></div></div>    
</body>
</html>