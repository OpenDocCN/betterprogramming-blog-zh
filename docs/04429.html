<html>
<head>
<title>10 Efficient Ways to Use Python Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python列表的10种有效方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-efficient-ways-to-use-python-lists-f6e7e666708?source=collection_archive---------8-----------------------#2020-04-13">https://betterprogramming.pub/10-efficient-ways-to-use-python-lists-f6e7e666708?source=collection_archive---------8-----------------------#2020-04-13</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="3c81" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">按值复制、最常出现、展平列表等等</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/0185a1156740482fb80f41ad599473b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1YAdWi5ruRiSQDas"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Glenn Carstens-Peters 在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="aef0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当您处理许多相关值时，Python列表是一种很好的数据结构。它们是可变的、有序的元素序列，可以容纳不同种类的元素。</p><p id="3520" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">开始使用列表真的很容易。它们被写在方括号中，如下所示:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="b87b" class="mb mc iu lx b gz md me l mf mg">brands = ['McD', 'KFC', 'Nike', 'Apple', 'Google']</span></pre><p id="48a1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们快速总结一下Python列表上的一些基本操作:</p><ul class=""><li id="8539" class="mh mi iu lc b ld le lg lh lj mj ln mk lr ml lv mm mn mo mp bi translated">您可以通过指定索引(切片符号)来访问一个元素或一系列元素。</li><li id="9a2b" class="mh mi iu lc b ld mq lg mr lj ms ln mt lr mu lv mm mn mo mp bi translated"><code class="fe mv mw mx lx b">in</code>关键字用于确定一个元素是否存在于列表中。</li><li id="12b3" class="mh mi iu lc b ld mq lg mr lj ms ln mt lr mu lv mm mn mo mp bi translated"><code class="fe mv mw mx lx b">remove()</code>方法移除指定的元素，而<code class="fe mv mw mx lx b">pop()</code>方法返回并移除给定索引处的元素(如果没有指定索引，则移除最后一个元素)。</li><li id="7ef8" class="mh mi iu lc b ld mq lg mr lj ms ln mt lr mu lv mm mn mo mp bi translated"><code class="fe mv mw mx lx b">*</code>操作符可用于乘法列表。它按照我们指定的数量复制列表。</li></ul><p id="8b42" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Python列表被广泛使用，所以高效地处理它们是至关重要的。在接下来的几节中，我们将探索Python列表的几个用例，并确保我们有效地使用它们。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="08f6" class="nf mc iu bd ng nh ni nj nk nl nm nn no ka np kb nq kd nr ke ns kg nt kh nu nv bi translated">按值复制列表</h1><p id="76c5" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">复制列表有很多方法，但使用赋值操作符不是其中之一。让我们确认一下:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="edf6" class="mb mc iu lx b gz md me l mf mg">&gt;&gt;&gt; a = [1, 2, 3, 4, 5]<br/>&gt;&gt;&gt; b = a</span><span id="1e90" class="mb mc iu lx b gz ob me l mf mg">&gt;&gt;&gt; id(a)<br/>4345924656</span><span id="f886" class="mb mc iu lx b gz ob me l mf mg">&gt;&gt;&gt; id(b)<br/>4345924656</span></pre><p id="3d84" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个赋值只是创建了一个对列表<code class="fe mv mw mx lx b">a</code>的引用。这意味着两个列表现在指向同一个内存，一个列表中的任何变化都会影响另一个。</p><p id="c347" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是创建Python列表的独立“浅层”副本的一些可能方法，按照速度从最高效率到最低效率排序:</p><ul class=""><li id="e02b" class="mh mi iu lc b ld le lg lh lj mj ln mk lr ml lv mm mn mo mp bi translated"><code class="fe mv mw mx lx b">b = [*a]</code></li><li id="5fc8" class="mh mi iu lc b ld mq lg mr lj ms ln mt lr mu lv mm mn mo mp bi translated"><code class="fe mv mw mx lx b">b = a * 1</code></li><li id="c6e8" class="mh mi iu lc b ld mq lg mr lj ms ln mt lr mu lv mm mn mo mp bi translated"><code class="fe mv mw mx lx b">b = a[:]</code></li><li id="52a9" class="mh mi iu lc b ld mq lg mr lj ms ln mt lr mu lv mm mn mo mp bi translated"><code class="fe mv mw mx lx b">b = a.copy()</code> (Python 3 —浅层复制)</li><li id="60b9" class="mh mi iu lc b ld mq lg mr lj ms ln mt lr mu lv mm mn mo mp bi translated"><code class="fe mv mw mx lx b">b = [x for x in a]</code></li><li id="1f0b" class="mh mi iu lc b ld mq lg mr lj ms ln mt lr mu lv mm mn mo mp bi translated"><code class="fe mv mw mx lx b">b = copy.copy(a)</code> (Python 2)</li></ul><p id="cf10" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然速度上的差异是可比较的，但有时执行<code class="fe mv mw mx lx b">deepcopy</code>(这显然是最慢且最需要内存的方法)是不可避免的。</p><p id="3857" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">与深层拷贝不同，浅层拷贝不会克隆嵌套对象。相反，它只是复制嵌套对象的引用。让我们看下面的例子来验证这一点:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="fb2f" class="mb mc iu lx b gz md me l mf mg">&gt;&gt;&gt; a = [[0,1],[2,3]]<br/>&gt;&gt;&gt; b = [*a]<br/>&gt;&gt;&gt; a[1][0] = 5</span><span id="89fd" class="mb mc iu lx b gz ob me l mf mg"><strong class="lx iv">#Output of b: [[0, 1], [5, 3]]</strong></span></pre><p id="d313" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">更新嵌套列表元素<code class="fe mv mw mx lx b">a[1][0] = 5</code>也会改变列表<code class="fe mv mw mx lx b">b</code>。在不使用1D列表的情况下，下面的方法最适合对所有列表元素进行深层复制:</p><ul class=""><li id="31a4" class="mh mi iu lc b ld le lg lh lj mj ln mk lr ml lv mm mn mo mp bi translated"><code class="fe mv mw mx lx b">b = [x[:] for x in a]</code></li><li id="2e9a" class="mh mi iu lc b ld mq lg mr lj ms ln mt lr mu lv mm mn mo mp bi translated"><code class="fe mv mw mx lx b">b = copy.deepcopy(a)</code>(导入<code class="fe mv mw mx lx b">copy</code>库)</li></ul></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="932e" class="nf mc iu bd ng nh ni nj nk nl nm nn no ka np kb nq kd nr ke ns kg nt kh nu nv bi translated">列表中出现的次数</h1><p id="acee" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">我们可以使用list comprehension、<code class="fe mv mw mx lx b">filter()</code>或<code class="fe mv mw mx lx b">count()</code>找到一个元素出现的次数。虽然列表理解使得编写优雅的代码变得容易，但是在目前的情况下，它们是效率最低的。最高效的是内置方法<code class="fe mv mw mx lx b">count()</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oc od l"/></div></figure><p id="f987" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用计数器库，我们可以检索每个元素出现的次数。它是一个无序的集合容器，包含表示键的元素，它们的计数以值的形式设置。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="c013" class="mb mc iu lx b gz md me l mf mg">&gt;&gt;&gt; from collections import Counter<br/>&gt;&gt;&gt; a = <!-- -->['apple', ‘orange’, ‘orange’, 'grape', 'apple']<br/>&gt;&gt;&gt; Counter(a)</span><span id="bb8f" class="mb mc iu lx b gz ob me l mf mg">#Output: Counter({'apple': 2, 'orange': 2, 'grape': 1})</span></pre></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="ff61" class="nf mc iu bd ng nh ni nj nk nl nm nn no ka np kb nq kd nr ke ns kg nt kh nu nv bi translated">列表中最常见的元素</h1><p id="c628" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">以下是查找列表中最常见元素的一种方法:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="6cee" class="mb mc iu lx b gz md me l mf mg">x = [1,2,2,3,2,1,1]<br/>common_element = max(set(x), key=x.count)</span></pre><p id="ea7e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然上面的实现看起来聪明、简洁、优雅，但是使用<code class="fe mv mw mx lx b">count</code>方法会导致额外的循环开销和明显的<em class="oe"> O( n2 ) </em>时间。</p><p id="af95" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过使用我们刚刚看到的<code class="fe mv mw mx lx b">Counter</code>库，找到最常见(或第二常见)的元素要快得多。以下代码片段展示了我们如何实现这一点:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oc od l"/></div></figure></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="7688" class="nf mc iu bd ng nh ni nj nk nl nm nn no ka np kb nq kd nr ke ns kg nt kh nu nv bi translated">将文件解析到列表</h1><p id="23ab" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">将文件解析为Python列表是一个非常常见的用例，虽然下面的代码看起来不错，但效率很低:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="cb22" class="mb mc iu lx b gz md me l mf mg">with open('filename.txt', 'r') as f:     <br/>   lines = [line.split() for line in f.readlines()]</span></pre><p id="0803" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe mv mw mx lx b">readlines()</code>一次将整个文件放入内存，并解析成一个列表。现在，这可能不会对小文件造成太大的麻烦，但是随着文件大小的增加，程序需要一段时间才能启动。</p><p id="f293" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">幸运的是，您并不真的需要读取文件来解析它。默认情况下，文件是可迭代的，因此下面的代码片段将为您完成这项工作，以一种有效的方式将每一行放入嵌套列表中:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="d582" class="mb mc iu lx b gz md me l mf mg">a = [i.split() for i in open(‘filename.txt’)]</span></pre><p id="3159" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe mv mw mx lx b">split()</code>函数帮助我们去掉每个嵌套列表元素中烦人的换行符。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="3f94" class="nf mc iu bd ng nh ni nj nk nl nm nn no ka np kb nq kd nr ke ns kg nt kh nu nv bi translated">在字典列表中搜索</h1><p id="4f85" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">搜索包含在列表中的字典的较慢方法是使用<code class="fe mv mw mx lx b">Filter + Lamda</code>:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="70b0" class="mb mc iu lx b gz md me l mf mg">next(filter(lambda obj: obj.get('name') == 'Anupam', dicts), None)</span><span id="d03b" class="mb mc iu lx b gz ob me l mf mg">#Time Elapsed: 0.001047</span></pre><p id="8ca5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，利用列表理解不仅简洁，而且节省了函数调用开销，因此速度更快:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="c19d" class="mb mc iu lx b gz md me l mf mg">next((item for item in dicts if item["name"] == "Anupam"), None)</span><span id="48cb" class="mb mc iu lx b gz ob me l mf mg">#Time Elapsed: 0.0009327</span></pre></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="bd2f" class="nf mc iu bd ng nh ni nj nk nl nm nn no ka np kb nq kd nr ke ns kg nt kh nu nv bi translated">列表的合并</h1><p id="5d7c" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">列表的连接或合并不等同于追加。一个<code class="fe mv mw mx lx b">append</code>函数将一个元素添加到列表中，从而使计数增加1，如下所示:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="d27c" class="mb mc iu lx b gz md me l mf mg">x = [1, 2, 3]<br/>x.append([4, 5])</span><span id="fe61" class="mb mc iu lx b gz ob me l mf mg">#Output: [1,2,3,[4,5]]</span></pre><p id="390a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一方面，<code class="fe mv mw mx lx b">extend</code>通过迭代它的参数，将集合中的每个元素添加到列表中。值得注意的是，传递单个元素，如整数，在<code class="fe mv mw mx lx b">extend</code>函数中不起作用。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="6c20" class="mb mc iu lx b gz md me l mf mg">x = [1, 2, 3]<br/>y = [4,5]<br/>x.extend(y)</span><span id="e698" class="mb mc iu lx b gz ob me l mf mg">#Output of x: [1,2,3,4,5]</span><span id="4972" class="mb mc iu lx b gz ob me l mf mg">x = [1,2,3]<br/>x.extend(4)</span><span id="a1fb" class="mb mc iu lx b gz ob me l mf mg"># TypeError: 'int' object is not iterable</span></pre><p id="56ca" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用<code class="fe mv mw mx lx b">extend</code>函数或使用<code class="fe mv mw mx lx b">+=</code>操作符可以正确地连接或合并列表。</p><h2 id="5aec" class="mb mc iu bd ng of og dn nk oh oi dp no lj oj ok nq ln ol om ns lr on oo nu op bi translated">扩展vs. +=</h2><p id="9235" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">就速度而言，<code class="fe mv mw mx lx b">extend</code>和<code class="fe mv mw mx lx b">+=</code>之间只有微小的差别，虽然它们看起来可能是一样的，但实际上并不是这样。例如，不能对非局部变量使用<code class="fe mv mw mx lx b">+=</code>。此外，与<code class="fe mv mw mx lx b">extend</code>不同，<code class="fe mv mw mx lx b">+=</code>不支持链式函数调用(<code class="fe mv mw mx lx b">getListA() += listB</code>会抛出语法错误)。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="20ca" class="mb mc iu lx b gz md me l mf mg">a = [1, 2]<br/>b = [2, 3]<br/>b.extend(a)</span><span id="5f87" class="mb mc iu lx b gz ob me l mf mg">#Time elapsed: 0.000189</span><span id="f674" class="mb mc iu lx b gz ob me l mf mg"><br/>#Second way</span><span id="632a" class="mb mc iu lx b gz ob me l mf mg">b += a<br/>#Time elapased: 0.0002098</span></pre><h2 id="52ea" class="mb mc iu bd ng of og dn nk oh oi dp no lj oj ok nq ln ol om ns lr on oo nu op bi translated">Splat运算符</h2><p id="2a77" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">splat操作符有助于解包和连接列表，同时还允许我们在其中添加文字元素。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="8d6b" class="mb mc iu lx b gz md me l mf mg">a = [1,2]<br/>b = [2,3]<br/>a = [*a, *b]</span><span id="7600" class="mb mc iu lx b gz ob me l mf mg">#Output of a: [1, 2, 2, 3]<br/>#Time elapsed : 0.00021719</span></pre></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="fbdc" class="nf mc iu bd ng nh ni nj nk nl nm nn no ka np kb nq kd nr ke ns kg nt kh nu nv bi translated">并行迭代多个列表</h1><p id="d0a9" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">为了并行遍历列表，我们将利用<code class="fe mv mw mx lx b">zip</code>操作符。<code class="fe mv mw mx lx b">zip</code>操作符通过将每个列表中相同索引处的元素组合在一起，返回元组的迭代器。</p><p id="7fd7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果列表的长度不同，当最短的列表完成时，zip操作符停止。要获得元组列表，请使用<code class="fe mv mw mx lx b">list(zip(a, b))</code>。以下代码显示了一个并行无错迭代多个列表的示例:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oc od l"/></div></figure></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="06c6" class="nf mc iu bd ng nh ni nj nk nl nm nn no ka np kb nq kd nr ke ns kg nt kh nu nv bi translated">展平列表列表</h1><p id="6bc4" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">在展平列表列表的各种可能方法中，让我们看看三种流行的方法，并在<code class="fe mv mw mx lx b">timeit</code>中比较它们在500次迭代中的效率。</p><h2 id="eafb" class="mb mc iu bd ng of og dn nk oh oi dp no lj oj ok nq ln ol om ns lr on oo nu op bi translated">方法1:使用列表理解——慢</h2><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="223f" class="mb mc iu lx b gz md me l mf mg">l = [[1, 2, None], [3, 4], [5, 6]]</span><span id="a4b3" class="mb mc iu lx b gz ob me l mf mg">[item for items in l for item in items]</span><span id="13e2" class="mb mc iu lx b gz ob me l mf mg">#Time is 0.0009621297940611839</span></pre><h2 id="3c30" class="mb mc iu bd ng of og dn nk oh oi dp no lj oj ok nq ln ol om ns lr on oo nu op bi translated">方法2:使用链式迭代——更快</h2><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="de26" class="mb mc iu lx b gz md me l mf mg">import itertools<br/>list(itertools.chain.from_iterable(l))<br/></span><span id="4f12" class="mb mc iu lx b gz ob me l mf mg">#Time is 0.0007339292205870152</span></pre><h2 id="31ab" class="mb mc iu bd ng of og dn nk oh oi dp no lj oj ok nq ln ol om ns lr on oo nu op bi translated">方法3:使用functools —最快</h2><p id="6ec3" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">使用<code class="fe mv mw mx lx b">Functools (reduce-iconcat)</code>是使列表变平的最快方法(尽管不太快),尽管它需要导入一些库:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="c74c" class="mb mc iu lx b gz md me l mf mg">import functools<br/>import operator</span><span id="fc04" class="mb mc iu lx b gz ob me l mf mg">l = functools.reduce(operator.iconcat, l, [])</span><span id="5ad3" class="mb mc iu lx b gz ob me l mf mg"># Output: [1, 2, None, 3, 4, 5, 6]<br/>#Time is 0.0006934418343007565</span></pre></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="fcee" class="nf mc iu bd ng nh ni nj nk nl nm nn no ka np kb nq kd nr ke ns kg nt kh nu nv bi translated">列表中的排列和组合</h1><p id="f06a" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">Python提供了<code class="fe mv mw mx lx b">itertools</code>包中的内置方法来生成序列的排列和组合。让我们看看如何从Python列表中创建它们。</p><h2 id="618e" class="mb mc iu bd ng of og dn nk oh oi dp no lj oj ok nq ln ol om ns lr on oo nu op bi translated">排列</h2><p id="66aa" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">它产生<em class="oe"> n！</em>输入序列长度的排列<em class="oe"> n </em>。我们也可以显式传递一个自定义参数来生成不同长度的序列。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="3b7a" class="mb mc iu lx b gz md me l mf mg">import itertools <br/>print(list(itertools.permutations([1,2,3])))</span><span id="6b5f" class="mb mc iu lx b gz ob me l mf mg">#Output: [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]</span></pre><h2 id="06d2" class="mb mc iu bd ng of og dn nk oh oi dp no lj oj ok nq ln ol om ns lr on oo nu op bi translated">组合</h2><p id="dec6" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">就像我们轻松通过的七年级数学概念一样，这需要一个输入<code class="fe mv mw mx lx b">r</code>并生成所有可能的元组组合。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="9633" class="mb mc iu lx b gz md me l mf mg">import itertools<br/>a = [1,2,3,4]<br/>list(itertools.combinations(a, r=2)) </span><span id="a3c4" class="mb mc iu lx b gz ob me l mf mg">#Output: [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]</span></pre><h1 id="e6ee" class="nf mc iu bd ng nh oq nj nk nl or nn no ka os kb nq kd ot ke ns kg ou kh nu nv bi translated">字符串到列表，列表到字符串</h1><p id="9e53" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">要从一个字符串创建一个列表，我们只需要使用列表理解来迭代它，如下面的代码所示:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="79e2" class="mb mc iu lx b gz md me l mf mg">a = [_ for _ in 'abcdefghi']</span></pre><p id="b7a5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">相反，我们将使用一个<code class="fe mv mw mx lx b">join()</code>方法来获取iterable的每个元素，并将其连接到字符串中:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="0ae5" class="mb mc iu lx b gz md me l mf mg">b = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']<br/>x = ', '.join(mylist)</span><span id="041e" class="mb mc iu lx b gz ob me l mf mg">#Output x is:</span><span id="2905" class="mb mc iu lx b gz ob me l mf mg">'a, b, c, d, e, f, g, h, i'</span></pre></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="ac29" class="nf mc iu bd ng nh ni nj nk nl nm nn no ka np kb nq kd nr ke ns kg nt kh nu nv bi translated">结论</h1><p id="a56b" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">这篇文章总结了Python列表的基本语法和一些常见用例，同时强调了不同方法的效率。</p><p id="96dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢阅读。</p></div></div>    
</body>
</html>