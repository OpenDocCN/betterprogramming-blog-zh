<html>
<head>
<title>Setting Up Ruby on Rails With Postgres Using Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker通过Postgres设置Ruby on Rails</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/setting-up-rails-with-postgres-using-docker-426c853e8590?source=collection_archive---------1-----------------------#2018-12-15">https://betterprogramming.pub/setting-up-rails-with-postgres-using-docker-426c853e8590?source=collection_archive---------1-----------------------#2018-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="34c4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">不再为安装而烦恼。这使得启动和运行变得简单</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5ad6dd4b7ad25433a27e69b46a219812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YP9V6oh7JZ8Tmkt5sZblLA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@dnevozhai?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Denys Nevozhai </a>在<a class="ae kv" href="https://unsplash.com/s/photos/red?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="57dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我曾经在一个技术训练营中用Ruby on Rails教授web开发。几乎每个人都在努力安装Ruby、Rails和Postgres，并让它们运行起来。</p><p id="98fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">过去这需要相当长的时间，所以我写了一个Docker Compose文件，用一个命令就可以启动一切。这是文件和它的魔力。在你看完下面的视频后，我将解释Docker Compose文件和Docker文件中的所有内容。这表明运行您的开发环境是多么容易。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/f93bd8d5b9f74f150ee3d864acf018a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*zYanrZ_sLWW6HAuW2WhL5A.gif"/></div></figure><p id="993b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于不知道Docker或者Docker Compose的人，可以<a class="ae kv" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank">在这里</a>了解一下。不知道它们也没关系——您仍然可以使用演示代码启动一个Rails项目，并运行Postgres。我在文章的最后附上了一个类似的Docker Compose文件和Docker文件，用于与Express一起工作。</p><p id="7be3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们首先在您的系统上运行它。</p><p id="5a7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">克隆这个repo—<a class="ae kv" href="https://github.com/tushartuteja/rails-docker-compose-example" rel="noopener ugc nofollow" target="_blank">https://github . com/tushartuteja/rails-docker-compose-example</a></p><p id="1454" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">转到根文件夹并运行<code class="fe lt lu lv lw b">docker-compose up</code>。如果是第一次运行，这可能需要一段时间。它应该如下所示:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="38d3" class="mb mc iq lw b gy md me l mf mg">docker-compose up</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mh"><img src="../Images/232bcd10886de78ae9e7aefb02e3f979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3NsAt1_YzVZveJ83Angupw.png"/></div></div></figure><p id="bc61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将运行两个容器。一个是运行Rails的web服务，另一个是附加到web服务的Postgres数据库。</p><p id="bb25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">众所周知，我们需要运行<code class="fe lt lu lv lw b">rake db:create</code>、<code class="fe lt lu lv lw b">rails db:migrate</code>和许多其他神奇的Rails命令。应该有一种方法可以连接到web容器。我们可以非常容易地做到这一点，只需两步。</p><p id="fe85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，运行<code class="fe lt lu lv lw b">docker ps</code>命令列出所有当前正在运行的容器。参考下面的图片。</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="a556" class="mb mc iq lw b gy md me l mf mg">docker ps</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/3bea5df21db11a7c357ccb5fbe606e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D54xUA5O1ZgIefUXONk0Ew.png"/></div></div></figure><p id="8427" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所看到的，有两个容器在运行。为了连接到一个特定的容器，我们将运行<code class="fe lt lu lv lw b">docker exec -it 1597728759c0 sh</code>。该字符串是容器id。这将把我们连接到容器，就像我们SSH到另一台机器一样。</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="ecb6" class="mb mc iq lw b gy md me l mf mg">docker exec -it 1597728759c0 sh</span></pre><p id="10db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将运行<code class="fe lt lu lv lw b">rake db:create</code>和<code class="fe lt lu lv lw b">rake db:migrate</code>在我们的数据库服务器上运行数据库迁移。</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="09ce" class="mb mc iq lw b gy md me l mf mg">rake db:create</span><span id="1f62" class="mb mc iq lw b gy mj me l mf mg">rake db:migrate</span></pre><p id="b573" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">去<a class="ae kv" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>看看是否一切正常。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/e2a728d7b379bcd04c61bcd3ee1faa2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*OV3MvW4Metp6DuhMFPjSXg.png"/></div></figure><p id="a818" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经在当前的回购中创建了一个博客脚手架。访问<a class="ae kv" href="http://localhost:3000/blogs" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/blogs</a>看看它是否能在你的系统上工作。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="5f49" class="ms mc iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">让我们看看它是如何工作的</h1><p id="b541" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">我们通过三个文件来了解一切是如何工作的。第一个是Rails项目的<code class="fe lt lu lv lw b">Dockerfile</code>，第二个是<code class="fe lt lu lv lw b">docker-compose.yml</code>文件，第三个是配置数据库连接的<code class="fe lt lu lv lw b">database.yml</code>文件。</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="f6fd" class="mb mc iq lw b gy md me l mf mg">FROM ruby:2.3.0<br/>RUN apt-get update -qq &amp;&amp; apt-get install -y build-essential libpq-dev nodejs<br/>RUN mkdir /myapp<br/>WORKDIR /myapp<br/>COPY Gemfile /myapp/Gemfile<br/>COPY Gemfile.lock /myapp/Gemfile.lock<br/>RUN bundle install<br/>CMD ["rails", "server"]<br/></span></pre><p id="e961" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个文件的作用是在运行Ruby的映像(即<code class="fe lt lu lv lw b">Dockerfile</code>)之外制作容器，并安装运行项目所需的所有依赖项。当一个容器被创建时，我们运行服务器。</p><p id="6672" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其次，我们会调查<code class="fe lt lu lv lw b">docker-compose</code>的档案。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="73f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一行指定Docker Compose的版本。</p><p id="faec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从第二行开始，我们描述了我们想要运行的两个服务(容器)。第一个是我们的数据库，服务名是<em class="nq"> db </em>。这是由Docker Hub<a class="ae kv" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank">上公开的Postgres图片运行的。它是自动为我们下载的。</a></p><p id="8ed1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个是我们的网络服务。为此，我们需要建立一个形象。那将由上面提到的<code class="fe lt lu lv lw b">Dockerfile</code>建造。</p><p id="956f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望我们的应用程序重新启动，并反映代码的变化。这就是为什么我们将应用程序的根文件夹作为一个卷连接到Docker容器中的工作目录。一旦您在系统上更改了代码，容器就会读取这些更改并重启服务器。你可以继续做你的发展，而不用担心你的环境。</p><p id="f810" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该可以从我们的机器上打开集装箱。因此，我们通过将系统的端口3000绑定到Docker容器的端口3000来指定端口。</p><p id="0d45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，运行Rails的容器应该能够访问我们的数据库。因此，我们的服务依赖于数据库服务。我的web服务容器的db主机将只是<em class="nq"> db </em>。</p><p id="d887" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我给你看一下<code class="fe lt lu lv lw b">database.yml</code>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9d51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所看到的，提到的主机只是字符串<em class="nq"> db </em>，db容器的所有端口都可以直接被我们的web容器访问，尽管它们不能被我们的本地机器访问。</p><p id="04f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">db容器中映射的卷确保了即使我们停止db容器，数据也是持久的。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="66ef" class="ms mc iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">摘要</h1><p id="8bb5" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">如果想尽快上手，只需将<code class="fe lt lu lv lw b">Dockerfile</code>和<code class="fe lt lu lv lw b">docker-compose.yml</code>复制到自己的项目中，将<code class="fe lt lu lv lw b">database.yml</code>中的<code class="fe lt lu lv lw b">db host</code>更改即可。您将很快在任何支持Docker的机器上启动并运行。</p><p id="6899" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Node.js和Golang的类似示例repos即将推出。我也会给你更新的。</p></div></div>    
</body>
</html>