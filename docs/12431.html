<html>
<head>
<title>Factory: Swift Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工厂:快速依赖注入</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/factory-swift-dependency-injection-14da9b2b5d09?source=collection_archive---------3-----------------------#2022-06-06">https://betterprogramming.pub/factory-swift-dependency-injection-14da9b2b5d09?source=collection_archive---------3-----------------------#2022-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a9ae" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解决老问题的新方法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c391ce98e6ead6052815147a21c6c282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b63DMzqgSzNHBjRF5RcBQA.png"/></div></div></figure><h2 id="87d2" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">为什么要做新的东西？</h2><p id="8e7c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">我写过的第一个依赖注入系统是<a class="ae mj" href="https://github.com/hmlongco/Resolver" rel="noopener ugc nofollow" target="_blank">解析器</a>。这个开源项目虽然非常强大，并且仍然在许多应用程序中使用，但是也有一些缺点。</p><ol class=""><li id="a62f" class="mk ml it ls b lt mm lw mn ld mo lh mp ll mq mi mr ms mt mu bi translated">解析器要求预先注册所有服务工厂。</li><li id="7586" class="mk ml it ls b lt mv lw mw ld mx lh my ll mz mi mr ms mt mu bi translated">解析器使用类型推断来动态地从容器中查找并返回注册的服务。</li></ol><p id="d062" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">第一个问题相对较小。虽然预注册可能会导致应用程序启动时的性能下降，但实际上这个过程通常很快，通常不会引起注意。</p><p id="7772" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">不，这是第二个问题。</p><p id="cb4e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">如果我们试图解析给定的类型，并且没有找到匹配的注册，那么找不到匹配的类型会导致应用程序崩溃。在现实生活中，这并不是一个真正的问题，因为当你第一次运行单元测试或者当你运行应用程序来查看你的最新特性是否工作时，这样的事情往往会被注意到并且很快被修复。</p><p id="0a85" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">但是…我们能做得更好吗？这个问题<a class="ae mj" href="https://medium.com/geekculture/i-hate-swift-i-love-swift-318171a0f0df" rel="noopener">引导我寻找编译时类型安全</a>。其他几个项目也试图解决这个问题，但是我不想在构建过程中添加源代码扫描和生成步骤，也不想放弃基于运行时的系统中固有的大量控制和灵活性。</p><p id="fcf1" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">我还想要一些简单、快速、干净、易于使用的东西。</p><p id="fba2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">我可以把我的蛋糕也吃掉吗？</p><p id="4461" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">让我们找出答案。</p><blockquote class="nd ne nf"><p id="2380" class="lq lr ng ls b lt mm ju lv lw mn jx ly nh na ma mb ni nb md me nj nc mg mh mi im bi translated">注意:本文假设您熟悉依赖注入及其概念。如果没有，你可能想读一读我为Resolver写的<a class="ae mj" href="https://github.com/hmlongco/Resolver/blob/master/Documentation/Introduction.md" rel="noopener ugc nofollow" target="_blank">关于依赖注入的温和方法</a>指南。</p></blockquote><h2 id="1d4f" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">工厂</strong></h2><p id="4e5a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">工厂受到SwiftUI的强烈影响，在我看来非常适合在那个环境中使用。工厂是…</p><ul class=""><li id="5146" class="mk ml it ls b lt mm lw mn ld mo lh mp ll mq mi nk ms mt mu bi translated"><strong class="ls iu">安全</strong>:工厂是编译时安全的；给定类型* <em class="ng">的工厂必须</em> *存在，否则代码根本无法编译。</li><li id="30e2" class="mk ml it ls b lt mv lw mw ld mx lh my ll mz mi nk ms mt mu bi translated"><strong class="ls iu">灵活:</strong>很容易在运行时覆盖依赖关系，并在SwiftUI预览中使用。</li><li id="e671" class="mk ml it ls b lt mv lw mw ld mx lh my ll mz mi nk ms mt mu bi translated"><strong class="ls iu">强大:</strong>像解析器一样，工厂支持应用程序、缓存、共享和自定义范围、客户容器、参数、装饰器等等。</li><li id="d533" class="mk ml it ls b lt mv lw mw ld mx lh my ll mz mi nk ms mt mu bi translated"><strong class="ls iu">轻量级:</strong>所有工厂都是精简的，不到300行代码。(不到分解器大小的三分之一。)</li><li id="300e" class="mk ml it ls b lt mv lw mw ld mx lh my ll mz mi nk ms mt mu bi translated"><strong class="ls iu"> Performant: </strong>您的绝大多数服务都不需要设置时间，解决速度极快，并且不需要编译时脚本或构建阶段。</li><li id="4e39" class="mk ml it ls b lt mv lw mw ld mx lh my ll mz mi nk ms mt mu bi translated"><strong class="ls iu">简洁:</strong>定义一个注册通常只需要一行代码。</li><li id="ea7f" class="mk ml it ls b lt mv lw mw ld mx lh my ll mz mi nk ms mt mu bi translated"><strong class="ls iu"> Tested </strong>:单元测试确保注册、分辨率和作用域的正确操作。</li><li id="2135" class="mk ml it ls b lt mv lw mw ld mx lh my ll mz mi nk ms mt mu bi translated"><strong class="ls iu">免费:</strong>在麻省理工学院的许可下，Factory是免费和开源的。</li></ul><p id="fcc1" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">听起来好得难以置信？让我们来看看。</p><h2 id="c39e" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">简单的例子</h2><p id="aa73" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">大多数基于容器的依赖注入系统要求您以某种方式定义给定的服务类型可用于注入，并且许多系统要求某种工厂或机制，在需要时提供服务的新实例。</p><p id="f70a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">工厂也不例外。这里有一个简单的依赖关系注册。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="33c6" class="ku kv it nm b gy nq nr l ns nt">extension Container {<br/>    static let myService = Factory { MyService() as MyServiceType }<br/>}</span></pre><p id="7783" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">不像Resolver经常需要定义过多的注册函数，或者SwiftUI，定义一个新的环境变量需要创建一个新的EnvironmentKey并添加额外的getters和setters，这里我们只需向默认容器添加一个新的static <code class="fe nu nv nw nm b">Factory</code>。当需要我们对象的一个实例时，工厂闭包被求值并返回我们依赖关系的一个实例。就是这样。</p><p id="deca" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">在需要的地方使用服务同样简单。这里有一种方法。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="91e4" class="ku kv it nm b gy nq nr l ns nt">class ContentViewModel: ObservableObject {<br/>    @Injected(Container.myService) private var myService<br/>    ...<br/>}</span></pre><p id="a2b7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">这里，我们的视图模型使用一个<code class="fe nu nv nw nm b">@Injected</code>属性包装器来请求所需的依赖关系。类似于SwiftUI中的<code class="fe nu nv nw nm b">@EnvironmentObject</code>,我们为属性包装器提供对所需类型工厂的引用，其余的由它来处理。</p><p id="589a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">这就是核心机制。为了使用属性包装器，你必须定义一个工厂。当被询问时，工厂<em class="ng">必须</em>返回想要的类型。任何一项都做不好，代码将无法编译。因此，工厂是编译时安全的。</p><h2 id="5bd2" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">什么是工厂？</h2><p id="a09e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated"><code class="fe nu nv nw nm b">Factory</code>是一个轻量级结构，它管理给定的依赖关系。由于静态变量的惰性，工厂直到第一次被引用时才会被实例化。</p><p id="c6d3" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">当一个工厂被评估时，它提供一个期望依赖的实例。注意，也可以绕过属性包装，直接调用工厂。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="fd1b" class="ku kv it nm b gy nq nr l ns nt">class ContentViewModel: ObservableObject {<br/>    // dependencies<br/>    private let myService = Container.myService()<br/>    private let eventLogger = Container.eventLogger()<br/>    ...<br/>}</span></pre><p id="c9bc" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">你可以直接引用容器或者使用属性包装器，但是为了清楚起见，我建议把一个给定对象的所有依赖项都放在类的顶部。哦，把它们也标记为私人的。</p><h2 id="d7ec" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">嘲笑和测试</h2><p id="3011" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">检查上面的代码，有人可能想知道为什么我们要这么麻烦？为什么不直接说<code class="fe nu nv nw nm b">let myService = MyService()</code>就完事了呢？</p><p id="bf60" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">或者保留容器的想法，但是写一些类似这样的东西…</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="3b0c" class="ku kv it nm b gy nq nr l ns nt">extension Container {<br/>    static var myService: MyServiceType { MyService() }<br/>}</span></pre><p id="d9bb" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">使用基于容器的依赖注入系统的主要好处是，我们能够根据需要改变系统的行为，如果你硬编码依赖，我们就不能这样做。</p><p id="ba09" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">考虑以下代码:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="4fde" class="ku kv it nm b gy nq nr l ns nt">struct ContentView: View {<br/>    @StateObject var model = ContentViewModel1()<br/>    var body: some View {<br/>        Text(model.text())<br/>            .padding()<br/>    }<br/>}</span></pre><p id="40c8" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">我们的<code class="fe nu nv nw nm b">ContentView</code>使用我们的视图模型，它被分配给一个<code class="fe nu nv nw nm b">StateObject</code>。太好了。但是现在我们想预览我们的代码。我们如何改变<code class="fe nu nv nw nm b">ContentViewModel</code>的行为，使得它的<code class="fe nu nv nw nm b">MyService</code>依赖在开发过程中不进行实时API调用？</p><p id="841d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">很简单。只是用一个模仿来代替<code class="fe nu nv nw nm b">MyService</code>。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="9e1e" class="ku kv it nm b gy nq nr l ns nt">struct ContentView_Previews: PreviewProvider {<br/>    static var previews: some View {<br/>        let _ = Container.myService.register { MockService2() }<br/>        ContentView()<br/>    }<br/>}</span></pre><p id="ea45" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">请注意预览代码中的那一行，我们回到了容器，并在工厂中注册了一个新的闭包。该功能<em class="ng">覆盖</em>默认的工厂关闭。</p><p id="65c0" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">现在，当我们的预览显示时,<code class="fe nu nv nw nm b">ContentView</code>创建一个<code class="fe nu nv nw nm b">ContentViewModel</code>,它又依赖于使用<code class="fe nu nv nw nm b">Injected</code>属性包装器的<code class="fe nu nv nw nm b">myService</code>。但是当属性包装器调用工厂来请求一个<code class="fe nu nv nw nm b">MyServiceType</code>实例时，它现在接收一个<code class="fe nu nv nw nm b">MockService2</code>实例，而不是最初定义的<code class="fe nu nv nw nm b">MyService</code>实例。</p><p id="21d5" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">我们可以这样做，因为我们最初将<code class="fe nu nv nw nm b">myService</code>工厂的结果转换为协议<code class="fe nu nv nw nm b">MyServiceType</code>。因为<code class="fe nu nv nw nm b">MockService2</code>符合<code class="fe nu nv nw nm b">MyServiceType</code>协议，所以我们很好，我们可以用一个替换另一个。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="e4f1" class="ku kv it nm b gy nq nr l ns nt">extension Container {<br/>    static let myService = Factory { MyService() as MyServiceType }<br/>}</span></pre><p id="18fa" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">如果没有专门化，工厂的类型被推断为工厂闭包返回的类型。您也可以通过专门化通用工厂获得相同的结果，如下所示。两者相当。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="bd9a" class="ku kv it nm b gy nq nr l ns nt">extension Container {<br/>    static let myService = Factory&lt;MyServiceType&gt; { MyService() }<br/>}</span></pre><p id="fd88" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">另外要注意的一点是，我们注册块的结果也必须符合原厂的类型。如果不是这样，如果你试图返回其他东西，Swift会抱怨并给你一个错误。简而言之，这也是编译时安全的。</p><p id="8e1a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">如果我们有几个一直在使用的mocks，我们也可以在容器中添加一个设置函数来简化这个过程。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="d148" class="ku kv it nm b gy nq nr l ns nt">extension Container {<br/>    static func setupMocks() {<br/>        myService.register { MockServiceN(4) }<br/>        sharedService.register { MockService2() }<br/>    }<br/>}</span><span id="a1d3" class="ku kv it nm b gy nx nr l ns nt">struct ContentView_Previews: PreviewProvider {<br/>    static var previews: some View {<br/>        let _ = Container.setupMocks()<br/>        ContentView()<br/>    }<br/>}</span></pre><p id="a38d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">这是一个强大的概念，它让我们深入到依赖链中，并根据需要改变系统的行为。</p><p id="386e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">但是工厂还有更多锦囊妙计。</p><h2 id="756f" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">领域</h2><p id="313d" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">如果您以前使用过Resolver或其他依赖注入系统，那么您可能已经体验过作用域的好处和威力。</p><p id="55c0" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">如果不是，这个概念很容易理解:</p><blockquote class="nd ne nf"><p id="7145" class="lq lr ng ls b lt mm ju lv lw mn jx ly nh na ma mb ni nb md me nj nc mg mh mi im bi translated">一个对象的实例应该存在多久？</p></blockquote><p id="1835" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">毫无疑问，在你职业生涯的某个阶段，你已经在应用程序中创造了一个singleton。这是一个范围的例子。应用程序中的所有方法和函数创建、使用和共享一个实例。</p><p id="32e3" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">这可以在工厂中简单地通过添加一个范围属性来完成。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="f35f" class="ku kv it nm b gy nq nr l ns nt">extension Container {<br/>    static let someService = Factory(scope: .singleton) { <br/>        SomeService() <br/>    }<br/>}</span></pre><p id="93f8" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">现在，每当有人请求一个<code class="fe nu nv nw nm b">someService</code>的实例时，他们都会得到和其他人一样的对象实例。</p><p id="7d1a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">除非改动，否则默认范围是<code class="fe nu nv nw nm b">unique</code>；每当工厂被请求一个对象的实例时，它将获得该对象的一个新实例。</p><p id="116b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">其他常见的范围有<code class="fe nu nv nw nm b">cached</code>和<code class="fe nu nv nw nm b">shared</code>。缓存项会一直保存到缓存被重置，而共享项只要有人持有对它们的强引用就会一直存在。当最后一个引用消失时，弱持有的共享引用也消失。</p><p id="9a3b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">您也可以添加您自己的特殊用途的范围。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="dc95" class="ku kv it nm b gy nq nr l ns nt">extension Container.Scope {<br/>    static var session = Cached()<br/>}</span><span id="00da" class="ku kv it nm b gy nx nr l ns nt">extension Container {<br/>    static let authentication = Factory(scope: .session) { <br/>        Authentication()<br/>    }<br/>}</span></pre><p id="2061" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">一旦创建好了，<code class="fe nu nv nw nm b">Authentication</code>的单个实例将被提供给任何需要的人……直到会话范围被重置，可能是用户注销。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="3df2" class="ku kv it nm b gy nq nr l ns nt">func logout() {<br/>    Container.Scope.session.reset()<br/>    ...<br/>}</span></pre><p id="2075" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">瞄准镜是你武器库中的强大工具。使用它们。</p><h2 id="ed92" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">构造函数注入</h2><p id="c593" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">有时，我们可能更喜欢(或需要)使用一种称为<em class="ng">构造函数注入</em>的技术，在初始化时向对象提供依赖关系。</p><p id="cde7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">这在工厂里很容易做到。这里我们有一个依赖于前面定义的<code class="fe nu nv nw nm b">MyServiceType</code>实例的服务。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="3592" class="ku kv it nm b gy nq nr l ns nt">extension Container {<br/>    static let constructedService = Factory {<br/>       MyConstructedService(service: myService())<br/>    }<br/>}</span></pre><p id="27a3" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">容器中的所有工厂对容器中的其他工厂都是可见的。只需调用所需的工厂作为函数，就会提供依赖关系。</p><h2 id="9e86" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">定制容器</h2><p id="8412" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">在大型项目中，您可能希望将工厂分隔成额外的较小容器。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="b7ff" class="ku kv it nm b gy nq nr l ns nt">class OrderContainer: SharedContainer {<br/>    static let optionalService = Factory&lt;SimpleService?&gt; { <br/>        nil<br/>    }<br/>    static let constructedService = Factory { <br/>        MyConstructedService(service: myServiceType()) <br/>    }<br/>    static let additionalService = Factory(scope: .session) { <br/>        SimpleService()<br/>    }<br/>}</span></pre><p id="6602" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">只需定义一个从<code class="fe nu nv nw nm b">SharedContainer</code>派生的新容器，并在那里添加您的工厂。您可以拥有任意多的容器，甚至可以从您自己的容器中派生出其他容器。</p><p id="f9a9" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">虽然容器<em class="ng">树</em>使得依赖关系解析更加容易，但是不要忘记，如果需要，您可以通过指定完整的container.factory路径来跨越容器。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="bb24" class="ku kv it nm b gy nq nr l ns nt">class PaymentsContainer: SharedContainer {<br/>    static let anotherService = Factory {<br/>       AnotherService(OrderContainer.optionalService())<br/>    }<br/>}</span></pre><h2 id="0baa" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">共享容器</h2><p id="7a38" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">注意，你也可以将自己的工厂添加到<code class="fe nu nv nw nm b">SharedContainer</code>中。在那里添加的任何内容都可以在系统中的每个容器上看到。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="8256" class="ku kv it nm b gy nq nr l ns nt">extension SharedContainer {<br/>    static let api = Factory&lt;APIServiceType&gt; { APIService() }<br/>}</span></pre><h2 id="970c" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">单元测试</h2><p id="9079" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">工厂还增加了一些条款，使单元测试更容易。在您的单元测试设置功能中，您可以* <em class="ng">推送</em> *注册系统的当前状态，然后注册并测试您想要的任何东西。</p><p id="fbdb" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">然后在你的拆卸函数中，简单地* <em class="ng">弹出</em> *你的修改，将一切恢复到运行测试套件之前的状态。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="2496" class="ku kv it nm b gy nq nr l ns nt">final class FactoryCoreTests: XCTestCase {</span><span id="0e7a" class="ku kv it nm b gy nx nr l ns nt">    override func setUp() {<br/>        super.setUp()<br/>        Container.Registrations.push()<br/>     }</span><span id="aa10" class="ku kv it nm b gy nx nr l ns nt">    override func tearDown() {<br/>        super.tearDown()<br/>        Container.Registrations.pop()<br/>    }<br/>    <br/>    ...<br/>}</span></pre><h2 id="f4e7" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">重置</h2><p id="5d6c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">您也可以重置注册以恢复原始工厂关闭。或者，如果需要，您可以用一个命令将一切都重置回原点。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="e8bd" class="ku kv it nm b gy nq nr l ns nt">Container.myService.reset() // single<br/>Container.Registrations.reset() // all</span></pre><h2 id="d6bd" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">开放源码</h2><p id="50e4" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">如上所述，Factory在MIT许可下是免费和开源的。</p><p id="c7a3" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">在GitHub 上的<a class="ae mj" href="https://github.com/hmlongco/Factory" rel="noopener ugc nofollow" target="_blank">工厂存储库下有源代码、一个小的演示应用和单元测试。</a></p><h2 id="7435" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">分解器</h2><p id="439c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">工厂可能标志着解析器的终结。我从那个项目中学到了很多，它甚至为我赢得了来自谷歌的开源同行奖金<a class="ae mj" href="https://opensource.googleblog.com/2021/09/announcing-latest-open-source-peer-bonus-winners.html" rel="noopener ugc nofollow" target="_blank">。(我一直觉得一个iOS开发者获得谷歌的奖项有点奇怪，但你知道了。)</a></p><p id="016a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated">但是工厂更小、更快、更干净，总之是比分解器更好的解决方案。</p><h2 id="d5b7" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">完成块</h2><p id="d8e5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">原来如此。一如既往，请在下面的评论中让我知道你的想法。</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="8c24" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly ld na ma mb lh nb md me ll nc mg mh mi im bi translated"><em class="ng">本文是</em> <a class="ae mj" href="https://medium.com/p/365ce5038ef7/edit" rel="noopener"> <em class="ng">雨燕依赖注入系列</em> </a> <em class="ng">的一部分。</em></p></div></div>    
</body>
</html>