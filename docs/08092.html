<html>
<head>
<title>Android Data Binding With MVVM: Using StateFlow and ViewModel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与MVVM的Android数据绑定:使用StateFlow和ViewModel</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/android-data-binding-with-mvvm-using-stateflow-and-viewmodel-bce04d0b9bc4?source=collection_archive---------2-----------------------#2021-03-24">https://betterprogramming.pub/android-data-binding-with-mvvm-using-stateflow-and-viewmodel-bce04d0b9bc4?source=collection_archive---------2-----------------------#2021-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="979f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用数据绑定构建基于MVVM架构的应用程序指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d14e77f39d0d8ea211b7c8955d0a7ffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KvhN146fXV77DjAX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">美国宇航局在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="749a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个系列的第三部分，在这个系列中，您将学习数据绑定的基础知识，以及如何将数据绑定用于像<code class="fe lv lw lx ly b">LiveData</code>和<code class="fe lv lw lx ly b">ViewModel</code>这样的架构组件。今天，您将学习如何使用Kotlin协同程序和<code class="fe lv lw lx ly b">StateFlow</code>通过来自<code class="fe lv lw lx ly b">ViewModel</code>的数据绑定来更新UI。</p><ul class=""><li id="997f" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/android-2-way-data-binding-with-mvvm-c13022a2f04a">“Android与MVVM架构的数据绑定(上)”</a> : <em class="mi">基础知识&gt;双向绑定&gt;代码优化</em></li><li id="43e4" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/android-data-binding-with-mvvm-using-livedata-and-viewmodel-71028901e3bb">“Android与MVVM架构的数据绑定(下)”:<em class="mi">与LiveData和ViewModel的数据绑定</em> </a></li><li id="37a2" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated">“Android数据绑定与MVVM架构(第三部分)”:你在这里。</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="4559" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">介绍</h1><h2 id="0c71" class="nn mw it bd mx no np dn nb nq nr dp nf li ns nt nh lm nu nv nj lq nw nx nl ny bi translated">状态流</h2><p id="3511" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated"><a class="ae ky" href="https://kotlinlang.org/docs/reference/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank">协程</a>中的<a class="ae ky" href="https://kotlinlang.org/docs/reference/coroutines/flow.html" rel="noopener ugc nofollow" target="_blank">流API </a>是处理数据流的更好方式。<code class="fe lv lw lx ly b">StateFlow</code>试图在你的Android应用中引入强大的Flow特性来管理状态。</p><p id="1d74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如GitHub 上的<a class="ae ky" href="https://github.com/Kotlin/kotlinx.coroutines/issues/1973" rel="noopener ugc nofollow" target="_blank">所解释的那样，<code class="fe lv lw lx ly b">StateFlow</code>有两种变体:<code class="fe lv lw lx ly b">StateFlow</code>和<code class="fe lv lw lx ly b">MutabaleStateFlow</code>。</a></p><blockquote class="oe of og"><p id="954f" class="kz la mi lb b lc ld ju le lf lg jx lh oh lj lk ll oi ln lo lp oj lr ls lt lu im bi translated">“<code class="fe lv lw lx ly b">StateFlow&lt;T&gt;</code>接口是一个只读视图，它提供对当前<code class="fe lv lw lx ly b">value</code>的访问，并实现一个<code class="fe lv lw lx ly b">Flow&lt;T&gt;</code>来收集对值的更新。</p><p id="b0f7" class="kz la mi lb b lc ld ju le lf lg jx lh oh lj lk ll oi ln lo lp oj lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">MutabaleStateFlow&lt;T&gt;</code>接口增加了修改值的操作。"</p></blockquote><p id="c530" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是第一次接触<code class="fe lv lw lx ly b">StateFlow</code>，我强烈建议你在进一步了解之前阅读以下文章:</p><div class="ok ol gp gr om on"><a rel="noopener  ugc nofollow" target="_blank" href="/introducing-coroutines-stateflow-ca1b13133265"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">引入协程StateFlow</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">这是Android版LiveData的终结吗？</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">better编程. pub</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div><h2 id="42cd" class="nn mw it bd mx no np dn nb nq nr dp nf li ns nt nh lm nu nv nj lq nw nx nl ny bi translated">数据绑定</h2><p id="601b" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">数据绑定是一个框架，它通过减少开发人员需要编写的样板代码来充当布局和数据源之间的桥梁。这将提高开发人员的生产力，让他们有时间专注于重要的事情。</p><p id="6f3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是数据绑定框架的新手，我建议您阅读下面的文章和本系列的第一部分。今天的部分是关于如何在架构中使用数据绑定。要理解这一点，你应该知道一些基本知识。</p><div class="ok ol gp gr om on"><a href="https://sgkantamani.medium.com/data-binding-in-android-4ff7bba93a2c" rel="noopener follow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">Android中的数据绑定</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">不再需要编程来更新UI并将事件链接到视图</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">sgkantamani.medium.com</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb ks on"/></div></div></a></div></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="07d2" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">数据绑定中的状态流支持</h1><p id="4ad4" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">如果您阅读了本系列的第二部分，我们使用了<code class="fe lv lw lx ly b">LiveData</code>作为数据源来更新布局中的UI。使用<code class="fe lv lw lx ly b">LiveData</code>使数据绑定具有生命周期意识，并且只有当屏幕在前台时才更新UI。</p><p id="2cb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文的目标是用<code class="fe lv lw lx ly b">StateFlow</code>代替<code class="fe lv lw lx ly b">LiveData</code>的用法。Kotlin团队最近宣布，我们现在可以使用<code class="fe lv lw lx ly b">StateFlow</code>作为数据绑定的数据源。要做到这一点，你应该安装Android Studio北极狐金丝雀4 (2020.3.1.4)，现在金丝雀和Dev频道都有。</p><p id="5eec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在继续之前，让我们检查一下缺点:</p><ol class=""><li id="dedd" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu pd mf mg mh bi translated">与<code class="fe lv lw lx ly b">LiveData</code>不同，<code class="fe lv lw lx ly b">StateFlow</code>是新的。</li><li id="357d" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu pd mf mg mh bi translated"><code class="fe lv lw lx ly b">LiveData</code>是Jetpack库的一部分，所以它可以在Java代码中使用。<code class="fe lv lw lx ly b">StateFlow</code>是协程的一部分，只能在Kotlin中使用。</li></ol><p id="ca4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，我看不出使用<code class="fe lv lw lx ly b">StateFlow</code>有任何潜在的缺点。但是我应该说<code class="fe lv lw lx ly b">StateFlow</code>将改变我们在架构中管理状态的方式，因为我们倾向于非常深入地使用协程。</p><p id="c12c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">话虽如此，我们还是开始吧。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="2a46" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">履行</h1><p id="4d89" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">让我们继续本系列前几部分中使用的例子。在第1部分中，我们直接导入了<code class="fe lv lw lx ly b">Activity</code>中的<code class="fe lv lw lx ly b">UserModel</code>作为绑定的数据源。在第二部分中，我们创建了一个<code class="fe lv lw lx ly b">ViewModel</code>并从<code class="fe lv lw lx ly b">ViewModel</code>实例中访问了由<code class="fe lv lw lx ly b">LiveData</code>包装的<code class="fe lv lw lx ly b">UserModel</code>。</p><h2 id="7fbe" class="nn mw it bd mx no np dn nb nq nr dp nf li ns nt nh lm nu nv nj lq nw nx nl ny bi translated">快速回顾</h2><p id="1292" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">数据类别:</p><pre class="kj kk kl km gt pe ly pf pg aw ph bi"><span id="c1a7" class="nn mw it ly b gy pi pj l pk pl">data class UserModel (var name: <strong class="ly iu">String </strong>="" ,<br/>                 var email: <strong class="ly iu">String </strong>= "")</span></pre><p id="5f39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">ViewModel</code>同<code class="fe lv lw lx ly b">LiveData</code>:</p><pre class="kj kk kl km gt pe ly pf pg aw ph bi"><span id="1971" class="nn mw it ly b gy pi pj l pk pl">class UserViewModel : ViewModel() {<br/><br/>    var userModel  = <strong class="ly iu">MutableLiveData&lt;UserModel&gt;()</strong><br/><br/>}</span></pre><p id="3a6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，使用<code class="fe lv lw lx ly b">LiveData</code>作为数据源来在XML布局中进行数据绑定:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><h2 id="965d" class="nn mw it bd mx no np dn nb nq nr dp nf li ns nt nh lm nu nv nj lq nw nx nl ny bi translated">用StateFlow替换LiveData</h2><p id="d8f8" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">很像<code class="fe lv lw lx ly b">LiveData</code>，<code class="fe lv lw lx ly b">StateFlow</code>完全支持开箱即用的数据绑定。就我个人而言，我认为这是Kotlin在Android开发中的影响力的一种进步。数据绑定是来自Android家族的Jetpack库，而<code class="fe lv lw lx ly b">StateFlow</code>来自Kotlin coroutines。看到两个来自不同环境的不同实体走到一起真是太棒了。</p><p id="95c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望<code class="fe lv lw lx ly b">StateFlow</code>对数据绑定的支持不会像最近被弃用的Kotlin synthetics那样。</p><p id="5d3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢Kotlin团队，我们只需要将<code class="fe lv lw lx ly b">ViewModel</code>中的<code class="fe lv lw lx ly b">LiveData</code>更新为<code class="fe lv lw lx ly b">StateFlow</code>对象。其余的将由数据绑定和引擎盖下的<code class="fe lv lw lx ly b">StateFlow</code>处理。</p><p id="17f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要创建一个带有初始值的私有可变<code class="fe lv lw lx ly b">StateFlow</code>实例。然后，我们将它分配给另一个<code class="fe lv lw lx ly b">StateFlow</code>实例，我们在XML布局中使用它来更新UI:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="f09e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已。我们不需要对视图或XML布局做任何改变。内部发生的事情是，它将通过替换<code class="fe lv lw lx ly b">LiveData</code>在我们的Android组件中使用具有给定上下文的<code class="fe lv lw lx ly b">StateFlow</code>。最重要的事情之一是要求生命周期所有者在使用<code class="fe lv lw lx ly b">LiveData</code>或<code class="fe lv lw lx ly b">StateFlow</code>时绑定对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="0359" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你有了一个使用<code class="fe lv lw lx ly b">ViewModel</code>、<code class="fe lv lw lx ly b">StateFlow</code>和数据绑定的应用程序。</p><p id="5886" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本系列的第一部分中，我们学习了如何用可观察字段更新UI。在第二部分中，我们删除了所有带有<code class="fe lv lw lx ly b">LiveData</code>和数据绑定的样板文件。今天，我们使用一个Kotlin核心API来替换<code class="fe lv lw lx ly b">LiveData</code>,以便用协程改进代码。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="ae8f" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">奖金</h1><p id="ef31" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">要了解有关Android高级开发的更多信息，请阅读以下文章:</p><ul class=""><li id="57bc" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><a class="ae ky" href="https://medium.com/better-programming/android-recyclerview-with-kotlin-sealed-classes-6d2985aac3e5" rel="noopener">“Android recycler view With kot Lin Sealed Classes”</a></li><li id="3a4d" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><a class="ae ky" href="https://medium.com/better-programming/use-android-build-variants-to-manage-server-environments-146125ae31d2" rel="noopener">“使用Android构建变体管理服务器环境”</a></li><li id="9825" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><a class="ae ky" href="https://medium.com/better-programming/gradle-dependency-management-with-buildsrc-and-kotlin-dsl-1de958eab166" rel="noopener">“使用BuildSrc和Kotlin DSL进行梯度依赖管理”</a></li><li id="e55b" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><a class="ae ky" href="https://medium.com/better-programming/the-evolution-of-view-linking-in-android-d6219678740d" rel="noopener">《Android中视图链接的演变》</a></li></ul><p id="9aa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>