<html>
<head>
<title>When to use “useImperativeHandle” and “forwardRefs” in React 18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 18中何时使用“useImperativeHandle”和“forwardRefs”</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/when-to-use-useimperativehandle-and-forwardrefs-in-react-18-89cce42b3309?source=collection_archive---------7-----------------------#2022-09-12">https://betterprogramming.pub/when-to-use-useimperativehandle-and-forwardrefs-in-react-18-89cce42b3309?source=collection_archive---------7-----------------------#2022-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="38fb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">有时候，你必须拿出大枪</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f2ca4e4ad9b806b4d1e354c837fc1607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WjZfcb7YZ0pgUx7z3cz6uQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者的标题图像</p></figure><p id="afa5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文是<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/react-v18-demystifying-useref-forwardref-and-useimperativehandle-feec2fc5b2f6">https://better programming . pub/react-v 18-demystifying-useref-forward ref-and-useimperativehandle-feec 2 fc 5 b 2 f 6</a>的延续，在那里我们看到了什么是ref以及它们是如何操作的。有了上一篇文章中获得的知识，让我们深入一点更复杂的理解，这在具有大量组件嵌套和一点真正的基于DOM的需求的真实项目中会派上用场。</p><h1 id="0fbf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">正向参考</h1><p id="1c2b" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">没有问题的解决方案是什么，对吗？所以，让我们来定义一个普通裁判不能完成工作的情况。如果我们有一个父组件想要引用子组件中定义的一个元素并修改焦点状态，该怎么办？让我们创建这样一个例子。</p><div class="kg kh ki kj gt ab cb"><figure class="mp kk mq mr ms mt mu paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/cd28f9d4a4a594df58d7b432d815190e.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*eLWlolRaMn11RnnBbH642g.png"/></div></figure><figure class="mp kk mv mr ms mt mu paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/a97d6485af93181d6fc8fc0edfdcfb6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*_4mb7gSEAbJLPfX_mdTvhQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk mw di mx my translated">父组件控制子组件中定义的按钮的焦点。</p></figure></div><p id="45d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如您在上面看到的，父组件控制子组件按钮上的焦点。这并不像将父元素中定义的ref作为道具传递给子元素那么简单。在我们的例子中，ref是一个特殊的属性，它定义在要改变焦点的HTML元素上，而不是子组件包装器上，因为它只是一个函数。</p><p id="f116" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过将我们的子组件包装到React提供的<code class="fe mz na nb nc b">forwardRef </code>函数中来获得期望的行为，该函数将处理这种委托。这个函数应该传递发送的道具，并允许组件上有一个额外的道具，这就是我们的“ref”代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">React中如何使用forwardRef？</p></figure><h1 id="c398" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">useImperativeHandle</h1><p id="55e8" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">看起来，我们在上一节中取得的成果对于复杂的情况来说已经足够了。尽管如此，有时您可能想在组件中定义一个自定义的ref功能，该功能将向使用它的组件公开。让我们试着创建一个需要这种细粒度控制的场景。</p><p id="0cf4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">默认情况下，输入的焦点颜色是<code class="fe mz na nb nc b">blue</code>，但是假设我们的忍者应该得到一个超临界的jonin级任务，那么输入区域应该聚焦在<code class="fe mz na nb nc b">red</code>上。</p><div class="kg kh ki kj gt ab cb"><figure class="mp kk nf mr ms mt mu paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/d5d8e39f6cfab33a72a00e2dbb473e4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*T0uOssF90_YeOKgDjfJrBg.png"/></div></figure><figure class="mp kk nf mr ms mt mu paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/68b1ed488f5f359f507e7c50b32f956a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*tMJLmQI44rvjHPCo89Vwvg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk ng di nh my translated">父组件可以控制子组件的输入所关注的颜色。</p></figure></div><p id="dc28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了说明<code class="fe mz na nb nc b">useImperativeHandle</code>在这种情况下的用法，让我们脱离常识，构建两个通过ref绑定到输入组件的自定义方法。这次，我们将有两个自定义方法<code class="fe mz na nb nc b">focusRed()</code>和<code class="fe mz na nb nc b">focusBlue()</code>，而不是默认的聚焦方法。</p><p id="a1d7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们仍然需要使用<code class="fe mz na nb nc b">forwardRef</code>将ref传递给子组件，但是在子组件内部，我们将在<code class="fe mz na nb nc b">useImperativeHandle</code>钩子的帮助下创建这些新函数。代码如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们正在使用useImperativeHandle向ref添加自定义方法。</p></figure><blockquote class="ni nj nk"><p id="a6e4" class="kv kw nl kx b ky kz jr la lb lc ju ld nm lf lg lh nn lj lk ll no ln lo lp lq ij bi translated">需要注意的一件重要事情是，在上面的代码中，我们没有像前面的情况那样扩展默认可用的方法，而是创建了一组全新的方法。因此，<code class="fe mz na nb nc b"><em class="iq">default focus() </em></code>方法对我们来说不再可用，调用它会给我们带来甜蜜的错误。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/e2c6a412970a455260101a2329567e7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91DtTO0n1C-kP-Jyh4ERhA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用命令式句柄时，focus方法不可用。</p></figure><h1 id="4481" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="290f" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">总而言之，我将重复我在上一篇文章中说过的话:在进行基于虚拟dom的开发时，不应该使用对DOM的引用本身，因为您在真实DOM中所做的更改不会正确地转移到vDOM设置中，这会导致意外的反应。</p><p id="570e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我选择<code class="fe mz na nb nc b">focus</code>作为本文的中心话题，只是因为它是需要召唤裁判时的主要需求之一。React提到了一组有限的引用用例，你可以在这里看到:<a class="ae lr" href="https://reactjs.org/docs/refs-and-the-dom.html#when-to-use-refs" rel="noopener ugc nofollow" target="_blank">https://react js . org/docs/refs-and-the-DOM . html # when-to-use-refs</a>。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt nx nc ny nz aw oa bi"><span id="0aee" class="ob lt iq nc b gy oc od l oe of"><strong class="nc ir">Want To Connect?</strong></span><span id="4fe5" class="ob lt iq nc b gy og od l oe of">LinkedIn: <a class="ae lr" href="https://www.linkedin.com/in/sameerkumar1612/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/sameerkumar1612</a></span></pre></div></div>    
</body>
</html>