<html>
<head>
<title>Everything You Want to Know About React Refs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你想知道的关于React Refs的一切</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/most-things-you-want-to-know-about-react-refs-29901ebf28c6?source=collection_archive---------7-----------------------#2020-01-28">https://betterprogramming.pub/most-things-you-want-to-know-about-react-refs-29901ebf28c6?source=collection_archive---------7-----------------------#2020-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="05b1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看引用、回调引用、转发引用和命令句柄</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8ce38e3c2de2ace2f5b6096f993943e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kTeOHJWyLhInAWW7Qg_9HQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@mr_vero?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">欧文·史密斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c249" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你在React中遇到这些术语时，有没有感到迷茫:<code class="fe lv lw lx ly b"><a class="ae ky" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank">ref</a></code> <a class="ae ky" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank"> s </a>、<code class="fe lv lw lx ly b"><a class="ae ky" href="https://reactjs.org/docs/refs-and-the-dom.html#callback-refs" rel="noopener ugc nofollow" target="_blank">callback ref</a></code> <a class="ae ky" href="https://reactjs.org/docs/refs-and-the-dom.html#callback-refs" rel="noopener ugc nofollow" target="_blank"> s </a>、<code class="fe lv lw lx ly b"><a class="ae ky" href="https://reactjs.org/docs/forwarding-refs.html" rel="noopener ugc nofollow" target="_blank">forwarding ref</a></code> <a class="ae ky" href="https://reactjs.org/docs/forwarding-refs.html" rel="noopener ugc nofollow" target="_blank"> s </a>、<code class="fe lv lw lx ly b"><a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#useimperativehandle" rel="noopener ugc nofollow" target="_blank">imperativeHandle</a></code> <a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#useimperativehandle" rel="noopener ugc nofollow" target="_blank"> s </a>？我知道我有。</p><p id="b695" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在React历史的开始有<code class="fe lv lw lx ly b"><a class="ae ky" href="https://reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs" rel="noopener ugc nofollow" target="_blank">string ref</a></code> <a class="ae ky" href="https://reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs" rel="noopener ugc nofollow" target="_blank"> s </a>，然后是回调参考——但事情仍然不对劲。从React 16.3起，<a class="ae ky" href="https://github.com/reactjs/rfcs/pull/17/files" rel="noopener ugc nofollow" target="_blank">React团队决定</a>引进推广<code class="fe lv lw lx ly b">createRef</code>，保留回调引用，弃用<code class="fe lv lw lx ly b">string ref</code> s，11个月后React 16.8来了，带着革命性的钩子。我们以附加的<code class="fe lv lw lx ly b">useRef</code>和<code class="fe lv lw lx ly b">useImperativeHandle</code>结束。</p><p id="dc5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ref是访问DOM元素或React元素的一种方式。我们被赋予了<code class="fe lv lw lx ly b">ref</code>、<code class="fe lv lw lx ly b">callback ref</code>、<code class="fe lv lw lx ly b">forwarding ref</code>和<code class="fe lv lw lx ly b">imperativeHandle</code>的权利</p><p id="9cc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么什么时候我们应该使用<code class="fe lv lw lx ly b">ref</code> s呢？只要我们能抵抗，我们就应该使用它们。多么讽刺！</p><ul class=""><li id="35f5" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">React团队说过，“避免对任何可以声明完成的事情使用引用。”</li><li id="3751" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">他们加粗了标题，“不要过度使用参考文献”</li><li id="2f55" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">他们再次强调，“如果可能的话，我们建议不要暴露DOM节点，但这可能是一个有用的逃生出口。”</li></ul><p id="4194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好——一个有用的逃生出口！</p><p id="494a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React文档指出了一些很好的<code class="fe lv lw lx ly b">ref</code>用例:</p><ul class=""><li id="cdc9" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">管理焦点、文本选择或媒体播放。</li><li id="cc7e" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">触发命令式动画。</li><li id="eb98" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">与第三方DOM库集成。</li></ul><p id="bc20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这几个好的用例，我们来探索一下<code class="fe lv lw lx ly b">ref</code> s。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="a0a5" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">使用案例</h1><p id="3d5a" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在本文中，我们使用这个用例作为例子。</p><p id="4539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个只读输入字段，初始文本:<code class="fe lv lw lx ly b">highlight and copy me</code>。旁边是复制按钮。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/d4d339ad50284699b6e5adcc8e5aca39.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*CQchp9hQR8c5fLJnJaIknA.png"/></div></figure><p id="2ed4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果单击该按钮，输入字段内容将突出显示，文本将复制到剪贴板。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/0f8dc902c2073ad3ed85526602fbba01.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*RjIdpgcWhcntLTd5nUfy0w.png"/></div></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="2115" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated"><strong class="ak"> React.createRef </strong></h1><p id="4fed" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><code class="fe lv lw lx ly b">React.createRef</code>是为类组件设计的。通常，在构造函数中调用它来初始化一个<code class="fe lv lw lx ly b">ref</code>，然后将生成的<code class="fe lv lw lx ly b">ref</code>传递给DOM元素或React元素。</p><p id="4587" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第七行，我们创建了一个<code class="fe lv lw lx ly b">ref</code>并将其分配给<code class="fe lv lw lx ly b">this.textInput</code>。从第八行的输出中，我们可以看到开发者控制台上<code class="fe lv lw lx ly b">this.textInput</code>的初始值。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="4697" class="oa mw it ly b gy ob oc l od oe">Object {<br/>  current: null<br/>}</span></pre><p id="6c64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组件安装后，<code class="fe lv lw lx ly b">this.textInput.current</code>被分配给输入元件。单击复制按钮可以触发第13行的输出:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="f7c2" class="oa mw it ly b gy ob oc l od oe">"&lt;input type='text' readonly='' value='highlight and copy me'&gt;"</span></pre><p id="4392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们明白了为什么<code class="fe lv lw lx ly b">createRe</code> f会生成一个具有属性<code class="fe lv lw lx ly b">current</code>的对象。这允许我们保持对对象的相同引用，同时将<code class="fe lv lw lx ly b">current</code>分配给被引用的元素或组件。</p><p id="b083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当组件卸载时，<code class="fe lv lw lx ly b">this.textInput.current</code>将被分配回<code class="fe lv lw lx ly b">null</code>。<code class="fe lv lw lx ly b">ref</code>更新发生在<code class="fe lv lw lx ly b">componentDidMount</code>或<code class="fe lv lw lx ly b">componentDidUpdate</code>生命周期方法之前。</p><p id="ef04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从第13行的输出中，我们可以看到<code class="fe lv lw lx ly b">this.textInput.current</code>中没有<code class="fe lv lw lx ly b">ref</code>道具。<code class="fe lv lw lx ly b">ref</code>，类似于<code class="fe lv lw lx ly b">key</code>，是React内部使用的保留属性。</p><p id="85f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">借助<code class="fe lv lw lx ly b">this.textInput.current</code>的魔力，我们能够高亮显示第14行的输入，并通过第15行将其发送到剪贴板。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="2826" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">React.useRef</h1><p id="b060" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><code class="fe lv lw lx ly b">React.useRef</code>，相当于<code class="fe lv lw lx ly b">React.createRef</code>，是为功能部件设计的。下面的代码做了同样的事情，但是它更加简洁明了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="88a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">createRef</code>和<code class="fe lv lw lx ly b">useRef</code>有什么区别？</p><ul class=""><li id="19e1" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated"><code class="fe lv lw lx ly b">createRef</code>创建一个将<code class="fe lv lw lx ly b">current</code>分配给<code class="fe lv lw lx ly b">null</code>的对象。每次调用<code class="fe lv lw lx ly b">createRef</code>都会生成一个新的对象。对于一个类组件的构造函数来说，它是完美的，因为它只被调用一次。但是，它不是用于功能组件的。为每次渲染重新生成一个对象并不是一个好的用途，但它是有效的。</li><li id="c1cf" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated"><code class="fe lv lw lx ly b">useRef</code>创建一个可自定义初始值的对象。只有第一次调用<code class="fe lv lw lx ly b">useRef</code>才会生成一个新对象。该对象的<code class="fe lv lw lx ly b">current</code>值在功能组件的生命周期内保持不变，除非它被重新分配一个新值。它是为功能组件设计的。</li></ul><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="e93d" class="oa mw it ly b gy ob oc l od oe">React.useRef() generates:<br/>  Object {<br/>    current: undefined<br/>  }</span><span id="ed5a" class="oa mw it ly b gy of oc l od oe">React.useRef(null) generates:<br/>  Object {<br/>    current: null<br/>  }</span><span id="49c8" class="oa mw it ly b gy of oc l od oe">React.useRef('abc') generates:<br/>  Object {<br/>    current: "abc"<br/>  }</span></pre><ul class=""><li id="f43d" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">虽然<code class="fe lv lw lx ly b">React.createRef</code>的<code class="fe lv lw lx ly b">current</code>是可变的，但它是供React内部使用的。</li><li id="0936" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated"><code class="fe lv lw lx ly b">React.useRef</code>的用法超出了<code class="fe lv lw lx ly b">ref</code>属性——它用于保存任何可变值，类似于<code class="fe lv lw lx ly b">instance</code>变量。</li></ul><p id="563c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你遇到过这种反应警告吗？：</p><blockquote class="og oh oi"><p id="4bc1" class="kz la lz lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated">警告:无法对已卸载的组件执行反应状态更新。</p></blockquote><p id="f893" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子<a class="ae ky" href="https://github.com/material-components/material-components-web-react/issues/434" rel="noopener ugc nofollow" target="_blank">用<code class="fe lv lw lx ly b">useRef</code>解决了这个问题</a>。第三行的<code class="fe lv lw lx ly b">mounted</code>被初始化为<code class="fe lv lw lx ly b">true</code>，该值在组件安装时保持不变。当组件被卸载时，<code class="fe lv lw lx ly b">useEffect</code>的清理功能会通过第11行将其设置为<code class="fe lv lw lx ly b">false</code>。然后，<code class="fe lv lw lx ly b">setState</code>在组件被卸载后，第六行的条件保证命令不会被执行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ae0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">React.useRef</code>不通知其内容变更。改变<code class="fe lv lw lx ly b">.current</code>属性不会触发重新渲染。如果您想在React将一个<code class="fe lv lw lx ly b">ref</code>附加或分离到一个DOM节点时运行一些代码，回调引用可以用于这种用途。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="e39d" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">回调参考</h1><p id="f919" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">当React团队弃用字符串<code class="fe lv lw lx ly b">ref</code> s时，他们保持回调<code class="fe lv lw lx ly b">ref</code> s。回调<code class="fe lv lw lx ly b">ref</code>是一个函数。它对<code class="fe lv lw lx ly b">ref</code>何时置位和复位提供了更精细的控制。有了函数，我们可以直接存储对<code class="fe lv lw lx ly b">textInput</code>的输入引用，而不需要可变的holder <code class="fe lv lw lx ly b">current</code>。类似于<code class="fe lv lw lx ly b">createRef</code>和<code class="fe lv lw lx ly b">useRef</code>，回调ref将在组件挂载时被调用，在组件卸载时被设置为<code class="fe lv lw lx ly b">null</code>。</p><p id="22be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个类组件的回调<code class="fe lv lw lx ly b">ref</code>实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="f56f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个功能组件的回调<code class="fe lv lw lx ly b">ref</code>实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="5271" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不推荐回调引用——如果是内联回调，它们会在更新期间被调用两次。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="03c1" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">转发参考</h1><p id="96df" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">真正的项目是复杂的。不直接使用input元素，我们可能最终会得到一个组件库— <code class="fe lv lw lx ly b">MyTextInput</code>。先前的<code class="fe lv lw lx ly b">React.useRef</code>示例修改如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="acac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们单击“复制”按钮，发现了一些问题:</p><ul class=""><li id="40d3" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">输入字段内容不会突出显示。</li><li id="ad73" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">文本不会复制到剪贴板。</li><li id="7e7f" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">开发人员控制台出现错误:<code class="fe lv lw lx ly b">textInput.current.select is not a function.</code></li><li id="6cb1" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">第12行输出<code class="fe lv lw lx ly b">initialRef</code>，而不是<code class="fe lv lw lx ly b">MyTextInput</code>。</li></ul><p id="8d47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些问题是由于React没有给<code class="fe lv lw lx ly b">current</code>分配非DOM元素造成的。<code class="fe lv lw lx ly b">ref</code>不应该为<code class="fe lv lw lx ly b">MyTextInput</code>设置，而是应该为第三行的输入元素设置。要解决这个问题，我们需要一个转发<code class="fe lv lw lx ly b">ref</code>。</p><p id="3136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React团队是这样定义的:<code class="fe lv lw lx ly b">Ref</code>转发是一种自动将<code class="fe lv lw lx ly b">ref</code>通过一个组件传递给它的一个子组件的技术。</p><p id="9e93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当<code class="fe lv lw lx ly b">MyTextInput</code>得到一个<code class="fe lv lw lx ly b">ref</code>时，它需要调用<code class="fe lv lw lx ly b">React.forwardRef</code>(第一行)将<code class="fe lv lw lx ly b">ref</code>传递给它的子节点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="09b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二行输出<code class="fe lv lw lx ly b">MyTextInput</code>的<code class="fe lv lw lx ly b">props</code>值，不包括<code class="fe lv lw lx ly b">ref</code>:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="71f5" class="oa mw it ly b gy ob oc l od oe">Object {<br/>  readOnly: true,<br/>  type: "text",<br/>  value: "highlight and copy me"<br/>}</span></pre><p id="ea5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三行输出<code class="fe lv lw lx ly b">ref</code>的初始值，其中<code class="fe lv lw lx ly b">current</code>为<code class="fe lv lw lx ly b">null</code>:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="8b45" class="oa mw it ly b gy ob oc l od oe">Object {<br/>  current: null<br/>}</span></pre><p id="793d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第14行输出分配的<code class="fe lv lw lx ly b">textInput.current</code>:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="5e8a" class="oa mw it ly b gy ob oc l od oe">&lt;input type='text' readonly='' value='highlight and copy me'&gt;</span></pre><p id="f75a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在转发引用的帮助下，我们的示例使用库组件<code class="fe lv lw lx ly b">MyTextInput</code>。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="c435" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated"><code class="fe lv lw lx ly b">React.useImperativeHandle</code></h1><p id="0aa7" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><code class="fe lv lw lx ly b">React.useImperativeHandle</code>甚至没有用<code class="fe lv lw lx ly b">someRef</code>命名，但它仍然是ref家族的一部分。</p><ul class=""><li id="87f8" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">React团队是这样定义的，“<code class="fe lv lw lx ly b">useImperativeHandle</code>定制使用<code class="fe lv lw lx ly b">ref</code>时暴露给父组件的实例值。”</li><li id="d46b" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">他们又一次说，“像往常一样，在大多数情况下应该避免使用引用的命令式代码。”</li></ul><p id="a53b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看这个<code class="fe lv lw lx ly b">ref</code>特性。</p><p id="225f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">React.useImperativeHandle(ref, createHandle, [deps])</code>用在<code class="fe lv lw lx ly b">forwardRef</code>里面。它提供对<code class="fe lv lw lx ly b">ref</code>的精细控制:</p><ul class=""><li id="9bb3" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">公开有限的DOM方法(如select、focus、click等。)给呼叫者。</li><li id="bb8d" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">重写现有的DOM方法。</li><li id="3f44" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">向调用方提供常规方法</li></ul><p id="eacf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe lv lw lx ly b">React.useImperativeHandle</code>实现的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="394d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">React.useImperativeHandle</code>的代码是从第4行到第12行。它有两种方法，<code class="fe lv lw lx ly b">select</code>和<code class="fe lv lw lx ly b">log</code>。<code class="fe lv lw lx ly b">select</code>是输入元素的DOM方法。它被选择重写并向调用者公开。<code class="fe lv lw lx ly b">log</code>是正常的方法。它在开发人员控制台上打印出消息:<code class="fe lv lw lx ly b">log is invoked inside MyTextInput.</code></p><p id="7d00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从第24行的输出中，我们可以看到当前对象不再是输入元素。相反，它是一个包含可用方法的对象:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="a1f3" class="oa mw it ly b gy ob oc l od oe">Object {<br/>  log: () =&gt; {<br/>    console.log('log is invoked inside MyTextInput');<br/>  },<br/>  select: () =&gt; {<br/>    childRef.current.select();<br/>    console.log('Special select is called');<br/>  }<br/>}</span></pre><p id="9823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第25行，<code class="fe lv lw lx ly b">textInput.current.log()</code>调用log方法。在第26行，<code class="fe lv lw lx ly b">textInput.current.select()</code>调用定制的select方法。让我们从第5行到第8行注释掉。单击复制按钮不会使输入字段内容高亮显示，并且文本不再被复制到剪贴板。这是因为select方法不再公开。</p><p id="b9aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，对于一个真正的React项目，你可能不需要<code class="fe lv lw lx ly b">useImperativeHandle</code>。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="c2b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们解释了<code class="fe lv lw lx ly b">ref</code> s、<code class="fe lv lw lx ly b">callback ref</code> s、<code class="fe lv lw lx ly b">forwarding ref</code> s和<code class="fe lv lw lx ly b">imperativeHandle</code>s。React是一种不断发展的语言。新事物的出现为开发者提供了更多的动力。</p><p id="266c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保持饥饿。保持愚蠢。让我们等待未来的<code class="fe lv lw lx ly b">whatever ref</code>吧！</p><p id="97c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。如果你有任何问题，请随时回复。你可以在这里看到我的其他媒体出版物<a class="ae ky" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p></div></div>    
</body>
</html>