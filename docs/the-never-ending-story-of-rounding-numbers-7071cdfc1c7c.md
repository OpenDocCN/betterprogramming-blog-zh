# 舍入数字的永无止境的故事

> 原文：<https://betterprogramming.pub/the-never-ending-story-of-rounding-numbers-7071cdfc1c7c>

## 这就是为什么在 JavaScript 中舍入数字仍然是一个问题

![](img/a5a280fe44343a762fd6da1b3bb84e7e.png)

尼克·希利尔在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片。

现在是 2020 年(或者可能是`2020.0000000000000004`)，舍入数字仍然是 JavaScript 中的一个问题。其实一般来说是计算方面的问题。

这里有一个关于如何使用 JavaScript 正确完成这项工作的权威指南。通读一遍，永远记住！

# 介绍

首先，我们来理解一下为什么浮点数一直是，现在是，将来也会继续是计算中的一个问题。

每个数字都是一个字节序列。例如，十进制数`3`是二进制数`00000011`。这基本上是计算机如何用字节来表示每个数字的(即一个字节是 8 位:`0`或`1`)。如果我们取八个字节，`00000000`相当于十进制的`0`。`11111111`相当于`255`。每个字节都有一个权重。从左边开始，依次为`128`、`64`、`32`、`16`、`8`、`4`、`2`、`1`。将这些加在一起后，我们得到`255`。因此，要从二进制转换到十进制，我们查看每个字节，将每个字节乘以其权重，然后求和:

```
00000011 = 0*128 + 0*64 + 0*32 + 0*16 + 0*8 + 0*4 + 1*2 + 1*1 = 3
10101010 = 1*128 + 0*64 + 1*32 + 0*16 + 1*8 + 0*4 + 1*2 + 1*0 = 170
11111111 = 1*128 + 1*64 + 1*32 + 1*16 + 1*8 + 1*4 + 1*2 + 1*1 = 255
```

这对整数来说非常有效。浮点数的问题是，我们不能把字节分成无限小的数，每个浮点数的表示都有一些限制。

# 二进制分数

为了将十进制(分数)部分转换成二进制，我们也可以用权重来表示分数部分！然而，这次我们将向下(即最高有效位的值为`0.5`，下一位为`0.25`、`0.125`、`0.0625`，以此类推):

```
0.10000000 = 0.5
0.01000000 = 0.25
0.00100000 = 0.125
0.00010000 = 0.0625
0.00001000 = 0.03125
0.00000100 = 0.015625
0.00000010 = 0.0078125
0.00000001 = 0.00390625
...
0.11111111 = 0.99609375
```

# 为什么是 0.2 + 0.1！== 0.3

这是一个常见的 JavaScript 面试问题:为什么添加`0.1`和`0.2`不等于`0.3`？简单的答案是，计算机不是用十进制数计算，而是用二进制数计算。因此:

```
const a = 0.1;
const b = 0.2;
const c = a + b; // equals to: 0.30000000000000004
```

我们，人类，会期望这个等于`0.3`。

然而，`0.1`的二进制计算机表示是`0.0001100110011001101`。转换回十进制，得出`0.1000003814697265625`。足够接近`0.1`，但不完全是`0.1`！

# 数学.圆

`Math.round()`函数将数字四舍五入为最接近的整数。因此，这对我们的情况不好，因为它将为`0.3`返回`0`:

```
const d = Math.round(c); // returns: 0
```

# 简单但不正确的方法

如果我们开始在互联网上搜索解决方案，我们可能会找到一个类似于以下解决方案的最佳结果:

```
const result = Math.round(value * 100)/100;
```

如果我们用等于`c = 0.30000000000000004`的`value`来检查它，那么它可能看起来是有效的，因为结果将是`0.3`。然而，使用下一个值`1.005`进行快速测试将会错误地产生`1`，而不是预期的`1.01`:

```
const value = 1.005;
Math.round(value * 100)/100; // returns: 1
```

在我们继续深入之前，让我们停下来注意一下，我们不自觉地多了一个要求:我们四舍五入到小数点后两位，或者更科学一点，我们没有讨论精度。

# 埃普西隆

在 MDN 网络文档上，我们可以找到关于[艾司隆](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON)的信息:

> "`**Number.EPSILON**`属性表示 1 和大于 1 的最小浮点数之间的差。"

但是这到底意味着什么，它如何帮助我们舍入呢？首先，我们可以用 Epsilon 更新上面的代码:

```
const value = 1.005;
Math.round((value + Number.EPSILON) * 100) / 100; // returns: 1.01
```

看起来很对，不是吗？

然而，在进入下一个解决方案之前，让我们引用[这个堆栈溢出答案](https://stackoverflow.com/a/56967003/3013633)来添加一个简短的注释，说明 Epsilon 的用途:

> "这只是超级电脑迷可能会在计算中用到的东西."

换句话说，不要用！有关更多详细信息，请查看引用的 SO 问题。

此外，我们可以通过此测试案例证明此解决方案失败:

```
const value = 1.1049999999999998;
Math.round((value + Number.EPSILON) * 100) / 100; // returns: 1.11
```

预期结果是:`1.10`。

# Number.toFixed()

继续，`[Number.toFixed()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)`是另一个流行的[解决方案](https://stackoverflow.com/a/15762794/3013633)。这是一个带一个可选参数的方法:`digits` —小数点后出现的位数。方法返回数字的字符串表示形式，如有必要，将对其进行舍入:

```
0.1.toFixed(2);                // returns: "0.10"
0.2.toFixed(2);                // returns: "0.20"
1.005.toFixed(3);              // returns: "1.005"
1.1049999999999998.toFixed(2); // returns: "1.10"
```

然而:

```
1.005.toFixed(2); // returns: "1.00" instead of expected: "1.01"
```

# 使用外部库

在这个阶段，我们已经尝试了许多流行的舍入方法，但都失败了。

然而，我们可以重用其他开发人员编写的代码，而不是重新发明轮子。例如， [Lodash](https://lodash.com/) 是一个流行的实用程序库，它具有`[round()](https://lodash.com/docs/4.17.15#round)`功能:

# 结论

当在 JavaScript 或任何计算机编程语言中使用浮点数时，我们需要知道数字是如何表示的。

当我们在源代码中看到定制的舍入函数时，应该会立即在我们的头脑中拉响警报。有些解决方案可能行得通，但舍入一直是一个常见的问题。因此，我们应该在数学函数的支持下使用完善的库。

请在下面的评论中让我知道你最喜欢或使用哪种解决方案。你遇到过四舍五入的问题吗？