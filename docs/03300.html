<html>
<head>
<title>Build a Simple To-Do List App in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Golang中构建一个简单的待办事项列表应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-simple-todolist-app-in-golang-82297ec25c7d?source=collection_archive---------0-----------------------#2020-02-03">https://betterprogramming.pub/build-a-simple-todolist-app-in-golang-82297ec25c7d?source=collection_archive---------0-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bcd4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解一门新语言的最有教育意义的方法之一</h2></div><p id="1c94" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇博客最初发表在<a class="ae le" href="https://fadhil-blog.dev/blog/golang-todolist/" rel="noopener ugc nofollow" target="_blank">我的个人博客</a>上。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/e39cf44b5083c9bbdd23c350e384ea14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b9mwmwne9f5nZqwitDOH8w.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">由<a class="ae le" href="https://pixabay.com/users/mohamed_hassan-5229782/" rel="noopener ugc nofollow" target="_blank">穆罕默德·哈桑</a>在<a class="ae le" href="https://pixabay.com/illustrations/to-do-list-business-checklist-form-4483048/" rel="noopener ugc nofollow" target="_blank">皮克斯贝</a>上插画</p></figure><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="705a" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">为什么是Golang？</h1><p id="00ce" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">我很久以前就想学戈兰语了。根据堆栈溢出调查，Golang是2019年第三大最受欢迎的编程语言。作为Python背景的人，学习Golang这样的新编程语言让我对如何编写代码有了一个独特的视角。</p><p id="f3bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">凯兰·斯考特的一篇很有帮助的教程给了我灵感。下面的教程受Keiran教程的影响很大，但作为我学习Golang的一部分，它使用了MySQL而不是Mongo。</p><p id="4c29" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我个人认为Golang是新的Java。许多开源项目(如Jaeger、Kubernetes、Docker、InfluxDB、Serf等。)现在都是用戈兰语写的。相比之下，较老的项目(如Apache Kafka、Apache Hadoop等。)都是用Java写的。我希望将来能参与并为OSS Golang项目做出贡献。</p><p id="58e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与其他语言相比，Golang有许多优势，包括:</p><ul class=""><li id="26e5" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld mz na nb nc bi translated"><strong class="kk iu"> Golang是炽快的</strong> <br/> <a class="ae le" href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go.html" rel="noopener ugc nofollow" target="_blank">自己看</a>。</li><li id="93ac" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated"><strong class="kk iu"> Golang是为并发性而构建的</strong> <br/> Golang附带了goroutines，就是为了解决这个问题而设计的。当我第一次了解Golang时，我就被这个特性迷住了。不幸的是，在本教程中我们还看不到goroutines是如何工作的。</li><li id="68a9" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated"><strong class="kk iu"> Golang是一种静态类型语言<br/> </strong>来自Python背景，一开始我觉得Golang的这个特性有点气人。然而，用静态类型的编程语言编写意味着你会引入更少的错误，因为你在解释和传递数据时会犯更少的错误。</li><li id="0378" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated"><strong class="kk iu"> Go将程序编译成一个二进制文件<br/> </strong>当你在Go中构建应用程序时，你可以随时随地运行你的应用程序。您不必担心它的依赖性，因为它们都是捆绑在一起的。</li><li id="92e7" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">Golang是一种固执己见的语言。这意味着人们应该如何用Golang编写代码的变化更少，这最终意味着代码的一致性、可读性和可维护性。对于一个大而复杂的项目，这是非常有帮助的。</li><li id="9009" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">你可以在这里阅读更多关于它的优点。</li></ul><h2 id="b05f" class="ni ly it bd lz nj nk dn md nl nm dp mh kr nn no mj kv np nq ml kz nr ns mn nt bi translated">先决条件</h2><ul class=""><li id="ece6" class="mu mv it kk b kl mp ko mq kr nu kv nv kz nw ld mz na nb nc bi translated">系统上安装的<a class="ae le" href="https://golang.org/doc/install" rel="noopener ugc nofollow" target="_blank"> Golang </a>和<a class="ae le" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank"> Docker </a></li><li id="1a59" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">Golang和JQuery的基础知识</li></ul><p id="74e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我为这个app准备了一个前端部分，你不用担心这个，可以专注于写Golang代码。您需要做的就是在步骤7中克隆存储库。</p><h2 id="77b1" class="ni ly it bd lz nj nk dn md nl nm dp mh kr nn no mj kv np nq ml kz nr ns mn nt bi translated">我们将建造什么</h2><p id="8737" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">我们将构建一个连接到前端页面的经典而简单的Golang API服务器。我们的Golang API服务器将使用:</p><ul class=""><li id="51a1" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld mz na nb nc bi translated">MySQL作为我们的数据库</li><li id="b987" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">GORM作为一个ORM与我们的数据库进行交互</li><li id="6f09" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">使用<code class="fe nx ny nz oa b">gorilla/mux</code>请求路由器</li><li id="1e5d" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">用于测井的测井曲线</li></ul><h2 id="d6b1" class="ni ly it bd lz nj nk dn md nl nm dp mh kr nn no mj kv np nq ml kz nr ns mn nt bi translated">我们的整个应用程序将如何工作</h2><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ob"><img src="../Images/b9d0da441c08ddfd4f7eaf8715fbc46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WWen5Jd5Lf_cH6JNa-22HA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">我们的应用程序将如何工作的图表</p></figure><p id="aed5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将构建图表右侧的内容。我们的API服务器的规格如下:</p><ul class=""><li id="35de" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld mz na nb nc bi translated">它监听<code class="fe nx ny nz oa b">localhost</code>上的端口8000</li><li id="0479" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">它有五个端点:<code class="fe nx ny nz oa b">healthz</code>、<code class="fe nx ny nz oa b">createItem</code>、<code class="fe nx ny nz oa b">getCompletedItems</code>、<code class="fe nx ny nz oa b">getIncompleteItems</code>、<code class="fe nx ny nz oa b">updateItem</code>和<code class="fe nx ny nz oa b">deleteItem</code></li><li id="59e0" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated"><code class="fe nx ny nz oa b">TodoItem</code>模型由<code class="fe nx ny nz oa b">Id</code>、<code class="fe nx ny nz oa b">Description</code>和<code class="fe nx ny nz oa b">Completed</code>状态属性组成</li></ul><p id="0ea0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我准备的web前端将对所有操作执行对<code class="fe nx ny nz oa b">localhost:8000</code>的AJAX请求。首先检查这个JS脚本，看看它是如何工作的。最初的代码是由<a class="ae le" href="https://github.com/themaxsandelin" rel="noopener ugc nofollow" target="_blank"> themaxsandelin </a>制作的。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="c0c0" class="lx ly it bd lz ma oj mc md me ok mg mh jz ol ka mj kc om kd ml kf on kg mn mo bi translated">我们开始吧</h1><h2 id="d7df" class="ni ly it bd lz nj nk dn md nl nm dp mh kr nn no mj kv np nq ml kz nr ns mn nt bi translated">1.启动一个项目</h2><p id="c9c4" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">首先，让我们创建一个新目录，并在该目录中安装<code class="fe nx ny nz oa b">gorilla/mux</code>和<code class="fe nx ny nz oa b">logrus</code>包。</p><pre class="lg lh li lj gt oo oa op oq aw or bi"><span id="3f0f" class="ni ly it oa b gy os ot l ou ov">$ mkdir todolist-mysql-go<br/>$ cd todolist-mysql-go<br/>$ go get -u github.com/gorilla/mux<br/>$ go get -u github.com/sirupsen/logrus</span></pre><p id="d06d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在用以下内容创建一个<code class="fe nx ny nz oa b">todolist.go</code>文件:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ow lw l"/></div></figure><p id="b411" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第3-8行，我们导入了在前面的<code class="fe nx ny nz oa b">go get -u</code>命令中得到的所有必需的包。请注意，在不实际使用Go代码的情况下导入任何包，都会导致编译错误。</p><p id="3da5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第10-14行，我们创建了一个<code class="fe nx ny nz oa b">Healthz</code>函数，它将在每次被调用时响应客户端的<code class="fe nx ny nz oa b">{"alive": true}</code>。</p><p id="e129" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第16-19行，我们设置我们的init函数来设置我们的<code class="fe nx ny nz oa b">logrus</code>记录器设置。在Golang中，<code class="fe nx ny nz oa b">init()</code>将在程序第一次开始时执行。你可以在这里阅读更多<a class="ae le" href="https://tutorialedge.net/golang/the-go-init-function/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="a8c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第21-26行，我们用一个walrus操作符初始化我们的<code class="fe nx ny nz oa b">gorilla/mux</code> HTTP路由器。我们将<code class="fe nx ny nz oa b">/healthz</code> HTTP GET请求路由到<code class="fe nx ny nz oa b">Health()</code>函数。路由器将监听端口8000。</p><p id="4f23" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">设置<code class="fe nx ny nz oa b">Content-Type: application/json</code>很重要，这样客户端软件就能理解响应。</p><p id="4d60" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很简单，对吧？让我们看看目前为止都有什么。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ox"><img src="../Images/5e5d3e2455912271eaf0dacc4c69e157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gQWr_-dqW3zeiaLGhnjSqw.gif"/></div></div></figure><p id="532e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了！我们的第一个端点现已上线。</p><h2 id="d8e3" class="ni ly it bd lz nj nk dn md nl nm dp mh kr nn no mj kv np nq ml kz nr ns mn nt bi translated">2.连接到MySQL数据库</h2><p id="c237" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">在将我们的Go应用程序连接到MySQL数据库之前，首先我们需要启动MySQL服务器。在本例中，我们将使用Docker来启动一个MySQL容器，并将端口3306暴露给<code class="fe nx ny nz oa b">localhost</code>。我们将在MySQL容器中创建一个<code class="fe nx ny nz oa b">todolist</code>数据库。</p><pre class="lg lh li lj gt oo oa op oq aw or bi"><span id="b137" class="ni ly it oa b gy os ot l ou ov">$ docker run -d -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=root mysql<br/>$ docker exec -it mysql mysql -uroot -proot -e 'CREATE DATABASE todolist'</span></pre><p id="3901" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回到我们的Go应用程序，我们需要安装GORM库和方言。</p><pre class="lg lh li lj gt oo oa op oq aw or bi"><span id="36a0" class="ni ly it oa b gy os ot l ou ov">$ go get -u github.com/jinzhu/gorm<br/>$ go get -u github.com/go-sql-driver/mysql<br/>$ go get -u github.com/jinzhu/gorm/dialects/mysql</span></pre><p id="3319" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的<code class="fe nx ny nz oa b">todolist.go</code>代码中添加这些行:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ow lw l"/></div></figure><p id="658b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将我们的新导入添加到第8-10行的导入列表中。在Golang中，如果你不打算使用这个变量，你必须把它命名为<code class="fe nx ny nz oa b">_</code>。你可以在这里阅读更多<a class="ae le" href="https://www.geeksforgeeks.org/what-is-blank-identifierunderscore-in-golang/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="f6f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们将使用GORM初始化MySQL到数据库的连接。下面几行用于检查连接到数据库时是否有错误。如果有，记录下来。</p><p id="2084" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nx ny nz oa b">defer db.Close()</code>意味着当<code class="fe nx ny nz oa b">main()</code>函数返回时，我们将关闭数据库连接。</p><h2 id="d5ba" class="ni ly it bd lz nj nk dn md nl nm dp mh kr nn no mj kv np nq ml kz nr ns mn nt bi translated">3.自动迁移TodoItem ORM模型</h2><p id="38bf" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">GORM附带了一个简洁的数据库自动迁移特性，它将根据代码中的结构定义创建一个数据库表。</p><p id="22dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的<code class="fe nx ny nz oa b">TodoItem</code>结构将包括:</p><ul class=""><li id="bccb" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld mz na nb nc bi translated"><code class="fe nx ny nz oa b">Id int</code>:这将是我们的<code class="fe nx ny nz oa b">primary_key</code></li><li id="dede" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated"><code class="fe nx ny nz oa b">Description string</code>:这是我们将在前端UI中显示的内容</li><li id="7df0" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated"><code class="fe nx ny nz oa b">Completed bool</code>:确定<code class="fe nx ny nz oa b">TodoItem</code>是否完成</li></ul><p id="a72c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将这些行添加到您的Go代码中:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ow lw l"/></div></figure><p id="92a2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第7-11行，我们定义了前面描述的<code class="fe nx ny nz oa b">TodoItem</code>模型。这里的一切都是不言自明的。</p><p id="4913" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第19-20行，我们在启动API服务器后，立即对MySQL数据库运行自动迁移。请点击此处查看它的实际应用:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ox"><img src="../Images/47f78fea1f404c8ead7a42a7ef1a2342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hqEWI3MCagcX1ghgMfh5iQ.gif"/></div></div></figure><p id="5a92" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">耶，我们的数据库准备好了。</p><h2 id="6eed" class="ni ly it bd lz nj nk dn md nl nm dp mh kr nn no mj kv np nq ml kz nr ns mn nt bi translated">4.创建TodoItem操作</h2><p id="f3e7" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">在我们的<code class="fe nx ny nz oa b">todolist.go</code>文件中添加以下几行:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ow lw l"/></div></figure><p id="d8c5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第16行，我们用<code class="fe nx ny nz oa b">r.FormValue("parameter")</code>从POST操作中获得值。我们使用该值作为描述插入到我们的数据库中。之后，我们创建了<code class="fe nx ny nz oa b">todo</code>对象并将其保存在数据库中。最后，我们查询数据库并将查询结果返回给客户端，以确保操作成功。</p><p id="6966" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第32行，我们用一个HTTP POST请求将新路由<code class="fe nx ny nz oa b">/todo</code>注册到新的<code class="fe nx ny nz oa b">CreateItem()</code>函数中。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ox"><img src="../Images/99269cfc2e0e6b0b44033342313b04ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*e_YvTQGCB1FPI895p3wlJQ.gif"/></div></div></figure><h2 id="ccbc" class="ni ly it bd lz nj nk dn md nl nm dp mh kr nn no mj kv np nq ml kz nr ns mn nt bi translated">5.继续剩余的CRUD操作</h2><p id="adec" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">让我们继续其余的<code class="fe nx ny nz oa b">Read</code>、<code class="fe nx ny nz oa b">Update</code>和<code class="fe nx ny nz oa b">Delete</code>操作。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ow lw l"/></div></figure><p id="76a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该能够在<code class="fe nx ny nz oa b">TodoItem</code>上执行<code class="fe nx ny nz oa b">Create</code>、<code class="fe nx ny nz oa b">Read</code>、<code class="fe nx ny nz oa b">Update</code>和<code class="fe nx ny nz oa b">Delete</code>操作。</p><p id="504f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了更新一个<code class="fe nx ny nz oa b">TodoItem</code>对象，我们将首先查询我们的数据库以确保该项确实存在。为此，我创建了一个函数<code class="fe nx ny nz oa b">GetItemById()</code>。等效的SQL查询是<code class="fe nx ny nz oa b">SELECT * FROM todo_item_models WHERE Id = &lt;Id&gt; LIMIT 1;</code>。</p><p id="4b98" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在实际更新或删除之前，<code class="fe nx ny nz oa b">UpdateItem()</code>和<code class="fe nx ny nz oa b">DeleteItem()</code>功能将首先调用<code class="fe nx ny nz oa b">GetItemById()</code>。</p><p id="09fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意我在那里导入了<code class="fe nx ny nz oa b">strconv</code>包。在我们运行SQL查询之前，这个包用于将<code class="fe nx ny nz oa b">String</code>变量转换成<code class="fe nx ny nz oa b">Integer</code>。</p><p id="6bce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nx ny nz oa b">GetCompletedItems()</code>和<code class="fe nx ny nz oa b">GetIncompletedItems()</code>功能也是不言自明的。它将执行一个SQL SELECT查询，并在将其返回给客户机之前将其编码成JSON。</p><h2 id="6ffd" class="ni ly it bd lz nj nk dn md nl nm dp mh kr nn no mj kv np nq ml kz nr ns mn nt bi translated">6.与前端连接</h2><p id="2153" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">为了将API服务器连接到前端页面，我们需要为响应提供CORS头。CORS是一种机制，允许从提供第一资源的域之外的另一个域请求网页上的受限资源。</p><p id="7053" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，您需要安装Go <code class="fe nx ny nz oa b">cors</code>包。</p><pre class="lg lh li lj gt oo oa op oq aw or bi"><span id="5a4d" class="ni ly it oa b gy os ot l ou ov">$ go get -u github.com/rs/cors</span></pre><p id="d932" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将这些行添加到您的Go代码中:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ow lw l"/></div></figure><p id="3426" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第28-32行，我们将CORS处理程序包装在我们现有的应用程序中。</p><p id="2ef3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在克隆我的这个围棋应用程序的前端网站。</p><pre class="lg lh li lj gt oo oa op oq aw or bi"><span id="bb31" class="ni ly it oa b gy os ot l ou ov">$ git clone <a class="ae le" href="https://github.com/sdil/todo.git" rel="noopener ugc nofollow" target="_blank">https://github.com/sdil/todo.git</a></span></pre><p id="6c05" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，在浏览器中打开<code class="fe nx ny nz oa b">index.html</code>页面。这个简单的jQuery页面没有什么特别之处。我修改了由<a class="ae le" href="https://github.com/themaxsandelin/" rel="noopener ugc nofollow" target="_blank">themassandelin</a>编写的原始代码，以便在你点击页面中的按钮时执行AJAX请求。检查<code class="fe nx ny nz oa b">resources/js/main.js</code>文件，看看web前端是如何工作的。</p><h2 id="e992" class="ni ly it bd lz nj nk dn md nl nm dp mh kr nn no mj kv np nq ml kz nr ns mn nt bi translated">7.构建包</h2><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oy"><img src="../Images/55927216c76347a3cf1a82e99151d3bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s1r_sDuTJWuQDN8V"/></div></div></figure><p id="4ee0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们完成了编码。现在可以编译代码了。</p><pre class="lg lh li lj gt oo oa op oq aw or bi"><span id="e681" class="ni ly it oa b gy os ot l ou ov">$ go build<br/>$ ./todolist-mysql-go</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="c98b" class="lx ly it bd lz ma oj mc md me ok mg mh jz ol ka mj kc om kd ml kf on kg mn mo bi translated">一个小的端到端演示</h1><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oz"><img src="../Images/e684a772066f69fe501aed870468212b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LIur3Zccdy1ESmEltZjDOQ.gif"/></div></div></figure><p id="d097" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">恭喜你，你已经在Golang为自己建立了一个待办事项列表！</p><p id="e6cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在我的GitHub资源库中找到完整的源代码。如果你在本教程的任何一点上停滞不前，请随意参考那里。</p><div class="pa pb gp gr pc pd"><a href="https://github.com/sdil/learning/blob/master/go/todolist-mysql-go/todolist.go" rel="noopener  ugc nofollow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">sdil/学习</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">我的学习项目汇编。在GitHub上创建一个帐户，为sdil/learning开发做贡献。</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">github.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr lp pd"/></div></div></a></div></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="25f2" class="lx ly it bd lz ma oj mc md me ok mg mh jz ol ka mj kc om kd ml kf on kg mn mo bi translated">不要停止学习</h1><p id="9df4" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">事实上，这只是Golang的一小部分。</p><p id="568c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来在Golang你可以探索更多的东西。你会有更多的理由去爱Golang。我希望这篇教程能激发你去探索更多。</p></div></div>    
</body>
</html>