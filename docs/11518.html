<html>
<head>
<title>Flutter Unit Testing — The Beginner’s Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振单元试验——初学者指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/flutter-unit-testing-the-beginners-guide-35105164722e?source=collection_archive---------0-----------------------#2022-03-28">https://betterprogramming.pub/flutter-unit-testing-the-beginners-guide-35105164722e?source=collection_archive---------0-----------------------#2022-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e93c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">单元测试是自动化测试过程的一部分，在这个过程中测试小的代码单元</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/15f0ec168de0ff2108416119b6f2cd1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oTFKOYXlcFWo0wbhzEFsWQ.png"/></div></div></figure><p id="37b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大家好。在这篇文章中，我们将学习所有关于单元测试的知识。</p><h2 id="99e1" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">议程</h2><ul class=""><li id="6f90" class="mg mh iq kt b ku mi kx mj la mk le ml li mm lm mn mo mp mq bi translated">什么是自动化测试？</li><li id="c409" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated"><a class="ae mr" href="#22c2" rel="noopener ugc nofollow">什么是单元测试？</a></li><li id="859c" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated"><a class="ae mr" href="#5d26" rel="noopener ugc nofollow">我们为什么需要测试？</a></li><li id="293a" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">我们可以在一个单元中测试什么？</li><li id="6f7d" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated"><a class="ae mr" href="#e992" rel="noopener ugc nofollow">如何在Dart中做单元测试？</a></li><li id="d613" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated"><a class="ae mr" href="#5879" rel="noopener ugc nofollow">良好的单元测试实践</a></li><li id="f37c" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated"><a class="ae mr" href="#e0a5" rel="noopener ugc nofollow">嘲讽</a></li><li id="4c0b" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated"><a class="ae mr" href="#a1e6" rel="noopener ugc nofollow">不同的嘲讽方式</a></li><li id="0c00" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated"><a class="ae mr" href="#61f7" rel="noopener ugc nofollow">莫奇托</a></li><li id="c74c" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated"><a class="ae mr" href="#8c58" rel="noopener ugc nofollow">模仿秀</a></li></ul><h1 id="55ba" class="mx lo iq bd lp my mz na ls nb nc nd lv jw ne jx ly jz nf ka mb kc ng kd me nh bi translated">什么是自动化测试？</h1><p id="3051" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">软件自动化测试是评估和验证软件产品或应用程序是否达到预期目的的过程。防止了bug，降低了开发成本。</p><p id="fd4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们需要明白一些事情。自动化测试只是防止软件出现预期错误的一种方式。这并不意味着软件没有任何缺陷。这只是意味着软件没有任何预期的错误。</p><blockquote class="nl nm nn"><p id="ffc0" class="kr ks no kt b ku kv jr kw kx ky ju kz np lb lc ld nq lf lg lh nr lj lk ll lm ij bi translated">"测试显示了缺陷的存在，而不是不存在."埃德格·迪克斯特拉</p></blockquote><p id="23da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">循环总是如下进行:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/a6d01e31887ecf493c5276a2b8affc4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*LQQFptO0cmT-SA7Y_HIgdw.png"/></div></figure><p id="ac37" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们所看到的，在开发阶段之后，我们编写预期的测试用例(TDD是个例外)。一旦它通过了所有的测试用例，我们通常会发布软件。当软件处于生产阶段时，如果出现任何错误，我们会修复它并编写测试用例，以防止软件在未来出现同样的错误。</p><p id="75a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">测试只是验证的行为。在开发一个新的特性或者修复一个现存的错误时，测试用例帮助我们验证是否所有现存的特性和单元都如预期的那样工作。它确保当前的开发不会破坏任何现有的特性。</p><h1 id="22c2" class="mx lo iq bd lp my mz na ls nb nc nd lv jw ne jx ly jz nf ka mb kc ng kd me nh bi translated">什么是单元测试？</h1><p id="86b0" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">单元测试是自动化测试过程的一部分，在这个过程中，小的代码单元通过几个用例来测试它们的可靠性。一个单元可以是一个函数、方法、类、状态，或者仅仅是一个变量。</p><p id="60f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">单元测试是测试套件的最底层。在这一层，我们测试每个特性的内部工作。</p><p id="a2a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">单元测试有三个阶段:</p><ul class=""><li id="152f" class="mg mh iq kt b ku kv kx ky la nt le nu li nv lm mn mo mp mq bi translated">安排</li><li id="89a4" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">行动</li><li id="6baa" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">维护</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/65a9573948a0ba0264817e764e3b3a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*fP4Eby_XQcAsYyloEyWG0A.png"/></div></figure><p id="b1af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在安排阶段，我们只需要创建我们需要测试的单元的对象，并为我们的测试准备先决条件，即，设置状态变量，设置模拟，等等。根据需要，安排阶段可能存在，也可能不存在。</p><p id="721c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Act阶段，我们用一些状态(传递参数)运行单元，并存储结果(如果有的话)。</p><p id="5cba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在断言阶段，我们验证单元的行为是否符合预期。我们可能希望调用一个方法，或者结果与预期的结果相同。</p><p id="a762" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="no">安排和行动阶段不是强制性的。</em></p><h2 id="5d26" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">为什么我们需要单元测试？</h2><ul class=""><li id="03fa" class="mg mh iq kt b ku mi kx mj la mk le ml li mm lm mn mo mp mq bi translated">单元测试非常容易编写和运行。从而节省了大量的时间。</li><li id="a029" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">单元测试帮助我们在早期识别错误。从而节省了大量的时间和金钱。</li><li id="ccaf" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">由于我们编写了该单元的所有预期案例，任何人都可以理解该单元是关于什么的。从而作为更好的文档。</li><li id="82f7" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">通常我们不会通过思考来重构代码，这样做可能会破坏单元。进行单元测试给了我们重构代码的信心。</li><li id="52ea" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">调试很简单。因为我们确切地知道失败的案例，我们可以精确地定位导致bug的单元。</li><li id="1fe0" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">通过查看测试用例，我们可以很容易理解这个单元是关于什么的。因此长期维护更容易。</li></ul><h2 id="bab2" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">我们可以在一个单元中测试什么？</h2><p id="c3a6" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">为了有一个好的单元测试套件，我们需要了解我们需要在一个单元中测试什么。</p><p id="86e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常，单元测试基于以下几个方面:</p><ul class=""><li id="2804" class="mg mh iq kt b ku kv kx ky la nt le nu li nv lm mn mo mp mq bi translated">状态变量</li><li id="c69f" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">函数/变量调用</li><li id="f611" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">函数参数</li><li id="e8f3" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">函数返回</li></ul><p id="ea21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="no">状态变量是局部范围之外的变量。它可能是一个全局变量，也可能是一个可以被多个单元访问的类属性。通常，它包含一个状态。</em></p><p id="9646" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是我们需要在单元中寻找的一些案例:</p><ul class=""><li id="9c5e" class="mg mh iq kt b ku kv kx ky la nt le nu li nv lm mn mo mp mq bi translated">验证常量或最终变量的值。</li><li id="6dac" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">状态变量的初始值。</li><li id="5591" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">验证单元是否调用某个函数1…n次。</li><li id="812b" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">验证该单元是否从不调用某个函数。</li><li id="e90a" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">确保状态变量按预期更新。</li><li id="debf" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">单元的结果和预期的一样。</li><li id="9a70" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">如果涉及到字符串、列表或任何其他复杂的DS，请确保检查空的案例，尤其是当我们遍历DS时。</li><li id="223c" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">检查空情况(仅适用于可空类型。Dart现在是空安全的)</li><li id="2e43" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">检查变量或参数的类型(如果我们很好地利用了Dart的类型系统，就不需要这样做)</li></ul><p id="4ff4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Dart的空安全和类型系统保存了所有场景中的大量测试用例。</p><h1 id="e992" class="mx lo iq bd lp my mz na ls nb nc nd lv jw ne jx ly jz nf ka mb kc ng kd me nh bi translated">如何在Dart中做单元测试？</h1><ul class=""><li id="fb79" class="mg mh iq kt b ku mi kx mj la mk le ml li mm lm mn mo mp mq bi translated">首先，我们需要在<code class="fe nx ny nz oa b">pubspec.yaml</code>文件中包含依赖关系。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><ul class=""><li id="c41f" class="mg mh iq kt b ku kv kx ky la nt le nu li nv lm mn mo mp mq bi translated">创建一个带有<code class="fe nx ny nz oa b">_test</code>后缀的dart测试文件。它有助于dart分析器将文件视为测试文件。</li></ul><p id="d208" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们要测试圆的面积。</p><pre class="kg kh ki kj gt od oa oe of aw og bi"><span id="5f34" class="ln lo iq oa b gy oh oi l oj ok">sample_project/<br/>  lib/<br/>    area.dart<br/>    main.dart<br/>  test/<br/>    area_test.dart</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="749b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是Dart测试文件。每个测试文件都应该有一个开始执行的<code class="fe nx ny nz oa b">main()</code>方法。</p><p id="bf43" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要将我们的测试用例包装在一个函数中，并将该函数作为一个参数传递给<code class="fe nx ny nz oa b">test()</code>方法，并附上对测试用例的适当描述。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="4edb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当半径为1时，该测试预计圆的面积为3.141592。这里的单位是<code class="fe nx ny nz oa b">circle()</code>法。</p><ul class=""><li id="d9f1" class="mg mh iq kt b ku kv kx ky la nt le nu li nv lm mn mo mp mq bi translated">在Arrange(setup)阶段，我们为<code class="fe nx ny nz oa b">Area</code>类创建了一个实例。</li><li id="333e" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">在Act(run)阶段，我们使用一些输入来运行我们想要测试的单元。</li><li id="1ec9" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">在断言(验证)阶段，我们将结果与预期结果进行了比较。</li></ul><p id="99f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里还有一个测试来验证getter <code class="fe nx ny nz oa b">pi</code>的值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="39a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们可以看到，安排和行动阶段并不存在。由于<code class="fe nx ny nz oa b">pi</code>是一个静态getter，我们不需要设置或运行任何东西。但是我们需要验证它，因此只有断言阶段。</p><h2 id="f2a4" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">对测试用例进行分组</h2><p id="83ac" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">通常，我们需要编写许多类似的测试用例。<code class="fe nx ny nz oa b">group()</code>方法帮助我们将相似的测试用例分组，以便于管理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="f28f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一切都很好，但是我们为每个测试创建了<code class="fe nx ny nz oa b">Area</code>实例。随着测试用例的增长，我们需要为每个测试用例重复同样的步骤。这不是一种好的做法。</p><p id="b0a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nx ny nz oa b">setUpApp()</code>方法在所有测试用例之前首先运行。利用这一点我们可以减少重复。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="efdc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们所看到的，我将声明和初始化移到了这个main方法的范围内。因此，它首先运行，然后运行所有的测试用例，也就是说，它对所有的测试用例使用相同的实例。如果对象不包含任何状态，就不会有问题。</p><p id="8e9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果对象拥有一个状态，那么拥有所有状态的公共实例可能会导致很多问题。因此，我们需要为每个测试用例创建单独的实例。</p><p id="3c5b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在许多测试用例中有一个共同的状态是一个不好的实践。</p><p id="f242" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="no">我们需要每个测试用例都有单独的状态。我们通常为每个测试注入初始状态。这是我们在安排阶段需要做的工作之一。</em></p><p id="0af5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nx ny nz oa b">setUp()</code>方法类似于<code class="fe nx ny nz oa b">setUpAll()</code>方法，但不同之处在于它每次都在当前范围内的测试用例之前运行。因此，每个测试用例都有自己的状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="7cda" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，<code class="fe nx ny nz oa b">setUp()</code>方法在每个测试用例之前运行。因此每个测试都有单独的实例。因此没有国家问题。</p><p id="a05c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="no">除非回调很慢，否则始终首选</em> <code class="fe nx ny nz oa b"><em class="no">setUp()</em></code> <em class="no">方法，而不是</em> <code class="fe nx ny nz oa b"><em class="no">setUpAll()</em></code> <em class="no">方法。</em></p><p id="b669" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在当前范围内的所有测试完成后，可以使用<code class="fe nx ny nz oa b">tearDownAll()</code>方法运行一些东西。类似地，<code class="fe nx ny nz oa b"> tearDown()</code>方法用于在每个测试用例之后运行一些东西。通常用于释放实例或取消订阅。</p><p id="9ce1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nx ny nz oa b"><em class="no">setUp()</em></code> <em class="no">、</em> <code class="fe nx ny nz oa b"><em class="no"> setUpAll()</em></code> <em class="no">、</em> <code class="fe nx ny nz oa b"><em class="no">tearDown()</em></code> <em class="no">、</em> <code class="fe nx ny nz oa b"><em class="no">tearDownAll()</em></code> <em class="no">可以在</em> <code class="fe nx ny nz oa b"><em class="no">group()</em></code> <em class="no">里面使用来限制范围。</em></p><h2 id="5879" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">良好的单元测试实践</h2><ul class=""><li id="055c" class="mg mh iq kt b ku mi kx mj la mk le ml li mm lm mn mo mp mq bi translated">单元测试应该很快</li><li id="bc27" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">单元测试应该简单</li><li id="2d61" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">单元测试应该是确定性的</li><li id="bdb5" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">单元测试应该是有重点的</li><li id="5b09" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">在单元测试中代码重复是可以的</li><li id="4d0c" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">测试描述应该易于理解</li></ul><p id="db75" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">单元测试应该很快。我们的整个单元测试套件应该能够在几分钟内运行，这样我们就可以在开发阶段自己运行测试套件。这有助于尽早修复错误。如果需要更长的时间，那么我们通常会将这项工作放入某种管道中。</p><p id="ddc2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">单元测试应该简单。当我们通过一个单元测试用例时，我们需要知道的一切都应该在那个测试用例里面。我们不想滚动代码来理解单个测试用例。单元测试应该是自解释的。</p><p id="1fa2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">单元测试应该是确定性的。无论何时何地，在不改变源代码的情况下，一个单元测试都应该像以前一样运行。单元测试不应该依赖于任何外部因素，如当前时间、数据库、网络、本地API等。我们通常会模仿这些。</p><p id="06a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">单元测试应该是集中的。单元测试应该只关注单个单元。我们不应该在单元测试中测试依赖关系。</p><p id="e956" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在单元测试中代码重复是可以的。单元测试应该更加关注简单性，而不是良好的编码实践。任何人都应该理解测试用例，而不需要搜索它的依赖或者单元的当前状态。因此，如果重复代码的某些部分有助于理解和简化，那么这是可以的。</p><p id="2bfe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">单元测试描述应该容易理解。一个好的描述必须包含四个部分:</p><ul class=""><li id="183c" class="mg mh iq kt b ku kv kx ky la nt le nu li nv lm mn mo mp mq bi translated">我们要测试的单元</li><li id="2348" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">设备的当前状态</li><li id="f6b1" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">我们将要给出的输入</li><li id="6b6d" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">我们期待的回应</li></ul><p id="c486" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个测试描述中，“半径为1的圆的面积应该是3.141592”，我们可以像下面这样分解它:</p><ul class=""><li id="9012" class="mg mh iq kt b ku kv kx ky la nt le nu li nv lm mn mo mp mq bi translated">“圆的面积”是我们要测试的单位</li><li id="8b43" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">“半径1”是我们将要使用的输入</li><li id="2731" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">“3.141592”是我们期望的输出</li></ul><p id="2ba4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个单位没有任何状态。</p><h1 id="e0a5" class="mx lo iq bd lp my mz na ls nb nc nd lv jw ne jx ly jz nf ka mb kc ng kd me nh bi translated">嘲弄的</h1><p id="4673" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">单元测试背后的主要思想是隔离并关注我们正在测试的当前单元，而不是外部依赖的行为。但在大多数情况下，我们需要依赖外部依赖，如数据库、web服务器、平台API、外部设备等。</p><p id="044c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们假设我们当前的单元依赖于一个web API。当服务器运行时，测试运行缓慢但很好。但是当服务器离线时，单元测试就会失败。这使得单元测试不可预测。因为网络服务器不在我们的控制之下。当网络服务器关闭时，这不是我们的错。这就是嘲讽的由来。</p><p id="37f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="no">嘲讽只是被测单元存在外部依赖时，单元测试中使用的过程。嘲讽的目的是隔离并关注被测试的代码，而不是外部依赖的行为。</em></p><p id="3e79" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一个例子。</p><p id="22cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将在repository类中测试这个<code class="fe nx ny nz oa b">fetch()</code>方法。正如我们所看到的，我们的单元依赖于与web API通信的<code class="fe nx ny nz oa b">RemoteDataSource’s fetch()</code>方法，这是一个外部依赖。因此，我们需要从<code class="fe nx ny nz oa b">RemoteDataSource</code>中剔除<code class="fe nx ny nz oa b">fetch()</code>方法。</p><p id="236e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="no"> Stubbing是指在不影响其他任何东西的情况下，改变单元某个部分的行为。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="a1e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以用一些方式来嘲笑。</p><h2 id="8851" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">实现我们需要模拟的类</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="4903" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们在两个模拟类上实现了<code class="fe nx ny nz oa b">RemoteDateSource</code>类。<code class="fe nx ny nz oa b">MockRemoteDateSourceSuccess</code>模仿成功案例，而<code class="fe nx ny nz oa b">MockRemoteDateSourceFailure</code>模仿失败案例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="075c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在编写测试用例时，我们可以根据测试来选择我们需要什么样的实现。</p><ul class=""><li id="96a3" class="mg mh iq kt b ku kv kx ky la nt le nu li nv lm mn mo mp mq bi translated">在第一个测试中，我使用了模拟成功案例的<code class="fe nx ny nz oa b">MockRemoteDateSourceSuccess</code>实例，并验证了结果是<code class="fe nx ny nz oa b">Student</code>的实例。</li><li id="c522" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">在第二个测试中，我使用了模拟失败案例的<code class="fe nx ny nz oa b">MockRemoteDateSourceFailure</code>实例，并验证了方法调用抛出了异常。</li></ul><h2 id="a018" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">扩展我们需要模仿的抽象类</h2><p id="244d" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">这与前面的方法类似。唯一的区别是，我们没有实现一个具体的类，而是扩展了一个具体类正在扩展的<code class="fe nx ny nz oa b">abstract</code>类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="a95d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这有助于减少具体类中一些不必要的实现。</p><p id="1473" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是这两种技术都有两个问题。</p><ul class=""><li id="75f0" class="mg mh iq kt b ku kv kx ky la nt le nu li nv lm mn mo mp mq bi translated">它们缺乏简单性，因为我们需要移动到模拟代码来了解它的实现细节。</li><li id="bddd" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">此外，我们需要为所有测试用例创建单独的模拟类。对于单元测试来说，部分代码重复是可以接受的。但是如此多的代码重复很难维护。</li></ul><p id="daa6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是嘲讽包发挥作用的地方。</p><h2 id="61f7" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated"><a class="ae mr" href="https://pub.dev/packages/mockito" rel="noopener ugc nofollow" target="_blank">Mock ITO</a>—Dart的模拟库</h2><p id="62a0" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">这个包解决了这两个问题。Mockito库背后的想法是，我们只需要使用<code class="fe nx ny nz oa b">@GenerateMocks()</code>注释来传递我们需要模仿的类。它在<code class="fe nx ny nz oa b"><a class="ae mr" href="https://pub.dev/packages/build_runner" rel="noopener ugc nofollow" target="_blank">build_runner</a></code>包的帮助下为我们生成模拟类(不要忘记将<code class="fe nx ny nz oa b"> build_runner</code>作为<code class="fe nx ny nz oa b">dev_dependency</code>)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="5aef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们使用了来自Mockito的<code class="fe nx ny nz oa b">when()</code>方法来完成存根部分。</p><p id="522e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不要忘记生成模拟类。</p><pre class="kg kh ki kj gt od oa oe of aw og bi"><span id="3a06" class="ln lo iq oa b gy oh oi l oj ok">dart run build_runner build --delete-conflicting-outputs</span></pre><p id="bfd0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nx ny nz oa b">build_runner</code>将根据包含<code class="fe nx ny nz oa b">@GenerateMocks</code>注释的文件生成一个文件名。这里，在<code class="fe nx ny nz oa b">repository_test.dart</code>示例中，我们将生成的库作为<code class="fe nx ny nz oa b">repository_test.mocks.dart</code>导入。</p><ul class=""><li id="73b8" class="mg mh iq kt b ku kv kx ky la nt le nu li nv lm mn mo mp mq bi translated">我们不需要移动到任何地方来查看实现逻辑。一切都会在那里。</li><li id="a6e0" class="mg mh iq kt b ku ms kx mt la mu le mv li mw lm mn mo mp mq bi translated">mock类的生成由mockito完成，因此易于维护。</li></ul><p id="f556" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以只关注存根、行为和断言。就是这样。</p><p id="08a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Mockito的唯一问题是代码生成。我们可以用模仿秀来克服它。</p><h2 id="8c58" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated"><a class="ae mr" href="https://pub.dev/packages/mocktail" rel="noopener ugc nofollow" target="_blank"> MockTail </a> —无代码生成</h2><p id="090e" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">Mocktail专注于提供一个熟悉的、简单的API，用于在Dart中创建模拟(具有空安全性)，而不需要手动模拟或代码生成。</p><p id="bf2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个库是由菲利克斯·安杰洛夫写的，他也是写了bloc等的人。这个库甚至像他写的其他包一样有100%的代码覆盖率。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="8733" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就是这样。没有注释也没有代码生成。只有一行。</p><pre class="kg kh ki kj gt od oa oe of aw og bi"><span id="6b28" class="ln lo iq oa b gy oh oi l oj ok">class MockRemoteDataSource extends Mock implements RemoteDateSource{}</span></pre><p id="1f05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">干得好，伙计们！您已经准备好进行单元测试了。</p><p id="8003" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望你喜欢这篇文章。</p><pre class="kg kh ki kj gt od oa oe of aw og bi"><span id="dc93" class="ln lo iq oa b gy oh oi l oj ok"><strong class="oa ir">Want to Connect?</strong></span><span id="b721" class="ln lo iq oa b gy on oi l oj ok">Connect with me on <a class="ae mr" href="https://www.linkedin.com/in/bharath-t-dev/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>, <a class="ae mr" href="https://twitter.com/bharath_dev_t" rel="noopener ugc nofollow" target="_blank">Twitter</a>, <a class="ae mr" href="https://github.com/Bharathh-Raj" rel="noopener ugc nofollow" target="_blank">GitHub</a>.</span></pre></div></div>    
</body>
</html>