<html>
<head>
<title>Build a Distributed Task Scheduler Using RabbitMQ and Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RabbitMQ和Redis构建分布式任务调度器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-distributed-task-scheduler-using-rabbitmq-and-redis-8ee1310cfc8?source=collection_archive---------2-----------------------#2022-10-29">https://betterprogramming.pub/build-a-distributed-task-scheduler-using-rabbitmq-and-redis-8ee1310cfc8?source=collection_archive---------2-----------------------#2022-10-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="43e5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用RabbitMQ deadLetterExchange延迟任务执行</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ec5a3e734339767ea71fcb7343d3b7c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ll7napqvntM2dAiw9f9EIg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">调度程序</p></figure><p id="3da6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您对使用RabbitMQ构建任务调度器感兴趣吗？</p><p id="93ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可能想知道为什么要使用RabbitMQ构建任务调度程序，因为它是一个消息代理，没有理由充当调度程序。</p><p id="3ed9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">嗯，一年前，我在做一个业余爱好项目，我想使用RabbitMQ，我碰巧有一个在一定时间后执行一段代码的要求。我们可以称之为。</p><p id="4ddc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是我好奇的地方，想知道是否有可能延迟消息的执行。换句话说，假设一条消息在<code class="fe lr ls lt lu b">x</code>时间被发送到一个队列，我想在<code class="fe lr ls lt lu b">x+y</code>时间使用它，这里<code class="fe lr ls lt lu b">y</code>是可以为每条消息/任务配置的。</p><p id="75d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我能够使用<code class="fe lr ls lt lu b">deadLetterExchange</code>来实现这一点。这是RabbitMQ的一个特性。通过使用这个RabbitMQ特性作为核心逻辑，我能够指定消费者在消费任务或消息之前应该经过多长时间。<br/>但它还不是一个任务调度器，它只是一个延迟的任务执行。一个任务调度器应该能够<code class="fe lr ls lt lu b">schedule</code>和<code class="fe lr ls lt lu b">cancel</code>任务。这就是Redis发挥作用的地方，让它成为一个任务调度器。</p><p id="954b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">希望以上内容有助于在此设定脉络。让我们开始吧。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="2b03" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">先决条件</h1><p id="ea78" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">作为这篇文章的一部分，我们不打算讨论RabbitMQ和Redis的介绍。假设您至少对RabbitMQ和Redis有基本的了解。这里讨论的示例项目是在NodeJS上编写的。了解NodeJS会有所帮助，但这不是必需的。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="7419" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">如何实现延迟任务执行</h1><p id="cef8" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">一旦消息可用，RabbitMQ就会将它们转发到相应的队列。我们无法直接告诉RabbitMQ将消息保存在某个地方，并在<code class="fe lr ls lt lu b">y</code>时间后将其发送到预期队列。<br/>让我们看看如何通过使用<code class="fe lr ls lt lu b">deadLetterExchange</code>来实现这一点。</p><h2 id="c201" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">死信交流</h2><p id="73c4" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">当发生以下任何事件时，队列中的消息可以被<code class="fe lr ls lt lu b">dead-lettered</code>(即，重新发布到交换):</p><ul class=""><li id="32b3" class="nl nm iq kx b ky kz lb lc le nn li no lm np lq nq nr ns nt bi translated">消费者否定了该消息。</li><li id="c861" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated"><strong class="kx ir"> <em class="nz">由于每条消息的TTL，消息过期。</em> </strong></li><li id="700f" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated">消息被丢弃，因为其队列超过了长度限制。</li></ul><p id="6e7d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将使用第二个选项(即每个消息的TTL)来触发<code class="fe lr ls lt lu b">deadLetterExchange</code>。我们来详细看看。</p><blockquote class="oa ob oc"><p id="81f3" class="kv kw nz kx b ky kz jr la lb lc ju ld od lf lg lh oe lj lk ll of ln lo lp lq ij bi translated">TTL代表时间<strong class="kx ir"> T </strong> o <strong class="kx ir"> L </strong> ive</p></blockquote><p id="a149" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们<strong class="kx ir">为我们的每条消息</strong>设置一个 <code class="fe lr ls lt lu b"><strong class="kx ir">TTL</strong></code> <strong class="kx ir">，并将它们发送到一个队列中。姑且称之为<code class="fe lr ls lt lu b">intermediate queue</code>。当声明一个<code class="fe lr ls lt lu b">intermediate queue</code>时，我们设置一个选项，当这个队列中的消息过期时，它们应该被传递到另一个指定的交换。姑且称之为<code class="fe lr ls lt lu b">final exchange</code>。</strong></p><p id="db1f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">消息</strong> <code class="fe lr ls lt lu b"><strong class="kx ir">TTL</strong></code>时间<strong class="kx ir">就是我们要拖延的时间</strong>。<code class="fe lr ls lt lu b">final exchange</code>是我们的消费者消费来自指定队列的消息的地方。</p><p id="0f32" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，一旦消息<code class="fe lr ls lt lu b">TTL</code>过期，我们的消费者就会收到消息。</p><p id="40d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在的问题是，我们如何让消息过期？很简单。我们正在向<code class="fe lr ls lt lu b">intermediate queue</code>发送消息。我们不允许任何人从这里消费它。如果这个<code class="fe lr ls lt lu b">intermediate queue</code>中的消息直到指定的<code class="fe lr ls lt lu b">TTL</code>才被使用，那么它们就是<code class="fe lr ls lt lu b">dead-lettered</code>，消息将被传递给我们的消费者，他正在愉快地使用来自<code class="fe lr ls lt lu b">final exchange</code>队列的消息。</p><p id="9ef8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过将这个<code class="fe lr ls lt lu b">TTL</code>设置为我们需要的延迟，并将消息发送到没有消费者的<code class="fe lr ls lt lu b">intermediate queue</code>，我们可以在RabbitMQ上实现一个<code class="fe lr ls lt lu b">delayed task execution</code>。</p><p id="d0e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是使用<code class="fe lr ls lt lu b">dead letter exchange</code>在RabbitMQ上实现<code class="fe lr ls lt lu b">delayed task execution</code>的UML图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/dd2e200c37ceeae6aeef5abb3b705ed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*zBVmcQKeVf4pHEbxo16q0w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">RabbitMQ使用死信交换延迟任务执行</p></figure><p id="b16d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是延迟任务执行不是任务调度器，对吧。让我们看看如何构建一个任务调度器，它将提供使用RabbitMQ和Redis来调度和取消任务的选项。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="927d" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">任务调度程序</h1><h2 id="4232" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">Redis的作用</h2><p id="bb43" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">Redis用于跟踪计划任务的有效性。利用这一点，我们可以根据需要将任何调度的任务设置为无效，并且当该执行任务时，我们可以检查该任务是否可以执行。</p><p id="41ce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们将使用Redis只存储任务有效性信息，所以它可以用任何数据存储工具来代替。</p><h2 id="87a7" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">体系结构</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/b0f92c308cedfb0c010b543c2cf24def.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eKK-unZQzDEYjoql0hIx-w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">任务调度程序体系结构</p></figure><p id="850a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们用来构建这个任务调度器的列表实体如下。</p><ul class=""><li id="b94d" class="nl nm iq kx b ky kz lb lc le nn li no lm np lq nq nr ns nt bi translated"><a class="ae oi" href="https://github.com/sridhar-sp/task-scheduler/blob/main/src/task/task.ts" rel="noopener ugc nofollow" target="_blank">任务</a> →任务定义。</li><li id="be6e" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated"><a class="ae oi" href="https://github.com/sridhar-sp/task-scheduler/blob/main/src/rabbitmq/producer.ts" rel="noopener ugc nofollow" target="_blank">生产者</a> →基类提供发送延迟消息的选项。</li><li id="688f" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated"><a class="ae oi" href="https://github.com/sridhar-sp/task-scheduler/blob/main/src/rabbitmq/consumer.ts" rel="noopener ugc nofollow" target="_blank">消费者</a> →从最终队列中消费消息的基类。</li><li id="6e68" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated"><a class="ae oi" href="https://github.com/sridhar-sp/task-scheduler/blob/main/src/task/repository/taskRepositoryImpl.ts" rel="noopener ugc nofollow" target="_blank">任务仓库</a> →仓库类检查任务有效性状态。</li><li id="aaac" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated"><a class="ae oi" href="https://github.com/sridhar-sp/task-scheduler/blob/main/src/task/scheduler/taskSchedulerImpl.ts" rel="noopener ugc nofollow" target="_blank">任务调度器</a> →类提供了调度和无效任务的选项。</li><li id="6204" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated"><a class="ae oi" href="https://github.com/sridhar-sp/task-scheduler/blob/main/src/task/consumer/taskConsumerImpl.ts" rel="noopener ugc nofollow" target="_blank">任务消耗者</a> →从指定的<code class="fe lr ls lt lu b">task type</code>队列中消耗任务的类。</li></ul><h2 id="287e" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">工作</h2><pre class="kg kh ki kj gt oj lu ok ol aw om bi"><span id="c8de" class="mz md iq lu b gy on oo l op oq">class Task {<br/>  public taskId: string;<br/>  public taskType: string; // queue name<br/>  public ttlInSeconds: number;<br/>  public payload: string;<br/>}</span></pre><ul class=""><li id="488e" class="nl nm iq kx b ky kz lb lc le nn li no lm np lq nq nr ns nt bi translated"><code class="fe lr ls lt lu b">taskId</code> →标识该任务的唯一id。</li><li id="245a" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated"><code class="fe lr ls lt lu b">taskType</code> →该任务的类型。这用作队列名称，因此生产者和消费者都可以从任务类型中推断出名称。</li><li id="88cf" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated"><code class="fe lr ls lt lu b">ttlInSeconds</code> →我们希望任务执行的时间延迟。</li><li id="ad4f" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated"><code class="fe lr ls lt lu b">payload</code> →描述任务的JSON字符串；根据不同的任务类型，<code class="fe lr ls lt lu b">taskType</code>将很方便地解析这个json。</li></ul><p id="8d60" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">taskType</code>起着重要的作用。它充当一个队列名，因此当任务调度器想要调度一个任务时，它可以使用<code class="fe lr ls lt lu b">taskType</code>作为队列名，任何想要使用特定任务类型的人都可以从该队列中使用它。</p><blockquote class="oa ob oc"><p id="e410" class="kv kw nz kx b ky kz jr la lb lc ju ld od lf lg lh oe lj lk ll of ln lo lp lq ij bi translated">以下是taskType <code class="fe lr ls lt lu b">send-sms, send-offer-notification, send-greetings</code>等的一些例子</p></blockquote><h2 id="4daf" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">生产者</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Producer.ts</p></figure><p id="3757" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我们之前讨论的，我们需要两个队列来实现这个<code class="fe lr ls lt lu b">delayed task execution.</code></p><ol class=""><li id="bace" class="nl nm iq kx b ky kz lb lc le nn li no lm np lq ot nr ns nt bi translated">中间队列→持有任务直到到期；post到期将任务转发给<code class="fe lr ls lt lu b">final exchange</code>。</li><li id="8790" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq ot nr ns nt bi translated">最终队列→这与<code class="fe lr ls lt lu b">final exchange</code>相关。我们的任务消费者将监听这个队列。</li></ol><p id="d57e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">队列及其相关的交换名称都是从<code class="fe lr ls lt lu b">taskType</code>开始形成的，以便在调度程序和消费者之间引入某种契约。</p><p id="996d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从上面的代码中，我们可以看到中间队列作为<code class="fe lr ls lt lu b">dead letter exchange</code>与最终交换相关联。</p><pre class="kg kh ki kj gt oj lu ok ol aw om bi"><span id="5b71" class="mz md iq lu b gy on oo l op oq">this.assertQueue(<br/>    INTERMEDIATE_QUEUE, { deadLetterExchange: FINAL_EXCHANGE }<br/>)</span></pre><p id="526f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦任务到期时间过去，任务将被转发给<code class="fe lr ls lt lu b">final exchange</code>，而<code class="fe lr ls lt lu b">final exchange</code>将任务路由给<code class="fe lr ls lt lu b">final queue</code>。</p><pre class="kg kh ki kj gt oj lu ok ol aw om bi"><span id="a30f" class="mz md iq lu b gy on oo l op oq">sendToQueue(INTERMEDIATE_QUEUE, Buffer.from(data), {<br/>    expiration: delayInMills,<br/>});</span></pre><h2 id="25e2" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">消费者</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="836f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">消费者将消费特定队列中的消息(即<code class="fe lr ls lt lu b">taskType</code>)。</p><h2 id="bd3b" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">任务储存库</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="faf2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这提供了创建、删除和验证任务的选项。</p><h2 id="2004" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">任务调度程序</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="01cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">Task Scheduler</code>在调度任务时会在Redis中创建一个任务条目。<br/>当我们不再希望任务被执行时，可以删除该任务，将其标记为无效。<code class="fe lr ls lt lu b">scheduleTask</code>返回一个<code class="fe lr ls lt lu b">taskId</code>。如果需要，同样可以用来使任务无效。</p><h2 id="53d4" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">任务消费者</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="cc26" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">Task Consumer </code>将监听特定的<code class="fe lr ls lt lu b">taskType</code>并在任务仍然有效时执行它。即使我们通过删除任务使其无效。消费者将在预定的时间消费它。在使用来自<code class="fe lr ls lt lu b">Task Repository</code>的<code class="fe lr ls lt lu b">isTaskValid</code>功能执行任务之前，检查任务有效性将是<code class="fe lr ls lt lu b">Task Consumer</code>的责任。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="3aa4" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">演示</h1><p id="bb12" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">演示包括两个消费者和两个生产者。<br/>将消费者1和2视为电子邮件服务，每个微服务负责向客户发送<code class="fe lr ls lt lu b">greetings</code>和<code class="fe lr ls lt lu b">offer notification</code>。<br/><code class="fe lr ls lt lu b">greeting</code>和<code class="fe lr ls lt lu b">offer-notification</code>是两种不同的<code class="fe lr ls lt lu b">task types</code>，分别由<code class="fe lr ls lt lu b">Greeter-Service</code>和<code class="fe lr ls lt lu b">Offer-Notification-Service</code>生产商生产。</p><p id="12df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">演示显示<code class="fe lr ls lt lu b">Email-Service-1</code>(即消费者1)将处理<code class="fe lr ls lt lu b">greet</code>和<code class="fe lr ls lt lu b">offer-notification</code>任务，而as <code class="fe lr ls lt lu b">Email-Service-2</code>(即消费者2)将仅处理<code class="fe lr ls lt lu b">offer-notification</code>任务。</p><p id="3921" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了简洁起见，任务失效没有在演示中显示，而是在项目的Readme文件中进行了解释。</p><p id="d6f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我尽力动画化并突出显示日志消息，以表明<code class="fe lr ls lt lu b">scheduler</code>和<code class="fe lr ls lt lu b">consumer</code>之间的事件流。日志消息包含一个时间戳，可用于断言使用者是否在预期的计划时间收到任务通知。每当<code class="fe lr ls lt lu b">consumer</code>接收到<code class="fe lr ls lt lu b">task</code>时，我都会在<code class="fe lr ls lt lu b">scheduler</code>和<code class="fe lr ls lt lu b">consumer</code>上突出显示时间戳。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou os l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">演示</p></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="b20b" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">源代码</h1><div class="ov ow gp gr ox oy"><a href="https://github.com/sridhar-sp/task-scheduler" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd ir gy z fp pd fr fs pe fu fw ip bi translated">GitHub-srid har-sp/Task-scheduler:使用RabbitMQ的分布式任务调度程序</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">使用RabbitMQ的分布式任务调度器。通过创建一个帐户，为Sri dhar-sp/任务调度程序的开发做出贡献…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">github.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm kp oy"/></div></div></a></div></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="13a5" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">参考</h1><ul class=""><li id="b453" class="nl nm iq kx b ky mu lb mv le pn li po lm pp lq nq nr ns nt bi translated"><a class="ae oi" href="https://www.rabbitmq.com/dlx.html" rel="noopener ugc nofollow" target="_blank">https://www.rabbitmq.com/dlx.html</a></li><li id="ef03" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated"><a class="ae oi" href="https://github.com/sridhar-sp/draw-server" rel="noopener ugc nofollow" target="_blank">https://github.com/sridhar-sp/draw-server</a>(使用这个任务调度器的多人绘图游戏)</li><li id="b797" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated"><a class="ae oi" href="https://play.google.com/store/apps/details?id=com.gandiva.draw" rel="noopener ugc nofollow" target="_blank">https://play.google.com/store/apps/details?id=com.gandiva.draw </a>(使用此任务计划程序的生产应用程序)</li></ul></div></div>    
</body>
</html>