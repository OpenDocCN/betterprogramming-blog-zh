# 如何在 iOS 遗留代码库中实现单元测试

> 原文：<https://betterprogramming.pub/implement-unit-test-in-ios-legacy-codebase-d11c640c52eb>

## 测试旧代码的简单指南

![](img/15e10dcad025cac0c1125c462c02fc05.png)

照片由[大卫·格兰穆金](https://unsplash.com/@davidgrdm?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

拥有一个单元测试总是很重要的，它给了我们很多好处。它给你快速的反馈，并最小化你的代码在生产中的严重错误。当你想对你的代码库进行大的重构时，单元测试也可以一步一步地保护你。单元测试也可以作为文档，这对公司的新员工来说非常有用。

但是实现单元测试并不容易，尤其是对于遗留代码库。通常，遗留代码库并不关心代码质量，因为有很多因素。也许我们有一个紧迫的期限，应该尽快交付应用程序，或者我们只是不知道如何在当前时刻创建一个可扩展的代码。但这完全没问题。我们都经历过这一刻，对吧？我们必须继续前进，现在就考虑可能的解决方案。

因此，出于教育目的，我创建了一个示例应用程序，演示了一个简单的 iOS 遗留代码库。这是一个显示神奇宝贝列表的简单应用程序。虽然这是一个简单的应用程序，但它可能是您学习如何添加单元测试和一步一步重构的良好开端。检查它，克隆存储库，并将您的分支切换到`legacy`。

[](https://github.com/tifoaudii/PokemonApp) [## GitHub — tifoaudii/PokemonApp

### 在 GitHub 上创建一个帐户，为 tifoaudii/PokemonApp 开发做贡献。

github.com](https://github.com/tifoaudii/PokemonApp) 

## 我们应该从哪里开始？

首先可以查一下`PokemonLegacyListViewController.swift`，给几分钟熟悉一下代码。这个简单的应用程序在视图加载时从服务器获取神奇宝贝的数据。如果成功，该视图将显示神奇宝贝卡的集合。否则，它将显示错误状态。

在`PokemonAppTest`目录中，创建一个名为`PokemonLegacyViewControllerTest`的新文件。在类内部，创建第一个名为`test_whenSuccessFetchPokemons_shouldRenderCollectionCard`的测试用例函数。

当创建一个测试用例功能时，我们通常有三个遵循惯例的部分。它从`Given`开始，在这一部分，我们设置被测系统并提供它所需的依赖项。然后我们有`When`部分。这里，我们模拟被测系统的动作。最后，我们有`Then`部分，在那里我们将在系统测试动作完成后断言条件。

当处理遗留代码库时，总是从简单的案例开始。在这种情况下，我们知道当视图加载时，我们从 API 服务器获取了神奇宝贝。让我们像这样编写我们的第一个测试用例:

尝试点击`cmd + U`运行测试，测试结果失败。当我们运行测试时，它是作为一个网络请求来执行的，在我们从 API 服务器获取数据之前，您的测试就已经完成了。为了测试异步代码，我们可以像这样给测试增加一个延迟:

试着再运行一次测试，嘣，成功了。但是我们需要等三秒钟才能得到测试结果。如果 API 服务器关闭，也许我们应该等待三秒以上。所以此时此刻，我们的测试并不可靠，而且耗时太长。单元测试应该是快速和独立的，所以我们不想执行异步操作，这是测试环境中真正的网络请求。

我们可以使用的方法是用 spy 对象替换网络服务。一个 spy 对象用于记录来自被测系统的一个动作的信息，它也可以作为一个 stub，在那里我们可以得到一个预定义的结果。

让我们再来看看`PokemonLegacyListViewController.swift`，里面的`viewDidLoad`函数。我们使用`PokemonLegacyService` singleton 来执行网络请求。在这种情况下，使用 singleton 使我们的类具有隐式依赖。所以我们需要一些重构来支持测试环境中依赖实例的变化。

我们可以在这里创建一个新的属性，使用属性注入来注入依赖项。现在我们可以使用 spy 对象来更改我们的测试实现。当处理混乱的遗留代码库时，通过属性进行依赖注入是很容易的。但是如果您从头开始编写代码，实现依赖注入的最佳实践是使用初始化器注入。

在测试环境中，我们可以使用一个 spy 对象，而不需要执行网络请求。因此，我们还可以提供一个预定义的结果，在本例中，是我们获取神奇宝贝时的结果。我们的测试现在既可靠又快速！

但问题是，如果`PokemonLegacyService`是最终类，那么我们就不能创建子类。然后我们可以为这种情况创建一个特定的协议，并使我们的`PokemonLegacyViewController`依赖于协议而不是具体的实现。

既然我们的`PokemonLegacyService`已经有了`fetchPokemons`函数的实现，我们就不用再写什么了。只需改变`PokemonLegacyListViewController`内部的依赖类型。在这一点上，我们已经实现了依赖倒置原则，这很好！

现在我们可以更新 spy 对象实现了。再次运行测试，以确保我们没有打破任何东西。

太棒了。当我们从 API 服务器得到错误响应时，让我们编写另一个测试用例。

因为我们想要模拟 API 服务器给出的错误响应，所以我们需要更改 spy 对象中的预定义结果。为了简化我们的项目，我们可以在这里创建一个新的私有类型`AnyError`。但是也许我们需要在现实世界中断言不同种类的错误状态。运行测试以确保一切正常。

# 从这里去哪里

恭喜你关注了这篇文章。您已经深入了解了如何开始一小步来改进遗留代码库。虽然是一个相当简单的例子，但希望能对你有用。理解如何实现单元测试的基础知识现在非常重要。我们可以从中获得很多好处。

感谢您阅读这篇文章。如果您有任何建议或反馈，请告诉我。

另文再见！