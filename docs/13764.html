<html>
<head>
<title>Developing Custom Libraries With Spring Boot Starter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Spring Boot软件开发自定义库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/developing-custom-libraries-with-spring-boot-starter-cf463a5eca39?source=collection_archive---------0-----------------------#2022-09-26">https://betterprogramming.pub/developing-custom-libraries-with-spring-boot-starter-cf463a5eca39?source=collection_archive---------0-----------------------#2022-09-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f4a7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用Spring Boot入门框架开发自定义库的分步说明</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2c8be2d72481da4785335cd7bd645f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_-QnZ_Vj_2O_jzlJh06d7Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><h1 id="90ce" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">为什么选择自定义库？</h1><p id="136e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">似乎是一个有明显答案的问题。但是在微服务领域，有很多关于为什么或者为什么不使用定制库的讨论。这里有几个值得一提的要点:</p><ul class=""><li id="3860" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">DRY(不要重复自己)原则鼓励我们创建可重用的代码。我们将重复的代码提取到抽象中，比如自定义库，然后我们可以从多个地方调用它。对共享逻辑的更改发生在一个库中，而不是在所有调用该共享逻辑的地方。定制库是微服务间代码复制的关键解决方案。</li><li id="f7b8" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">如果共享代码的使用泄漏到我们的服务边界之外，我们将会引入一种潜在的耦合形式，这在微服务世界中是不可取的，因为它的原则是建立在低耦合和高内聚的基础上的。</li><li id="ac50" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">一些人认为“服务间过多耦合的弊端比代码复制引起的问题更糟糕。”(引自山姆·纽曼的书<em class="nc">构建微服务</em>)。</li></ul><h1 id="e0a8" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">如何最好地设计定制库？</h1><ul class=""><li id="b252" class="mm mn it ls b lt lu lw lx lz nd md ne mh nf ml mt mu mv mw bi translated">不要在定制库中编写任何特定于领域的代码。</li><li id="379d" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">即使是与业务相关的共享代码也不应该在定制库中。</li><li id="2539" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">想想共同点。思考抽象。想想卑鄙的行为。这些是定制库的候选对象。</li></ul><h1 id="d045" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">为什么是Spring Boot首发？</h1><p id="d1eb" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Spring Boot启动库是Spring Boot应用程序的一些主要构件。作为Spring Boot开发者，我们都已经习惯了一些我们最喜欢的启动库，比如<code class="fe ng nh ni nj b">spring-boot-starter-web</code>、<code class="fe ng nh ni nj b">spring-boot-starter-data-jpa</code>、<code class="fe ng nh ni nj b">spring-boot-starter-actuator</code>等等。在这个故事中，我们将探索Spring Boot启动器框架来创建我们自己的自定义启动器库。使用Spring Boot启动器作为我们的定制启动器库框架有很多好处:</p><ul class=""><li id="7198" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">与Spring Boot的自动配置更加无缝集成。</li><li id="b9ab" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">更全面地利用成熟的Spring Boot启动框架，使其成为Spring Boot的延伸。</li><li id="97a5" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">在我看来，最大的优势是Spring Boot启动框架能够提供自定义库的默认行为，并且仍然允许调用自定义库的微服务用自定义行为覆盖默认行为。仅这个特性就在很多方面解决了定制库导致微服务间耦合的困境。<br/>是的，通过Spring Boot启动器提供的出色框架，我们可以拥有定制库，如果需要，还可以选择在微服务中定制这些库的逻辑，从而减少耦合。</li></ul><h1 id="3a89" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">如何使用Spring Boot启动建立自定义库？</h1><p id="6e4d" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Spring Boot让我们通过使用Spring Boot自动配置来构建我们自己的定制库变得非常容易。遵循几个简单的步骤:</p><h1 id="7fb8" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">步骤1:选择多模块还是单模块</h1><p id="c3a3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">根据<a class="ae nk" href="https://docs.spring.io/spring-boot/docs/2.6.7/reference/htmlsingle/#features.developing-auto-configuration.custom-starter" rel="noopener ugc nofollow" target="_blank"> Spring的文档</a>，定制启动器可以包含以下内容:</p><ul class=""><li id="ff7f" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">包含库逻辑自动配置代码的<code class="fe ng nh ni nj b">autoconfigure</code>模块。</li><li id="d4d9" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">为<code class="fe ng nh ni nj b">autoconfigure</code>模块提供依赖关系的<code class="fe ng nh ni nj b">starter</code>模块，以及库逻辑和任何通常有用的附加依赖关系。简而言之，添加starter应该提供开始使用该库所需的一切。</li></ul><p id="333e" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nl mb mc md nm mf mg mh nn mj mk ml im bi translated">这种分成两个模块的方式是不必要的。如果库逻辑有几种风格、选项或可选特性，最好将自动配置分开，因为这样可以清楚地表达一些特性是可选的这一事实。</p><p id="6c8d" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nl mb mc md nm mf mg mh nn mj mk ml im bi translated">此外，您有能力制作一个提供关于那些可选依赖项的观点的启动器。与此同时，其他人只能依靠<code class="fe ng nh ni nj b">autoconfigure</code>模块，用不同的观点来制作自己的启动器。</p><p id="1ee7" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nl mb mc md nm mf mg mh nn mj mk ml im bi translated">如果自动配置相对简单，并且没有可选特性，那么在starter中合并这两个模块无疑是理想的，因为它简化了库结构。</p><p id="d99b" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nl mb mc md nm mf mg mh nn mj mk ml im bi translated">基于这个指导方针，我们可以建议，对于我们的定制库，如果库逻辑非常简单，我们应该坚持只创建一个模块。让我们简化，而不是过度工程化。对于可能需要多个实现的特殊库场景，建议采用上面提到的两模块方法。</p><h1 id="17ae" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">步骤2:选择库名</h1><p id="1cdb" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Spring关于自定义库命名约定的指导方针是，我们应该首先以我们的库名开始命名，然后是“<code class="fe ng nh ni nj b">-spring-boot-starter</code>”。因此，例如，对于一个样本定制库，我们应该将我们的工件id命名为“<code class="fe ng nh ni nj b">sample-spring-boot-starter</code>”。原因是，如果我们以“<code class="fe ng nh ni nj b">spring-boot-starter-</code>”开始我们的库名，它很有可能与现成的Spring Boot初学者库或他们可能提供的任何潜在的新初学者发生冲突。</p><p id="2394" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nl mb mc md nm mf mg mh nn mj mk ml im bi translated">确保在pom中指定库的工件id，例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="4fc6" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">步骤3:POM . XML中的变化</h1><p id="186b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">除了为定制库添加任何特定的依赖项之外，确保pom <code class="fe ng nh ni nj b">parent</code>被指定，注意我们使用的是<code class="fe ng nh ni nj b">spring-boot-starter-parent</code>版本<code class="fe ng nh ni nj b">3.0.0-M5</code>，这是撰写本文时最新的boot 3里程碑版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c9c5" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nl mb mc md nm mf mg mh nn mj mk ml im bi translated">另外，确保添加<code class="fe ng nh ni nj b">spring-boot-autoconfigure</code>依赖关系:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="e680" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">步骤4:创建定义定制库中主要逻辑的服务层</h1><p id="2ded" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这是您的详细库逻辑实现，无论是在服务层、配置层还是任何其他层。这是我们想要提取到自定义库中的共享代码。</p><h1 id="db9a" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">步骤5:创建自定义自动配置类</h1><p id="9dd6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这一步，结合第6步，是我们的定制库如何成为一个定制Spring Boot启动器的关键。</p><p id="cbd3" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nl mb mc md nm mf mg mh nn mj mk ml im bi translated">示例代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><ul class=""><li id="f456" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated"><code class="fe ng nh ni nj b">@ConditionalOnClass</code>注释让<code class="fe ng nh ni nj b">SampleService</code>类基于<code class="fe ng nh ni nj b">ApplicationContext</code>中<code class="fe ng nh ni nj b">SampleService</code>类的存在而被包含。</li><li id="a4d3" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated"><code class="fe ng nh ni nj b">@ConditionalOnMissingBean</code>注释表明如果<code class="fe ng nh ni nj b">ApplicationContext</code>中还没有包含<code class="fe ng nh ni nj b">SampleService</code>类型的bean，那么将创建<code class="fe ng nh ni nj b">sampleService</code> bean。</li></ul><h1 id="36c4" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">步骤6:添加spring.factories来反映这个定制的自动配置类</h1><p id="7ae5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><code class="fe ng nh ni nj b">spring.factories</code>文件是Spring Boot在启动时自动加载的文件。Spring Boot检查jar文件中的<code class="fe ng nh ni nj b">META-INF</code>目录下是否存在<code class="fe ng nh ni nj b">spring.factories</code>文件。该文件应该在<code class="fe ng nh ni nj b">EnableAutoConfiguration</code>键下面列出您的配置类。</p><p id="92eb" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nl mb mc md nm mf mg mh nn mj mk ml im bi translated">对于我们的示例，我们指示Spring Boot将我们的<code class="fe ng nh ni nj b">SampleAutoConfiguration</code>类作为<code class="fe ng nh ni nj b">EnableAutoConfiguration</code>的候选类加载到我们的<code class="fe ng nh ni nj b">META-INF/spring.factories</code>中:</p><pre class="kj kk kl km gt nq nj nr ns aw nt bi"><span id="6730" class="nu kz it nj b gy nv nw l nx ny">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.github.wenqiglantz.library.sample.config.SampleAutoConfiguration</span></pre><p id="90ef" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nl mb mc md nm mf mg mh nn mj mk ml im bi translated">一旦我们的自定义启动器库被创建，我们就可以开始在需要调用我们的自定义启动器库的微服务中使用它，只需添加一个引用我们的新自定义启动器库的新依赖项，就像我们如何添加任何常规的Spring Boot启动器库一样。</p><p id="5871" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nl mb mc md nm mf mg mh nn mj mk ml im bi translated">定制Spring Boot启动器的样本可以在GitHub 上找到<a class="ae nk" href="https://github.com/wenqiglantz/sample-spring-boot-starter" rel="noopener ugc nofollow" target="_blank">。此示例用作要创建的新自定义库的模板。它除了提供上述所有功能外，还提供:</a></p><ul class=""><li id="2298" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">确保编码风格自动化的checkstyle maven插件</li><li id="5cd4" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">确保单元测试覆盖率的jacoco maven插件</li><li id="3b07" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">依赖性检查插件，以确保我们的库中不包含有漏洞的第三方库</li></ul><h1 id="00a2" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">依赖层次结构</h1><p id="7931" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">该示例服务库的完成的依赖关系层次结构如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c0d90d760a9bf9c42815e75be6116793.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*bhw0x_GUCNZZjhXwm4eaSA.png"/></div></figure><h1 id="620e" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">Monorepo存放自定义库</h1><p id="cd74" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">谷歌、脸书和优步等工程领先的公司已经将monorepos作为其基础设施的核心部分，引发了一阵采用热潮。让我们来看看使用monorepo来存放我们的定制库的优缺点。</p><h2 id="ea0c" class="nu kz it bd la oa ob dn le oc od dp li lz oe of lk md og oh lm mh oi oj lo ok bi translated">赞成的意见</h2><ul class=""><li id="5052" class="mm mn it ls b lt lu lw lx lz nd md ne mh nf ml mt mu mv mw bi translated">跨团队更好的可见性和协作。Monorepo使定制库更容易被发现和利用。这鼓励协作和代码重用，这可以减少技术债务。</li><li id="73e0" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">简化的依赖性管理。Monorepos有助于简化内部和第三方依赖性管理。它有助于解决挑战，如<a class="ae nk" href="https://jlbp.dev/what-is-a-diamond-dependency-conflict#:~:text=A%20diamond%20dependency%20conflict%20is,features%20that%20the%20consumers%20expect." rel="noopener ugc nofollow" target="_blank">钻石依赖问题</a>以及多个项目具有相同依赖的多个版本的问题。</li><li id="a728" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">大规模代码重构。monorepos允许我们通过一次提交来处理利用特性的服务，而不是必须在多个项目中进行多次PR来重构一个特定的特性。</li><li id="8cf6" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">简化版本。当构建一个新版本时，我们为所有的库创建相同的版本，所以当使用这些库时，我们可以为所有的库创建一个单一的版本。</li></ul><h2 id="6bd3" class="nu kz it bd la oa ob dn le oc od dp li lz oe of lk md og oh lm mh oi oj lo ok bi translated">骗局</h2><ul class=""><li id="ccba" class="mm mn it ls b lt lu lw lx lz nd md ne mh nf ml mt mu mv mw bi translated">修建管道。对于拥有大型代码库的团队来说，确保您的构建是一个挑战。脸书和谷歌都开发了自己的构建工具(分别是Buck和Bazel ),来帮助管理他们庞大的monorepos的构建过程。幸运的是，Buck和Bazel都是开源的，所以如果您使用monorepo，就可以利用它们。</li><li id="50b7" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">VCS工装挑战。拥有大量代码和数百万次提交的组织可能会面临git性能下降的问题。</li><li id="2acd" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">关于访问控制的限制。有了monorepo，开发人员将可以看到其中的所有代码。限制对特定图书馆的访问并不容易。</li><li id="0b5d" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">开源漏洞优先级和许可。尽管monorepos可以使管理开源依赖关系变得更容易，但它们可能会使漏洞修复的优先级排序和生成特定于产品的属性报告的过程变得复杂。您需要将软件组合分析(SCA)或开源管理软件与构建系统集成起来，以了解用于构建每个产品的文件和依赖关系。</li></ul><h1 id="d633" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">摘要</h1><p id="11b9" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在这个故事的开始，我们探讨了支持和反对定制库的论点。然后我们看了为什么Spring Boot入门框架非常适合开发定制库。接下来，我们查看了使用Spring Boot启动器开发定制库的一步一步的说明。</p><p id="5727" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nl mb mc md nm mf mg mh nn mj mk ml im bi translated">示例代码可以在<a class="ae nk" href="https://github.com/wenqiglantz/sample-spring-boot-starter" rel="noopener ugc nofollow" target="_blank"> my GitHub repository </a>中找到。</p><p id="c8c5" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nl mb mc md nm mf mg mh nn mj mk ml im bi translated">编码快乐！</p><h1 id="65b4" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">参考</h1><p id="59ed" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><a class="ae nk" href="https://docs.spring.io/spring-boot/docs/2.6.7/reference/htmlsingle/#features.developing-auto-configuration" rel="noopener ugc nofollow" target="_blank"> Spring Boot参考文献</a></p><p id="f82b" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nl mb mc md nm mf mg mh nn mj mk ml im bi translated"><a class="ae nk" href="https://medium.com/duda/shared-libraries-design-and-best-practices-710774ae0bdc" rel="noopener">微服务共享库——设计和最佳实践</a></p><p id="5e9b" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nl mb mc md nm mf mg mh nn mj mk ml im bi translated"><a class="ae nk" href="https://fossa.com/blog/pros-cons-using-monorepos/" rel="noopener ugc nofollow" target="_blank">使用Monorepos — FOSSA的利与弊</a></p></div></div>    
</body>
</html>