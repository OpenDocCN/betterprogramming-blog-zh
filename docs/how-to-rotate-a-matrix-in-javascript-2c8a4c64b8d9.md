# 面试问题:如何在 JavaScript 中旋转矩阵

> 原文：<https://betterprogramming.pub/how-to-rotate-a-matrix-in-javascript-2c8a4c64b8d9>

## 为你的下一次面试赢得先机

![](img/aea732d6a37b96fa8ea69291238fbbee.png)

图片来自 [Pixabay](https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1381230) 的 [Bessi](https://pixabay.com/users/Bessi-909086/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1381230) 。

这个问题的一个版本可以在 [LeetCode 的顶级面试问题简易集](https://leetcode.com/explore/interview/card/top-interview-questions-easy/92/array/770/)中找到(需要账号)。我讨厌编程中的“容易”这个词。总是相对的。但是如果你以前解决过一些技术面试问题，你也可以解决这个问题。

这个问题经常伴随着旋转必须“在原位”完成的规定，这意味着我们需要修改原始矩阵，而不是生成新的矩阵。

# 问题是

矩阵是数组的数组。例如，数字图像本质上是矩阵，每个像素是阵列的一个单元，并且每个阵列垂直堆叠。这就是为什么这个问题也被称为旋转图像。

这是一个矩阵的例子。左边是输入，右边是所需的输出:

```
[                       [
  [0,1,2],                [6,3,0], 
  [3,4,5],     //=>       [7,4,1],
  [6,7,8]                 [8,5,2]
]                       ]
```

我承认我一开始被这个问题难住了，因为我试图通过对每个单元只做一次变换来找到一种变换矩阵的方法。可以通过一次旋转四个细胞来实现。看这个例子，我们可以看到有两组四个——角(`1`、`2`、`8`和`6`)和边(`1`、`5`、`7`和`3`)。对于更大的矩阵，将会有更多的这种四个一组的矩阵。这些集合中的任何一个都可以在它们之间独立旋转，而不必担心矩阵的其余部分。

这种方法在时间复杂度方面可能更有效，但是我还没有看到它的代码效率实现。它需要写太多的行，这使得它不太适合技术面试，除非特别要求。因此，我不会介绍这种方法。

# 转置和反转

最后，我将向您展示一个非常好、非常简单的解决方案，它可以使用嵌套的`.map`语句一次性旋转图像。学习捷径真的很有价值，值得，但不是一切。直接跳到一个简短的、记忆的解决方案会剥夺你通过你的逻辑说话的机会，而这正是好的面试官想要看到的。此外，如果你在循序渐进地讨论解决方案时犯了小错误(每个人都会犯)，面试官可以帮你发现它们。你将有机会向他们提问，这样他们不仅可以引导你找到任何解决方案，还可以引导你找到他们想要的解决方案。

这就是为什么我将重点放在依赖于两个操作的解决方案上:`transpose`和`reverse`。

```
const rotate = matrix => reverse(transpose(matrix));
```

这就是我们的解决方案！好吧，不完全是。这是我将要使用的最后一个`rotate`，但是在它里面，我使用了两个还没有被编写的辅助函数:`transpose`和`reverse`。

注意:此解决方案将顺时针旋转矩阵 90 度。最后，我将展示如何仅使用相同的`transpose`和`reverse`函数逆时针旋转矩阵。

`transpose`是什么意思？在矩阵的上下文中，这意味着翻转每个值的 x 和 y 坐标。右上角的值`matrix[0][2]`变成左下角的值`matrix[2][0]`，反之亦然。该操作应该像这样转换矩阵:

```
[                       [
  [0,1,2],                [0,3,6], 
  [3,4,5],     //=>       [1,4,7],
  [6,7,8]                 [2,5,8]
]                       ]
```

要交换右上和左下的值，我们可以运行以下操作:

```
let temp = matrix[2][0]
matrix[2][0] = matrix[0][2]
matrix[0][2] = temp
```

我们需要多次运行这个操作，尽管不是对矩阵中的每个单元。如果我们从矩阵的左上角到右下角画一条穿过矩阵中间的线，并且只查看矩阵的左下半部分中的值，我们可以将这些值与右上角的值对进行交换。如果我们在每个单元上运行交换操作，我们将交换矩阵，然后再去交换矩阵，这将一无所获。

下面是最后一个`transpose`函数:

为了将矩阵的右上半部分排除在循环之外，我们将内部循环的上限设置为外部循环当前行的索引(第 3 行的`column < row`)。这也有排除左上到右下对角线中间行的好处，在那里不需要做任何工作。

编写我们的反函数要简单得多，这取决于你或面试官想让它有多难。我们不能在整个矩阵上调用`.reverse()`,因为那样会垂直翻转矩阵。要水平翻转它，我们需要在矩阵中的每个数组上调用`.reverse()`:

```
const reverse = matrix =>  matrix.map(row => row.reverse());
```

面试官可能会说也可能不会说像`.reverse()`这样的高阶功能是禁止的。关于这方面的更多内容，我将参考约瑟夫·卡迪罗的文章关于编写你自己的`reverse`操作。

剩下的就是把这些碎片拼起来。要顺时针旋转 90 度，我们需要首先转置，然后反转我们的矩阵，这就是我们如何得到这一节顶部的单行`rotate`函数。因为我认为这个解决方案在一行上看起来很好，所以我写了这些帮助函数来返回转置或反转的矩阵，允许我们将原始矩阵传递到`transpose`，我们将直接传递到`reverse`。

要逆时针旋转，我们只需要先反转，然后转置:

```
const rotate = matrix => transpose(reverse(matrix));
```

# 一体化解决方案:嵌套。地图()s

```
const rotate = matrix => {
  return matrix.map((row, i) =>
    row.map((val, j) => matrix[matrix.length - 1 - j][i])
  );
};
```

我不会深入研究这个解决方案，因为有几层要解开。对于“旋转矩阵”问题的“嵌套贴图”解决方案，你可以找到其他的解释，以及我在这里没有提到的其他解决方案。

在我看来，我在这里关注的解决方案是面试中最好的解决方案。不算太长，可读性还算不错，而且如果你能记住这两个运算(`transpose`和`reverse`)的概念和作用，就可以当场从头重构问题，而不用背什么代码。最终，在练习面试问题时，这种理解对我们最有帮助。