<html>
<head>
<title>What’s New in Swift 5.6 and 5.7</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 5.6和5.7的新功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-to-swift-5-6-and-5-7-6b08195d2917?source=collection_archive---------4-----------------------#2022-02-23">https://betterprogramming.pub/whats-new-to-swift-5-6-and-5-7-6b08195d2917?source=collection_archive---------4-----------------------#2022-02-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="84ff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解Swift 5.6和5.7的下一步发展</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/e93c0c8b43722499526a015e1c3e156c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*u6s2mrKqy6CSO8aybgS0HQ.png"/></div></figure><h1 id="d9b7" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">Swift 5.6</h1><p id="4157" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Swift 5.6于2021年11月发布，预计将很快问世。让我们快速浏览一下这门语言的新内容。</p><h2 id="1ee4" class="me kr it bd ks mf mg dn kw mh mi dp la lr mj mk lc lv ml mm le lz mn mo lg mp bi translated"><a class="ae mq" href="https://github.com/apple/swift-evolution/blob/main/proposals/0290-negative-availability.md" rel="noopener ugc nofollow" target="_blank"> SE-0290 </a>:不可用关键字</h2><p id="dc30" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用新的<code class="fe mr ms mt mu b">#unavailable</code>关键字编写反向可用性条件的可能性。例如，假设我们的应用程序支持iOS 13之前的大量iOS版本，我们必须手动加载主窗口。因此，在Swift 5.6之前，我们将采取如下措施:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0423" class="pw-post-body-paragraph li lj it lk b ll mx ju ln lo my jx lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">现在，借助Swift 5.6，我们可以做更具可读性的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="5985" class="me kr it bd ks mf mg dn kw mh mi dp la lr mj mk lc lv ml mm le lz mn mo lg mp bi translated">SE-0315 :键入占位符</h2><p id="918e" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">“类型占位符”,它指导编译器根据通常的类型推断规则来填充类型的该部分。类型占位符拼写为下划线(“<code class="fe mr ms mt mu b">_</code>”)。例如，让我们定义一个<code class="fe mr ms mt mu b">UIColors</code>的字典，然后让5.6 Swift编译器推断类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="0e09" class="me kr it bd ks mf mg dn kw mh mi dp la lr mj mk lc lv ml mm le lz mn mo lg mp bi translated"><a class="ae mq" href="https://github.com/apple/swift-evolution/blob/main/proposals/0320-codingkeyrepresentable.md" rel="noopener ugc nofollow" target="_blank"> SE-0320 </a>:字典编码改进</h2><p id="5470" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到目前为止，字典编码令人惊讶地受到限制，只允许使用<code class="fe mr ms mt mu b">Int</code>或<code class="fe mr ms mt mu b">String</code>类型作为键。这个提议引入了一个名为<code class="fe mr ms mt mu b">CodingKeyRepresentable</code>的全新协议，它允许你拥有符合这个协议的任何类型的可编码字典键。在下面的例子中，我创建了一个符合这个协议的自定义类型<code class="fe mr ms mt mu b">ID</code>，它需要提供一个<code class="fe mr ms mt mu b">codingKey</code>和一个带有通用编码键的init。那么对具有类型<code class="fe mr ms mt mu b">ID</code>的键的字典进行编码就变得简单了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="8610" class="me kr it bd ks mf mg dn kw mh mi dp la lr mj mk lc lv ml mm le lz mn mo lg mp bi translated"><a class="ae mq" href="https://github.com/apple/swift-evolution/blob/main/proposals/0337-support-incremental-migration-to-concurrency-checking.md" rel="noopener ugc nofollow" target="_blank"> SE-0337 </a>:支持并发迁移</h2><p id="caa7" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Swift 5.5引入了从语言中消除数据竞争的机制，包括<code class="fe mr ms mt mu b">Sendable</code>协议来指示哪些类型具有可以跨任务和参与者边界安全使用的值。然而，Swift 5.5并不强制使用<code class="fe mr ms mt mu b">Sendable</code>，而是可选的，这意味着数据竞争可能会发生。因此，这个建议意味着默认情况下编译器将检查这些可能发生的数据竞争。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="965e" class="me kr it bd ks mf mg dn kw mh mi dp la lr mj mk lc lv ml mm le lz mn mo lg mp bi translated">存在主义<code class="fe mr ms mt mu b">any</code></h2><p id="2d37" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Swift现在允许使用<code class="fe mr ms mt mu b">any</code>关键字显式编写存在类型，从而在存在类型和协议一致性约束之间创建了语法区别。在Swift 5中，现在任何可以使用存在类型的地方，<code class="fe mr ms mt mu b">any</code>关键字都可以用来明确表示存在类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b495" class="pw-post-body-paragraph li lj it lk b ll mx ju ln lo my jx lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">在Swift 6中，存在类型需要用<code class="fe mr ms mt mu b">any</code>明确拼写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="f37d" class="kq kr it bd ks kt nj kv kw kx nk kz la jz nl ka lc kc nm kd le kf nn kg lg lh bi translated">Swift 5.7</h1><p id="6f66" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Swift 5.7对不透明类型做了一些小的改进，以提高可读性和可见性。让我们快速浏览一下这些变化。</p><h2 id="214a" class="me kr it bd ks mf mg dn kw mh mi dp la lr mj mk lc lv ml mm le lz mn mo lg mp bi translated"><a class="ae mq" href="https://github.com/apple/swift-evolution/blob/main/proposals/0341-opaque-parameters.md" rel="noopener ugc nofollow" target="_blank"> SE-0341 </a>:不透明功能参数</h2><p id="0479" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不透明类型现在可以用在函数和下标的参数中，它们为泛型参数的引入提供了一种简化的语法。这一更改从函数声明中删除了大量样板代码。在这个新变化到来之前，我们发现自己编写了如下的通用函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="bd9f" class="pw-post-body-paragraph li lj it lk b ll mx ju ln lo my jx lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">这个提议将不透明结果类型的语法扩展到参数，允许指定通用的函数参数，而不需要与通用参数列表相关联的样板文件。上面的<code class="fe mr ms mt mu b">horizontal</code>函数可以表示为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="def5" class="me kr it bd ks mf mg dn kw mh mi dp la lr mj mk lc lv ml mm le lz mn mo lg mp bi translated"><a class="ae mq" href="https://github.com/apple/swift-evolution/blob/main/proposals/0328-structural-opaque-result-types.md" rel="noopener ugc nofollow" target="_blank"> SE-0328 </a>:结构不透明的结果类型</h2><p id="9792" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与上面的非常相似，现在我们可以使用不透明类型作为函数的结果类型，变量的类型，或者下标的结果类型。在所有情况下，不透明结果类型必须是整个类型。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="7634" class="pw-post-body-paragraph li lj it lk b ll mx ju ln lo my jx lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">希望你喜欢并发现这篇文章有用。</p></div></div>    
</body>
</html>