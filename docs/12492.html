<html>
<head>
<title>A Comprehensive Guide to Flutter’s BLoC Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter块架构综合指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-comprehensive-guide-to-flutters-bloc-architecture-d2d16022b0b9?source=collection_archive---------0-----------------------#2022-06-09">https://betterprogramming.pub/a-comprehensive-guide-to-flutters-bloc-architecture-d2d16022b0b9?source=collection_archive---------0-----------------------#2022-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f6dd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">和Redux类似吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b1329539b287762925dc2c95cdda06bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*40JEym29BWfisZVj"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">詹姆斯·温斯科特在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="eca1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">BLoC架构在Flutter社区已经存在了一段时间，我们可以有把握地说社区喜欢它。该模式如何让我们隔离我们的逻辑，并使其更具可测试性，仅仅是通过在我们的应用程序中做一些改变，这是非常棒的东西。</p><p id="8762" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我们将通过创建一个简单的应用程序来学习BLoC概念及其整体流程，在本教程结束时，我们应该已经能够编写实现BLoC架构的应用程序。</p><blockquote class="ls lt lu"><p id="6960" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">我们将在本教程中使用的BLoC版本是8.0.1(撰写本文时的最新版本)</p></blockquote><h1 id="bb06" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">关于集团的一些理论</h1><p id="c280" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">BLoC体系结构有三个核心组件:</p><ol class=""><li id="fe79" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">状态是我们的页面或应用程序可能存在的每一个条件。例如，如果我们从一个页面获取API，那么我们的页面将至少有三种状态:</li></ol><ul class=""><li id="79b3" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nf nc nd ne bi translated">在这种情况下，我们可能希望在页面上显示一个加载器，这样用户就知道我们正在试图获取一些数据。</li><li id="708c" class="mw mx iq ky b kz nk lc nl lf nm lj nn ln no lr nf nc nd ne bi translated"><code class="fe ng nh ni nj b">ErrorFetchDataState<br/></code>在这种状态下，我们可能想要显示一个错误文本，一个重试按钮，或者显示一个警告，通知用户我们的网络调用出现了问题。</li><li id="837a" class="mw mx iq ky b kz nk lc nl lf nm lj nn ln no lr nf nc nd ne bi translated"><code class="fe ng nh ni nj b">SuccessFetchDataState<br/></code>在这种状态下，我们可以根据从响应中获得的数据显示卡片或数据的列表。</li></ul><ol class=""><li id="1eaf" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">事件<br/>事件是UI为了改变我们的页面状态而发送的动作(听起来很熟悉，redux开发者？)</li><li id="9b35" class="mw mx iq ky b kz nk lc nl lf nm lj nn ln no lr nb nc nd ne bi translated">BloC充当动作处理器和状态变异器，我们也可以在这里处理我们的业务逻辑，例如获取API，存储共享的首选项等等。有人称他们为减压器。</li></ol><p id="2a24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">从它的概念理论来看，BLoC与redux或composable architecture非常相似，所以如果你碰巧理解了其中的一个，你就基本上理解了BLoC。</em></p><h1 id="1e63" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">让我们编码</h1><p id="8c4e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">导航到您选择的代码编辑器，用您想到的任何名称创建一个新的Flutter项目。然后，在Flutter为我们创建完样板文件后，像这样在<code class="fe ng nh ni nj b">pubspec.yaml</code>中添加<code class="fe ng nh ni nj b">flutter_bloc</code>依赖项。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="af0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用此代码替换<code class="fe ng nh ni nj b">main.dart</code>上的所有内容</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="edb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，我们创建了一个主屏幕小部件，在页面中央有一个按钮。非常简单。</p><p id="2982" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们接下来要做的是，我们将为我们的应用程序添加几个功能，我们最终的应用程序可以根据我们从API获得的响应显示食品卡列表或错误消息。</p><p id="fced" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">为了简单起见，我们不会触及任何真正的端点，我们只是在用户每次按下按钮时随机产生结果。</em></p><p id="6a86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个名为<code class="fe ng nh ni nj b">food.dart</code>的新文件，这个文件将包含我们的食品卡的模型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c455" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建另一个名为<code class="fe ng nh ni nj b">food_generator.dart</code>的新文件，该文件将为我们提供应用程序上显示的所有虚拟数据。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3beb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，让我们继续我们的第一个与BLoC相关的代码，在这里我们将为我们的状态和事件创建类。</p><p id="95e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个名为<code class="fe ng nh ni nj b">home_state.dart</code>的新文件，并在文件中添加以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="403d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从需求来看，我们的app目前只能做一件事，就是在按钮按下的时候尝试取数据。由此，我们可以想象我们的页面至少应该有三种状态:</p><ol class=""><li id="15c4" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated"><code class="fe ng nh ni nj b">HomeLoadingState</code> <br/>这是我们等待API响应时的状态，我们可能想要显示某种加载器指示器或闪烁器，让用户知道它仍在处理。</li><li id="2084" class="mw mx iq ky b kz nk lc nl lf nm lj nn ln no lr nb nc nd ne bi translated"><code class="fe ng nh ni nj b">HomeErrorFetchDataState</code> <br/>这是当我们从API收到一个错误时，我们可能想要显示一个警告或者显示一些错误小部件。</li><li id="5f89" class="mw mx iq ky b kz nk lc nl lf nm lj nn ln no lr nb nc nd ne bi translated"><code class="fe ng nh ni nj b">HomeSuccessFetchDataState</code> <br/>这是当我们成功地从API接收到我们的食物数据时，我们可能想要在这里显示食物卡的列表。</li></ol><p id="26f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了上面提到的三个状态，我们还必须创建另一个<code class="fe ng nh ni nj b">HomeInitialState</code>。这是页面的第一个状态，因为我们不想在用户查看页面时显示加载器。以下是更多相关信息。</p><p id="3ab0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们应该定义页面可以发送的动作，你可以想象动作是触发状态变化的任何东西。创建一个名为<code class="fe ng nh ni nj b">home_event.dart</code>的新文件，并在下面添加代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="4bcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们的主页目前只能做一件事，获取数据，我们必须创建这个获取数据事件作为我们的<code class="fe ng nh ni nj b">HomeEvent</code>之一。记住发送事件是我们的小部件告诉BLoC他们想要做什么的方式。</p><p id="5e4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果您想在我们查看页面时点击追踪器，您可以在这里添加另一个事件。</p><p id="3a26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们必须创建一个BloC类，这个类充当一个动作处理器，执行所有的业务逻辑，并通过它的状态构造将结果返回给我们的页面。创建一个名为<code class="fe ng nh ni nj b">home_bloc.dart</code>的新文件，并添加以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">home_bloc.dart</p></figure><p id="cd5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe ng nh ni nj b">HomeBloc</code>扩展了base Bloc类，它需要两个参数:我们的事件和状态类。这是为了告诉Bloc我们正在分别处理HomeEvent和HomeState类型的事件和状态，这回答了我们为什么将它们创建为抽象类的问题。</p><p id="076c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在构造函数内部，我们应该通过它的超级构造函数为类提供初始状态。因为我们在第一次查看页面时没有做任何事情，所以我们可以创建另一个空状态，在本例中是<code class="fe ng nh ni nj b">HomeInitialState</code>。</p><p id="d3c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">但是，例如，如果您想在用户打开页面时直接显示shimmer，您可以考虑在构造函数中将</em> <code class="fe ng nh ni nj b"><em class="lv">HomeLoadingState</em></code> <em class="lv">设置为其初始状态。</em></p><p id="27f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在超级构造函数闭包内，我们必须列出所有可能发送到我们的<code class="fe ng nh ni nj b">HomeBloc</code>的事件，因为我们只有一个动作，所以我们只放一个。或者如果你喜欢更友好的解释，第6行可以这样理解:</p><p id="0ab8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">当HomeBloc收到一个</em> <code class="fe ng nh ni nj b"><em class="lv">FetchDataEvent</em></code> <em class="lv">时，它会尝试通过执行给它的处理程序来处理事件，这里是</em> <code class="fe ng nh ni nj b"><em class="lv">_onFetchDataEvent</em></code> <em class="lv">函数。</em></p><p id="d6fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们在<code class="fe ng nh ni nj b">_onFetchDataEvent</code>里面做什么？</p><p id="5a80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，我们希望获取数据并将响应返回到我们的主页。在这种情况下，我将延迟函数执行两秒钟来模拟网络调用，并生成一个随机布尔值来确定我们得到的是食物列表还是错误。</p><p id="5fa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在处理所有这些逻辑的同时，我们希望在页面上显示一个加载程序，因此算法如下:</p><ol class=""><li id="27d0" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">将状态更改为<code class="fe ng nh ni nj b">HomeLoadingState</code></li><li id="1f29" class="mw mx iq ky b kz nk lc nl lf nm lj nn ln no lr nb nc nd ne bi translated">延迟功能执行两秒钟以模拟网络呼叫</li><li id="0dc3" class="mw mx iq ky b kz nk lc nl lf nm lj nn ln no lr nb nc nd ne bi translated">random a boolean，如果为真，我们将状态更改为<code class="fe ng nh ni nj b">HomeSuccessFetchDataState</code>，带来一个虚拟食物列表，否则，我们将状态更改为<code class="fe ng nh ni nj b">HomeErrorFetchDataState</code>。</li></ol><p id="c6f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对<code class="fe ng nh ni nj b">_onFetchDataEvent</code> <em class="lv"> </em>功能增加一些修改:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ceb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">恭喜你！我们刚刚完成了我们的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr nq l"/></div></figure><p id="2361" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后要做的一件事是修改我们的小部件(主屏幕),以便它可以监听BLoC内部发生的状态变化。完成后，我们可以根据我们的状态相应地更改我们的UI(例如，当错误发生时显示一些重试按钮，等等)。).</p><p id="f56c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，集团图书馆为我们提供了保护。我们所要做的就是将我们的小部件包装在一个<code class="fe ng nh ni nj b">BlocConsumer</code>小部件中，然后我们就可以开始了！</p><p id="9242" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">导航至<code class="fe ng nh ni nj b">main.dart</code>并将代码更改如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="4ae6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">BlocConsumer要求我们定义两个属性，即监听器和构建器。</p><p id="5f24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次状态改变时，都会触发构建器代码块。所以我们要列出所有可能的状态，这也是为什么我们能看到很多<code class="fe ng nh ni nj b">if state is</code>；这是因为我们必须具体处理每个状态。</p><p id="6163" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当状态改变时，监听器块也将被执行。监听器和构建器的区别在于，构建器希望我们返回一个小部件。换句话说，<code class="fe ng nh ni nj b">what kind of UI you want to show to the user when the state is X, Y, or Z</code>。另一方面，侦听器不要求我们返回一个小部件。这是我们做副作用的地方，比如显示警告，小吃店，点击跟踪器等。</p><p id="c960" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在构建器中的每个状态上添加小部件，这样我们的主屏幕就像下面这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7c38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe ng nh ni nj b">HomeLoadingState</code>，我只是返回了一个<code class="fe ng nh ni nj b">CircularActivityIndicator</code>作为<code class="fe ng nh ni nj b">HomeSuccessFetchDataState</code>的加载器，我返回了一个<code class="fe ng nh ni nj b">ListView</code>以便用户可以看到我们所有的食物，并且我们返回了一个错误文本，在<code class="fe ng nh ni nj b">ErrorState</code>上有一个重试按钮。</p><p id="5340" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们必须将我们的<code class="fe ng nh ni nj b">HomeScreen</code>包装在<code class="fe ng nh ni nj b">runApp</code>函数的<code class="fe ng nh ni nj b">BlocProvider</code>中。这样做是为了给<code class="fe ng nh ni nj b">HomeScreen</code>及其所有子节点提供对bloc的访问。否则，我们将收到一条错误消息，指出找不到该块。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="63b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，为了做到这一点，我们还必须在home小部件上添加发送事件功能。我们必须在主屏幕小部件中获取<code class="fe ng nh ni nj b">HomeBloc</code>，因为我们已经通过<code class="fe ng nh ni nj b">BlocProvider</code>提供了它们，所以我们可以从上下文中读取它们。</p><p id="c9ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在主屏幕小部件中添加一个<code class="fe ng nh ni nj b">HomeBloc</code>属性和一个<code class="fe ng nh ni nj b">initState</code>函数，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c0b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，在每个<code class="fe ng nh ni nj b">onPressed</code>函数中添加事件发送代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="fc37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们最终的<code class="fe ng nh ni nj b">main.dart</code>将是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ca0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">试着运行这个应用程序，瞧！，我们的应用程序应该完成的要求履行！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/cc8aa337ce827a931a5032b75afe25ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*Dm-foUWr3-c9yHy2suNVzw.gif"/></div></figure><h1 id="3397" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="de30" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">BLoC与redux或composable architecture非常相似，它们都有一个充当动作处理程序的实例，我们在其中处理所有的业务逻辑。并且UI发送状态变化动作并监听状态变化以执行必要的更新。</p><p id="53ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在我的存储库中找到完成的代码:</p><div class="nt nu gp gr nv nw"><a href="https://github.com/aryasurya21/bloctorial/tree/completed" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">GitHub-aryasurya 21/bloctorial at已完成</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">一个新的颤振项目。这个项目是颤振应用的起点。一些帮助您入门的资源…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">github.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok kp nw"/></div></div></a></div><p id="5bb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在他们官方文档中了解更多关于BLoC的信息:</p><div class="nt nu gp gr nv nw"><a href="https://bloclibrary.dev/#/flutterbloccoreconcepts" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">阻塞状态管理库</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">集团国家管理图书馆的官方文件。支持镖，扑，角。包括…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">bloclibrary.dev</p></div></div><div class="of l"><div class="ol l oh oi oj of ok kp nw"/></div></div></a></div><p id="20be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编码快乐！</p></div></div>    
</body>
</html>