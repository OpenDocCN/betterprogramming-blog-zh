<html>
<head>
<title>Rust Error Handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust错误处理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rust-error-handling-84e7bd169e47?source=collection_archive---------10-----------------------#2020-05-06">https://betterprogramming.pub/rust-error-handling-84e7bd169e47?source=collection_archive---------10-----------------------#2020-05-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="926c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何安全正确地处理Rust中的错误</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/42eaacdcdc26f5dcab7c992399ede4f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0ZSzAAg-g85bBIwb"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@mattartz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马特·阿特兹</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="d9b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">铁锈没有例外。它使用<code class="fe ls lt lu lv b">Result</code>枚举，它是Rust标准库的一部分，用于表示成功(<code class="fe ls lt lu lv b">Ok</code>)或失败(<code class="fe ls lt lu lv b">Err</code>):</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="ea52" class="ma mb iq lv b gy mc md l me mf">enum Result&lt;T,E&gt; {<br/>    Ok(T),<br/>    Err(E),<br/>}</span></pre><p id="1f47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你在编写函数并需要处理潜在的问题时，你可以使用<code class="fe ls lt lu lv b"><a class="ae kv" href="https://doc.rust-lang.org/std/macro.panic.html" rel="noopener ugc nofollow" target="_blank">panic</a></code> <a class="ae kv" href="https://doc.rust-lang.org/std/macro.panic.html" rel="noopener ugc nofollow" target="_blank">(宏)</a>退出程序。这应该很少见。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="5fc0" class="mn mb iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated"><code class="fe ls lt lu lv b">panic</code></h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0792" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，如果随机数大于5，我们称之为<code class="fe ls lt lu lv b">panic!</code>。</p><p id="ab76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让我们的意图更加清晰，我们可以返回一个<code class="fe ls lt lu lv b">Result</code>。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="3213" class="mn mb iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">使用<code class="fe ls lt lu lv b">Result</code></h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4700" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，如果数字小于或等于5，我们返回<code class="fe ls lt lu lv b">Ok</code>变量。否则，我们返回一个带有<code class="fe ls lt lu lv b">String</code>消息的<code class="fe ls lt lu lv b">Err</code>。</p><p id="135d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用一个<code class="fe ls lt lu lv b"><a class="ae kv" href="https://doc.rust-lang.org/std/option/enum.Option.html" rel="noopener ugc nofollow" target="_blank">Option</a></code>返回类型，但是在这种情况下，我们使用<code class="fe ls lt lu lv b">Result</code>，因为<code class="fe ls lt lu lv b">a number greater than five</code>是一个错误的场景(在我们虚构的用例中)。</p><p id="266c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了一个返回<code class="fe ls lt lu lv b">Result</code>的方法，让我们研究一下调用者如何使用这个方法。有几个选项:</p><ul class=""><li id="5526" class="ng nh iq ky b kz la lc ld lf ni lj nj ln nk lr nl nm nn no bi translated">使用<code class="fe ls lt lu lv b">panic!</code>。</li><li id="a5fa" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">承认问题并处理它。</li><li id="7d4a" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">传下去。</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="713f" class="mn mb iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated"><code class="fe ls lt lu lv b">panic</code>(又来了！)</h1><p id="25dd" class="pw-post-body-paragraph kw kx iq ky b kz nu jr lb lc nv ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">这是处理问题最简单的方式，但往往是最不可取的方式。恐慌是个糟糕的主意。我们可以让它变得更好。</p><h2 id="c94e" class="ma mb iq bd mo nz oa dn ms ob oc dp mw lf od oe my lj of og na ln oh oi nc oj bi translated"><strong class="ak">使用expect </strong></h2><p id="fc93" class="pw-post-body-paragraph kw kx iq ky b kz nu jr lb lc nv ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><a class="ae kv" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect" rel="noopener ugc nofollow" target="_blank">expect</a></code>是捷径。这是一个在<code class="fe ls lt lu lv b">Result</code>上可用的方法，如果可用的话，它返回来自<code class="fe ls lt lu lv b">Ok</code>变体的内容。否则，它用传入的消息和<code class="fe ls lt lu lv b">Err</code>内容<code class="fe ls lt lu lv b">panics</code>。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="afc3" class="ma mb iq lv b gy mc md l me mf">fn caller() -&gt; String {<br/>    let n = gen2().expect("generate failed!");<br/>    n.to_string()<br/>}</span></pre><h2 id="eed5" class="ma mb iq bd mo nz oa dn ms ob oc dp mw lf od oe my lj of og na ln oh oi nc oj bi translated"><strong class="ak">使用展开</strong></h2><p id="6127" class="pw-post-body-paragraph kw kx iq ky b kz nu jr lb lc nv ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated"><code class="fe ls lt lu lv b">unwrap</code>类似于<code class="fe ls lt lu lv b">expect</code>，除了它不允许您指定自定义消息(显示在<code class="fe ls lt lu lv b">panic!</code>上)。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="357d" class="ma mb iq lv b gy mc md l me mf">fn caller() -&gt; String {<br/>    let n = gen2().unwrap();<br/>    n.to_string()<br/>}</span></pre><p id="a8cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以用<code class="fe ls lt lu lv b">unwrap_or()</code>做得更好一点，在出现<code class="fe ls lt lu lv b">Err</code>的情况下用它返回一个默认值:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="b2ff" class="ma mb iq lv b gy mc md l me mf">fn caller() -&gt; String {<br/>    let zero = gen2().unwrap_or(0);<br/>    zero.to_string()<br/>}</span></pre><p id="f326" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，如果出现错误，我们将返回<code class="fe ls lt lu lv b">0</code> ( <code class="fe ls lt lu lv b">String</code>表单)。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="2803" class="mn mb iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">处理问题</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ecba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们在<code class="fe ls lt lu lv b">Result</code>上<code class="fe ls lt lu lv b">match</code>，返回一个<code class="fe ls lt lu lv b">String</code>(使用<code class="fe ls lt lu lv b">i.to_string()</code>)，或者返回<code class="fe ls lt lu lv b">Err</code>内容(在这种情况下恰好也是一个<code class="fe ls lt lu lv b">String</code>)。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="1561" class="mn mb iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">不是我的问题…传下去</h1><p id="232f" class="pw-post-body-paragraph kw kx iq ky b kz nu jr lb lc nv ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">如果您不想处理这个问题，而需要将它传播给调用者(以稍微不同的方式)，该怎么办呢？</p><p id="861d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不返回显式的<code class="fe ls lt lu lv b">String</code>，你可以返回一个<code class="fe ls lt lu lv b">Result&lt;String,String&gt;</code>，其中<code class="fe ls lt lu lv b">Ok</code>变量将包含一个<code class="fe ls lt lu lv b">String</code>结果，而<code class="fe ls lt lu lv b">Err</code>变量也将包含一个解释错误细节的<code class="fe ls lt lu lv b">String</code>结果。</p><p id="ae42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注:A <code class="fe ls lt lu lv b">String</code>也用于表示错误(<code class="fe ls lt lu lv b">Err</code>)。这只是为了保持事情简单。通常，您会使用一种特殊的错误类型(例如<code class="fe ls lt lu lv b">std::io:Error</code>)。</p><p id="aefd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一种方法可以做到:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2b95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将返回类型更改为<code class="fe ls lt lu lv b">Result&lt;String, String&gt;</code>，调用函数和<code class="fe ls lt lu lv b">match</code>(返回一个<code class="fe ls lt lu lv b">Result&lt;i32,String&gt;</code>)。我们所需要的就是确保我们返回了<code class="fe ls lt lu lv b">i32</code>的<code class="fe ls lt lu lv b">String</code>转换。所以我们匹配返回的<code class="fe ls lt lu lv b">Result</code>。如果是<code class="fe ls lt lu lv b">Ok</code>，我们返回另一个<code class="fe ls lt lu lv b">Ok</code>，包含<code class="fe ls lt lu lv b">i32</code>的<code class="fe ls lt lu lv b">String</code>版本(即<code class="fe ls lt lu lv b">Ok(i) =&gt; Ok(i.to_string())</code>)。如果有错误，我们简单地返回它。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="d6be" class="mn mb iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated"><code class="fe ls lt lu lv b">?</code>操作员</h1><p id="3011" class="pw-post-body-paragraph kw kx iq ky b kz nu jr lb lc nv ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">我们可以通过使用<code class="fe ls lt lu lv b">?</code>操作符来进一步简化。这类似于<code class="fe ls lt lu lv b">match</code>过程，其中它返回<code class="fe ls lt lu lv b">Result</code>的<code class="fe ls lt lu lv b">Ok</code>变量中的值，或者通过返回<code class="fe ls lt lu lv b">Err</code>本身退出。在我们的例子中，它的用法如下:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="0f39" class="ma mb iq lv b gy mc md l me mf">fn caller() -&gt; Result&lt;String, String&gt; {<br/>    let n = gen2()?;<br/>    Ok(n.to_string())<br/>}</span></pre><p id="92d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该方法被调用—注意末尾的<code class="fe ls lt lu lv b">?</code>。它所做的只是返回<code class="fe ls lt lu lv b">Ok</code>变量中的值，我们使用<code class="fe ls lt lu lv b">Ok(n.to_string())</code>返回它的<code class="fe ls lt lu lv b">String</code>版本。这就照顾到了<code class="fe ls lt lu lv b">Result</code>的一半(与<code class="fe ls lt lu lv b">Ok</code>的幸福之路)。另一半呢(<code class="fe ls lt lu lv b">Err</code>)？就像我之前提到的，使用<code class="fe ls lt lu lv b">?</code>，所有的事情都在幕后处理，并且<code class="fe ls lt lu lv b">Err</code>会随着它的值自动从函数中返回！</p><p id="2265" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，如果返回<code class="fe ls lt lu lv b">Result</code>或<code class="fe ls lt lu lv b">Option</code>或实现<code class="fe ls lt lu lv b">std::ops::Try</code>的其他类型，则可以使用<code class="fe ls lt lu lv b">?</code>运算符。</p><p id="c3a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe ls lt lu lv b">Err</code>型号不同呢？您可能会遇到要求您在<code class="fe ls lt lu lv b">Result</code>中返回不同错误类型的情况。在这种情况下，您需要为您的错误类型实现<code class="fe ls lt lu lv b">std::convert::From</code>。这不会起作用，因为<code class="fe ls lt lu lv b">Result&lt;String, NewErr&gt;</code>是返回类型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1b27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，您需要告诉Rust如何从<code class="fe ls lt lu lv b">String</code>转换到<code class="fe ls lt lu lv b">NewErr</code>，因为<code class="fe ls lt lu lv b">gen2()</code>函数的返回类型是<code class="fe ls lt lu lv b">Result&lt;String,String&gt;</code>。这可以通过以下方式完成:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="9f71" class="ma mb iq lv b gy mc md l me mf">impl std::convert::From&lt;String&gt; for NewErr {<br/>    fn from(s: String) -&gt; Self {<br/>        NewErr { ErrMsg: s }<br/>    }<br/>}</span></pre></div></div>    
</body>
</html>