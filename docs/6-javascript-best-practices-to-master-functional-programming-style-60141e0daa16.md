# 掌握函数式编程风格的 6 个 JavaScript 最佳实践

> 原文：<https://betterprogramming.pub/6-javascript-best-practices-to-master-functional-programming-style-60141e0daa16>

## 以现代方式使用 JavaScript 函数

![](img/e4f735e766e95fe6375038de2b09d5c4.png)

照片由[塞巴斯蒂安·威利斯](https://unsplash.com/@sebastiancoffee?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

你在这里是为了事实和最佳实践。所以，没有浪费时间的介绍。我们走吧！

> 免责声明:请记住，列出的每一项练习都是 JavaScript 函数式编程的进一步发展。如果你只应用了一个或几个，你的代码就不能完全发挥作用。每一步都可能违反 FP 设计理念，但提供了更好的功能设计。

# **1。**注入——神奇的分类库存

我们将从传递函数作为由`Array.prototype.sort()`方法提供的参数的例子开始。

假设您有一个表示`inventory` *、*的字符串数组，并且您想按字母顺序对其进行排序。您的第一个假设可能是使用如下代码结构:

正如您可能已经观察到的，我们没有向`sort()`方法传递任何参数。但是结果被很好的分类了。

这是因为，默认情况下，该方法根据字符串的 ASCII 内部表示形式对字符串进行排序。

把它和数字一起使用，你就把这个美丽的小数组的整个故事搞砸了:

您必须注入自己的排序算法来实现这一点:

使用一个排序函数作为参数——以一种非常 FP 的方式——也有助于按照给定的属性对对象进行排序。然后我们可以使用一个比较函数。例如，您可以按年龄对人进行排序，大致如下:

```
dementedPeope.sort((a,b) => a.age — b.age))
```

提示:谈论字符串和排序——无论何时处理外语字符串，例如西班牙语，都应该使用`localCompare()`方法，并提供注入以获得正确的顺序。那是因为他们的字母表中有不同的字母。

# **2。**回访、承诺和分手

您可能已经多次使用了即将出现的例子，但是您是否已经增强了这种用法，或者只是停留在良好的旧模式上？

我说的是作为一级对象传递的函数，它们与回调和承诺有关。

在 Node.js 中，读取文件是异步完成的，如下所示:

显然`readFile()`函数想要回调。这一次，我选择了一个匿名函数来完成这项工作。

更进一步意味着你将使用`promise`或`async/await`。

很公平！

但是如果您要使用`fetch()`功能，您可以按以下方式操作:

## **延续传球方式**

到目前为止我给你演示的可以认为是 CPS——延续传球式。

这是因为无论何时调用一个函数，都会传递另一个函数，该函数将在输入/输出操作完成时执行。

考虑一下:如果禁止使用 return 语句，您将如何编码？

乍一看，这似乎是一种不可能的情况，除非允许您向被调用的函数传递回调。当该过程准备返回给调用者时，它将调用传递的回调，而不是实际返回。

在这些术语中，回调提供被调用的函数来继续这个过程，因此也是名称的延续。

这是递归的基石。

总的来说，我们不局限于单一的延续。与承诺一样，您可以随时提供两个或更多的备选回电。不过，这也为另一个问题打开了大门:

你如何处理异常？

抛出一个错误，您就会再次遇到返回问题。

摆脱这种情况的方法是每当抛出异常时提供一个替代回调。另一个真正的函数式编程的解决方案叫做单子。

考虑这个例子来看看这个理论的实际应用:

如你所见，没有`return`声明。

# 3.Polyfills — **使用 Ajax 的超级干净代码**

聚合填充是一段代码，它提供了您希望浏览器本身提供的技术。定义聚合填充时，动态指定函数可提高效率。

这里有一个关于 Ajax 的例子，当调用是不同的方式时。您的任务是编写代码来区分和处理新旧浏览器之间的差异。

上面的代码没有做错什么。它完美地工作。

不过，我不得不说，这意味着每次都要回忆起这个功能，即使什么都没有改变。

一定有更有效的方法来做得更好。

如果应用一级函数的概念呢？

并将其与即时调用函数表达式(IIFE)相结合。使用这种方式，您可以只检查一次条件并分配正确的函数以备将来使用。

这段代码结合了两个重要的概念。

1.  您可以动态地分配一个函数:当这段代码运行时，根据当前的浏览器，全局变量`window.getAjax`将获得三个可能值中的一个。当您稍后在代码中调用`getAjax()`时，正确的函数将会执行，无需进一步的浏览器检测测试。
2.  按照定义`initializeGetAjax()`函数的方式，它会在运行后自动清理。所以它所有的局部变量在函数运行后都不存在了。

您可能认为 Ajax 示例已经过时了。但是考虑一下使用现代的`fetch()`方式调用服务的事实。你还会发现，并不是所有的现代[浏览器都支持所有提供的方法](https://caniuse.com/?search=fetch)。

你要用一个多孔填充物来修复它，[就像这个](https://github.com/github/fetch)。如果你检查代码，你会看到一些非常熟悉的策略。当然，看完这篇文章。

# **4。**添加缺失的功能

运行中定义函数的想法也允许我们编写 polyfill*来提供其他缺失的函数。举一个不太好但很常见的例子:*

*通过使用更新、更清晰的方式和利用`include`方法，我们会过得更好:*

*好吧，等等！如果我或我的团队也必须支持不能使用`include()`的旧浏览器，会发生什么？*

*我抓住你了！我们可以这样定义运行中的函数:*

*这个程序实际上检查了`String`的`prototype`是否定义了`include`方法。*

*如果没有，我们为`prototype`创建一个新的属性，并为它分配一个函数。*

*最终创造出我们自己的自制`include()`方法。*

# ***5。不仅仅是你的脚趾***

*Stubbing 与 polyfills 有一些非常相似的方面。*

*它始于拥有一个根据环境支持做不同事情的功能。*

*存根的一般概念来自源代码测试领域，用于将一个函数替换为另一个函数，该函数只做兼职工作，而不是非存根函数会做的实际全职工作。*

*因此，考虑使用记录器函数的常见情况。在产品的开发阶段有一个日志不仅仅是至关重要的。然而，当部署时，它应该给出一个控制台打印输出。*

> *提示:当然，日志文件总是一个好主意。*

*仔细思考一下，您可能会立即想到下面的代码:*

*这个程序做了比它需要的更多的工作，因为它每次都检查应用程序是否在`DEVELOPMENT`中。*

*等等！让我们简化一下。*

*删除日志功能，这样如果不在`DEVELOPMENT`模式下，它实际上不会做任何事情。*

*JavaScript 允许调用参数多于实参的函数，并且当你不在`DEVELOPMENT`时`log()`不会发生任何事情，你可以使用`() => {}`并且它会工作。*

# ***6。即时调用和初始化***

*广为人知的用法，在库和框架中也被采用，引入了模块化——甚至在旧版本的 JavaScript 中。我说的是即时调用函数表达式(IIFE)。我已经在前面的章节中讨论过了。*

*现在，让我们假设你正在定义一个函数并马上调用它，这样它就可以在现场执行了。*

*典型的写法是这样的:*

> *另一种风格是`(function(){//...}())`——函数括号的不同位置不会产生任何影响。选择你的风格并坚持下去。*

*您也可以使用相同的样式，但是向函数传递一些参数，这些参数将用作其参数的初始值:*

*您也可以从函数中返回一些内容:*

*问题总是为什么？因为简单地内联编写代码也能为我们完成这项工作。答案是:*

*范围范围范围。*

*由于 JavaScript 的函数作用域，如果在生命中定义任何变量或函数，这些定义将是内部的，从而阻止代码的其他部分访问它。*

*假设你为一个施法者编写了一些复杂的初始化程序:*

*那么，上面的代码会出什么问题呢？*

*这个问题取决于这样一个事实，即我们可能——偶然——拥有与三个被创造的函数中的任何一个同名的函数。*

*JavaScript 的提升特性确保后一个函数被调用，如下所示:*

*如果你用了生命，问题就不会发生了。*

*此外，这三个内部函数对于代码的其余部分甚至是不可见的。这也有助于保持全局名称空间的整洁:*

# *结论*

*本文演示了函数定义的几种方法。这几种 JS 技术恰好在概念上是完全 FP 的。*

> *免责声明:请记住，列出的每一项练习都是 JavaScript 函数式编程的进一步发展。如果你只应用了一个或几个，你的代码就不能完全发挥作用。每一步都可能违反 FP 设计理念，但提供了更好的功能设计。*

*感谢阅读。*

# *资源*

*   *[理解 Javascript 中的函数式编程——完全指南](https://levelup.gitconnected.com/understanding-functional-programming-in-javascript-a-complete-guide-e85ed13b42c8)*
*   *[Javascript 中的函数式编程原则](https://www.freecodecamp.org/news/functional-programming-principles-in-javascript-1b8fc6c3563f/)*
*   *[使用 JavaScript 的函数式编程](https://www.youtube.com/watch?v=sCAR8ZPM6ew)*
*   *[掌握 JavaScript 函数式编程](https://amzn.to/3ziF8cL)*

## *想联系作者？*

*[*获取 26 份备忘单，只研究你真正需要的东西，以获得你的第一份网络开发工作！*](https://arnoldcodeacademy.ck.page/26-web-dev-cheat-sheets)*

*![](img/227a060a3bfa55f41fa795d5990e6032.png)*

*[Arnold Code Academy 26 Web 开发人员备忘单](https://arnoldcodeacademy.ck.page/26-web-dev-cheat-sheets)*