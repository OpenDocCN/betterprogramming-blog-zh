<html>
<head>
<title>React State Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应状态管理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-state-management-7e7f3a2018e4?source=collection_archive---------11-----------------------#2021-02-24">https://betterprogramming.pub/react-state-management-7e7f3a2018e4?source=collection_archive---------11-----------------------#2021-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7995" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何为您的项目选择正确的状态管理解决方案，并知道何时使用Redux</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/885d1cb8d1d288b63e57c0b0bce9c645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rqIgB2HhWSkWRGYG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@mariacantu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">玛利亚·坎图</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="6fcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在社区中四处看看，你总是会遇到下面这个问题:我如何在React中管理我的状态？</p><p id="bde1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以前使用过其他框架如<a class="ae ky" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>或<a class="ae ky" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>的开发人员会问自己如何在React中管理他们的状态。通常，这个问题涉及国家管理的官方解决方案。</p><p id="b6f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.reddit.com/r/reactjs/comments/epxavs/is_redux_really_a_good_idea/" rel="noopener ugc nofollow" target="_blank">自从React 16.8中引入上下文API和钩子API以来，开发人员面临的另一个问题是如何在Redux和带有<code class="fe lv lw lx ly b">useState</code> / <code class="fe lv lw lx ly b">useReducer</code>的上下文API之间做出决定，以管理其全局状态。</a></p><p id="933b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想在下面的文章中回答这两个问题。为了这个目的，我在社区里做了一些研究，得到了很多有经验的React开发者的意见。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c48b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么是国家管理？</h1><p id="5a7a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">然而，在我们开始之前，我想澄清几个基本点。在我们能够解决正确的状态管理问题之前，我认为我们需要一个状态管理确切含义的定义。</p><p id="f573" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">状态描述了应用程序在给定时间点的状况。</p><p id="d80f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">状态的子类型有:</p><ul class=""><li id="ba6d" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">服务器状态</li><li id="a5e2" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">导航状态</li><li id="32be" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">本地用户界面状态</li><li id="779d" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">全局用户界面状态</li></ul><p id="fa55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">状态管理描述了根据所有输入维护应用<a class="ae ky" href="https://hackernoon.com/how-to-simplify-your-application-state-management-as6n3wz8" rel="noopener ugc nofollow" target="_blank">的状态/知识。</a></p><p id="93b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输入通常发生在服务器(API)或客户端(用户)。</p><p id="2418" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，<a class="ae ky" href="https://hackernoon.com/how-to-simplify-your-application-state-management-as6n3wz8" rel="noopener ugc nofollow" target="_blank">状态管理的困难</a>来自于应用程序中所有状态子类型的协调。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1693" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">React中的State是什么意思？</h1><p id="bc99" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">UI是应用程序状态的可视化表示。如上所述，state代表<a class="ae ky" href="https://www.robinwieruch.de/react-state#react-state-graphql%23what-is-state-in-react" rel="noopener ugc nofollow" target="_blank">应用程序在给定时间点的状态</a>。</p><p id="6684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在React中，状态是反映UI当前状态的数据结构。</p><p id="dc14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">状态可以由不同种类的数据组成:</p><ol class=""><li id="bcfe" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu nr nj nk nl bi translated">决定侧边栏是否打开的布尔值。</li><li id="c6ee" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nr nj nk nl bi translated">表单的文本内容。</li><li id="d95f" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nr nj nk nl bi translated">通过API提取的服务器数据。</li></ol><p id="07bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，我们可以这样表示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ee0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些数据既可以本地管理(即在一个组件中使用React Hooks或<code class="fe lv lw lx ly b">setState</code>)也可以全局管理。</p><p id="b5b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，管理意味着保存和更改状态，以及通过UI显示状态。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="da06" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">有官方/推荐的状态管理解决方案吗？</h1><p id="08e7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有了<code class="fe lv lw lx ly b">setState</code>方法和<code class="fe lv lw lx ly b">useState</code> / <code class="fe lv lw lx ly b">useReducer</code>钩子，组件内部的本地状态管理有了一个特定于React的解决方案。有了这个，<a class="ae ky" href="https://reactjs.org/docs/faq-state.html#should-i-use-a-state-management-library-like-redux-or-mobx" rel="noopener ugc nofollow" target="_blank">你已经可以创建</a>相当复杂的应用程序了。</p><p id="070c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像Angular的<a class="ae ky" href="https://ngrx.io/" rel="noopener ugc nofollow" target="_blank"> NgRx </a>或者Vue的<a class="ae ky" href="https://vuex.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vuex </a>这样的全局状态管理没有半官方的解决方案。在这里，你被React宠坏了。一些解决方案专门针对应用程序状态的某些部分(例如<a class="ae ky" href="https://react-query.tanstack.com/" rel="noopener ugc nofollow" target="_blank"> react-query </a>)，而<a class="ae ky" href="https://changelog.com/posts/when-and-when-not-to-reach-for-redux" rel="noopener ugc nofollow" target="_blank">一些是通用解决方案</a>(例如Redux)。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="767c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">那么，如何选择合适的状态管理解决方案呢？</h1><p id="0a63" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我有意不考虑导航状态。任何拥有两个以上视图的React应用程序都应该依赖于像<a class="ae ky" href="https://reactrouter.com/" rel="noopener ugc nofollow" target="_blank"> react-router </a>这样的路由库。从我的角度来看，处理浏览器API太复杂了，你自己无法管理。</p><p id="de24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们假设主要的困难是协调子类型，那么我们首先应该问自己，我们需要在(React)应用程序中管理什么类型的状态。我们的状态有多复杂？多久换一次？然后我们决定哪种解决方案最适合我们。</p><p id="04db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，你可以看到我决策过程的示意图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/f8a367d32785737f721d293c9bdf44e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NCu_Bd9V34F8_Ekp.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">选择正确的状态管理解决方案的决策过程。</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f875" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用状态</h1><p id="54ce" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先，我们的状态是由两个以上的组件共享的吗？如果不是，那么下一个问题就是我们的状态是否有复杂的更新逻辑。换句话说，新状态依赖于旧状态还是多个子值被改变？如果这些问题的答案是否定的，我们就用带<code class="fe lv lw lx ly b">useState</code>的局部状态。</p><p id="9d2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有一个只有一个组件的简单计数器，使用带有<code class="fe lv lw lx ly b">useState</code>的本地状态就足够了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1dcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一次渲染<code class="fe lv lw lx ly b">Counter</code>组件时，<code class="fe lv lw lx ly b">useState</code>钩子用<code class="fe lv lw lx ly b">intialCount</code>初始化。作为返回值，我们得到状态变量<code class="fe lv lw lx ly b">count</code>和更新函数<code class="fe lv lw lx ly b">setCount</code>。</p><p id="9d34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要改变计数，我们需要用一个新值调用<code class="fe lv lw lx ly b">setCount</code>。每当我们调用<code class="fe lv lw lx ly b">setCount</code>时，计数器组件被重新呈现。</p><p id="9a47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想在旧值的基础上设置<code class="fe lv lw lx ly b">count</code>的新值，我们应该传递给<code class="fe lv lw lx ly b">setCount</code>一个简单的更新函数，该函数传递count的新值作为它的返回值。</p><h2 id="c0a1" class="nv mh it bd mi nw nx dn mm ny nz dp mq li oa ob ms lm oc od mu lq oe of mw og bi translated">任务</h2><ul class=""><li id="52f3" class="nd ne it lb b lc my lf mz li oh lm oi lq oj lu ni nj nk nl bi translated">阅读React文档中的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">useState</a></code> <a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="233a" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">通过<code class="fe lv lw lx ly b"><a class="ae ky" href="https://dmitripavlutin.com/react-usestate-hook-guide/" rel="noopener ugc nofollow" target="_blank">useState</a></code> <a class="ae ky" href="https://dmitripavlutin.com/react-usestate-hook-guide/" rel="noopener ugc nofollow" target="_blank">导轨</a>进行工作。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cb97" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">用户教育</h1><p id="29c4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在，如果我们的状态确实有复杂的更新逻辑，那么对<code class="fe lv lw lx ly b">useReducer</code>就有意义了。</p><p id="7020" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，上下文中的“复杂”意味着状态的改变必须改变状态的许多值，或者状态依赖于先前的状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5d5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们定义一个初始状态和一个纯约化函数。这消耗了一个状态和一个动作，并返回一个新的状态。</p><p id="94fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在我们的计数器组件中使用<code class="fe lv lw lx ly b">useReducer</code>，我们进行类似于<code class="fe lv lw lx ly b">useState</code>的操作:我们用<code class="fe lv lw lx ly b">initialState</code>和<code class="fe lv lw lx ly b">reducer</code>初始化<code class="fe lv lw lx ly b">useReducer</code>。初始化之后，我们得到状态和一个调度函数。调度功能用于向减速器请求状态改变。为此，我们用适当的动作调用<code class="fe lv lw lx ly b">dispatch</code>。</p><p id="f3db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相应地，按钮的<code class="fe lv lw lx ly b">onClick</code>处理程序不再包含它们自己的逻辑，而是仅通过<code class="fe lv lw lx ly b">dispatch</code>请求状态改变。</p><h2 id="09cb" class="nv mh it bd mi nw nx dn mm ny nz dp mq li oa ob ms lm oc od mu lq oe of mw og bi translated">任务</h2><ul class=""><li id="faff" class="nd ne it lb b lc my lf mz li oh lm oi lq oj lu ni nj nk nl bi translated">阅读React文档中关于<code class="fe lv lw lx ly b"><a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">useReducer</a></code>的内容。</li><li id="61a8" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><a class="ae ky" href="https://css-tricks.com/getting-to-know-the-usereducer-react-hook/" rel="noopener ugc nofollow" target="_blank">了解</a> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://css-tricks.com/getting-to-know-the-usereducer-react-hook/" rel="noopener ugc nofollow" target="_blank">useReducer</a></code>。</li><li id="db78" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><a class="ae ky" href="https://www.robinwieruch.de/react-usereducer-vs-usestate" rel="noopener ugc nofollow" target="_blank">学习什么时候到</a> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.robinwieruch.de/react-usereducer-vs-usestate" rel="noopener ugc nofollow" target="_blank">useState</a></code> <a class="ae ky" href="https://www.robinwieruch.de/react-usereducer-vs-usestate" rel="noopener ugc nofollow" target="_blank">和什么时候到</a> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.robinwieruch.de/react-usereducer-vs-usestate" rel="noopener ugc nofollow" target="_blank">useReducer</a></code>。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b5a5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">上下文API +状态挂钩</h1><p id="881b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果我们看决策图的右边部分——也就是说，如果我们对“状态是由两个以上的组件共享的吗？”—我们面临的问题是，我们的全球状态是否经常变化。如果我们可以回答不，那么上下文API可以让我们的生活更轻松。</p><p id="5dc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个典型的例子是许多不同组件都需要的用户登录状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="62a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的代码示例中，我们用<code class="fe lv lw lx ly b">createContext</code>初始化上下文，它对<code class="fe lv lw lx ly b">AuthProvider</code>组件的所有子组件都可用。</p><p id="2cb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用自定义钩子<code class="fe lv lw lx ly b">useAuth</code>，子组件可以访问状态。这样可以让我们省去不必要的支柱钻孔。</p><h2 id="fffa" class="nv mh it bd mi nw nx dn mm ny nz dp mq li oa ob ms lm oc od mu lq oe of mw og bi translated">任务</h2><ul class=""><li id="afb3" class="nd ne it lb b lc my lf mz li oh lm oi lq oj lu ni nj nk nl bi translated">在React文档中阅读更多关于React的 <code class="fe lv lw lx ly b"><a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">useContext</a></code> <a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">钩子的信息。</a></li><li id="945b" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">阅读更多关于<code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.robinwieruch.de/react-state-usereducer-usestate-usecontext" rel="noopener ugc nofollow" target="_blank">useContext</a></code> <a class="ae ky" href="https://www.robinwieruch.de/react-state-usereducer-usestate-usecontext" rel="noopener ugc nofollow" target="_blank">结合</a> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.robinwieruch.de/react-state-usereducer-usestate-usecontext" rel="noopener ugc nofollow" target="_blank">useState</a></code> <a class="ae ky" href="https://www.robinwieruch.de/react-state-usereducer-usestate-usecontext" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.robinwieruch.de/react-state-usereducer-usestate-usecontext" rel="noopener ugc nofollow" target="_blank">useReducer</a></code>。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d557" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">服务器状态(react-query、Apollo、swr)</h1><p id="255b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">再次查看我们的决策图，我们看到我们已经用完了React的板资源。我们现在进入了一个值得使用外部状态管理解决方案的领域。</p><p id="1cfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果应用程序主要使用全局状态来检索、缓存和更新驻留在服务器上的数据，<a class="ae ky" href="https://kentcdodds.com/blog/application-state-management-with-react#server-cache-vs-ui-state" rel="noopener ugc nofollow" target="_blank">建议</a>使用专门的数据管理解决方案。</p><p id="0cb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在管理界面中，我们经常需要在不同的视图中显示许多不同的数据。有效地管理这些数据绝非易事。</p><p id="47f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，我将展示一个使用react-query的简单示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="026d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于我们的上下文API示例，<a class="ae ky" href="https://react-query.tanstack.com/" rel="noopener ugc nofollow" target="_blank"> react-query </a>为我们提供了一个上下文提供者和一个定制钩子。</p><p id="541d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">useQuery</code>定制钩子，我们现在可以获取我们需要的数据。为此，我们给<code class="fe lv lw lx ly b">useQuery</code>传递一个惟一的名称和实际的获取函数。我们取回需要显示的数据(<code class="fe lv lw lx ly b">status</code>、<code class="fe lv lw lx ly b">error</code>、<code class="fe lv lw lx ly b">content</code>)。</p><p id="344f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">真正的亮点是<code class="fe lv lw lx ly b">react-query</code>替我们接手管理。它确保数据被自动缓存和更新。如果我们在第二个组件中使用相同的查询问题，<code class="fe lv lw lx ly b">react-query</code>将不会多次执行查询，但是<a class="ae ky" href="https://react-query.tanstack.com/guides/important-defaults" rel="noopener ugc nofollow" target="_blank">将依靠缓存的数据</a>。</p><p id="7634" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，所提供的上下文提供程序被优化，以防止组件不必要的重新呈现。自己实现这个功能并不简单。</p><h2 id="c2dc" class="nv mh it bd mi nw nx dn mm ny nz dp mq li oa ob ms lm oc od mu lq oe of mw og bi translated">任务</h2><ul class=""><li id="f175" class="nd ne it lb b lc my lf mz li oh lm oi lq oj lu ni nj nk nl bi translated">了解更多关于react-query 背后的<a class="ae ky" href="https://react-query.tanstack.com/overview" rel="noopener ugc nofollow" target="_blank">动机。</a></li><li id="de42" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">了解备选方案，阿波罗<a class="ae ky" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank">和SWR </a>。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ca93" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Redux等人。</h1><p id="a87e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">但是，如果状态由多个组件共享，频繁更改，并且主要不是服务器状态，该怎么办呢？</p><p id="6d90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以在有许多按钮的文本编辑器中管理状态为例。这就是Redux的用武之地。Redux非常高效，拥有一个包含许多插件(所谓的中间件)的大型生态系统，并且非常有据可查。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c69a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里再次使用Redux和Redux工具包重新实现了我们的<code class="fe lv lw lx ly b">Counter</code>示例。它与<code class="fe lv lw lx ly b">useReducer</code>变体非常相似。</p><p id="2ed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们初始化我们的状态和我们的规约。在我们的<code class="fe lv lw lx ly b">Counter</code>组件中，我们初始化了一个所谓的选择器——一个选择状态子集的函数。此外，我们使用Redux的<code class="fe lv lw lx ly b">useDispatch</code>钩子来命令状态改变。</p><p id="83a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与我们的<code class="fe lv lw lx ly b">useReducer</code>变体不同，我们不需要用字符串来命名一个动作。动作名称由<code class="fe lv lw lx ly b">createSlice</code>自动生成。</p><p id="9bd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们简单的<code class="fe lv lw lx ly b">Counter</code>示例所示，设置Redux确实需要更多的努力。自从React 16.3正式引入了Context API之后，对于小型应用来说，大部分都是不值得花力气的。</p><p id="2103" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://blog.isquaredsoftware.com/2018/03/redux-not-dead-yet/" rel="noopener ugc nofollow" target="_blank">Redux</a>相对于上下文API和React挂钩的组合的优势在于:</p><ul class=""><li id="fe36" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">可以促进团队合作的一致的和定义的架构模式。</li><li id="3b13" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">通过出色的浏览器扩展轻松调试。</li><li id="17fa" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">不同中间件的使用。</li><li id="1aea" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">插件多，扩展性好。</li><li id="72d4" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">跨平台和跨框架使用。</li><li id="d3df" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">根据应用程序状态，性能优于上下文API。</li></ul><p id="42af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然Redux是React最著名和最受欢迎的状态管理解决方案，但它绝不是唯一的。备选方案有<a class="ae ky" href="https://mobx.js.org/README.html" rel="noopener ugc nofollow" target="_blank"> MobX </a>、<a class="ae ky" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>、<a class="ae ky" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>。</p><h2 id="ccda" class="nv mh it bd mi nw nx dn mm ny nz dp mq li oa ob ms lm oc od mu lq oe of mw og bi translated">任务</h2><ul class=""><li id="2f74" class="nd ne it lb b lc my lf mz li oh lm oi lq oj lu ni nj nk nl bi translated">了解更多关于使用von Redux und Redux-Toolkit 的信息。</li><li id="71b8" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">研究Redux替代品。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7791" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="827b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">很多React应用没有Redux也能过得去。在许多情况下，使用它会增加不必要的复杂性。</p><p id="89e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React钩子和上下文API可以覆盖许多以前用Redux解决的用例。</p><p id="fe19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于服务器状态缓存，建议使用专门的库。</p><p id="d440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">决策图可以帮助开发人员为他们的应用程序找到正确的状态管理形式。</p><p id="eb59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，所示的解决方案并不相互排斥。在应用程序中使用局部和全局状态没有任何问题。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="372b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">参考文献</strong></h1><ol class=""><li id="5e20" class="nd ne it lb b lc my lf mz li oh lm oi lq oj lu nr nj nk nl bi translated"><a class="ae ky" href="https://www.reddit.com/r/reactjs/comments/jb638g/n00b_q_why_would_you_ever_use_react_wo_hooks/" rel="noopener ugc nofollow" target="_blank"> n00b问:你为什么会使用React w/o钩子？</a></li><li id="f5b4" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nr nj nk nl bi translated"><a class="ae ky" href="https://www.reddit.com/r/reactjs/comments/khki5p/state_management_in_react/" rel="noopener ugc nofollow" target="_blank">状态管理在React？</a></li><li id="6e06" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nr nj nk nl bi translated"><a class="ae ky" href="https://www.reddit.com/r/reactjs/comments/epxavs/is_redux_really_a_good_idea/" rel="noopener ugc nofollow" target="_blank">redux真的是个好主意吗？</a></li><li id="86f3" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nr nj nk nl bi translated"><a class="ae ky" href="https://hackernoon.com/how-to-simplify-your-application-state-management-as6n3wz8" rel="noopener ugc nofollow" target="_blank"> Virdol，Marin —如何简化您的应用统计管理</a></li><li id="9ec0" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nr nj nk nl bi translated"><a class="ae ky" href="https://hackernoon.com/how-to-simplify-your-application-state-management-as6n3wz8" rel="noopener ugc nofollow" target="_blank"> Virdol，Marin —如何简化您的应用状态管理</a></li><li id="47fb" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nr nj nk nl bi translated"><a class="ae ky" href="https://www.robinwieruch.de/react-state#react-state-graphql#what-is-state-in-react" rel="noopener ugc nofollow" target="_blank">威鲁奇，罗宾-React状态管理</a></li><li id="64d5" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nr nj nk nl bi translated"><a class="ae ky" href="https://reactjs.org/docs/faq-state.html#should-i-use-a-state-management-library-like-redux-or-mobx" rel="noopener ugc nofollow" target="_blank">应该用Redux或者MobX这样的状态管理库吗？</a></li><li id="5145" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nr nj nk nl bi translated"><a class="ae ky" href="https://changelog.com/posts/when-and-when-not-to-reach-for-redux" rel="noopener ugc nofollow" target="_blank"> Erikon，Mark——何时(以及何时不)达到Redux </a></li><li id="bf20" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nr nj nk nl bi translated"><a class="ae ky" href="https://kentcdodds.com/blog/application-state-management-with-react#server-cache-vs-ui-state" rel="noopener ugc nofollow" target="_blank">肯特郡多兹——使用React进行应用状态管理</a></li><li id="0229" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nr nj nk nl bi translated"><a class="ae ky" href="https://react-query.tanstack.com/overview#motivation" rel="noopener ugc nofollow" target="_blank">概述反应-查询</a></li><li id="5bff" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nr nj nk nl bi translated"><a class="ae ky" href="https://react-query.tanstack.com/guides/important-defaults" rel="noopener ugc nofollow" target="_blank">重要默认值—反应-查询</a></li><li id="8fe0" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nr nj nk nl bi translated"><a class="ae ky" href="https://yihui.org/en/2018/06/cache-invalidation/" rel="noopener ugc nofollow" target="_blank">关于缓存失效——为什么很难？</a></li><li id="513a" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nr nj nk nl bi translated">埃里克森·马克——博客回答:Redux——还没死！</li></ol></div></div>    
</body>
</html>