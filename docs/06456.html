<html>
<head>
<title>Go, WebAssembly, HTTP Requests, and Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go、WebAssembly、HTTP请求和承诺</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/go-webassembly-http-requests-and-promises-ddb76af69ba8?source=collection_archive---------2-----------------------#2020-10-03">https://betterprogramming.pub/go-webassembly-http-requests-and-promises-ddb76af69ba8?source=collection_archive---------2-----------------------#2020-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5e8f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Go/Wasm中的JavaScript交互指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bc9b3a2d49b41f71d12f575fc7995c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPuHA1hb4trYxjGTH9VOpA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@sairaa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">萨莉娜</a>在<a class="ae ky" href="https://unsplash.com/@sairaa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="f263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://webassembly.org/" rel="noopener ugc nofollow" target="_blank"> WebAssembly </a>，或Wasm，是一个开放的标准，允许开发者使用编译的编程语言构建在网络浏览器中运行的应用。使用WebAssembly，可以用C/C++、Rust、C#和Go等语言编写web应用程序的组件，这些组件与JavaScript在同一个沙箱中运行。这允许诸如移植现有库、利用JavaScript中不可用的功能，以及更快地运行代码，因为WebAssembly被编译成二进制格式。</p><p id="9ebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近我一直在用WebAssembly进行试验，以便能够在浏览器中运行一些<a class="ae ky" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>代码。具体来说，我一直在尝试将用于存储端到端加密文档的开源项目<a class="ae ky" href="https://github.com/italypaleale/prvt" rel="noopener ugc nofollow" target="_blank"> prvt </a>的某些部分移植到web浏览器中直接运行。WebAssembly实验的原因有两个:首先，prvt广泛使用了密码学和流，这两种东西在JavaScript中还不是很好；第二，prvt本身是用Go编写的，因此能够在浏览器中重用代码将大大简化开发。</p><p id="34ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于使用WebAssembly和Go 的介绍，我推荐这篇关于Golang Bot 的文章。此外，更多信息可以在Go项目的<a class="ae ky" href="https://github.com/golang/go/wiki/WebAssembly" rel="noopener ugc nofollow" target="_blank"> GitHub wiki </a>和<a class="ae ky" href="https://golang.org/pkg/syscall/js/" rel="noopener ugc nofollow" target="_blank"> syscall/js </a>包的文档中找到。<br/>请注意，在撰写本文时，<strong class="lb iu">Go中的WebAssembly支持仍处于试验阶段</strong>。因此，API也可能会改变。本文针对Go 1.15进行了测试。</p><p id="fa17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章包含了我在使用WebAssembly端口时学到的四个不同但相关的东西，我认为分享这些东西很有用。</p><ol class=""><li id="6e56" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">从Go代码使用和创建JavaScript对象</li><li id="ca55" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在Go中创建传递异步结果的承诺</li><li id="1869" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">从Go代码发出HTTP请求</li><li id="d1be" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">从Go代码流</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="46b6" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">WebAssembly和Go中的JavaScript对象</h1><p id="d493" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">WebAssembly runtime for Go会自动将最常见的Go类型转换为对应的JavaScript类型。<code class="fe nn no np nq b"><a class="ae ky" href="https://golang.org/pkg/syscall/js/#ValueOf" rel="noopener ugc nofollow" target="_blank">js.ValueOf</a></code>方法的文档包含一个关于Go和JavaScript类型如何匹配的很好的汇总表:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="67f2" class="nv mr it nq b gy nw nx l ny nz">| Go                     | JavaScript             |<br/>| ---------------------- | ---------------------- |<br/>| js.Value               | [its value]            |<br/>| js.Func                | function               |<br/>| nil                    | null                   |<br/>| bool                   | boolean                |<br/>| integers and floats    | number                 |<br/>| string                 | string                 |<br/>| []interface{}          | new array              |<br/>| map[string]interface{} | new object             |</span></pre><p id="54b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里，您可以看到最常见的类型，如数字、布尔值和字符串，都是自动转换的。最后一行特别有趣，因为它解释了如何传递“普通旧JavaScript对象”(POJO)，这是最简单的对象(也称为字典)。</p><p id="4dfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，下面的Go代码定义了一个名为<code class="fe nn no np nq b">MyGoFunc</code>的函数，可以从JavaScript代码中调用该函数，该函数返回一个包含一个字符串和一个数字的字典(如您所见，类型可以是异构的)。</p><p id="ed3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关如何将Go代码编译成WebAssembly的说明，请查看Wiki的<a class="ae ky" href="https://github.com/golang/go/wiki/WebAssembly#getting-started" rel="noopener ugc nofollow" target="_blank">入门部分</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="d0fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将代码编译成WebAssembly并导入JavaScript代码后，您可以从JavaScript调用<code class="fe nn no np nq b">MyGoFunc()</code>来查看结果。例如:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="96a1" class="nv mr it nq b gy nw nx l ny nz">console.log(MyGoFunc())<br/>// Prints: {hello: "world", answer: 42}</span></pre><p id="45f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，文档中没有明确说明的是，我们还可以在Go代码中使用任何JavaScript对象，甚至是内置对象！这是事情变得更有趣的地方。</p><p id="7ff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们尝试将日期作为<code class="fe nn no np nq b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" rel="noopener ugc nofollow" target="_blank">Date</a></code>对象传递。为此，我们首先需要获取<code class="fe nn no np nq b">Date</code>构造函数，从JS的全局范围加载它的<code class="fe nn no np nq b">js.Value</code>:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="0159" class="nv mr it nq b gy nw nx l ny nz">dateConstructor := js.Global().Get("Date")</span></pre><p id="cae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以用<code class="fe nn no np nq b">dateConstructor.New</code>方法从这个构造函数创建一个新的对象，像在JavaScript中传递给<code class="fe nn no np nq b">new Date()</code>构造函数一样传递任何参数给它。调用的结果是一个可以返回给JavaScript的<code class="fe nn no np nq b">js.Value</code>:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="8bdb" class="nv mr it nq b gy nw nx l ny nz">dateConstructor.New("2020-10-01")</span></pre><p id="ab2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以修改我们的<code class="fe nn no np nq b">MyGoFunc</code>来返回在Go:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="6c90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript代码中调用<code class="fe nn no np nq b">MyGoFunc()</code>将会返回一个<code class="fe nn no np nq b">Date</code>对象:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="1aa5" class="nv mr it nq b gy nw nx l ny nz">let d = MyGoFunc()<br/>console.log(typeof d)<br/>console.log(d instanceof Date)<br/>console.log(d.toString())</span><span id="0d2a" class="nv mr it nq b gy oc nx l ny nz">/*<br/>Prints:</span><span id="ddfc" class="nv mr it nq b gy oc nx l ny nz">object<br/>true<br/>Sat Oct 03 2020 10:58:27 GMT-0700 (Pacific Daylight Time)<br/>*/</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6fa9" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">来自Go的承诺的异步JS</h1><p id="d100" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在JavaScript中，<code class="fe nn no np nq b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">Promise</a></code>是async/await的基础。如果你需要重温承诺，这是一篇好文章。</p><p id="a216" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，考虑下面的代码，它创建了一个承诺，三秒钟后通过一条消息(<a class="ae ky" href="https://www.mamalisa.com/?t=es&amp;p=5534" rel="noopener ugc nofollow" target="_blank">一个意大利绕口令</a>)解决:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="2e1b" class="nv mr it nq b gy nw nx l ny nz">const p = new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>        resolve("sopra la panca la capra campa, sotto la panca la capra crepa")<br/>    }, 3000)<br/>})</span></pre><p id="42e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个<code class="fe nn no np nq b">async</code>函数中，你可以在上面的<code class="fe nn no np nq b">await</code>上承诺，所以三秒钟后，你收到消息:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="c283" class="nv mr it nq b gy nw nx l ny nz">// This is an async function, which can contain "await" statements inside<br/>async function MyFunc() {<br/>    // Create the Promise<br/>    const p = new Promise((resolve, reject) =&gt; {<br/>        // After a 3 second timeout, this calls "resolve" with the message we're passing<br/>        setTimeout(() =&gt; {<br/>            resolve("sopra la panca la capra campa, sotto la panca la capra crepa")<br/>        }, 3000)<br/>    })<br/>    // Await for the Promise - this resolves after 3 seconds<br/>    const message = await p<br/>    console.log(message)<br/>}</span></pre><p id="5764" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe nn no np nq b">MyFunc()</code>会在控制台显示<code class="fe nn no np nq b">sopra la panca la capra campa, sotto la panca la capra crepa</code>。</p><p id="f4a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Go中与Wasm合作时，承诺尤为重要。</p><p id="8954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，根据文档，您不能在由JavaScript直接调用的函数内部进行阻塞调用——如果您这样做，您将立即得到一个死锁，并且您的应用程序将崩溃。相反，文档建议所有阻塞调用都在goroutine中，这就产生了将值返回给JavaScript代码的问题。引用自<a class="ae ky" href="https://golang.org/pkg/syscall/js/#FuncOf" rel="noopener ugc nofollow" target="_blank">文件</a>:</p><blockquote class="od oe of"><p id="4c10" class="kz la og lb b lc ld ju le lf lg jx lh oh lj lk ll oi ln lo lp oj lr ls lt lu im bi translated">“从JavaScript调用包装的Go函数将暂停事件循环并产生新的goroutine。在调用从Go到JavaScript的过程中触发的其他包装函数在同一个goroutine上执行。</p><p id="7bf4" class="kz la og lb b lc ld ju le lf lg jx lh oh lj lk ll oi ln lo lp oj lr ls lt lu im bi translated">因此，如果一个被包装的函数阻塞，JavaScript的事件循环将被阻塞，直到该函数返回。因此，调用任何需要事件循环的异步JavaScript API，比如fetch (http。客户端)，将导致立即死锁。因此，阻塞函数应该显式启动新的goroutine。</p></blockquote><p id="289a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Promise可能是解决这个问题的最好方法，既避免了死锁，又允许用惯用的JavaScript编程。</p><p id="c091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在上一节中看到，我们可以从Go创建定制的JavaScript对象，这也适用于承诺！我们只需要通过向构造函数传递一个函数来创建<code class="fe nn no np nq b">Promise</code>对象。就像上面的pure-JS代码一样，这个函数接收两个参数，这两个参数本身就是函数:<code class="fe nn no np nq b">resolve</code>应该在Promise的工作完成时用最终结果调用，而<code class="fe nn no np nq b">reject</code>可以在出现错误时调用，使Promise失败。</p><p id="3bd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个更新的<code class="fe nn no np nq b">MyGoFunc</code>解决了一个消息(<a class="ae ky" href="https://www.bbc.co.uk/languages/yoursay/tongue_twisters/italian/trotting_trentonians.shtml" rel="noopener ugc nofollow" target="_blank">另一个意大利绕口令！</a>)三秒钟后:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="8783" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要从JavaScript调用它:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="5353" class="nv mr it nq b gy nw nx l ny nz">async function MyFunc() {<br/>    // Get the Promise from Go<br/>    const p = MyGoFunc()<br/>    // Show the current UNIX timestamps (in seconds)<br/>    console.log(Math.floor(Date.now() / 1000))<br/>    // Await for the Promise to resolve<br/>    const message = await p<br/>    // Show the current timestamp in seconds, then the result of the Promise<br/>    console.log(Math.floor(Date.now() / 1000), message)<br/>}</span><span id="fda6" class="nv mr it nq b gy oc nx l ny nz">/*<br/>Result:<br/>  1601746916<br/>  1601746919 "Trentatré Trentini entrarono a Trento, tutti e trentatré trotterellando"<br/>*/</span></pre><p id="a2c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的Go代码出错，您可以通过使用<code class="fe nn no np nq b">reject</code>函数来抛出JavaScript异常。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="5d74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您从JavaScript调用这个函数时，大约有一半时间您会看到返回的对象，另一半时间您会得到一个异常。注意，我们用一个实际的JavaScript <code class="fe nn no np nq b">Error</code>对象调用<code class="fe nn no np nq b">reject</code>函数，这是JavaScript的最佳实践。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="4c39" class="nv mr it nq b gy nw nx l ny nz">async function MyFunc() {<br/>    try {<br/>        console.log(await MyGoFunc())<br/>    } catch (err) {<br/>        console.error('Caught exception', err)<br/>    }<br/>}</span><span id="8c24" class="nv mr it nq b gy oc nx l ny nz">/*<br/>Result is either:<br/>  {error: null, message: "Hooray, it worked!"}<br/>Or a caught exception (followed by the stack trace):<br/>  Caught exception Error: Nope, it failed<br/>*/</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="96d1" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">从Go代码发出HTTP请求</h1><p id="a4db" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">最后，让我们看看如何使用Go和WebAssembly来发出HTTP请求，这是一个非常常见的任务。例如，您可以在一个<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers" rel="noopener ugc nofollow" target="_blank">服务工作器</a>中这样做，以<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent" rel="noopener ugc nofollow" target="_blank">拦截网络请求</a>并让Go处理它们(这就是我对prvt所做的，所以Go代码可以解密文件)。</p><p id="3ce0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两件重要的事情要记住:</p><ol class=""><li id="b03f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">来自Go的网络调用是阻塞的，所以它们必须在单独的Goroutine中执行。因此，我们应该从Go向JavaScript返回一个承诺，最终以网络请求的结果进行解析。</li><li id="6e23" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果您的目标是拦截网络请求，那么您的Go代码应该返回包装在JavaScript <code class="fe nn no np nq b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Response" rel="noopener ugc nofollow" target="_blank">Response</a></code>对象中的响应。</li></ol><p id="b784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="ac2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以在JavaScript代码中使用它来调用任何REST API并获得结果，就好像它是一个<code class="fe nn no np nq b">fetch</code>请求一样。例如，在下面的代码中，我们调用了<a class="ae ky" href="https://taylor.rest/" rel="noopener ugc nofollow" target="_blank"> taylor.rest </a> API，该API会从Taylor Swift返回一段随机引用:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="a263" class="nv mr it nq b gy nw nx l ny nz">async function MyFunc() {<br/>    try {<br/>        const response = await MyGoFunc('https://api.taylor.rest/')<br/>        const message = await response.json()<br/>        console.log(message)<br/>    } catch (err) {<br/>        console.error('Caught exception', err)<br/>    }<br/>}</span><span id="a23d" class="nv mr it nq b gy oc nx l ny nz">/*<br/>Result is a quote from Taylor Swift, as a JSON object. For example:<br/>  {"quote":"The only one who's got enough of me to break my heart."}<br/>*/</span></pre><p id="f593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，当从Go发出HTTP请求时，WebAssembly运行时在内部将调用转换为浏览器中的fetch请求。因此，即使在使用WebAssembly时，您仍然受到与JavaScript <code class="fe nn no np nq b">fetch</code>调用相同的安全策略和要求的约束，包括CORS。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="812b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">从Go代码流</h1><p id="72f5" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">最后，还有一件事。我们已经看到了如何从WebAssembly/Go发出HTTP请求并返回数据。只有一个问题:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="93a6" class="nv mr it nq b gy nw nx l ny nz">data, err := ioutil.ReadAll(res.Body)</span></pre><p id="838a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一行中，我们在将响应返回给JavaScript之前，在内存中读取整个响应的主体。这在很多(大多数？)案例——但是，如果您试图读取一个非常大的文件，比如一个视频，该怎么办呢？上面的调用需要大量内存。</p><p id="0377" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我们可以将响应流回。遗憾的是，由于JavaScript对流的支持相对不成熟(在Node.js之外)，这并不简单。解决方案包括在WebAssembly代码中创建一个<code class="fe nn no np nq b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream" rel="noopener ugc nofollow" target="_blank">ReadableStream</a></code> JS对象，然后一旦数据在流中可用，就使用它的API来传递数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="efd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">MyGoFunc(url)</code>的最后一次迭代可以用来以流的形式检索数据。例如，在我们的JavaScript代码中，我们可以请求一个图像，并看到它以块的形式到达:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="f36a" class="nv mr it nq b gy nw nx l ny nz">async function MyFunc() {<br/>    try {<br/>        const response = await MyGoFunc('https://images.unsplash.com/photo-1571079520814-c2840ce6ec7b')<br/>        const reader = response.body.getReader()<br/>        let done = false<br/>        while (!done) {<br/>            const read = await reader.read()<br/>            done = read &amp;&amp; read.done<br/>            console.log('Read', read.value.length, 'bytes')<br/>        }<br/>    } catch (err) {<br/>        console.error('Caught exception', err)<br/>    }<br/>}</span></pre><p id="fc6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您调用这个函数时，您将在控制台中看到一串类似于<code class="fe nn no np nq b">Read 16384 bytes</code>的语句被重复多次，有时字节数不同，但不会超过16384，因为我们使用的是16KB的缓冲区。</p></div></div>    
</body>
</html>