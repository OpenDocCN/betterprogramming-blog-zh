<html>
<head>
<title>Build a Global Event System With TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript构建全局事件系统</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-global-event-system-using-custom-observers-and-subscribers-d3a409eb7d6e?source=collection_archive---------2-----------------------#2022-07-29">https://betterprogramming.pub/build-a-global-event-system-using-custom-observers-and-subscribers-d3a409eb7d6e?source=collection_archive---------2-----------------------#2022-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4e0e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用带有观察者、订阅者和单例模式的Typescript跟踪自定义事件的基础结构</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dde7341ecfdac8fdb03d659a29a890ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j57SkmXhYZRdpHOhXJlkOg.jpeg"/></div></div></figure><p id="a6a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">编写复杂的项目可能需要处理组件之间的不同事件。这些组件中的一些可能在编程方式上彼此相距太远。建立一个全球事件系统来处理这个问题可以解决这个问题。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="9b4f" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">事件系统模式</h1><p id="23b2" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">事件系统应该包含以下方法:</p><ul class=""><li id="0c6d" class="mr ms iq kt b ku kv kx ky la mt le mu li mv lm mw mx my mz bi translated"><code class="fe na nb nc nd b">subscribe(event, handler)</code>。此方法用于订阅实体以接收事件并运行这些事件的处理程序。它将被一个对某些事件感兴趣的实体使用。</li><li id="1794" class="mr ms iq kt b ku ne kx nf la ng le nh li ni lm mw mx my mz bi translated"><code class="fe na nb nc nd b">unsubscribe(event, handler)</code>。此方法用于取消实体接收事件的订阅。它将被一个对某些事件感兴趣的实体使用。</li><li id="be31" class="mr ms iq kt b ku ne kx nf la ng le nh li ni lm mw mx my mz bi translated"><code class="fe na nb nc nd b">notify(event, ...args)</code>。此方法用于向订阅该事件的所有实体通知已触发的事件。它将被一个向其他人发送事件的实体使用。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/d9088cb2292017284cad476712381721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CWfovdjsr89wYVvp_8kenw.png"/></div></div></figure><h2 id="72f8" class="nk lv iq bd lw nl nm dn ma nn no dp me la np nq mg le nr ns mi li nt nu mk nv bi translated">什么是单例</h2><p id="177b" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">Singleton是一种编程模式，它确保一个类在内存中只有一个实例。这对于管理一次只能用于一个实例的资源的类很有用。</p><p id="d291" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">单例模式是通过为类创建一个私有构造函数来实现的，这样可以防止其他代码实例化它。获取类的实例的唯一方法是通过一个静态方法，该方法返回一个现有的实例。</p><h2 id="07bb" class="nk lv iq bd lw nl nm dn ma nn no dp me la np nq mg le nr ns mi li nt nu mk nv bi translated">事件系统单例</h2><p id="e102" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">事件系统将使用单例模式来避免内存泄漏，并确保整个代码中只有一个事件系统实例，以确保逻辑一致性。这将使事件系统类在代码中全局表现相同，并允许通过<code class="fe na nb nc nd b">getInstance</code>静态方法访问事件系统逻辑。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="97fa" class="lu lv iq bd lw lx ny lz ma mb nz md me jw oa jx mg jz ob ka mi kc oc kd mk ml bi translated">事件</h1><p id="67f2" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">事件系统将能够触发事件并通知订阅者。这个过程应该尽可能的类型化。第一次，事件可以与它们的名称、处理程序参数和处理程序返回类型一起存储在接口中。稍后我们将使用<a class="ae od" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank"> TypeScript generics </a>扩展它，这样就有可能使用你自己的类型，这将使事件系统更加可定制。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="0f25" class="nk lv iq bd lw nl nm dn ma nn no dp me la np nq mg le nr ns mi li nt nu mk nv bi translated">事件订阅者</h2><p id="8a36" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">订户将被通知正在发生的事件。每个订阅者都将收到一个事件通知，以及一个用于处理该事件的处理程序。</p><p id="ff97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">函数在JavaScript世界中是非原语(此外，它们是<a class="ae od" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions" rel="noopener ugc nofollow" target="_blank">对象</a>)，并作为指针存储在程序中。这样，即使函数内部有相同的代码，它们也可以是唯一的。这允许识别唯一的订阅者使用他们订阅的事件和用于该事件的事件处理程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="1fb5" class="nk lv iq bd lw nl nm dn ma nn no dp me la np nq mg le nr ns mi li nt nu mk nv bi translated">订阅者方法</h2><p id="9709" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">由于EventSystem类的<code class="fe na nb nc nd b">subscribers</code>字段是一个数组，所以添加或删除数组的一个条目就足够了。触发事件处理程序的逻辑将在<code class="fe na nb nc nd b">notify</code>方法中实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="b74d" class="nk lv iq bd lw nl nm dn ma nn no dp me la np nq mg le nr ns mi li nt nu mk nv bi translated">通知方法</h2><p id="9e2c" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">事件系统方法<code class="fe na nb nc nd b">notify</code>将被打算触发一些动作的组件使用。该方法将触发所有订阅者的事件处理程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="d568" class="lu lv iq bd lw lx ny lz ma mb nz md me jw oa jx mg jz ob ka mi kc oc kd mk ml bi translated">使用</h1><p id="21c9" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">所以在所有这些逻辑实现之后，事件系统就准备工作了。目前，不可能扩展事件，所以它们应该是预定义的。这种扩展和一些其他功能将在第二部分中实现<a class="ae od" rel="noopener ugc nofollow" target="_blank" href="/extending-global-event-system-with-typescript-generics-16c2c626fa25">。</a></p><pre class="kg kh ki kj gt oe nd of og aw oh bi"><span id="1716" class="nk lv iq nd b gy oi oj l ok ol">Github Repository: <a class="ae od" href="https://github.com/NickSettler/event-system" rel="noopener ugc nofollow" target="_blank">https://github.com/NickSettler/events-system</a></span></pre></div></div>    
</body>
</html>