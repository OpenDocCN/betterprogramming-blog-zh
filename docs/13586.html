<html>
<head>
<title>How to Create a Whitelist NFT Collection Using the Merkle Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Merkle树创建白名单NFT集合</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-whitelist-nft-collection-using-the-merkle-tree-dc0b34c412f0?source=collection_archive---------2-----------------------#2022-09-09">https://betterprogramming.pub/how-to-create-a-whitelist-nft-collection-using-the-merkle-tree-dc0b34c412f0?source=collection_archive---------2-----------------------#2022-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9442" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及如何实际使用Merkle树</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c839ef3cc87e61e294683244ae5bb20a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wurNx7X1OHNi2WK5.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这就是我们在本教程末尾将会看到的白名单过程</p></figure><p id="1b61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将深入研究用solidity编写的白名单NFT智能合约。您将了解什么是白名单，Merkle树的实际用法，以及当您有几千个白名单地址时，如何以最节能的方式创建白名单ERC721。事不宜迟(我最喜欢的一句话来了)——让我们开始吧。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="e19b" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">为什么要创建白名单？</h1><p id="90dd" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">白名单是允许特定地址做特定事情的过程。在加密空间中，你允许地址x做一些动作，在一个聚会中，你可以被列入白名单，由于这个原因，你可以进去。超级简单。每当有人提到白名单的时候，记住——这意味着只有特定的人被允许做特定的事情(造币，参加聚会等等)。).</p><p id="30a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在NFT，白名单是一个受欢迎的过程。人们这样做是为了取消机器人的资格，并围绕一个项目大肆宣传。当有些东西不适合每个人时，它会让人发疯。🤯</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="2422" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">如何以及为什么应该使用Merkle树来检查地址是否在白名单中</h1><p id="1b7c" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">和往常一样，实现同一个目标有几种不同的方法。例如，您可以将白名单地址存储在映射或数组中。有一个但是。在区块链储存物品是最费油的行为，所以如果有更好的方法，为什么不试试呢？原来是有的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/35094b033670e533da753fe843fa2819.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/0*XWSWYlAJm_TGCTTz.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Merkle树</p></figure><p id="d3d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默克尔树就是答案。从技术上讲，这是一个散列树。因此，为了计算根哈希，也就是最高的节点，我们必须计算所有以前的哈希。哈希是单向操作，因此如果用于计算根哈希的任何哈希不正确，根哈希也将不正确。</p><blockquote class="mz na nb"><p id="b723" class="ky kz nc la b lb lc ju ld le lf jx lg nd li lj lk ne lm ln lo nf lq lr ls lt im bi translated">如果我们使用我们想要列入白名单的地址来创建树叶(A、B、C …哈希),那么我们可以很容易地验证一个地址是否被列入白名单，而无需存储几千个哈希，并在此过程中节省大量的气体💸</p></blockquote><h1 id="5226" class="mb mc it bd md me ng mg mh mi nh mk ml jz ni ka mn kc nj kd mp kf nk kg mr ms bi translated">怎么做？</h1><p id="88a5" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">该过程是离线和在线的。我们必须在智能契约中存储Merkle根，但是首先，我们需要知道一个。我们是怎么知道的？我们收集电子邮件、地址和任何我们想加入白名单的东西<strong class="la iu">离线，</strong>，然后我们使用这些数据来计算Merkle root，然后存储在智能合约中。映射成项目符号，看起来会是这样的:</p><ol class=""><li id="cf3e" class="nl nm it la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated">收集电子邮件、地址和任何你想加入白名单的东西。它可以是不和谐的，也可以是通过某种在线形式，</li><li id="81ac" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">得到所有你想加入白名单的东西，并为它们计算一个Merkle根，</li><li id="c5c9" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">给智能合同注入一个Merkle根，</li><li id="4ca8" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">您的智能合约现在支持白名单，</li><li id="c0ee" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">你是一个快乐的开发者(可选)。</li></ol><p id="81d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不多不少。现在我们要编码了。</p><h1 id="0bad" class="mb mc it bd md me ng mg mh mi nh mk ml jz ni ka mn kc nj kd mp kf nk kg mr ms bi translated">链外代码</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="6ca4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样。现在让我们浏览一下代码。</p><p id="b286" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们假设“白名单”是我们想要加入白名单的一组地址。你从你的不和谐服务器得到它，现在你从你的数据库加载它。加载后，你需要创建一个长度为64的字节数组，因为这是你需要传递的格式。从填充的字符串创建一个缓冲区，填充意味着添加一个字符，直到字符串达到给定的长度。</p><p id="8063" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们创建作为填充地址缓冲区的叶子，然后使用keccak256函数计算MerkleTree。Keccak256是一种广泛使用的哈希算法。我们还将排序选项设置为true。最后一步是获取Merkle树的HexRoot，我们将在我们的智能契约中使用它，以便能够验证想要创建的地址是否在白名单中。瞧。</p><p id="7b3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当你在前端编写minting函数时，你需要用一个填充的发件人地址作为参数来获取HexProof。</p><h1 id="2514" class="mb mc it bd md me ng mg mh mi nh mk ml jz ni ka mn kc nj kd mp kf nk kg mr ms bi translated">链上代码</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="7f97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我不会讨论ERC721合同。相反，我们将关注白名单机制。有两个重要的操作。第一个是将我们在第一步中计算的Merkle根注入到构造函数中。第二个是传递从特定地址计算的Merkle证明。这里没有魔法。</p><h1 id="21d6" class="mb mc it bd md me ng mg mh mi nh mk ml jz ni ka mn kc nj kd mp kf nk kg mr ms bi translated">测试脚本</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="9f59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然我们在区块链宝贝，我们需要测试一切。那不是例外。我提供的测试是不言自明的，我们得到了一组假地址，其中一半被标记为白名单，另一半没有。然后，我们计算树的Merkle根，并在部署契约时将其作为构造函数参数传递。从适当的数组中准备Merkle proof和invalidMerkleProof，并确保未列入白名单的地址确实不能制造NFT。</p><h1 id="990a" class="mb mc it bd md me ng mg mh mi nh mk ml jz ni ka mn kc nj kd mp kf nk kg mr ms bi translated">摘要</h1><p id="3587" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">那么什么是Merkle树呢？🌲</p><p id="db40" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一种快速有效的方法来验证某个东西是否真的是某个大数据的一部分。在白名单示例中，它告诉我们一个地址是否属于白名单阵列，以及它是否能够铸造。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="5978" class="og mc it oc b gy oh oi l oj ok"><strong class="oc iu">Want to Connect?</strong></span><span id="7b45" class="og mc it oc b gy ol oi l oj ok"><a class="ae om" href="https://expert-speaker-6559.ck.page/5c59cac2ef" rel="noopener ugc nofollow" target="_blank">Interested in weekly articles about solidity &amp; react? Let’s stay in loop 🔁</a></span></pre></div></div>    
</body>
</html>