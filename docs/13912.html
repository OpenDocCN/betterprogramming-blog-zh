<html>
<head>
<title>Serverless API Essentials: PUT vs PATCH</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器API Essentials:发布与修补</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/serverless-api-essentials-put-vs-patch-36235a36e88e?source=collection_archive---------2-----------------------#2022-10-13">https://betterprogramming.pub/serverless-api-essentials-put-vs-patch-36235a36e88e?source=collection_archive---------2-----------------------#2022-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a2ae" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">知道何时用PUT或补丁进行更新可能很棘手。选择使用哪些无服务器资源是您的下一个障碍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2ca434eea827345550c0c5e50f247f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oW5NX2FH4mpQyI03.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自Freepik上的<a class="ae ky" href="https://www.freepik.com/free-vector/teacher-concept-illustration_8449776.htm#query=teacher&amp;position=39&amp;from_view=search" rel="noopener ugc nofollow" target="_blank">故事集</a></p></figure><p id="ec1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我进行了大量的开发者访谈。我在采访中最喜欢的话题之一是REST APIs。总的来说，我对API设计和<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/are-you-really-api-first-or-do-you-just-think-it-24ffc47ec7ea"> API开发</a>充满热情。所以很自然，这是我经常问的问题。</p><p id="35b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们涵盖了基础知识，比如端点是如何构造的，以及如何平衡基本的REST构造和开发人员的经验。但是，当我要求解释<a class="ae ky" href="https://doc.oroinc.com/api/http-methods" rel="noopener ugc nofollow" target="_blank"> HTTP方法</a>的区别以及何时使用一种方法而不是另一种方法时，比你想象的更容易出错。</p><p id="a4e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数人能清楚地说出何时使用POST、GET、PUT和DELETE。但当我问及帕奇时，我经常会有一种“车灯前的鹿”的表情。</p><p id="9450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时人们告诉我他们以前从未听说过它；其他时候，他们告诉我他们知道这是一个更新操作，但不确定修补和上传之间的区别。</p><p id="4b66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种操作之间最简单的区别是:</p><blockquote class="lv lw lx"><p id="a39b" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">PUT用请求有效负载替换整个资源，但是PATCH对资源应用部分更新。</p></blockquote><p id="4115" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您使用PUT或PATCH的决定，当涉及到无服务器时，您的下游实现可能会发生巨大的变化。因此，让我们讨论一下什么时候您会使用其中的一个，并讨论无服务器资源的实现。</p><h1 id="5b65" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">何时使用PUT操作</h1><p id="54b0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如前所述，PUT将用请求负载替换整个资源。这意味着当您进行调用时，所有内容都将被覆盖，从而使该操作成为一般的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/serverless-api-essentials-idempotency-e753b7b49680">等幂</a>。</p><p id="fa4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何需要幂等且需要提供完整资源数据的操作都应该由PUT操作支持。例如，如果我们从我的参考项目<a class="ae ky" href="https://github.com/allenheltondev/gopher-holes-unlimited" rel="noopener ugc nofollow" target="_blank"> Gopher Holes Unlimited </a>中获取<a class="ae ky" href="https://github.com/allenheltondev/gopher-holes-unlimited/blob/master/openapi.yaml#L670" rel="noopener ugc nofollow" target="_blank"> update gopher hole </a>端点，您可以看到我们覆盖了整个gopher hole资源。</p><p id="5beb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该资源具有有限的字段，并且没有一个字段是通过访问控制来限制的(稍后将详细介绍)。因此，我们有了一个完美的看跌期权用例。要求调用者提供gopher hole资源的所有细节，甚至是不变的值，并不是一个过多的负担。</p><p id="a9a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当涉及到在无服务器系统中实现PUT时，您可以通过几种不同的方式来实现。如果您不需要执行验证(在模式验证之外),只需要替换实体，您可以通过API网关直接连接DynamoDB来替换资源。</p><p id="6fde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个<a class="ae ky" href="https://www.openapis.org/" rel="noopener ugc nofollow" target="_blank">开放API规范</a>中的示例实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ff8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个简单的操作不需要任何Lambda函数。API Gateway会直接调用DynamoDB，替换所请求资源的数据，假设资源已经存在。</p><p id="56cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果资源不存在，也允许PUT操作<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT#responses" rel="noopener ugc nofollow" target="_blank">创建资源</a>。它将资源的id设置为路径中提供的id。但是因为我们讨论的是更新操作，如果资源不存在，这个端点将返回一个错误。</p><h1 id="568a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">何时使用修补操作</h1><p id="efde" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果一个资源的元素处于访问控制级别之下，或者它太大而无法让使用者在所有字段中传递，那么您正在寻找一个修补程序的最佳机会。</p><p id="d461" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我提到访问控制时，我指的是需要一定级别的授权才能查看或编辑的资源元素。例如，这些字段只有资源的创建者才能操作。在Gopher Holes Unlimited中，有一个<code class="fe nb nc nd ne b"><a class="ae ky" href="https://github.com/allenheltondev/gopher-holes-unlimited/blob/master/openapi.yaml#L231" rel="noopener ugc nofollow" target="_blank">PATCH /gophers/{gopherId}</a></code>端点，允许调用者通过请求模式只更新Gopher信息的一个子集。</p><p id="7aff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下游实现中，进行验证以确保只有添加gopher的人才能更改名称。API的其他消费者可以更改其他字段，如他们看到地鼠的次数或颜色，但不能更改关键的标识信息。</p><p id="7e75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于内容的额外验证，补丁是这种情况下的首选途径。要在Node.js Lambda函数中实现通用补丁机制，请参考本要点中的代码<a class="ae ky" href="https://gist.github.com/allenheltondev/ccf585a1470e6be200f3ef970187e636" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="83c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与PUT操作相反，当谈到无服务器实现时，补丁将在Dynamo中执行一个<code class="fe nb nc nd ne b">UpdateItem</code>调用。这个<code class="fe nb nc nd ne b"><a class="ae ky" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_UpdateItem.html" rel="noopener ugc nofollow" target="_blank">UpdateItem</a></code>调用将添加、更新或删除一个条目的特定属性，而不是像我们在PUT端点中使用的<code class="fe nb nc nd ne b"><a class="ae ky" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_PutItem.html" rel="noopener ugc nofollow" target="_blank">PutItem</a></code>调用那样进行完全替换。</p><p id="89c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意——当使用类似上面要点中的通用补丁机制时，您必须依赖API网关级别的模式验证。您应该将传入的模式定义为<a class="ae ky" href="https://gist.github.com/allenheltondev/ccf585a1470e6be200f3ef970187e636#file-openapi-yaml-L49" rel="noopener ugc nofollow" target="_blank">，将潜在的更改限制在</a>可变的字段。确保在使用泛型时不允许任何额外的属性，因为您可能会存储恶意用户传入的无限数据。</p><p id="6c0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于实现补丁端点，有两种观点:</p><ul class=""><li id="24d9" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">像POST或PUT一样，在请求有效负载中提供所有更新的属性</li></ul><pre class="kj kk kl km gt no ne np nq aw nr bi"><span id="f8f0" class="ns md it ne b gy nt nu l nv nw">{ <br/>  "location": { <br/>    "longitude": 24.554 <br/>  }, <br/>  "comment": "This is a nasty gopher" <br/>}</span></pre><ul class=""><li id="587b" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">以数组形式提供每个变化值的操作、属性路径和值</li></ul><pre class="kj kk kl km gt no ne np nq aw nr bi"><span id="39fb" class="ns md it ne b gy nt nu l nv nw">[<br/>  {<br/>    "op": "add",<br/>    "path": "/comment",<br/>    "value": "This is a nasty gopher"<br/>  },<br/>  {<br/>    "op": "replace",<br/>    "path": "/location/longitude",<br/>    "value": 24.554<br/>  },<br/>  {<br/>    "op": "remove",<br/>    "path": "color"<br/>  }<br/>]</span></pre><p id="d256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和大多数软件一样，这些实现都有一些折衷。第一种实现更为熟悉，并且在使用API时通常成本更低。但是，它不提供删除属性的功能。</p><p id="1c2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个实现只是一个添加或更新操作。一种解决方法是删除作为空值传递到请求中的属性，但这可能不是100%正确的。</p><p id="18d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个实现需要传入要更改的每个字段的op、path和值。这导致显著更灵活的设计，但是增加了消费者跟踪在执行数据输入时发生的操作的复杂性。</p><p id="ddac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种实现在各自的场景中都是完全有效的。但是请确保在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/going-api-first-your-first-30-days-4c1ef6da320d">执行您的初始API设计</a>时做出一个有意识的决定。</p><h1 id="5380" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="a23b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">资源更新是一次冒险。在决定使用哪种实现时，您有很多选项可以考虑。</p><p id="cbd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">API设计和无服务器的伟大之处在于，您不必为整个应用程序坚持一个决定。也许您的端点的子集作为PUT操作运行是有意义的，而其他端点更适合于补丁。</p><p id="d3ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的修补操作中，可能有些端点应该只允许更新，从不删除字段，而其他端点可能需要删除字段的能力。这完全取决于您的用例。</p><p id="b348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的无服务器基础设施决策也各不相同。如果您的更新是一个没有副作用的简单PUT，您可以从API Gateway直接进入DynamoDB。如果在进行更改之前需要运行验证，Lambda函数更适合您的需要。如果您有多个验证和由于变更而触发的副作用，那么<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-lightning-fast-apis-with-aws-step-functions-d1725624aaaa">步骤功能工作流</a>可能是您的最佳选择。</p><p id="306a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，看跌期权或补丁不是灵丹妙药。将大型端点分解成较小的端点可能更明智。</p><p id="d0c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与其通过一个<code class="fe nb nc nd ne b">PUT /gophers/{gopherId}</code>端点来更新gopher状态，不如实现一个<code class="fe nb nc nd ne b">POST /gophers/{gopherId}/statuses</code>来分隔更新特定字段时需要运行的副作用或业务逻辑。</p><p id="c2a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是API设计的美妙之处。这是原教旨主义和完美开发者体验之间的平衡。用最有意义的东西让你的消费者开心。</p><p id="9d11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>