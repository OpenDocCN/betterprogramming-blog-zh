<html>
<head>
<title>Dynamic Programming Interview Questions: Unique Paths</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态编程面试问题:独特的路径</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/interview-questions-unique-paths-d2bbeed53017?source=collection_archive---------11-----------------------#2020-06-26">https://betterprogramming.pub/interview-questions-unique-paths-d2bbeed53017?source=collection_archive---------11-----------------------#2020-06-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c63a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有多少条通往目标的独特道路？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d96c92da14ea7a8fdc9af25c1b11f234.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tPFcrD_8v06o3Hah"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔治·巴科斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8e44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来看看一个好玩的小问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="6a38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个机器人位于一个m x n网格的左上角，在下图中标有“开始”。</p><p id="9a37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">机器人在任一时刻只能向下或向右移动<strong class="lb iu"> <em class="mc"> </em> </strong>。机器人正试图到达网格的右下角，下图中标有“完成”。</p><p id="a732" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有多少条可能的唯一路径？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi md"><img src="../Images/a2590d870d3951fe17628ada9c79343c.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*nisroZklYoveQNSB"/></div></figure><p id="17d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面是一个7 x 3的网格。有多少条可能的唯一路径？</p><h2 id="f78f" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">示例1</h2><ul class=""><li id="6b62" class="mx my it lb b lc mz lf na li nb lm nc lq nd lu ne nf ng nh bi translated">输入:m = 3，n = 2</li><li id="d3a9" class="mx my it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">输出:3</li><li id="9bfe" class="mx my it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">说明:从左上角开始，总共有三种方法可以到达右下角:</li></ul><ol class=""><li id="c4ad" class="mx my it lb b lc ld lf lg li nn lm no lq np lu nq nf ng nh bi translated">右-&gt;右-&gt;下</li><li id="cfe6" class="mx my it lb b lc ni lf nj li nk lm nl lq nm lu nq nf ng nh bi translated">右-&gt;下-&gt;右</li><li id="425e" class="mx my it lb b lc ni lf nj li nk lm nl lq nm lu nq nf ng nh bi translated">向下-&gt;向右-&gt;向右示例2:</li></ol><ul class=""><li id="eca6" class="mx my it lb b lc ld lf lg li nn lm no lq np lu ne nf ng nh bi translated">输入:m = 7，n = 3</li><li id="35fa" class="mx my it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">产量:28</li><li id="f05b" class="mx my it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">约束:1 &lt;= m, n &lt;= 100 It’s guaranteed that the answer will be less than or equal to 2 * 10 ^ 9.</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="5555" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Like our previous problem, we immediately know that we should use the bottom-up approach to solve this since we’re required to find <em class="mc">所有</em>可能的唯一路径。</p><h1 id="e50b" class="nr mf it bd mg ns nt nu mj nv nw nx mm jz ny ka mp kc nz kd ms kf oa kg mv ob bi translated">基础案例</h1><p id="02cc" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">在任何自下而上的方法中，我们都需要首先建立一些基础案例。我认为基础案例是不能进一步分解的案例——它们是子问题的最简单形式。如果我可以一步计算它们，<em class="mc">独立于任何先前的结果</em>，那么它一定是一个基本情况。通常，寻找基础案例的良好开端是查看问题的最小输入大小(即，边缘案例)。在我们的例子中，这将是m=1和n=1。那么如果m=1，n=1，有多少条唯一的路径。它只会是1。</p><p id="0517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好——我们已经建立了一个基本案例。<em class="mc">还有吗？</em></p><p id="5733" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，机器人在任何时候都只能向下或向右移动。这意味着如果m=1，n的值并不重要——只有一条唯一的路径可以到达那里。类似地，如果n=1，m的值并不重要——同样，只有一条唯一的路径。</p><p id="ebb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇！这个基础案例甚至比我们建立的第一个案例更有洞察力，第一个案例仅仅是这个基础案例的一个子集！</p><p id="868a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mc">这个故事的寓意:在努力向上爬之前，尽可能多地寻找基本案例</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bad3" class="nr mf it bd mg ns of nu mj nv og nx mm jz oh ka mp kc oi kd ms kf oj kg mv ob bi translated">一路向上</h1><p id="614d" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">对于m&gt;1或n&gt;1的情况，我们如何从我们的基本情况和以前的结果计算可能的唯一路径？希望这部分对你来说是直观的，就像对我一样。因为对我来说，很明显，我们可以通过将前面两个结果的解相加来计算它——可能的唯一路径来自左边，可能的唯一路径来自上面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi md"><img src="../Images/2a7513a10fded6f1920a3f244b65227b.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*GMI9WXLYBDSRhEMY"/></div></figure><p id="0422" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，对于所有n，m &gt; 1，解[n][m]=解[n-1][m] +解[n][m-1]。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ad01" class="nr mf it bd mg ns of nu mj nv og nx mm jz oh ka mp kc oi kd ms kf oj kg mv ob bi translated">用Python实现</h1><p id="e29c" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">现在我们知道该做什么了。让我们用Python实现我们的解决方案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="ce17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，我们已经完成了这个动态规划问题！你觉得你找到窍门了吗？</p></div></div>    
</body>
</html>