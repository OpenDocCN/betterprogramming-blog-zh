<html>
<head>
<title>Using SELECT * in an SQL Query Is a Bad Practice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SQL查询中使用SELECT *是一种不好的做法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-select-in-an-sql-query-is-a-bad-practice-a8f6beeca1da?source=collection_archive---------6-----------------------#2020-05-14">https://betterprogramming.pub/using-select-in-an-sql-query-is-a-bad-practice-a8f6beeca1da?source=collection_archive---------6-----------------------#2020-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f5aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">具体说明你的选择</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://javarevisited.blogspot.com/2018/05/top-5-sql-and-database-courses-to-learn-online.html"><div class="gh gi ki"><img src="../Images/ee7e4b3e81469e8f497a9f3582856788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L33kq2lAdd7PUd92o88hSg.png"/></div></a><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者照片。</p></figure><p id="9e13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在网上看过很多文章，人们认为在SQL查询中使用<strong class="kw iu"> </strong>是一种不好的做法，你应该总是避免它，但是他们从来不愿意解释为什么。</p><p id="20f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">他们中的一些人会说你应该在你的<a class="ae lu" href="https://javarevisited.blogspot.com/2017/02/top-6-sql-query-interview-questions-and-answers.html" rel="noopener ugc nofollow" target="_blank"> SQL查询中使用一个显式的列列表，</a>这是一个很好的建议，也是我教给初级程序员的<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/mysql-best-practices-b103260f8b45"> SQL最佳实践</a>之一。但是，很多都没有解释背后的原因。</p><p id="136e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除非你解释为什么不应该在查询中使用<code class="fe lq lr ls lt b">SELECT *</code>,否则很难说服SQL开发人员——他们中的许多人已经开始通过在<a class="ae lu" href="http://www.java67.com/2018/02/5-free-oracle-and-microsoft-sql-server-online-courses.html" rel="noopener ugc nofollow" target="_blank"> Oracle </a>数据库中使用来自EMP的<code class="fe lq lr ls lt b">SELECT *</code>来学习SQL 。</p><p id="8a70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我将尝试通过给出一些实际的原因来弥补这个差距，为什么在一个<a class="ae lu" href="https://www.java67.com/2013/04/10-frequently-asked-sql-query-interview-questions-answers-database.html" rel="noopener ugc nofollow" target="_blank"> SQL查询</a>中使用<code class="fe lq lr ls lt b">SELECT *</code>不是一个好主意。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3c3c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.不必要的IO</h1><p id="753e" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">通过使用<code class="fe lq lr ls lt b">SELECT *</code>，您可以返回不必要的数据，这些数据将被忽略。但是获取这些数据并不是没有成本的。这会导致数据库端出现一些浪费的IO周期，因为您将从页面中读取所有数据。也许你可以从<a class="ae lu" href="https://javarevisited.blogspot.com/2022/12/12-database-sql-index-interview.html" rel="noopener ugc nofollow" target="_blank">索引页</a>中读取数据。这也可能使您的查询变得有点慢。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a983" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.网络流量增加</h1><p id="ce97" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated"><code class="fe lq lr ls lt b">SELECT *</code>向客户端返回比所需更多的数据，这反过来会使用更多的网络带宽。网络带宽的增加也意味着数据需要更长的时间到达客户端应用程序，这可能是SSMS或你的Java应用服务器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6b3f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.更多应用程序内存</h1><p id="b883" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">由于数据的增加，您的应用程序可能需要更多的内存来保存不必要的数据，这些数据不会被使用，而是来自于<a class="ae lu" href="https://medium.com/javarevisited/5-best-courses-to-learn-microsoft-sql-server-in-depth-e9f11b73c14a" rel="noopener"> Microsoft SQL server </a>或您正在连接的任何其他数据库。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="23e7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.对结果集列顺序的依赖性</h1><p id="9740" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">当您在应用程序中使用<code class="fe lq lr ls lt b">SELECT *</code>查询并且对列的顺序有任何依赖时(这是不应该的),如果您添加新列或更改列的顺序,<a class="ae lu" href="http://javarevisited.blogspot.sg/2016/10/how-to-check-if-resultset-is-empty-in-Java-JDBC.html" rel="noopener ugc nofollow" target="_blank">结果集</a>的顺序将会改变。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a4bb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.向表中添加新列时破坏视图</h1><p id="de9a" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">当您在视图中使用<code class="fe lq lr ls lt b">SELECT *</code>时，如果添加了一个新列，而从表中删除了旧列，就会产生微妙的错误。为什么？因为您的视图不会中断，但会开始返回不正确的结果。<br/> <br/>为了避免这种情况，你应该始终使用<code class="fe lq lr ls lt b">WITHSCHEMABINDING it</code>和视图。这也将阻止您在视图中使用<code class="fe lq lr ls lt b">SELECT *</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c813" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.连接查询中的冲突</h1><p id="008f" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">当您在<code class="fe lq lr ls lt b"><a class="ae lu" href="https://javarevisited.blogspot.com/2020/04/combine-two-tables-using-left-join-in-SQL.html" rel="noopener ugc nofollow" target="_blank">JOIN</a></code> <a class="ae lu" href="https://javarevisited.blogspot.com/2020/04/combine-two-tables-using-left-join-in-SQL.html" rel="noopener ugc nofollow" target="_blank">查询</a>中使用<code class="fe lq lr ls lt b">SELECT *</code>时，当多个表具有相同名称的列(例如，状态、活动、名称等)时，您会引入复杂性。).对于一个简单的查询，这可能没问题。但是，当您尝试按这些列之一进行排序，或者在CTE或派生表中使用查询时，您将需要进行一些调整。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://medium.com/javarevisited/7-free-courses-to-learn-database-and-sql-for-programmers-and-data-scientist-e7ae19514ed2"><div class="gh gi mz"><img src="../Images/55b09623c4959ccf23088d20002705b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*T_wBEzWWmsDIEQUn.png"/></div></a></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a963" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.将数据从一个表复制到另一个表</h1><p id="4705" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">当您在<code class="fe lq lr ls lt b">INSERT .. SELECT</code>语句中使用<code class="fe lq lr ls lt b">SELECT *</code>时，这是将数据从一个表复制到另一个表的常用方法，如果两个表之间的列顺序不同，您可能会将不正确的数据复制到不正确的列中。<br/> <br/>一些程序员认为在你的<code class="fe lq lr ls lt b"><a class="ae lu" href="https://javarevisited.blogspot.com/2016/01/sql-exists-example-customers-who-never-ordered.html" rel="noopener ugc nofollow" target="_blank">EXISTS</a></code>代码中使用<code class="fe lq lr ls lt b">SELECT *</code> vs. <code class="fe lq lr ls lt b">SELECT 1</code>会更快，因为查询解析器必须做额外的工作来验证静态值。<br/> <br/>很久以前这可能是真的，但是现在解析器已经变得足够聪明，知道<code class="fe lq lr ls lt b">SELECT</code>列表在<code class="fe lq lr ls lt b">EXISTS</code>子句中是完全不相关的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bb98" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="d6da" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">这就是为什么您不应该再在SQL查询中使用<code class="fe lq lr ls lt b">SELECT *</code>的原因。在<code class="fe lq lr ls lt b">SELECT</code>查询中使用显式列列表总是比使用<code class="fe lq lr ls lt b">*</code>通配符要好。它不仅提高了性能，还使您的代码更加清晰。</p><p id="128a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它还帮助您创建可维护的代码，当您向表中添加新列时，这些代码不会中断——特别是当您有引用原始表的视图时。</p></div></div>    
</body>
</html>