<html>
<head>
<title>Hexagonal Architecture on Spring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">弹簧上的六角形建筑</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/hexagonal-architecture-on-spring-a76c5be5039b?source=collection_archive---------3-----------------------#2022-07-26">https://betterprogramming.pub/hexagonal-architecture-on-spring-a76c5be5039b?source=collection_archive---------3-----------------------#2022-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ab6a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">六边形建筑正在取代分层风格，原因如下</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/547c05f9a74d689cc71617e7683e4cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jWcUSfHwriTG_AhePNWQyg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://stocksnap.io/photo/geometric-industrial-QTP6YBOO6T" rel="noopener ugc nofollow" target="_blank">照片</a>由<a class="ae kv" href="https://stocksnap.io/author/burstshopify" rel="noopener ugc nofollow" target="_blank">爆料</a>上<a class="ae kv" href="https://stocksnap.io/" rel="noopener ugc nofollow" target="_blank">抓拍</a></p></figure><p id="8eef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">六边形架构是一种用于设计软件应用程序的架构模式。近年来，它越来越受欢迎，因为它是传统分层体系结构的替代方案。在本文中，我解释了为什么六边形架构正在取代分层架构。</p><h1 id="392d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">分层架构有什么问题？</h1><p id="2473" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这种架构模式应用SoC ( <em class="mp">关注点分离</em>)原则将我们的组件分解成层，每一层都有不同的职责。通常有3层:</p><ol class=""><li id="5b13" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir">表示层</strong>，包含用户界面。</li><li id="b5a0" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">业务层或领域层</strong>，包含业务逻辑。</li><li id="bca9" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">持久层</strong>，处理数据库操作。</li></ol><p id="e27b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在应用这种架构模式时，我们面临着层与层之间的依赖，也就是说，每一层都依赖于紧接着的下一层。</p><p id="dbd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该模型未能表明我们可以与多个数据库交互，或者根本不与任何数据库交互。此外，表示层没有考虑到用户与应用程序交互的方式可能不止一种。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="fafc" class="ls lt iq bd lu lv nl lx ly lz nm mb mc jw nn jx me jz no ka mg kc np kd mi mj bi translated">六边形架构如何克服分层架构的弊端？</h1><p id="23f2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">该模型将所有业务逻辑置于应用程序的核心，抽象出任何类型的外部依赖。这种隔离使得逻辑更容易测试和维护。</p><p id="3b42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用程序现在有一个或多个处理用户请求的输入适配器，而不是表示层。类似地，代替持久层，现在我们有一个或多个调用外部应用程序或服务的输出适配器，比如亚马逊S3的文件存储、SendGrid之类的电子邮件服务，或者更常见的是数据库。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/35a92fed8d2f34c0fbdc413628d30479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zDk8LCB2RLQUGv-jd-rStA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者<a class="ae kv" href="https://manerajona.medium.com" rel="noopener">作者</a></p></figure><p id="84ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">业务核心有一个或多个端口。端口定义了一组操作，允许内核与适配器进行交互，从而与应用程序外部的内容进行交互。正如我们有两种类型的适配器，输入和输出，有一个输入端口和一个输出端口。输入端口是由核心公开的API，供外部应用程序访问，而输出端口是允许核心使用外部服务的接口。</p><p id="6c5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输入适配器通过调用输入端口来处理来自外界的请求。这方面的一个例子是实现REST API或gRPC服务器的Spring控制器。</p><p id="70be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出适配器通过调用外部应用程序或服务来实现处理来自业务核心的请求的输出端口。一些例子是执行数据库操作的DAO(数据访问对象)类，或者使用电子邮件服务的Spring组件。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="1106" class="ls lt iq bd lu lv nl lx ly lz nm mb mc jw nn jx me jz no ka mg kc np kd mi mj bi translated">我们如何在Spring上处理这种建筑风格呢？</h1><p id="d244" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">到目前为止，我们已经看到了六边形建筑的相关概念。现在，让我们将理论付诸实践，并使用Kotlin构建一个Spring应用程序。</p><p id="ecfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我个人喜欢将项目分为三个主要部分:</p><ul class=""><li id="bf91" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr nr mw mx my bi translated">“<code class="fe ns nt nu nv b">core</code>”包，包含与核心业务相关的组件。</li><li id="cb02" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr nr mw mx my bi translated">“<code class="fe ns nt nu nv b">ports</code>”包，包含将业务核心与外界交流的输入和输出组件。</li><li id="5b11" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr nr mw mx my bi translated">“<code class="fe ns nt nu nv b">config</code>”包，用于启动应用程序和处理其内部行为所需的所有配置。</li></ul><h2 id="1ebf" class="nw lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated">构建核心</h2><p id="9cb2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这里是我们的<code class="fe ns nt nu nv b">Article</code>实体。请注意，它是用普通的Kotlin(或Java)编写的，但是完美地代表了业务实体。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="dabb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是<code class="fe ns nt nu nv b">ArticleRepository</code>接口，它允许业务核心与外部服务进行通信。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="b359" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是<code class="fe ns nt nu nv b">ArticleService</code>接口，它允许外部应用程序与业务核心通信。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="3556" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ns nt nu nv b">usecase</code> <em class="mp"> </em>包<em class="mp">，</em>中的<code class="fe ns nt nu nv b">ArticleServiceImpl</code> <em class="mp"> </em>类<em class="mp"> </em>扩展了<code class="fe ns nt nu nv b">ArticleService</code>并包含了实际的业务逻辑。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="e9ce" class="nw lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated">数据库适配器的输出端口</h2><p id="a716" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe ns nt nu nv b">ports/output/jpa</code>包包含将数据保存到数据库中的组件。</p><p id="a687" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是基于核心实体的<code class="fe ns nt nu nv b">ArticleJpa</code>类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="00b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是从Spring JPA库中扩展了<code class="fe ns nt nu nv b">JpaRepository</code>的<code class="fe ns nt nu nv b">ArticleJpaRepository</code>类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="01c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，<code class="fe ns nt nu nv b">ArticleDao</code>类扩展了<code class="fe ns nt nu nv b">ArticleRepository</code>，允许业务核心获取和保存数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="ccaf" class="nw lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated">REST适配器的输入端口</h2><p id="c20f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">最后，<code class="fe ns nt nu nv b">ports/inputs/rs</code> <em class="mp"> </em>包包含Rest控制器，这些控制器公开了供外部应用程序使用的端点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="bf5a" class="ls lt iq bd lu lv nl lx ly lz nm mb mc jw nn jx me jz no ka mg kc np kd mi mj bi translated">为什么建筑很重要？</h1><p id="1f4c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当工程软件时，存在一组基本需求，称为服务质量需求。这些需求定义了我们在构建高质量软件的过程中必须解决的一些权衡，例如可伸缩性、可靠性、可维护性、可测试性和可部署性。</p><p id="083f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">架构很重要，因为如果我们在选择时足够明智，为我们的项目选择正确的架构模式将有助于我们的软件达到预期的质量，也许还会让我们少一些头痛。</p><p id="0624" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。我希望这有所帮助！</p><p id="cc76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例代码可在<a class="ae kv" href="https://github.com/manerajona/spring-hexagonal-kt" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>