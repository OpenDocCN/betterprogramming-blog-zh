<html>
<head>
<title>Let’s Smell Some Tests #3 — Testing Randomness in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们闻闻测试# 3——测试Java中的随机性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lets-smell-some-tests-3-testing-randomness-in-java-26a70a017239?source=collection_archive---------18-----------------------#2022-05-25">https://betterprogramming.pub/lets-smell-some-tests-3-testing-randomness-in-java-26a70a017239?source=collection_archive---------18-----------------------#2022-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0851" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么您应该避免测试非确定性行为</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a4e1fdffe8b355d1bd83b8ddf946c257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*miCetM47me0xOX6v"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">卢卡斯·乔治·温迪特在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a335" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你好，欢迎来到<em class="ls"/>系列的第四篇《来闻点测试吧》。在前一集，我们看到了锻炼内部行为的测试，我们指出了这种方法的缺点。</p><p id="ae7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我们将分析另一个有趣的话题:为什么测试不可测试性是一个糟糕的实践，为什么它会导致过度复杂的测试用例。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="1f8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是我在今天的例子中使用的内容:</p><ul class=""><li id="6f2b" class="ma mb iq ky b kz la lc ld lf mc lj md ln me lr mf mg mh mi bi translated">Java 17</li><li id="5550" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">JUnit 5.8.2</li><li id="adbe" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">AssertJ 3.22.0</li><li id="c126" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">摩奇托4.5.1</li></ul><h1 id="9f3d" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">例子:在地图上随机选择一个地方繁殖一个玩家</h1><h2 id="7a32" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">要求</h2><p id="a7c3" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">此用例的要求如下:</p><ul class=""><li id="7bd2" class="ma mb iq ky b kz la lc ld lf mc lj md ln me lr mf mg mh mi bi translated">当游戏开始时，在地图上产生一个新玩家</li><li id="a6bb" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">地图是一个平铺矩阵；地图的大小是可以配置的</li><li id="51a4" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">默认情况下，将玩家放在随机牌上</li></ul><h2 id="6d2b" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">第一种实现方法</h2><p id="846e" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">这些需求的一个示例实现可能类似于下面的代码片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/4e86e63ff0429ff74cd1015974bd9c88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnsqecqmPrtD4wLyxXALNQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试通过了，尽管应该返工</p></figure><p id="8680" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简短的解释:</p><ul class=""><li id="4873" class="ma mb iq ky b kz la lc ld lf mc lj md ln me lr mf mg mh mi bi translated"><code class="fe oa ob oc od b">Board</code>类由一个对象矩阵组成，每个对象都属于<code class="fe oa ob oc od b">Tile</code>类型</li><li id="5fba" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated"><code class="fe oa ob oc od b">Tile</code>类由<code class="fe oa ob oc od b">x</code>和<code class="fe oa ob oc od b">y</code>属性表示，加上它持有一组<code class="fe oa ob oc od b">Localizable</code>对象，像玩家；在未来,<code class="fe oa ob oc od b">Localizable</code>界面可能还会显示其他物体，比如敌人、可消耗的物品，以及任何可以绑定到地图上一个区块的东西</li><li id="7a2d" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">因为我们想在地图上的某个地方放置一个新玩家，所以<code class="fe oa ob oc od b">Player</code>类实现了<code class="fe oa ob oc od b">Localizable</code>接口，它带有<code class="fe oa ob oc od b">getCurrentLocation()</code>函数。</li><li id="2d28" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">为了实例化一个新的<code class="fe oa ob oc od b">Player</code>，我们必须调用一个工厂方法<code class="fe oa ob oc od b">create(Board board)</code></li><li id="6021" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">为了满足要求，<code class="fe oa ob oc od b">Player</code>类包含选择随机牌的逻辑，玩家应该在这里开始游戏</li></ul><h1 id="e784" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">代码分析</h1><p id="25d1" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">代码可以被编写成能够正常工作，也可以工作并保持高质量。不幸的是，当前的实现代表了第一种选择。</p><p id="bcab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码编译通过，测试通过，理论上，我们可以继续并实现其他功能，但是让我们看看还有什么可以做得更好:</p><ul class=""><li id="f88a" class="ma mb iq ky b kz la lc ld lf mc lj md ln me lr mf mg mh mi bi translated">测试用例<code class="fe oa ob oc od b">SpawnPlayerTest#testSpawnPlayerOnTheMap</code>通过检查棋盘大小进行了过多的验证(测试的名称表明它只关注于生成玩家，这是不正确的)</li><li id="2f41" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">断言逻辑太复杂(因为玩家被分配到的牌是随机的，我们从棋盘上收集所有的牌，并且我们正在检查玩家是否被分配到其中的一个)</li><li id="216b" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">为新玩家选择牌的逻辑是硬编码在<code class="fe oa ob oc od b">Player</code>类中的(违反了单一责任和开闭原则)</li></ul><h1 id="afdc" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">如何改进代码</h1><p id="cf17" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">处理随机性可能很棘手，我们的代码就是这种情况。根据这个例子，我们有一个尺寸为5x4的板。这给了我们20个可能的牌，产卵玩家可以从中选择牌。</p><p id="d0ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，有一件重要的事情要说:即使我们知道有20个可能的值要断言，实际上也没有办法确定在下一次测试执行中将选择哪个特定的图块。随机性是一种我们有点无法控制的东西，在我看来，如果我们接受这个事实，而不是在测试中与之斗争，那会更好。</p><p id="5a5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以用以下几点来描述更适合当前需求的解决方案:</p><ul class=""><li id="d63f" class="ma mb iq ky b kz la lc ld lf mc lj md ln me lr mf mg mh mi bi translated">提取逻辑为玩家选择一个独立的单位</li><li id="8b55" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">为这个逻辑创建一个抽象，以便在需求变化时可以使用不同的实现</li><li id="5387" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">要生成玩家，通过构造函数将磁贴选择器传递给<code class="fe oa ob oc od b">Player</code>类</li><li id="8378" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">简化测试<code class="fe oa ob oc od b">SpawnPlayerTest#testSpawnPlayerOnTheMap</code></li></ul><h2 id="cfc5" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">步骤1:提取为玩家选择牌</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="fb86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果将来需求发生变化，我们将需要编写另一个类来实现<code class="fe oa ob oc od b">LocationSeed</code>接口。</p><h2 id="aa63" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">步骤2:告诉玩家对象在哪里可以得到初始的方块</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="2cf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构造函数通过调用<code class="fe oa ob oc od b">locationSeed.getTile()</code>方法来利用提供的<code class="fe oa ob oc od b">LocationSeed</code>对象。将来，当需要时，我们可以简单地提供一个不同的<code class="fe oa ob oc od b">LocationSeed</code>接口实现，这样我们就不会接受修改，但可以接受扩展。</p><h2 id="2fc7" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">步骤3:重做测试</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="c6be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将电路板创建的逻辑提取到一个新的测试类中的一个单独的测试方法中。现在，这个测试验证了它的名字的含义。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="cfcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从现在开始，旧的测试被简化了。它只专注于繁殖玩家。</p><p id="2f61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用来自Mockito的<code class="fe oa ob oc od b">mock()</code>方法创建了一个<code class="fe oa ob oc od b">RandomLocationSeed</code>类的伪实现。这在开始时似乎有点违反直觉，因为我们希望我们的测试验证玩家的生成是否如预期的那样工作。</p><p id="d9b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，我们应该测试可观察的行为，也就是“在地图上的随机位置繁殖玩家”然而，我们希望用我们可以控制的相关性来设置这个测试，因为随机性是我们无法控制的外部因素。</p><p id="dc43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我通过调用同样由Mockito提供的<code class="fe oa ob oc od b">when()</code>和<code class="fe oa ob oc od b">then()</code>函数来设置mock。这些函数用于配置调用方法时应该做什么。我简单地查询了<code class="fe oa ob oc od b">Board</code>对象以返回它的一个图块，每当调用<code class="fe oa ob oc od b">getTile()</code>函数时，它都会返回一个样本图块。</p><p id="8512" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于模仿<code class="fe oa ob oc od b">LocationSeed</code>的最后一件事是调用<code class="fe oa ob oc od b">verify()</code>方法，它检查模仿是否被调用过。</p><p id="d4ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上，我建议对上面的测试做最后一点小小的修改。事实上，我们是用存根来处理测试，而不是用模拟。它们之间的主要区别是mocks不返回值(它们充当命令)，而stubs确实返回值(它们充当查询)。</p><p id="d103" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在存根上调用<code class="fe oa ob oc od b">verify()</code>方法是一种不好的做法，因为它验证内部行为。在我们的案例中，可观察到的行为是“产生一个玩家”，因此查询图块只是业务案例的中间步骤。因此，让我们删除对<code class="fe oa ob oc od b">verify()</code>方法的调用，这样测试的最终版本将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试的最终版本，不检查模拟是否被调用</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/83f66e30127b90b9960a80cad4dcf6b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LYMxCIdAE4tnb8FnK9mAMA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试的最终版本已经通过</p></figure><h1 id="06cd" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">结论</h1><p id="3e18" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">如你所见，编程游戏可以和玩游戏一样有趣:)。</p><p id="db8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们总结一下从这个例子中得到的教训:</p><ul class=""><li id="d127" class="ma mb iq ky b kz la lc ld lf mc lj md ln me lr mf mg mh mi bi translated">不要让你的测试过于复杂</li><li id="bf74" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">如果您的测试做得太多，例如，包含多个<code class="fe oa ob oc od b">assert</code>语句并检查多个对象，考虑将这个测试分成更小的测试</li><li id="026c" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">不是所有的功能都适合直接测试(比如依赖于随机性的特性)</li><li id="c892" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated">在事情失去控制的地方使用mock/stub(测试随机性，但也跨越应用程序边界，比如调用文件系统、web服务/消息总线等等)</li></ul><h1 id="b87b" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">参考</h1><p id="5ca4" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">[1]:王南钧·什皮查考斯基，<em class="ls">让我们闻闻一些测试# 2</em><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/lets-smell-some-tests-2-asserting-the-internal-behavior-in-java-1c0f34fe8bbc">https://better programming . pub/Let-smeet-Some-Tests-2-asserting-the-internal-behavior-in-Java-1c 0 f 34 Fe 8 BBC</a></p></div></div>    
</body>
</html>