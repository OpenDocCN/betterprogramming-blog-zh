<html>
<head>
<title>Implement Polling Using RxJS in Your Angular Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Angular应用程序中使用RxJS实现轮询</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-polling-using-rxjs-in-your-angular-application-278129d5a9a9?source=collection_archive---------5-----------------------#2020-12-04">https://betterprogramming.pub/implement-polling-using-rxjs-in-your-angular-application-278129d5a9a9?source=collection_archive---------5-----------------------#2020-12-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b7e2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">或者在任何RxJS应用程序中</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e3594c10b4c52fe492e553c3b113fe9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cy7oUgXbNc2nZHbn-JNX9w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片。</p></figure><blockquote class="kv"><p id="04b0" class="kw kx iq bd ky kz la lb lc ld le lf dk translated">"最便宜、最快、最可靠的组件是那些不存在的."— <a class="ae lg" href="https://www.azquotes.com/quote/1058099" rel="noopener ugc nofollow" target="_blank">戈登·贝尔</a></p></blockquote><p id="4a4d" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb lf ij bi translated">Angular的强大之处在于它的反应式架构。<a class="ae lg" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>是Angular如何做到这一点的。RxJS <em class="mc"> </em>是有史以来使用最多的反应式JavaScript库，其受欢迎程度与日俱增。</p><p id="7384" class="pw-post-body-paragraph lh li iq lj b lk md jr lm ln me ju lp lq mf ls lt lu mg lw lx ly mh ma mb lf ij bi translated">在我以前的一篇文章中，我坦白了作为一个Angular开发者我后悔没有做的事情。没有深入学习RxJS就是其中之一，现在学习它是如此愉快的经历。</p><p id="a0b2" class="pw-post-body-paragraph lh li iq lj b lk md jr lm ln me ju lp lq mf ls lt lu mg lw lx ly mh ma mb lf ij bi translated">在本文中，我们将使用RxJS实现轮询逻辑。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="a9d2" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">什么是轮询？</h1><p id="fe1f" class="pw-post-body-paragraph lh li iq lj b lk nh jr lm ln ni ju lp lq nj ls lt lu nk lw lx ly nl ma mb lf ij bi translated">轮询只是一个技术术语，指的是客户机定期与服务器通信以获取一些数据的技术。例如，当您在服务器上处理大量数据(例如，需要一分钟以上才能完成)时，此过程非常耗时，您需要向用户提供有关该过程当前状态的视觉反馈。</p><p id="a3d2" class="pw-post-body-paragraph lh li iq lj b lk md jr lm ln me ju lp lq mf ls lt lu mg lw lx ly mh ma mb lf ij bi translated">您可能希望以固定的时间间隔对服务器进行HTTP调用，以检查状态并基于此操作UI。这是一个完美的投票用例。</p><p id="0c13" class="pw-post-body-paragraph lh li iq lj b lk md jr lm ln me ju lp lq mf ls lt lu mg lw lx ly mh ma mb lf ij bi translated">我们将以上面的例子为例，解释RxJS <em class="mc"> </em>如何帮助轻松实现这一点。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="4b3a" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">RxJS方式</h1><p id="b4b5" class="pw-post-body-paragraph lh li iq lj b lk nh jr lm ln ni ju lp lq nj ls lt lu nk lw lx ly nl ma mb lf ij bi translated">让我们直接跳到代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3601" class="pw-post-body-paragraph lh li iq lj b lk md jr lm ln me ju lp lq mf ls lt lu mg lw lx ly mh ma mb lf ij bi translated">该代码遵循以下执行流程:</p><ol class=""><li id="7fcd" class="no np iq lj b lk md ln me lq nq lu nr ly ns lf nt nu nv nw bi translated">使用<a class="ae lg" href="https://rxjs-dev.firebaseapp.com/api/index/function/interval" rel="noopener ugc nofollow" target="_blank"> RxJS区间</a>创建一个在连续区间上发出值的可观察值。</li><li id="067a" class="no np iq lj b lk nx ln ny lq nz lu oa ly ob lf nt nu nv nw bi translated">使用<code class="fe oc od oe of b"><a class="ae lg" href="https://rxjs-dev.firebaseapp.com/api/operators/switchMap" rel="noopener ugc nofollow" target="_blank">switchMap</a></code> <strong class="lj ir"> </strong>向服务器发出HTTP请求，检查操作的最新状态。您也可以使用<code class="fe oc od oe of b"><a class="ae lg" href="https://rxjs-dev.firebaseapp.com/api/operators/mergeMap" rel="noopener ugc nofollow" target="_blank">mergeMap</a></code> <strong class="lj ir"> </strong>，但是如果最后一个请求在间隔之外响应，我们不需要让它一直挂起。</li><li id="bb72" class="no np iq lj b lk nx ln ny lq nz lu oa ly ob lf nt nu nv nw bi translated">使用<code class="fe oc od oe of b"><a class="ae lg" href="https://rxjs-dev.firebaseapp.com/api/operators/takeWhile" rel="noopener ugc nofollow" target="_blank">takeWhile</a></code> <strong class="lj ir"> </strong>来决定何时停止轮询。这里的想法是，直到函数<code class="fe oc od oe of b">isStatusCompleted()</code> <em class="mc"> </em>返回一个falsy值，我们将保持轮询。</li><li id="a8e8" class="no np iq lj b lk nx ln ny lq nz lu oa ly ob lf nt nu nv nw bi translated">当状态检查返回<code class="fe oc od oe of b">true</code>时，可观察对象进入<em class="mc">完成</em>状态，我们可以执行需要在轮询完成时运行的逻辑。</li></ol><p id="2873" class="pw-post-body-paragraph lh li iq lj b lk md jr lm ln me ju lp lq mf ls lt lu mg lw lx ly mh ma mb lf ij bi translated">黑客快乐！</p></div></div>    
</body>
</html>