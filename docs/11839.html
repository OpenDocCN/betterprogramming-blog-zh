<html>
<head>
<title>How to Use the PatienceDiff Method in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Javascript中使用PatienceDiff方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-the-patiencediff-method-in-javascript-36e36be8ebd3?source=collection_archive---------13-----------------------#2022-04-20">https://betterprogramming.pub/how-to-use-the-patiencediff-method-in-javascript-36e36be8ebd3?source=collection_archive---------13-----------------------#2022-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="68a7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">处理用户输入和文档的JavaScript爱好者的必备知识</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3d583ecc70943729ac60878e72d31f81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nMChlHW_533QvB--"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">帕特里克·托马索在Unsplash<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">上的照片</a></p></figure><p id="6d09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您处理用户定义的输入时，您可能会发现，比较文本可以加快某些功能的速度，甚至是应用程序中的一项关键功能。例如，如果您正在处理一个需要实时处理用户输入的编辑器，那么最好只查找和处理被修改的文本块，而不是递归地处理整个文本。</p><p id="3384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在自然语言处理方面也可能需要它，我想到的第一个用例将适用于Jasper这样的应用程序，开发人员可以比较他们的ML模型的输出和用户写的句子。根据两种文本之间的差异，微调ML模型以匹配用户的写作风格。</p><p id="2da3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当代码变得太长而无法手动分析时，您可能还想用它来比较调整后的代码块与原始代码块。</p><h1 id="ea1c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">PatienceDiff方法是什么？</h1><p id="ac9a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">正如您所看到的，寻找两个文本之间的差异有各种用例，知道如何使用PatienceDiff JavaScript实现可以节省您的时间，因为这是一种将两个文本块中的行匹配起来的复杂方法，允许您将它们分成更小的片段。在对两个文档应用Patience Diff方法后，我们将很容易找到第二个文档与第一个文档不同的行。</p><p id="eaf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一件值得注意的事情是，我们将在PatienceDiff函数中传递要处理的数组，这意味着它不仅适用于文本行(尽管这是它的主要用例)，还适用于单个字符的变体，只是将文本作为逐字符数组传递，而不是逐行传递。</p><p id="36d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Patience diff的工作原理以及它与大多数diff方法相比的优势在<a class="ae ky" href="https://bramcohen.livejournal.com/73318.html" rel="noopener ugc nofollow" target="_blank">这篇小博文</a>中有详细描述。主要是，最大的实际优势是耐心差异不会匹配空白行或两个完全重写的文本之间的共同字符。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="4ba0" class="lv lw it bd lx ly mz ma mb mc na me mf jz nb ka mh kc nc kd mj kf nd kg ml mm bi translated">JavaScript实现</h1><p id="af41" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">耐心差异的JavaScript实现可以在<a class="ae ky" href="https://github.com/jonTrent/PatienceDiff/blob/dev/PatienceDiff.js" rel="noopener ugc nofollow" target="_blank">这里</a>找到。现在可以导入这个JavaScript文件并使用<code class="fe ne nf ng nh b">patienceDiff()</code>函数。让我们来看看如何使用它。</p><p id="952e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这个函数非常简单，假设我们有两个文本数组<code class="fe ne nf ng nh b">textOne</code>和<code class="fe ne nf ng nh b">textTwo</code>，我们现在可以如下调用耐心差异:<code class="fe ne nf ng nh b">patienceDiff(textOne, textTwo)</code>。现在我们来看一个更实际的例子。</p><p id="70c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们定义两个文本数组，然后调用<code class="fe ne nf ng nh b">patienceDiff</code>函数并记录diff ( <code class="fe ne nf ng nh b">diff.lines</code>)的结果:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="c7b5" class="nm lw it nh b gy nn no l np nq">const textOne = ['this is the first line of my text', '<strong class="nh iu">this is the second</strong>', 'this is the third']<br/>const textTwo = ['this is the first line of my text', '<strong class="nh iu">this the second is</strong>', 'this is the third']</span><span id="e6b9" class="nm lw it nh b gy nr no l np nq">const diff = patienceDiff(textOne, textTwo)<br/>console.log(diff.lines)</span></pre><p id="0da2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您对差异的理解，输出可能与您想象的不同:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/f8b9610dc680949579c2344ea05ae7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*qdrSWaXJ9qQhx4-d4afpzw.png"/></div></figure><p id="478b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是什么？<br/> 如果你还记得的话，patience diff做的事情是将两个文本块匹配起来；这正是这里发生的事情。从两个初始数组开始，Patience diff创建了一个数组，将两个文本的所有唯一行放在一起。事实上，只有索引1行(<code class="fe ne nf ng nh b">textOne[1]</code>和<code class="fe ne nf ng nh b">textTwo[1]</code>)在这个数组中被报告了两次，因为它是文本之间唯一发生变化的行。</p><p id="e2a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了正确地读取数组，您必须理解数组中每个对象的结构(<code class="fe ne nf ng nh b">[line, aIndex, bIndex]</code>)。直观地说，<code class="fe ne nf ng nh b">object.aIndex</code>表示第一次通过的数组中第<code class="fe ne nf ng nh b">object.line</code>行的索引，在我们的例子中是<code class="fe ne nf ng nh b">textOne</code>。另一方面，<code class="fe ne nf ng nh b">object.bIndex</code>表示第二次传递的数组中行<code class="fe ne nf ng nh b">object.line</code>的索引，在我们的例子中是<code class="fe ne nf ng nh b">textTwo</code>。</p><p id="84e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe ne nf ng nh b">object.bIndex</code>中的<code class="fe ne nf ng nh b">-1</code>出现时，意味着<code class="fe ne nf ng nh b">object.line</code>在第二次传递的数组(<code class="fe ne nf ng nh b">textTwo</code>中不同，反之，当<code class="fe ne nf ng nh b">object.aIndex</code>中的<code class="fe ne nf ng nh b">-1</code>出现时，则相反。</p><h2 id="878b" class="nm lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated">实际例子</h2><p id="8edb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，我将向您介绍我在文章开头谈到的第一个用例的实现:我们有一个文本的两个版本，我们希望找到在最新版本中发生变化的行。这些要更新的行将作为文本第二个版本中已更改的行的索引数组返回。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><ul class=""><li id="80c5" class="og oh it lb b lc ld lf lg li oi lm oj lq ok lu ol om on oo bi translated">在第[1，2]行中，我定义了文本的两个版本</li><li id="570c" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated">在第[5，6]行中，我使用了耐心差异并记录了输出数组</li><li id="83fa" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated">在第[9，15]行中，我启动了一个forEach循环:每当在<code class="fe ne nf ng nh b">line.aIndex</code>或<code class="fe ne nf ng nh b">line.bIndex</code>中发现一个<code class="fe ne nf ng nh b">-1</code>，就在我们要更新的索引列表中添加<code class="fe ne nf ng nh b">aIndex</code>和<code class="fe ne nf ng nh b">bIndex</code>T5的总和。<strong class="lb iu">为什么会这样？</strong>我们需要找到当前行的索引(因为它是需要更新的行)，我们也知道<code class="fe ne nf ng nh b">line.aIndex</code>或<code class="fe ne nf ng nh b">line.bIndex</code>将始终是<code class="fe ne nf ng nh b">-1</code>，因为<code class="fe ne nf ng nh b">line</code>已经通过了if条件，这意味着<code class="fe ne nf ng nh b">aIndex</code>和<code class="fe ne nf ng nh b">bIndex</code>的和将始终是<code class="fe ne nf ng nh b">lineIndex-1</code>，所以我们用一个<code class="fe ne nf ng nh b">+1</code>来平衡等式。这不是一个完美的解决方案，但是在我们的例子中非常好，因为我们不需要再次调用<code class="fe ne nf ng nh b">diff.lines</code>数组来查询它的索引。</li><li id="dec5" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated">最后，在第[15，16]行，我从<code class="fe ne nf ng nh b">toUpdate</code>列表中删除了所有重复的内容(我选择添加<code class="fe ne nf ng nh b">aIndex</code>和<code class="fe ne nf ng nh b">bIndex</code>以及for循环，然后删除其中一个，因为它给出了一个通用的解决方案，也适用于空白行删除)并记录了输出。</li></ul></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="06b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有用，一如既往地感谢你的阅读！</p></div></div>    
</body>
</html>