<html>
<head>
<title>Understanding the Boyer-Moore Algorithm…in Bits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Boyer-Moore算法…以位为单位</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-the-boyer-moore-algorithm-in-bits-247f6e66c820?source=collection_archive---------7-----------------------#2019-10-12">https://betterprogramming.pub/understanding-the-boyer-moore-algorithm-in-bits-247f6e66c820?source=collection_archive---------7-----------------------#2019-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b964" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用BMA的简化版本搜索字符串是否包含另一个字符串</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9ff51f86304c662d248c08dd08f51d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X6A3Y8GFMNfWcU4rajnpIA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">https://www.pexels.com/@pixabay皮查拜<a class="ae ky" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><p id="a6b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您经常编写代码，那么有时您必须搜索一个字符串是否包含另一个字符串。一个很好的例子是搜索数据库中的行，以了解用户名是否存在，或者是否有标题中包含特定单词的帖子。</p><p id="f47c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Boyer Moore算法(BMA)是用来完成这项任务的众多算法之一。本文使用BMA的一个简化版本，以比特为单位向您介绍算法背后的思想。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f21c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">天真的方式</h1><p id="54d2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们进入BMA <strong class="lb iu">，</strong>之前，让我们来看看任何人都会用来解决这个问题的典型方法。我们先这样做，这样你就可以看到BMA是如何优化搜索的。</p><p id="3adc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单的解决方案是从左到右遍历要搜索的字符串中的每个字符，并将该字符及其后的所有字符与要查找的字符串中的字符进行比较。</p><p id="570d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这给了我们一个时间复杂度为<strong class="lb iu"> </strong> O(n*m ),这不是很有效。下面的代码片段展示了搜索字符串的简单方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a4b2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">博耶-摩尔方式</strong></h1><h2 id="51e4" class="nb md it bd me nc nd dn mi ne nf dp mm li ng nh mo lm ni nj mq lq nk nl ms nm bi translated">我们如何知道一个字符串是匹配的？</h2><p id="1739" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我们将从这个算法的基本情况开始(当两个字符串匹配时)。将两个字符串放在一起比较时，BMA从右到左进行比较。</p><p id="057c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个比较两个长度相等的字符串的非常特殊的代码示例。(注意:这个代码片段不是完整的Boyer-Moore算法。这只是为了让你熟悉Boyer-Moore如何比较匹配的字符串。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="799c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从代码片段中，我们看到BMA从右到左比较字符串中的每个字符，直到<strong class="lb iu"> </strong>指针的索引为零。</p><p id="c06c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这是两个字符串长度相等的特殊情况，如果在任何字符中发现不匹配，<code class="fe nn no np nq b">haystack</code>的索引被设置为等于字符串长度的值，从而停止<code class="fe nn no np nq b">while</code>循环。</p><h2 id="6137" class="nb md it bd me nc nd dn mi ne nf dp mm li ng nh mo lm ni nj mq lq nk nl ms nm bi translated">如果字符串不等长会发生什么？</h2><p id="6427" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这里，我们将看到BMA如何优化它的字符串搜索。</p><p id="a15a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我将使用一个特例来使BMA在O(n)时间内运行。这样，您将关注于该位的主要目标(BMA <strong class="lb iu"> </strong>如何通过被搜索的字符串移动要被找到的字符串)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3905" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，每当出现不匹配时(对于这个测试用例，它将出现在最后一个字符处)，我们向前移动n-j个字符。</p><p id="2eb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当找到一个匹配时，我们继续向后遍历两个字符串，看看整个单词是否匹配。如果被比较的字符之间存在不匹配，那么我们将指针向前移动并重置j。</p><p id="f89b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个代码片段的最佳运行时间将是O(n) <strong class="lb iu"> </strong>但是当要搜索的字符串以重复字符作为其正确的前缀，并且要搜索的字符串以相同的重复字符作为其后缀时，它将具有O(nm)的时间复杂度。</p><p id="c93d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面给出一个例子:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="1299" class="nb md it nq b gy nv nw l nx ny">haystack = "aaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaa"<br/>needle = "baaaaaaaa"</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9516" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用火柴提高效率</h1><p id="0e66" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">虽然上面的算法具有O(n)的最佳时间复杂度，但是这不是完整的BMA <strong class="lb iu"> </strong>算法，并且最佳情况的时间复杂度仍然可以提高到O(n/m)。</p><p id="c27a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">BMA优化搜索的另一种方法是利用两个字符串之间的匹配字符。</p><p id="2f6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在比较<code class="fe nn no np nq b">haystack</code>和<code class="fe nn no np nq b">needle</code>时发现不匹配，并且<code class="fe nn no np nq b">haystack</code>的不匹配字符出现在<code class="fe nn no np nq b">needle</code> <strong class="lb iu">，</strong>的某处，其索引可用于跳过更多字符并减少要进行的比较次数。</p><p id="cb2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们构建一个字典，保存<code class="fe nn no np nq b">needle</code>中的每个字符及其出现的索引。如果出现不匹配，我们就检查它是否包含在字典中，并获取它的索引。</p><p id="d994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果它包含在字典中，并且它的索引小于正在检查的当前字符的索引，我们将<code class="fe nn no np nq b">needle</code>移动到这个字符。</p><p id="1874" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果该字符不包含在字典中，那么我们移动<code class="fe nn no np nq b">needle</code>，直到它的第一个字符现在与<code class="fe nn no np nq b">haystack</code>中不匹配字符之后的字符相比较。</p><p id="25fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码片段显示了移位操作:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="3f31" class="nb md it nq b gy nv nw l nx ny"># FIRST ITERATION WHEN MISMATCHED CHARACTER IS NOT FOUND IN NEEDLE</span><span id="f4e6" class="nb md it nq b gy nz nw l nx ny">HJKD<strong class="nq iu">L</strong>FAADFJ<br/>QWER<strong class="nq iu">T</strong></span><span id="c003" class="nb md it nq b gy nz nw l nx ny">T &amp; L are compared and they do not match. L is not contained in the needle so we shift the needle so that F &amp; Q are next to be compared</span><span id="4d5c" class="nb md it nq b gy nz nw l nx ny"># SECOND ITERATION</span><span id="5c48" class="nb md it nq b gy nz nw l nx ny">HJKDL<strong class="nq iu">F</strong>AADFJ<br/>     <strong class="nq iu">Q</strong>WERT<br/></span><span id="cc93" class="nb md it nq b gy nz nw l nx ny"># FIRST ITERATION WHEN MISMATCHED CHARACTER IS FOUND IN NEEDLE</span><span id="e2aa" class="nb md it nq b gy nz nw l nx ny">HJKD<strong class="nq iu">E</strong>FAADFJ<br/>QWER<strong class="nq iu">T</strong></span><span id="cfbc" class="nb md it nq b gy nz nw l nx ny"># SECOND ITERATION</span><span id="3673" class="nb md it nq b gy nz nw l nx ny">HJKDL<strong class="nq iu">E</strong>AADFJ<br/>   QW<strong class="nq iu">E</strong>RT</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的片段显示了完整的BMA。这在最好的情况下有O(n/m)的时间复杂度，在最坏的情况下有O(nm)的时间复杂度，只要你在针中出现的干草堆中有重复的字符。</p><p id="fe1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在大多数语言中，字符不会以这种方式出现。因此，在实践中，我们不太可能让BMA出现最坏的情况。</p><p id="cd4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这并不是我让你了解BMA的最后一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bfc9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">最后一位</strong></h1><p id="2a8b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当你看字典是如何形成的，你会注意到它是我们选择作为索引的一个字符的最后一次出现。</p><p id="ac2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们为什么要这么做？我将给出三个场景来解释这一点。</p><h2 id="c6cf" class="nb md it bd me nc nd dn mi ne nf dp mm li ng nh mo lm ni nj mq lq nk nl ms nm bi translated"><strong class="ak"> 1。当两个字符之间出现不匹配时</strong></h2><p id="2caf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在下面的代码片段中，不匹配出现在t处。<code class="fe nn no np nq b">haystack</code> <strong class="lb iu"> </strong>中的不匹配字符是E，在<code class="fe nn no np nq b">needle</code>中出现了两个E。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="6a02" class="nb md it nq b gy nv nw l nx ny">ASSD<strong class="nq iu">E</strong>EKDLFGFJGFLGKJHFGKF<br/>QWER<strong class="nq iu">T</strong>E</span></pre><p id="bcb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，看起来最佳的选择是从左边选择第一个E，因为这将给我们更多的跳跃。然而，这可能会导致不准确，你很快就会看到。</p><h2 id="e89f" class="nb md it bd me nc nd dn mi ne nf dp mm li ng nh mo lm ni nj mq lq nk nl ms nm bi translated"><strong class="ak"> 2。当两个字符</strong>前出现不匹配时</h2><p id="aed2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这里，在BMA中，我们选择哪个Es并不重要，因为它们都将被忽略，因为它们的索引大于不匹配的字符t。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="9e5f" class="nb md it nq b gy nv nw l nx ny">ASSD<strong class="nq iu">E</strong>EKDLFGFJGFLGKJHFGKF<br/>QWTR<strong class="nq iu">T</strong>EE</span></pre><h2 id="7e05" class="nb md it bd me nc nd dn mi ne nf dp mm li ng nh mo lm ni nj mq lq nk nl ms nm bi translated"><strong class="ak"> 3。当两个字符</strong>后出现不匹配时</h2><p id="e428" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这种情况下，我们将看到选择具有较小索引的重复字符是如何的错误。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="c694" class="nb md it nq b gy nv nw l nx ny"># FIRST ITERATION</span><span id="4c8f" class="nb md it nq b gy nz nw l nx ny">AZXEZM<strong class="nq iu">E</strong>LPOI<br/>ZXEZME<strong class="nq iu">L</strong></span><span id="b65e" class="nb md it nq b gy nz nw l nx ny"># SECOND ITERATION -- WHEN THE SMALLER INDEX IS USED</span><span id="fe19" class="nb md it nq b gy nz nw l nx ny">AZXEZM<strong class="nq iu">E</strong>LPOI<br/>    ZX<strong class="nq iu">E</strong>ZMEL</span><span id="dfb8" class="nb md it nq b gy nz nw l nx ny"># SECOND ITERATION -- WHEN THE LARGER INDEX IS USED</span><span id="fb65" class="nb md it nq b gy nz nw l nx ny">AZXEZM<strong class="nq iu">E</strong>LPOI<br/> ZXEZM<strong class="nq iu">E</strong>L</span></pre><p id="99a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的片段中我们可以看到，当我们使用较小的索引时，我们冒着跳过第二个重复字符可能出现的匹配(并导致完全匹配)的风险。</p><p id="cd74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，通过使用最后一个也是最大的索引，当我们遇到发生在<code class="fe nn no np nq b">needle</code>中的<code class="fe nn no np nq b">haystack</code>不匹配时，我们可以得到最大的、最安全的跳转。</p></div></div>    
</body>
</html>