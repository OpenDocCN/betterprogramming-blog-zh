# 如何在 Go 中使用 SQL

> 原文：<https://betterprogramming.pub/how-to-work-with-sql-in-go-ca8bc0b30722>

## 知道如何在 Go 中查询 SQL 数据库。正确的方式

![](img/2638c729d61f89821cc91459be24f8eb.png)

照片由 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的 [Sunder Muthukumaran](https://unsplash.com/@sunder_2k25?utm_source=medium&utm_medium=referral) 拍摄

这个故事基于一个关于在 Go 中使用 SQL 的好资源:[http://go-database-sql.org/](http://go-database-sql.org/)。我鼓励您查看它，全面了解 SQL 数据库的 Go 方法。

# 概观

在 Go 中使用 SQL 或类似 SQL 的数据库的惯用方式是通过`[database/sql package](http://golang.org/pkg/database/sql/)`。它为面向行的数据库提供了一个轻量级接口。这个包的文档告诉你每件事都做什么，但是没有告诉你如何使用这个包。我们中的许多人发现自己希望有一个快速的参考和一个讲述故事而不是列举事实的“入门”方向。这个故事就是关于这个的。我们走吧！

## sql。分贝

要在 Go 中访问数据库，可以使用一个 [sql。DB](https://pkg.go.dev/database/sql#DB) 。您可以使用这种类型来创建语句和事务、执行查询以及获取结果。

您应该知道的第一件事是`sql.DB`不是一个数据库连接。它也没有映射到任何特定数据库软件的“数据库”或“模式”概念它是数据库的抽象，可以像本地文件一样变化，可以通过网络连接访问，也可以在内存中和进程中访问。

`sql.DB`在幕后为你执行一些重要的任务:

*   它通过驱动程序打开和关闭与实际底层数据库的连接。
*   它根据需要管理一个连接池，可能是上面提到的各种东西。

`sql.DB`抽象旨在让您不必担心如何管理对底层数据存储的并发访问。多个 goroutines 并发使用是安全的。

当您使用某个连接来执行某项任务时，该连接会被标记为正在使用，当它不再使用时，会被返回到可用池中。这样做的一个后果是，如果您无法将连接释放回池中，您可能会导致`sql.DB`打开大量的连接，潜在地耗尽资源(太多的连接，太多的打开文件句柄，缺少可用的网络端口，等等)。我们稍后会详细讨论这一点。

## 数据库驱动程序

要使用`database/sql`,你需要软件包本身，以及你想要使用的特定数据库的驱动程序。

你通常不应该直接使用驱动包，尽管有些驱动鼓励你这样做。(在我们看来，这通常是个坏主意。)相反，如果可能的话，您的代码应该只引用在`database/sql`中定义的类型。这有助于避免使您的代码依赖于驱动程序，因此您可以用最少的代码更改来更改底层驱动程序(以及您正在访问的数据库)。这也迫使你使用 Go 习惯用法，而不是某个特定驱动作者可能提供的特别习惯用法。

Go 标准库中不包含数据库驱动程序。但是有很多是作为第三方实现的，参见[https://golang.org/s/sqldrivers](https://golang.org/s/sqldrivers)。

出于演示目的，我们将使用优秀的 [MySQL 驱动程序](https://github.com/go-sql-driver/mysql)。

将以下内容添加到 Go 源文件的顶部:

```
import (
	"database/sql"
	_ "github.com/go-sql-driver/mysql"
)
```

请注意，我们正在匿名加载驱动程序，将它的包限定符别名化为`_`,因此它的导出名称对我们的代码都不可见。在幕后，驱动程序将自己注册为对`database/sql`包可用，但是一般来说，除了 init 函数运行之外，不会发生任何其他事情。

现在您已经准备好访问数据库了。

# 访问数据库

现在您已经加载了驱动程序包，您已经准备好创建一个数据库对象，一个`sql.DB`。

要创建一个`sql.DB`，您需要使用`sql.Open()`。这将返回一个`*sql.DB`:

```
func main() {
	db, err := sql.Open("mysql",
		"user:password@tcp(127.0.0.1:3306)/hello")
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()
}
```

在所示的例子中，我们举例说明了几件事:

1.  `sql.Open`的第一个参数是驱动程序名。这是驱动程序用来向`database/sql`注册自己的字符串，通常与包名相同以避免混淆。例如，`mysql`代表[github.com/go-sql-driver/mysql](https://github.com/go-sql-driver/mysql)。有些驱动不遵循惯例，使用数据库名，例如`sqlite3`代表[github.com/mattn/go-sqlite3](https://github.com/mattn/go-sqlite3)和`postgres`代表[github.com/lib/pq](https://github.com/lib/pq)。
2.  第二个参数是特定于驱动程序的语法，它告诉驱动程序如何访问底层数据存储。在本例中，我们连接到本地 MySQL 服务器实例中的“hello”数据库。
3.  您应该始终检查并处理所有`database/sql`操作返回的错误。
4.  对于`defer db.Close()`来说，如果`sql.DB`不应该有超出函数范围的生存期，这是惯用的。

也许与直觉相反，`sql.Open()`没有建立到数据库的任何连接，也没有验证驱动程序连接参数。相反，它只是为以后的使用准备数据库抽象。当第一次需要时，第一个到底层数据存储的实际连接将被延迟建立。如果您想立即检查数据库是否可用和可访问(例如，检查您是否可以建立网络连接并登录)，使用`db.Ping()`来完成，并记住检查错误:

```
err = db.Ping()
if err != nil {
	// do something here
}
```

尽管当您使用完数据库时习惯于使用`Close()`，但是`sql.DB`对象被设计成是长期存在的。不要频繁的`Open()`和`Close()`数据库。相反，为您需要访问的每个不同的数据存储创建一个`sql.DB`对象，并保留它，直到程序访问完那个数据存储。根据需要传递它，或者让它在全球范围内可用，但要保持开放。并且不要从一个短命的函数`Open()`和`Close()`。相反，将`sql.DB`作为一个参数传递给这个短期函数。

# 检索结果集

Go 的`database/sql`函数名很重要。如果一个函数名包含`Query`，它被设计成询问数据库的一个问题，并且将返回一组行，即使它是空的。不返回行的语句不应使用`Query`函数；他们应该使用`Exec()`。

## 从数据库获取数据

让我们看一个例子，看看如何查询数据库，处理结果。我们将在`users`表中查询一个`id`为 1 的用户，并打印出该用户的`id`和`name`。我们将用`rows.Scan()`将结果分配给变量，一次一行。

下面是上面代码中发生的情况:

1.  我们使用`db.Query()`将查询发送到数据库。像往常一样，我们检查错误。
2.  我们推迟`rows.Close()`。这一点非常重要。
3.  我们用`rows.Next()`遍历这些行。
4.  我们用`rows.Scan()`将每行中的列读入变量。
5.  我们在完成对行的迭代后检查错误。

这几乎是围棋中唯一的方法。例如，你不能把一行作为一个地图。那是因为一切都是强类型的。您需要创建正确类型的变量，并将指针传递给它们，如下所示。

这其中的几个部分很容易出错，并可能产生不良后果。

*   `rows.Next()`指示结果集中的下一行是否可用，并将返回`true`，直到结果集用尽或者在获取数据期间出现错误。因此，你应该在`for rows.Next()`循环结束时检查错误(这是通过调用`rows.Err()`完成的)。如果在循环过程中有错误，你需要知道它。不要只是假设循环会迭代，直到处理完所有的行。
*   第二，只要有一个打开的结果集(由`rows`表示)，底层连接就是繁忙的，在`rows.Close()`被调用之前不能用于任何其他查询。这意味着它在连接池中不可用。关于`database/sql`的好处是，当`rows.Next()`返回`false`时，它会隐式地为您调用`rows.Close()`，但是如果您过早地退出循环，那么您有责任关闭这些行，否则连接将被占用，无法用于其他操作，从而导致连接泄漏。因此，根据经验，您应该总是`defer rows.Close()`，以避免连接泄漏和资源耗尽。
*   `rows.Close()`是一个无害的 no-op，如果它已经被关闭，那么多次调用它是可以的。但是，请注意，我们首先检查来自`db.Query()`的错误，只有在没有错误的情况下才推迟`rows.Close()`，以避免运行时混乱(例如，当从`db.Query()`方法返回错误时，`rows`对象将是`nil`)。

## Scan()的工作原理

当您遍历行并将它们扫描到目标变量中时，Go 会在后台为您执行数据类型转换工作。它基于目标变量的类型。意识到这一点可以清理您的代码，并有助于避免重复工作。

例如，假设您从一个用字符串列定义的表中选择一些行，比如`VARCHAR(45)`或类似的。然而，您碰巧知道该表总是包含数字。如果你传递一个指向字符串的指针，Go 会把字节复制到字符串中。现在您可以使用`strconv.ParseInt()`或类似的方法将值转换为数字。您必须检查 SQL 操作中的错误，以及解析整数时的错误。这是混乱和乏味的。

或者，你可以只传递给`Scan()`一个指向整数的指针。Go 会检测到并为你调用`strconv.ParseInt()`。如果转换中有错误，对`Scan()`的调用将返回错误。您的代码现在更整洁、更小了。这是推荐使用`database/sql`的方式。

## 单行查询

如果查询最多返回一行，您可以在一些冗长的样板代码周围使用快捷方式:

来自查询的错误被推迟，直到调用`Scan()`，然后从那里返回。

# 修改数据

使用`Exec()`，完成一个`INSERT`、`UPDATE`、`DELETE`或另一个不返回行的语句(可能是特定于数据库的)。以下示例显示了如何插入一行并检查有关该操作的元数据:

执行该语句会产生一个`sql.Result`,用于访问语句元数据:最后插入的 ID 和受影响的行数。

如果你不在乎结果呢？如果您只想执行一条语句并检查是否有错误，但忽略结果，该怎么办？下面两种说法不也是这样吗？

```
_, err := db.Exec("DELETE FROM users")  // OK
_, err := db.Query("DELETE FROM users") // BAD
```

答案是否定的。它们不做同样的事情，你永远不应该这样使用`Query()`。`Query()`将返回一个`sql.Rows`，它保留一个数据库连接，直到`sql.Rows`关闭。由于可能存在未读数据(例如，更多数据行)，因此无法使用该连接。在上面的例子中，连接将*不再*被释放。因此，这种反模式是耗尽资源的好方法(例如，连接太多)。

# 摘要

我们探索了使用标准`database/sql`包在 Go 编程语言中使用 SQL 数据库的惯用方法。为了简洁起见，先不讨论事务和准备好的语句的高级概念。

如果您需要更多关于如何在`database/sql`中处理事务和预准备语句的细节，我鼓励您查看优秀的 golang SQL 教程:【http://go-database-sql.org/index.html】。