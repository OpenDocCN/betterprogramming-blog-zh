<html>
<head>
<title>Is Vite Really Faster Than Webpack?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vite真的比Webpack快吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/is-vite-really-faster-than-webpack-b414f6cc751c?source=collection_archive---------0-----------------------#2022-11-27">https://betterprogramming.pub/is-vite-really-faster-than-webpack-b414f6cc751c?source=collection_archive---------0-----------------------#2022-11-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3052" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对于较大的代码库来说，这就不那么简单了</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/23666fcff993624379ac9ac4e52b85c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AOlky2Jja5cAf8EgxNi-fA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://npmtrends.com/vite" rel="noopener ugc nofollow" target="_blank">https://npmtrends.com/vite</a></p></figure><p id="4b8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://vitejs.dev/" rel="noopener ugc nofollow" target="_blank">维特</a>在前端社区制造了一些噪音。npm上的下载量去年翻了两番，而且越来越受欢迎。</p><p id="a0a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你在他们的网站上读到的关于Vite的第一件事是，他们的名字在法语中的意思是“快”。Vite承诺显著提高性能，那么Vite是如何实现的呢？</p><p id="402a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Webpack和其他传统的捆绑器使用古老的方法操作，读取所有的源代码并将其编译成几个JS文件。</p><p id="a4cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有主流浏览器都支持ESM已经有好几年了，所以Vite采取了不同的方法。它将您的源代码原样输入到您的浏览器中，并让它自己处理模块的导入。这大大加快了构建过程，因为开发工作不再需要捆绑。</p><p id="36c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但和往常一样，这里有一个陷阱。</p><p id="74cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">浏览器需要时间来解析本机模块。打开一个包比打开数百个依赖项要快得多。那么表演到底有多大的不同呢？我用不同数量的文件制作了一些模拟项目来说明性能上的差异。</p><h1 id="81c9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">标杆管理</h1><p id="b482" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我制作了一个脚本，用Vite和Webpack自动生成一个现成的项目，还创建了预设数量的模拟组件，这些组件都呈现在一个页面上。你可以在这里找到GitHub链接<a class="ae kv" href="https://github.com/grumd/vite-vs-webpack" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="df2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我用<code class="fe mp mq mr ms b">npm start</code>启动了一个自动生成的项目，并记录了两个指标:</p><ol class=""><li id="dbf4" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">bundler报告的建造时间。</li><li id="7344" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">Chrome开发工具报告的加载时间。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/dc7b919513759c88b04410b6da50bac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vmJC9y5GRk_ZYS0GbI_w7Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">是的，这个图表不是对数的，很难看出较小项目的捆扎机之间的确切差异。那是因为在现实世界中使用它们时，你也不会感觉到区别！</p></figure><p id="0a53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于较小的包大小，Vite胜于Webpack，但是对于500个以上的文件，Webpack设法更快地编译一个包。文件越多，差别越大。当你的包大得不合理时，Vite会让你慢几十秒。</p><p id="8081" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">浏览器不能在几秒钟内高效地获取数千个文件，这并不奇怪。因为你真的不应该在一个JS包中包含5000个文件。</p><h1 id="1b67" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">代码分裂来拯救！</h1><p id="6777" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">实际上，您应该在需要的时候随时加载JS代码。你的初始块应该尽可能小。这通常是通过路由实现的，当您导航到需要延迟加载模块的路由时，路由器会处理这些模块。<a class="ae kv" href="https://reactjs.org/docs/code-splitting.html" rel="noopener ugc nofollow" target="_blank">阅读React文档中的更多信息</a>。</p><p id="3bda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Vite和代码分割，您的浏览器将只获取小批量的JS文件，从而获得更好的性能。</p><p id="3174" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是Webpack并没有人们想象的那么落后。从5.20开始，Webpack可以延迟动态导入模块的编译。使用<code class="fe mp mq mr ms b"><a class="ae kv" href="https://webpack.js.org/configuration/experiments/#experimentslazycompilation" rel="noopener ugc nofollow" target="_blank">experiments.lazyCompilation</a></code> config选项，您的构建性能也可以通过代码分割得到显著提高。</p><p id="5c72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那我们就基准吧！</p><p id="72cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一次，我使用相同的自动生成的项目，但是这数百个组件现在是延迟加载的，所以最初的部分基本上是一个几乎空的项目。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/7eee74cc1eb5a9e3332abf64e892d285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pww9gJEtOjGZXXThkP0u-Q.png"/></div></div></figure><p id="4d91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/8fea926e46574160cae499c91ede8c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y_vVy_u6_mnMbZE3UjKO0Q.png"/></div></div></figure><p id="5fc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这与我们在项目中拥有的10个文件的图片相同。相差不到一秒，但维特确实在这里赢了。这不应该让任何人感到惊讶！当您延迟加载几乎所有东西时，您的初始构建时间会尽可能的短。如果你能保持你所有的块合理的小，Vite将继续给你带来快速构建的好处。</p><h1 id="827d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="c719" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果你能对你的应用程序进行代码分割，并保持你的程序块较小，Vite将在这里和那里为你节省半秒钟。</p><p id="313e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是Webpack并不像人们想象的那么落后，特别是因为像<code class="fe mp mq mr ms b">lazyCompilation</code>和<code class="fe mp mq mr ms b"><a class="ae kv" href="https://swc.rs/docs/usage/swc-loader" rel="noopener ugc nofollow" target="_blank">swc-loader</a></code>这样的创新。如果您的Webpack构建需要30多秒，您可能希望首先使用这些更新的选项来优化您的配置。</p><p id="4805" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您希望对模糊的用例有更广泛的支持，或者如果您的初始包块很大并且您不能分割它，Webpack仍然是一个好的选择。</p><p id="9ffa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Vite是更现代的方法，具有更简单的设置和配置，并且马上就有很好的性能。</p><p id="53d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终，一切都取决于你和你的需求！</p></div></div>    
</body>
</html>