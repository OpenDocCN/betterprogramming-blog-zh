<html>
<head>
<title>An Effortless Guide to Automation Testing using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python进行自动化测试的轻松指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-effortless-guide-to-automation-testing-using-python-2fd387ef4469?source=collection_archive---------4-----------------------#2021-11-30">https://betterprogramming.pub/an-effortless-guide-to-automation-testing-using-python-2fd387ef4469?source=collection_archive---------4-----------------------#2021-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="a687" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">想要在您的项目中创建一个安全网吗？</h2><div class=""/><div class=""><h2 id="f8dd" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">通过GitHub Actions引入端到端持续集成(CI)实现的单元和文档测试</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/191c9694fda723132029aa8a62d462dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*QH-O7_mwyJLCcNXSZfjxOw.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated"><a class="ae la" href="https://cartoontester.blogspot.com/" rel="noopener ugc nofollow" target="_blank">卡通测试员——安迪·格洛弗</a></p></figure><p id="3bd5" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">让我告诉你一个情况。我们对项目需求有着完美的理解。我们开始相应地开发脚本，并轻松地完成了脚本！万岁现在开始敲定脚本的过程。在这里，我们将变更提交到我们的存储库中。</p><p id="4584" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">我们成功地降低了产量！这听起来熟悉吗？当涉及多个开发人员，每个开发人员不断地将他们的脚本提交到存储库中时，也会出现这种情况。我们怎样才能避免这样的不幸呢？唯一的解决办法就是测试。在本文中，我们将深入探讨文档测试和单元测试。我们将演示一些流行的测试，这些测试是任何开发人员都必须包含在脚本中的。</p><blockquote class="lx"><p id="b28d" class="ly lz iq bd ma mb mc md me mf mg lw dk translated">除了测试行为，设计测试的行为是已知的最好的错误预防措施之一。</p></blockquote><p id="5a3a" class="pw-post-body-paragraph lb lc iq ld b le mh ka lg lh mi kd lj lk mj lm ln lo mk lq lr ls ml lu lv lw ij bi translated">在本文的最后，我们将有一个GitHub动作的小演示。我们将在一个验证我们定义的测试用例的存储库中建立持续集成。</p><blockquote class="mm mn mo"><p id="f5e4" class="lb lc mp ld b le lf ka lg lh li kd lj mq ll lm ln mr lp lq lr ms lt lu lv lw ij bi translated">为了节省时间，我们将直接开始为这两个主题定义测试用例。放心吧！该主题的完整文档位于我的<a class="ae la" href="https://github.com/ginelledsouza/Continuous-Integration" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中。</p></blockquote><h1 id="a677" class="mt mu iq bd mv mw mx my mz na nb nc nd kf ne kg nf ki ng kj nh kl ni km nj nk bi translated"><strong class="ak">文件测试</strong></h1><p id="bfa3" class="pw-post-body-paragraph lb lc iq ld b le nl ka lg lh nm kd lj lk nn lm ln lo no lq lr ls np lu lv lw ij bi translated">作为开发人员，我们必须在脚本中附上有价值的文档。因此，我们在定义下面的函数/方法时，总是提到它们的用途。如果我们也可以在文档中定义一个测试用例会怎么样。这难道不会让我们的生活变得更好吗？该死，当然会！在这里，文档测试开始发挥作用。Python有一个名为doctest的内置模块。该模块将函数/方法处理的输出与我们在文档中定义的输出进行比较。</p><p id="f087" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">对单个输出的测试可以通过互联网获得，但是用熊猫来测试？激动人心！让我们开始吧！</p><h2 id="a51a" class="nu mu iq bd mv nv nw dn mz nx ny dp nd lk nz oa nf lo ob oc nh ls od oe nj iw bi translated"><strong class="ak">测试熊猫数据帧</strong></h2><p id="0b07" class="pw-post-body-paragraph lb lc iq ld b le nl ka lg lh nm kd lj lk nn lm ln lo no lq lr ls np lu lv lw ij bi translated">某些功能负责预处理<code class="fe nq nr ns nt b">dataframes</code>，引入增强数据的附加功能。下面的例子是一个接受<code class="fe nq nr ns nt b">dataframe</code>来分析平板手机设备类型的函数。该函数返回处理后的<code class="fe nq nr ns nt b">dataframe</code>。</p><p id="c172" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">在定义我们的测试用例之前，有一个用于测试的虚拟数据集是非常重要的。让我们仔细看看文档字符串，即下面给出的例子中的<code class="fe nq nr ns nt b">“””________“””</code>。请注意，在docstring的定义之前或之后不能有任何额外的行。</p><p id="7b45" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><strong class="ld ja">代码</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="31e3" class="nu mu iq bd mv nv nw dn mz nx ny dp nd lk nz oa nf lo ob oc nh ls od oe nj iw bi translated"><strong class="ak">代码解释</strong></h2><ol class=""><li id="7656" class="oh oi iq ld b le nl lh nm lk oj lo ok ls ol lw om on oo op bi translated">在docstring中，我们需要调用测试函数并提供预期的输出。函数<code class="fe nq nr ns nt b">DeviceType(Data)</code>由docstring post &gt; &gt; &gt;调用。</li><li id="eca3" class="oh oi iq ld b le oq lh or lk os lo ot ls ou lw om on oo op bi translated">现在，我们将定义预期的输出。输出字符串是<code class="fe nq nr ns nt b">dataframe</code>的复制品。我必须说，这是一个棘手的部分！所以，让我给你一个建议。</li></ol><ul class=""><li id="5879" class="oh oi iq ld b le lf lh li lk ov lo ow ls ox lw oy on oo op bi translated">始终保持虚拟<code class="fe nq nr ns nt b">dataframe</code>最多5条记录。</li><li id="00d5" class="oh oi iq ld b le oq lh or lk os lo ot ls ou lw oy on oo op bi translated">在单独的脚本中运行带有虚拟参数<code class="fe nq nr ns nt b">DeviceType(Dummy)</code>的函数<code class="fe nq nr ns nt b">DeviceType()</code>。</li><li id="5afa" class="oh oi iq ld b le oq lh or lk os lo ot ls ou lw oy on oo op bi translated">我们现在复制并粘贴输出字符串，并在docstring中定义它。</li></ul><p id="9620" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">3.要运行该脚本，我们必须使用以下命令。</p><pre class="kp kq kr ks gt oz nt pa pb aw pc bi"><span id="b581" class="nu mu iq nt b gy pd pe l pf pg">python DoctestScript.py -v, <br/>where v denotes verbose.</span></pre><p id="e394" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><strong class="ld ja">输出</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/6c893430953cad60eec3a43c2344ca59.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*lfktZGhhus03Kuf6KxV-5g.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">测试熊猫数据帧—输出</p></figure><h2 id="4a5a" class="nu mu iq bd mv nv nw dn mz nx ny dp nd lk nz oa nf lo ob oc nh ls od oe nj iw bi translated"><strong class="ak">测试已处理的文本</strong></h2><p id="a068" class="pw-post-body-paragraph lb lc iq ld b le nl ka lg lh nm kd lj lk nn lm ln lo no lq lr ls np lu lv lw ij bi translated">我们现在将关注于为函数返回的字符串/文本创建测试用例。这里我们将演示文档测试，其中给定的数据被处理并提供文本输出。</p><p id="a5b1" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><strong class="ld ja">代码</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="067e" class="nu mu iq bd mv nv nw dn mz nx ny dp nd lk nz oa nf lo ob oc nh ls od oe nj iw bi translated"><strong class="ak">代码解释</strong></h2><ol class=""><li id="0a29" class="oh oi iq ld b le nl lh nm lk oj lo ok ls ol lw om on oo op bi translated">如上例所述，我们将测试指令放在docstring中。我们首先调用<code class="fe nq nr ns nt b">Main(Dummy_final_test)</code>函数和虚拟参数post &gt; &gt; &gt;。</li><li id="5459" class="oh oi iq ld b le oq lh or lk os lo ot ls ou lw om on oo op bi translated">在我们的测试docstring中，我们将提供一个预期的输出字符串来验证所实现的输出。</li><li id="eff2" class="oh oi iq ld b le oq lh or lk os lo ot ls ou lw om on oo op bi translated">与上面的例子类似，我们使用<code class="fe nq nr ns nt b">python DoctestScript.py -v</code>来执行脚本。</li></ol><p id="e099" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><strong class="ld ja">输出</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="pj pk di pl bf pm"><div class="gh gi pi"><img src="../Images/11c8ea2a22a2fe5633e5d174a6795149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OlejvXKzGZmHY3v58FbEHg.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">测试已处理的文本—输出</p></figure><h1 id="1d43" class="mt mu iq bd mv mw mx my mz na nb nc nd kf ne kg nf ki ng kj nh kl ni km nj nk bi translated"><strong class="ak">单元测试</strong></h1><p id="31e9" class="pw-post-body-paragraph lb lc iq ld b le nl ka lg lh nm kd lj lk nn lm ln lo no lq lr ls np lu lv lw ij bi translated">在单元测试中，开发人员测试一个模块，以验证该模块是否没有错误。对系统的单个单元进行了分析。如果有错误，开发人员会在将模块投入生产之前纠正它们。我们将使用用于演示单元测试的两种方法。</p><h2 id="7aa2" class="nu mu iq bd mv nv nw dn mz nx ny dp nd lk nz oa nf lo ob oc nh ls od oe nj iw bi translated"><strong class="ak"> 1。assertEqual() </strong></h2><p id="356d" class="pw-post-body-paragraph lb lc iq ld b le nl ka lg lh nm kd lj lk nn lm ln lo no lq lr ls np lu lv lw ij bi translated"><code class="fe nq nr ns nt b">assertEqual()</code>是一个单元测试库函数，用来测试两个值是否相等。该函数接受三个参数作为输入——来自已处理函数的值、期望值和错误消息。它将根据两个值的比较返回一个布尔值。如果两个值相等，该方法将返回true，否则返回false。</p><h2 id="0a1a" class="nu mu iq bd mv nv nw dn mz nx ny dp nd lk nz oa nf lo ob oc nh ls od oe nj iw bi translated"><strong class="ak"> 2。pandas . testing . assert _ frame _ equal()</strong></h2><p id="4f3a" class="pw-post-body-paragraph lb lc iq ld b le nl ka lg lh nm kd lj lk nn lm ln lo no lq lr ls np lu lv lw ij bi translated">该函数比较两个数据帧，并提供表示两者之间任何差异的输出。还有一些额外的参数允许开发者增加测试难度。</p><p id="d976" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><strong class="ld ja">代码</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="7ae7" class="nu mu iq bd mv nv nw dn mz nx ny dp nd lk nz oa nf lo ob oc nh ls od oe nj iw bi translated"><strong class="ak">代码解释</strong></h2><ol class=""><li id="3488" class="oh oi iq ld b le nl lh nm lk oj lo ok ls ol lw om on oo op bi translated">与单元测试的文档测试不同，我们需要创建一个专用的Python脚本来封装我们想要运行的测试。因此，对于这个例子，我们创建了一个单独的脚本<code class="fe nq nr ns nt b">TestCases.py</code></li><li id="c7e5" class="oh oi iq ld b le oq lh or lk os lo ot ls ou lw om on oo op bi translated"><code class="fe nq nr ns nt b">DummyData and DummyDataResult</code>:我们现在将验证<code class="fe nq nr ns nt b">dataframe</code>的神智是否正常。我们需要定义要测试的原始<code class="fe nq nr ns nt b">dataframe</code>和预期的结果<code class="fe nq nr ns nt b">dataframe</code>。</li><li id="d736" class="oh oi iq ld b le oq lh or lk os lo ot ls ou lw om on oo op bi translated"><code class="fe nq nr ns nt b">DummyData = test.DataCleaning(DummyData)</code>:我们需要从测试模块导入函数。</li><li id="e01d" class="oh oi iq ld b le oq lh or lk os lo ot ls ou lw om on oo op bi translated"><code class="fe nq nr ns nt b">assertEqual(DummyData.shape, (2, 9), “Data Cleaning Module Check Failed”)</code>:我们比较<code class="fe nq nr ns nt b">dataframe</code>的实际尺寸和预期尺寸。如果它们之间有任何不一致，该函数将抛出一条错误消息——“数据清理模块检查失败”</li><li id="5569" class="oh oi iq ld b le oq lh or lk os lo ot ls ou lw om on oo op bi translated"><code class="fe nq nr ns nt b">pd.testing.assert_frame_equal(DummyData.reset_index(drop=True), DummyDataResult.reset_index(drop=True), check_dtype=True)</code>:验证已处理<code class="fe nq nr ns nt b">dataframe</code>和预期<code class="fe nq nr ns nt b">dataframe</code>内的值。如果它们之间有任何不一致，该函数将提供差异。我们将使用<code class="fe nq nr ns nt b">check_dtype</code>参数来增加测试的难度。<code class="fe nq nr ns nt b">check_dtype</code>验证两个<code class="fe nq nr ns nt b">dataframes</code>中的值以及两个值的数据类型。</li></ol><p id="cd65" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><strong class="ld ja">输出</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/64505767e85bb4ccebde03e93e57cefe.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*m0WQ97y7SWEH1al0SZko5A.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated"><strong class="bd po">执行命令:python TestCases.py </strong></p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="pj pk di pl bf pm"><div class="gh gi pp"><img src="../Images/1534b3525316787bbd594500d703ec92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RKwI_jgP76OuPuhWgbCpjg.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated"><strong class="bd po">执行命令:python TestCases.py -v </strong></p></figure><h1 id="6296" class="mt mu iq bd mv mw mx my mz na nb nc nd kf ne kg nf ki ng kj nh kl ni km nj nk bi translated"><strong class="ak"> GitHub动作</strong></h1><p id="4841" class="pw-post-body-paragraph lb lc iq ld b le nl ka lg lh nm kd lj lk nn lm ln lo no lq lr ls np lu lv lw ij bi translated">Github Actions允许您直接在Github存储库中创建工作流。这些工作流是不同的任务，称为操作。某些事件可能会触发动作。持续集成(CI)和持续部署(CD)是GitHub Actions最受欢迎的两个特性。</p><ol class=""><li id="31b6" class="oh oi iq ld b le lf lh li lk ov lo ow ls ox lw om on oo op bi translated">创建新的存储库，并在主分支内上传脚本</li><li id="8604" class="oh oi iq ld b le oq lh or lk os lo ot ls ou lw om on oo op bi translated">GitHub Actions为我们提供了一台机器来针对所有指定的测试用例执行提交的脚本。我们需要一个requirements.txt来指定脚本中使用的库</li><li id="548c" class="oh oi iq ld b le oq lh or lk os lo ot ls ou lw om on oo op bi translated">我们现在开始为持续集成(CI)设置工作流</li></ol><ul class=""><li id="2b3e" class="oh oi iq ld b le lf lh li lk ov lo ow ls ox lw oy on oo op bi translated">在下图中，我们观察点(1)。一旦我们成功设置了工作流，就会在突出显示的框中看到一个状态符号。因此，让我们从选择点(2)行动开始。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="pj pk di pl bf pm"><div class="gh gi pq"><img src="../Images/58cb61a99d5eda6017e91c980d25bce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gl0THOYxotYXYB-1KMeWpA.png"/></div></div></figure><ul class=""><li id="81b3" class="oh oi iq ld b le lf lh li lk ov lo ow ls ox lw oy on oo op bi translated">基于存储库中提交的脚本，GitHub推荐各种工作流。我们可以从可用的工作流程中选择任何一个。但是，我们将设置我们的自定义工作流。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="pj pk di pl bf pm"><div class="gh gi pq"><img src="../Images/731b1bae9960ac0283cddf36a0b45a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zJ7l-ah4ZVt_yMaTpba_mw.png"/></div></div></figure><ul class=""><li id="a994" class="oh oi iq ld b le lf lh li lk ov lo ow ls ox lw oy on oo op bi translated">我们的工作流文件将驻留在。github\workflows\ <workflow_name> .yml .正如我们所看到的，我们有一个基本动作的框架yml文件。我们将修改这些并添加一个命令来安装requirements.txt并执行我们的测试用例脚本。</workflow_name></li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="pj pk di pl bf pm"><div class="gh gi pq"><img src="../Images/53d5718c906f668e4653479dd7cd8649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aRcxAl2XQ7q3Q5GlxKx3Eg.png"/></div></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="of og l"/></div></figure><ul class=""><li id="be7b" class="oh oi iq ld b le lf lh li lk ov lo ow ls ox lw oy on oo op bi translated">一旦我们建立了我们的工作流，我们需要提交变更到主分支。当测试用例被验证时，显示的状态符号是一个小的橙色圆圈。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="pj pk di pl bf pm"><div class="gh gi pq"><img src="../Images/50ffa3e34611cda2e47e1b4ea77fcb85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zG-hJpPnaep2nam3bto4GQ.png"/></div></div></figure><ul class=""><li id="e03a" class="oh oi iq ld b le lf lh li lk ov lo ow ls ox lw oy on oo op bi translated">我们已经成功设置了我们的工作流，并可以通过检查状态符号(显示为绿色对勾)来验证这一点。</li></ul><p id="e2ef" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">4.如果在更新存储库中的脚本时出现任何错误，可以通过日志来跟踪错误。我们可以看到整体的日志，以及单独的测试用例日志。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="pj pk di pl bf pm"><div class="gh gi pq"><img src="../Images/e1bbd58082b1c37f0bff20165871a991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U1qAYXhrqGhlUxpibhB9Kg.png"/></div></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="pj pk di pl bf pm"><div class="gh gi pq"><img src="../Images/c73a300f9bb3d4dfa62fc1735fec5ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MS-pIkD4s-EXspYZtz3m6w.png"/></div></div></figure><p id="0934" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">万岁！我们坚持到了这篇文章的结尾。伙计们，这就是我们如何使用测试和持续集成(CI)来验证我们是否总是在正确的轨道上。</p></div><div class="ab cl pr ps hu pt" role="separator"><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw"/></div><div class="ij ik il im in"><p id="7bb7" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">我希望这篇文章能为您提供一个方便的方法来保证您的项目的未来性！感谢您的阅读！</p></div></div>    
</body>
</html>