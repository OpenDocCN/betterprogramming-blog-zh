<html>
<head>
<title>Themes, Elements, and Structure in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中的主题、元素和结构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/themes-elements-structure-in-swiftui-ac83652b5856?source=collection_archive---------4-----------------------#2022-01-19">https://betterprogramming.pub/themes-elements-structure-in-swiftui-ac83652b5856?source=collection_archive---------4-----------------------#2022-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2187" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建可重用元素和自定义视图修改器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/573ace1e6847d7a59c9048cbd31728d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ixpE1RGcGGdfUHpmp0CZqA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kelly sik kema-Unsplash提供的照片</p></figure><p id="24b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我开始编写一个应用程序时，我通常从主视图和关键组件开始。在我进行的过程中，我将向元素中添加一些修饰符，以给出应用程序的感觉(以及进度感)。</p><p id="1d9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">问题来了，不久之后，我为一个简单的视图生成了一个长达数百行的SwiftUI文件，因为我为每个元素单独声明了修饰符。一个文本标签最多可以有七个修饰词来使它看起来更漂亮。接下来，我想精简我的UI外观，调整间距、颜色和大小。这包括检查每一个修饰符并改变静态值。一定有更简单的方法…</p><h1 id="c29f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">集中主题和视图修改器</h1><p id="13bb" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Xcode有一个很好的管理颜色资源的系统，但是它不是最直观的，而且只能在Xcode上访问。</p><p id="699b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在iPad上使用Playgrounds 4，你需要手动管理颜色。让我们再详细阐述一下。主题不仅仅是颜色。是的，这是一个不错的定制入口，但实际上一个主题还应该包含尺寸、字体、阴影、圆角半径、字距等等。</p><p id="219a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当你在设备上从亮模式切换到暗模式时，你会看到设计中的微妙之处，让应用程序在视觉上更令人愉悦，这正是主题所需要的。当使用较深的颜色时，文本的字距调整在视觉上更令人愉快。所以让我们来看看如何适应这一点。</p><p id="c33d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，想想你想在你的应用程序中声明什么。从颜色开始，因为这是我们可能想要提供差异的第一件事。</p><p id="e214" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于以下内容，创建一个<code class="fe mr ms mt mu b">Theme.swift</code>文件来放置以下代码。</p><p id="8767" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先为我们的主题声明一个类，首先声明所有的颜色:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7bb6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了帮助解决这个问题，我使用了一个扩展来允许我输入十六进制值。这真的不是必需的，但是我发现它有助于在使用多种颜色时保持代码整洁。稍后您将看到如何使用它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="907e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理想情况下，这将是广泛的，但在大多数情况下，你的应用程序不会有超过7或8种颜色需要定义。</p><p id="f019" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，考虑你的应用程序中可能需要的各种字体。它可能只是4或5种不同的字体(包括你想要引用的大小:标题、页眉、正文、按钮文本、警告)。</p><p id="b460" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以简单地在我们的主题类中定义每一个，但是我们可能希望从一个地方更新所有主题的字体或大小。为此，我们创建一个枚举来定义我们的字体。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="1c72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，我们可以将我们的字体添加到主题类中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="19af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了结束本次演示，我们将添加一些有用的属性，如间距值。当我们想要定义填充的值时，这将被引用。我通常坚持8的网格。小的是8，中的是16，大的是24。</p><p id="b68a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">向类中添加一些初始化器，这就产生了成品:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="a5a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们在一个地方有很多设计参数。你会注意到我们创建了一个类，而不是一个结构。这是因为我们希望能够让类符合<code class="fe mr ms mt mu b">@ObservableObject</code>。你很快就会明白为什么。</p><p id="47ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以接下来我们需要一个存储所有不同主题的地方，以及一个获取<code class="fe mr ms mt mu b">selectedTheme</code>的enum。</p><p id="5dab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">仍然在同一个<code class="fe mr ms mt mu b">Theme.swift</code>文件中，创建一个数组来保存主题数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="712f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里没有做什么特别的事情，但是它可以很快地引用参数来更新各种主题。确保您用<code class="fe mr ms mt mu b">themeName</code>注释此处的数据，以便参考。</p><p id="67b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们希望将它添加到一个枚举中，这样我们就可以选择要使用的主题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="86ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每次我们添加一个新的主题到我们的主题数组中，我们必须用主题名更新枚举。这就是我们<code class="fe mr ms mt mu b">Theme.Swift</code>文件中声明的一切。完整的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="83b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么我们如何利用这一点呢？嗯，在我们的<code class="fe mr ms mt mu b">ContentView</code>(或任何其他视图)中，我们有一个变量来存储我们的<code class="fe mr ms mt mu b">currentTheme</code>和一个函数来改变它。就这么简单。同样，每当添加新主题时，<code class="fe mr ms mt mu b">changeTheme</code>也需要添加案例。这只是引用了<code class="fe mr ms mt mu b">themes</code>数组中主题的索引:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3b1a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们用<code class="fe mr ms mt mu b">@State</code>定义了我们的<code class="fe mr ms mt mu b">currentTheme</code>，每当它被改变时，我们视图的其余部分都会被刷新。作为奖励，我们还可以添加<code class="fe mr ms mt mu b">withAnimation</code>，这样它会淡入新的外观，对眼睛来说更容易一些。</p><p id="8b05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际上，用户可以从一个下拉菜单中选择一些预定义的主题，但我是为了上下文才这么做的。</p><p id="684f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了所有这些，我们可以查看我们的预览，并开始从一个Swift文件改进我们的应用程序的外观。如果我们想在全球范围内改变标题字体，我们可以这样做。</p><p id="1213" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里的强大之处在于，您可以为每个页面使用一个标题，因此它可以在多个视图中使用，但是我们仍然可以从一个地方修改它。或者为此在主题中定义一种新的字体。</p><p id="37fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个例子，说明创建一个<code class="fe mr ms mt mu b">View</code>并从一个地方修改一切是多么容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/6f2358144ef6945ff1acabcc57098bae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6U9DJbUx6Bx28Et8RKRLeg@2x.jpeg"/></div></div></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="6d71" class="lu lv it bd lw lx nf lz ma mb ng md me jz nh ka mg kc ni kd mi kf nj kg mk ml bi translated">可重用元素和自定义修饰符</h1><p id="6f9b" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">还有另一种方法可以利用集中化，那就是确定在整个应用程序中重复使用的关键设计元素。</p><p id="85b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了在<code class="fe mr ms mt mu b">ContentView</code>主体中存在多个修改器，您可以为这些视图定制修改器以应用多个修改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0ee4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们要做的第一件事是定义一个<code class="fe mr ms mt mu b">ViewModifier</code>并声明我们想要应用于视图的所有不同的修饰符。这里可能有很多。为了使这个作品符合我们的主题，我们将<code class="fe mr ms mt mu b">currentTheme</code>传递给它作为参考。通过这样做，我们可以引用<code class="fe mr ms mt mu b">currentTheme</code>的字体和颜色，如果<code class="fe mr ms mt mu b">currentTheme</code>改变，这些将会刷新。</p><p id="093f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们简单地通过添加一个函数作为<code class="fe mr ms mt mu b">View</code>的扩展来调用它。要使用它，我们只需在内容视图中放置一个修饰符:<code class="fe mr ms mt mu b">.headerStyle(theme: currentTheme)</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/a48781abcfb9535ccf840425b6ca1c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RI_8L6AlVgjs2dweWk2hng.png"/></div></div></figure><p id="62e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样做的好处是我们可以从一个地方修改多个视图，而且我们的<code class="fe mr ms mt mu b">ContentView</code>更加简洁易读。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="02e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在花时间考虑这个问题，为主题设计一个好的工作系统，将有助于加速UI的改进，从而产生一个完美的产品。您还可以使用它来启用应用程序中的辅助功能，例如更大的字体大小。或者根据设备或屏幕分辨率调用不同的主题。</p><p id="23e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的演示展示了如何使用它，但是很明显，有更多的参数可以集中和定制，例如阴影，圆角半径，甚至条件格式。可能性是无限的。</p></div></div>    
</body>
</html>