<html>
<head>
<title>The Evolution of View Linking in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中视图链接的演变</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-evolution-of-view-linking-in-android-d6219678740d?source=collection_archive---------14-----------------------#2020-07-01">https://betterprogramming.pub/the-evolution-of-view-linking-in-android-d6219678740d?source=collection_archive---------14-----------------------#2020-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="97dc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">findViewById &gt;黄油刀&gt;数据绑定&gt; Kotlin合成&gt;视图绑定</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/decd8374df1d9ca8cafbd0027e0fed71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9RrEWj13h9wAdGkp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼尔·利维斯·佩鲁西在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7840" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Android开发环境从一开始就基于三种类型的文件:XML、Kotlin和Java。XML文件包含与设计相关的一切，而Kotlin/Java文件包含除设计部分之外的任何内容。</p><p id="a605" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，UI和业务逻辑需要链接起来，这就是本文所要讨论的。让我们看看在布局中查找视图是如何演变的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a15c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">' findViewByID '</h1><p id="4d2b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">findViewByID</code>是该系列中的第一个，由Android团队在API Level 1中引入。这个函数提供了一个视图对象作为返回类型，开发人员将这个对象链接到在<code class="fe mz na nb nc b">View</code>类中创建的视图。</p><p id="c28b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Android中的每个视图都是从<code class="fe mz na nb nc b">View</code>类扩展而来的。因此，XML布局中使用的所有视图都以某种方式扩展到了<code class="fe mz na nb nc b">View</code>类。<code class="fe mz na nb nc b">findViewByID</code>返回该类的一个实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“findViewByID”的用法</p></figure><p id="ae6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，Android团队对该功能进行了增强，以克服视图投射。因此，开发人员不再需要在与<code class="fe mz na nb nc b">findViewByID</code>链接时转换视图。</p><p id="1a25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管努力增强<code class="fe mz na nb nc b">findViewByID</code>，许多开发者觉得这不是最好的方法。所以人们开始创造像黄油刀这样的替代品，在某个时候，Android团队提出了数据绑定(尽管它的主要焦点不仅仅是链接视图)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5441" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">黄油刀</h1><p id="7c71" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Android Butter Knife库是一个轻量级的view0injection库，用于注释。这是第一个似乎是传统的<code class="fe mz na nb nc b">findViewByID</code>的成功替代品的图书馆。</p><p id="dd89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是由杰克·沃顿(Jake Wharton)创建的，你可以在其官方<a class="ae ky" href="http://jakewharton.github.io/butterknife/" rel="noopener ugc nofollow" target="_blank">网站</a>上找到如何使用黄油刀的文档。该库使用<code class="fe mz na nb nc b">@BindView</code>注释链接布局中的视图。有一段时间，开发人员将它作为<code class="fe mz na nb nc b">findViewByID</code>的正式替代品。让我们来看看如何使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">黄油刀的用法</p></figure><p id="dda5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和<code class="fe mz na nb nc b">findViewByID</code>差不多；对于开发人员来说，删除样板代码的唯一好处是我们不需要单独实现视图的声明和初始化。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1d1a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据绑定</h1><p id="fdac" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://developer.android.com/topic/libraries/data-binding" rel="noopener ugc nofollow" target="_blank">数据绑定库</a>是一个支持库，允许您使用声明性格式将布局中的UI组件绑定到应用程序中的数据源，而不是以编程方式。</p><p id="30ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据绑定库为布局生成绑定类，我们可以在像<code class="fe mz na nb nc b">Activity</code>和<code class="fe mz na nb nc b">Fragment</code>这样的Android组件中使用它们。数据绑定是一种具有类型和空安全的声明性解决方案。</p><p id="3810" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使布局支持数据绑定，我们必须用<code class="fe mz na nb nc b">layout</code>标签包装文件的内容。这将生成该布局的绑定文件，并引用其中的所有视图。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将根内容包装在“layout”标记中</p></figure><p id="66e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们完成了XML中的这一部分，就会生成一个绑定类，我们需要在<code class="fe mz na nb nc b">View</code>类中使用它。这个绑定文件实例包含布局中的所有视图。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“View”类中的数据绑定</p></figure><p id="0cc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这似乎是一个合理的解决方案，但是创建数据绑定是为了解决比链接视图更复杂的问题，比如访问<code class="fe mz na nb nc b">Data</code>类的布局文件从XML本身发布数据，以及使用绑定适配器加载远程图像。</p><p id="5ff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些事情使得数据绑定成为解决视图链接问题的复杂库。本质上，数据绑定是为了解决复杂的问题而创建的，因为它会增加编译时间，而且错误也很难理解。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6057" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">科特林合成纤维</h1><p id="7436" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当Kotlin被引入Android开发时，它解决了许多问题，包括视图链接。Kotlin Extensions是Kotlin团队开发的一个插件。它消除了在代码中使用<code class="fe mz na nb nc b">findViewById</code>的需要。</p><p id="7d95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Kotlin扩展的帮助下，合成代码在Android中应运而生，不使用<code class="fe mz na nb nc b">findViewByID</code>就解决了Android中的视图链接问题。与这里的其他库不同，我们可以在类文件中直接使用视图的ID。</p><p id="a4a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kotlin synthetics第一次调用<code class="fe mz na nb nc b">findViewById</code>函数，然后在默认情况下将视图实例缓存在<code class="fe mz na nb nc b">HashMap</code>中。该缓存配置可通过梯度设置更改为<code class="fe mz na nb nc b">SparseArray</code>或无缓存。</p><p id="8958" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kotlin synthetics是最好的方法之一——它是类型安全的，我们可以直接从布局中使用id。通过使用Kotlin的<code class="fe mz na nb nc b">?</code>操作符，我们可以使这个过程不安全。</p><p id="ef68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了好处之外，我们还有一个问题——如果我们使用视图的ID，Android Studio会显示自动完成，即使膨胀的布局与您试图访问的视图不同。在这种情况下，如果您不使用<code class="fe mz na nb nc b">?</code>操作符，您的应用程序将会崩溃。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9ef7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">视图绑定</h1><p id="8b13" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后<code class="fe mz na nb nc b">ViewBinding</code>，是一个链接视图到类文件的官方解决方案。<code class="fe mz na nb nc b">ViewBinding</code>背后的想法是为每个布局创建一个绑定类，保存布局中视图的引用。这减少了组件中的样板代码(<code class="fe mz na nb nc b">Activity</code>和<code class="fe mz na nb nc b">Fragment</code>)，我们可以通过创建该类的实例来访问视图。</p><p id="1ee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了视图绑定，就像在数据绑定中一样，在对视图执行操作时，不再需要对视图进行空检查。作为直接从布局文件生成的绑定类，它只包含布局内的视图。</p><p id="e10d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型安全是视图绑定最显著的优点之一。如果你试图给一个按钮分配一个文本监视器，它不会接受，因为<code class="fe mz na nb nc b">Binding</code>类包含了适当视图类型的引用。</p><p id="a018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图绑定的唯一目的是取代<code class="fe mz na nb nc b">findviewbyId</code>的使用。与数据绑定不同，它是轻量级的，所以编译不会花太多时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查看绑定用法示例代码</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c43e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">奖金</h1><p id="44df" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要了解有关Android高级开发的更多信息，请阅读以下文章:</p><ul class=""><li id="b339" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><a class="ae ky" href="https://medium.com/better-programming/how-to-integrate-google-pay-into-your-existing-android-app-d75b269cd623" rel="noopener">“如何将Google Pay集成到您现有的Android应用中”</a></li><li id="1931" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><a class="ae ky" href="https://medium.com/@sgkantamani/android-product-flavors-eb526e35f9f1" rel="noopener">《安卓产品口味》</a></li><li id="2700" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><a class="ae ky" href="https://medium.com/@sgkantamani/how-to-create-and-publish-an-android-library-f37bf715932" rel="noopener">“如何创建和发布Android库”</a></li><li id="cce7" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><a class="ae ky" href="https://medium.com/better-programming/evolution-of-adapters-in-android-2e2ff58c0f98" rel="noopener">“Android中适配器的演变”</a></li></ul><p id="8beb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前就这些——希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>