<html>
<head>
<title>Evolving a Database Schema</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">发展数据库模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/evolving-a-database-schema-10b7f4094d14?source=collection_archive---------3-----------------------#2019-07-28">https://betterprogramming.pub/evolving-a-database-schema-10b7f4094d14?source=collection_archive---------3-----------------------#2019-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b2de" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">CI/CD管道中的大象</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/67447f0ab5c0f8166de3f36e213cfe8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MHPQ4KX31LH8cWGK"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">詹姆斯·哈蒙德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="20b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在过去写过关于<a class="ae ky" href="https://medium.com/better-programming/straight-to-prod-ca12205841fc" rel="noopener"> <em class="lv">基于主干的开发</em> </a>。我也读过其他人写的关于它的文章。众所周知，说到鼻子，房间里的大象就是数据库。代码更改通常与模式更改密切相关，考虑如何在CI/CD环境中管理这一点是完全合理的。我们为自己设定的目标是让每一次推送都为生产做好准备。关系数据库是如何工作的？</p><p id="aa91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不是DBA，也不是任何意义上的数据库专家。然而，我很幸运地在一个不相信加班的工程系呆了很多年。即使是部署也不行。非工作时间部署的替代方案是在工作时间部署<strong class="lb iu">。当软件正在使用时。这听起来可能有风险，但我们认为，当我们所有人都在甲板上，每个人都相对新鲜时，部署风险较小。否则，如果灾难降临，我们一开始都会睡着，然后变得烦躁、疲惫、不耐烦，喝着咖啡跑来跑去。</strong></p><p id="8b58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，诀窍就在于如何在“为了维护和升级”而不关闭软件的情况下进行部署最终，这只是另一个需要克服的工程挑战。我们最初的解决方案在许多方面类似于<a class="ae ky" href="https://martinfowler.com/bliki/BlueGreenDeployment.html" rel="noopener ugc nofollow" target="_blank">蓝/绿部署</a>。然而，正如马丁·福勒在链接文章中指出的，“数据库是棘手的。”嗯……我们学了一些技巧。我是说“我们”我在这里展示的是最好的集体智慧，三重蒸馏和木桶陈酿。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="77ea" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">假设</h1><p id="5cbf" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我在这篇文章中做了一些假设。即使它们不适用于你的情况，许多内容可能仍然是相关的。我很明确地说明了这些假设，这样你就可以做出明智的决定。</p><p id="5201" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最大的假设是，您有多个可独立部署的服务(微服务或其他服务),并且具有独立的模式。它们是否在同一个物理服务器上并不重要，但是<code class="fe na nb nc nd b">Service A</code>不能读取<code class="fe na nb nc nd b">Service B</code>的表，反之亦然。我还假设您的服务没有在数据层集成。它们通过RPC和/或消息代理相互对话。但不是数据库。从来没有数据库。</p><p id="bbce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还假设你没有大量使用“事件源”如果是，您的事件可能存储在事件存储或关系数据库中。演化一个持久化的可回放事件序列超出了本文的范围。</p><p id="e63c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个隐含的假设是，您不会因为每秒事务数(TPS)而感到紧张。也许这对你来说是一个重要的指标，也许不是。但是我认为维护当前的TPS是在部署期间保持系统正常运行的次要问题。如果对你来说不是这样，也许这篇文章仍然有用，但是你可能需要调整建议的解决方案。</p><p id="ce3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个假设是，您正在与CI/CD管道一起工作，或者朝着CI/CD管道工作。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e0e3" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">先决条件</h1><p id="3513" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">你首先需要三件小事:</p><h2 id="165c" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">1.模式迁移工具</h2><p id="be06" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">您将需要一个工具或库，允许您定义数据库迁移，并智能地执行那些在启动时没有运行的迁移。<a class="ae ky" href="https://www.liquibase.org/" rel="noopener ugc nofollow" target="_blank"> Liquibase </a>和<a class="ae ky" href="https://flywaydb.org/" rel="noopener ugc nofollow" target="_blank"> Flyway </a>是JVM世界中的主要竞争者，它们中的任何一个都会让你满意。</p><h2 id="9dbc" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">2.碎玻璃程序</h2><p id="2492" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有人会犯错误。可能是你。这是时<em class="lv">的情况，不是<em class="lv">时</em>的情况。不管你读了多少遍这篇文章，不管你买了多少本《重构数据库》放在你的桌子旁边，没有读，错误还是会发生。</em></p><p id="30ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当错误出现在迁移中，并且迁移出现在生产中时，如果没有手动干预，就不可能恢复。确保你有办法进去解决问题。</p><h2 id="6eda" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">3.经过<strong class="ak">测试的备份和恢复策略</strong></h2><p id="75d8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">见上文“2”。但你已经有了，对吧？当然，有经过充分测试的恢复和业务连续性计划。没有一个已经有代码的产品是不可想象的。比如开车不系安全带。在道路的错误一边。晚上。没有车头灯。所以我们甚至不需要提到它，我们可以继续有趣的部分。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5f09" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">没有回头路了</h1><p id="e55f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">回滚！我们需要这个，对吗？补偿交易。撤消迁移。啊啊。你很好。如果你知道，我会把它列在“先决条件”下但我没有。所以你没有。</p><p id="953d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请原谅我的轻率。我这样做是为了喜剧效果，但说真的，回滚并不能作为一个通用的“出狱”卡。有些迁徙是破坏性的。添加一列或一个表也可以。你可以倒回去。但是一个<code class="fe na nb nc nd b">drop</code>或<code class="fe na nb nc nd b">delete</code>——好吧……你不能从那个位置上后退。最好减少损失，恢复数据库。是啊，问题就在这里。任何构建某种系统来从破坏性迁移中回滚的尝试实际上都是重新发明备份和恢复。你已经可以这么做了，因为在先决条件中<strong class="lb iu">是</strong>。</p><p id="369a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比数据库回滚更有用的是确保您执行代码回滚(或通过<code class="fe na nb nc nd b">git revert</code>执行前滚并重新部署)而不用担心数据库回滚的方法。实现这一点意味着您还可以在构建时进行测试和验证，并且可以针对更新的模式部署未修改的代码。这是一个好地方，因为这意味着即使模式迁移失败，部署的代码仍然可以工作。</p><p id="bbb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多方法可以做到这一点。他们主要归结为:</p><ol class=""><li id="4a4a" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">将数据库迁移到“最新”版本。</li><li id="b848" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">运行“以前的”版本。</li></ol><p id="ce33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我以前的工作场所，我们创建的每个需要关系数据库的服务都包括一个构建管道步骤，它将:</p><ol class=""><li id="7199" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">运行一个空数据库</li><li id="604d" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">针对空数据库执行当前迁移</li><li id="ced6" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">签出在生产中部署的当前版本</li><li id="3029" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">针对演进的数据库运行来自生产版本的全套集成测试。</li></ol><p id="335c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，旧代码与新数据库相抵触。在这种情况下，旧的代码是我们的集成测试，这足以让我们相信没有模式变化会破坏候选版本和我们当前使用的版本之间的向后兼容性。嗯，差不多了。参见本文最后的“战斗伤痕”部分。</p><p id="8679" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">投入精力构建这样一个测试套件还有一个很好的理由:金丝雀部署或蓝/绿部署。这些技术要求新旧代码并行运行。更好的办法是知道你的新代码不会在构建时而不是在部署时从你的旧代码下面取出模式。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7065" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">基本行动手册</h1><h2 id="ec66" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">添加表格</h2><p id="e1c2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">演进架构的基本原则是增加是安全的。最简单和最安全的添加是一个全新的表。它是如此的简单和安全，几乎没有“陷阱”，以至于我很难想出还能说些什么。继续吧。添加该表。不会痛的。</p><p id="29bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转念一想，别开枪。等一下。睡一觉。在将模式移植到生产环境中一段时间后，你会发现<a class="ae ky" href="https://tvtropes.org/pmwiki/pmwiki.php/Main/RuggedScar" rel="noopener ugc nofollow" target="_blank">身上有一些伤疤</a>。幸存者的诀窍是，在添加桌子时，要等到最后负责任的时刻。首先尽可能多地编写代码。参见我在<a class="ae ky" href="https://medium.com/better-programming/straight-to-prod-ca12205841fc" rel="noopener">早期文章</a>中的“自上而下”或“中间向外”剧本。</p><p id="938f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你第一次计划这个故事时，你认为你需要的和你最终需要的很少是一样的。给你自己一个机会来清除那些隐藏的假设。给自己一个机会来决定该表应该被称为<code class="fe na nb nc nd b">UserPreferences</code>还是<code class="fe na nb nc nd b">UserPrefs.</code></p><h2 id="7fb8" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">添加列</h2><p id="05f2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">添加一个未使用的列也是安全的，尽管安全程度取决于要添加的表是否为空。如果是空的，你可以随心所欲。如果没有，我们就不得不谈可空性和默认值。</p><p id="70b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我关于基于主干的开发的文章中，我给出了向<code class="fe na nb nc nd b">UserPreferences</code>表<code class="fe na nb nc nd b">favouriteSaladGreen</code>添加新列的例子。我们的整个业务模型是建立在获取和存储沙拉信息的基础上的——这个字段是必填的。它必须是非空的。</p><p id="2d05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们的用户表中已经有用户了。将不可为空的字段添加到已填充的表中将会失败。我们有几个选择:</p><ol class=""><li id="7f1c" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">将列添加为可空，使用另一种技术(如代码迁移，稍后介绍)来填充数据，并在未来的版本中更改可空性约束。</li><li id="7dfe" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">在列上设置默认值。</li></ol><p id="e9b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于新手数据库迁移者来说，这是一个阴险的<em class="lv">陷阱</em>,因为即使您有集成测试，它们也很可能是针对一个最初为空的数据库运行的。如果你幸运的话，这个问题会在集成或阶段环境中被发现。还好通常比什么都尴尬。迁移工具应该以这样一种方式展开，告诉您到底发生了什么，然后回滚迁移事务，让一切保持原样。一个快速，有罪的修补程序后，你又上路了。</p><h2 id="ab18" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">删除列和表</h2><p id="72a7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">移除一个<strong class="lb iu">未使用的</strong>列或表是一种安全而简单的迁移。当添加到模式中时，我们首先更改模式，然后添加代码。移除是同样的事情，但是反过来。首先删除代码，然后删除表或列。那么，关键是你如何确定它没有被使用？</p><p id="3820" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以从现有的测试中获得一定程度的信心。像删除整个表这样极端的事情如果还在代码中被引用，肯定会导致爆炸。在这种假设下，您可以通过运行您的集成测试套件，了解到您的表或列在master中未被使用。</p><p id="a444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是生产中的代码呢？删除的危险区域是意外地从一些代码下面拉出一列，这些代码在主服务器上被删除，但仍在生产中运行，作为分阶段推广或蓝/绿部署的一部分。</p><p id="124d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前面关于回滚的部分中，我讨论了向后兼容性测试套件的创建。那个测试套件应该是你的护栏。无论如何，这都是不可靠的，但是应该给你合理的信心，你提议的删除是安全的。</p><h2 id="3256" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">重命名列和表</h2><p id="6e90" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Liquibase和Flyway都支持作为原子操作的重命名。毫无疑问，所有像样的数据库迁移框架也会如此。不幸的是，您不能在蓝/绿部署场景中使用它。在保持与现有代码向后兼容的同时执行重命名通常是一个三步过程。</p><p id="762e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简洁起见，我将参考一个专栏来描述下面的步骤。同样的技术也适用于整个表。</p><ol class=""><li id="bbd6" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">添加一个内容重复的新列作为旧列[部署]</li><li id="d1c3" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">更改代码以使用新列[Deploy]</li><li id="339b" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">删除旧列[部署]</li></ol><p id="b815" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复杂的因素是您希望新列包含与旧列相同的数据。有几种方法可以做到这一点。例如，使用直接SQL填充新列。或者，您可以使用迁移工具重命名操作来重命名表和列，但是创建一个视图来模拟旧代码所期望的结构。精心设计的视图可以是可更新的和可插入的，因此这可能是一种选择。如果更改很小并且包含在内，您可以将上面的步骤1和2压缩到一个部署中。</p><p id="8de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快速的发布周期显然是最重要的。连续部署或按需部署都很好。每周都可以。但是每两个星期你就要花大约六个星期来重命名一个列。这种变化背后的代码可能只需要几个小时就可以完成。另一方面，如果您的部署周期超过两周，您可能不担心零停机部署和连续交付。您可以在一个“简单”的部署中执行重构和代码更改。</p><p id="2d2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">凡事总有取舍。引入连续交付将像这样的重构变成了一个多步骤的过程。但是我认为这个特殊的重构也说明了一些不便可以通过更快的速度来减轻。速度产生速度。</p><h2 id="801f" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">改变列</h2><p id="5ca0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">更改列中的数据类型可能很简单。你总是可以变得不那么拘束。可以把<code class="fe na nb nc nd b">VARCHAR(255)</code>改成<code class="fe na nb nc nd b">TEXT</code>。可以把<code class="fe na nb nc nd b">INT</code>改成<code class="fe na nb nc nd b">BIGINT</code>。</p><p id="221b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想反过来——变得更严格——我们需要担心已经在列中的数据。如果您可以在生产数据的精确副本上运行试生产，这是一个好主意。如果您没有副本(这可能是出于合理的原因，如客户隐私或关注点分离)，请考虑将更改作为代码迁移来进行。</p><ol class=""><li id="9c76" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">添加具有变更类型的新列。</li><li id="8df7" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">执行代码迁移(参见下面的专门章节)。</li><li id="3660" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">删除旧列。</li><li id="3f82" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">或者，重命名该列(请参见上面的专用部分)。</li></ol><p id="1b6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，有很多步骤。不过，关键是，这是可能的！这是一个不错的小紧张，真的，当事情足够困难，强烈鼓励少量的前期设计和规划。至少要考虑清楚。但是不会太难以至于需要一个大的前期设计。</p><h2 id="2cd0" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">合并或拆分列</h2><p id="c706" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这里的典型例子是，我们将姓名存储为单独的名和姓列。现在我们只想将它合并到一个<em class="lv">名称</em>列中，因为<a class="ae ky" href="https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/" rel="noopener ugc nofollow" target="_blank">名称很难</a>，这似乎是最简单的答案。在另一个时间，另一个地方，我们可能会反其道而行之，拆分列，也许会将“地址”从自由格式的文本转换成更有结构的文本。</p><p id="c1c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，这是相当安全的；我们可以增加一个新的<code class="fe na nb nc nd b">name</code>栏目。理想情况下，它不会为空。我们将需要一些代码来写入新字段，但这是一个小的迁移，所以我们可以将代码和数据库更改捆绑在一起。那么我们所需要的就是一个SQL迁移，它创建一个可空的列，通过连接“名字”+“姓氏”来填充它，然后将其更新为不可空。</p><p id="6e0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了……这个变化可能——但愿如此！—导致我们的数据库向后兼容性测试失败。那些针对新模式运行旧代码的。因为我们的旧代码(将在蓝/绿部署场景中共存于生产中)不会写入新的不可空的<code class="fe na nb nc nd b">name</code>列。</p><p id="3d94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，新计划！</p><ol class=""><li id="b581" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">先添加新的<code class="fe na nb nc nd b">name</code>列，可空。</li><li id="837c" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">添加代码以写入新列以及旧的first name和last name列。</li><li id="04ee" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">如果填充了新的<code class="fe na nb nc nd b">name</code>列，添加从中读取的代码，否则如果为空，则使用旧的first+last name逻辑。</li><li id="79e1" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">使用代码迁移来消除所有的空值。(将在下一节介绍可能的选项。)</li><li id="0e28" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">清理；将新的<code class="fe na nb nc nd b">name</code>列标记为可空，并删除旧的列。</li></ol></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c24c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">代码迁移</h1><p id="1702" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在整篇文章中，我留下了空白点，将艰难的对话推迟到以后。但是我们已经在这条路上走得够远了。最后，我们来到了一个黑暗的角落，在这里我们再也不能推迟讨论代码移植了。</p><p id="2a08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们这些关系数据库的追随者总是会发现，在我们连续交付旅程中的某个时刻，我们处于与上一节类似的情况，SQL无法在一个简单的部署中填充我们修改过的数据结构。这可能有很多原因。这可能是在蓝/绿部署中需要同时运行新旧代码的结果。这可能是由于迁移的复杂性。可能这个问题仅仅依靠SQL是无法解决的。仅仅通过SQL来解决这个问题可能会将一个表锁定一段不可接受的时间。</p><p id="ab7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，留给我们的唯一可行的选择是代码迁移。</p><p id="9ff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与其说是剧本，不如说是一个一般性的概念。我这里指的是编写代码将数据从一种格式转换成另一种格式。尽管这个主题很宽泛，而且实际上不可能找到一个简单的示例，但是有几种常见的技术可能是有用的。</p><h2 id="d902" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">兼容层</h2><p id="5f07" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">简而言之:如果填充了新结构，就从新结构读取，否则就退回到旧结构。</p><p id="2cb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<em class="lv">合并列</em>示例中，我们提到了这一点。如果不为空，我们可以从一个<code class="fe na nb nc nd b">name</code>列中读取。否则，我们会退回到单独检查<code class="fe na nb nc nd b">firstName</code>和<code class="fe na nb nc nd b">lastName</code>，并可能用空格将它们连接起来。</p><p id="bcaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它会变得更加复杂。在最近的一个案例中，我们意识到我们已经将一些信息持久化到一个可能经常改变的表中，但是我们正在动态地查找那些不经常改变的信息。一定是反过来了。在这种情况下，如果新添加的列为空，兼容性层会进行一些额外的API调用，但这归结为相同的概念。有就用；如果没有，请提供解决方法。</p><h2 id="8e24" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">从兼容层读取；写入新结构</h2><p id="d974" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">一种用于执行代码迁移的技术是使上述兼容层是只读的。写入将填充新结构。在我们的例子中，如果<code class="fe na nb nc nd b">name</code>丢失，我们从<code class="fe na nb nc nd b">firstName</code>和<code class="fe na nb nc nd b">lastName</code>中读取，但是当用户更新他们的名字(或者任何潜在的信息)时，我们写回<code class="fe na nb nc nd b">name</code>字段。</p><p id="524b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单。请注意，在蓝/绿部署场景中，根据处理更新请求的版本，您可能仍然会填充旧的数据结构。只有当所有旧代码都被替换后，新数据才会停止进入旧结构。</p><p id="7402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复杂的是，在旧代码消失后的某个时刻，我们想要删除旧的数据结构。将可为空的列标记为不可为空，以及任何其他所需的清理。在所有数据迁移完毕之前，我们无法做到这一点。</p><p id="74a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这给我们留下了一些问题:</p><ul class=""><li id="b3a8" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu oe nw nx ny bi translated">我们怎么知道什么时候完成了？</li><li id="bb76" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu oe nw nx ny bi translated">有没有办法强制它更快完成？</li></ul><p id="09a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些问题的答案将是高度个体化和上下文敏感的，但它们不太可能特别难回答。在某些情况下，我们使用像<a class="ae ky" href="https://metabase.com/" rel="noopener ugc nofollow" target="_blank">元数据库</a>这样的工具，指向生产数据库的只读副本，为开发人员提供代码迁移进度的仪表板。在其他情况下，我们不得不使用SQL语句来提交JIRA票证，以便由能够访问生产数据库的运营团队来执行。有志者事竟成。</p><h2 id="f9a2" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">读取时写入</h2><p id="0869" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">作为上述的变体，当请求读取时，可以更新数据结构。</p><p id="0e08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的名称示例中，如果<code class="fe na nb nc nd b">name</code>列为空，代码将从<code class="fe na nb nc nd b">firstName</code>和<code class="fe na nb nc nd b">lastName</code>读取，然后，可能在同一个事务中，立即写回<code class="fe na nb nc nd b">name</code>列。与<em class="lv">写时写</em>相比，有一些优点和缺点。</p><p id="64a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优势:</p><ul class=""><li id="3827" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu oe nw nx ny bi translated">如果数据的访问频率高于更新频率，可能会更快地完成迁移</li></ul><p id="ebcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缺点:</p><ul class=""><li id="72c1" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu oe nw nx ny bi translated">可能会产生不可接受的性能影响</li><li id="8d7a" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu oe nw nx ny bi translated">如果写事务失败，可能会导致直接读取失败，这可不是什么好事。除非您使用读取来触发异步更新，在这种情况下:</li><li id="0e80" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu oe nw nx ny bi translated">异步更新可能会失败，在这种情况下，您可能需要担心全新级别的错误处理。</li></ul><p id="5228" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管怎样，这只是个想法。</p><h2 id="327b" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">重放或合成事件</h2><p id="8297" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在某些情况下，传入事件将触发数据更新。通常，这可能是来自webhook的回调，或者是由RabbitMQ和SQS之类的消息代理提供的，或者是像Kafka之类的更奇特的东西。事件可以是<em class="lv">胖</em>，携带更新所需的所有信息，也可以是<em class="lv">瘦</em>——仅仅是一个标识符和一个动作，就像“用户X更新了”当事件是信息的主要来源时，这通常被称为“事件流”或“事件驱动”架构。这是完全不同的，不要与<em class="lv">事件源</em>混淆。</p><p id="6899" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事件驱动架构的一个优点是，您很可能生成或回复事件来触发数据<code class="fe na nb nc nd b">write</code>。作为一个人工示例，让我们假设我们一直使用的<code class="fe na nb nc nd b">firstName</code> / <code class="fe na nb nc nd b">lastName</code>迁移不是发生在用户数据的主存储中，“真实的来源”，而是发生在其他一些维护本地副本以提高性能的下游微服务中。当我们收到一个<code class="fe na nb nc nd b">user.updated</code>事件时，我们更新该用户的本地副本。</p><p id="7108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是一个现实的例子，因为在任何地方部署了代码更改之后，简单的SQL迁移可能就足够了。但是出于讨论的原因，在这个场景中，我们已经有了当收到一个<code class="fe na nb nc nd b">user.updated</code>事件时将写入新的<code class="fe na nb nc nd b">name</code>字段的<strong class="lb iu">代码。为每个用户生成一个事件并将他们注入系统是实现完全迁移的一种方式，而无需等待用户更改他们的姓名。(这种情况可能不会经常发生)。</strong></p><p id="fa91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以前的团队中，我们遵循稍微复杂一点的流程来快速完成数据迁移。在一个案例中，我们为操作团队提供了一个shell脚本，该脚本可以读取现有的表，生成合成事件，并将它们弹出到消息队列中。在另一个例子中，我们为上游服务添加了一个开发人员后门，当这个后门被打开时(在我们的例子中是被一个<a class="ae ky" href="https://docs.oracle.com/javase/tutorial/jmx/overview/index.html" rel="noopener ugc nofollow" target="_blank"> JMX </a>控件打开),它将读取自己的数据存储并发出一个事件“风暴”。</p><p id="75c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的可行性将取决于您是否已经有了消息处理程序，并且必须在这些处理程序中编写兼容性代码。这还假设消息处理机制将对突发消息具有弹性，并且这仍然比在删除了所有写入旧数据结构的代码后在SQL中执行迁移更省力。</p><p id="7d1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">避免需要独立运行的“部署步骤”几乎总是更可取的。除了上述脚本之外，可能还有其他方式来触发事件生成。但就像生活中的所有事情一样，这归结为一种权衡。有时，最实用、最方便的方法就是在部署后运行脚本。那么最重要的事情就是确保你有一个脚本可以并且应该在一个特定的部署完成后运行，但是<strong class="lb iu">没有</strong>必须运行。这样，代码可以首先安全地进入生产环境，脚本或其他部署步骤只是加速迁移的一种方式。</p><h2 id="6e07" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">批处理作业</h2><p id="29d0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">没有事件？那我邀请你考虑一下卑微的批处理工作。这种事情<a class="ae ky" href="https://docs.spring.io/spring-batch/4.1.x/reference/html/spring-batch-intro.html#spring-batch-intro" rel="noopener ugc nofollow" target="_blank">春批</a>就是被创造出来管理的。老方法是最好的。<a class="ae ky" href="https://mcfunley.com/choose-boring-technology" rel="noopener ugc nofollow" target="_blank">镗孔技术</a>等等。</p><p id="ff83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">批处理就是读取数据，处理数据，然后写回数据。大块的。简单，本质上。当您考虑每个事务中要处理多少项，如果其中一项失败会发生什么，以及如何将独立的步骤链接到一个更大的工作流中时，就会出现复杂的因素。</p><p id="c739" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">批处理框架可以为您处理大部分复杂性。你打算引入一个批处理框架来合并<code class="fe na nb nc nd b">firstName</code>和<code class="fe na nb nc nd b">lastName</code>吗？大概不会。但是也许您已经有了一个批处理框架。也许你不介意“推出自己的”产品，并介绍一些能满足你需求的超薄产品。也许您需要迁移的数据量可能证明引入第三方框架的弹性和错误处理是正确的。</p><h2 id="9219" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">和解</h2><p id="6673" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有些迁移比其他迁移更重要。这是简单、纯粹的事实。通常，这归结为钱。不总是这样，但如果你只能选择一个，客户银行账户中的金额比他们的名字更值得仔细审查。</p><p id="bdd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，有些迁移非常复杂。在一次冒险中，我们将数据从平面结构迁移到一个规范化的模型中。一些相对复杂的业务逻辑控制着实体之间的关系，需要将代码从从列值派生实体关系改为从外键关系派生实体关系。</p><p id="ef45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，让新旧结构在更长时间内并行运行可能是有意义的。您可以对这两种结构同时执行一段时间的代码，并比较结果。像科学家这样的图书馆可以在这方面提供帮助。</p><p id="db1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在数据访问时同时运行两条路径会造成不可接受的速度下降，另一种方法是在非高峰时段安排一个协调作业，并检查(彻底检查或抽样检查)针对新旧数据结构运行的代码的结果是否匹配。</p><p id="2915" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这是一种暂时的状态。一旦新的数据结构得到验证，就可以删除协调代码，废弃旧的数据结构，从那时起，代码就可以自由地分化和发展。</p><h2 id="579a" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">处理旧的、不完整的迁移</h2><p id="3785" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有时迁移永远不会结束。在这些情况下，有时最好寻找非技术性或带外解决方案来解决问题。</p><p id="5b5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想起了我们不得不为一个内部工具迁移一些用户数据的时候，这个工具只能由登录事件触发。我们有一个跟踪已转化的现有用户百分比的仪表板。我们让迁移在登录时运行几个星期。然后我们联系了没有登录的用户，要求他们在下周登录。这转换了更多的散兵游勇，但仍然留下一些数据未迁移。</p><p id="cb22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这些用户是员工，并且已经有近一个月没有登录，我们删除了他们的帐户。这些帐户提供了对系统的访问，但它们本身并不存储任何状态。如果他们确实需要登录，我们可以很容易地创建新帐户，但是删除它们可以让我们完成迁移，整理旧代码，并继续改进工具。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="35e8" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">战斗伤痕</h1><p id="401c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在德国他们有一句谚语，<em class="lv"> </em>“德国佬是一个德国佬，”<a class="ae ky" href="https://blogs.transparent.com/german/devilish-german-sayings/" rel="noopener ugc nofollow" target="_blank">魔鬼是一只松鼠</a>显然，他们想到了<a class="ae ky" href="http://squirrel-sql.sourceforge.net/" rel="noopener ugc nofollow" target="_blank">松鼠</a>，表明他们有所发现。数据库太可怕了。松鼠得了狂犬病，它冲着你来了——张牙舞爪。再多的阅读也不能阻止你至少被咬一次。你所能期望的最好结果是，从错误中恢复过来不会太昂贵，而且你能从中吸取教训。</p><p id="95eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我想以分享几个我们被一只吐着泡沫的魔鬼松鼠咬伤的故事来结束我的演讲。在这两种情况下，问题都源于自满。我们已经熟练掌握了添加、删除和合并列的基础知识。我们变得粗心了。</p><h2 id="c909" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">确认</h2><p id="c641" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们有一个<a class="ae ky" href="https://deviq.com/value-object/" rel="noopener ugc nofollow" target="_blank">值对象</a>。这是一个重要的，作为实体标识的一部分。它接受一个字符串作为构造函数，但不执行任何验证。我们确实有控制这个特定字符串的格式的业务规则，将这些相同的验证规则添加到值对象中似乎是一个显而易见的举动。我们照做了。</p><p id="aa73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们忘记了检查数据库中是否存在任何违反验证的现有数据。我们的试运行环境中没有，但生产环境中有。结果是从数据库中读取时出现爆炸，这反过来导致一些非常重要的API调用失败。将紧急修补程序排队。吸取的教训；收紧验证是一种数据迁移，本质上类似于更改列。</p><h2 id="c3c9" class="ne me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">排序次序</h2><p id="12a9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们有一个只写的表，用作一种原始<a class="ae ky" href="https://microservices.io/patterns/data/event-sourcing.html" rel="noopener ugc nofollow" target="_blank">事件源</a>的事件存储。该事件本质上是金融事件。我们对此表运行了一个查询来计算货币金额。该查询通过数据库标识符而不是事件时间戳对结果进行排序。到目前为止，这还没有引起任何问题，但它似乎像一个事故等待发生。</p><p id="4ec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决办法似乎很简单。更改查询的排序顺序。好心，坏主意。我们忘记了一个重要的细节——旧代码和新代码会并行运行一段时间。碰巧的是，在这个窗口中运行了一个批处理进程，并用事件淹没了我们的服务。有些是旧代码捡的，有些是新代码捡的。不同的排序顺序导致相同基础数据的不同计算结果。这些不一致导致…不好的事情发生。有财务影响。</p><p id="118a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那天我们的猫用完了它九条命中的一条。我们很幸运。财务影响很小，我们可以通过邮寄支票和手动调整来解决差异。我们很幸运，之前的团队已经建立了手动调整功能。我们很幸运，一些“这不可能发生”的安全措施被触发，提醒我们有事情发生了。</p><p id="e0ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们忘记了这个查询是由数据访问层中的DAO执行的。尽管该DAO上的方法签名没有改变，但在给定相同的底层数据的情况下，不同版本的结果可能会不同。这本质上是一个实现上的变化，应该被如此对待。</p><p id="c19b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一课几乎与前一课相反。在第一课中，我们忘记了代码更改可能是数据迁移。在本课中，我们忘记了一个无关紧要的查询更改可能是代码迁移。</p><p id="a913" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">后来，我们确实想到了一种安全执行迁移的方法。我们应该使用一个特性标志，允许我们升级所有服务器，然后通过切换开关同时改变所有服务器的排序顺序。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="2e6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，我认为以向前和向后兼容的方式迁移关系模式是连续交付中最困难的部分之一。但是有了一些基本的规则，一些自动化的护栏，和许多非常仔细的思考，管理这头大象是完全可能的。松鼠。随便啦。</p></div></div>    
</body>
</html>