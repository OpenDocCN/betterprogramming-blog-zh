<html>
<head>
<title>I Automated My AWS Lambda Artifacts With Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我用Go自动化了我的AWS Lambda工件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/i-automated-my-aws-lambda-artifacts-with-go-847cad8877a4?source=collection_archive---------1-----------------------#2022-12-11">https://betterprogramming.pub/i-automated-my-aws-lambda-artifacts-with-go-847cad8877a4?source=collection_archive---------1-----------------------#2022-12-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c85e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我在AWS Lambda部署中遇到的问题，以及我如何使用基本CLI解决这些问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/14c4cc5c3c083947497cfeac1b85d6ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M_issyoz7HurUbdQ2AscyA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">蕾妮法语，<a class="ae kv" href="https://creativecommons.org/licenses/by/3.0" rel="noopener ugc nofollow" target="_blank"> CC BY 3.0 </a></p></figure><p id="7b93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近对AWS Lambda有些兴趣。它很便宜，很容易与其他服务或API集成，而且启动和运行起来几乎毫不费力。差不多了。正如我之前在另一篇<a class="ae kv" href="https://blog.lorisocchipinti.com/forex-bot-with-lambda-telegram/" rel="noopener ugc nofollow" target="_blank">文章</a>中提到的，AWS控制台中没有Golang功能的web编辑器选项。相反，有必要构建一个二进制文件，创建一个zip存档文件，并将其上传到WebUI(我猜也可以通过CLI上传)。</p><p id="82f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，没问题。起初，我只是像任何体面的家伙一样在终端中输入单独的<code class="fe ls lt lu lv b">go build</code>和<code class="fe ls lt lu lv b">zip</code>命令。不幸的是，随着我开始对我的小函数越来越感兴趣，我开始一直打包许多不同的程序。很快，我希望有一些更有条理的东西，所以我创建了这个脚本:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="f3ca" class="ma mb iq lv b be mc md l me mf">#!/bin/bash<br/>filename=lambda-function-$(date +%Y_%m_%d).zip<br/>GOOS=linux go build main.go<br/>zip $filename main</span></pre><p id="a917" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我满足了一段时间。</p><h1 id="2549" class="mg mb iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">设计Gozip CLI</h1><p id="bfdb" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">当然，上面解释的解决方案对于零星的原型开发来说是相当不错的。然而，为了保持实用性，这个代码片段必须与应用程序入口点位于同一个目录中。我必须做大量的复制/粘贴工作，并在文件系统中来回移动。我逐渐厌倦了这种工作方式:我想要手中有可塑性的粘土，但我只有一个僵硬的代码片段。</p><p id="0bcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上，我意识到我需要一个方便的新CLI实用程序，尽管我知道我不应该走得太远，花整个周末来设计一些过于花哨的东西。首先，我很快收集了对CLI的一些要求:</p><ul class=""><li id="2dda" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">它应该构建一个Go程序，然后将其打包成zip存档</li><li id="a9de" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">应该是用Go写的(对，一直往下走！)</li><li id="ca40" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">它应该允许在文件系统中的任何地方选择目标目录</li><li id="d2e9" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">它应该允许定制一些修订标签来区分不同的可执行版本</li><li id="a6cf" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">它应该具有合理的缺省值，这样就可以在不指定任何参数的情况下执行</li></ul><p id="a8c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据以上几点，我需要两个主要功能:访问命令行参数和与shell交互。幸运的是，Go的标准库已经涵盖了这一点。</p><h1 id="3f00" class="mg mb iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">在工作台上</h1><p id="be9f" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">一般来说，在Go中通过调用<code class="fe ls lt lu lv b">os.Args</code>可以轻松完成处理命令行参数的任务。通过这种方式，可以返回表示命令行参数的字符串标记列表(包括正在执行的程序的名称)并使用它们。然而，每一个像样的CLI可以修补其选项，并改变默认行为。例如，我想用这样的命令从任何目录运行我的实用程序:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="98f9" class="ma mb iq lv b be mc md l me mf">$ gozip --target path/to/main.go --revision v1_3_7</span></pre><p id="b8fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过输入<code class="fe ls lt lu lv b">gozip</code>命令敲击一次应该也是可能的，所以没有选项应该是强制性的。当然，从头开始管理选项和缺省值是可能的，但是Go标准库提供了更实用的东西:<code class="fe ls lt lu lv b">flag</code>包。顾名思义，<code class="fe ls lt lu lv b">flag</code>允许您轻松地配置命令行标志。代码如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6a7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很简单，不是吗？<code class="fe ls lt lu lv b">flag</code>的另一个很酷的特性是它自动为CLI生成有用的文档:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="7a5b" class="ma mb iq lv b be mc md l me mf">$ gozip -h Usage of gozip: -name string name of the executable aws-lambda handler (default "main") -output string The desired path to store the zip archive. If not explicitly set, gozip tries to create a sub-directory at the target location -revision string a version number for the executable. If not explicitly set, gozip uses the current datetime -target string path to the Go program (default ".")</span></pre><p id="9055" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我已经有了捕捉和处理输入的方法，打包Go程序就变成了正确检查选项参数是否是有效的文件路径的问题(这是<code class="fe ls lt lu lv b">os.Stat()</code>的工作)，并与命令行交互以构建&amp; zip程序。如上所述，我不想被拖入重新创建我的zip实用程序的兔子洞——尽管它本身可能是一个有趣的练习——我想继续利用Go的本机功能。我们的朋友<code class="fe ls lt lu lv b">os/exec</code>迅速赶来救援:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="31bf" class="ma mb iq lv b be mc md l me mf">exec.Command("go", "build", "main.go")</span></pre><p id="d99f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，<code class="fe ls lt lu lv b">gozip</code>就充当了一个终端包装器，所以我可以直接向shell提交命令，而不需要从头开始重新构建任何东西。</p><h1 id="5c5b" class="mg mb iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">将这些点连接起来</h1><p id="4fab" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">所有不同的部分都准备好了，所以此时将它们放在一起很简单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="fb78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可能有许多有用的扩展可以用来改进<code class="fe ls lt lu lv b">gozip</code>，比如连接Docker注册中心或S3桶，增加对其他语言的支持，甚至开发与AWS Lambda的端到端集成。就目前而言，我对我所拥有的感到满意，考虑到它只花了很少的时间来开发，并且肯定会在将来避免一些令人头痛的问题。</p><h1 id="ce6c" class="mg mb iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">结论</h1><p id="799a" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">在本文中，我谈到了我在AWS Lambda部署中遇到的问题，以及我如何利用Golang标准库中的<code class="fe ls lt lu lv b">flag</code>和<code class="fe ls lt lu lv b">os/exec</code>包的基本CLI来解决这些问题。虽然额外改进和扩展会使我的工具更有价值，但我觉得我在提高效率和开发工作之间取得了很好的折衷。</p><p id="9b80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你有最喜欢的实用工具吗？大家讨论一下吧！</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="3a07" class="ma mb iq lv b be mc md l nz mf"><strong class="lv ir">Want to Connect?</strong><br/><br/><a class="ae kv" href="https://blog.lorisocchipinti.com" rel="noopener ugc nofollow" target="_blank">Join my newsletter for more stories like this</a>.</span></pre></div></div>    
</body>
</html>