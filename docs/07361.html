<html>
<head>
<title>Exploring the New CSS Houdini Painting API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索新的CSS胡迪尼绘画API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-the-new-css-houdini-painting-api-3f641bfce614?source=collection_archive---------6-----------------------#2021-01-07">https://betterprogramming.pub/exploring-the-new-css-houdini-painting-api-3f641bfce614?source=collection_archive---------6-----------------------#2021-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="567f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">与浏览器渲染引擎的样式和布局流程挂钩的低级API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/80cb2c5b2a71ae39f66f57873d0f86e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SURbk6sxLK7AkAdN2k35og.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:ishoudinireadyyet.com</p></figure><p id="1f21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注:本文后半部分讨论的演示的源代码可以在</em> <a class="ae ky" href="https://gitlab.com/gvanderput/css-houdini-drawing-api" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> GitLab </em> </a> <em class="lv">上找到。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5b4a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">介绍</h1><p id="a738" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">正如我在最近一篇关于React组件内<a class="ae ky" href="https://gerardvanderput.medium.com/canvas-animation-inside-react-components-with-requestanimationframe-c5d594afc1b" rel="noopener"> canvas动画的文章中提到的，我<em class="lv">喜欢</em> HTML canvas。因此，当我读到一篇由Stephen Fulghum撰写的关于css-tricks.com的短文时，我对新的CSS Houdini APIs感到无比兴奋。</a></p><p id="595a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我感到兴奋的主要原因是，绘画API使得通过在PaintRenderingContext2D上绘画来创建<em class="lv">自定义CSS图像</em>成为可能(这几乎是我们使用常规Canvas API时在其上绘画的2D上下文的精确副本——除了一小部分功能)。</p><p id="fff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用绘画API，我们可以以编程方式绘制图像，并在CSS中使用这些图像。在绘图时，我们可以接收来自DOM和应用样式表的参数信息。</p><p id="6b60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MDN网络文档<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/Houdini" rel="noopener ugc nofollow" target="_blank">这样描述</a>:</p><blockquote class="na nb nc"><p id="f89d" class="kz la lv lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">Houdini是一组低级API，公开CSS引擎的部分内容，使开发人员能够通过挂钩浏览器渲染引擎的样式和布局过程来扩展CSS。</p></blockquote><p id="3398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我觉得这非常令人兴奋，尤其是因为我们看到所有主流浏览器都在实现这一点:</p><div class="ng nh gp gr ni nj"><a href="https://ishoudinireadyyet.com" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">胡迪尼准备好了吗？</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">版本Opera 52。发布日期:2018 . 3 . 22 Notes调试(即断点)不起作用。不支持“paint()”…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">ishoudinireadyyet.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ks nj"/></div></div></a></div><p id="1fb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在本文中了解一下<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Painting_API" rel="noopener ugc nofollow" target="_blank"> CSS绘画API </a>(以及<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Worklet" rel="noopener ugc nofollow" target="_blank">小工具</a>)。</p><p id="4109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">重要提示</strong> : <em class="lv"> CSS Houdini总体来说还是一个实验性的技术。但是如前所述，大多数浏览器</em> <a class="ae ky" href="https://ishoudinireadyyet.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lv">正在实现它</em> </a> <em class="lv">或者正在强烈考虑实现它。谷歌Chrome是一个早期的适配器，从65版开始支持绘画API，所以这是我们今天将使用的浏览器。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="830d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><em class="ny"> CSS Painti </em> ng API</h1><p id="e5ad" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">通过使用这个API，我们可以以编程方式绘制图像，并在我们的CSS中使用这些图像。这就是我们将要创造的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/ca84908eab6d802f1aa82d162581ea0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dEG8em6db6rTjvzCAUPJaQ.png"/></div></div></figure><p id="514e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">令人印象深刻的是，这是三个DIV元素，而<em class="lv">三个DIV元素只有</em>。</p><p id="9ebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在index.html的档案就是证据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="a131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">三个窗格背景的“样式化”(绘图…)是通过绘画API以编程方式完成的。所有三个窗格都是由同一个函数绘制的。</p><p id="497a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看样式表中的CSS类<code class="fe oc od oe of b">pane</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="179e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们<em class="lv">在第2行给</em>涂上叫做<em class="lv">窗格</em>的东西。这需要解释，我们很快就会看到。</p><p id="cb14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，paint函数并不是只执行一次。每当浏览器的渲染引擎发出指令时，它就会执行并重新绘制图像。例如，当用户调整浏览器窗口大小时，或者当DIV元素的其他CSS属性发生变化时，DIV元素会获得另一个维度。</p><p id="c0c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们的功能将“挂钩”到渲染引擎，这是一个非常高性能和低成本的操作。</p><p id="5a1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，值得一提的是，我们所有的窗格都有不同的字体大小(记住这一点，我们稍后将再次引用它)。我们看到使用了两个自定义CSS变量:</p><ul class=""><li id="bd68" class="og oh it lb b lc ld lf lg li oi lm oj lq ok lu ol om on oo bi translated"><code class="fe oc od oe of b">‑‑dot‑spacing</code></li><li id="f3ea" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated"><code class="fe oc od oe of b">‑‑pane‑color</code></li></ul><p id="577f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CSS变量并不新鲜。它们自2014/2016年以来一直存在(分别为。火狐/谷歌Chrome)。但是一个新的CSS胡迪尼API叫做<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Properties_and_Values_API" rel="noopener ugc nofollow" target="_blank"> CSS属性和值API </a>允许我们<em class="lv">注册</em>这些自定义变量，这样浏览器<em class="lv">将会知道更多关于它们的信息，</em>这将会派上用场。</p><p id="5c6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在样式表中，我们可以这样注册它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0118" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意，我们也可以在JavaScript </em>  <em class="lv">中完成这个</em> <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Properties_and_Values_API" rel="noopener ugc nofollow" target="_blank"> <em class="lv">。结果会是一样的。</em></a></p><p id="ccd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们为什么要这样做呢？现在我们的浏览器和它的渲染引擎知道了这些属性的细节。它知道<code class="fe oc od oe of b">‑‑pane‑color</code>包含一个<em class="lv">颜色值</em>，默认值是“#646464”。并且<code class="fe oc od oe of b">‑‑dot‑spacing</code>包含一个<em class="lv">长度值</em>，默认为“5px”</p><p id="bd46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的两个新变量现在被称为<em class="lv">注册定制变量</em>。</p><p id="9d37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到这行:</p><pre class="kj kk kl km gt ou of ov ow aw ox bi"><span id="3b22" class="oy me it of b gy oz pa l pb pc">background-image: paint(pane);</span></pre><p id="d145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">绘画API允许我们绘制图像。<code class="fe oc od oe of b">paint</code>函数接收一个参数。这个参数是一个<em class="lv"> JavaScript类</em>，它在一个名为<code class="fe oc od oe of b">worklet.js</code>的文件中注册为<em class="lv"> Paint </em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="156b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是！这段代码不能在我们常规的JavaScript执行环境中执行。它需要在一个所谓的——因此文件名为——<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Worklet" rel="noopener ugc nofollow" target="_blank"><em class="lv">的工作小程序</em> </a> <em class="lv"> : </em>中执行</p><blockquote class="na nb nc"><p id="b9dc" class="kz la lv lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">“Worklet接口是Web Workers的一个轻量级版本，允许开发人员访问渲染管道的低级部分。借助Worklets，您可以运行JavaScript和WebAssembly代码，在需要高性能的地方进行图形渲染或音频处理。”</p></blockquote><p id="c26f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过向我们的常规JavaScript文件(<code class="fe oc od oe of b">main.js</code>)中添加下面一行来确保工作小程序将被执行，该文件是在index.html内部加载的，如下所示:</p><pre class="kj kk kl km gt ou of ov ow aw ox bi"><span id="57b5" class="oy me it of b gy oz pa l pb pc">// main.js<br/>CSS.paintWorklet.addModule("worklet.js");</span></pre><p id="6e57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果该调用返回错误，则您的浏览器不支持绘画API。</p><p id="91cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们的Paint类“pane”以“Pane”的名称注册，我们可以在CSS中使用它，正如我们前面看到的:</p><pre class="kj kk kl km gt ou of ov ow aw ox bi"><span id="ca5e" class="oy me it of b gy oz pa l pb pc">background-image: paint<strong class="of iu">(pane)</strong>;</span></pre><h2 id="2ee6" class="oy me it bd mf pd pe dn mj pf pg dp mn li ph pi mp lm pj pk mr lq pl pm mt pn bi translated">“绘制类别”窗格的详细信息</h2><p id="b0ef" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">让我们看看worklet.js中的Paint类的细节:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="68ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态函数<code class="fe oc od oe of b">inputProperties</code>应该返回我们在绘制图像时感兴趣的CSS属性列表。这是任意的，你可以添加任何你想要的CSS属性。</p><p id="6e7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由<code class="fe oc od oe of b">contextOptions</code>返回的值表明我们希望能够在画布中使用透明度。</p><p id="2d99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在第10行，是<code class="fe oc od oe of b">paint</code>函数。在该函数中，我们将进行实际的绘制。在我们的例子中，它接收三个参数:</p><ol class=""><li id="f743" class="og oh it lb b lc ld lf lg li oi lm oj lq ok lu po om on oo bi translated"><code class="fe oc od oe of b">ctx</code>:我们画布上的2D背景。如果您熟悉常规的HTML Canvas元素，这应该会让您想起什么。</li><li id="dffc" class="og oh it lb b lc op lf oq li or lm os lq ot lu po om on oo bi translated"><code class="fe oc od oe of b">size</code>:一个<em class="lv"> PaintSize </em>实例，有两个属性:<code class="fe oc od oe of b">.width</code>和<code class="fe oc od oe of b">.height</code>。这些是我们为其绘制图像的HTML元素的计算尺寸。包括填充，如果设置的话。</li><li id="fee9" class="og oh it lb b lc op lf oq li or lm os lq ot lu po om on oo bi translated"><code class="fe oc od oe of b">styleMap</code>:<em class="lv">CSS声明块</em> ( <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/StylePropertyMapReadOnly" rel="noopener ugc nofollow" target="_blank">源</a>)的只读表示。它是一个<code class="fe oc od oe of b">StylePropertyMapReadOnly</code>的实例，只包含我们在静态函数<code class="fe oc od oe of b">inputProperties</code>中定义的属性值。</li></ol><p id="0400" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关最后一个参数的更多细节，您可以阅读关于<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Typed_OM_API/Guide" rel="noopener ugc nofollow" target="_blank"> CSS类型化对象模型API </a>和/或关于<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/StylePropertyMapReadOnly" rel="noopener ugc nofollow" target="_blank">StylePropertyMapReadOnly</a>接口的内容。</p><p id="4470" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">提示:</em> </strong> <em class="lv">在支持的浏览器中，通过调用computedStyleMap，可以获得DOM中任何HTML元素的完整StylePropertyMapReadOnly(包含所有计算的CSS样式):</em></p><pre class="kj kk kl km gt ou of ov ow aw ox bi"><span id="0a68" class="oy me it of b gy oz pa l pb pc">const styleMap =<br/>  document.getElementById('myElement').computedStyleMap();</span></pre><p id="af11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了阐明我们如何从这样的实例中检索值，我创建了一个带有一些行内注释的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="80df" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">画出真实的图像</h1><p id="bb12" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">回到我们的小演示的逻辑。唯一剩下的就是我们的paint函数体的内容了。</p><p id="fed4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以从简单地绘制一个填充的矩形作为背景图像开始(您应该认识到在常规HTML画布上绘制的命令):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="1207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/d90ec0cef9e814d854cdea517ea3e31b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D6L-Nruae3CardTqLCax3w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">绘制背景图片！</p></figure><p id="d08b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们如何使用自定义CSS属性<code class="fe oc od oe of b">‑‑pane‑color</code>来动态设置填充样式。</p><p id="6f7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用我们浏览器的开发工具，我们甚至可以更新颜色值，背景图像将立即重新绘制！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/0b09d89c7751555dc18547b2c11df5b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*w7dtxUoxloEa4nXd5P_AHA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">谷歌浏览器开发工具，颜色选择器。</p></figure><p id="87ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们用一些更奇特的逻辑更新我们的paint函数(你可以在库的<a class="ae ky" href="https://gitlab.com/gvanderput/css-houdini-drawing-api/-/blob/master/worklet.js" rel="noopener ugc nofollow" target="_blank"> worklet.js文件中查看细节)，我们的背景图像将看起来像这样:</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/ca84908eab6d802f1aa82d162581ea0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dEG8em6db6rTjvzCAUPJaQ.png"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b58f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">CSS过渡</h1><p id="d455" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">注意右下角的<em class="lv">点序列</em>。这些点之间的间距由自定义CSS属性<code class="fe oc od oe of b">‑‑dot‑spacing</code>的值决定，默认值为“5px”</p><p id="0ed9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过给这个属性添加一个过渡来增加一点乐趣。当我们将鼠标悬停在<code class="fe oc od oe of b">.pane</code>元素上时，我们还会增加点间距的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="7994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…悬停元素时会产生平滑的动画效果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/f20732745308fa51cf2834e6a6ac013c.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/1*Z_Uw007tXTg7u5zQ6U3gcw.gif"/></div></figure><p id="a6e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它展示了我们定制的<em class="lv">绘制函数</em>的性能，它每秒钟可以运行60多次。</p><p id="091d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能够向自定义CSS变量添加过渡的原因是我们之前已经注册了该属性(参见要点中的第1–5行)。</p><p id="90cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">提示:</em> </strong> <em class="lv">我们还可以为我们的自定义CSS属性添加一个无限的CSS动画，这将导致我们有一个自定义绘制的动画背景！</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c8d9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="375b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我发现胡迪尼绘画API不仅有趣，而且易于理解和强大(表演)。我满脑子都是使用这一新功能的想法，但我必须耐心等待，直到所有主流浏览器都支持它，然后我们才能考虑在生产中使用它。</p><p id="2fa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的宝贵时间！</p></div></div>    
</body>
</html>