# 学习动态编程:硬币兑换问题初学者指南

> 原文：<https://betterprogramming.pub/learn-dynamic-programming-the-coin-change-problem-22a104478f50>

## 通过学习动态编程的基础知识，提高你的面试技巧，成为一名更好的开发人员

![](img/99edc0dabcbfc61498e14137f5e1d77c.png)

米歇尔的照片||视觉故事在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

动态编程是一种解决复杂问题的方法，它包括将问题分解成更简单的问题并解决这些问题。如果你被要求乘 21 * 5，你可能会选择乘(20 * 5)加(1 * 5)。你没有解决一个复杂的问题，而是把它分解成三个简单的问题并解决它们。

*   20 * 5 = 100
*   1 * 5 = 5
*   100 + 5 = 105

正如我们将会看到的，这与动态编程中发生的事情并不*完全*相同，但它确实说明了通过将复杂问题分解成多个更简单的问题来解决它的基本思想。

# 硬币兑换问题

解释动态编程最常用的问题之一是硬币兑换问题。问题如下。

> 给你一个整数数组"***" coins "***"代表不同面额的硬币和一个整数" **amount"** "代表钱的总数。
> 
> 归还你需要的最少数量的硬币来补足这个数目。如果任何硬币的组合都无法补足该金额，则返回-1。
> 
> 你可以假设每种硬币都有无限个。

例如，假设我们正在处理普通的美国硬币(便士、镍币、一角硬币、两角五分硬币),需要返回 87 美分的零钱。在这种情况下，我们将获得两个输入:

```
amount = 87
coins = [ 1, 5, 10, 25 ]
```

我们可以用来返还 87 美分零钱的最少硬币数量是 6 枚硬币:3 枚 25 美分硬币、1 枚 10 美分硬币和 2 枚 1 美分硬币。所以我们的函数应该返回 6。

首先，让我们考虑一下在不使用动态编程的情况下，我们将如何处理这个问题。最简单的解决方案是暴力方法。简单地确定组成 87 的所有可能的硬币组合，然后返回最小集合的大小。这是可行的，但效率极低，尤其是对于较大的问题。

另一种方法是使用[贪婪算法](https://en.m.wikipedia.org/wiki/Greedy_algorithm)。贪婪算法是在每一步做出最佳选择的算法，称为“局部最优”选择。在这种情况下，这意味着总是选择最大的硬币。让我们一步一步来看看这是如何工作的。

1.  剩余:87。选择:季度(25)。
2.  剩余:62。选择:季度(25)。
3.  剩余:37。选择:季度(25)。
4.  剩余:12。选择:一角(10)。
5.  剩余:2。选择:便士(1)。
6.  剩余:1。选择:便士(1)。

解决方案:6

使用贪婪算法，我们很快发现所需的最少硬币数是 6 枚硬币(3 枚 25 美分硬币、1 枚 1 角硬币和 2 枚 1 分硬币)。

贪婪的解决方案对于这个特定的例子来说很好。实际上，它适用于任何使用美国硬币的例子，因为美国硬币使用特定的面额。但是在某些情况下，它无法找到更普遍的硬币兑换问题的正确解决方案。考虑以下问题。

```
amount = 20
coins = [ 3, 8, 11 ]
```

贪婪算法将进行以下尝试。

1.  剩余:20。选:11。
2.  剩余:9。选择:8。
3.  剩余:1。没有有效的选择。

解:-1(不可解)

但这是不正确的。在第一次选择 11 个之后，我们还剩 9 个。展望未来，我们可以看到这可以通过选择 3 三次来实现。但是我们贪婪的算法不知道这一点。它旨在使*成为本地*的最佳选择——选择当前可用的*最高面额。在这种情况下，由于 8(在剩余的 9 个中)是合适的，所以选择 8。我们需要的是一种算法，它可以“向前看”，看到虽然 8 是局部的*最优选择，但它不是长期的最优选择。这正是动态编程所做的。正如动态编程的一个定义所解释的，动态编程被设计成“整体问题的最优解依赖于其子问题的最优解。”**

*动态规划的关键是识别给主问题“最优子结构性质”的子问题。这只是一种正式的说法，关键是识别子问题，让我们通过反复解决子问题来解决主问题。*

*举个简单的例子，假设我们生活在一个世界里，把任何两个大于 1 的数 a 相加都太复杂了，我们被赋予了求解 3 + 2 的不可能任务。事实证明，我们很幸运！我们的问题具有最优子结构性质。我们知道 2 就是 1 + 1。所以我们可以把我们的问题简化为*

```
*3 + (1 + 1)*
```

*我们知道 3 是 2 + 1，所以我们可以进一步简化为*

```
*(2 + 1) + (1 + 1)*
```

*我们已经解决了 2 的子问题。是 1 + 1。因此，我们的原始问题可以被改写为只是我们的子问题的重复解决。*

```
*1 + 1 + 1 + 1 + 1*
```

*这是一个我们可以解决的问题。(任何读到这里的数学家都会对我的插图不满意，这是理所当然的。别想太多。不是数学证明，只是举例说明。)*

*回到我们的硬币兑换问题，我们的任务是识别子问题(“1 + 1”)，为了解决我们的主要问题，我们可以重复解决这个子问题。这是一项艰巨的任务，但实际上比听起来简单得多。事实上你已经知道答案了，只是你没有意识到而已。*

*以下是我们的解决方法。如果一个给定的硬币兑换问题是可解的，那么在某一点上，我们将得到最后一个硬币，它的面额正好等于剩余的金额。想象一下，我们使用标准的美国硬币，剩下 5 美分可以兑换。一枚镍币正好等于这个数量，所以我们的最后一枚硬币就是这枚镍币。这意味着返回的硬币总数将是我们之前*和*返回的硬币数(为了只剩下 5 美分我们需要的硬币数)再加上一个:我们最后的镍币。*

*我们可以用下面的形式描述来表示我们刚才所说的。*

> *F(a) = F(a - c) + 1*

*在哪里*

*   *F =我们求解硬币数量的函数*
*   *a =要找零的金额*
*   *c =我们将归还的最后一枚硬币的面额*

*这将是这样的，“为某一金额`a`找零所需的最小硬币数等于 1 加上为`a`找零所需的最小硬币数减去`c`，其中`c`是用于找零的最后一枚硬币。”*

*因此，将这一点应用到我们的镍的例子中，让我们假设我们要找的零钱是 40 美分。这意味着 a = 40。既然我们已经说过五分硬币将是我们返回的最后一枚硬币，这意味着 c = 5。所以把这些值代入 a 和 c，我们得到*

```
*F(40) = F(40 - 5) + 1*
```

*这简化为*

```
*F(40) = F(35) + 1*
```

*换句话说，兑换 40 美分所需的硬币数量等于兑换 35 美分所需的硬币数量，再加上一枚硬币(我们最后的镍币)。*

*这是关键的一步——现在我们将为 35 解决这个同样的子问题(姑且称之为“最终硬币子问题”)。*

```
*F(35) = F(35 - c) + 1*
```

*我们将使用一角硬币作为这里的最后一个硬币面额(我们将在一分钟内了解如何做出这一选择，但现在让我们假设它是一角硬币)。所以用一角硬币(10)代替 c，我们得到*

```
*F(35) = F(35 - 10) + 1*
```

*这简化为*

```
*F(35) = F(25) + 1*
```

*所以，35 美分找零需要的硬币数等于 25 美分找零需要的硬币数，再加上一个硬币(我们用的一角硬币)。记得我们之前的等式是*

```
*F(40) = F(35) + 1*
```

*我们可以代入新发现的 F(35 ),得到*

```
*F(40) = (F(25) + 1) + 1*
```

*或者*

```
*F(40) = F(25) + 2*
```

*因此，找零 40 美分所需的硬币数量等于找零 25 美分所需的硬币数量，再加上 2 个硬币(我们在前面两个子问题中使用的一角硬币和五分硬币)。从这里很容易看出我们对这个问题的解决方案是 3。通过反复解决最后一个硬币子问题，我们已经解决了最初的问题。*

*现在，我们需要知道的最后一件事是，对于给定的最终硬币子问题，如何确定哪个硬币应该是最终硬币。本质上，我们将重复试错，以确定哪个硬币为给定子问题提供了最佳解决方案。对每个子问题都这样做将会给我们主要问题的最优解。*

*有两种编码方法可供我们选择:“自顶向下”方法或“自底向上”方法。本文将介绍自顶向下的方法。*

# *自顶向下(递归)方法*

*在自上而下的方法中，我们将从起始金额开始，并使用每个可能的硬币面额作为子问题中的“最终硬币”，递归地尝试解决我们的子问题。所以用上面的标准美国硬币的例子，我们的问题是*

```
*amount = 40
coins = [ 1, 5, 10, 25 ]*
```

*我们将把我们的子问题表示为*

```
*min_coins(40) = min_coins(40 — c) + 1*
```

*并求解`c (using standard US coins 1, 5, 10, 25)`的每个可能值，使用最优结果(即所需硬币的最小数量)。*

*所以我们会检查*

*   *`min_coins(40 — 25) + 1`*
*   *`min_coins(40 — 10) + 1`*
*   *`min_coins(40 — 5) + 1`*
*   *`min_coins(40 — 1) + 1`*

*对于每一个可能的硬币，我们递归地检查这些子问题。因此*

*`min_coins(40 — 25) + 1`*

*简化为*

*`min_coins(15) + 1`*

*然后我们为每个可能的硬币解决这个子问题*

*   *`min_coins(15 — 25) + 1 => -1`*
*   *`min_coins(15 — 10) + 1`*
*   *`min_coins(15 — 5) + 1`*
*   *`min_coins(15 — 1) + 1`*

*注意，在这种情况下，我们的第一次尝试产生了-1，代表一个不可解的解。这表明我们的动态规划算法已经决定，当我们返回 40 美分的零钱时，我们不能从选择两个 25 美分开始。*

*在我们看一些代码之前，我们需要理解的最后一个概念是[记忆化](http://wikipedia.org/wiki/Memoization)。记忆化只是指缓存昂贵的函数调用的结果，这样我们就不必再次调用函数。例如，一旦我们计算出兑换 11 美分所需的最小硬币数，我们将缓存该结果，并将其用于所有未来的呼叫，这样我们就不必每次都重新计算。*

*好了，让我们来看看一些代码。为了尽可能降低门槛，我将用 Javascript、Python、Kotlin 和 Swift 提供解决方案。请随意使用您最熟悉的语言，因为所有四个代码片段都包含完全相同的算法。在完成下面的代码后，我们将在文章的剩余部分一步一步地浏览代码。*

## *java 描述语言*

## *计算机编程语言*

## *科特林*

## *迅速发生的*

*让我们浏览一下代码。(提前向 Python 读者道歉，使用 camel case 引用变量名，但其他 3 种语言都使用 camel case)。我们有两个函数，都叫做`coinChange`。第一个将我们的两个输入`coins`和`amount`作为参数。第二个函数添加了一个名为`solutions`的附加参数。这个参数是我们的记忆表。例如，当我们找到一个 8 的子问题的解时，我们将把它存储在记忆表数组的第 8 个索引中。在我们的初始函数中，我们将创建一个大小为 amount 的空数组，足够容纳所有可能的子问题的解决方案。*

*第二个`coinChange`函数将作为我们的递归函数。它最初由第一个 `coinChang` e 函数调用，然后继续调用自己，每次调用都将剩余的量用于下一个子问题。这就是将第二个参数命名为 `amountRemainin` g 而不是像我们在第一个函数中那样命名为 `amoun` t 的原因。所以让我们一步一步来看这个递归函数。*

*前两行涵盖了递归函数的基本条件。如果我们的剩余量小于 0，那么我们就达到了一个不可能的解，并返回-1，如问题说明中所指定的。如果余额正好是 0，那么我们返回 0，因为它需要 0 个硬币来兑换 0。*

*下一步利用我们的记忆表`solutions`。在我们计算如何为`amountRemaining`做出改变之前，我们需要检查我们是否已经计算了如何最好地为`amountRemaining`做出改变(这将存储在`solutions`中的索引`amountRemaining — 1`)。如果是这样，返回我们已经计算过的缓存值。*

*如果我们通过了这三个步骤，那么我们就有了一个有效的`amountRemaining`，我们还没有确定它的最优解。所以现在我们需要确定`amountRemaining`的最优解。我们将通过探索如果我们使用现有的每一枚硬币会发生什么来做到这一点。这就是递归的由来。*

*假设我们试图找 72 美分的零钱，在我们的假设场景中还剩 47 美分。我们将通过递归调用我们的`coinChange`函数*为每一种可能的硬币面额确定找零 47 美分的最佳解决方案。*我们实际上是在说，“假设此时我们选择下一个季度。需要多少硬币才能换成零钱？如果我们选择了一角硬币呢？一枚镍币怎么样？一分钱呢？”*

*关键步骤如下(语法可能因语言不同而略有不同)*

```
*solutionUsingThisCoin = coinChange(coins, amountRemaining - coin, solutions)*
```

*这个呢*

```
**if* solutionUsingThisCoin >= 0 && solutionUsingThisCoin < optimalSolution {
    optimalSolution = solutionUsingThisCoin + 1
}*
```

*如果我们接下来使用 coin `coin`，第一行递归调用`coinChange`来确定子问题的最佳可能解决方案。通过在每个硬币的循环中调用这个函数并取最低的结果，我们计算出这个子问题*的最佳可能解，而不管我们选择哪个硬币。例如，我们现在将知道`amountRemaining = 47`子问题的最佳可能解决方案是 5(恰好是 1 个 25 美分、2 个 10 美分和 2 个 1 美分，但是对于我们的实际问题，我们不关心具体的硬币是什么)。我们用`solutionUsingThisCoin + 1`更新`optimalSolution`，其中 1 代表测试硬币本身。这是我们在上面正式描述为`F(a) = F(a — c) + 1`的子问题的代码实现。最后，我们在记忆表中缓存新找到的子问题解(如果不可能，则为-1)并返回值。**

# *结论*

*动态规划被用于[多个问题](https://leetcode.com/tag/dynamic-programming/)，包括[硬币兑换问题](https://leetcode.com/problems/coin-change/)，背包问题，以及[求解斐波那契数列](https://leetcode.com/problems/fibonacci-number/)。这些都是你在面试中可能会遇到的问题，所以对于大多数软件开发人员来说，仅仅因为这个原因，理解动态编程是值得的。但是，即使你不期望在采访中回答这些问题，软件开发也是一个我们一直在寻求增长理解和发现解决问题的新方法的领域。动态编程是这方面的一个很好的例子，我希望它对您有所帮助。*