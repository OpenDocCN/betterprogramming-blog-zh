<html>
<head>
<title>Beginning Python Programming— Part 6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python编程入门—第6部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/beginning-python-programming-part-6-f128360f44ab?source=collection_archive---------2-----------------------#2019-05-29">https://betterprogramming.pub/beginning-python-programming-part-6-f128360f44ab?source=collection_archive---------2-----------------------#2019-05-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b96f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为您的代码创建可重用的蓝图</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8cff78f15ea82c69fd483413eeeb90da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i4t_VPny10Pu0guJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@brookelark?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁克·拉克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="6e47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一篇文章中，我们讨论了功能和范围:</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/beginning-python-programming-part-5-3c7cfa3cd701" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Python编程入门—第5部分</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">理解代码层次结构，以及如何使代码可重用</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="85e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它让我们很好地理解了如何将可重复的代码分解成函数，以及变量的范围如何影响程序的输出。</p><p id="ba67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们将学习一种新类型的物体，它也可以被认为是一种类型。这种新类型的对象可以被认为是一个容器或一个蓝图，它为类似的代码段定义了一个称为<em class="mn">名称空间</em>的特殊范围。</p><p id="d565" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个新对象被称为一个<strong class="lb iu">类</strong>，它在清理和组织代码方面创造了奇迹。在我们学习本教程的过程中，我希望你能想象出一个房子的蓝图，或者是制作上图中所有星星的切饼刀。它不是房子，也不是cookie，但它确保蓝图的每个<em class="mn">实例</em>都是完全相同的——这正是一个类所做的。</p><h1 id="dd46" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">班级</h1><p id="7bac" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">简单地说，类是包含变量和函数的对象，但实际上，它们不仅仅是充当容器。类提供了一种创建可重复使用的代码的方法。</p><p id="ab53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我要回去引用指针(你知道，我们提到它是有原因的)。当你创建一个类时，你就创建了一个引用；也就是说，指向内存中将存储该类的块，并引用它来创建该类的新实例或副本，并将它们复制到具有新值的新内存块中。这听起来可能会令人困惑，所以一些例子可能会有所帮助:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5a45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过使用语法<code class="fe nn no np nq b">class &lt;name&gt;()</code>来定义一个类。使用PascalCase命名类，这意味着没有空格，每个单词的第一个字母大写。对于这个例子，我正在创建一个新的<code class="fe nn no np nq b">House</code>类。括号是必需的，我将在下面解释为什么。和往常一样，我们需要在末尾使用冒号来包含类的主体。</p><p id="8edc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会在这里看到一些有趣的东西:<code class="fe nn no np nq b">def __init__(self)</code>。至少，这是你的<em class="mn">初始化函数</em>应该的样子。经验丰富的程序员喜欢称之为<em class="mn">构造方法。</em></p><p id="87ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mn">一个方法和函数用在一个句子中时大多是可以互换的。大部分程序员用错了不会纠正你，但是函数和方法的区别在于方法属于类对象，而函数不属于。</em></p><p id="7232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">init</code>两边的双下划线或<code class="fe nn no np nq b">__</code>被称为<em class="mn">下划线</em>，用于<em class="mn">重载</em>，或替换默认方法中的功能。默认情况下，类包含一个<code class="fe nn no np nq b">__init__(self)</code>方法，所以如果你事先没有任何事情要做，你不必添加这个方法。</p><p id="198e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我没有在构造函数方法中仅仅使用<code class="fe nn no np nq b">self</code>，我还有一些其他的参数:<code class="fe nn no np nq b">number_of_windows</code>和<code class="fe nn no np nq b">number_of_doors</code>。我认为很容易理解它们的用途，因为我们在命名变量方面做得越来越好，但是为什么我们需要添加它们呢？</p><p id="d8ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在构造函数方法中，添加参数来允许我们为类提供初始值总是有用的。在这种情况下，我们增加了窗户和门的数量。但仅此还不够。如果你只是把参数传递给一个常规函数，而不对它们做任何事情，什么都不会发生，对吧！？我们需要把这些分配给类，但是范围有问题。</p><p id="066f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在上一篇文章中告诉过你，Python为你处理范围。这就是其中一个例子。我们需要将传递给构造函数方法的值赋给属于该类实例的变量。为此，我们使用关键字<code class="fe nn no np nq b">self</code>。<code class="fe nn no np nq b">self</code>表示这个对象，不是类，而是要从类中创建的对象。</p><p id="4eab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">self.number_of_windows</code>是<em class="mn">属性</em>，我们将使用它来存储我们为<code class="fe nn no np nq b">number_of_windows</code>参数传递的数字。点<code class="fe nn no np nq b">.</code>在这里很重要。如果<code class="fe nn no np nq b">self</code>指的是这个类的实例，而<code class="fe nn no np nq b">self.number_of_windows</code>是这个实例中我们想要存储这个值的属性，那么这一定意味着<code class="fe nn no np nq b">.</code>一定意味着这个属性是这个类的子对象。<code class="fe nn no np nq b">.</code>是我们如何访问类的属性和方法。</p><p id="1b21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">属性很像方法，除了它们引用类中的变量。是的，它们有时互换使用，你很可能不会得到纠正。</p><p id="5d4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当创建一个新类时，您会注意到我有下面几行代码:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="fa72" class="nv mp it nq b gy nw nx l ny nz">my_house = House(number_of_windows=2, number_of_doors=1)<br/>your_house = House(4, 2)</span></pre><p id="92f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个都是正确的语法，除了一个使用了<em class="mn">命名参数</em>。如果你错过了我关于<a class="ae ky" href="https://medium.com/better-programming/beginning-python-programming-part-5-3c7cfa3cd701" rel="noopener">函数</a>的文章，我会稍微介绍一下，但同样适用于这里。如果使用命名参数，每个人都很容易理解这些值的含义，而无需深入研究代码。您还可以获得以任何顺序使用它们的额外好处。另外，注意<code class="fe nn no np nq b">self</code>是缺失的，我们在调用方法时不使用<code class="fe nn no np nq b">self</code>。一分钟后会有更多关于<code class="fe nn no np nq b">self</code>的报道。</p><p id="85ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们像对待<code class="fe nn no np nq b">your_house</code>一样选择省略命名参数，我们必须对参数使用与它们在构造函数方法中出现时相同的顺序。这意味着窗户的数量是<code class="fe nn no np nq b">4</code>，门的数量是<code class="fe nn no np nq b">2</code>。</p><p id="908f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们打印每栋房子的窗户和门的数量。<code class="fe nn no np nq b">my_house</code>只有一扇门，所以它会打印号码<code class="fe nn no np nq b">1</code>。<code class="fe nn no np nq b">your_house</code>比我的好，所以可以打印<code class="fe nn no np nq b">4</code>窗口。我可以打印出<code class="fe nn no np nq b">your_house.number_of_doors</code>，它会显示<code class="fe nn no np nq b">2</code>。原因是<code class="fe nn no np nq b">my_house</code>和<code class="fe nn no np nq b">your_house</code>是<code class="fe nn no np nq b">House</code>的两个不同实例。尽管它们来自同一个类，但它们是两个独立的实体。</p><p id="5540" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么为什么<code class="fe nn no np nq b">self</code>如此重要呢？我们还没有讨论静态方法，但是我们可以快速浏览一下。静态方法是不依赖于类属性或方法运行的方法。让我们看一个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ec43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有一个<code class="fe nn no np nq b">Dog</code>类。跳过构造函数，我们有了第一个方法。这是一个类方法，所以我们包含了<code class="fe nn no np nq b">self</code>。我们这样做是因为它引用了这个实例的<code class="fe nn no np nq b">name</code>和<code class="fe nn no np nq b">age</code>属性。然而，所有的狗生来就有说话的能力。当我们提到狗时，我们知道它们应该汪汪叫！既然我们知道这是事实，我们可以通过在这个名为<code class="fe nn no np nq b">staticmethod</code>的方法上面添加一个<em class="mn">装饰器</em>来使它成为一个静态方法。<code class="fe nn no np nq b">@</code>表示这应该修饰下一个函数，是的，这是必需的。</p><p id="9e45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<code class="fe nn no np nq b">@staticmethod</code>装饰器，我们不必使用<code class="fe nn no np nq b">self</code>。那么<code class="fe nn no np nq b">self</code>到底有什么重要的？如果我们使用<code class="fe nn no np nq b">self</code>，我们必须有一个类的实例。如果我们没有一个类的实例，我们就不能使用属于这个类的属性或方法。通过使用静态方法，我们能够在不创建类的实例的情况下调用这个方法。</p><p id="fd64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们可以使用<code class="fe nn no np nq b">Dog.speak()</code>并将<code class="fe nn no np nq b">Woof!</code>打印到我们的终端上。<code class="fe nn no np nq b">Datetime</code>是使用静态方法的一个很好的例子。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="b18e" class="nv mp it nq b gy nw nx l ny nz">from datetime import datetime</span><span id="e8e4" class="nv mp it nq b gy oa nx l ny nz">datetime.now()</span></pre><p id="e9e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在不要太担心第一行——我们将在以后讨论它。这里你可以看到<code class="fe nn no np nq b">datetime</code>类有一个名为<code class="fe nn no np nq b">now()</code>的静态方法，它从你的系统返回当前的日期时间。我能够调用<code class="fe nn no np nq b">now</code>方法，而不需要实际创建<code class="fe nn no np nq b">datetime</code>类。</p><p id="27f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的方法未标记为静态，则需要创建该类的新实例，然后才能使用它。</p><p id="adc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<code class="fe nn no np nq b">Dog</code>类中的<code class="fe nn no np nq b">get_description(self)</code>方法需要注意的一些事情:如果你从类内部调用这个方法，你必须使用<code class="fe nn no np nq b">self.get_description()</code>。仅仅因为它是这个类的一个方法，并不意味着它可以免于<code class="fe nn no np nq b">self</code>。当从类中的另一个方法调用静态方法<code class="fe nn no np nq b">speak()</code>时，必须用<code class="fe nn no np nq b">self</code>调用它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/e372be4d05c34ced0dd67ee9ad1a4afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lxbsmROioYy8I2Kw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@brenoassis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Breno Assis </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="eaa8" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">性能</h1><p id="7eb7" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">不，不是那些种类的属性，但是我确实选择了那个图像作为一个千篇一律的蓝图的例子。</p><p id="93a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向类添加属性时，范围很重要。举例来说:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7aa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有什么区别？在<code class="fe nn no np nq b">Person1</code>中，我们添加了一个名为name的属性，然后我们从<code class="fe nn no np nq b">Person1</code>创建了<code class="fe nn no np nq b">fred</code>和<code class="fe nn no np nq b">wilma</code>。我们有两个实例，我们将每个实例设置为各自的名称。</p><p id="a136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们显示<code class="fe nn no np nq b">fred.name</code>时，它错误地打印了“威尔玛”，但是当我们显示<code class="fe nn no np nq b">wilma.name</code>时，它正确地打印了“威尔玛”。怎么回事？！</p><p id="8796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你不使用<code class="fe nn no np nq b">self.</code>创建一个顶级属性时，就像我们在构造函数方法中所做的那样，它变成了一个类属性。</p><p id="1b93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类属性和类属性之间的区别在于，类属性在类的所有实例中共享，而类属性仅在该实例中可用。</p><p id="3790" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">范围让我们来到这里，但是如果我们将<code class="fe nn no np nq b">name</code>改为<code class="fe nn no np nq b">self.name</code>，我们的代码将是正确的；然而，在创建实例时，我们没有构造函数方法来为<code class="fe nn no np nq b">self.name</code>提供初始值。</p><p id="3389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的第二个例子中，我们没有使用<code class="fe nn no np nq b">self.name</code>作为类中的属性，但是，我们将构造函数中的参数<code class="fe nn no np nq b">name</code>赋给了<code class="fe nn no np nq b">self.name</code>。在幕后，当您使用<code class="fe nn no np nq b">self.something</code>时，Python自动将范围提升到类的顶级，并将对象标记为属性而不是特性。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="5c55" class="nv mp it nq b gy nw nx l ny nz">class Dog(object):<br/>    self.name</span><span id="7db2" class="nv mp it nq b gy oa nx l ny nz">    def __init__(self, name):<br/>        self.name = name</span><span id="4354" class="nv mp it nq b gy oa nx l ny nz"># is the same as</span><span id="bd9a" class="nv mp it nq b gy oa nx l ny nz">class Dog():<br/>    def __init__(self, name):<br/>        self.name = name</span></pre><p id="988e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在创建类的时候要小心，并且尽量使用构造函数。</p><h1 id="943c" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">摘要</h1><p id="19c0" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">今天我们讨论了类、方法和属性。我也顺便提一下<em class="mn">初始化</em>。我将在下一个主题中更多地介绍初始化，但我真的想介绍更多与类相关的内容，包括更多的覆盖、子类、去初始化和引用计数。</p><h2 id="5316" class="nv mp it bd mq oc od dn mu oe of dp my li og oh na lm oi oj nc lq ok ol ne om bi translated">推荐阅读</h2><p id="c276" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">Python教程的9 - 9.4章。</p><div class="lv lw gp gr lx ly"><a href="https://docs.python.org/3/tutorial/classes.html" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">9.类- Python 3.7.3文档</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">与其他编程语言相比，Python的类机制用最少的新语法和…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">docs.python.org</p></div></div></div></a></div><p id="b9b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是让我觉得上课有趣的东西，我希望你在实践你所学的东西。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/@broebling/beginning-python-programming-part-7-2f7df98b7c68" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Python编程入门—第7部分</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">在上一篇文章中，我们讨论了类、方法和属性。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="on l mj mk ml mh mm ks ly"/></div></div></a></div></div></div>    
</body>
</html>