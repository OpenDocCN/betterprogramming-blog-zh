<html>
<head>
<title>Understanding Structured Concurrency With Java and Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Java和Kotlin理解结构化并发</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-structured-concurrency-with-java-and-kotlin-53db895967f9?source=collection_archive---------8-----------------------#2022-10-24">https://betterprogramming.pub/understanding-structured-concurrency-with-java-and-kotlin-53db895967f9?source=collection_archive---------8-----------------------#2022-10-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="10c3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索如何更安全、更轻松地运行多个程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1b14230a8ecba8b87759083e2cb4ffad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NZYPUk0x7dzyke69flVDTw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迪帕克·劳特拉在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="0124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能最近听说过<a class="ae ky" href="https://en.wikipedia.org/wiki/Structured_concurrency" rel="noopener ugc nofollow" target="_blank">结构化并发</a>，并想知道它到底是关于什么的。结构化并发是一种范式，它试图使并发程序更容易阅读和理解，更快编写，最重要的是，使它们更安全。</p><p id="24e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们进入细节之前，为什么需要这个？我们来过一遍背后的原因。</p><h1 id="a873" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">背景</h1><p id="f060" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了理解结构化并发的需要，我们必须回顾过去，看看几年前并发程序是如何编写的。</p><p id="5c08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在非结构化并发范例中，我们在代码中的任何地方开始线程，并且不清楚这个线程在哪里开始或结束。</p><p id="e6dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用Java看下面的例子；尽管比Java中的其他老例子更容易理解，但它仍然有一个主要问题:它不安全，因为一个线程的失败不会取消任何其他任务，并且结果是不可预测的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="5001" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行上面的代码，我们会看到3号任务是如何立即运行异常的，尽管发生了异常，其他任务都没有停止。应用程序继续运行，几秒钟后其他任务成功完成。这不是我们所期望的。理想情况下，我们希望立即取消其他任务。想象其中一个任务永远运行，我们可以在每次失败时泄漏一个线程。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="9baa" class="mz lw it mv b gy na nb l nc nd">&gt; Task :UnstructuredConcurrency.main() FAILED<br/>I'm task 3 running on ForkJoinPool.commonPool-worker-3<br/>I'm task 2 running on ForkJoinPool.commonPool-worker-2<br/>I'm task 1 running on ForkJoinPool.commonPool-worker-1</span><span id="3a42" class="mz lw it mv b gy ne nb l nc nd">Deprecated Gradle features were used in this build, making it incompatible with Gradle 8.0.</span><span id="3418" class="mz lw it mv b gy ne nb l nc nd">You can use '--warning-mode all' to show the individual deprecation warnings and determine if they come from your own scripts or plugins.</span><span id="cb2c" class="mz lw it mv b gy ne nb l nc nd">See https://docs.gradle.org/7.4/userguide/command_line_interface.html#sec:command_line_warnings<br/>2 actionable tasks: 1 executed, 1 up-to-date<br/>Exception in thread "main" java.util.concurrent.CompletionException: java.lang.RuntimeException: Something went wrong!</span></pre><p id="7a3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，解决办法是什么？这就是结构化并发发挥作用的地方。让我们看看怎么做。</p><h1 id="fea3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结构化并发</h1><p id="b028" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">结构化并发的主要目标有两个:能够编写更容易理解的并发代码和避免线程泄漏。这个想法总是保证当我们的代码的控制流被分成多个并发线程时，我们确保在这个流结束时，我们总是合并这些线程并保持对它们如何被执行的控制。借助结构化并发，我们可以确保在我们的应用程序中没有孤立线程脱离控制。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/1f8899cfee005684e0fc27b2ca4ee1ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R0lJp1ZmDOzu5jED.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@alain_pham?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Alain Pham </a>在<a class="ae ky" href="https://unsplash.com/s/photos/structure?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4eb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着并发代码的开始和结束总是显式的。这样，任何开发人员都可以很容易地理解并发代码，而不依赖于他们在并发编程方面的经验或专业知识。简单永远是赢家。</p><p id="cea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">近年来有几种编程语言引入了结构化并发——其中包括<a class="ae ky" href="https://go.dev/" rel="noopener ugc nofollow" target="_blank"> Golang </a>、<a class="ae ky" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>和<a class="ae ky" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>。我们将特别关注<a class="ae ky" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>如何实现结构化并发。</p><h1 id="9139" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Kotlin中的结构化并发</h1><p id="87a1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Kotlin 通过使用协程作用域来实施结构化并发。协程是Kotlin给它的“虚拟线程”起的名字，虚拟线程是需要一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Operating_system" rel="noopener ugc nofollow" target="_blank">操作系统</a>线程来完成工作的执行单元，但不依赖于给定的操作系统线程。它们可以等待<a class="ae ky" href="https://en.wikipedia.org/wiki/Input/output" rel="noopener ugc nofollow" target="_blank"> IO </a>而不阻塞给定的操作系统线程，另一个协程可以在此期间占用相同的操作系统线程。你可以在这里阅读更多关于Kotlin协同程序的内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/20a0625a2ec972d4e7d64fbeb8a673a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BxayRnIUT3fc5f1D.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">科特林标志</p></figure><p id="2e09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其思想是协程作用域总是属于一个具有有限生命周期的实体，例如，一个繁重的调度批处理作业使用数千个线程来实现更高的吞吐量。</p><p id="3d10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当该作业结束时，由于它的作用域也应该终止，所有属于它的协程或虚拟线程都不应该继续存在。</p><p id="0707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank">科特林</a>有一个<a class="ae ky" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/" rel="noopener ugc nofollow" target="_blank">全球镜</a>可用，尽管不推荐使用。为什么？因为全局范围将在应用程序的整个生命周期中持续，在大多数情况下，这不是我们想要的，因为这将导致多线程泄漏。</p><p id="670b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">全局范围唯一有效的用例是当给定实体的生命周期与应用程序或服务相同时。例如，一个不断重复执行的后台作业。假设我们正在实现一个分布式系统，它需要在每个节点中运行一个后台作业，只要应用程序在运行，就向系统中的其余节点发送一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Heartbeat_(computing)" rel="noopener ugc nofollow" target="_blank">周期心跳</a>。</p><p id="bdeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想在<a class="ae ky" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>中这样做，我们必须用<code class="fe ng nh ni mv b">GlobalScope.launch</code>运行一个线程；通过这样做，我们创建了一个(虚拟)线程，它只会在应用程序被告知关闭时停止。</p><p id="03fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个经验法则，你总是需要为你的线程定义一个范围。运行一个或多个线程并不重要。这样做可以保证，如果您的应用程序在该范围内出现问题，该范围内的所有子线程都会被正常取消，无论发生什么情况，您都不会有线程泄漏！</p><p id="6b3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个kot Lin<a class="ae ky" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank">中的例子来理解我们刚刚描述的行为。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6d8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们在给定的范围内运行两个后台线程。运行此代码的结果将类似于以下内容:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="3872" class="mz lw it mv b gy na nb l nc nd">Adding random number to 10<br/>Adding random number to 1<br/>Task completed with result 13232!</span><span id="50d5" class="mz lw it mv b gy ne nb l nc nd">Process finished with exit code 0</span></pre><p id="8d3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni mv b">Job2</code>首先打印其值，因为我们已经指定了更长的延迟来模拟IO延迟。</p><p id="0743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了证明这段代码在出错时是安全的，当第一个线程等待一秒钟时，我们将在第二个协程中抛出一个异常。在前面的例子中，使用<code class="fe ng nh ni mv b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" rel="noopener ugc nofollow" target="_blank">CompletableFuture</a></code>，当出现异常时，其他线程继续运行，就像什么都没发生一样。在本例的后面，这种情况不会发生。我们将取消该范围内任何正在运行的线程。用于模拟我们刚刚描述的内容的代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="13e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您检查第二个作业，我们会在500毫秒后引发一个异常。此时，<code class="fe ng nh ni mv b">job1</code>仍然应该等待额外的500ms，然后打印一些东西。然而，如果事情实现正确，我们应该会看到一个异常被抛出，运行时应该立即取消所有正在运行的线程。这正是我们运行这段代码时发生的情况:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="2cd3" class="mz lw it mv b gy na nb l nc nd">Exception in thread "main" java.lang.RuntimeException: Something went wrong!<br/>	at org.theboreddev.CoroutinesKt$sumNumbersToRandomNumbers$2$job2$1.invokeSuspend(Coroutines.kt:27)<br/>	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)<br/>	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:106)<br/>	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:570)<br/>	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:750)<br/>	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:677)<br/>	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:664)</span></pre><p id="d225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以随意自己运行它，看看它是否像预期的那样工作。</p><p id="8de6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经看到了<a class="ae ky" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>如何允许我们在相同的范围内对协程进行分组，以及它如何相应地自动处理该范围内的任何线程。但是Java呢？我们能用Java做类似的事情吗？</p><h1 id="0148" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Java中的结构化并发</h1><p id="922e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">简单的回答是没有，或者至少现在还没有。JDK团队长期以来一直致力于Java并发模型的一些改变。这个项目叫做<a class="ae ky" href="https://wiki.openjdk.org/display/loom/Main" rel="noopener ugc nofollow" target="_blank">项目织机</a>。这项工作中实现的变化将引入Java中的<a class="ae ky" href="https://en.wikipedia.org/wiki/Virtual_threads" rel="noopener ugc nofollow" target="_blank">虚拟线程</a>和结构化并发。关于结构化并发，它已经作为<a class="ae ky" href="https://openjdk.org/jeps/428" rel="noopener ugc nofollow" target="_blank"> JEP 428 </a>的一部分包含在Java 19中，但是它仍然处于“孵化器”阶段。<a class="ae ky" href="https://en.wikipedia.org/wiki/Virtual_threads" rel="noopener ugc nofollow" target="_blank">虚拟线程</a>作为<a class="ae ky" href="https://openjdk.org/jeps/425" rel="noopener ugc nofollow" target="_blank"> JEP 425 </a>的一部分，在Java 19中作为预览特性被引入。你必须<a class="ae ky" href="https://theboreddev.com/how-to-enable-previews-in-java/" rel="noopener ugc nofollow" target="_blank">启用预览</a>才能测试它。</p><p id="cec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当这些变化变得稳定时，Java并发模型和我们对Java中多线程的理解将会变得更好。</p><p id="1203" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java中现有的将Java线程绑定到OS线程的限制将不复存在，能够构建更加健壮、可靠和高性能的系统。这是Java生态系统的巨大进步！</p><p id="6f72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码举例说明了Java中结构化并发的新提议。你会发现这是Java中一个全新的范例。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="774c" class="mz lw it mv b gy na nb l nc nd">Response handle() throws ExecutionException, InterruptedException {<br/>    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {<br/>        Future&lt;String&gt;  user  = scope.fork(() -&gt; findUser());<br/>        Future&lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder());</span><span id="ab0a" class="mz lw it mv b gy ne nb l nc nd">scope.join();           // Join both forks<br/>        scope.throwIfFailed();  // ... and propagate errors</span><span id="1d5a" class="mz lw it mv b gy ne nb l nc nd">// Here, both forks have succeeded, so compose their results<br/>        return new Response(user.resultNow(), order.resultNow());<br/>    }<br/>}</span></pre><p id="6ccc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们不打算深入研究Java虚拟线程的细节，但是我保证我们很快会更多地讨论它们。从我们到目前为止所看到的来看，它看起来非常有前途，但是我们将把它留在这里作为一个小的引子，让您开始对Java中的未来并发模型感兴趣！</p><h1 id="d203" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="e53d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们已经看到一些语言如何实现虚拟线程来构建更具弹性的系统，其中一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Operating_system" rel="noopener ugc nofollow" target="_blank"> OS </a>线程可以在数百或数千个虚拟线程之间共享，因为与现有的Java线程相比，虚拟线程非常轻量级。甚至Java现在也在向这种新范式迁移，这种新范式允许并发代码更容易理解和编写。很快，我们将不再需要编写容易出错的并发代码，因为我们必须考虑代码可能错误执行的许多可能情况！</p><p id="b89d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对<a class="ae ky" href="https://go.dev/" rel="noopener ugc nofollow" target="_blank"> Golang </a>如何实现并发感兴趣，可以从这里看“go routines”<a class="ae ky" href="https://go.dev/tour/concurrency/1" rel="noopener ugc nofollow" target="_blank">开始。</a></p><p id="30ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们今天的全部内容！我们真的希望您喜欢这篇文章，并且更好地理解什么是结构化并发以及我们为什么需要它。</p><p id="0e88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往，如果你喜欢我们的文章，请继续关注。</p><p id="cb09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>