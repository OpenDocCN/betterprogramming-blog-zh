<html>
<head>
<title>How To Gradually Introduce React.js in an Old Application and migrate it to a SPA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在旧应用中逐步引入React.js并迁移到SPA</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dont-be-afraid-of-legacy-how-to-gradually-introduce-react-js-in-a-really-old-application-79876c0dfa42?source=collection_archive---------1-----------------------#2019-10-14">https://betterprogramming.pub/dont-be-afraid-of-legacy-how-to-gradually-introduce-react-js-in-a-really-old-application-79876c0dfa42?source=collection_archive---------1-----------------------#2019-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="43e3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不要害怕遗产</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/293c1e73a91637e4a6cc78a3e379e51a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2-UaeE0Groi6bV6x"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://me.me/i/much-later-the-life-of-a-software-engineer-clean-slate-8712be55ea2c41f2bf6fd85feb386dab" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="5dec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数开发人员的梦想之一是从零开始一个项目，在这个项目中，legacy不在字典中，一切看起来都很美好。</p><p id="5df8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅仅因为这是一个愿望和最好的情况，并不意味着它是所有情况下的最佳选择。我无法告诉你我见过多少重构比最初的更糟糕。遗留应用程序可能有许多历史细节，如果没有正确的项目经验、时间和资源带宽，这些细节可能会被简单的视图所忽略。</p><p id="cead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将介绍我们如何将<a class="ae ky" href="https://github.com/uyuni-project/uyuni" rel="noopener ugc nofollow" target="_blank"> Uyuni </a>与React.js集成，并将其从缓慢的多页面应用程序转换为快速的单页面应用程序(SPA)的用例。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="41e4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用例</h1><p id="2e54" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Uyuni是一个已有15年历史的应用程序，是广泛使用的SUSE管理器的上游社区项目。可以想象，一个存在时间如此之长的应用程序，有着大量的遗留技术和庞大的代码库。在某一点上，我们必须决定哪些策略是最合适的，以便不落后，并根据新的趋势和用户需求不断发展产品。</p><p id="1720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想在引入新技术的同时不断推出新功能，你应该迭代地去做；否则，你会很难过。</p><p id="0c81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到前端技术，一般来说，有一些规则我相信可以帮助你不被锁定在某个特定的技术上。例如，<strong class="lb iu">永远三思</strong>当:</p><ul class=""><li id="6d5e" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">添加新库。仅仅因为这会为你节省几天时间，并不意味着从长远来看它是值得的。</li><li id="798c" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">将您的业务逻辑耦合到特定的框架。如果你的所有逻辑都是完全独立的，并且只依赖于语言的原生特性，那么你使用哪个框架都没有关系，不管是React.js、Vue.js还是Angular:代码应该是可重用的。</li></ul><p id="e66d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Uyuni中，为了使我们的UI和技术栈现代化，我们决定选择react . js。react . js团队在使其易于集成到现有应用程序方面做得很好。查看官方的<a class="ae ky" href="https://reactjs.org/docs/add-react-to-a-website.html" rel="noopener ugc nofollow" target="_blank">文档</a>，我们可以看到在页面中间添加React.js非常简单，只需定义一个新的HTML元素id作为我们新应用程序的容器/根，并简单地调用方法<code class="fe nn no np nq b">ReactDOM.render</code> ( <code class="fe nn no np nq b">&lt;App /&gt;</code>，<code class="fe nn no np nq b">htmlContainer</code>)。这种方法有一个很多人都不知道的巨大好处，那就是您可以在同一个页面上根据需要多次执行它，这非常方便。</p><p id="a13e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们遵循的策略是利用这种方法的灵活性开始引入独立的React.js树。通过这种方式，我们可以逐步实现新的功能，并重构UI的旧部分。在下图中，蓝色框现在使用React.js，红色框仍然使用传统的服务器端呈现的JSP堆栈。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/f76e9b496ab774cddbe35ddd69a712f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*601O1QG_wExVlzsg"/></div></div></figure><p id="5bc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个结构，我们可以根据需要逐步将React.js添加到更多的页面中。</p><p id="1131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，一切看起来简单明了！但是我们有丰富的用户界面。如果这些独立的部分需要互相通信会怎么样？我们如何捆绑所有这些小应用并从服务器注入数据？</p><p id="a2fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，这种通信和共享状态仍然是通过服务器完成的。即使使用客户端呈现引擎，每次页面点击仍然会返回一个完整的服务器页面。这也有助于更快地呈现第一页，因为所有需要的信息都可以在一个请求中获得——尽管有时我们也依赖JSON API来获得更动态的页面。</p><p id="2098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了注册这些新应用并从服务器端模板技术向它们注入数据，我们利用了新的ES6特性动态导入及其在webpack中对代码分割的支持。</p><p id="ed71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种策略，webpack将为每个React.js应用程序自动创建一个新的包文件，只有在加载应用程序时才会获取这个包文件。Uyuni只需要知道<code class="fe nn no np nq b">main.bundle.js</code>文件，该文件将导出一个能够加载任何注册应用程序的全局函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/101f1a51262a9861824fc3265417ce5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/0*sAO7jMCommj1_AzU"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/5d168d60a6ff0a39432d3da6a79f6c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zv96Q8PlsVwUaHCx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nu"> main.bundle.js —通过全局函数spaImportReactPage </em>引导任何应用程序所需的基础代码</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/d8085223ee1575219b7cd78bdbc3a995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qOxyf2jS6hK7meRU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nu">为其JS捆绑包注册新应用和入口点</em></p></figure><p id="e3ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，从任何服务器端模板技术通过名称异步加载任何已注册的React.js应用程序将变得简单。方法<code class="fe nn no np nq b">spaImportReactPage</code>将返回一个带有渲染器函数的承诺，该函数可用于在任何地方渲染我们的应用程序，并向其中注入一些初始状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/745fe26f073a838876539913f44c76c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p14qpT0Ukm2ZBX_J"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nu">html模板中函数SpaImportReactPage的用法示例</em></p></figure><p id="b1d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:请记住，这段代码是在HTML中内联执行的，没有任何代码转换。因此，如果您需要支持像Internet Explorer这样的旧浏览器，您可能需要为promises添加一个polyfill！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="43c2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">开发周期更快</strong></h1><p id="4d20" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们面临的另一个问题是，即使有了更新的堆栈，我们也无法使用绿色React.js应用程序可以拥有的快速开发，例如即时重新编译或热重新加载。由于页面不是完全独立的，仍然依赖于web服务器来注入数据和呈现遗留部分，我们仍然必须在服务器运行的任何地方部署这些新的部分。</p><p id="865c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">令人高兴的是，这看起来比实际情况更复杂。使用<a class="ae ky" href="https://github.com/webpack/webpack-dev-server" rel="noopener ugc nofollow" target="_blank"> webpack-dev-server </a>和<a class="ae ky" href="https://github.com/chimurai/http-proxy-middleware" rel="noopener ugc nofollow" target="_blank"> http-proxy-middleware </a>，我们可以拥有一个本地webpack服务器来完成重新编译我们的JavaScript更改和热更新的所有魔法。通过这种方式，我们可以从本地环境中提供所有更新的文件，但仍然可以代理所有与前端无关并依赖于后端服务器的内容。它可以是本地开发服务器，也可以是远程共享测试服务器。因此，如果您只需要在前端工作，就没有必要像以前一样安装整个后端，并且仍然可以享受所有令人敬畏的webpack/hot-reload特性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/44ce5a9d8eca3e17bae5b56819245d59.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/0*V-SrcNnmDRYV2anu"/></div></figure><p id="a61c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请随意查看我们的webpack代理配置:<a class="ae ky" href="https://github.com/uyuni-project/uyuni/tree/master/web/html/src/build" rel="noopener ugc nofollow" target="_blank">https://github . com/uyuni-project/uyuni/tree/master/web/html/src/build</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ab2d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">单页应用</strong></h1><p id="b43f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">尽管有了更新的堆栈和快速的开发周期，我们仍然对最终的结果不太满意。因为我们仍然有一个旧的多页面架构风格，每次用户点击一个新的页面，就会发生一次完整的刷新。尽管这种架构可以用于更简单、动态性更低的web应用程序，但在我们的例子中，它影响了使用UI的整体体验。</p><p id="1e44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，改进这种行为的正确方向应该是从多页面转向SPA架构。当从头开始一个新的应用程序时，这可以通过开发一个独立的前端应用程序来实现，该应用程序通过<a class="ae ky" href="https://github.com/ReactTraining/react-router" rel="noopener ugc nofollow" target="_blank"> react-router </a>使用客户端路由控制所有页面，并从JSON/graphql API获取所有需要的数据。然而，如果没有巨大的重构，将现有的遗留应用程序迁移到这种风格是不可行的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/43fda54cf97b37771177f5cd7e5f7af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JgMQ03Axzb5nYfsY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">绿色区域代表新页面上的成本</p></figure><p id="45e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过一些研究和考虑，我们决定使用一种更实用的方法，遵循多页面和SPA之间的混合架构风格。基本上，我们的想法是，我们的路线是由链接本身定义的，服务器一直以同样的方式呈现所有的完整页面。但是我们并没有完全刷新页面，而是通过Ajax调用获取相同的链接URL，只替换页面上需要的部分。这可以在初始化新的JavaScript引擎、获取和解析公共资源以及绘制未更改的部分时节省大量时间。这也有助于避免在每个页面上重新连接WebSocket连接。</p><p id="b755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在尝试了我们自己的解决方案和一些现有的开源库之后，我们决定将我们的解决方案基于库<a class="ae ky" href="https://sennajs.com" rel="noopener ugc nofollow" target="_blank"> Senna.js </a>之上。其他被考虑的库是turbolinks和pjax，但是它们不能满足所有的需求。</p><p id="c92c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们面临的主要挑战是:</p><ol class=""><li id="05b8" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ny nf ng nh bi translated">修改表现不佳的代码，这在每次页面转换时都会造成内存泄漏</li><li id="a416" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ny nf ng nh bi translated">确保React.js old trees DOM结构完全卸载</li></ol><p id="5a46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，与架构重构相比，所需的工作量是最小的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/538467f41a7360ff93e4523a019c2730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6u7CqWxW2vRcoO2u"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">绿色区域代表新页面上的成本</p></figure><p id="254e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随意看看我们与Senna.js/SPA:<a class="ae ky" href="https://twitter.com/luis_neves12" rel="noopener ugc nofollow" target="_blank">的主要配置https://github . com/uyuni-project/uyuni/tree/master/web/html/src/core/spa</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a8cc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">让过渡变得更好</h1><p id="65f2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">所有这些工作为未来许多可能的改进打开了大门。因为我们有一个SPA，不需要每次点击都刷新页面，所以我们现在可以很容易地改善页面之间的过渡，无论是速度还是流畅度。</p><p id="96ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在添加了这个新的SPA引擎之后，我们开始注意到一些过渡看起来有点笨拙。尽管两个旧页面之间的转换看起来流畅而快速，但是在两个反应页面之间，可以注意到一个白色闪烁的页面。</p><p id="24be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为React渲染是在客户端完成的，所以这种行为是意料之中的。Senna.js无法猜测新页面何时可以过渡到。基本上，当旧页面被删除并且新页面已经安装在屏幕上时，就会出现白屏，但React.js仍处于完成第一次初始渲染的过程中。这在旧页面中不会发生，因为当新页面到达浏览器时，它已经在服务器中呈现了。</p><p id="df0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的一面是Senna.js的转换行为很容易扩展。因此，我们不必使用同步默认转换。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/879031cd6a03646da31587419596f38d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r4UqVtDfigppeCXB"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ob">白屏图像:</strong>旧页面- &gt;删除旧页面- &gt;过渡- &gt;添加新页面- &gt;白屏- &gt;完成渲染</p></figure><p id="6500" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们可以将其扩展为异步的，只在渲染完成时显示新页面，将旧页面作为占位符。基本上，它会在屏幕上呈现两个页面，只有当一切准备就绪时，才会显示新页面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/b9e396bb26e8011d5101534bb05b9a96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rXt_4QY78n5gFdM2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ob">异步转场图像:</strong>旧页面- &gt;添加新页面- &gt;完成渲染- &gt;移除旧页面- &gt;完成转场</p></figure><p id="6895" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当读取碰巧利用了所有页面都是通过Ajax读取的这一事实时，可以在时间上做额外的工作。默认情况下，当用户单击一个链接时，就会进行获取。</p><p id="98bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，这是可以优化的。例如，我们可以在用户鼠标悬停在某个链接上几秒钟时显示出点击该链接的意图时开始获取页面，或者(甚至更极端)在鼠标按下时开始获取页面。click事件仅在鼠标抬起事件之后发生，因此由于硬件限制，我们可以在鼠标按下和鼠标抬起事件之间节省几毫秒的时间。在用这个策略做了一些测试之后，我们注意到每次转换都有大约100毫秒的改进。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="68d0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="ddee" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">总而言之，即使我们还有很大的改进空间，我们对迄今为止的努力还是很满意的。与之前相比，我们离拥有一个看起来像本地桌面应用的web应用越来越近了。即使有了所有这些改进，我们也没有大的架构重构。这可能是有价值的，特别是在大多数开发人员都关注后端的产品中，因此减少了前端新贡献的摩擦。</p><p id="4f6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想进一步讨论什么，请随意发表评论。</p></div></div>    
</body>
</html>