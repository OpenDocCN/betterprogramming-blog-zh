<html>
<head>
<title>Cut Your RSpec/Minitest Runtime With TestProf</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TestProf削减您的RSpec/Minitest运行时</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cut-your-rspec-minitest-runtime-with-testprof-d19e55783050?source=collection_archive---------11-----------------------#2020-01-02">https://betterprogramming.pub/cut-your-rspec-minitest-runtime-with-testprof-d19e55783050?source=collection_archive---------11-----------------------#2020-01-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="af68" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我如何让我的测试运行速度加快70%</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d770a5b96ff60453c45c9920c3c9c6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m4jWGqfOPRQzj-PrLhq5cw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">卢卡斯·布拉塞克在<a class="ae kv" href="https://unsplash.com/s/photos/time?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="bcdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着业务复杂性的增加，许多应用程序的测试套件运行速度呈指数级下降。这对开发人员的生产力和资源效率来说是痛苦的。</p><p id="292e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将向您展示我如何通过更改几行代码使我的测试运行速度提高了70%。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a06d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">为什么考试很重要</h1><p id="42fe" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">想象一下，我有一个测试套件来验证我的代码的所有输出和副作用。有了这种掩护，我可以自信地重构代码，直到我对它的质量感到满意<strong class="ky ir">。</strong>信心允许更快的代码编写、遗留代码重构和可持续的速度。这对软件开发至关重要。</p><p id="0623" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">未经测试的遗留代码是一个沼泽，会让开发团队停滞不前。最终，它会降低整个组织的速度，甚至让它们破产。因此，消除恐惧对高绩效团队和公司至关重要。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3f88" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">我爱TDD</h1><p id="e3d1" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">随着程序员的成熟，我越来越喜欢上<a class="ae kv" href="https://www.codecademy.com/articles/tdd-red-green-refactor" rel="noopener ugc nofollow" target="_blank"> TDD </a>。这让我想起了<a class="ae kv" href="https://en.wikipedia.org/wiki/Scientific_method" rel="noopener ugc nofollow" target="_blank">科学方法</a>——成功的结果是在实验之前定义的。所以结果不会影响你的判断。</p><p id="85dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TDD让你专注于重要的东西——输入和输出，而不是内部发生了什么。在开发过程中，我们经常通过将一个类分成几个类、颠倒逻辑或者使用不同的数据结构来多次改变它的实现。使用TDD，您确信重构没有改变输出。这就是TDD如此强大的原因。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e227" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">问题是——测试太慢了</h1><p id="f70c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">所以我完成了我的测试套件——45个漂亮、闪亮的RSpec/Minitest测试。但是，唉，它们太慢了——运行时间超过25秒。</p><p id="9f62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当实践TDD时，您会多次运行您的测试(通过<a class="ae kv" href="https://www.codecademy.com/articles/tdd-red-green-refactor" rel="noopener ugc nofollow" target="_blank">红色、绿色、重构</a>循环)。25秒是等待结果的一段相当长的时间。这让我的一天变得更加无聊。我能怎么做呢？</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="57f2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">挖掘理解——为什么这么慢？</h1><p id="bbed" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我的测试如此缓慢有两个主要原因:</p><ol class=""><li id="8681" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated"><strong class="ky ir">活动记录:</strong> Ruby on Rails使得在您的类中混合DB访问变得太容易了——这反过来导致您编写单元/集成混合测试，这比单元测试慢得多。在这些测试中，您不仅要测试您的类，还要在过程中在数据库中创建对象。数据库访问比执行代码慢得多，这本身就大大降低了测试的速度。</li><li id="bbf3" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir">工厂级联:</strong>为了在测试中创建那些复杂的对象，许多RoR开发人员使用<a class="ae kv" href="https://github.com/thoughtbot/factory_bot" rel="noopener ugc nofollow" target="_blank">工厂机器人</a> gem。这是一个美妙的宝石，它通过利用<code class="fe nk nl nm nn b">Factory</code>模式提高了生活质量并有助于创建简洁的测试。但潜在地，这也导致了一种叫做<em class="no">工厂级联</em>的现象。工厂级联是指一个工厂使用其他工厂，而这些工厂又使用其他工厂。在级联测试中，您可以很容易地发现自己在一次测试中获得了+30 DB <code class="fe nk nl nm nn b">insert</code>。(参见<a class="ae kv" href="https://evilmartians.com/chronicles/testprof-2-factory-therapy-for-your-ruby-tests-rspec-minitest" rel="noopener ugc nofollow" target="_blank">这篇精彩的帖子</a>了解更多关于这个话题的信息。)</li></ol><p id="8b43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在测试过程中，我不仅在数据库中创建对象，还创建了许多对象——这很慢。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="dfe1" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">测试专家Gem来拯救我们了</h1><p id="2c49" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">有一种很酷的宝石叫做<code class="fe nk nl nm nn b"><a class="ae kv" href="https://test-prof.evilmartians.io/#/" rel="noopener ugc nofollow" target="_blank">test-prof</a></code>。它有一些工具可以帮助你分析和改进你的测试套件。由于我的代码中没有繁重的工作，我立即怀疑是工厂级联。</p><p id="8a3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了理解级联有多糟糕，我使用了gem提供的<a class="ae kv" href="https://test-prof.evilmartians.io/#/factory_prof" rel="noopener ugc nofollow" target="_blank">工厂分析器</a>。</p><p id="5596" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">工厂利润的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/e4cb92eff636beaae3d920dc08efe026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I3QR_KIqRokax9TlGcI1fA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">哎哟！</p></figure><p id="d741" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于45个测试，在数据库中创建了1，490个对象，这导致这45个测试在对象创建上花费了超过15秒的时间。听起来像是一大堆东西，对吧？绝对是！请继续阅读下面的内容，看看我是如何削减70%的对象和运行时间的。</p><p id="358c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我注意到的第一件事是我正在创建152个位置，这需要4秒钟——但是没有一个是从我的测试套件中显式调用的(<code class="fe nk nl nm nn b">top-level</code>是0)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/a891f497e16339ca74f2353c67868e45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gTjjlMXvi7xKg5GYqliKow.png"/></div></div></figure><p id="521a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了停止疯狂地创建位置，我必须看看哪个工厂正在为我创建这些位置。</p><p id="1c0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看来<code class="fe nk nl nm nn b">invoice</code>工厂是罪魁祸首之一。因为我正在构建一个处理发票数据的类，所以您可以假设我经常调用发票工厂。</p><pre class="kg kh ki kj gt nq nn nr ns aw nt bi"><span id="533b" class="nu ma iq nn b gy nv nw l nx ny">FactoryBot.define do<br/>  factory :invoice do<br/>    some_dependency { "foo" }<br/>    ...<br/><strong class="nn ir">    location</strong></span></pre><p id="a7ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">啊哈！确实是头号嫌疑人。以防你不知道——你不必每次需要一个对象时都使用<code class="fe nk nl nm nn b">FactoryBot</code>的<code class="fe nk nl nm nn b">create</code>方法。只有在需要将对象持久保存在数据库中时，才应该使用它。可以用来生成对象的其他选项有:</p><ul class=""><li id="1339" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nz nc nd ne bi translated"><code class="fe nk nl nm nn b">FactoryBot.build</code> —这不会在数据库中持久化对象，所以比<code class="fe nk nl nm nn b">create</code>快得多，但会<strong class="ky ir"/><strong class="ky ir"/>持久化数据库中的对象关联。所以它会导致瀑布。哎哟。</li><li id="ef35" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nz nc nd ne bi translated"><code class="fe nk nl nm nn b">FactoryBot.build_stubbed</code> —这个不会在数据库中持久化对象，也不会持久化关联。很好。但是有一个问题:它将填充<code class="fe nk nl nm nn b">id</code>列和工厂中定义的所有字段。使用这种方法时，如果不显式地将关联传递给工厂，您将无法使用它们——例如<code class="fe nk nl nm nn b">FactoryBot.build_stubbed(:location, address: address)</code>。</li></ul><p id="11a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，让我们通过一个存根位置，无论我在哪里创建发票:</p><pre class="kg kh ki kj gt nq nn nr ns aw nt bi"><span id="c490" class="nu ma iq nn b gy nv nw l nx ny">let(:invoice) { FactoryBot.build_stubbed(:final_invoice, <strong class="nn ir">location: location</strong>) }<br/>let(:location) { FactoryBot.<strong class="nn ir">build_stubbed(:location)</strong> }</span></pre><p id="5171" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看使用<code class="fe nk nl nm nn b">build_stubbed</code>后的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/f7355ddcdb6c268232fa0b8f80f14141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fgV7CP9yu1LZ0dvq4ySrlQ.png"/></div></div></figure><p id="246d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哇哦。存根位置也大大减少了<code class="fe nk nl nm nn b">address</code>和<code class="fe nk nl nm nn b">bank_account</code>的数量。我们已经削减了30%的测试运行时间。</p><p id="7546" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看我们还能解决什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/a906f315c15e02b4a00ce79d7d992a1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9IN5Gda1T-5N2tRHY-oimg.png"/></div></div></figure><p id="5a02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">似乎是个不错的候选人。同样，我们看到一个没有被显式调用的工厂占用了大量运行时间——8秒。让我们看看什么工厂可能是罪魁祸首:</p><pre class="kg kh ki kj gt nq nn nr ns aw nt bi"><span id="07f7" class="nu ma iq nn b gy nv nw l nx ny">FactoryBot.define do<br/>  factory :line_item do<br/>    some_dependency { "foo" } <br/><strong class="nn ir">    association :reservation, factory: :primary_reservation</strong></span></pre><p id="6fac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">啊哈！是<code class="fe nk nl nm nn b">line_item</code>厂。行项目是发票中的行——因此它们在这个测试套件中经常使用。让我们找到不需要预订的地方，并将<code class="fe nk nl nm nn b">nil</code>分配给它们:</p><pre class="kg kh ki kj gt nq nn nr ns aw nt bi"><span id="6174" class="nu ma iq nn b gy nv nw l nx ny">let!(:line_item) { FactoryBot.create(:line_item, <strong class="nn ir">reservation: nil</strong>) }</span></pre><p id="8afd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并且确实需要预订的位置将获得存根预订:</p><pre class="kg kh ki kj gt nq nn nr ns aw nt bi"><span id="cff0" class="nu ma iq nn b gy nv nw l nx ny">let(:primary_reservation) { FactoryBot.build_stubbed(:primary_reservation, <strong class="nn ir">location: location</strong>) }</span></pre><p id="4acc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/3bccc15facab1777871a472bf1735650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n48fDayt9l6kTpuC8H7DUw.png"/></div></div></figure><p id="5cf3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嘭！又过了六秒钟。哇，创建对象的时间从15多秒缩短到了4秒，减少了70%以上。</p><p id="c5fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">四秒钟的时间似乎足够在这一点上停下来了。让我们推动这个提交。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="08ed" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">总结一下</h1><ul class=""><li id="f372" class="mw mx iq ky b kz mr lc ms lf oc lj od ln oe lr nz nc nd ne bi translated">使用<code class="fe nk nl nm nn b">FactoryBot.create</code>时要小心。它会导致瀑布，大大降低测试速度。</li><li id="41a0" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nz nc nd ne bi translated">尽可能使用<code class="fe nk nl nm nn b">build_stubbed</code>，如果这样还不够好，尝试使用<code class="fe nk nl nm nn b">build</code>。</li><li id="95c7" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nz nc nd ne bi translated">如果您必须使用<code class="fe nk nl nm nn b">create</code>，使用<code class="fe nk nl nm nn b">test-prof</code>了解级联有多糟糕，并尝试使用此信息进行优化。</li></ul><p id="5a75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8444" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">资源</h1><ul class=""><li id="5454" class="mw mx iq ky b kz mr lc ms lf oc lj od ln oe lr nz nc nd ne bi translated"><a class="ae kv" href="https://www.codecademy.com/articles/tdd-red-green-refactor" rel="noopener ugc nofollow" target="_blank">《红绿重构》</a>code academy</li><li id="514f" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nz nc nd ne bi translated"><a class="ae kv" href="https://github.com/thoughtbot/factory_bot" rel="noopener ugc nofollow" target="_blank">工厂_机器人</a></li><li id="c076" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nz nc nd ne bi translated"><a class="ae kv" href="https://evilmartians.com/chronicles/testprof-2-factory-therapy-for-your-ruby-tests-rspec-minitest" rel="noopener ugc nofollow" target="_blank">《火星编年史》中的“TestProf II:你的红宝石测试的工厂疗法”</a></li><li id="f263" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nz nc nd ne bi translated"><a class="ae kv" href="https://test-prof.evilmartians.io/#/factory_prof" rel="noopener ugc nofollow" target="_blank">工厂利润</a></li></ul></div></div>    
</body>
</html>