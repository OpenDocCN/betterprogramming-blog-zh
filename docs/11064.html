<html>
<head>
<title>A Deep Dive Into Weak Memory Management in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入探讨JavaScript中薄弱的内存管理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-deep-dive-into-weak-memory-management-in-javascript-55ab240a09aa?source=collection_archive---------5-----------------------#2022-02-15">https://betterprogramming.pub/a-deep-dive-into-weak-memory-management-in-javascript-55ab240a09aa?source=collection_archive---------5-----------------------#2022-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9e99" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索JavaScript的薄弱API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b0ce647f201e8deb4c8e4233ddcc9353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SQbsjWOboVpFCfnA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@possessedphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">附身摄影</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="cf8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript内存管理过程起初看起来很简单。JavaScript VM通过垃圾收集内存回收过程来管理内存。</p><p id="5613" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们不能强迫垃圾收集以编程方式运行。浏览器会决定何时执行它。由于没有共同的规格，它将因供应商而异。这是一个不可预测和不确定的过程。</p><p id="c0b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这并不意味着我们可以无忧无虑。我们需要了解记忆在钩子下是如何工作的。否则，我们可能会出现一些内存泄漏。为了有资格进行垃圾回收，该对象不能在其他地方被引用。肯定是够不着的。相反，当保存对对象的引用时，该资源被阻止分配。</p><p id="ff3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们从一个不受我们管理的对象获取引用时会发生什么？我们应该保留引用吗？我们应该只是复制对象吗？怎么才能知道什么时候不再被引用？</p><p id="1abf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript弱API就是基于这一动机而创建的。它使我们能够在不阻止垃圾收集过程的情况下保存对对象的引用。目标对象可以随时回收。这些不会添加强引用。当我们想在一个对象还活着的时候保存它的信息时，它是合适的。</p><p id="fab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将检查我们拥有的所有工具以及如何最好地使用它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="45fd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">WeakRef API - ES2021</h1><p id="299d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">那个<code class="fe mz na nb nc b">WeakRef</code> API是最新的弱API之一。它让我们保存对一个对象的弱引用，并在需要时提取它。</p><p id="1600" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">怎么用？这是一个分两步走的过程。</p><p id="874d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 1。</strong> <strong class="lb iu">创建弱引用:</strong>目标参数必须是对象。只有那些是垃圾收集的。例如，您不能为字符串或数字创建WeakRef。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9309" class="nh md it nc b gy ni nj l nk nl">// creating a weak object reference<br/>const ElmentRef = new <strong class="nc iu">WeakRef(</strong>element<strong class="nc iu">)</strong>;</span></pre><p id="555a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。</strong> <strong class="lb iu">拉引用:</strong>要使用被引用的目标，我们必须使用<code class="fe mz na nb nc b">deref()</code>。第一步只是生成一个普通的JavaScript对象，它包含对我们的目标的弱引用。我们对此无能为力。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="de77" class="nh md it nc b gy ni nj l nk nl">// pulling stored weak object<br/>const element = ElmentRef<strong class="nc iu">.deref()</strong>;</span></pre><p id="9873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们使用了那个<code class="fe mz na nb nc b">deref()</code>方法，我们就创建了一个新的对对象的强引用。这意味着在引用未被使用之前，该对象不再有资格进行垃圾收集。这个物体会变成<code class="fe mz na nb nc b">undefined</code>是没有意义的。这会使该特征不可靠且无用。</p><p id="4a17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个完整的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="582a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意在上面的代码中，我们总是需要检查从<code class="fe mz na nb nc b">deref</code>返回的不是<code class="fe mz na nb nc b">undefined</code>。如果从<code class="fe mz na nb nc b">DOM</code>中删除了<code class="fe mz na nb nc b">DOM</code>元素，那么资源可以在任何时候被回收。</p><p id="dfb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看另一个例子。让我们做一个元素记忆跟踪器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1b4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们将继续获取控制台<code class="fe mz na nb nc b">Element is still on memory</code>语句，直到元素在GC中从内存中被清除。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a71f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">WeakSet和WeakMap API - ES2015</h1><p id="9720" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些是最古老的脆弱的Javascript APIs。它们从<code class="fe mz na nb nc b">ES6</code>开始就存在了。尽管它们可以保存弱引用的集合，但是它们是不可迭代的。我们只能添加值、查询它们的存在或删除它。</p><p id="7f05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们总是通过目标对象与它们互动。</p><p id="106c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来看一个<code class="fe mz na nb nc b">WeakSet</code>的例子。它很简单，只是作为一个弱字典。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="02d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而<code class="fe mz na nb nc b">WeakMap</code>更为复杂。我们可以用它来存储目标对象的附加信息。可以是对象或者只是原语。当目标引用被垃圾回收时，它们将被回收。</p><p id="723d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="187a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在上面的例子中看到的，当通过<code class="fe mz na nb nc b">set()</code>添加一个值时，可以通过执行具有相同目标的<code class="fe mz na nb nc b">get()</code>方法来检索它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ad6f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">终结器API - ES2021</h1><p id="17ce" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在最新的<code class="fe mz na nb nc b">ES2021</code>中，有一种方法可以知道一个对象是否已经被GC回收。这个特性叫做<code class="fe mz na nb nc b">Finalizers</code>。</p><p id="9ff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而:</p><ul class=""><li id="b539" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">不能保证回调会被执行。</li><li id="d162" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">目标对象已被清除，将无法访问。</li><li id="c017" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">回调将执行多长时间是不确定的。可以是一分钟，也可以是一个小时。</li><li id="9c67" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">行为可能因供应商而异</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1baa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么<code class="fe mz na nb nc b">register</code>方法采用两个值？当<code class="fe mz na nb nc b">FinalizationRegistry</code>被调用时,<code class="fe mz na nb nc b">x</code>值可能已经被垃圾收集了。所以没有办法找回那个值。相反，我们可以传递任何我们认为合适的目标提示。</p><p id="c728" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们用相同的<code class="fe mz na nb nc b">x</code>值调用<code class="fe mz na nb nc b">register</code>，它将不会被垃圾收集，因为该参数是强持有的。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5fdd" class="nh md it nc b gy ni nj l nk nl">// ❌ x would never be reclaimed as it is strongly held in the second parameter<br/>cleanup.<strong class="nc iu">register(x, x)</strong>;</span></pre><p id="684c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一种方法可以注销回调的执行。该方法可以接受第三个参数，这个参数不是很强。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5480" class="nh md it nc b gy ni nj l nk nl">// ✅ x is not strongly held so it can be garbage collected<br/>cleanup.<strong class="nc iu">register(</strong>x, 'cleaning up x'<strong class="nc iu">, x)</strong>;</span><span id="472c" class="nh md it nc b gy oc nj l nk nl">// ✅ will remove callback<br/>cleanup.<strong class="nc iu">unregister(x);</strong></span></pre><p id="7e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="od">不建议在关键区域使用此功能。这只是为了执行一些额外的清理，以进一步减少我们的web应用程序的内存占用。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6f9c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用例</h1><p id="337a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在查看用例之前，请注意这是一个高级特性，应该小心使用。成功地使用它需要一些仔细的思考和计划。</p><h2 id="127e" class="nh md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">1.附加数据</h2><p id="8972" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时候我们只是想增强一些不属于自己的对象。我们不控制他们的引用或他们的流程。</p><p id="ea97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们可以改变对象实例，打破函数式编程范式。创建另一个有一些变化的对象会增加我们的内存占用。</p><p id="c42b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个例子可能是DOM元素或来自库的对象。如果我们需要增强它们，我们可以简单地创建一个<code class="fe mz na nb nc b">WeakRef</code>或<code class="fe mz na nb nc b">WeakMap</code>并将我们自己的值存储在那里。这样，当不使用该对象时，我们就不必考虑增强的属性。</p><h2 id="7125" class="nh md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">2.贮藏</h2><p id="2f74" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以利用这些API来创建一些缓存机制。我们可以创建临时缓存，当这个大对象不再被引用并被清除时，可以回收这些缓存。</p><p id="776f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个例子是将不变性与<code class="fe mz na nb nc b">WeakMap</code>结合起来，创建一个缓存来存储计算开销很大的操作的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d6a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们在JavaScript引擎中内置了一个自动清除缓存。这会变得非常有用。</p><h2 id="f54b" class="nh md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">3.额外清理</h2><p id="16fb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通过选择进入<code class="fe mz na nb nc b">FinalizationRegistry</code>，我们可以在对象不再存在时执行一些清理。它不应该用于执行某些业务逻辑。</p><p id="e5f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的代码第一次可以更接近垃圾收集过程并利用它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="09c0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">概述</h1><p id="5d26" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经看到JavaScript最近是如何增强其弱引用特性的。我们突然对应用程序有了更多的控制权，并且离引擎更近了。</p><p id="6037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，重要的是不要严重依赖任何脆弱的引擎API。它们有非常具体的用例。垃圾收集过程很复杂，并且会因浏览器而异。这是一个很难的课题，需要不断改进和变化。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="b44c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您有兴趣了解更多关于JavaScript内存泄漏的知识吗？查看我下面的文章:</p><div class="op oq gp gr or os"><a rel="noopener  ugc nofollow" target="_blank" href="/5-common-javascript-memory-mistakes-c8553972e4c2"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">5个常见的JavaScript内存错误</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">避免应用程序内存泄漏的技巧</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">better编程. pub</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div></div></div>    
</body>
</html>