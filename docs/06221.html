<html>
<head>
<title>Implementing Micro Frontends Using Single SPA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用单个SPA实施微前端</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-micro-frontends-using-single-spa-1ac2a3f704a2?source=collection_archive---------6-----------------------#2020-09-10">https://betterprogramming.pub/implementing-micro-frontends-using-single-spa-1ac2a3f704a2?source=collection_archive---------6-----------------------#2020-09-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d54aae4d558c06c7742772ce1aa85210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lAf89fIazn-hu0mlBuAHQw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">使用单个SPA组合React、Vue和JS应用程序</p></figure><p id="c70f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在我的<a class="ae ld" href="https://medium.com/better-programming/what-are-micro-frontends-is-it-even-necessary-to-use-them-f1393d65ef2f?source=friends_link&amp;sk=e058674caf56966e035ddd76dc124631" rel="noopener">上一篇文章</a>中，我解释了什么是微前端以及它们如何有用。在本文中，我将解释我们如何实现微前端来使用单个SPA在单个页面中显示各种组件，这是一个MFE(微前端)框架。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="7e2b" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">什么是单身SPA？</h1><p id="495a" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">Single SPA是一个框架，用于在前端应用程序中整合多个JavaScript MFEs。现在有很多框架，但这是最受欢迎的微前端开源项目之一。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="ad48" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">我们要实现什么？</h1><p id="1aa3" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">我们将实现一个简单的应用程序，它由三个应用程序组成，Vanilla JS、React和Vue app，其中每个应用程序执行递增和递减操作。我们还将确保我们在这些应用程序之间进行沟通，也就是说，每当我们在任何应用程序中进行更改时，这些更改也会反映在其他应用程序中。请记住，当使用MFE框架时，我们应该始终确保使用DOM/globals进行交互，而不是任何发布-订阅方法。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="e948" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">让我们开始吧</h1><p id="92f1" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">假设您的机器上已经安装了<code class="fe mo mp mq mr b">node</code>和<code class="fe mo mp mq mr b">npm</code>，让我们继续下面的步骤。</p><h2 id="e259" class="ms lm it bd ln mt mu dn lr mv mw dp lv kq mx my lz ku mz na md ky nb nc mh nd bi translated">安装所需的软件包</h2><p id="0ad7" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">为了使用<code class="fe mo mp mq mr b">npm</code>脚本运行服务器，我将首先用这个命令初始化我的项目目录</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="8010" class="ms lm it mr b gy nm nn l no np">npm init -y</span></pre><p id="113e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这反过来会给我提供一个<code class="fe mo mp mq mr b">package.json</code>文件。我们不会使用CLI方法创建React应用程序或Vue应用程序。相反，我们将手动实现一切。</p><p id="b0f7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了实现微前端，<code class="fe mo mp mq mr b">single-spa</code>是需要的主要软件包之一。对于React，我们将需要像<code class="fe mo mp mq mr b">react</code>、<code class="fe mo mp mq mr b">react-dom</code>、<code class="fe mo mp mq mr b">single-spa-react</code>这样的包。对于Vue，我们需要两个包<code class="fe mo mp mq mr b">vue</code>和<code class="fe mo mp mq mr b">single-spa-vue</code>。最后，对于普通的JS，我们需要<code class="fe mo mp mq mr b">single-spa-html</code>。<a class="ae ld" href="https://single-spa.js.org/docs/ecosystem" rel="noopener ugc nofollow" target="_blank">单spa </a>提供的套餐多的是。对于我们的应用程序，这些包就足够了。运行此命令安装这些依赖项。</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="d38d" class="ms lm it mr b gy nm nn l no np">npm install react react-dom single-spa single-spa-react single-spa-vue vue single-spa-html</span></pre><p id="54d8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们还需要两套包装才能继续。一个是<a class="ae ld" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank">巴别塔</a>。这是用来转换所有花哨的新语法(JSX等。)转换成浏览器可接受的JS语法。简单地说，它改变了语法。<a class="ae ld" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>需要另一套包。Webpack是Javascript的一个模块捆绑器。它将许多文件捆绑成一个文件。我们还可以为我们配置Webpack应该如何捆绑。</p><p id="7903" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们首先为Babel安装依赖项。运行此命令安装这些开发依赖项。</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="f4ee" class="ms lm it mr b gy nm nn l no np">npm install --save-dev <a class="ae ld" href="http://twitter.com/babel/core" rel="noopener ugc nofollow" target="_blank">@babel/core</a> <a class="ae ld" href="http://twitter.com/babel/plugin-proposal-object-re" rel="noopener ugc nofollow" target="_blank">@babel/plugin-proposal-object-re</a>st-spread <a class="ae ld" href="http://twitter.com/babel/plugin-syntax-dynamic-imp" rel="noopener ugc nofollow" target="_blank">@babel/plugin-syntax-dynamic-imp</a>ort <a class="ae ld" href="http://twitter.com/babel/preset-env" rel="noopener ugc nofollow" target="_blank">@babel/preset-env</a> <a class="ae ld" href="http://twitter.com/babel/preset-react" rel="noopener ugc nofollow" target="_blank">@babel/preset-react</a> babel-loader</span></pre><p id="463e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来，按照这个命令安装Webpack的依赖项。</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="438c" class="ms lm it mr b gy nm nn l no np">npm install --save-dev webpack webpack-cli webpack-dev-server clean-webpack-plugin css-loader html-loader style-loader vue-loader vue-template-compiler</span></pre><h2 id="3da9" class="ms lm it bd ln mt mu dn lr mv mw dp lv kq mx my lz ku mz na md ky nb nc mh nd bi translated">配置巴别塔</h2><p id="6141" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">为了配置Babel，让我们在同一个目录中创建一个<code class="fe mo mp mq mr b">.babelrc</code>,然后粘贴这段代码。基本上这段代码片段指示Babel使用某些预设和插件。还有其他几个插件可用。一定要在巴别塔的网站上查看同样的内容。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="8a30" class="ms lm it bd ln mt mu dn lr mv mw dp lv kq mx my lz ku mz na md ky nb nc mh nd bi translated">配置Webpack</h2><p id="1ba7" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">像Babel一样，我们需要另一个名为<code class="fe mo mp mq mr b">webpack.config.js</code>的配置文件。这里我们提到了什么是模式，Webpack要查看的入口点，要捆绑的输出目录，以及在那里创建文件。我们还指定了加载器，以便解析<code class="fe mo mp mq mr b">.css</code>文件、<code class="fe mo mp mq mr b">.js</code>文件和<code class="fe mo mp mq mr b">.vue</code>文件。插件在这里用于Vue，并在每次构建时清理Webpack。此外，我们使用<code class="fe mo mp mq mr b">source-map</code> Devtool进行调试和<code class="fe mo mp mq mr b">devServer</code>配置，这样我们就可以启动一个开发服务器来监视Webpack中的变化。我们的文件应该如下所示:</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d447" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如上所述，我们已经提到文件的入口点是<code class="fe mo mp mq mr b">singleSPA.config.js</code>。让我们创建这个文件。</p><h2 id="3914" class="ms lm it bd ln mt mu dn lr mv mw dp lv kq mx my lz ku mz na md ky nb nc mh nd bi translated">配置单个SPA</h2><p id="5e9a" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">让我们从这个文件的<code class="fe mo mp mq mr b">single-spa</code>包中导入<code class="fe mo mp mq mr b">start</code>函数，并在文件末尾调用start函数。一旦我们开始编写组件，我们将回到这个文件。</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="a826" class="ms lm it mr b gy nm nn l no np">import { start } from 'single-spa'</span><span id="28e1" class="ms lm it mr b gy ns nn l no np">start()</span></pre><h2 id="eb4a" class="ms lm it bd ln mt mu dn lr mv mw dp lv kq mx my lz ku mz na md ky nb nc mh nd bi translated">创建存储文件</h2><p id="e2fd" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">如前所述，在单个SPA中，我们可以使用DOM/任何全局对象在组件内进行通信。因此，让我们利用窗口对象在组件之间进行通信。让我们在同一个目录下创建一个新文件<code class="fe mo mp mq mr b">store.js</code>并粘贴这段代码。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2540" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这段代码是不言自明的。我们有一个增量函数、一个减量函数和一个计数器变量来访问这个值。当我们调用这些方法时，我们也在调度事件。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="3d76" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">创建组件</h1><p id="b47c" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">到目前为止，我们已经完成了应用程序的配置，现在让我们创建三个不同的组件。首先，让我们创建一个名为<code class="fe mo mp mq mr b">components</code>的目录。让我们在组件中创建三个目录，即<code class="fe mo mp mq mr b">react</code>、<code class="fe mo mp mq mr b">vue</code>和<code class="fe mo mp mq mr b">vanillajs</code>。</p><h2 id="9d75" class="ms lm it bd ln mt mu dn lr mv mw dp lv kq mx my lz ku mz na md ky nb nc mh nd bi translated">创建反应组件</h2><p id="0e98" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">让我们创建一个简单的功能组件<code class="fe mo mp mq mr b">App.js</code>，它呈现来自React的消息、计数器的当前值和两个递增和递减按钮。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0757" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，既然我们的应用程序已经创建，让我们看看如何使用单个SPA来配置它。让我们创建主<code class="fe mo mp mq mr b">index.js</code>文件。在这个文件中，我们需要调用从<code class="fe mo mp mq mr b">single-spa-react</code>包导出的函数，用一个对象作为由<code class="fe mo mp mq mr b">React</code>、<code class="fe mo mp mq mr b">ReactDOM</code>、<code class="fe mo mp mq mr b">rootComponent</code>组成的参数，以及一个附加的<code class="fe mo mp mq mr b">domElementGetter</code>函数。最后，我们需要导出创建的实例的三个属性:<code class="fe mo mp mq mr b">bootstrap</code>、<code class="fe mo mp mq mr b">mount</code>和<code class="fe mo mp mq mr b">unmount</code>。这是单spa中常用的模式。我们的<code class="fe mo mp mq mr b">index.js</code>文件应该是这样的:</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="b3a1" class="ms lm it bd ln mt mu dn lr mv mw dp lv kq mx my lz ku mz na md ky nb nc mh nd bi translated">创建Vue组件</h2><p id="b0b4" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">类似地，在我们的<code class="fe mo mp mq mr b">vue</code>目录中，让我们创建一个<code class="fe mo mp mq mr b">index.js</code>文件和一个<code class="fe mo mp mq mr b">App.js</code>。我们将实现几乎相同的功能，但使用Vue。所以我就跳过解释，附上下面的代码片段。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="9f14" class="ms lm it bd ln mt mu dn lr mv mw dp lv kq mx my lz ku mz na md ky nb nc mh nd bi translated">创建普通的JS组件</h2><p id="3145" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">正如官方<a class="ae ld" href="https://single-spa.js.org/docs/ecosystem-html-web-components" rel="noopener ugc nofollow" target="_blank">文档</a>中提到的，我们将利用<code class="fe mo mp mq mr b">single-spa-html</code>通过传递包含HTML片段的模板来创建一个实例。我们还将修改<code class="fe mo mp mq mr b">mount</code>函数，这样一旦创建了HTML元素，我们就可以使用绑定了。所以让我们在<code class="fe mo mp mq mr b">vanillajs</code>目录下的<code class="fe mo mp mq mr b">index.js</code>文件中创建所有内容。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8e36" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">差不多就是这样。现在只剩下几步了。我们需要在我们的<code class="fe mo mp mq mr b">singleSPA.config.js</code>文件中注册这些导出的组件，最后在我们的<code class="fe mo mp mq mr b">package.json</code>中添加一些脚本来启动并运行服务器。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="02cf" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">将组件注册到SPA配置</h1><p id="9a55" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">这是我们注册组件的主要步骤之一，只有到那时单个SPA才会知道。有一种叫做<code class="fe mo mp mq mr b">registerApplication</code>的方法是单个SPA提供的。它基本上接受三个参数。首先是应用的名称(这里React、Vue、Native JS被认为是三个不同的应用)。第二个参数是应用程序或加载函数，这意味着每个应用程序的启动(<code class="fe mo mp mq mr b">index.js</code>)文件。最后一个强制参数是activity函数，它告诉single SPA何时呈现该应用程序。通常我们提供路径(URL ),基于它我们可以告诉单个SPA何时渲染它。下面是我们的文件经过这些更改后的样子:</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="aae8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在你可能想知道它在浏览器中是如何呈现的。我们还没有做那么一点点。所以让我们把事情做完。基本上，我们需要一个<code class="fe mo mp mq mr b">index.html</code>文件和某些容器，以便内容在其中准确显示。我们将把这个<code class="fe mo mp mq mr b">index.html</code>文件放在我们的主根目录中，并且有一些<code class="fe mo mp mq mr b">div</code>容器，这些容器带有我们在注册时给应用程序命名的值的id，即<code class="fe mo mp mq mr b">vue</code>、<code class="fe mo mp mq mr b">react</code>、<code class="fe mo mp mq mr b">vanillajs</code>。我们的<code class="fe mo mp mq mr b">index.html</code>应该是这样的:</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="9e54" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，我们还包括了<code class="fe mo mp mq mr b">singleSPA.config.js</code>文件。注意，我们在它之前指定了一个目录<code class="fe mo mp mq mr b">dist</code>。这是因为我们在webpack配置文件中将<code class="fe mo mp mq mr b">dist</code>指定为输出目录。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="9605" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">运行我们的服务器</h1><p id="e1fb" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">最后一步，在我们的<code class="fe mo mp mq mr b">package.json</code>文件中添加两个脚本。一个是运行webpack dev服务器，另一个是将文件构建到一个目录中。我们最终的<code class="fe mo mp mq mr b">package.json</code>文件应该是这样的:</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7232" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">唷，就这样。现在，让我们通过运行以下命令来测试我们的应用程序:</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="6e8e" class="ms lm it mr b gy nm nn l no np">npm start</span></pre><p id="f545" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后，导航至<code class="fe mo mp mq mr b">localhost:8080</code>。你可以在主页上找到这三款应用。尝试使用递增/递减按钮，你会发现计数器值在每个应用程序中都会更新。另外，尝试导航到<code class="fe mo mp mq mr b">localhost:8080/react</code>以仅显示React应用程序，<code class="fe mo mp mq mr b">/vue</code>以仅显示vue应用程序，最后<code class="fe mo mp mq mr b">/vanillajs</code>以仅显示Vanilla JS组件。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/73fb61ade2fed6c345bb363e387a9647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kQfxY3Og9c4AOFIf0ULcFg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">包含3个不同组件的主页</p></figure><p id="1025" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下面是一个截图，只显示了一个应用程序。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/257f2bda9a8cf3daab7d89e127f2ffb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vvhDY2by7dsEaPICUqbIiA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">单一SPA仅渲染React应用程序</p></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="0308" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">最后的想法</h1><p id="b26e" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">我们已经看到了如何使用单个SPA来实现微前端。单个SPA支持几种不同的生态系统，如Angular、Ember、Preact等等。如果你有兴趣了解更多，请参考他们的<a class="ae ld" href="https://single-spa.js.org/docs/getting-started-overview" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="64c0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> Git回购</strong>——【https://github.com/harshaktg/microfrontends-single-spa】T4</p><p id="1804" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">现场演示</strong>——<a class="ae ld" href="https://microfrontends-single-spa.netlify.app/" rel="noopener ugc nofollow" target="_blank">https://microfrontends-single-spa.netlify.app/</a></p><p id="e1fa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我希望这篇文章是有帮助的。感谢您的阅读！</p></div></div>    
</body>
</html>