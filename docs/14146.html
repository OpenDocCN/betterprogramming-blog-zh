<html>
<head>
<title>Implement Real-Time Filtering With CIFilter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用CIFilter实现实时过滤</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/real-time-filtering-with-cifilter-bf7af16aee04?source=collection_archive---------8-----------------------#2022-11-10">https://betterprogramming.pub/real-time-filtering-with-cifilter-bf7af16aee04?source=collection_archive---------8-----------------------#2022-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f78d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在AVFoundation上执行核心图像过滤</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b5e7a84b7dfdbc192a5ac68628e0f79e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZVEfb5zZ78KZWDri"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@habibdadkhah?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">哈比卜·达德哈</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="181f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的<a class="ae kv" href="https://medium.com/@sonmezbahad/creating-a-custom-filter-with-cifilter-3e5a6445ec15" rel="noopener">上一篇文章</a>中，我谈到了用<code class="fe ls lt lu lv b">CIFilter</code>创建一个自定义过滤器。在本文中，我将讨论如何使用<code class="fe ls lt lu lv b">CIFilter</code>过滤器进行实时过滤。应用程序需要摄像机使用和摄像机使用许可才能工作。确保您在<code class="fe ls lt lu lv b">Info.plist</code>中请求了隐私-相机使用描述许可。</p><p id="ff03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们创建一个名为<code class="fe ls lt lu lv b">CameraCapture</code>的类来处理和传输相机捕获的图像。这个类用一个摄像机位置和一个<code class="fe ls lt lu lv b">callback</code>闭包初始化。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="6397" class="ma mb iq lv b be mc md l me mf">typealias Callback = (CIImage?) -&gt; ()<br/>private let position: AVCaptureDevice.Position<br/>private let callback: Callback<br/>init(position: AVCaptureDevice.Position = .front, callback: @escaping Callback) {<br/>  self.position = position<br/>  self.callback = callback<br/>  super.init()<br/>}</span></pre><p id="60d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在类中定义一个<code class="fe ls lt lu lv b">AVCaptureSession</code>和一个用户启动的<code class="fe ls lt lu lv b">DispatchQueue</code>。定义<code class="fe ls lt lu lv b">userInitiated</code>很重要，因为它会一直出现在UI中。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="e1d5" class="ma mb iq lv b be mc md l me mf">private let session = AVCaptureSession()<br/>private let bufferQueue = DispatchQueue(label: "someLabel", qos: .userInitiated)</span></pre><p id="8b96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编写两个公共函数来启动和结束会话，因为会话是私有的。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="d000" class="ma mb iq lv b be mc md l me mf">func start() {<br/>  session.startRunning()<br/>}</span></pre><pre class="mg lw lv lx bn ly lz bi"><span id="3650" class="ma mb iq lv b be mc md l me mf">func stop() {<br/>  session.stopRunning()<br/>}</span></pre><p id="77ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为会话配置创建一个函数，并在<code class="fe ls lt lu lv b">super.init()</code>后调用它。为了处理摄像机捕获的图像，<code class="fe ls lt lu lv b">CameraCapture</code>必须符合<code class="fe ls lt lu lv b">AVCaptureVideoDataOutputSampleBufferDelegate</code>协议。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="43a5" class="ma mb iq lv b be mc md l me mf">private func configureSession() {<br/>// 1<br/>session.sessionPreset = .hd1280x720<br/>// 2<br/>let discovery = AVCaptureDevice.DiscoverySession(deviceTypes: [.builtInDualCamera, .builtInWideAngleCamera], mediaType: .video, position: position)<br/>guard let camera = discovery.devices.first, let input = try? AVCaptureDeviceInput(device: camera) else {<br/>// Error handling<br/>return<br/>}<br/>session.addInput(input)<br/>// 3<br/>let output = AVCaptureVideoDataOutput()<br/>output.setSampleBufferDelegate(self, queue: bufferQueue)<br/>session.addOutput(output)<br/>}</span></pre><p id="1814" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们一步一步地看看函数内部是什么。</p><p id="c7a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">1.确定图像质量。<br/> 2。用<code class="fe ls lt lu lv b">AVCaptureDevice.DiscoverySession</code>找到并配置合适的视频采集元件，用<code class="fe ls lt lu lv b">AVCaptureDeviceInput</code> <br/> 3创建采集输入。用<code class="fe ls lt lu lv b">AVCaptureVideoDataOutput</code>创建输出，并将委托添加到类中</p><p id="fd26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">捕获的图像需要转换到<code class="fe ls lt lu lv b">CIImage</code>并输入到<code class="fe ls lt lu lv b">callback</code>闭合中。为此编写符合<code class="fe ls lt lu lv b">AVCaptureVideoDataOutputSampleBufferDelegate</code>的<code class="fe ls lt lu lv b">CameraCapture</code>扩展。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="082c" class="ma mb iq lv b be mc md l me mf">extension CameraCapture:AVCaptureVideoDataOutputSampleBufferDelegate {<br/>  func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) {<br/>    guard let imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer) else { return }<br/>    DispatchQueue.main.async {<br/>      let image = CIImage(cvImageBuffer: imageBuffer)<br/>      self.callback(image.transformed(by: CGAffineTransform(rotationAngle: 3 * .pi / 2)))<br/>    }<br/>  }<br/>}</span></pre><p id="da73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用委托函数中的<code class="fe ls lt lu lv b">sampleBuffer</code>创建一个<code class="fe ls lt lu lv b">CIImage</code>，并将其传递给<code class="fe ls lt lu lv b">callback</code>。由于传入的图像是侧向的，因此有必要将其旋转270度。结果，创建了下面的类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="e8df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在没有任何问题地创建了<code class="fe ls lt lu lv b">CameraCapture</code>类之后，就可以使用这个类进行过滤了。用<code class="fe ls lt lu lv b">UIImageView</code>和<code class="fe ls lt lu lv b">CameraCapture</code>实例创建一个<code class="fe ls lt lu lv b">ViewController</code>。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="796b" class="ma mb iq lv b be mc md l me mf">class RealtimeFilterViewController: UIViewController {<br/>  var imageView: UIImageView!<br/>  var cameraCapture: CICameraCapture?<br/>  override func viewDidLoad() {<br/>    super.viewDidLoad()<br/>    imageView = UIImageView(frame: view.bounds)<br/>    view.addSubview(imageView)<br/>    cameraCapture = CICameraCapture(cameraPosition: .front, callback: { image in })<br/>    cameraCapture?.start()<br/>  }<br/>}</span></pre><p id="b116" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在是时候过滤并显示来自<code class="fe ls lt lu lv b">callback</code>的图像了。选择并应用任何内置过滤器。我们来选择<code class="fe ls lt lu lv b">xRay</code>滤镜。在<code class="fe ls lt lu lv b">callback</code>封闭内进行过滤。最后，<code class="fe ls lt lu lv b">cameraCapture</code>看起来是这样的:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="ccc0" class="ma mb iq lv b be mc md l me mf">cameraCapture = CICameraCapture(cameraPosition: .front, callback: { image in<br/>  guard let image = image else { return }<br/>  let filter = CIFilter.xRay()<br/>  filter.setDefaults()<br/>  filter.inputImage = image<br/>  let uiImage = UIImage(ciImage: (filter.outputImage!.cropped(to: image.extent)))<br/>  self.imageView.image = uiImage<br/>})</span></pre><p id="3464" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们这样运行它。但那是什么？什么都不会出现，并且控制台会不断记录一条消息。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="dd6b" class="ma mb iq lv b be mc md l me mf">2022-11-08 15:06:14.829234+0300 RealtimeFiltering[2903:883376] [api] -[CIContext(CIRenderDestination) _startTaskToRender:toDestination:forPrepareRender:forClear:error:] The image extent and destination extent do not intersect.</span></pre><p id="9729" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个信息非常清楚。图像范围和目标范围不相交。我们应该定义一个函数来将图像转换和缩放到我们的视图范围内。创建一个扩展并使用此功能:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="48eb" class="ma mb iq lv b be mc md l me mf">import CoreImage<br/>extension CIImage {<br/>  func transformToOrigin(withSize size: CGSize) -&gt; CIImage {<br/>    let originX = extent.origin.x<br/>    let originY = extent.origin.y<br/>    let scaleX = size.width / extent.width<br/>    let scaleY = size.height / extent.height<br/>    let scale = max(scaleX, scaleY)<br/>    return transformed(by: CGAffineTransform(translationX: -originX, y: -originY)).transformed(by: CGAffineTransform(scaleX: scale, y: scale))<br/>  }<br/>}</span></pre><p id="9dcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们用这个函数来定义<code class="fe ls lt lu lv b">uiImage</code>，然后嘭！我们已经创建了一个有效的实时过滤应用程序。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="e40c" class="ma mb iq lv b be mc md l me mf">let uiImage = UIImage(ciImage: (filter.outputImage!.cropped(to: image.extent).transformToOrigin(withSize: self.view.bounds.size)))</span></pre><p id="35b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，<code class="fe ls lt lu lv b"><em class="mj">RealtimeFilterViewController</em></code>应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="8e65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它非常适合一个简单的过滤器。输出图像如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/5e74b68d99b41bf3f459bf26c76218c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rjy09uYhixC9OweU1YcLWg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">输入图像→输出图像</p></figure><p id="2c15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果几个滤镜作为一个链条呢？让我们试一试。像这样改变<code class="fe ls lt lu lv b">cameraCapture</code>的定义:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="c0f6" class="ma mb iq lv b be mc md l me mf">cameraCapture = CICameraCapture(cameraPosition: .front, callback: { image in<br/>  guard let image = image else { return }<br/>  let filter = CIFilter.thermal()<br/>  let filter2 = CIFilter.xRay()<br/>  let filter3 = CIFilter.motionBlur()<br/>  filter.setDefaults()<br/>  filter2.setDefaults()<br/>  filter3.setDefaults()<br/>  filter.inputImage = image<br/>  filter2.inputImage = filter.outputImage!<br/>  filter3.inputImage = filter2.outputImage!<br/>  let uiImage = UIImage(ciImage: (filter3.outputImage!.cropped(to: image.extent).transformToOrigin(withSize: self.view.bounds.size)))<br/>  self.imageView.image = uiImage<br/>})</span></pre><p id="e1ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它仍然工作，但是当查看资源消耗时，它看起来就像是在消耗。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/911239589ad2e112ccfdffa9ab8ea053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*gVamaCwNt0DEFwtLepHh5w.png"/></div></figure><p id="7119" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方式一点效率都没有。那么，该怎么办呢？幸运的是，苹果意识到了这一点，并提供了一种更高效的方式。是<code class="fe ls lt lu lv b">MTKView</code>。创建一个继承了<code class="fe ls lt lu lv b">MTKView</code>的名为<code class="fe ls lt lu lv b">MetalRenderView</code>的类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="44a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果设备不支持Metal框架，应用程序将会崩溃。<code class="fe ls lt lu lv b">MetalRenderView</code>最重要的部分是<code class="fe ls lt lu lv b">renderImage</code>功能。分配图像时调用该函数，使图像适用于<code class="fe ls lt lu lv b">MTKView</code>。更多信息，可以使用苹果的<a class="ae kv" href="https://developer.apple.com/documentation/metalkit/mtkview" rel="noopener ugc nofollow" target="_blank">文档<code class="fe ls lt lu lv b">MTKView</code>的</a>。</p><p id="8476" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们在这个<code class="fe ls lt lu lv b">MetalRenderView</code>的帮助下展示过滤后的图像。首先，让我们将<code class="fe ls lt lu lv b">RealtimeFilterViewController</code>中的<code class="fe ls lt lu lv b">imageView</code>替换为<code class="fe ls lt lu lv b">MetalRenderView</code>。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="3c4d" class="ma mb iq lv b be mc md l me mf">var metalView: MetalRenderView!</span></pre><p id="62f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其次，替换<code class="fe ls lt lu lv b">viewDidLoad</code>中的<em class="mj">的以下块:</em></p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="6549" class="ma mb iq lv b be mc md l me mf">imageView = UIImageView(frame: view.bounds)<br/>view.addSubview(imageView)</span></pre><p id="7c6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…有了这个</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="a387" class="ma mb iq lv b be mc md l me mf">metalView = MetalRenderView(frame: view.bounds, device: MTLCreateSystemDefaultDevice())<br/>view.addSubview(metalView)</span></pre><p id="3290" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后更换<code class="fe ls lt lu lv b"><em class="mj">callback</em></code>封口内的这两条线</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="9642" class="ma mb iq lv b be mc md l me mf">let uiImage = UIImage(ciImage: (filter3.outputImage!.cropped(to: image.extent).transformToOrigin(withSize: self.view.bounds.size)))<br/>self.imageView.image = uiImage</span></pre><p id="1537" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与这个</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="45e2" class="ma mb iq lv b be mc md l me mf">self.metalView.setImage(filter3.outputImage?.cropped(to: image.extent))</span></pre><p id="9f5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">MetalRenderView</code>独立处理<code class="fe ls lt lu lv b">transformToOrigin</code>方法。现在，<code class="fe ls lt lu lv b">RealtimeFilterViewController</code>应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="e2fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们再次运行应用程序，看看有什么不同。看起来稍微好一点。但是，当过滤器的数量增加或使用更困难的过滤器时，这种细微的差别会更有价值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/4225d1c45b1d8d289f41f12ae5067421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*NotEAuYg0SkN4aQgN8g5Nw.png"/></div></figure><p id="2664" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，我们现在有了一个完全正常工作且更高效的实时过滤应用程序。可以使用不同的过滤器和不同的UI增强来开发应用程序。这款应用也许可以拍照，但那是另一篇文章的主题。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="403c" class="ma mb iq lv b be mc md l mu mf">Want to Connect?<br/><br/>Linkedin: https://www.linkedin.com/in/bahadir-sonmez-itu/<br/>Website: https://bahadirsonmez.github.io/</span></pre></div></div>    
</body>
</html>