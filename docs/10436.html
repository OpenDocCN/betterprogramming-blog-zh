<html>
<head>
<title>Quickly Extract Links From a Webpage With This Streamlit App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用这个Streamlit应用程序从网页中快速提取链接</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/quickly-extract-links-from-a-webpage-with-this-streamlit-app-fcb5a548c58?source=collection_archive---------13-----------------------#2022-01-06">https://betterprogramming.pub/quickly-extract-links-from-a-webpage-with-this-streamlit-app-fcb5a548c58?source=collection_archive---------13-----------------------#2022-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3cd8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python异步函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/38cc9c78620db40e4e78e87692d3bb6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bLExmCqpPJEeUGmi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@bel2000a?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">贝琳达·费因斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e4e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TL；DR:提取链接的app这里是<a class="ae ky" href="https://streamlit-file-extractor.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">这里是</a></p><p id="e123" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe lv lw lx ly b">wget</code>和一个输入文件下载文件干净而直观:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b676" class="md me it ly b gy mf mg l mh mi">wget -i file-list.txt</span></pre><p id="a5f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，<code class="fe lv lw lx ly b">file-list.txt</code>包含要下载的URL列表</p><p id="92d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当我们拥有的只是一个包含子目录链接的网页时，创建这个列表并不明显(例如<a class="ae ky" href="https://www.ncei.noaa.gov/data/sea-surface-temperature-optimum-interpolation/v2.1/access/avhrr/" rel="noopener ugc nofollow" target="_blank"> this </a>，网页)。</p><p id="c870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将解释如何使用Python和异步函数创建一个快速的链接提取器。为了方便使用，我将这段代码转换成部署在<a class="ae ky" href="https://heroku.com/" rel="noopener ugc nofollow" target="_blank"> Heroku </a>上的网络应用。此处有app<a class="ae ky" href="https://streamlit-file-extractor.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/ad242aacaeb94801992466086637f04b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sR7lvFX37wRFTUJN-h1wjQ@2x.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://streamlit-file-extractor.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://streamlit-file-extractor.herokuapp.com/</a>可用的链接提取器应用截图(图片由作者提供)</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="25f1" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">程序如何工作</h1><p id="21ee" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">下面是程序的伪代码。</p><ol class=""><li id="bb33" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">创建一个空列表来存储所有链接</li><li id="039f" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">从网页获取HTML</li><li id="f4a4" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">解析HTML中的<code class="fe lv lw lx ly b">&lt;a&gt;</code>标签并提取<code class="fe lv lw lx ly b">href</code>属性</li><li id="ac07" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">如果链接包含正则表达式，则将链接追加到空的</li><li id="b759" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">如果<code class="fe lv lw lx ly b">href</code>指向子目录，则重复步骤2-4</li></ol><p id="df4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了显著提高速度，一些功能通过<code class="fe lv lw lx ly b">asyncio</code>和<code class="fe lv lw lx ly b">aiohttp</code>封装实现异步。加快程序运行速度的原因是，当我们在步骤2中等待从网页获取HTML时，我们可以继续做一些工作。当搜索子目录时，可以实现显著的加速。</p><p id="f2e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们接收到HTML，<code class="fe lv lw lx ly b">BeautifulSoup</code>和<code class="fe lv lw lx ly b">lxml</code>就会帮助解析它。正则表达式用于通过<code class="fe lv lw lx ly b">regex</code>过滤结果，内置<code class="fe lv lw lx ly b">itertools</code>库中的<code class="fe lv lw lx ly b">chain</code>用于将列表“链接”在一起。</p><p id="f8b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是完整的进口清单(不包括<code class="fe lv lw lx ly b">Streamlit</code>)。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="93cf" class="md me it ly b gy mf mg l mh mi">from bs4 import BeautifulSoup<br/>from itertools import chain<br/>import asyncio<br/>import aiohttp<br/>import lxml<br/>import re</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="b608" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">这些功能</h1><p id="f245" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">为了保持代码简洁，我把它分成了五个函数:<code class="fe lv lw lx ly b">format_base_url()</code>、<code class="fe lv lw lx ly b">get_html_async()</code>、<code class="fe lv lw lx ly b">get_links()</code>、<code class="fe lv lw lx ly b">get_sub_dirs()</code>和<code class="fe lv lw lx ly b">get_files()</code></p><p id="efea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些函数然后被串在一起创建最终的<code class="fe lv lw lx ly b">main()</code>程序。在这里，我将讨论每个函数是如何工作的。</p><h2 id="745e" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">格式_基本_url()</h2><p id="3b5c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这个函数只是确保用户输入的URL以<code class="fe lv lw lx ly b">http://</code>或<code class="fe lv lw lx ly b">https://</code>开头，以“/”结尾，然后返回重新格式化的URL。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="470a" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">get_html_async()</h2><p id="eac9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe lv lw lx ly b">aiohttp</code>允许我们进行异步HTTP请求。为此，我们首先通过上下文管理器打开一个<code class="fe lv lw lx ly b">.ClientSession()</code>，然后发出一个<code class="fe lv lw lx ly b">get</code>请求。通过<code class="fe lv lw lx ly b">.text()</code>访问响应(或本例中的HTML)。但是，为了确保我们正在访问的URL确实存在，我检查了状态代码“OK”(<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" rel="noopener ugc nofollow" target="_blank">状态代码200 </a>)。如果后者被确认，那么HTML将被返回。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="4cbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不打算详细介绍异步编程，只是说在<code class="fe lv lw lx ly b">def</code>告诉Python这个函数是一个协程之前<code class="fe lv lw lx ly b">async</code>和<code class="fe lv lw lx ly b">await</code>告诉Python我们需要等待结果。</p><h2 id="f1f2" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">get_links()</h2><p id="6cce" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">检索到的HTML被传递给<code class="fe lv lw lx ly b">get_links</code>函数进行解析。我们首先使用<code class="fe lv lw lx ly b">lxml</code>解析器创建一个<code class="fe lv lw lx ly b">BeautifulSoup()</code>对象，它应该比 <code class="fe lv lw lx ly b"><a class="ae ky" href="https://medium.com/geekculture/how-to-make-webscraping-with-beautiful-soup-5x-faster-d3dcf0427837" rel="noopener">html.parser</a></code>快<a class="ae ky" href="https://medium.com/geekculture/how-to-make-webscraping-with-beautiful-soup-5x-faster-d3dcf0427837" rel="noopener">。使用这个对象，我们找到所有的<code class="fe lv lw lx ly b">&lt;a&gt;</code>标签，然后在里面得到<code class="fe lv lw lx ly b">href </code>。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="5f58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，正则表达式查找任何内容或末尾的“/”。</p><p id="ee8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将返回HTML中的所有链接。现在我们需要将文件从子目录中分离出来。</p><h2 id="7e49" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">获取_订阅_目录()</h2><p id="dae4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">从提取的链接中，我们将简单地通过搜索末尾的“/”来分离出子目录，并使用列表理解来存储它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="beaa" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">获取文件()</h2><p id="d85c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">为了获取文件，我们将保留所有符合指定正则表达式的链接。如果没有指定正则表达式，则程序会查找没有结尾“/”的链接。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="ae43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正则表达式允许您非常具体地指定想要返回的文件类型。如果你需要复习，我强烈推荐科里·斯查费在YouTube上的视频。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo on l"/></div></figure><h2 id="209b" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">主()</h2><p id="c050" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe lv lw lx ly b">main()</code>函数只是按照逻辑顺序将所有函数串在一起。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="ea16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很清楚上半部分在做什么。这将获取在基本URL中找到的文件，并将它们添加到主文件列表中。</p><p id="c35b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来的代码处理子目录，这是<code class="fe lv lw lx ly b">asyncio</code>的亮点。</p><p id="bc2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先通过将<code class="fe lv lw lx ly b">sub_dirs</code>中的每个子目录传递给<code class="fe lv lw lx ly b">main()</code>函数来创建一个协程列表。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="dd24" class="md me it ly b gy mf mg l mh mi">coros = [main(sub) for sub in sub_dirs]</span></pre><p id="299a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们通过将这些函数传递给<code class="fe lv lw lx ly b">asyncio.gather()</code>来同时运行所有这些函数<em class="op"/>。这很快，因为我们不必等待每个任务完成后再开始下一个任务。这将返回<code class="fe lv lw lx ly b">new_files</code>，这是一个列表列表。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4b2d" class="md me it ly b gy mf mg l mh mi">new_files = await asyncio.gather(*coros)</span></pre><p id="abed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们想要的是一个单一的列表，这就是<code class="fe lv lw lx ly b">chain</code>派上用场的地方。该链表然后被添加到主<code class="fe lv lw lx ly b">files</code>列表中。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="57fc" class="md me it ly b gy mf mg l mh mi">files.extend(chain(*new_files))</span></pre><p id="8002" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，您可能希望在每个文件前面加上<code class="fe lv lw lx ly b">base_url</code>。这是通过列表理解来实现的。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="2fd7" class="md me it ly b gy mf mg l mh mi">if prepend_base_url:<br/>    files = [base_url + file for file in files]</span></pre><h2 id="8532" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">运行程序</h2><p id="96c8" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe lv lw lx ly b">main()</code>程序实际上是一个协同程序，注意开头的异步。要运行协程，我们需要使用<code class="fe lv lw lx ly b">asyncio.run()</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="cde8" class="md me it ly b gy mf mg l mh mi">base_url='https://example.com/<br/>files = asyncio.run(main(base_url, regex='.'))</span></pre><p id="bc9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">厉害！我们有一个从网页中提取链接的程序！</p><p id="de4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用Streamlit给它增加一点趣味，给它一个闪亮的用户界面。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="807f" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">创建Streamlit应用程序</h1><p id="4223" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Streamlit 是一个库，允许你快速地将你的代码转换成一个网络应用。我们只需要添加几行代码，将一些输入连接到UI小部件。首先，您需要导入streamlit。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6dd3" class="md me it ly b gy mf mg l mh mi">import streamlit as st</span></pre><p id="600e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是制作web应用程序的代码。请记住，您需要包含<code class="fe lv lw lx ly b">format_base_url()</code>、<code class="fe lv lw lx ly b">get_html()</code>、<code class="fe lv lw lx ly b">get_links()</code>、<code class="fe lv lw lx ly b">get_sub_dirs()</code>、<code class="fe lv lw lx ly b">get_files()</code>和<code class="fe lv lw lx ly b"> main()</code>的代码，这样代码才会起作用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="b0df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对这段代码的完整描述超出了本文的范围。将链接提取器变成web应用程序的秘密是将主函数中的每个输入链接到一个<a class="ae ky" href="https://docs.streamlit.io/library/api-reference/widgets" rel="noopener ugc nofollow" target="_blank">输入小部件</a>。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5402" class="md me it ly b gy mf mg l mh mi">search_subs = st.checkbox('Search sub-directories', value=False)       <br/>prepend_base = st.checkbox('Append base URL', value=True)<br/>custom_regex = st.text_input('Filter results by regex', '.')<br/>base_url = st.text_input(label='Extract links from URL')</span></pre><p id="5dd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论用户选择什么，都会传递给main函数，生成的文件会显示在屏幕上。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6598" class="md me it ly b gy mf mg l mh mi">asyncio.run(main(base_url=base_url, <br/>                 search_subs=search_subs,<br/>                 prepend_base_url=prepend_base,<br/>                 regex=custom_regex))</span></pre><p id="0f58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Streamlit应用程序的完整代码可从<a class="ae ky" href="https://github.com/lgloege/streamlit-link-extractor" rel="noopener ugc nofollow" target="_blank">这里</a>获得</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="38ad" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="7a9b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这个应用证明了我从网页中收集链接的努力，特别是那些有多个子目录的网页，如<a class="ae ky" href="https://psl.noaa.gov/data/gridded/data.noaa.oisst.v2.highres.html" rel="noopener ugc nofollow" target="_blank"> NOAA-OI SSTv2高分辨率数据集</a>。</p><p id="0c2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能让你对自己的项目有所启发。如果你觉得链接提取有用，请让我知道。可能已经有这样的应用了，但是我自己也学到了很多。它迫使我深入到像异步编程和简化会话状态这样的高级主题中。我惊讶地发现，仅仅通过将代码改为异步就节省了时间。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="7721" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>