<html>
<head>
<title>Create a Serverless Rust Function for Fast Experience</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建无服务器的Rust功能以获得快速体验</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rust-for-the-fastest-serverless-experience-80530acdd4d4?source=collection_archive---------6-----------------------#2022-08-04">https://betterprogramming.pub/rust-for-the-fastest-serverless-experience-80530acdd4d4?source=collection_archive---------6-----------------------#2022-08-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8f10" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">WASM再次施展魔法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5621902a9ff58e7cfc18061ffd74b63d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EKHS1NDfka4icx_U"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">瑞安·贝克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a0a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现无服务器令人惊叹:开发的速度、多功能性和简易性令人难以置信。如果你读了我关于部署你的第一个JS无服务器worker 的最新故事，你已经知道我正在使用Cloudflare workers作为我的画布来构建我想要通过URL访问的函数和API。</p><p id="5ce9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Cloudflare workers在chrome V8隔离中运行，这些隔离在Cloudflare的全球网络中找到它们的运行时，这意味着您的无服务器功能在支持和运行其他隔离的运行时中安全运行(在这里，您会发现Cloudflare workers的效率)。</p><p id="da96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从标题和副标题就能猜到，CF工人原生支持Rust，这要感谢WebAssembly。这项技术允许在浏览器上执行C和Rust等语言(请记住，工作人员是在chrome V8运行时上运行的)，从而为Cloudflare开发团队提供了一个环境，让他们的工作人员使用Rust进行编写，并享受该语言的安全性和效率(在速度和开发工作方面)。</p><p id="8816" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来看看如何使用Rust创建我们的第一个无服务器函数，并像使用JS一样部署它(我建议也阅读<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/create-and-deploy-your-first-javascript-serverless-worker-e234f3f69cea?source=your_stories_page-------------------------------------">这篇文章</a>，以便更熟悉如果Rust不是您最常用的语言，我们在做什么)。</p><h1 id="2878" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置</h1><p id="730c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">就像JS cf workers一样，我们将使用<code class="fe ms mt mu mv b">wrangler</code>，我们将使用它来测试和发布我们的功能(并且不仅仅是)。如果您还没有安装，请继续安装<code class="fe ms mt mu mv b">npm install -g wrangler</code>。</p><p id="2819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与JavaScript不同，我们将从模板开始。要加载模板，请输入您的终端并键入:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="bce8" class="na lw it mv b gy nb nc l nd ne">npm init cloudflare serverlessworker worker-rust</span></pre><p id="d037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你进入<code class="fe ms mt mu mv b">serverlessworker</code>目录，你就可以用牧马人的<code class="fe ms mt mu mv b">wrangler dev</code>测试这个模板(第一次安装<code class="fe ms mt mu mv b">worker-build</code>需要几分钟)。您现在可以看到该工人在本地接受服务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/100d765a9d805bf41f0a01abdeb3d3f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*swSRtT3yn3inr-bJpUCkrg.png"/></div></figure><p id="a964" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们工人的根是<code class="fe ms mt mu mv b">serverlessworker/src/lib.rs</code>文件。如果打开它，您会注意到总体的worker语法与js实现没有太大的不同。</p><p id="7027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在fetch事件发生时(正如我们在本文的第一段中所讨论的)，路由器被调用并配置了一组路径，这些路径接受并使用请求和上下文通过<code class="fe ms mt mu mv b">Response</code>结构来制定响应。</p><p id="445e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这是一篇关于rust中无服务器的介绍性文章，所以让我们实现一个简单的worker函数，该函数将对一组点进行线性插值，并返回用户提供的值<code class="fe ms mt mu mv b">x</code>的y值。例如，我们将提交三个点<code class="fe ms mt mu mv b">(1;2)</code>、<code class="fe ms mt mu mv b">(2;5)</code>、<code class="fe ms mt mu mv b">(4;6)</code>，并额外请求插值函数中<code class="fe ms mt mu mv b">3.1</code>的<code class="fe ms mt mu mv b">y</code>值(并获得<code class="fe ms mt mu mv b">5.55</code>作为结果)。</p><p id="3845" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的第一件事是添加具有<code class="fe ms mt mu mv b">derive</code>特性的<code class="fe ms mt mu mv b">serde</code>依赖项，以便从我们的请求体获得强类型的JSON输入(如果您不熟悉在rust中使用JSON，我推荐<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-work-with-json-in-rust-35ddc964009e">阅读本文</a>)。将这一行添加到<code class="fe ms mt mu mv b">Cargo.toml</code>文件中的依赖项中:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="f3e2" class="na lw it mv b gy nb nc l nd ne">serde = { version = "1.0", features = ["derive"] }</span></pre><p id="a5f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还想将<code class="fe ms mt mu mv b">use</code> it(在我们的<code class="fe ms mt mu mv b">lib.rs</code>中)包括在内:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="6a58" class="na lw it mv b gy nb nc l nd ne">use serde::{Deserialize, Serialize};</span></pre><p id="06f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们想为JSON请求体创建一个结构。如果你还记得，我们需要一个x坐标的向量，一个y坐标，和一个x来计算y。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="d9de" class="na lw it mv b gy nb nc l nd ne">#[derive(Serialize, Deserialize)]<br/>struct InterpData {    <br/>    x: Vec&lt;f64&gt;,    <br/>    y: Vec&lt;f64&gt;,    <br/>    x_query: f64<br/>}</span></pre><p id="f484" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们为<code class="fe ms mt mu mv b">InterpData</code>结构编写线性插值方法，从<code class="fe ms mt mu mv b">x_query</code>和提供的向量开始提取<em class="ng"> y </em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="14c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们简单地匹配哪些<code class="fe ms mt mu mv b"><em class="ng">x</em></code>索引可以找到我们的<code class="fe ms mt mu mv b">query_x</code>(在这个函数中是<code class="fe ms mt mu mv b">n</code>)，然后将匹配变量赋给它。接下来，我们根据lerp公式计算<code class="fe ms mt mu mv b"><em class="ng">y</em></code>。</p><p id="307d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们向路由器添加一个post路由。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="459a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第4行中，我们将JSON请求主体作为一个字符串，并在第5行中将其序列化(如果主体和<code class="fe ms mt mu mv b">InterpData</code>结构之间存在名称类型不匹配，那么worker将返回，这就是错误)。最后，我们使用<code class="fe ms mt mu mv b">interpolate_extract</code>方法计算我们的<code class="fe ms mt mu mv b"><em class="ng">y</em></code> <em class="ng"> </em>坐标，并在第11行将其作为响应返回。</p><h1 id="5fb4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">把所有的放在一起</h1><p id="bb71" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">结果是您的<code class="fe ms mt mu mv b">lib.rs</code>文件中的以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0b00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们测试一下，再运行一次<code class="fe ms mt mu mv b">wrangler dev</code>。我们希望验证<code class="fe ms mt mu mv b">/interpolate</code>端点是否按预期工作。我将使用httpie，如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="265d" class="na lw it mv b gy nb nc l nd ne">http http://localhost:8787/interpolate x:='[1.0,2.0,4.0]' y:='[2.0,5.0,6.0]' x_query:=3.1</span></pre><p id="a9de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述命令与使用以下主体向<code class="fe ms mt mu mv b"><a class="ae ky" href="http://localhost:8787/interpolate" rel="noopener ugc nofollow" target="_blank">http://localhost:8787/interpolate</a></code>端点发出post请求相同:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="65ab" class="na lw it mv b gy nb nc l nd ne">{<br/>  "x":[1.0, 2.0, 4.0],<br/>  "y":[2.0, 5.0, 6.0],<br/>  "x_query":3.1<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/292cae5dfd5b7484d86ddadb71af7202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*n9H741Nb8urtlEJ4RdnjxQ.png"/></div></figure><h1 id="e77d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">发布您的员工</h1><p id="5fde" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要发布员工，请执行以下操作:</p><ol class=""><li id="5bf1" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">用牧马人登录cloud flare:<code class="fe ms mt mu mv b">wrangler login</code></li><li id="f48e" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">发布工人:在工人的根目录下，<code class="fe ms mt mu mv b">wrangler publish.</code></li></ol><p id="0be8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以从提供的worker URL使用这个端点。</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="d777" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我之前提到的，由于WebAssembly，用Rust编写Cloudflare workers成为可能。这确保了用Rust编写的工人很可能总是比他们的JavaScript对手更快。此外，感谢编译器，您将能够编写workers，而不用担心类型和内存安全。随着您对Rust越来越熟悉，这将使开发变得更加容易。</p><p id="8f93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想知道更多关于铁锈和WASM的事情，你可以<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/get-started-with-wasm-in-rust-2347056bab4">阅读这篇文章</a>。</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="848b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>