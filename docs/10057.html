<html>
<head>
<title>12 Best Practices for Increasing the Database Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高数据库性能的12个最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/12-best-practices-for-increasing-the-database-performance-ca9dae8161a7?source=collection_archive---------0-----------------------#2021-11-21">https://betterprogramming.pub/12-best-practices-for-increasing-the-database-performance-ca9dae8161a7?source=collection_archive---------0-----------------------#2021-11-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2901" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高数据库性能的SQL技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/50ba95ceb10d1ca759f697c0e8654b35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EknmG1CFw0TnYotS4vdwIg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由来自<a class="ae ky" href="https://www.pexels.com/photo/set-of-modern-cables-and-connectors-on-shelf-4330788/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae ky" href="https://www.pexels.com/@brett-sayles?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Brett Sayles </a>拍摄</p></figure><p id="0c83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们开发时，一个重要的部分是知道如何正确地与我们的数据库交互。但是，我们往往只看数据库的配置参数和运行它的服务器的能力。虽然这很重要，但更重要的是知道如何正确使用SQL语言与数据库进行交互。因此，在这篇文章中，我们将看到一系列提高数据库性能的SQL查询技巧。</p><p id="eb37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些示例可以应用于不同的关系数据库。</p><p id="032d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧。</p><h1 id="9173" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">一般提示</h1><h2 id="0ba4" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">1.分析执行计划</h2><p id="a137" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">当我们执行SQL语句时，我们的数据库引擎首先分析没有语法错误。然后，它确定执行语句的最佳方式；也就是说，它创建自己的执行计划。</p><p id="9fa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用这个SQL执行计划来分析SQL语句是如何执行的，并搜索性能问题。</p><p id="7beb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">做这件事的方法很简单。例如，在Oracle中，我们可以使用以下命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">解释Oracle中的计划语法。</p></figure><p id="8a7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者在PostgreSQL中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">解释Postgres中的计划语法。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/727b1c9c20c8f70b17587504f78cb9ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PyfxM8G7DIIVjsjIKymBxw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">前一个查询的执行计划。</p></figure><p id="53f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成本元组中的第一个数字(36.04..37.05)一是<em class="nh">启动成本</em>，二是<em class="nh">总成本</em>。<em class="nh">总成本</em>是组件从读入数据到写入输出的整个执行时间。</p><p id="afa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之前的结果是估计值，因为我使用了"<em class="nh">解释。"</em>如果我们想要真实的度量，我们可以用<em class="nh"> </em>代替<em class="nh">“解释分析”</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">解释Postgres中的计划分析语法。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/f4409ec67b18f9fb73e866b6fdfb54f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xtqXFKwKUEFOeNiGrjPkQw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">前一个查询的执行计划。</p></figure><p id="e88b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过分析结果，我们可以检查SQL语句的哪一部分需要更多的优化。</p><h2 id="c72b" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">2.避免编码循环</h2><p id="96c2" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">使用循环在表中进行插入是一个坏主意，因为我们不让数据库引擎优化<em class="nh">插入</em>。我经常在代码中看到循环插入数百行，而不是使用其他更优化的方式。</p><p id="3145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用for循环:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用Java循环插入</p></figure><p id="56b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用具有多行和值的唯一的<em class="nh"> INSERT </em>或<em class="nh"> BATCH </em>语句来转换上面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用Java批量插入。</p></figure><h2 id="343f" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">3.避免相关的SQL子查询</h2><p id="84cd" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">相关子查询是使用父查询中的值的查询。除非SQL引擎优化器使用联接重写相关子查询，否则这种SQL查询会对外部查询返回的每一行运行一次，从而降低SQL查询的整体性能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">相关子查询。</p></figure><p id="3ef9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在这里看到的，问题是内部查询(SELECT c.name…)对外部查询(SELECT r.id，..)并对外部查询处理的每一行重复同样的操作。</p><p id="fb64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过如下重写语句来解决这个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用左连接代替相关子查询。</p></figure><h2 id="68e1" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">4.分割</h2><p id="85b1" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">SQL中的表分区是将大型数据表划分为称为分区的小型可管理表的过程。使用这种技术，我们可以提高查询性能，并使管理和查询数据变得更加容易。</p><p id="7b51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们主要有两种类型的分区:</p><p id="dc26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">垂直分区</strong></p><p id="d98c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">垂直分区是垂直拆分表，并且是在列上完成的。因此，一组列放在一个数据存储中，另一组放在另一个数据存储中。</p><p id="4b5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">水平分区</strong></p><p id="b366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">水平分区是水平分割表，并且在行上进行。一组行进入一个数据存储，另一组进入不同的数据存储。</p><p id="dea1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表分区通常用于包含历史数据的表。例如，在这些情况下，我们可以按年份进行水平分区，这将提供对包含当前年份数据的表的快速访问，这些数据通常是被咨询最多的数据。</p><h2 id="d521" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">5.检查索引</h2><p id="92a9" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如果使用得好的话，索引将会给我们的数据库迭代带来更快的速度。</p><p id="66a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">建议我们在WHERE和JOINS子句中使用的字段上创建索引，如果可能的话，在具有数字值而不是字符值的列上创建索引。</p><h2 id="46e5" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">6.删除未使用的索引</h2><p id="65b7" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">为所有东西创建索引而不担心它会使我们的表空间耗尽，特别是当我们在其上创建索引的表非常大的时候。为此，建议不时清理一下，看看我们拥有的所有索引是否都有必要。</p><h2 id="dfd4" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">7.选择合适的数据类型</h2><p id="626d" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">并不是所有的类型都占据相同的位置，当我们使用一个具体的数据类型时，我们也可以根据我们存储的内容来限制它的大小。例如，VARCHAR(4000)与VARCHAR(40)不同。我们总是必须调整我们将存储在字段中的内容，以免占用数据库中不必要的空间。</p><h2 id="d2fe" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">8.处理</h2><p id="9c90" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">保持较小的事务，因为事务会锁定正在处理的表数据，并可能导致死锁。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="4e86" class="lv lw it bd lx ly nq ma mb mc nr me mf jz ns ka mh kc nt kd mj kf nu kg ml mm bi translated">语法提示</h1><h2 id="ac53" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">9.用EXISTS-NO EXISTS代替IN-NOT IN</h2><p id="62ba" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如果我们想确认特定表中某个值的存在，推荐的方法是使用<em class="nh"> EXIST </em>子句。</p><p id="246e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为执行<em class="nh"> EXISTS </em>子句的进程一旦在表中找到所需的值就会停止。但是，另一方面，在子句中使用<em class="nh">的查询会扫描所有内容，即使是在找到必要的值之后。</em></p><h2 id="8b90" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">10.仅在必要时使用LIKE运算符</h2><p id="6c50" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">要搜索一个字符串，我们可以使用LIKE操作符或“=”操作符。</p><p id="db59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LIKE操作符和“=”操作符之间的主要区别在于，我们可以通过LIKE操作符使用通配符来搜索部分字符串。相反，使用“=”操作符，我们搜索精确匹配。</p><p id="9e41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们执行精确搜索，使用“=”操作符总是更好，因为它使用索引列，速度更快。</p><h2 id="fdf7" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">11.仅选择您需要的字段</h2><p id="1a7f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">SELECT *查询返回表中所有列的记录。虽然在某些情况下很有帮助，但在许多其他情况下，这是不必要的。</p><p id="5b6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为我们带来所有专栏的一些问题是:</p><ol class=""><li id="9f08" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">带宽过度消耗。</li><li id="c2bc" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">可以添加或删除列，或者修改表中的列名。因此，对于SELECT *我们可能会得到意外的结果</li><li id="1368" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">SELECT *返回的列的顺序可能不同。</li></ol><h2 id="bcce" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">12.使用连接代替子查询</h2><p id="e9ce" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">子查询是嵌入在另一个SQL语句的子句中的SELECT语句。它更容易编写，但是连接通常针对数据库引擎进行了更好的优化。</p><p id="a597" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，使用子查询可能比使用连接更好。例如，当连接大型表时。在这些情况下，首选方法是从那个大表中进行子选择(限制行数)，然后连接它们。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="0cb1" class="lv lw it bd lx ly nq ma mb mc nr me mf jz ns ka mh kc nt kd mj kf nu kg ml mm bi translated">最后的想法</h1><p id="2045" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">SQL(结构化查询语言)是一种强大的领域特定语言，它允许我们轻松地管理和检索关系数据库中的信息。</p><p id="a8b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是，如果您不知道如何正确使用它，您的数据库的性能将会显著下降。这就是为什么有必要考虑我在这篇小文章中写的基本建议，并且作为一个好的实践，在编写SQL时使用一个好的风格指南。</p><p id="18d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多关于<a class="ae ky" href="https://www.sqlstyle.guide/" rel="noopener ugc nofollow" target="_blank"> SQL </a>的风格指南，但是选择一个并在我们所有的开发中使用它是很重要的。</p><p id="ad9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们不要忘记，我们必须做的第一件事是<strong class="lb iu">了解我们的数据</strong>，它的类型，以及它如何相互关联，以便在与我们的数据库交互时做出最佳决策。</p><p id="a2c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有所帮助，如果你有任何问题，请随时联系我。我会尽量尽快回答。</p><p id="9d60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，考虑通过我的<a class="ae ky" href="https://kesk.medium.com/membership" rel="noopener">个人资料</a>订阅Medium。谢谢大家！</p></div></div>    
</body>
</html>