<html>
<head>
<title>From Rust to Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从铁锈到雨燕</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/from-rust-to-swift-df9bde59b7cd?source=collection_archive---------5-----------------------#2022-01-17">https://betterprogramming.pub/from-rust-to-swift-df9bde59b7cd?source=collection_archive---------5-----------------------#2022-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7a27" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何打包用Rust编写的本地库，以便与Swift分发工具一起使用。正确的方式。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5f980cc92d18ae39b4ef250f780a7775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6FuR2ybCjUc_urUcPDGeIA.png"/></div></div></figure><h2 id="404e" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">TL；博士</strong></h2><p id="1b18" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated"><a class="ae mj" href="https://github.com/tmarkovski/rust-to-swift" rel="noopener ugc nofollow" target="_blank">用Rust和Swift工件完成样本代码库</a>。</p><h1 id="4c25" class="mk kv it bd kw ml mm mn kz mo mp mq lc jz mr ka lg kc ms kd lk kf mt kg lo mu bi translated">我们的目标</h1><p id="4b5d" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">有没有想过如何分发您的原生Rust库以用作Swift库，特别是以这样一种方式分发它，使它可以作为所有Apple平台的其他库或应用程序的包依赖项？如果答案是肯定的，这个指南就是为你准备的。</p><p id="d2d5" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">在本文中，我们将经历用Rust编写的简单库的构建过程。我们将向Swift公开它的方法，为所有平台和设备编译它，最后，将所有东西打包成一个可再分发的档案，可以使用<a class="ae mj" href="https://www.swift.org/package-manager/" rel="noopener ugc nofollow" target="_blank"> Swift Package Manager </a>或其他分发工具，如CocoaPods或Carthage来引用。</p><h1 id="8779" class="mk kv it bd kw ml mm mn kz mo mp mq lc jz mr ka lg kc ms kd lk kf mt kg lo mu bi translated">工具和环境</h1><p id="b945" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">为了烤这个馅饼，我们需要一个安装了Xcode工具的MacOS设备。我们还需要<a class="ae mj" href="https://www.rust-lang.org/tools/install" rel="noopener ugc nofollow" target="_blank"> Rust工具链</a>来构建我们的本地库。</p><p id="455b" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">还需要一些其他的工具和组件，比如不同架构的运行时，但是我们会在以后的工作中解决这些问题。</p><h1 id="4e0b" class="mk kv it bd kw ml mm mn kz mo mp mq lc jz mr ka lg kc ms kd lk kf mt kg lo mu bi translated">写一个小小的Rust库</h1><p id="6d2c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">让我们从在Rust中创建一个小库开始。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="1174" class="ku kv it nb b gy nf ng l nh ni">mkdir mathwiz &amp;&amp; cd mathwiz<br/>cargo init --lib</span></pre><p id="1275" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">我们称它为MathWiz，我们在<code class="fe nj nk nl nb b">src/lib.rs</code>文件中添加了几个简单的函数来定义我们的API:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="63a9" class="ku kv it nb b gy nf ng l nh ni">#[no_mangle]<br/>pub extern "C" fn add(<em class="nm">a</em>: <em class="nm">i32</em>, <em class="nm">b</em>: <em class="nm">i32</em>) -&gt; <em class="nm">i32</em> {<br/>    <em class="nm">a</em> + <em class="nm">b<br/></em>}</span><span id="1b74" class="ku kv it nb b gy nn ng l nh ni">#[no_mangle]<br/>pub extern "C" fn flip(<em class="nm">a</em>: <em class="nm">bool</em>) -&gt; <em class="nm">bool</em> {<br/>    !<em class="nm">a<br/></em>}</span></pre><p id="3e3c" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">这里的目标是使用Rust中对<a class="ae mj" href="https://doc.rust-lang.org/nomicon/ffi.html" rel="noopener ugc nofollow" target="_blank">外部函数接口</a>的支持，使我们的Rust函数成为C-callable函数。在实践中，您的方法看起来会稍微复杂一些，但这超出了本练习的范围。</p><blockquote class="no np nq"><p id="8d71" class="lq lr nm ls b lt mv ju lv lw mw jx ly nr mx ma mb ns my md me nt mz mg mh mi im bi translated">我将在另一篇文章中介绍一些关于如何定义高度可维护、安全和可扩展的FFI契约的良好实践，敬请关注！</p></blockquote><p id="0601" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">为了将这个项目构建为一个静态库，我们需要将下面几行添加到我们的<code class="fe nj nk nl nb b">Cargo.toml</code>文件中</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c364" class="ku kv it nb b gy nf ng l nh ni">[lib]<br/>name = "mathwiz"<br/>crate-type = [ "staticlib" ]</span></pre><h1 id="5dda" class="mk kv it bd kw ml mm mn kz mo mp mq lc jz mr ka lg kc ms kd lk kf mt kg lo mu bi translated">制作标题和模块图</h1><p id="4e77" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">为了在其他平台中使用静态库，我们需要提供一个C头文件来描述API中的方法和类型。</p><p id="20f1" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">另外，我们需要提供一个<a class="ae mj" href="https://clang.llvm.org/docs/Modules.html#module-maps" rel="noopener ugc nofollow" target="_blank">模块映射</a>，这是Swift 在导入C头文件时需要的<a class="ae mj" href="https://riptutorial.com/swift/example/1418/use-a-module-map-to-import-c-headers" rel="noopener ugc nofollow" target="_blank">。省略模块映射经常是许多令人头痛的原因，所以确保不要跳过这一步。</a></p><p id="92c0" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">为了构建头文件，我们可以使用一个名为<code class="fe nj nk nl nb b">cbindgen</code>的Cargo工具。这个工具自动解析我们的库文件并构建一个兼容的C头文件。让我们安装这个工具并生成头文件。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0cc5" class="ku kv it nb b gy nf ng l nh ni">cargo install --force cbindgen</span><span id="b826" class="ku kv it nb b gy nn ng l nh ni">cbindgen --lang c --output include/mathwiz.h</span></pre><p id="5ba8" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">接下来，让我们在<code class="fe nj nk nl nb b">include</code>文件夹中创建一个名为<code class="fe nj nk nl nb b">module.modulemap</code>的文件，紧挨着我们刚刚生成的头文件。我们将该文件的内容设置为:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c5fb" class="ku kv it nb b gy nf ng l nh ni">module MathWiz {<br/>    header "mathwiz.h"<br/>    export *<br/>}</span></pre><p id="bef1" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">标头的最终目录结构应该如下所示:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="d732" class="ku kv it nb b gy nf ng l nh ni">include/<br/>├── mathwiz.h<br/>└── module.modulemap</span></pre><h1 id="5f0b" class="mk kv it bd kw ml mm mn kz mo mp mq lc jz mr ka lg kc ms kd lk kf mt kg lo mu bi translated">为所有平台编译静态库</h1><p id="cc63" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">好了，现在我们已经实现并定义了基本的API，我们可以通过运行<code class="fe nj nk nl nb b">cargo build</code>从终端构建这个库。然而，很简单，这将为我们正在运行的当前平台构建一个库，这个平台就是你的装有英特尔或苹果硅芯片的MacOS。</p><p id="6afd" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">在发布库时，我们希望支持iOS、iOS Simulator、macOS以及适用于英特尔和苹果芯片的mac Catalyst。在Rust中，我们可以通过为特定目标编译库来轻松实现这一点。<a class="ae mj" href="https://doc.rust-lang.org/nightly/rustc/platform-support.html" rel="noopener ugc nofollow" target="_blank"> Rustup工具支持</a>这些目标架构，它们可以作为单独的组件安装。</p><p id="85c6" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">让我们为iOS设备安装和构建库。这就需要<code class="fe nj nk nl nb b">aarch64-apple-ios</code>目标。我们运行以下命令:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="462b" class="ku kv it nb b gy nf ng l nh ni">rustup target add aarch64-apple-ios</span><span id="9c4a" class="ku kv it nb b gy nn ng l nh ni">cargo build --release --target aarch64-apple-ios</span></pre><p id="d9c8" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">让我们对以下6个目标重复相同的步骤:</p><ul class=""><li id="8f87" class="nu nv it ls b lt mv lw mw ld nw lh nx ll ny mi nz oa ob oc bi translated"><code class="fe nj nk nl nb b">x86_64-apple-darwin</code>和<code class="fe nj nk nl nb b">aarch64-apple-darwin</code> — macOS</li><li id="a204" class="nu nv it ls b lt od lw oe ld of lh og ll oh mi nz oa ob oc bi translated"><code class="fe nj nk nl nb b">x86_64-apple-ios</code>和<code class="fe nj nk nl nb b"><a class="ae mj" href="https://doc.rust-lang.org/nightly/rustc/platform-support/aarch64-apple-ios-sim.html" rel="noopener ugc nofollow" target="_blank">aarch64-apple-ios-sim</a></code> — iOS模拟器</li><li id="876e" class="nu nv it ls b lt od lw oe ld of lh og ll oh mi nz oa ob oc bi translated"><code class="fe nj nk nl nb b">x86_64-apple-ios-macabi</code>和<code class="fe nj nk nl nb b">aarch64-apple-ios-macabi</code> — Mac催化剂</li></ul><p id="bf5a" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">我们就此打住。如果您想要支持其他架构，比如tvOS，只需通过从<a class="ae mj" href="https://doc.rust-lang.org/nightly/rustc/platform-support.html" rel="noopener ugc nofollow" target="_blank">支持的平台</a>中指定目标三元组来构建该目标。虽然您不需要支持所有的架构，但是您的库只支持一种架构就可以了，您可能会遇到不满意的开发人员，他们希望获得额外的支持。</p><blockquote class="no np nq"><p id="1943" class="lq lr nm ls b lt mv ju lv lw mw jx ly nr mx ma mb ns my md me nt mz mg mh mi im bi translated">在撰写本文时，Mac Catalyst的最后两个架构还不是标准库的一部分，所以我们需要使用夜间工具链手工构建它们。这很容易做到，因为:</p></blockquote><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="518f" class="ku kv it nb b gy nf ng l nh ni">cargo +nightly build --release -Z build-std --target x86_64-apple-ios-macabi</span><span id="cf11" class="ku kv it nb b gy nn ng l nh ni">cargo +nightly build --release -Z build-std --target aarch64-apple-ios-high macabi</span></pre><p id="71ba" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">至此，我们完成了静态库的构建。一切都要建在<code class="fe nj nk nl nb b">target</code>文件夹下。<br/>让我们用<code class="fe nj nk nl nb b">find target -type f -name 'libmathwiz.a'</code>检查一下里面有什么——我们应该会看到类似这样的内容:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="d9d4" class="ku kv it nb b gy nf ng l nh ni">target/x86_64-apple-darwin/release/libmathwiz.a<br/>target/x86_64-apple-ios-macabi/release/libmathwiz.a<br/>target/aarch64-apple-darwin/release/libmathwiz.a<br/>target/aarch64-apple-ios/release/libmathwiz.a<br/>target/x86_64-apple-ios/release/libmathwiz.a<br/>target/aarch64-apple-ios-macabi/release/libmathwiz.a<br/>target/aarch64-apple-ios-sim/release/libmathwiz.a</span></pre><p id="f0df" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">酷豆！</p><h1 id="3528" class="mk kv it bd kw ml mm mn kz mo mp mq lc jz mr ka lg kc ms kd lk kf mt kg lo mu bi translated">将所有内容捆绑在一起进行二进制分发</h1><p id="b1ea" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">输入XCFrameworks！Apple将xc framework定义为由Xcode创建的可分发二进制包，其中包含框架或库的变体，以便可以在多个平台(iOS、macOS、tvOS和watchOS)上使用，包括模拟器构建。XCFramework捆绑是优于通用框架或静态库的首选方式。</p><p id="798e" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">在我们做最后的捆绑之前，我们需要把一些东西缝合在一起。同一平台的不同架构的库必须组合在一个文件中，称为fat库。这可以通过<code class="fe nj nk nl nb b">lipo</code>工具轻松实现。<br/>我们将为MacOS、iOS模拟器和Mac Catalyst库执行此步骤。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4fcf" class="ku kv it nb b gy nf ng l nh ni">lipo -create \<br/>  target/x86_64-apple-darwin/release/libmathwiz.a \<br/>  target/aarch64-apple-darwin/release/libmathwiz.a \<br/>  -output libmathwiz_macos.a</span><span id="2a00" class="ku kv it nb b gy nn ng l nh ni">lipo -create \<br/>  target/x86_64-apple-ios/release/libmathwiz.a \<br/>  target/aarch64-apple-ios-sim/release/libmathwiz.a \<br/>  -output libmathwiz_iossimulator.a</span><span id="92b6" class="ku kv it nb b gy nn ng l nh ni">lipo -create \<br/>  target/x86_64-apple-ios-macabi/release/libmathwiz.a \<br/>  target/aarch64-apple-ios-macabi/release/libmathwiz.a \<br/>  -output libmathwiz_maccatalyst.a</span></pre><p id="ea33" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">我们将把这些fat库用于框架捆绑包，此外还有iOS库，它不是fat捆绑包的一部分，因为它没有多个架构。<br/>如果你想看看fat库中有哪些架构，使用<code class="fe nj nk nl nb b">lipo -info</code>。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c202" class="ku kv it nb b gy nf ng l nh ni">lipo -info libmathwiz_macos.a</span><span id="5ef0" class="ku kv it nb b gy nn ng l nh ni">Architectures in the fat file: libmathwiz_macos.a are: x86_64 arm64</span></pre><p id="5fa7" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">让我们构建最后一个包:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e9b6" class="ku kv it nb b gy nf ng l nh ni">xcodebuild -create-xcframework \<br/>  -library ./libmathwiz_macos.a \<br/>  -headers ./include/ \<br/>  -library ./libmathwiz_iossimulator.a \<br/>  -headers ./include/ \<br/>  -library ./libmathwiz_maccatalyst.a \<br/>  -headers ./include/ \<br/>  -library ./target/aarch64-apple-ios/release/libmathwiz.a \<br/>  -headers ./include/ \<br/>  -output MathWiz.xcframework</span></pre><p id="a5a0" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">这将在当前目录中创建一个XCFramework，内容如下:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="3764" class="ku kv it nb b gy nf ng l nh ni">MathWiz.xcframework<br/>├── Info.plist<br/>├── ios-arm64<br/>│   ├── Headers<br/>│   │   ├── mathwiz.h<br/>│   │   └── module.modulemap<br/>│   └── libmathwiz.a<br/>├── ios-arm64_x86_64-maccatalyst<br/>│   ├── Headers<br/>│   │   ├── mathwiz.h<br/>│   │   └── module.modulemap<br/>│   └── libmathwiz_maccatalyst.a<br/>├── ios-arm64_x86_64-simulator<br/>│   ├── Headers<br/>│   │   ├── mathwiz.h<br/>│   │   └── module.modulemap<br/>│   └── libmathwiz_iossimulator.a<br/>└── macos-arm64_x86_64<br/>    ├── Headers<br/>    │   ├── mathwiz.h<br/>    │   └── module.modulemap<br/>    └── libmathwiz_macos.a</span></pre><p id="b3a2" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">我们应该将所有内容压缩在一起，因为我们稍后需要上传该文件:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="bd73" class="ku kv it nb b gy nf ng l nh ni">zip -r bundle.zip MathWiz.xcframework</span></pre><p id="35e9" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">我们还需要计算这个文件的校验和，以备后用，所以让我们记下这个命令的输出:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0b30" class="ku kv it nb b gy nf ng l nh ni">openssl dgst -sha256 bundle.zip</span></pre><p id="8709" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">至此，我们已经具备了开始在Swift中使用我们的库所需的一切。XCFrameworks可以在任何Xcode项目中引用，也可以直接使用。我们创建的框架应该可以工作了，当你<code class="fe nj nk nl nb b">import MathWiz</code>的时候，你应该可以看到所有可用的API。</p><p id="b7ba" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">但是，我们希望更进一步，将该框架作为可与Swift Package Manager (SPM)一起使用的Swift软件包进行分发。</p><h1 id="8196" class="mk kv it bd kw ml mm mn kz mo mp mq lc jz mr ka lg kc ms kd lk kf mt kg lo mu bi translated">创建Swift包</h1><p id="3297" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">对于这一步，我们将使用同一个存储库。<a class="ae mj" href="https://developer.apple.com/documentation/xcode/creating_a_standalone_swift_package_with_xcode" rel="noopener ugc nofollow" target="_blank">苹果的文档</a>有一些关于如何创建Swift包的介绍性文本。我们的目标是制作一个包含我们的Rust库的包，并有选择地包装本地方法，其他开发人员可以使用SPM在他们的项目中简单地引用这些方法。我们将使用GitHub作为我们的包的远程位置。</p><p id="ba4e" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">让我们在回购的根位置创建一个<code class="fe nj nk nl nb b">Package.swift</code>,内容如下:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="2044" class="ku kv it nb b gy nf ng l nh ni">// swift-tools-version:5.3</span><span id="e4a0" class="ku kv it nb b gy nn ng l nh ni">import PackageDescription<em class="nm"><br/></em>import Foundation</span><span id="a6b2" class="ku kv it nb b gy nn ng l nh ni">let package = Package(<br/>        name: "RustToSwift",<br/>        platforms: [<br/>            .iOS(.v13), <br/>            .macOS(.v11)<br/>        ],<br/>        products: [<br/>            .library(<br/>                name: "RustToSwift",<br/>                targets: ["RustToSwift"]),<br/>        ],<br/>        targets: [<br/>            .target(<br/>                name: "RustToSwift",<br/>                dependencies: ["MathWiz"]),<br/>            <strong class="nb iu">.binaryTarget(<br/>                name: "MathWiz",<br/>                url: "https://github.com/...../bundle.zip",<br/>                checksum: "ea7a.....35b2"),</strong><br/>            .testTarget(<br/>                name: "RustToSwiftTests",<br/>                dependencies: ["RustToSwift"]),<br/>        ]<br/>)</span></pre><p id="c2b7" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">注意我们在<code class="fe nj nk nl nb b">.binaryTarget</code>元素中导入包的位置。Swift Package Manager将自动解析该引用，下载并解包XCFramework，并使用<code class="fe nj nk nl nb b">import MathWiz</code>导入库。这是我们在<code class="fe nj nk nl nb b">module.modulemap</code>文件中定义的名称。</p><p id="2c28" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">继续将<code class="fe nj nk nl nb b">bundle.zip</code>文件上传到您的repo，并更新上一步中的链接和校验和散列。</p><p id="0d6e" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">就是这样！</p><p id="8533" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">我们现在可以使用我们的repo，并将其作为依赖项导入到任何使用SPM的项目中。这将自动为正确的平台带来所有静态库，并自动打包它们，每当我们为AppStore构建iOS应用程序时，无需手动处理静态文件。您还可以在另一个包中引用这个包，并让依赖链正确地管理静态库的使用。</p><h1 id="041f" class="mk kv it bd kw ml mm mn kz mo mp mq lc jz mr ka lg kc ms kd lk kf mt kg lo mu bi translated">椰子和迦太基呢？</h1><p id="3457" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">你可以毫不费力地使用它们。整个魔术是构建一个正确配置的XCFramework。之后，这个框架可以按照您喜欢的任何方式进行捆绑。以下是一些描述如何使用替代分发平台的文章:</p><ul class=""><li id="629b" class="nu nv it ls b lt mv lw mw ld nw lh nx ll ny mi nz oa ob oc bi translated">使用Cocoapods将通用iOS框架作为XCFramework发布——您可以跳过描述使用通用框架的部分，因为我们已经有了一个xc framework</li><li id="a75e" class="nu nv it ls b lt od lw oe ld of lh og ll oh mi nz oa ob oc bi translated"><a class="ae mj" href="https://docs.sentry.io/platforms/apple/guides/ios/install/carthage/#macs-with-apple-silicon-and-xcframeworks" rel="noopener ugc nofollow" target="_blank">关于使用XCFrameworks的Carthage官方文档</a></li></ul><h1 id="7375" class="mk kv it bd kw ml mm mn kz mo mp mq lc jz mr ka lg kc ms kd lk kf mt kg lo mu bi translated">给我看看代码</h1><p id="0641" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">本文引用的代码可以从下面的链接获得。我添加了简单的Swift包装器和测试来说明如何包装本地调用，因为这是通常的情况。回购中的代码可以用<code class="fe nj nk nl nb b">swift build</code>和<code class="fe nj nk nl nb b">swift test</code>克隆后构建和测试。</p><p id="5f39" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated"><strong class="ls iu"> GitHub资源库</strong>→<a class="ae mj" href="https://github.com/tmarkovski/rust-to-swift" rel="noopener ugc nofollow" target="_blank">https://github.com/tmarkovski/rust-to-swift</a></p><p id="e935" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly ld mx ma mb lh my md me ll mz mg mh mi im bi translated">希望你会觉得有用！快乐包装！</p></div></div>    
</body>
</html>