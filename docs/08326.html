<html>
<head>
<title>5 JavaScript Array Methods and the Gotchas That You Should Watch Out For</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5个JavaScript数组方法和应该注意的陷阱</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-array-methods-to-know-by-heart-d298c7009999?source=collection_archive---------0-----------------------#2021-04-18">https://betterprogramming.pub/5-array-methods-to-know-by-heart-d298c7009999?source=collection_archive---------0-----------------------#2021-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4872" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解map、reduce、sort、foreach等的复杂性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/937e05b0306846b4524733540e6bedae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w4yjeOxXubfWR-Po"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">布莱克·康纳利在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="cbfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们都经历过这种情况:我们处在编码流程中，代码像闪电一样从我们的手指中弹出。然后我们需要一个方法来操作一个<code class="fe ls lt lu lv b">array</code>，但是我们是空白的！所以我们做了一些快速的谷歌搜索，甚至更快的复制粘贴，运行我们的代码，就在那里:一个大红色的错误<em class="lw">出现在我们的控制台上。这都是因为我们的代码与我们复制粘贴的代码略有不同。</em></p><p id="54b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文旨在通过提高您对五种常用的<code class="fe ls lt lu lv b">array</code>方法、它们的来龙去脉(包括示例用例)以及需要注意的陷阱的理解来防止这种情况再次发生！无论您是最近才开始编码，还是已经编码好几年了，这些提示和技巧既包括易于理解的例子，也包括高级用例。</p><p id="078d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是五个需要用心学习的数组方法(已排序),它们将使你的编码技巧更上一层楼！</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/6118c989fb3935bbe4ef483bd094688e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dWjEsyEaaCQjHDexe0Hpug.png"/></div></div></figure><h1 id="2f91" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">过滤器</h1><ul class=""><li id="2f36" class="mx my iq ky b kz mz lc na lf nb lj nc ln nd lr ne nf ng nh bi translated">返回一个新的<code class="fe ls lt lu lv b">array</code>。</li><li id="b19b" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">不会改变调用它的<code class="fe ls lt lu lv b">array</code>。</li></ul><p id="ea67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一条非常简单明了，不需要任何记忆技巧就能记住。想过滤你的数组吗？继续使用<code class="fe ls lt lu lv b">filter</code>方法吧！<code class="fe ls lt lu lv b">filter</code>方法遍历数组中的每个元素，只返回通过由提供的函数实现的测试的项目。</p><p id="6e54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">filter</code>方法接受三个参数:</p><ol class=""><li id="69e8" class="mx my iq ky b kz la lc ld lf nn lj no ln np lr nq nf ng nh bi translated">元素的<code class="fe ls lt lu lv b">currentValue</code></li><li id="1377" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr nq nf ng nh bi translated">数组中元素的<code class="fe ls lt lu lv b">index</code></li><li id="4082" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr nq nf ng nh bi translated"><code class="fe ls lt lu lv b">array</code>本身</li></ol><h2 id="3b2d" class="nr mg iq bd mh ns nt dn ml nu nv dp mp lf nw nx mr lj ny nz mt ln oa ob mv oc bi translated">使用</h2><pre class="kg kh ki kj gt od lv oe of aw og bi"><span id="62ee" class="nr mg iq lv b gy oh oi l oj ok">let oldBand = ["Scary", "Baby", "Ginger", "Sporty", "Posh"]</span><span id="9ea6" class="nr mg iq lv b gy ol oi l oj ok">let newBand = oldBand.filter(currentElement =&gt; currentElement.length &gt; 4)</span><span id="8ecc" class="nr mg iq lv b gy ol oi l oj ok">console.log(newBand)<br/>// Outputs: Array ["Scary", "Ginger", "Sporty"]</span></pre><p id="1eac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们在<code class="fe ls lt lu lv b">oldBand</code>变量上使用了<code class="fe ls lt lu lv b">filter</code>方法来创建一个<code class="fe ls lt lu lv b">newBand</code>变量，其中我们只保留了名称超过四个字母的乐队成员。</p><p id="020f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">filter</code>方法的一个典型用例是允许用户过滤新闻网站上的文章、博客上的帖子或社交平台上的用户。在我们希望允许用户过滤一系列文章的情况下，我们的代码可能如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="245a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们定义了一个<code class="fe ls lt lu lv b">searchTerm</code>变量(通常会绑定到一个文本输入)，并将其指向“React”(即我们只想找到标题中有“React”的文章)。然后，我们将变量<code class="fe ls lt lu lv b">articles</code>绑定到文章的<code class="fe ls lt lu lv b">array</code>(通常从数据库中获取)。最后，我们在<code class="fe ls lt lu lv b">filter</code>方法的帮助下创建一个新的<code class="fe ls lt lu lv b">array</code>，并传递给它一个函数，该函数利用<code class="fe ls lt lu lv b">includes</code>方法在我们的<code class="fe ls lt lu lv b">articles</code> <code class="fe ls lt lu lv b">array</code>中包含的对象的<code class="fe ls lt lu lv b">titles</code>中寻找我们的<code class="fe ls lt lu lv b">searchTerm</code>。<code class="fe ls lt lu lv b">includes</code>方法区分大写和小写字母。因此，我们需要在<code class="fe ls lt lu lv b">toLowerCase</code>方法的帮助下改变传递函数中的字符串。</p><h2 id="6832" class="nr mg iq bd mh ns nt dn ml nu nv dp mp lf nw nx mr lj ny nz mt ln oa ob mv oc bi translated">逮到你了</h2><p id="2ad3" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">除了必须提供一个函数之外，这个函数并没有任何其他的问题(也就是说，只调用<code class="fe ls lt lu lv b">array.filter()</code>而不调用函数会抛出一个<code class="fe ls lt lu lv b">TypeError</code>)。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/8ff43bec5c6e0f9e95dd0725a8bc6e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FYg398adG34vVkLrI7MavA.png"/></div></div></figure><h1 id="af9d" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">为每一个</h1><ul class=""><li id="a0a9" class="mx my iq ky b kz mz lc na lf nb lj nc ln nd lr ne nf ng nh bi translated">不返回任何内容，但执行为<code class="fe ls lt lu lv b">array</code>中的每个元素提供的函数。</li><li id="114f" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">不会改变调用它的<code class="fe ls lt lu lv b">array</code>。</li></ul><p id="6285" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个也很明显——它将为数组中的每个元素执行一次我们提供的函数。然而，只有在没有更好的工具时，才应使用<code class="fe ls lt lu lv b">forEach</code>方法。</p><p id="1050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">乍一看，它可能看起来像一个简单的循环，但重要的是要记住方法不是循环，如果你在编码前不思考，这个坏男孩会有一些令人讨厌的问题！<code class="fe ls lt lu lv b">forEach</code>方法接受一个函数，并为<code class="fe ls lt lu lv b">array.</code>中的每个元素执行该函数</p><p id="9be8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">forEach</code>方法接受三个参数:</p><ol class=""><li id="12d5" class="mx my iq ky b kz la lc ld lf nn lj no ln np lr nq nf ng nh bi translated">元素的<code class="fe ls lt lu lv b">currentValue</code></li><li id="51af" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr nq nf ng nh bi translated">数组中元素的<code class="fe ls lt lu lv b">index</code></li><li id="9c20" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr nq nf ng nh bi translated"><code class="fe ls lt lu lv b">array</code>本身</li></ol><h2 id="b399" class="nr mg iq bd mh ns nt dn ml nu nv dp mp lf nw nx mr lj ny nz mt ln oa ob mv oc bi translated">使用</h2><pre class="kg kh ki kj gt od lv oe of aw og bi"><span id="fcca" class="nr mg iq lv b gy oh oi l oj ok">let fruits = ["apple", "banana", "lemon"]</span><span id="2f68" class="nr mg iq lv b gy ol oi l oj ok">fruits.forEach(element =&gt; console.log(element))<br/>// Outputs: "apple"<br/>// Outputs: "banana"<br/>// Outputs: "lemon"</span></pre><p id="bf6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的例子只是将数组中的每个值记录到我们的控制台中。您可能已经知道，<code class="fe ls lt lu lv b">forEach</code>是在没有更好的选择时使用的通用工具。</p><p id="77ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管<code class="fe ls lt lu lv b">forEach</code>本身不会改变调用它的数组，我们还是可以通过提供的函数改变数组，尽管最佳实践是使用适合这个目的的方法(例如<code class="fe ls lt lu lv b">filter</code>或<code class="fe ls lt lu lv b">map </code>方法)。为了让您了解我们如何使用<code class="fe ls lt lu lv b">forEach</code>实现数组操作，以及为什么应该避免使用它，请看下面的代码:</p><pre class="kg kh ki kj gt od lv oe of aw og bi"><span id="03c1" class="nr mg iq lv b gy oh oi l oj ok">let countDown = [4, 3, 2, 1, 0]</span><span id="38ab" class="nr mg iq lv b gy ol oi l oj ok">countDown.forEach((element, index, array)=&gt; {<br/>  element &gt; 1 ? array.splice(index, 1) : ""<br/>})</span><span id="3c56" class="nr mg iq lv b gy ol oi l oj ok">console.log(countDown)<br/>// Outputs: [3, 1, 0]</span></pre><p id="c0a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">写上面的内容时，我们期望我们的函数移除所有值大于<code class="fe ls lt lu lv b">1</code>的元素。因为我们在迭代过程中操作数组，所以实际发生的是函数只在每隔一个索引上运行，因为当我们在迭代结束前移除元素时，我们的数组一直在收缩。当从我们的<code class="fe ls lt lu lv b">forEach</code>函数中记录元素和索引时变得很清楚，就像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="8b38" class="nr mg iq bd mh ns nt dn ml nu nv dp mp lf nw nx mr lj ny nz mt ln oa ob mv oc bi translated">逮到你了</h2><p id="57d7" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">你不会想到像这样的基本函数会有任何问题，但是我们已经在上面讨论过了！另一个容易被忽略的问题是，如果在调用<code class="fe ls lt lu lv b">forEach</code>方法的<code class="fe ls lt lu lv b">array</code>中有一个空索引或<code class="fe ls lt lu lv b">undefined</code>索引(即<code class="fe ls lt lu lv b">myArr = [1, 2, , 4, 5]</code>，则不会在空索引上调用该函数(在本例中为<code class="fe ls lt lu lv b">myArr[2]</code>)。</p><p id="9bfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终，我们会遇到需要使用外部引用(如数据库)的情况，这反过来要求我们异步工作。</p><p id="398c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">forEach</code>方法的一个缺点是它期望一个同步函数，不会等待承诺。因此，如果我们需要在一个已经异步运行的函数中遍历一个<code class="fe ls lt lu lv b">array</code>，我们就失去了对异步函数执行顺序的控制。在这些情况下，最好使用一个<code class="fe ls lt lu lv b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noopener ugc nofollow" target="_blank">for...of</a></code> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noopener ugc nofollow" target="_blank">块</a>，它是一个循环而不是一个函数，因此本身不必异步执行。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/04b8ceb2cc89ce3630ff617b24b5e03e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uG29cc2STGSrrlADELXfgg.png"/></div></div></figure><h1 id="5920" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">地图</h1><ul class=""><li id="83e4" class="mx my iq ky b kz mz lc na lf nb lj nc ln nd lr ne nf ng nh bi translated">返回新的<code class="fe ls lt lu lv b">array</code>。</li><li id="d831" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">不会改变调用它的<code class="fe ls lt lu lv b">array</code>。</li></ul><p id="5ff9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">map</code>方法接受一个函数并返回一个新的<code class="fe ls lt lu lv b">array</code>,其中填充了所提供函数的结果。这可能是新开发人员遇到的第一个方法，因为它是在React中构建元素集合时使用的方法。记住它的名字可能有点棘手，因为名字并没有真正描述它的功能。</p><p id="cb1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在数学中，<em class="lw">映射</em>和<em class="lw">函数</em>可以互换使用，如果你是数学家，这可能会让你更容易记住。试着想想主动动词，映射。我们正在将旧的<code class="fe ls lt lu lv b">array</code>中的每个元素映射到新的<code class="fe ls lt lu lv b">array</code>。</p><p id="cdd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">map</code>方法接受三个参数:</p><ol class=""><li id="1296" class="mx my iq ky b kz la lc ld lf nn lj no ln np lr nq nf ng nh bi translated">元素的<code class="fe ls lt lu lv b">currentValue</code></li><li id="93f9" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr nq nf ng nh bi translated">数组中元素的<code class="fe ls lt lu lv b">index</code></li><li id="a7ac" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr nq nf ng nh bi translated"><code class="fe ls lt lu lv b">array</code>本身</li></ol><h2 id="7857" class="nr mg iq bd mh ns nt dn ml nu nv dp mp lf nw nx mr lj ny nz mt ln oa ob mv oc bi translated">使用</h2><pre class="kg kh ki kj gt od lv oe of aw og bi"><span id="72f9" class="nr mg iq lv b gy oh oi l oj ok">let oldSalaries = [3000, 1500, 7000]</span><span id="0d11" class="nr mg iq lv b gy ol oi l oj ok">newSalaries = oldSalaries.map((element) =&gt; element * 1.02)</span><span id="6ab2" class="nr mg iq lv b gy ol oi l oj ok">console.log(newSalaries)<br/>// Outputs: Array [3060, 1530, 7140]</span></pre><p id="64cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码展示了一个如何使用<code class="fe ls lt lu lv b">map</code>方法的简单例子。我们有一份每年到期的工资清单。我们<code class="fe ls lt lu lv b">map</code>覆盖我们的旧数组，给每个人加薪2%，并将其保存在我们的<code class="fe ls lt lu lv b">newSalaries</code>变量中。</p><p id="5f5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">map</code>方法的一个典型用例是，当我们有一个<code class="fe ls lt lu lv b">array</code>时，我们希望基于初始<code class="fe ls lt lu lv b">array</code>中包含的值创建一个新的<code class="fe ls lt lu lv b">array</code>。如果你已经在React中编写了一些代码，当<a class="ae kv" href="https://reactjs.org/docs/lists-and-keys.html#embedding-map-in-jsx" rel="noopener ugc nofollow" target="_blank">嵌入内联JSX </a>并遍历存储在数组中的数据来创建UI组件时，你可能会不假思索地使用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="5b35" class="nr mg iq bd mh ns nt dn ml nu nv dp mp lf nw nx mr lj ny nz mt ln oa ob mv oc bi translated">逮到你了</h2><p id="26bc" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">就像使用<code class="fe ls lt lu lv b">forEach</code>方法一样，<code class="fe ls lt lu lv b">map</code>不会迭代空索引或<code class="fe ls lt lu lv b">array</code>中的<code class="fe ls lt lu lv b">undefined</code>索引。尽管可以操纵源<code class="fe ls lt lu lv b">array</code>并忽略返回的<code class="fe ls lt lu lv b">array</code>，但这是一种反模式。在这种情况下，应使用<code class="fe ls lt lu lv b">forEach</code>或<code class="fe ls lt lu lv b">for...of</code>块。</p><p id="da93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">map</code>与<code class="fe ls lt lu lv b">forEach</code>的另一个共同点是，当在迭代过程中操作源<code class="fe ls lt lu lv b">array</code>时，它会导致不可预见的问题。不过，这应该不是什么大问题，因为<code class="fe ls lt lu lv b">map</code>已经返回了一个新的<code class="fe ls lt lu lv b">array</code>。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/d7973c2f8cb3391a9f7e79c061d546ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tXnflu0l16MdUpN6TAP4Qw.png"/></div></div></figure><h1 id="cd0c" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">减少</h1><ul class=""><li id="dd43" class="mx my iq ky b kz mz lc na lf nb lj nc ln nd lr ne nf ng nh bi translated">回报取决于实现了什么功能，以及作为<code class="fe ls lt lu lv b">initialValue</code>提供了什么。</li><li id="e98e" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">总是提供一个<code class="fe ls lt lu lv b">initialValue</code>来避免陷阱！</li><li id="0156" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">不会改变调用它的数组。</li></ul><p id="0705" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住<code class="fe ls lt lu lv b">reduce</code>的诀窍是把它想象成一种把数组简化为一个新变量的方法——可以是<code class="fe ls lt lu lv b">number</code>、<code class="fe ls lt lu lv b">string</code>、<code class="fe ls lt lu lv b">array</code>或其他什么。在它最简单的形式中，它将把你的由数字组成的数组简化为一个数字，但是它有更多的用途！</p><p id="09b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">reduce</code>方法接受四个参数:</p><ol class=""><li id="6198" class="mx my iq ky b kz la lc ld lf nn lj no ln np lr nq nf ng nh bi translated"><code class="fe ls lt lu lv b">accumulator</code></li><li id="8ad6" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr nq nf ng nh bi translated">元素的<code class="fe ls lt lu lv b">currentValue</code></li><li id="330a" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr nq nf ng nh bi translated">数组中元素的<code class="fe ls lt lu lv b">index</code></li><li id="48c7" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr nq nf ng nh bi translated"><code class="fe ls lt lu lv b">array</code>本身</li></ol><h2 id="8273" class="nr mg iq bd mh ns nt dn ml nu nv dp mp lf nw nx mr lj ny nz mt ln oa ob mv oc bi translated">使用</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="7892" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">起初，用例似乎只限于处理数字，但是在其他情况下，<code class="fe ls lt lu lv b">reduce</code>方法可以证明是有益的(例如，当通过属性对存储在数组中的对象进行分组时<a class="ae kv" href="https://javascript.plainenglish.io/5-use-cases-for-reduce-in-javascript-61ed243b8fef#08bb" rel="noopener ugc nofollow" target="_blank">)。</a></p><h2 id="3fca" class="nr mg iq bd mh ns nt dn ml nu nv dp mp lf nw nx mr lj ny nz mt ln oa ob mv oc bi translated">逮到你了</h2><p id="bb2e" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">如果数组为空并且没有提供<code class="fe ls lt lu lv b">initialValue</code>，将抛出<code class="fe ls lt lu lv b">TypeError</code>。如果数组只有一个元素(不考虑位置)并且没有提供<code class="fe ls lt lu lv b">initialValue</code>——或者如果提供了<code class="fe ls lt lu lv b">initialValue</code>，但是数组是空的——将返回solo值，而不调用提供的函数<em class="lw">。</em></p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/e1c9355c1442cbe54f87e2c2b05e4b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UnH5MpwbplfGUhL05m_TYw.png"/></div></div></figure><h1 id="927e" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">分类</h1><ul class=""><li id="c88b" class="mx my iq ky b kz mz lc na lf nb lj nc ln nd lr ne nf ng nh bi translated">返回相同的数组。</li><li id="e646" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">在地方可称为<a class="ae kv" href="https://en.wikipedia.org/wiki/In-place_algorithm" rel="noopener ugc nofollow" target="_blank"/>(即<code class="fe ls lt lu lv b">array.sort()</code>)。</li><li id="d9d4" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">通过排序来改变调用它的数组。</li></ul><p id="f745" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个程序做了它所说的事情:它对我们的<code class="fe ls lt lu lv b">array</code>进行排序。然而，我们<em class="lw">应该</em>总是提供一个比较函数来避免陷阱。如果没有提供函数，<code class="fe ls lt lu lv b">sort</code>方法会将每个元素转换成字符串，比较它们的UTF-16代码单元值序列，并按升序排序。因此“angular”在“bootstrap”之前，由于转换为字符串，700在9之前。</p><p id="e225" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">sort</code>方法接受两个参数:</p><ol class=""><li id="e7a8" class="mx my iq ky b kz la lc ld lf nn lj no ln np lr nq nf ng nh bi translated">用于比较的<code class="fe ls lt lu lv b">firstElement</code></li><li id="5b4d" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr nq nf ng nh bi translated"><code class="fe ls lt lu lv b">secondElement</code>进行比较</li></ol><p id="0f37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当提供比较功能时，这是<code class="fe ls lt lu lv b">sort</code>解释返回值的方式:</p><ul class=""><li id="ed80" class="mx my iq ky b kz la lc ld lf nn lj no ln np lr ne nf ng nh bi translated">如果提供的函数返回小于<code class="fe ls lt lu lv b">0</code>的值，则<code class="fe ls lt lu lv b">firstElement</code>和<code class="fe ls lt lu lv b">secondElement</code>保持不变。</li><li id="a869" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">如果所提供的函数返回<code class="fe ls lt lu lv b">0</code>，则<code class="fe ls lt lu lv b">firstElement</code>和<code class="fe ls lt lu lv b">secondElement</code>相对于彼此保持不变，但相对于所有不同的元素进行排序。</li><li id="c8f0" class="mx my iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">如果提供的函数返回大于<code class="fe ls lt lu lv b">0</code>的值，则将<code class="fe ls lt lu lv b">secondElement</code>排在<code class="fe ls lt lu lv b">firstElement</code>之前。</li></ul><h2 id="3933" class="nr mg iq bd mh ns nt dn ml nu nv dp mp lf nw nx mr lj ny nz mt ln oa ob mv oc bi translated">使用</h2><pre class="kg kh ki kj gt od lv oe of aw og bi"><span id="f3ba" class="nr mg iq lv b gy oh oi l oj ok">let numbersArray = [46, 2000, 12, 58, 300]</span><span id="e702" class="nr mg iq lv b gy ol oi l oj ok">numbersArray.sort((a, b) =&gt; a - b)</span><span id="7c99" class="nr mg iq lv b gy ol oi l oj ok">console.log(numbersArray)<br/>// Outputs: [12, 46, 58, 300, 2000]</span></pre><p id="f8ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的例子显示了一个简单的比较函数，用于对包含数字的<code class="fe ls lt lu lv b">array</code>进行升序排序。</p><p id="6ef7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">稍微调整一下，可以使用类似的比较函数对日期进行排序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="ad3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，如果我们有一个包含大写和小写混合的<code class="fe ls lt lu lv b">array</code>，我们可以像这样按字母顺序排序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="0087" class="nr mg iq bd mh ns nt dn ml nu nv dp mp lf nw nx mr lj ny nz mt ln oa ob mv oc bi translated">逮到你了</h2><p id="10b5" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">始终提供比较功能来控制输出。还记得如果我们不提供compare函数，<code class="fe ls lt lu lv b">sort</code>方法会将元素转换成字符串并进行比较吗？这导致大写单词出现在小写单词之前(即“Bootstrap”出现在“angular”之前)，这很容易忘记，因此可能会导致问题。</p><p id="803f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果在我们提供的<code class="fe ls lt lu lv b">array</code>中有值是<code class="fe ls lt lu lv b">undefined</code>，它们将被排序到数组的末尾。因此，您应该始终为<code class="fe ls lt lu lv b">sort</code>提供一个由相同的<code class="fe ls lt lu lv b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" rel="noopener ugc nofollow" target="_blank">primitive values</a></code>或<code class="fe ls lt lu lv b">objects</code>组成的<code class="fe ls lt lu lv b">array</code>。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="a801" class="mf mg iq bd mh mi or mk ml mm os mo mp jw ot jx mr jz ou ka mt kc ov kd mv mw bi translated">结论</h1><p id="956d" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf oo lh li lj op ll lm ln oq lp lq lr ij bi translated">这就是我们列出的让你在编码中更加成功和高效的方法清单。感谢您花时间阅读这篇文章。我希望你学到了新的东西！</p></div></div>    
</body>
</html>