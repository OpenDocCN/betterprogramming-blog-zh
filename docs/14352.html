<html>
<head>
<title>Coding a GraphQL API With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python编写GraphQL API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/coding-a-graphql-api-with-python-af74919e7f90?source=collection_archive---------2-----------------------#2022-12-02">https://betterprogramming.pub/coding-a-graphql-api-with-python-af74919e7f90?source=collection_archive---------2-----------------------#2022-12-02</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="53dd" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">使用Flask、Ariadne和Flask-SQLAlchemy</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/725ff5e1fd4ba1b210eac0ad424e501d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owSqnZN7jfYgG4D33JBKxg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者制作的图像。</p></figure><blockquote class="kz la lb"><p id="bbb7" class="lc ld le lf b lg lh jv li lj lk jy ll lm ln lo lp lq lr ls lt lu lv lw lx ly in bi translated">完整的源代码可以在这里找到:【https://github.com/ericjaychi/sample-graphql T2】</p></blockquote><p id="85d0" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">在我们编写任何代码之前，我们可能应该快速浏览一下GraphQL是什么。GraphQL是一种用于API的查询语言。那是什么意思？这意味着与您的API进行交互的开发人员可以根据需要请求尽可能多或尽可能少的数据。想想看，给定一个表，您可以在关系数据库中查询任意多或任意少的列。</p><p id="ae30" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">现在最大的问题是，这与REST API有什么不同，为什么要使用它？如果你不知道什么是REST API，没关系，我有一篇关于如何创建一个的<a class="ae lz" href="https://medium.com/swlh/coding-a-rest-api-with-python-77384ad60511" rel="noopener">文章！我建议在开始本教程之前先看看本教程，因为它的复杂性比GraphQL API要低一些。</a></p><p id="cb48" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">现在，让我试着描述一下。想象一下，你带着预先包装好的三明治走进一家杂货店。这些三明治有面包、生菜、西红柿、奶酪、肉和蛋黄酱。你不能自定义它们；是“拿了就走”现在，让我们说，现在你已经成为素食者，也在低碳水化合物饮食，但仍然想从熟食店买一个三明治。这些预包装的三明治仍然足够了，但是当你打开三明治包装时，你必须去掉一些你不想要的东西，比如肉和面包。</p><p id="7f5d" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">现在，想象一下同样的熟食店，但不是预先包装的三明治，而是包含所有相同成分的自制三明治吧。根据你的饮食限制，你现在可以自由地做任何你想要的三明治。</p><p id="b540" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">在这个类比中，REST APIs是预先打包的三明治，而GraphQL APIs是自己构建的三明治。每种熟食店都有利弊，就像从软件和架构的角度来看也有利弊一样。现在舞台已经搭好，让我们继续前进，进入实施阶段！</p><pre class="kk kl km kn gu md me mf bn mg mh bi"><span id="5c3c" class="mi mj iu me b be mk ml l mm mn"><strong class="me iv">Table of Contents</strong><br/><br/><a class="ae lz" href="#350d" rel="noopener ugc nofollow">Step 1: Installing Dependencies</a><br/><br/><a class="ae lz" href="#3472" rel="noopener ugc nofollow">Step 2: Setting Up the Flask Environment</a><br/><br/><a class="ae lz" href="#dc97" rel="noopener ugc nofollow">Step 3: Defining the Database and the Models</a><br/><br/><a class="ae lz" href="#d676" rel="noopener ugc nofollow">Step 4: Populating the Database</a><br/><br/><a class="ae lz" href="#5632" rel="noopener ugc nofollow">Step 5: Defining GraphQL Schemas</a><br/><br/><a class="ae lz" href="#f337" rel="noopener ugc nofollow">Step 6: Creating and Binding Resolvers</a><br/><br/><a class="ae lz" href="#1f75" rel="noopener ugc nofollow">Step 7: Executing Our API</a><br/><br/><a class="ae lz" href="#884c" rel="noopener ugc nofollow">Step 8: Mutating Data</a></span></pre><h1 id="350d" class="mo mj iu bd mp mq mr ms mt mu mv mw mx ka my kb mz kd na ke nb kg nc kh nd ne bi translated"><strong class="ak">第一步:安装依赖关系</strong></h1><p id="8cc0" class="pw-post-body-paragraph lc ld iu lf b lg nf jv li lj ng jy ll ma nh lo lp mb ni ls lt mc nj lw lx ly in bi translated">对于这样的API，我们需要三个组件:Flask、Ariadne和Flask-SQLAlchemy。</p><ul class=""><li id="d573" class="nk nl iu lf b lg lh lj lk ma nm mb nn mc no ly np nq nr ns bi translated">Flask是一个允许我们用Python构建web服务器的框架。</li><li id="740e" class="nk nl iu lf b lg nt lj nu ma nv mb nw mc nx ly np nq nr ns bi translated">Ariadne是我们利用GraphQL的一个库。</li><li id="4196" class="nk nl iu lf b lg nt lj nu ma nv mb nw mc nx ly np nq nr ns bi translated">Flask-SQLAlchemy是一个库，可以让我们快速建立数据库。可以使用任何其他数据库解决方案，但是对于本教程，我们将使用Flask-SQLAlchemy这样简单的解决方案。</li></ul><p id="53fc" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">所有这三个包都可以在<code class="fe ny nz oa me b">pip</code>上获得，这意味着很容易安装到我们的机器上。这假设您的机器上已经安装了<code class="fe ny nz oa me b">pip</code>或者正在使用某种形式的虚拟环境。</p><pre class="kk kl km kn gu md me mf bn mg mh bi"><span id="8cec" class="mi mj iu me b be mk ml l ob mn">pip install flask ariadne flask-sqlalchemy</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oc"><img src="../Images/0269ec59253e67059db0efe8a4b3ccd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/1*QJHS8te5knU9Z2AcRtiueg.gif"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">通过pip安装依赖项。忽略警告，家酿是贬低皮普，我已经懒得移动了。</p></figure><p id="9df0" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">我不会详细介绍这些库是做什么的，如果你好奇的话，可以在网上搜索一下！</p><h1 id="3472" class="mo mj iu bd mp mq mr ms mt mu mv mw mx ka my kb mz kd na ke nb kg nc kh nd ne bi translated"><strong class="ak">步骤2:设置烧瓶环境</strong></h1><p id="db8e" class="pw-post-body-paragraph lc ld iu lf b lg nf jv li lj ng jy ll ma nh lo lp mb ni ls lt mc nj lw lx ly in bi translated">现在我们已经安装了将要使用的工具，让我们在添加任何复杂的GraphQL代码之前，首先启动并运行我们的应用程序。</p><p id="f45c" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">为此，我们需要在目录中创建一个小文件结构。首先，在项目目录中创建一个名为<code class="fe ny nz oa me b">main.py</code>的新文件。其次，您想要创建一个<code class="fe ny nz oa me b">api/</code>目录，然后在该目录中创建一个名为<code class="fe ny nz oa me b">__init__.py</code>的文件。最后，你会得到这个:</p><pre class="kk kl km kn gu md me od oe aw of bi"><span id="c42a" class="og mj iu me b gz oh oi l mm mn">sample-graphql-api<br/>├── api<br/>│   └── __init__.py<br/>├── book.db<br/>└── main.py</span></pre><p id="956e" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">在<code class="fe ny nz oa me b">main.py</code>文件的内容里面:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oj ok l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">main.py</p></figure><p id="119a" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">然后里面的<code class="fe ny nz oa me b">api/__init__.py</code>文件:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oj ok l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">api/__init__。巴拉圭</p></figure><p id="d306" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">这基本上只是样板代码，允许我们在本地机器上运行应用程序。我们将很快增加更多的功能。</p><p id="0c89" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">让我们通过在项目目录中键入以下命令来运行应用程序:</p><pre class="kk kl km kn gu md me od oe aw of bi"><span id="6cbd" class="og mj iu me b gz oh oi l mm mn">python main.py</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ol"><img src="../Images/0539c14b24ecdfce719996b0bd852a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*69xIATF98Sb1CFcAhfwxpA.gif"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">启动Flask应用程序的输出。</p></figure><p id="a65f" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">运行此命令将使本地服务器运行。您现在可以在浏览器中进入<code class="fe ny nz oa me b">127.0.0.1:5000 </code>，查看我们可爱的网页！<code class="fe ny nz oa me b">localhost:5000 </code>也行。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj om"><img src="../Images/419d205de7997ef8c4f03746327d25c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*j5JWlcT7t_t0GNpijlsj2g.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">http://127.0.0.1:5000/</p></figure><p id="641e" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">没什么特别的，但是这是我们开始迭代下一步所需要的。</p><h1 id="dc97" class="mo mj iu bd mp mq mr ms mt mu mv mw mx ka my kb mz kd na ke nb kg nc kh nd ne bi translated">步骤3:定义数据库和模型</h1><p id="9efd" class="pw-post-body-paragraph lc ld iu lf b lg nf jv li lj ng jy ll ma nh lo lp mb ni ls lt mc nj lw lx ly in bi translated">下一步我们将编写一些代码来定义本教程的数据库模型。因为我们正在与Flask-SQLAlchemy交互，所以我们不需要做任何工作来启动本地数据库，但是，我们仍然需要添加几行代码来将数据库配置到一个文件中，并且我们仍然需要在Python端定义我们的数据库模型。</p><p id="404e" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">让我们首先定义数据库，并在<code class="fe ny nz oa me b">__init__.py</code>文件中将它附加到Flask应用程序:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oj ok l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">api/__init__。巴拉圭</p></figure><p id="0490" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">同样，由于我们使用的是Flask-SQLAlchemy，与使用数据库解决方案相比，只需要几行代码就可以做到这一点。</p><ul class=""><li id="9a16" class="nk nl iu lf b lg lh lj lk ma nm mb nn mc no ly np nq nr ns bi translated">第10行告诉Flask-SQLAlchemy数据库的确切位置。</li><li id="91bd" class="nk nl iu lf b lg nt lj nu ma nv mb nw mc nx ly np nq nr ns bi translated">第11行是一个配置，它跟踪对象的修改，每次数据库发生变化时，它都向应用程序发送一个信号。这对于我们的教程来说是不必要的，所以我们将它设置为<code class="fe ny nz oa me b">False</code>。</li></ul><p id="6827" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">现在我们已经有了数据库文件，我们可以继续在一个名为<code class="fe ny nz oa me b">models.py</code>的新文件中定义我们将在这个例子中使用的数据模型。该文件将在<code class="fe ny nz oa me b">api</code>目录下创建。代码如下:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oj ok l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">api/models.py</p></figure><p id="1f26" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">这是相对简单的代码，因为大多数应用程序需要用后端语言表示数据模型。这允许我们在Python端表示我们的数据模型，它将与数据库通信。</p><p id="96b7" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">既然我们的数据库代码已经全部实现，我们现在可以通过Python命令行向数据库中添加一些虚拟数据。传统上，您将拥有来自用户的数据，但是由于这是一个关于使用GraphQL的教程，我们只需要虚拟数据来处理。</p><p id="4829" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">在我们进入下一步之前，我们还想完成我们的包的配置，所以在<code class="fe ny nz oa me b">main.py</code>中现有的import语句下面添加这个新的import语句。在<code class="fe ny nz oa me b">main.py</code>中，您的导入语句应该如下所示:</p><pre class="kk kl km kn gu md me mf bn mg mh bi"><span id="d1a6" class="mi mj iu me b be mk ml l ob mn">from api import app, db<br/>from api import models</span></pre><h1 id="d676" class="mo mj iu bd mp mq mr ms mt mu mv mw mx ka my kb mz kd na ke nb kg nc kh nd ne bi translated">步骤4:填充数据库</h1><p id="7763" class="pw-post-body-paragraph lc ld iu lf b lg nf jv li lj ng jy ll ma nh lo lp mb ni ls lt mc nj lw lx ly in bi translated">在这一步中，我们将重点关注将一些数据放入本地数据库。通常，我们会从不同的源(如最终用户)填充数据，但由于这是一个教程，我们需要自己添加数据。</p><p id="4909" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">为此，我们需要在项目目录中调用终端中的Python解释器。只需在您的终端中键入以下行:</p><pre class="kk kl km kn gu md me mf bn mg mh bi"><span id="114f" class="mi mj iu me b be mk ml l ob mn">python</span></pre><p id="8502" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">这将打开您的Python解释器。从这里开始，我们将在数据库中手动创建一条记录，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oj ok l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在解释器中键入每个命令(带有&gt;&gt;&gt;的行)。理论上我们可以做一个文件来做这个，但是这样更快。</p></figure><p id="4312" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">既然我们运行了这段代码，我们应该在目录中有一个名为<code class="fe ny nz oa me b">book.db</code>的新文件。这包含我们刚刚放入的数据，以及数据库正常运行所需的一些其他数据。</p><h1 id="5632" class="mo mj iu bd mp mq mr ms mt mu mv mw mx ka my kb mz kd na ke nb kg nc kh nd ne bi translated"><strong class="ak">步骤5:定义GraphQL模式</strong></h1><p id="2b19" class="pw-post-body-paragraph lc ld iu lf b lg nf jv li lj ng jy ll ma nh lo lp mb ni ls lt mc nj lw lx ly in bi translated">现在我们已经正确地创建了数据，是时候最终进入本教程的GraphQL部分了。简单总结一下，GraphQL有自己的语言，SDL，模式定义语言。这定义了我们的API必须提供什么。无论是从数据模型的角度还是从端点的角度。</p><p id="bbc2" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">我们需要在这个项目的根目录下创建一个名为<code class="fe ny nz oa me b">schema.graphql</code>的新文件，它将提供CRUD(创建、读取、更新、删除)功能。在本教程中，我们将只讨论创建和读取。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oj ok l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">schema.graphql</p></figure><p id="0bb6" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">请记住，这一步可以在定义API的开始阶段完成。只要你的服务器端代码尊重<code class="fe ny nz oa me b">schema.graphql</code>中的定义，这并不重要，反之亦然。</p><h1 id="f337" class="mo mj iu bd mp mq mr ms mt mu mv mw mx ka my kb mz kd na ke nb kg nc kh nd ne bi translated">步骤6:创建和绑定冲突解决程序</h1><p id="17c7" class="pw-post-body-paragraph lc ld iu lf b lg nf jv li lj ng jy ll ma nh lo lp mb ni ls lt mc nj lw lx ly in bi translated">在这一步中，我们将创建解析器，然后绑定它们，以便我们可以使用它们来调用我们的API。解析器是为我们创建的模式中的类型解析值的函数或方法。如果我在这里向你展示我的意思可能会更好。</p><p id="3cec" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">在<code class="fe ny nz oa me b">api/</code>目录中，请创建一个名为<code class="fe ny nz oa me b">queries.py</code>的新文件，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oj ok l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">api/queries.py</p></figure><p id="a37c" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">这是一个非常简单的函数。在<code class="fe ny nz oa me b">get_books_resolver() </code>函数中，我们查询<code class="fe ny nz oa me b">Book </code>表中的所有条目，并将其序列化到一个字典中，这样我们就可以将它作为响应进行传递。有一个代码片段允许我们在出现错误时捕捉错误，并根据出现的错误设置响应。</p><p id="4f36" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated"><code class="fe ny nz oa me b">obj</code>作为父解析器返回的值，对于这个特定的例子，它是根解析器。这在本教程中没有用到。</p><p id="bed0" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated"><code class="fe ny nz oa me b">info</code>包含GraphQL服务器在解析器执行期间提供的任何上下文。这可以携带广泛的数据，如身份验证详细信息。这在本教程中没有用到。</p><p id="4ed4" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">现在我们已经编写了一个基本的解析器，我们需要让我们的框架Ariadne知道如何执行这个函数。在我们的<code class="fe ny nz oa me b">main.py </code>中，我们想要添加以下代码片段:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oj ok l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">main.py</p></figure><p id="9154" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">我们在这里添加了相当多的代码，所以让我们来看一些重要的部分。</p><p id="04ca" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated"><code class="fe ny nz oa me b">ObjectType </code>被导入来帮助我们定义这个解析器在我们的模式中是什么类型的执行。我们定义了两种类型，<code class="fe ny nz oa me b">Query</code>和<code class="fe ny nz oa me b">Mutation</code>。在这种情况下，我们将<code class="fe ny nz oa me b">ObjectType</code>定义为<code class="fe ny nz oa me b">Query</code>类型，它与REST APIs中的<code class="fe ny nz oa me b">GET </code>同义。</p><p id="b03b" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated"><code class="fe ny nz oa me b">set_field </code>将<code class="fe ny nz oa me b">books </code>绑定到我们的解析器。那是什么意思？当与我们的API对话时，客户端或用户将使用我们在这个<code class="fe ny nz oa me b">set_field </code>函数的第一个参数中定义的内容。这意味着我们的用户必须使用<code class="fe ny nz oa me b">books </code>关键字来调用我们定义的任何函数，在本例中是<code class="fe ny nz oa me b">get_books_resolver()</code>。</p><p id="c215" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated"><code class="fe ny nz oa me b">load_schema_from_path</code>读取我们决定输入的模式。在本例中，我们在上一步中制作的<code class="fe ny nz oa me b">schema.graphql </code>文件。</p><p id="f2e3" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated"><code class="fe ny nz oa me b">make_executable_schema</code>获取我们定义的模式和查询，并允许它们被执行。</p><p id="b92b" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated"><code class="fe ny nz oa me b">snake_case_fallback_resolvers</code>允许在返回的对象中查找字段名之前，将字段名转换成大小写。这只是为了保持一致性，因为Python使用snake case，而大多数其他语言如Javascript使用camel case。</p><h1 id="1f75" class="mo mj iu bd mp mq mr ms mt mu mv mw mx ka my kb mz kd na ke nb kg nc kh nd ne bi translated">步骤7:执行我们的API</h1><p id="d94e" class="pw-post-body-paragraph lc ld iu lf b lg nf jv li lj ng jy ll ma nh lo lp mb ni ls lt mc nj lw lx ly in bi translated">我们正在接近终点线，实际上我们所有的辛勤工作都有一些东西可以展示。我们将利用Ariadne的GraphQL平台。这是一个用户界面，允许我们玩我们的API。我们需要添加更多的代码来实现这一点。</p><p id="202a" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">在您的<code class="fe ny nz oa me b">main.py </code>文件中，在解析器逻辑之后添加以下代码片段:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oj ok l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">main.py底部</p></figure><p id="bae1" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">这段代码允许我们在浏览器中使用<code class="fe ny nz oa me b">/graphql</code>目的地。这允许我们使用Ariadne提供的操场UI。要理解我说的话，请进入您浏览器内的<code class="fe ny nz oa me b">http://127.0.0.1:5000/graphql</code>。通过在您的终端内部执行<code class="fe ny nz oa me b">python main.py</code>,确保您正在运行您的Flask服务器！</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj on"><img src="../Images/53c60ca6ab2d8f37f4fc505a5e799705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zNdCZOyfPQ8cpsHfLhDwOw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">阿里阿德涅游乐场用户界面</p></figure><p id="6b23" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">现在，在编辑器的左侧，插入以下代码片段:</p><pre class="kk kl km kn gu md me mf bn mg mh bi"><span id="7e99" class="mi mj iu me b be mk ml l ob mn">query getAllBooks {<br/>  getBooks {<br/>    success<br/>    errors<br/>    books {<br/>      id<br/>      title<br/>      author<br/>      isbn<br/>    }<br/>  }<br/>}</span></pre><p id="7dac" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">当您通过按下巨大的play按钮来执行此操作时，您将在右侧看到我们数据库中所有不同的<code class="fe ny nz oa me b">Books</code>的输出:</p><pre class="kk kl km kn gu md me mf bn mg mh bi"><span id="3507" class="mi mj iu me b be mk ml l ob mn">{<br/>  "data": {<br/>    "getBooks": {<br/>      "books": [<br/>        {<br/>          "author": "James Clear",<br/>          "id": "1",<br/>          "isbn": "0735211299",<br/>          "title": "Atomic Habits"<br/>        }<br/>      ],<br/>      "errors": null,<br/>      "success": true<br/>    }<br/>  }<br/>}</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oo"><img src="../Images/0ccae8135497f99cf0cb3d07ef5a92ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JEg7_r0GrNXABK0dUuZIVg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在执行我们的查询之后。</p></figure><p id="44cb" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">如你所见，该模型的结构与我们在<code class="fe ny nz oa me b">schema.graphql</code>和<code class="fe ny nz oa me b">models.py</code>文件中定义的完全一样。</p><p id="6c42" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">本教程开头提到的GraphQL的有趣之处在于，与传统的REST API不同，您可以根据需要请求任意多或少的数据。为此，只需修改我们提交的查询，删除任何您不需要的字段！</p><pre class="kk kl km kn gu md me mf bn mg mh bi"><span id="f814" class="mi mj iu me b be mk ml l ob mn">query getAllBooks {<br/>  getBooks {<br/>    success<br/>    books {<br/>      id<br/>      title<br/>      author<br/>    }<br/>  }<br/>}</span></pre><p id="7e16" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">在这个查询中，我们删除了<code class="fe ny nz oa me b">isbn</code>字段和<code class="fe ny nz oa me b">error</code>字段，当我们执行这个查询时，我们不会在响应中看到这些数据点。因此，这确实给了客户很大的权力来请求他们确切需要的数据，而不是根据API合同获取每一条数据。这也是GraphQL极其强大的一点。</p><h1 id="884c" class="mo mj iu bd mp mq mr ms mt mu mv mw mx ka my kb mz kd na ke nb kg nc kh nd ne bi translated">步骤8:改变数据</h1><p id="1d45" class="pw-post-body-paragraph lc ld iu lf b lg nf jv li lj ng jy ll ma nh lo lp mb ni ls lt mc nj lw lx ly in bi translated">这个很长的教程的最后一步，改变数据！因为修改数据和检索数据一样重要。好的方面是它重复了与步骤6相同的步骤，除了我们编写逻辑来改变数据而不是检索数据。为了稍微缩短本教程，我们将只添加一个<code class="fe ny nz oa me b">Book</code>的创建逻辑。任何其他操作都遵循完全相同的步骤，不同之处在于在响应中填充数据的核心逻辑。</p><p id="cb43" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">为了创建一个用于修改数据的GraphQL词汇表<code class="fe ny nz oa me b">Mutation</code>，我们将在我们的<code class="fe ny nz oa me b">api </code>目录中创建一个名为<code class="fe ny nz oa me b">mutations.py</code>的新文件。这将是我们的突变的家，就像我们有一个查询的家一样。在这个新创建的文件中，添加以下代码行:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oj ok l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">api/mutations.py</p></figure><p id="e11b" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">我觉得代码在这里是不言自明的，因为我们在步骤6中已经这么做了。</p><p id="df51" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">现在我们已经将解析器注入到了我们的<code class="fe ny nz oa me b">mutations.py</code>文件中，我们需要在我们的<code class="fe ny nz oa me b">main.py</code>文件中配置它，这样我们的应用程序就能理解如何调用这段代码。</p><p id="0973" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">在我们的<code class="fe ny nz oa me b">main.py</code>文件中，我们想要更新我们的代码，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oj ok l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">main.py</p></figure><p id="4849" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">我们添加了几行代码。</p><ul class=""><li id="6b98" class="nk nl iu lf b lg lh lj lk ma nm mb nn mc no ly np nq nr ns bi translated">第8行我们正在导入我们在这一步前面定义的新解析器。</li><li id="7ddb" class="nk nl iu lf b lg nt lj nu ma nv mb nw mc nx ly np nq nr ns bi translated">第15行我们正在创建一个新的<code class="fe ny nz oa me b">ObjectType</code>,它带有我们在模式中定义的“突变”类型的值。</li><li id="009f" class="nk nl iu lf b lg nt lj nu ma nv mb nw mc nx ly np nq nr ns bi translated">第20行的行为与我们的对应查询非常相似，除了我们调用了<code class="fe ny nz oa me b">create_book_resolver</code>函数。</li><li id="251c" class="nk nl iu lf b lg nt lj nu ma nv mb nw mc nx ly np nq nr ns bi translated">第27行我们需要更新我们的参数列表，以包含我们定义的新的<code class="fe ny nz oa me b">mutation</code>变量。</li></ul><p id="007b" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">完成这些更改后，让我们快速重启我们的Flask服务器。现在，我们可以用下面的语句在UI中执行我们的新变化:</p><pre class="kk kl km kn gu md me mf bn mg mh bi"><span id="09b9" class="mi mj iu me b be mk ml l ob mn">mutation createBook {<br/>  createBook(title:"Eat That Frog!", author:"Brian Tracy", isbn:"152309513X") {<br/>    success<br/>    errors<br/>    book {<br/>      id<br/>      title<br/>      author<br/>      isbn<br/>    }<br/>  }<br/>}</span></pre><p id="82ed" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">这调用了我们的解析器，我们用在<code class="fe ny nz oa me b">type Mutation</code>部分下的<code class="fe ny nz oa me b">schema.graphql</code>中定义的匹配函数来定义它。参数列表与我们在<code class="fe ny nz oa me b">schema.graphql</code>文件和解析器中定义的完全一样。然后解析器处理我们编码的数据，然后将响应传递回客户端。</p><p id="ed6a" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">一旦在UI中执行了这个命令，您应该会得到以下响应:</p><pre class="kk kl km kn gu md me mf bn mg mh bi"><span id="34ce" class="mi mj iu me b be mk ml l ob mn">{<br/>  "data": {<br/>    "createBook": {<br/>      "book": {<br/>        "author": "Brian Tracy",<br/>        "id": "2",<br/>        "isbn": "152309513X",<br/>        "title": "Eat That Frog!"<br/>      },<br/>      "errors": null,<br/>      "success": true<br/>    }<br/>  }<br/>}</span></pre><p id="6a80" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">记住，GraphQL允许我们要求尽可能多或少的数据。在这里，在我们的响应中，我们接收所有的数据，因为这是在请求中定义的，但是如果我们想将它限制在我们的模型中的特定数据点，我们可以在我们的查询中删除字段，类似于我们在上一步中通过<code class="fe ny nz oa me b">getAllBooks</code>所做的。</p><p id="3f68" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">现在如果执行<code class="fe ny nz oa me b">getAllBooks</code>，就会看到新添加的书！</p><pre class="kk kl km kn gu md me mf bn mg mh bi"><span id="2d78" class="mi mj iu me b be mk ml l ob mn">{<br/>  "data": {<br/>    "getBooks": {<br/>      "books": [<br/>        {<br/>          "author": "James Clear",<br/>          "id": "1",<br/>          "title": "Atomic Habits"<br/>        },<br/>        {<br/>          "author": "Brian Tracy",<br/>          "id": "2",<br/>          "title": "Eat That Frog!"<br/>        }<br/>      ],<br/>      "success": true<br/>    }<br/>  }<br/>}</span></pre><h1 id="4514" class="mo mj iu bd mp mq mr ms mt mu mv mw mx ka my kb mz kd na ke nb kg nc kh nd ne bi translated">结论</h1><p id="491d" class="pw-post-body-paragraph lc ld iu lf b lg nf jv li lj ng jy ll ma nh lo lp mb ni ls lt mc nj lw lx ly in bi translated">我们做到了！恭喜你坚持到最后。这是一个非常长的教程，我们甚至跳过了一些操作，比如更新、删除和通过ID获取一本书。这个过程都是一样的，除了您正在更改解析器中的核心逻辑。只要您了解如何绑定解析器，那么理论上您就可以创建任何端点。</p><p id="f5ae" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">我鼓励您尝试自己实现其余的操作。</p><p id="d2d1" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">一如既往，所有的代码都可以在这里找到:<a class="ae lz" href="https://github.com/ericjaychi/sample-graphql-api" rel="noopener ugc nofollow" target="_blank">https://github.com/ericjaychi/sample-graphql-api</a></p><p id="179c" class="pw-post-body-paragraph lc ld iu lf b lg lh jv li lj lk jy ll ma ln lo lp mb lr ls lt mc lv lw lx ly in bi translated">下集再见！</p></div></div>    
</body>
</html>