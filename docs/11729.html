<html>
<head>
<title>Upserting Pandas Dataframes to Snowflake</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将熊猫数据帧上传到雪花</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/upserting-pandas-dataframes-to-snowflake-d49d2590ff9b?source=collection_archive---------10-----------------------#2022-04-12">https://betterprogramming.pub/upserting-pandas-dataframes-to-snowflake-d49d2590ff9b?source=collection_archive---------10-----------------------#2022-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4c19" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一劳永逸地实现管道自动化。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/16d811a95aa927dd7a582bf3dad023a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1Cy0iGdts1pCp4lq"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚伦·伯顿</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="409e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是upsert？</h1><p id="d42d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">upsert是一个SQL语句，它处理表上的插入和更新，通常是批量处理。它需要一个目标表(您正在更新的表)和一个源表或文件(包含更新信息的表或文件)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/33142201285cd21ac14885f3f73098dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1xtwCYF55s__4l7kniaT5w.png"/></div></div></figure><p id="f422" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在本文中，我们将看看当您用Python获得了一个熊猫数据帧时，如何在雪花表上执行upsert。这一切都是围绕Transact-SQL中的<code class="fe mq mr ms mt b">MERGE</code>命令进行的，您可以在这里找到进一步的文档<a class="ae kv" href="https://www.mssqltips.com/sqlservertip/1704/using-merge-in-sql-server-to-insert-update-and-delete-at-the-same-time/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="cbfc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">如何使用Python运行upsert</h1><p id="80c1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我先把它一步一步分解，最后再把它全部汇总起来。如果你只是想阅读代码并进行演绎-改编，你可以跳过这些步骤。</p><h2 id="73dd" class="mu kx iq bd ky mv mw dn lc mx my dp lg lx mz na li mb nb nc lk mf nd ne lm nf bi translated">创建一个JSON文件</h2><p id="30b2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">你要做的第一件事是将你的数据帧保存为一个雪花可以暂存的文件。CSV显然看起来像是一个首选的解决方案，但是对于您的数据类型来说，JSON是一个更安全的选择。任何以字符串形式存储的数字(电话号码是我放弃CSV的主要原因)最终都将是一个整数或浮点数，可能用科学符号表示——这是我们在这个房子里最不需要的东西。</p><p id="d5eb" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">为了确保一切顺利运行，JSON文件必须满足三个条件:</p><ul class=""><li id="5ca9" class="ng nh iq lq b lr ml lu mm lx ni mb nj mf nk mj nl nm nn no bi translated">它必须面向记录，</li><li id="548b" class="ng nh iq lq b lr np lu nq lx nr mb ns mf nt mj nl nm nn no bi translated">记录必须按行存储(与列表相反)，</li><li id="8a11" class="ng nh iq lq b lr np lu nq lx nr mb ns mf nt mj nl nm nn no bi translated">日期类型必须存储到秒(相对于毫秒或纳秒)。</li></ul><p id="8355" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">为了满足所有这些要求，您可以使用下面一行代码:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="0eb7" class="mu kx iq mt b gy ny nz l oa ob">df.to_json(filename,orient='records',lines=True,date_unit='s')</span></pre><p id="7165" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这将为您提供一个漂亮的逐行JSON表记录，看起来应该是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/5047019619e48ec11dfec116f9263f4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6vvg3w5Fo8xRqyF0n8qh4g.png"/></div></div></figure><h2 id="9bed" class="mu kx iq bd ky mv mw dn lc mx my dp lg lx mz na li mb nb nc lk mf nd ne lm nf bi translated">在雪花上为JSON文件创建一个stage</h2><p id="e2ad" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">阶段是文件的临时存储位置，这些文件包含我们需要复制到表中的数据。理想情况下，您会希望在与您尝试向上插入JSON文件的表相同的数据库和模式中创建它。</p><p id="9ac7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">要创建拟合阶段，只需在雪花工作表上正确设置上下文，然后运行以下代码行:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="1f36" class="mu kx iq mt b gy ny nz l oa ob">CREATE OR REPLACE STAGE my_stage_name FILE_FORMAT=(TYPE=’JSON’);</span></pre><h2 id="31ef" class="mu kx iq bd ky mv mw dn lc mx my dp lg lx mz na li mb nb nc lk mf nd ne lm nf bi translated">暂存您的JSON文件</h2><p id="e9c4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这只需要一个命令，您可以在终端中从snowsql会话运行该命令，也可以在设置好雪花连接后在Python中运行该命令(代码在最后给出)。</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="0b9d" class="mu kx iq mt b gy ny nz l oa ob">PUT file:///path/to/json_filename @my_stage_name OVERWRITE=TRUE;</span></pre><h2 id="5c5a" class="mu kx iq bd ky mv mw dn lc mx my dp lg lx mz na li mb nb nc lk mf nd ne lm nf bi translated">运行合并</h2><p id="fcfd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">将一个暂存文件合并到一个表中并不十分困难，只是语法有点问题。当引用JSON文件中的一个“列”时，需要在所有列的前面加上<code class="fe mq mr ms mt b">$1:</code>。</p><p id="90e2" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">您可以遵循这个示例，其中列A类似于主键，列B和C包含容易改变的信息(比如“最后更新”时间戳——这就是为什么当合并在列A上找到匹配时我们更新它们),而列D包含值得插入但不需要更新的信息(比如出生日期)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="6f43" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在即将到来的自动化中，我将把像A列这样的列称为“ID列”，把像B和C这样的列称为“更新列”。</p><h1 id="acc4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">把所有的放在一起</h1><p id="14de" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">以下函数中的代码将接受:</p><ul class=""><li id="132c" class="ng nh iq lq b lr ml lu mm lx ni mb nj mf nk mj nl nm nn no bi translated">你的数据框</li><li id="8e45" class="ng nh iq lq b lr np lu nq lx nr mb ns mf nt mj nl nm nn no bi translated">您的<code class="fe mq mr ms mt b">id_columns</code>(构成主键的列的列表——如果您手头有ID，可以是一个列的列表)</li><li id="2f2a" class="ng nh iq lq b lr np lu nq lx nr mb ns mf nt mj nl nm nn no bi translated">您的<code class="fe mq mr ms mt b">insert_columns</code>(您想要为不匹配的行插入的所有列的列表)</li><li id="ef03" class="ng nh iq lq b lr np lu nq lx nr mb ns mf nt mj nl nm nn no bi translated">您的<code class="fe mq mr ms mt b">update_columns</code>(您可能想要更新的所有栏目的列表——参见上面的例子)</li><li id="0d2e" class="ng nh iq lq b lr np lu nq lx nr mb ns mf nt mj nl nm nn no bi translated">您的上下文(数据库、方案、表和阶段名)</li></ul><p id="8ab8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">并运行上面提到的所有步骤，但不包括阶段创建。</p><p id="7470" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">它在第7行到第16行打开一个与Snowflake的连接，在第21行到第23行创建一个JSON文件，在第28行暂存文件，在第29行到第36行运行合并，在第38行从暂存文件中删除文件，并在第40行删除您的本地文件。最后，它在第43行正确地关闭了您的雪花连接。第4、18和41行提供了函数运行时的一些细节。</p><p id="1935" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当然，你需要Python 的<a class="ae kv" href="https://docs.snowflake.com/en/user-guide/python-connector.html" rel="noopener ugc nofollow" target="_blank">雪花连接器来建立连接。</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="cbf1" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">负责任地向上插！</p></div></div>    
</body>
</html>