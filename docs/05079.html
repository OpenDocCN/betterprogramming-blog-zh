<html>
<head>
<title>How to Make Your Own Concurrent Task Runner in Node</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Node中创建自己的并发任务运行器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-make-your-own-concurrent-task-runner-in-node-1770df68215b?source=collection_archive---------5-----------------------#2020-06-05">https://betterprogramming.pub/how-to-make-your-own-concurrent-task-runner-in-node-1770df68215b?source=collection_archive---------5-----------------------#2020-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b543" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Commander和Chalk，让我们从头开始实现并发任务运行器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1b041fdda9eb326061530f7e57a7b8a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VqB1y06PV5ua2ZxGyLdZ4A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@thecreative_exchange?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的创意交流</a>拍摄</p></figure><p id="1f73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你在开发时，让一个并发的任务运行器同时运行你的后端和前端有时会很有帮助。您可能已经知道并发<a class="ae kv" href="https://www.npmjs.com/package/concurrently" rel="noopener ugc nofollow" target="_blank"/>，它允许您在将输出流式传输到控制台的同时运行多个命令行脚本。在本教程中，我们将重新创建<code class="fe ls lt lu lv b">concurrently</code>的一个功能，同时学习如何在Node中构建自己的命令行界面(CLI)工具。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="e6dc" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">先决条件</h1><p id="e450" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我假设你已经知道NPM和<code class="fe ls lt lu lv b">yarn</code>是如何工作的，以及承诺和<code class="fe ls lt lu lv b">async/await</code>关键词是如何工作的。如果没有，在这里查看MDN关于承诺<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">的文档，在这里</a>查看他们关于<code class="fe ls lt lu lv b">async/await</code> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="noopener ugc nofollow" target="_blank">的文档。在本教程中，我将使用节点v10。</a></p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="3efa" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">依赖安装</h1><p id="cea9" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们的并发任务运行器<code class="fe ls lt lu lv b">simultaneously</code>将依赖两个外部库。让我们初始化工作区并安装这些依赖项:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="5a35" class="ne me iq lv b gy nf ng l nh ni">yarn init -y<br/>yarn add commander chalk</span></pre><p id="33d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.npmjs.com/package/commander" rel="noopener ugc nofollow" target="_blank"> Commander </a>公开了一套工具，让我们可以轻松地创建CLI工具，而<a class="ae kv" href="https://www.npmjs.com/package/chalk" rel="noopener ugc nofollow" target="_blank"> Chalk </a>让我们可以为终端输出添加样式和颜色。</p><h1 id="9a58" class="md me iq bd mf mg nj mi mj mk nk mm mn jw nl jx mp jz nm ka mr kc nn kd mt mu bi translated">了解应该如何同时工作</h1><p id="c754" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在写任何代码之前，我们需要了解<code class="fe ls lt lu lv b">simultaneously</code>应该如何工作。让我们的工具简单明了，调用语法如下:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="4bf1" class="ne me iq lv b gy nf ng l nh ni">node simultaneously.js run "command1 arg" "command2 arg" ...</span></pre><p id="20f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行时，<code class="fe ls lt lu lv b">command1 arg</code>应该与<code class="fe ls lt lu lv b">command2 arg</code>同时运行，以及随后括号中的所有其他命令，命令的所有输出都被传输到标准输出。还应该有一种方法来识别每个输出行的来源。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="d558" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">我们开始吧</h1><p id="45dc" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">现在我们已经指定了工具的预期行为和语法，我们可以开始构建它了。让我们从切入点开始，<code class="fe ls lt lu lv b">simultaneously.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0dbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个文件中，我们定义了一个新命令<code class="fe ls lt lu lv b">run</code>，它接受一个必需参数<code class="fe ls lt lu lv b">script</code>和可选参数<code class="fe ls lt lu lv b">otherScripts</code>。必需的参数用方括号括起来，可选的参数用方括号括起来。在<code class="fe ls lt lu lv b">otherScripts</code>末尾包含省略号意味着它可以接受数量可变的参数。</p><p id="c631" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了测试我们的工具能否正确解析我们的参数，让我们试着执行它:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="4f85" class="ne me iq lv b gy nf ng l nh ni">node simultaneously.js "echo command1" "echo command2" "echo command3"</span></pre><p id="b571" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该看到<code class="fe ls lt lu lv b">Script: echo command1</code>记录在第一行，而<code class="fe ls lt lu lv b">Other Scripts: echo command2 echo command3</code>记录在第二行。</p><p id="9bba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太好了！但它只是打印我们输入的内容，这不是我们想要的功能。让我们运行这些命令，而不是打印它们:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6a30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Node的标准库包括一个名为<code class="fe ls lt lu lv b">child_process</code>的包，它公开了运行多个进程的功能。在这种情况下，我们将使用<code class="fe ls lt lu lv b">spawn</code>来运行我们的脚本，因为它允许我们将输出从子流程流式传输到主流程。</p><p id="55e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像以前一样运行该命令，现在应该只显示以下内容:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="4da9" class="ne me iq lv b gy nf ng l nh ni">command1<br/>command2<br/>command3</span></pre><p id="d071" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有用！然而，到目前为止，我们只运行了不会运行很长时间并且输出可预测的脚本——我们如何确保我们的工具输出流，而不是一个接一个地执行命令？当我们运行开发服务器时，服务器无限期地运行。出于这个原因，我们将创建一个脚本<code class="fe ls lt lu lv b">sleeper.js</code>，它在退出之前以不确定的间隔数到10:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="58ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尝试运行<code class="fe ls lt lu lv b">node sleeper.js</code>几次，观察每次运行需要不同的时间来完成。</p><p id="ae95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以测试并查看<code class="fe ls lt lu lv b">simultaneously</code>是否按预期工作。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="23a3" class="ne me iq lv b gy nf ng l nh ni">node simultaneously.js "node sleeper.js" "node sleeper.js" "node sleeper.js"</span></pre><p id="c0f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一次，您将看到类似这样的内容:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="1356" class="ne me iq lv b gy nf ng l nh ni">Count: 0<br/>Count: 0<br/>Count: 0<br/>Count: 1<br/>Count: 1<br/>Count: 2<br/>Count: 3<br/>Count: 1<br/>...<br/>Count: 8<br/>Count: 10<br/>Finished counting to 10!<br/>Count: 9<br/>Count: 10<br/>Finished counting to 10!<br/>Count: 10<br/>Finished counting to 10!</span></pre><p id="b22a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所希望的那样，这些程序正在同时运行。然而，不可能将每一行输入与每一条命令匹配起来。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="837d" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">识别输出流</h1><p id="2138" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们能做什么来识别输出流？一个简单的方法是给每个命令一个标识号，每当有东西从流中输出时，就在前面加上这个标识号。我们可以通过用自己的<code class="fe ls lt lu lv b">log</code>函数替换<code class="fe ls lt lu lv b">console.log</code>来实现这一点，该函数接受一个<code class="fe ls lt lu lv b">id</code>参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="dad7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当您运行上面的命令时，您会注意到每个输出行都有一个数字前缀，如下所示:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="2ec9" class="ne me iq lv b gy nf ng l nh ni">[2] Count: 0<br/>[1] Count: 0<br/>[1] Count: 1<br/>[0] Count: 0<br/>[2] Count: 1<br/>[1] Count: 2<br/>...</span></pre><p id="d51a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们快完成了！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="2a07" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">收尾</h1><p id="2e2e" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">为了更容易区分输出行，我们可以给每个标识符一种颜色。我们可以通过基于ID循环使用一组固定的颜色来实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a6c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Chalk公开了许多颜色，我们可以用它们来装饰我们的输出——我们可以预先定义一组我们想要使用的颜色，然后确保每个ID都有不同的颜色。当您重新运行脚本时，您会注意到索引现在有了颜色！干净利落。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/58237880bebc2cb0382431116e90f0f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kVbFcLz2lZOLBSUsRV8a5Q.gif"/></div></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="cd6d" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">进一步扩展</h1><p id="67d9" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我已经介绍了如何在Node中创建自己的并发任务运行器的基础知识，但是还有许多其他方法可以扩展这个项目。以下是一些让你开始的想法:</p><ul class=""><li id="1160" class="nr ns iq ky b kz la lc ld lf nt lj nu ln nv lr nw nx ny nz bi translated">分离标准输出流和错误流。</li><li id="2090" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">包括使用<a class="ae kv" href="https://www.npmjs.com/package/inquirer" rel="noopener ugc nofollow" target="_blank">查询者</a>的交互性。例如，您可以从一个<code class="fe ls lt lu lv b">package.json</code>文件中读取所有脚本，并提供它们作为运行并发任务的选项。</li><li id="eefe" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">添加一个命令来运行最新的指令集。</li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="62db" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">资源</h1><p id="9e51" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">如果您有兴趣进一步开发自己的CLI工具，这里有一些资源可以帮助您:</p><ul class=""><li id="62f9" class="nr ns iq ky b kz la lc ld lf nt lj nu ln nv lr nw nx ny nz bi translated"><a class="ae kv" href="https://github.com/tj/commander.js" rel="noopener ugc nofollow" target="_blank">指挥官的Github页面</a></li><li id="67f7" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="http://github.com/SBoudrias/Inquirer.js" rel="noopener ugc nofollow" target="_blank">问询者的Github页面</a></li><li id="ef97" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://github.com/chalk/chalk" rel="noopener ugc nofollow" target="_blank">粉笔的Github页面</a></li></ul></div></div>    
</body>
</html>