<html>
<head>
<title>My Basic HTTPManager in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在Swift中的基本HTTPManager</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/my-basic-httpmanager-in-swift-db2be1e340c2?source=collection_archive---------6-----------------------#2020-04-24">https://betterprogramming.pub/my-basic-httpmanager-in-swift-db2be1e340c2?source=collection_archive---------6-----------------------#2020-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5fad" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使网络请求变得更加容易</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/06fa82ae81e0165b19b2e06e1a400c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7M2jBDJ8x3OKIzBPYTf8CA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@drmakete?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> drmakete实验室</a>在<a class="ae ky" href="https://unsplash.com/s/photos/network?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4ef1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在Swift中将网络代码从视图和视图控制器中分离出来，我通常使用一个简单的HTTPManager。</p><p id="7369" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是关于这是如何工作的，以及如何在你自己的项目中实现，也许，最重要的是，如何测试。</p><p id="13b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">难度:初级|简单<strong class="lb iu"> </strong> | <strong class="lb iu">普通</strong> |挑战</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f4df" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件</h1><ul class=""><li id="cb5f" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated">有理由打网络电话</li><li id="3d93" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">能够产生一句“你好，世界！”iOS应用程序(本<a class="ae ky" href="https://medium.com/@stevenpcurtis.sc/your-first-swift-application-without-a-mac-79598ad839f8" rel="noopener">文章</a>中的指南)</li><li id="0550" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">Swift中的协议(指南<a class="ae ky" href="https://medium.com/swlh/for-loops-in-swift-628a6a2b2ea7" rel="noopener">此处为</a>)</li><li id="d542" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">能够使用相关类型(此处的指南<a class="ae ky" href="https://medium.com/@stevenpcurtis.sc/protocols-with-associated-types-in-swift-eec850af3c02" rel="noopener">为</a>)</li><li id="2e31" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">闭合装置(此处为导向装置<a class="ae ky" href="https://medium.com/swift-coding/swift-closures-c14cb7aa2170" rel="noopener"/></li><li id="bf78" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">雨燕的<code class="fe nk nl nm nn b">Result</code>型(此处为导向<a class="ae ky" href="https://medium.com/@stevenpcurtis.sc/result-type-in-swift-1b4e2a84f2c2" rel="noopener"/></li><li id="bba5" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">依赖注入测试(此处为指南<a class="ae ky" href="https://medium.com/swlh/injecting-services-into-swift-apps-for-testing-39623f48941c" rel="noopener"/></li><li id="b692" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">使用<code class="fe nk nl nm nn b">Codable</code>(此处导向<a class="ae ky" href="http://A type alias for the Encodable and Decodable protocols" rel="noopener ugc nofollow" target="_blank">为</a>)</li><li id="4575" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">仿制药(指南<a class="ae ky" href="https://medium.com/better-programming/generics-in-swift-aa111f1c549" rel="noopener">此处</a>)</li><li id="1b20" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">测试时处理异步调用(指南<a class="ae ky" href="https://medium.com/@stevenpcurtis.sc/result-type-in-swift-1b4e2a84f2c2" rel="noopener">此处为</a>)</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="293a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">术语</h1><ul class=""><li id="dcd0" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated">类:定义公共属性和方法的对象。</li><li id="3d9a" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">数据任务:检索URL内容的任务。</li><li id="1b70" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">错误:程序产生错误结果而导致的问题。</li><li id="7508" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">基础:包含定义基本应用功能的数据类型、集合和服务的框架。</li><li id="2232" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">框架:一种与应用程序、团队成员或更远的地方共享代码包的方式。</li><li id="8b90" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">HTTPManager:我创建并选择用来将网络代码从视图/视图控制器中分离出来的类。</li><li id="cd01" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">模拟:对对象的方法调用的虚假响应，允许检查特定的方法调用或属性。</li><li id="646d" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">模型:存储数据和操作数据的逻辑的地方。也许模型对象或网络代码存储在这里。把这看作是应用程序的本质。</li><li id="ac61" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">网络:共享资源的一组计算机或计算机设备。</li><li id="1d4b" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">协议:适合某项功能的方法、属性和需求的蓝图。</li><li id="9466" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">结果类型:表示成功或失败的值，包括每种情况下的关联值。</li><li id="010e" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">URL:统一资源定位器。网页或资源的地址。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="37ef" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">HTTPManager</h1><p id="ac1e" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">这都是关于将<code class="fe nk nl nm nn b">HTTPManager</code>分离成与视图和视图控制器分离的代码，以使这些功能可测试和可重用。</p><p id="24f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一件好事，因为从互联网下载是大多数应用程序都需要做的事情，而且你肯定希望有一套经过良好测试的功能来完成这些基本但(相当)棘手的测试任务。</p><p id="667e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不希望读者在我们进行的过程中在Xcode中输入这么多代码。为了帮助解决这个问题，我创建了一个Git存储库(在GitHub 上是<a class="ae ky" href="https://github.com/stevencurtis/BasicHTTPManager" rel="noopener ugc nofollow" target="_blank">)。</a></p><p id="4533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请继续阅读…</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="179b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">HTTPManager</h1><h2 id="7463" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">HTTPManager的使用</h2><p id="d1b9" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">HTTPManager类用于将任何特定应用程序中的网络代码与表示代码分开。</p><h2 id="60ed" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">创建一个协议</h2><p id="6b5b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">如果我们知道<code class="fe nk nl nm nn b">HTTPManager</code>被建议做什么，我们就可以建立一个经理会遵守的<code class="fe nk nl nm nn b">protocol</code>。</p><p id="0af8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，符合一个<code class="fe nk nl nm nn b">protocol</code>的原因是双重的。</p><ul class=""><li id="f243" class="mu mv it lb b lc ld lf lg li od lm oe lq of lu nb nc nd ne bi translated">我们可以在编写<code class="fe nk nl nm nn b">class</code>之前定义<code class="fe nk nl nm nn b">HTTPManager</code>的功能，并确保我们的管理器符合这个<code class="fe nk nl nm nn b">protocol</code>。</li><li id="fb59" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">我们可以交换<code class="fe nk nl nm nn b">HTTPManager</code>的实现来增强我们的测试过程。</li></ul><p id="301f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我实现了一个接口，其中<code class="fe nk nl nm nn b">HTTPManager</code>将从<code class="fe nk nl nm nn b">URL</code>获得结果，并返回Swift的<code class="fe nk nl nm nn b">Result type</code>。在这种情况下，我没有指定灵活的错误类型，只是使用了Swift的<code class="fe nk nl nm nn b">Error</code>类型。</p><p id="f965" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协议中的<code class="fe nk nl nm nn b">associatedtype</code>允许我们稍后在代码中用具体类型填充会话。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="2233" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">符合协议</h2><p id="1bae" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">这意味着我们必须通过扩展来强制<code class="fe nk nl nm nn b">HTTPManager</code>符合<code class="fe nk nl nm nn b">protocol</code>类。</p><pre class="kj kk kl km gt oi nn oj ok aw ol bi"><span id="cf24" class="nr md it nn b gy om on l oo op">extension HTTPManager : HTTPManagerProtocol {}</span></pre><p id="1516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">精彩！然后我们可以对<code class="fe nk nl nm nn b">HTTPManager</code>进行编码。</p><h2 id="2bef" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">定义HTTPManager</h2><p id="f735" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">简单的<code class="fe nk nl nm nn b">HTTPManager</code>使用简单的<code class="fe nk nl nm nn b">dataTask</code>将<code class="fe nk nl nm nn b">URL</code>的内容下载到你的设备上。</p><p id="c4d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经在模拟器上多次运行相同的代码，所以我将缓存策略设置为<code class="fe nk nl nm nn b">reloadIgnoringLocalCacheData</code>，以便每次都下载<code class="fe nk nl nm nn b">URL</code>的内容。</p><p id="761b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果状态码在<code class="fe nk nl nm nn b">200</code>和<code class="fe nk nl nm nn b">299</code>范围内(响应成功)，<code class="fe nk nl nm nn b">Result Type</code>返回数据。</p><p id="53b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当然，如果由<code class="fe nk nl nm nn b">dataTask</code>处理的<code class="fe nk nl nm nn b">URL</code>返回无效响应，我们返回我们的<code class="fe nk nl nm nn b">error</code>(它已经有一个选项<code class="fe nk nl nm nn b">invalidResponse(Data?, URLResponse?)</code>，这很好)。</p><p id="eaab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nn b">HTTPManager</code>类本身被<code class="fe nk nl nm nn b">protocol</code>的关联类型所绑定，这意味着<code class="fe nk nl nm nn b">URLProtocol</code>实例可以被生产代码中的<code class="fe nk nl nm nn b">URLSession</code>或测试代码中的<code class="fe nk nl nm nn b">URLSessionMock</code>所替代。</p><p id="dc44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从某种意义上说，除了缓存被设置为忽略60秒超时的本地缓存之外，其余大部分代码都是样板文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="d5d5" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">调用HTTPManager</h2><p id="2db0" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们从视图控制器中取出<code class="fe nk nl nm nn b">HTTPManager</code>。为了提高可测试性，我们有一个单独的<code class="fe nk nl nm nn b">downloadData</code>函数。</p><p id="3948" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nn b">downloadData</code>函数有一个受<code class="fe nk nl nm nn b">HTTPManagerProtocol</code>约束的参数(由于相关联的类型),并返回带有来自<code class="fe nk nl nm nn b">URL</code>的数据的<code class="fe nk nl nm nn b">result type</code>,在<code class="fe nk nl nm nn b">HTTPManager</code>中执行get。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="3d16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，它使用<code class="fe nk nl nm nn b">URLSession</code>，并且在生产代码中使用<code class="fe nk nl nm nn b">URLSession.shared</code>(它是<code class="fe nk nl nm nn b">URLSession</code>的单例实例)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="391c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">URLSession</h1><p id="3810" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe nk nl nm nn b">URLSession</code>发送和接收请求，本质上是为了API下载数据。</p><h2 id="ba73" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">符合协议</h2><p id="2c12" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">以类似于为<code class="fe nk nl nm nn b">HTTPManager</code>创建协议的方式，<code class="fe nk nl nm nn b">URLSession</code>可以遵循协议来启用依赖注入。</p><p id="5d1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该协议在以下代码段中定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="8672" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们让<code class="fe nk nl nm nn b">URLSession</code>符合它。</p><pre class="kj kk kl km gt oi nn oj ok aw ol bi"><span id="33ae" class="nr md it nn b gy om on l oo op">extension URLSession: URLSessionProtocol {}</span></pre><p id="16d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，由于<code class="fe nk nl nm nn b">URLSession</code>是一个<code class="fe nk nl nm nn b">foundation</code>类，我们不需要实现它，然而，我们将在本文后面实现一个<code class="fe nk nl nm nn b">mock</code>类。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8a19" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">URLSessionDataTask</h1><p id="beb1" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe nk nl nm nn b">URLSessionDataTask</code>将符合一个协议，这指定了任何符合协议的东西都需要实现resume方法。</p><pre class="kj kk kl km gt oi nn oj ok aw ol bi"><span id="1710" class="nr md it nn b gy om on l oo op">protocol URLSessionDataTaskProtocol {<br/>    func resume()<br/>}</span></pre><p id="d00b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是:</p><pre class="kj kk kl km gt oi nn oj ok aw ol bi"><span id="ef67" class="nr md it nn b gy om on l oo op">extension URLSessionDataTask: URLSessionDataTaskProtocol {}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="62ab" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">端点模型</h1><p id="63ee" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">现在我们使用<code class="fe nk nl nm nn b">Codable</code>创建一个<code class="fe nk nl nm nn b">model</code>来允许我们解码数据，所以我们开发了一个<code class="fe nk nl nm nn b">EndPointModel</code>来做这件事(然后被<code class="fe nk nl nm nn b">httpManager</code>调用)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="39c4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实例化HTTPManager</h1><p id="c9ae" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们需要实例化<code class="fe nk nl nm nn b">URLSession</code>和<code class="fe nk nl nm nn b">HTTPManager</code>。在这里，我们通过我们的<code class="fe nk nl nm nn b">URL</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="6d9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得实际运行这个项目并看到它从URL下载成为可能:</p><pre class="kj kk kl km gt oi nn oj ok aw ol bi"><span id="0d84" class="nr md it nn b gy om on l oo op">https://docs.google.com/uc?export=download&amp;id=0Bz-w5tutuZIYeDU0VDRFWG9IVUE</span></pre><p id="f457" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，选择这个<code class="fe nk nl nm nn b">URL</code>只是因为这个特定的文件相当大。</p><p id="7a6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嘿，你。为什么不下载Git链接，看看它是如何从<a class="ae ky" href="https://github.com/stevencurtis/BasicHTTPManager" rel="noopener ugc nofollow" target="_blank"> GitHub </a>运行的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="237f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">测试经理</h1><p id="f4cb" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">使用依赖注入来模拟代码的不同部分有点复杂，从这里开始，我将使用gists来展示所有内容的实现，因为这样更容易阅读。</p><p id="5e28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了检查响应(不是来自网络，而是我们的响应),我创建了一些JSON响应；这里没有技巧，只是一些带有预期响应的格式正确的JSON字符串。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="31ee" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">URLSessionMock</h2><p id="cca5" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">为了符合<code class="fe nk nl nm nn b">URLSessionProtocol</code>，<code class="fe nk nl nm nn b">URLSessionMock</code>需要实现<code class="fe nk nl nm nn b">dataTask(with url:)</code>和<code class="fe nk nl nm nn b">dataTask(with request:)</code>。</p><p id="b4fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意每一个<code class="fe nk nl nm nn b">dataTask</code>方法都返回<code class="fe nk nl nm nn b">URLSessionDataTaskMock</code>，它是用于<code class="fe nk nl nm nn b">URLSessionProtocol</code>中相关类型的对象。</p><p id="30af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实践中，实现简单地返回<code class="fe nk nl nm nn b">URLSessionDataTaskMock</code>，它本身必须实现<code class="fe nk nl nm nn b">resume()</code>，以及通过<code class="fe nk nl nm nn b">completionHandler</code>给出的大部分数据，因此，逻辑并不太复杂，但是代码(嗯)可以更简单。</p><p id="e32e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有一个错误(您希望返回)，您可以在实例上设置它(我知道这不是很优雅)，如<code class="fe nk nl nm nn b">HTTPManagerTests</code>所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="893b" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated"><strong class="ak"> URLSessionDataTaskMock </strong></h2><p id="c431" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe nk nl nm nn b">resume()</code>的实现不做任何事情，只是返回在<code class="fe nk nl nm nn b">URLSessionDataTaskMock</code>的初始化器中设置的闭包。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="02e4" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">HTTPManagerTests —避免进行网络调用</h2><p id="a29d" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">可以通过注入<code class="fe nk nl nm nn b">URLSessionMock</code>来测试<code class="fe nk nl nm nn b">HTTPManager</code>，因此我们<em class="oq">而不是</em>进行网络调用。</p><p id="53d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试要返回的特定数据的机制并不复杂，但是我们当然需要测试<a class="ae ky" href="https://medium.com/@stevenpcurtis.sc/how-to-test-asynchronous-functions-using-expectation-2c9183fd99c9" rel="noopener">异步调用</a>并处理<a class="ae ky" href="https://medium.com/@stevenpcurtis.sc/result-type-in-swift-1b4e2a84f2c2" rel="noopener">结果类型</a>，尽管我们确实需要将数据类型解码为字符串。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="18f6" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">视图控制测试</h2><p id="18d4" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">因为<code class="fe nk nl nm nn b">HTTPManager</code>是从viewcontroller中的一个单独的方法实例化的，所以它可以被测试。</p><p id="1598" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，很清楚(希望如此),如果您使用MVVM或类似的，您可能不会从视图控制器中进行实例化，但是，本教程有一些限制——所以我们从那里进行实例化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="152f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能够注入a <code class="fe nk nl nm nn b">HTTPManager</code>，我们再次知道它调用了mock <code class="fe nk nl nm nn b">URLSession</code>，所以我们不会进行网络调用。</p><p id="f4c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe nk nl nm nn b">HTTPManagerMock</code>的定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="5409" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，我的测试覆盖率已经达到了76.5% ，也就是说<em class="oq">几乎</em>足够好了(取决于你在哪里工作)。我认为我可以做得更好——我认为你可以做得更好——我对你接近100%测试覆盖率的方法很感兴趣。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1726" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="0a62" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">拥有一个能够从一个<code class="fe nk nl nm nn b">URL</code>下载的<code class="fe nk nl nm nn b">HTTPManager</code>显然是一件好事——拥有一个经过良好测试和良好记录的可以重用的<code class="fe nk nl nm nn b">class</code>真的很重要。</p><p id="4b60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将会用到它，因此锁定和加载这个类并准备好使用它是非常值得的。</p><p id="872e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这个教程已经给了你这样一个类的能力。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="45b7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Git链接</h1><p id="39fe" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我不期望任何人根据前面的解释来编码所有的东西。因此，我提供了一个已经完成的工作的Git链接！</p><div class="or os gp gr ot ou"><a href="https://github.com/stevencurtis/BasicHTTPManager" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">stevencurtis/BasicHTTPManager</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">基本的HTTPManager。在GitHub上创建一个帐户，为stevencurtis/BasicHTTPManager的开发做出贡献。</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">github.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c0e0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">扩展你的知识</h1><ul class=""><li id="fa99" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated">苹果有一份<code class="fe nk nl nm nn b"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/urlsession/1410330-datatask" rel="noopener ugc nofollow" target="_blank">dataTask(with:completionHandler:)</a></code>的文档。</li><li id="d61c" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">苹果对<code class="fe nk nl nm nn b"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/urlsession/1411511-downloadtask" rel="noopener ugc nofollow" target="_blank">downloadTask(with:completionHandler:)</a></code>有进一步的文档。</li><li id="20d0" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" rel="noopener ugc nofollow" target="_blank"> HTTP响应状态码</a>。</li></ul></div></div>    
</body>
</html>