<html>
<head>
<title>The State of Functional Reactive Programming in iOS: RxSwift vs. Combine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS中函数式反应式编程的现状:RxSwift与Combine</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-state-of-functional-reactive-programming-on-ios-comparaison-between-the-open-source-framework-126b7ec15658?source=collection_archive---------9-----------------------#2022-03-22">https://betterprogramming.pub/the-state-of-functional-reactive-programming-on-ios-comparaison-between-the-open-source-framework-126b7ec15658?source=collection_archive---------9-----------------------#2022-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0887" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">开源框架RxSwift与原生框架Combine的比较</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ac5650461ee722829f0e3814daf5b3bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kDA2xJ7p5Ky0WEKYfJSgYA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">资料来源:undraw.co</p></figure><p id="4a0c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先要从解释什么是反应式编程开始。这是维基百科上定义的第一段:</p><blockquote class="lr ls lt"><p id="4a6b" class="kv kw lu kx b ky kz jr la lb lc ju ld lv lf lg lh lw lj lk ll lx ln lo lp lq ij bi translated">在<a class="ae ly" href="https://en.wikipedia.org/wiki/Computing" rel="noopener ugc nofollow" target="_blank">计算</a>中，<strong class="kx ir">反应式编程</strong>是一种<a class="ae ly" href="https://en.wikipedia.org/wiki/Declarative_programming" rel="noopener ugc nofollow" target="_blank">声明式</a> <a class="ae ly" href="https://en.wikipedia.org/wiki/Programming_paradigm" rel="noopener ugc nofollow" target="_blank">编程范式</a>与<a class="ae ly" href="https://en.wikipedia.org/wiki/Stream_(computing)" rel="noopener ugc nofollow" target="_blank">数据流</a>和变化的传播有关。有了这个范例，就有可能轻松地表达静态(例如，数组)或动态(例如，事件发射器)数据流，并且还传达相关联的执行模型内存在推断出的依赖性，这有助于自动传播改变的数据流</p></blockquote><p id="58ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个概念很简单:我们有数据发射器和数据接收器，在它们之间，我们应用操作符来修改、转换和处理这些数据。另一种说法是，它随着时间的推移处理值。</p><p id="7dd4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些值可能来自网络响应或用户界面事件。反应式编程的概念是对完成块或委托的直接替换。这将产生一个更干净、更易维护的数据管道。如果使用得当，它可能是一种非常强大的编程方法。</p><p id="21d0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Swift中，进行反应式编程的两种主要方法是称为Combine和RxSwift的框架。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="255e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">联合收割机演示</h1><p id="da73" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">苹果在2019年WWDC期间大量引入了SwiftUI，但他们几乎没有说的是，有一个完整的框架为它提供动力:Combine。这是一个巨大的新框架，技术性太强，不能成为头条新闻，但它标志着苹果哲学的一个重大变化，从声明式到功能反应式的方法。你可以从iOS 13开始使用它，尽管它与SwiftUI密切相关，但你仍然可以将其与UIKit配对。</p><p id="f316" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一些基金会类型通过发布者公开他们的功能，包括<code class="fe nd ne nf ng b"><a class="ae ly" href="https://developer.apple.com/documentation/foundation/timer" rel="noopener ugc nofollow" target="_blank">Timer</a></code>、<code class="fe nd ne nf ng b"><a class="ae ly" href="https://developer.apple.com/documentation/foundation/notificationcenter" rel="noopener ugc nofollow" target="_blank">NotificationCenter</a></code>和<code class="fe nd ne nf ng b"><a class="ae ly" href="https://developer.apple.com/documentation/foundation/urlsession" rel="noopener ugc nofollow" target="_blank">URLSession</a></code>。Combine还为任何符合键值观察的属性提供了一个内置的发布器。</p><p id="d1f5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请随意查看关于联合收割机的苹果文档。</p><h1 id="97cf" class="mg mh iq bd mi mj nh ml mm mn ni mp mq jw nj jx ms jz nk ka mu kc nl kd mw mx bi translated">RxSwift演示</h1><p id="5666" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">RxSwift是一个开源框架。从iOS 8开始就可以用了。这是一个很大的优势，因为您现在可以安全地开始将它集成到您的项目中，而您可能需要等待一两年才能让Combine支持更多的iOS版本。</p><p id="2b6c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个非常受欢迎的框架，有一个很大的社区围绕着它，所以找到帮助和文档一点也不困难。首先查看主<a class="ae ly" href="https://github.com/ReactiveX/RxSwift" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>，在那里你会找到他们所有的主要文档。</p><h1 id="8407" class="mg mh iq bd mi mj nh ml mm mn ni mp mq jw nj jx ms jz nk ka mu kc nl kd mw mx bi translated">我们来对比一下！</h1><h2 id="52c8" class="nm mh iq bd mi nn no dn mm np nq dp mq le nr ns ms li nt nu mu lm nv nw mw nx bi translated">关于发射器</h2><p id="5c5c" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated"><strong class="kx ir"> Combine </strong> : <code class="fe nd ne nf ng b">Publisher</code>是一个协议，它定义了一个类型能够随时间向一个或多个订户传输一系列值的要求。这有点类似于<code class="fe nd ne nf ng b">NotificationCenter</code>正在做的事情，除了它当然是以一种更好更可读的方式完成的。你可以创建你自己的，但是苹果也在它的<a class="ae ly" href="https://developer.apple.com/documentation/combine/publishers" rel="noopener ugc nofollow" target="_blank"> enum </a>中提供了一整套预制的发布器。</p><pre class="kg kh ki kj gt ny ng nz oa aw ob bi"><span id="4c5d" class="nm mh iq ng b gy oc od l oe of"><strong class="ng ir">let</strong> publisher = NotificationCenter.default<br/>               .publisher(for: NSControl.textDidChangeNotification,<br/>                object: filterField)</span></pre><p id="0e94" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> RxSwift </strong>:它们被称为<code class="fe nd ne nf ng b">Observable</code>。这是一个流(实际上不发出)<code class="fe nd ne nf ng b">Event</code>的类，然后由<code class="fe nd ne nf ng b">Observers</code>接收。稍后会详细介绍。</p><pre class="kg kh ki kj gt ny ng nz oa aw ob bi"><span id="3271" class="nm mh iq ng b gy oc od l oe of"><strong class="ng ir">let</strong> name: String = "Peter"<br/><strong class="ng ir">let</strong> observable = Observable&lt;String&gt;.just(name)</span></pre><h2 id="3c3e" class="nm mh iq bd mi nn no dn mm np nq dp mq le nr ns ms li nt nu mu lm nv nw mw nx bi translated">关于接收者</h2><p id="6260" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated"><strong class="kx ir">组合</strong> : <code class="fe nd ne nf ng b">Subscriber</code>是一个协议，定义了一个类型能够从<code class="fe nd ne nf ng b">Publisher</code>接收输入的要求。</p><pre class="kg kh ki kj gt ny ng nz oa aw ob bi"><span id="c92c" class="nm mh iq ng b gy oc od l oe of"><strong class="ng ir">let</strong> subscriber = NotificationCenter.default<br/>                .publisher(for: NSControl.textDidChangeNotification,<br/>                 object: filterField)<br/>                .sink(receiveCompletion: { print ($0) },<br/>                 receiveValue: { print ($0) })</span></pre><p id="31d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> RxSwift </strong> : <code class="fe nd ne nf ng b">Observer</code>直接订阅<code class="fe nd ne nf ng b">Observable</code>。不像<code class="fe nd ne nf ng b">NotificationCenter</code>，开发者通常只使用它的<code class="fe nd ne nf ng b">.default</code>单例实例，Rx中的每个可观察对象都是不同的。此外，知道一个可观察对象在拥有订阅者之前不会流处理事件或执行任何工作是非常重要的。</p><pre class="kg kh ki kj gt ny ng nz oa aw ob bi"><span id="b799" class="nm mh iq ng b gy oc od l oe of"><strong class="ng ir">let</strong> name: String = "Peter"<br/><strong class="ng ir">let</strong> observable = Observable&lt;String&gt;.just(name)</span><span id="0250" class="nm mh iq ng b gy og od l oe of">observable.subscribe { event <strong class="ng ir">in</strong>   <br/>    print(event)<br/>}</span></pre><p id="67f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">总的来说，您有许多名称或多或少相同的操作符。<a class="ae ly" href="https://twitter.com/freak4pc" rel="noopener ugc nofollow" target="_blank"> Shai Mishali </a>制作了这个非常方便的<a class="ae ly" href="https://github.com/CombineCommunity/rxswift-to-combine-cheatsheet" rel="noopener ugc nofollow" target="_blank">电子表格</a>来帮助你。</p><h2 id="7971" class="nm mh iq bd mi nn no dn mm np nq dp mq le nr ns ms li nt nu mu lm nv nw mw nx bi translated">背压</h2><p id="2dca" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">联合收割机支持反压，但RxSwift不是这样的。在ReactiveX中，很容易出现这样一种情况:一个<code class="fe nd ne nf ng b">Observable</code>正在以超过操作员或观察者消费速度的速度传输物品。你仍然可以用冷观测值来控制，当观测者觉得方便的时候，以观测者想要的任何速率流动一个序列，而不会破坏序列的完整性。</p><h2 id="476e" class="nm mh iq bd mi nn no dn mm np nq dp mq le nr ns ms li nt nu mu lm nv nw mw nx bi translated">错误类型</h2><p id="6983" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">当RxSwift使用简单的<code class="fe nd ne nf ng b">Error</code>类型时，Combine需要特定的错误类型。在联合收割机方面，这听起来可能是一项更艰巨的任务，但我认为这是一项更好的任务。错误管理是至关重要的，被“强迫”去做你的自定义<code class="fe nd ne nf ng b">Error</code>类型将会产生更好的错误日志。</p><h2 id="13aa" class="nm mh iq bd mi nn no dn mm np nq dp mq le nr ns ms li nt nu mu lm nv nw mw nx bi translated">内存管理</h2><p id="5373" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">RxSwift有一个非常方便的系统，叫做Dispose Bag。observables的所有订阅都由一个唯一的对象持有，这允许我们更有效地管理这些订阅的生命周期。也就是说，订阅也适用于ARC。当订阅完成或由于错误而完成时，订阅总是被dealloc。</p><pre class="kg kh ki kj gt ny ng nz oa aw ob bi"><span id="43d9" class="nm mh iq ng b gy oc od l oe of"><strong class="ng ir">let</strong> disposeBag <strong class="ng ir">=</strong> DisposeBag()</span><span id="2960" class="nm mh iq ng b gy og od l oe of"><strong class="ng ir">let</strong> name: String = "Peter"<br/><strong class="ng ir">let</strong> observable = Observable&lt;String&gt;.just(name)</span><span id="e670" class="nm mh iq ng b gy og od l oe of">observable.subscribe { event <strong class="ng ir">in</strong>   <br/>    print(event)<br/>}<strong class="ng ir">.</strong>addDisposableTo(disposeBag)</span></pre><p id="a795" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于联合收割机来说，叫做<code class="fe nd ne nf ng b">Cancellable</code>。所有订阅都是单独管理的。这需要更多的努力，但是为了获得对我们代码的更多控制和可能的性能改进，因为在<code class="fe nd ne nf ng b">DisposeBag</code>的罩下有许多操作</p><pre class="kg kh ki kj gt ny ng nz oa aw ob bi"><span id="b2d2" class="nm mh iq ng b gy oc od l oe of"><strong class="ng ir">private</strong> <strong class="ng ir">var</strong> cancellable: AnyCancellable?</span><span id="387d" class="nm mh iq ng b gy og od l oe of"><strong class="ng ir">self</strong>.cancellable = subject<br/>                  .sink { value <strong class="ng ir">in</strong>       <br/>                      print(value)<br/>                   }</span></pre><h2 id="b458" class="nm mh iq bd mi nn no dn mm np nq dp mq le nr ns ms li nt nu mu lm nv nw mw nx bi translated">演出</h2><p id="38c6" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">苹果在设计时考虑到了性能方面。引用一位苹果工程师的话:<em class="lu">“rx swift和Combine的内存型号差别很大。联合收割机是专为性能而生的。”</em>它的规格几乎是RxSwift的两倍，允许苹果将Combine集成到RealityKit等高性能要求的框架中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/84677a018a822e4cc7b994733b096c43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BPiEEdVtWg6y04iQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">两个框架之间相似方法执行的比较(图由斯蒂芬·屈夫勒绘制)</p></figure><h1 id="2b7f" class="mg mh iq bd mi mj nh ml mm mn ni mp mq jw nj jx ms jz nk ka mu kc nl kd mw mx bi translated">结论</h1><p id="22c9" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">双方都有很强的理由使用这种或那种框架。总的来说，如果你想使用原生集成到iOS的东西，如果你不需要支持iOS 13之前的iOS版本，请使用Combine。这也将导致性能的提高。</p><p id="cf59" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一方面，RxSwift覆盖了更广泛的iOS版本，也有更大的社区和更多的指南/示例/内容。</p><p id="cd68" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但重要的问题是:要不要转行做反应式编程？它将彻底改变你对数据流和架构的看法，对于你选择的框架，它将是一种更现代、更安全、更不容易出错的方法。</p></div></div>    
</body>
</html>