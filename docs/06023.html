<html>
<head>
<title>Are CSRFs Still a Thing?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CSRFs还是一个东西吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/are-csrfs-still-a-thing-7e16c09c951a?source=collection_archive---------7-----------------------#2020-08-26">https://betterprogramming.pub/are-csrfs-still-a-thing-7e16c09c951a?source=collection_archive---------7-----------------------#2020-08-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6f21" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">默认情况下，SameSite对CSRFs的未来意味着什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aba6d771ccff976e822836d9a096b824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uwm_kmdafvmozBJM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@mak_jp?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mak </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="a2bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/swlh/intro-to-csrf-cross-site-request-forgery-9de669df03de" rel="noopener"> CSRF漏洞</a>发生在攻击者可以从外部域发起伪造的状态改变请求时。这通常是因为无论请求来自何处，用户的浏览器都会发送会话cookies。</p><p id="371c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了实现CSRF令牌来确保请求的真实性，另一种防范CSRF的方法是<code class="fe lv lw lx ly b">SameSite</code>cookie。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a957" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">SameSite Cookies</h1><p id="5c96" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">web应用程序通过一个<code class="fe lv lw lx ly b">Set-Cookie</code>头指示用户的浏览器设置cookies。例如，这个头将使客户端浏览器将cookie的值<code class="fe lv lw lx ly b">PHPSESSID</code>设置为<code class="fe lv lw lx ly b">UEhQU0VTU0lE</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="da99" class="nh mh it ly b gy ni nj l nk nl">Set-Cookie: PHPSESSID=UEhQU0VTU0lE</span></pre><p id="208f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了基本的“cookie_name=cookie_value”标志之外，<code class="fe lv lw lx ly b">Set-Cookie</code>头还允许使用几个可选标志来保护用户的cookie。其中之一是<code class="fe lv lw lx ly b">SameSite</code>旗，它有助于防止CSRF袭击。当cookie上的<code class="fe lv lw lx ly b">SameSite</code>标志设置为<code class="fe lv lw lx ly b">Strict</code>时，客户端的浏览器将不会在跨站点请求期间发送cookie。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="5d4f" class="nh mh it ly b gy ni nj l nk nl">Set-Cookie: PHPSESSID=UEhQU0VTU0lE; Max-Age=86400; Secure; HttpOnly; SameSite=Strict</span></pre><p id="f9a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">SameSite</code>标志的另一个可能设置是<code class="fe lv lw lx ly b">Lax</code>。这个设置告诉客户端的浏览器只在引起顶级导航的<code class="fe lv lw lx ly b">GET</code>请求中发送cookie。如果跨网站请求是有意的，此设置可确保用户仍然可以访问您网站上的资源。</p><p id="04a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您从第三方网站导航到脸书，您的脸书登录帐户将被发送。但是如果一个第三方网站向脸书发起一个<code class="fe lv lw lx ly b">POST</code>请求或者试图在Iframe中嵌入脸书的内容，cookies将不会被发送。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6479" class="nh mh it ly b gy ni nj l nk nl">Set-Cookie: PHPSESSID=UEhQU0VTU0lE; Max-Age=86400; Secure; HttpOnly; SameSite=Lax</span></pre><p id="53a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">指定<code class="fe lv lw lx ly b">SameSite</code>属性可以很好地防止CSRF，因为<code class="fe lv lw lx ly b">Strict</code>和<code class="fe lv lw lx ly b">Lax</code>设置都将阻止浏览器在跨站点表单<code class="fe lv lw lx ly b">POST</code>、<code class="fe lv lw lx ly b">AJAX</code>请求中以及在iframes和image标签中发送cookies。这使得经典的CSRF隐藏形式攻击变得无用。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="242e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">默认情况下相同的站点</h1><p id="0fc9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">今年早些时候，Chrome和其他一些浏览器将<code class="fe lv lw lx ly b">SameSite=Lax</code>设为默认cookie设置，如果web应用程序没有明确设置的话。这意味着，即使web应用程序没有实现CSRF保护，攻击者也无法使用后CSRF技术攻击使用Chrome浏览器的受害者。</p><p id="146b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在未来，经典的CSRF攻击的效力将大大降低，因为Chrome拥有最大的网络浏览器市场份额。</p><p id="3606" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Firefox上，<code class="fe lv lw lx ly b">SameSite by default</code>设置是一个需要启用的特性。你可以通过进入<code class="fe lv lw lx ly b">about:config</code>并将<code class="fe lv lw lx ly b">network.cookie.sameSite.laxByDefault</code>设置为<code class="fe lv lw lx ly b">true</code>来启用它。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8abe" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">CSRF还有可能吗？</h1><p id="2e16" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">是的。即使浏览器采用了<code class="fe lv lw lx ly b">SameSite by default</code>策略，CSRFs在某些情况下仍然是可能的。</p><p id="35ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，如果站点允许使用<code class="fe lv lw lx ly b">GET</code> HTTP方法的状态改变请求，那么第三方站点可以通过使用<code class="fe lv lw lx ly b">GET</code>请求创建CSRF来攻击用户。</p><p id="fa2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果网站允许你通过<code class="fe lv lw lx ly b">GET</code>请求更改密码，攻击者可以在论坛中嵌入这样的链接，诱骗用户点击它:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="cbe0" class="nh mh it ly b gy ni nj l nk nl"><a class="ae ky" href="https://email.example.com/password_change?new_password=abc123" rel="noopener ugc nofollow" target="_blank">https://email.example.com/password_change?new_password=abc123</a></span></pre><p id="96bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，由于点击链接将导致顶级导航，用户的会话cookies将被包括在<code class="fe lv lw lx ly b">GET</code>请求中，CSRF攻击将会成功。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="281d" class="nh mh it ly b gy ni nj l nk nl">GET /password_change?new_password=abc123<br/>Host: email.example.com<br/>Cookie: session_cookie=YOUR_SESSION_COOKIE</span></pre><p id="e161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个场景是站点手动将cookie的<code class="fe lv lw lx ly b">SameSite</code>属性设置为<code class="fe lv lw lx ly b">None</code>。一些web应用程序具有要求第三方站点发送跨站点、经过身份验证的请求的功能。在这种情况下，开发人员可能会显式地将会话cookie上的<code class="fe lv lw lx ly b">SameSite</code>设置为<code class="fe lv lw lx ly b">None</code>。当<code class="fe lv lw lx ly b">SameSite</code>属性设置为<code class="fe lv lw lx ly b">None</code>时，允许跨来源发送cookie，因此传统的CSRF攻击仍然有效。</p><p id="dc39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，如果受害者使用的浏览器在默认情况下没有将<code class="fe lv lw lx ly b">SameSite</code>属性设置为<code class="fe lv lw lx ly b">Lax</code>(如IE和Safari ),如果目标应用程序没有实施尽职的CSRF保护，传统的CSRF攻击仍然会起作用。</p></div></div>    
</body>
</html>