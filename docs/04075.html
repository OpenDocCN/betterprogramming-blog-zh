<html>
<head>
<title>Social Sharing With React and Vue Without Pre-Rendering or SSR</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React和Vue进行社交分享，无需预渲染或SSR</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/social-sharing-with-react-and-vue-without-pre-rendering-or-ssr-13f24cafa07c?source=collection_archive---------4-----------------------#2020-03-22">https://betterprogramming.pub/social-sharing-with-react-and-vue-without-pre-rendering-or-ssr-13f24cafa07c?source=collection_archive---------4-----------------------#2020-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5ed7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">向爬虫发送带有相关元标签的简化HTML文件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/29fae30bbc89fe359f0ad0186a19031b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K6jdNIVdbtHOqti3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@impatrickt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">帕特里克·托马索</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f521" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你刚刚构建了你的Vue.js或React.js应用程序，包括一个不错的API，部署它，并希望你的用户在脸书、Twitter等上共享一个URL。？哎呀，如果你认为流行的社交媒体网站使用的爬虫可以抓取你的JavaScript构建的单页面应用程序，你会失望的。</p><p id="1eec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，他们不能。Googlebot是唯一不会停在你的<code class="fe lv lw lx ly b">index.html</code>文件上的主要爬虫。截至2020年初，所有其他爬虫都不会执行您的JavaScript，最终会出现一个“空白页面”，只有共享的链接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/edbbd030daf0c231d47f816b2c1f2909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ds6meef5x14VsD_zB0bcYg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自脸书网址检查器的截图，加载主图片、标题和链接…脸书只能从一个SPA抓取信息，如果你在一个静态HTML文件中提供相关的元标签</p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="80ad" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">预渲染和SSR不是解决这个问题的唯一解决方案</h1><h2 id="dc44" class="mz mi it bd mj na nb dn mn nc nd dp mr li ne nf mt lm ng nh mv lq ni nj mx nk bi translated">服务器端渲染</h2><p id="e3d4" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">一旦你谷歌一下这个问题，你会发现大多数博主和教程建议的解决方案是<a class="ae ky" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>和<a class="ae ky" href="https://nuxtjs.org/" rel="noopener ugc nofollow" target="_blank"> Nuxt.js </a>等框架和服务器端渲染(SSR)。</p><p id="af7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SSR是一种技术，每当用户或爬虫/机器人访问您的后端以请求特定的URL时，您的应用程序的所有URL都会呈现在您的服务器上。</p><p id="2fdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的后端不是发送引用您的JavaScript包和CSS的<code class="fe lv lw lx ly b">index.html</code>,而是发送一个通过运行虚拟浏览器动态创建的呈现的静态HTML。</p><p id="5f34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">爬虫在这一点上停止，因为它只是想从一个单一的URL获得信息。普通用户将看到静态HTML，然后他们的浏览器加载你的应用程序，从那时起，使用你的网站的JavaScript运行版本。</p><p id="7b4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">听起来很容易？嗯，可以，特别是对于在Next.js或Nuxt.js中从头构建的轻量级应用程序和网站。对于更复杂的应用程序或最初在此类框架外构建的应用程序，您可能会遇到各种实现SSR的问题。</p><h2 id="6a3a" class="mz mi it bd mj na nb dn mn nc nd dp mr li ne nf mt lm ng nh mv lq ni nj mx nk bi translated">预渲染或动态渲染</h2><p id="678a" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">因此，您可能会考虑通常用于解决该问题的其他选项:预渲染或动态渲染。对于您使用的所有静态页面，在部署应用程序之前预先渲染它们是一个非常简单的解决方案。</p><p id="4bc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这些页面不会改变，除非您手动改变并重新部署，所以您可以在每次部署时预先呈现它们，就像在服务器端呈现一样。</p><p id="783d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，在社交媒体网站上分享内容的用户通常不会分享简单的静态页面，如您的条款和条件或您的登录页面。</p><p id="9638" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户希望分享他们发现的内容——一篇博文、一篇文章或任何其他有趣的东西，让其他人知道他们发现了这些内容。如果这些页面是用户内容，它们的URL必然是动态创建的。这意味着无论何时部署应用程序，预渲染都不是一个可行的解决方案。</p><p id="49a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户生成的动态内容的答案是预渲染的一种变体——动态渲染。第三方网站如<a class="ae ky" href="http://www.prerender.io" rel="noopener ugc nofollow" target="_blank"> prerender.io </a>允许你预渲染10，000个网址，并动态添加新创建的网址。</p><p id="318e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些第三方网站还会定期抓取所有这些网址，查看是否有更新。与SSR相比，这并不是一个完美的解决方案(因为预先呈现的内容不可避免地会比页面的当前状态落后几天)，但对于大多数SPAs来说，它很容易设置，并且运行良好，可以毫无问题地进行社交共享。</p><p id="3cfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个额外的奖励，你可以让搜索引擎抓取器指向这些预先呈现的页面——特别是搜索引擎，如Bing或Yandex，它们不像Google，不执行JavaScript来索引网站。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="d61d" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">不涉及SSR框架或预渲染/动态渲染的第三种解决方案</h1><p id="33c0" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">当我搜索这个主题来实现我们的第一次迭代<a class="ae ky" href="http://www.epiloge.com" rel="noopener ugc nofollow" target="_blank"> Epiloge </a>时，我遇到了一个关于堆栈溢出的参考，它几乎是说:“只要给社交媒体爬虫他们想要的东西——元标签信息。”</p><p id="a3ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我很好奇这可能是一个更简单的解决问题的方法。然而，它既有缺点也有好处。</p><p id="9133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不担心谷歌之外的搜索引擎，只希望在脸书和Twitter等大型社交媒体网站上进行社交分享，这个解决方案可能适合你。</p><p id="350d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它几乎是一个简化的服务器端渲染解决方案，不需要Next.js或Nuxt.js。您创建的HTML页面带有一个<code class="fe lv lw lx ly b">&lt;head&gt;</code>标签、一个简化的主体以及社交共享爬虫可以读取的所有必需的元标签。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="ddbc" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">在节点后端实现第三种解决方案</h1><p id="e0e4" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">我们使用Node.js和Express作为Epiloge的后端服务器。如果您没有使用Node.js，您应该仍然能够使用下面描述的原则。它们可以直接集成到任何后端。</p><h2 id="e065" class="mz mi it bd mj na nb dn mn nc nd dp mr li ne nf mt lm ng nh mv lq ni nj mx nk bi translated">1.从后端为您的index.html提供服务，以使该解决方案发挥作用</h2><p id="bfde" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">如果您已经部署了Vue.js、React.js或其他SPA，并由用户直接从云平台(如亚马逊S3)访问，而不需要用户首先访问您的后端，这里介绍的解决方案将不起作用。</p><p id="61a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你需要所有访问你的网站的流量，在我们的例子中，我们的域名<a class="ae ky" href="http://www.epiloge.com" rel="noopener ugc nofollow" target="_blank">www.epiloge.com</a>，首先到达你的Node.js服务器。通过这种方式，您可以检查爬虫的用户代理输入流量，同时将您的<code class="fe lv lw lx ly b">index.html</code>作为静态文件提供给所有其他用户。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="04ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码很容易解释。插入一个新的快速路由，称之为类似于<code class="fe lv lw lx ly b">nonSPArouter</code>的东西，只处理爬虫攻击你的服务器。您可以检查最常见的爬虫的用户代理。</p><p id="9d78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我只包括了脸书和Twitter，但你可以添加更多，如LinkedInbot、Quora、Pinterest、Slackbot、Whatsapp、Telegram等。</p><h2 id="7f27" class="mz mi it bd mj na nb dn mn nc nd dp mr li ne nf mt lm ng nh mv lq ni nj mx nk bi translated">2.对于静态页面，对页面进行硬编码，并使用您喜欢的模板引擎提供服务</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5ef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用Jade 作为模板引擎。在我们的Node.js服务器文件中，我们用<code class="fe lv lw lx ly b">npm install jade</code>安装Jade，并将<code class="fe lv lw lx ly b">app.set(‘view engine’, ‘jade’)</code> <em class="ns"> </em>添加到<code class="fe lv lw lx ly b">server.js</code>文件中。</p><p id="2be7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是集成Jade并让它作为模板引擎工作所需的全部内容。在你的后端结构中的<code class="fe lv lw lx ly b">/views</code>下创建一个<code class="fe lv lw lx ly b">bot.jade</code>文件，你就可以提供静态HTML文件了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="97ec" class="mz mi it bd mj na nb dn mn nc nd dp mr li ne nf mt lm ng nh mv lq ni nj mx nk bi translated">3.对于动态页面，您需要首先从数据库中获取数据，然后将其包含在用Jade呈现的HTML中</h2><p id="3530" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">对于我们的应用程序，我们希望社交分享特别适用于人们在Epiloge上分享的项目、论文和文章的URL。</p><p id="1129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要做到这一点，我们首先需要获取标题、正文中包含的文本的开头以及相关的封面图片(如果有的话),以便在我们的<code class="fe lv lw lx ly b">bot.jade</code>模板文件中设置meta标签。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0fb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Jade模板引擎将呈现填充了我们从数据库中获得的信息的模板。然后，它会将呈现的静态HTML发送给爬虫，爬虫可以从其内容中解析任何社交共享所需的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/86afc43ecf7d35e65ab7054a8463eb39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G4d8GKdDP-fAvgML"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">就这样，不需要对你的网站做进一步的编码或修改(图片由<a class="ae ky" href="https://unsplash.com/@yerlinmatu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Yerlin Matu </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="1a6c" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">我们已经完成了</h1><p id="d8ed" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">就是这样，不需要很多代码，也不需要任何第三方框架、插件或服务，我们就可以让社交分享网站从分享的URL访问数据。诀窍是简单地传递一个带有元标签的基本HTML文件，他们可以从中抓取信息。</p><p id="cc40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种解决方案适合并推荐给你构建和部署的每个应用吗？</p><p id="bac7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大概不会。如果你有一个更复杂的应用程序，将社交分享和所有搜索引擎的搜索引擎索引作为成功的关键部分，你可能应该看看Nuxt.js或Next.js这样的框架。</p><p id="8f74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你只有几百个或者最多几万个动态URL，又不想用SSR…那就看看动态渲染吧。</p><p id="5ea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哦，顺便说一下，d <a class="ae ky" href="https://developers.google.com/search/docs/guides/dynamic-rendering" rel="noopener ugc nofollow" target="_blank">动态渲染</a>实际上是谷歌特别认可的，所以不要担心你不被允许这样做，你可以。</p><p id="38e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您已经构建了一个Vue.js或React.js，不想投入大量时间和精力将SSR集成到您的后端，不想为动态渲染而烦恼，或者需要爬虫随时访问当前数据，这第三个解决方案可能适合您。</p></div></div>    
</body>
</html>