<html>
<head>
<title>Creating an Opinionated Go GQL Server — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建自以为是的Go GQL服务器—第2部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-an-opinionated-go-gql-server-part-2-f049e4a9afe1?source=collection_archive---------13-----------------------#2019-07-15">https://betterprogramming.pub/creating-an-opinionated-go-gql-server-part-2-f049e4a9afe1?source=collection_archive---------13-----------------------#2019-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a18a9e6d4935f36f7de0ccc3ecfb9112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-CZwOR3WZ0HMr99HtZ3hTA.png"/></div></div></figure><p id="5e15" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一部分中，我们将把<a class="ae kz" href="https://gqlgen.com/getting-started/" rel="noopener ugc nofollow" target="_blank"> gqlgen </a>生成的服务器添加到我们的项目中，并开始<code class="fe la lb lc ld b">gql</code>运行！而且，我们将会比第一部中的动作快得多。</p><div class="le lf gp gr lg lh"><a href="https://medium.com/better-programming/creating-an-opinionated-gql-server-part1-8fad071e525f" rel="noopener follow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">创建自以为是的Go GQL服务器—第1部分</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">项目设置和初始步骤</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">medium.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv jz lh"/></div></div></a></div></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="cada" class="md me it bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">将gqlgen添加到项目中</h1><p id="d34a" class="pw-post-body-paragraph kb kc it kd b ke nb kg kh ki nc kk kl km nd ko kp kq ne ks kt ku nf kw kx ky im bi translated">现在，我们可以使用gqlgen来初始化我们的服务器的gqlgen生成的文件:<code class="fe la lb lc ld b">go run github.com/99designs/gqlgen init</code></p><p id="6b05" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将初始化gqlgen服务器。然而，我们必须进行修改以适应我们的项目布局。移动几个文件并编辑<code class="fe la lb lc ld b">gqlgen.yml</code>文件。</p><ul class=""><li id="5292" class="ng nh it kd b ke kf ki kj km ni kq nj ku nk ky nl nm nn no bi translated"><code class="fe la lb lc ld b">generated.go</code>(保存gqlgen生成的<a class="ae kz" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>服务器代码的文件。)</li><li id="ad22" class="ng nh it kd b ke np ki nq km nr kq ns ku nt ky nl nm nn no bi translated"><code class="fe la lb lc ld b">resolver.go</code>(保存查询和变异的解析器。)</li><li id="f9ba" class="ng nh it kd b ke np ki nq km nr kq ns ku nt ky nl nm nn no bi translated"><code class="fe la lb lc ld b">schema.graphql</code>(gqlgen生成的示例模式，我们将对其进行修改。)</li><li id="8216" class="ng nh it kd b ke np ki nq km nr kq ns ku nt ky nl nm nn no bi translated"><code class="fe la lb lc ld b">server/server.go</code>(我们将转储存根服务器，但我们将使用处理程序。)</li><li id="27c6" class="ng nh it kd b ke np ki nq km nr kq ns ku nt ky nl nm nn no bi translated"><code class="fe la lb lc ld b">models_gen.go</code>(生成的模型文件，以<code class="fe la lb lc ld b">schema.graphql</code>为基础)。)</li></ul><p id="1955" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们将要做一些可能违背直觉的事情。</p><p id="84d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们删除所有这些新文件，除了<code class="fe la lb lc ld b">gqlgen.yml</code>。相信我，我们会把它们找回来，放在它们该在的地方。</p><p id="f315" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有关gqlgen配置的更多信息，请阅读文档。</p><p id="8aea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们需要做的是修改<code class="fe la lb lc ld b">gqlgen.yml</code>文件，就像这样:</p><figure class="nu nv nw nx gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="17a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，我想自动生成gqlgen文件。</p><p id="3853" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们创建一个脚本，命名为:</p><figure class="nu nv nw nx gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="3f49" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为什么我还要删除解析程序文件？</p><p id="e051" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然是为了让它重生。如果我们要改变模式，很可能我们也要更新解析器。</p><p id="ae3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当项目很小的时候，最好把它们都放在一个文件中，但是我们要把解析器放在它们自己的文件中，并且把这个文件<code class="fe la lb lc ld b">internal/gql/resolvers/generated.go</code>作为gqlgen代之间的临时文件。这有点乏味，但以后会有回报的。</p><p id="f33c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，现在我们需要定义一个gql模式文件，这样我们就可以使用我们的脚本在正确的位置重新生成gqlgen文件。</p><p id="59b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe la lb lc ld b">$ mkdir -p internal/gql/schemas</code></p><p id="a603" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，您可以编辑一个<code class="fe la lb lc ld b">schema.graphql</code>文件<code class="fe la lb lc ld b">$ vi internal/gql/schemas/schema.graphql</code>，并在上面粘贴以下内容:</p><figure class="nu nv nw nx gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ed6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不要担心gql的细节，我们将在下一部分使用<a class="ae kz" href="https://openid.net/" rel="noopener ugc nofollow" target="_blank"> OpenID </a>规范对这个模式进行更多的改进。</p><p id="512e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们抓住<code class="fe la lb lc ld b">internal/gql/resolvers/generated.go</code>，稍微编辑一下，返回一个被嘲笑的用户:</p><figure class="nu nv nw nx gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="3778" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们将GraphQL服务器中间件绑定到我们的服务器。</p><p id="c2f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe la lb lc ld b">internal/handlers/gql.go</code>中创建一个文件，并将其粘贴到:</p><figure class="nu nv nw nx gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="851d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以这样修改<code class="fe la lb lc ld b">pkg/server/main.go</code>:</p><figure class="nu nv nw nx gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="d8d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，通过新的修改，我们设置了新的<code class="fe la lb lc ld b">ENV</code>变量:</p><figure class="nu nv nw nx gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7952" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些决定了我们的服务器将在哪里监听GraphQL处理程序，并为我们已经定义的查询和变化提供服务。</p><p id="2ae1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在尝试运行该程序:</p><figure class="nu nv nw nx gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="fc79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在可以看到GraphQL请求被重定向到它们的处理程序！</p><p id="e519" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们导航到<a class="ae kz" href="http://localhost:7777" rel="noopener ugc nofollow" target="_blank"> http://localhost:7777 </a>。</p><p id="cf1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们已经有了一个正常运行的GQL服务器，让我们试着查询一下。</p><p id="1008" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在可以看到，一切都在按预期运行。</p><p id="6124" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们继续做更好的事情，重构代码，使其更加有序。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="536f" class="md me it bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">重构代码</h1><p id="90d4" class="pw-post-body-paragraph kb kc it kd b ke nb kg kh ki nc kk kl km nd ko kp kq ne ks kt ku nf kw kx ky im bi translated">正如我之前提到的，我有一个为gqlgen组织代码的有效方法。</p><p id="e412" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将有助于将代码组织成小文件:</p><ul class=""><li id="6056" class="ng nh it kd b ke kf ki kj km ni kq nj ku nk ky nl nm nn no bi translated"><code class="fe la lb lc ld b">{entity_plural}.go</code>用我们的<code class="fe la lb lc ld b">gqlgen.sh</code>脚本生成的解析必须为每个<code class="fe la lb lc ld b">entity</code>(用户、帖子、评论，等等)单独复制。</li><li id="0fed" class="ng nh it kd b ke np ki nq km nr kq ns ku nt ky nl nm nn no bi translated">这个很有趣。一旦我们将<a class="ae kz" href="https://gorm.io/" rel="noopener ugc nofollow" target="_blank"> GORM </a>添加到我们的项目中，并且有了数据库结构，我们将不得不<em class="oa">将这些GQL输入类型</em>转换成要存储在<code class="fe la lb lc ld b">db</code>中的数据库表示。反之亦然，例如从<code class="fe la lb lc ld b">db</code>到<code class="fe la lb lc ld b">GQL</code>返回查询。</li><li id="e913" class="ng nh it kd b ke np ki nq km nr kq ns ku nt ky nl nm nn no bi translated">然后，我将从<code class="fe la lb lc ld b">internal/gql/resolvers/generated/generated.go</code>生成的内容移动到<code class="fe la lb lc ld b">internal/gql/resolvers/main.go</code>，并从我们可能有的实体方法中对其进行修剪。我是这样离开的:</li></ul><figure class="nu nv nw nx gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="dcd3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从现在开始，这个文件将不再有任何生成的更改，我们将更改一些东西，是的，但是那将在第3部分中完成:</p><div class="le lf gp gr lg lh"><a href="https://medium.com/@cmelgarejo.dev/creating-an-opinionated-go-gql-server-part-3-ca9f71980131" rel="noopener follow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">创建自以为是的Go GQL服务器—第3部分</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">这是一个系列的一部分，不适合初学者，但您可以从一开始就检查它:</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">medium.com</p></div></div><div class="lq l"><div class="ob l ls lt lu lq lv jz lh"/></div></div></a></div><p id="8d27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我还没有找到一种不用递归导入就能把文件夹结构组织成文件夹的方法，所以前缀将有助于组织<code class="fe la lb lc ld b">resolvers</code>文件夹中实体的文件名。</p><p id="0a1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我的TOC迫使我这样做。</p><p id="a26c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你有更好的安排方式，请告诉我。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="12dd" class="md me it bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">密码</h1><p id="3adf" class="pw-post-body-paragraph kb kc it kd b ke nb kg kh ki nc kk kl km nd ko kp kq ne ks kt ku nf kw kx ky im bi translated">所有的代码都可以在<a class="ae kz" href="https://github.com/cmelgarejo/go-gql-server/tree/tutorial/part-2" rel="noopener ugc nofollow" target="_blank">库</a>中找到。</p><div class="le lf gp gr lg lh"><a href="https://github.com/cmelgarejo/go-gql-server/tree/tutorial/part-2" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">cmelgarejo/go-gql-server</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">用Go制作的自以为是的GraphQL服务器。创建一个帐户，为cmelgarejo/go-gql-server的开发做出贡献…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">github.com</p></div></div></div></a></div></div></div>    
</body>
</html>