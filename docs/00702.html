<html>
<head>
<title>Create GitHub Repos Remotely</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">远程创建GitHub Repos</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-github-repos-remotely-25153a6e6890?source=collection_archive---------3-----------------------#2019-07-02">https://betterprogramming.pub/create-github-repos-remotely-25153a6e6890?source=collection_archive---------3-----------------------#2019-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fb6f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">只需一个命令，使用Bash脚本</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/f8bad25ec563409cf87a10dd73ae81d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*9zGjjd13G-ZNWqogU6b71g.gif"/></div></figure><p id="ee19" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我一直在寻找简化我的编码环境的方法。直到最近，<a class="ae lm" href="https://medium.com/@ChristopherShaffer/host-your-own-git-server-with-gitea-on-ubuntu-16-04-1a4c255ed4d5" rel="noopener">我还在托管自己的Git服务器</a>,用于私人回购和无法提交给GitHub的客户项目。一旦GitHub开始为<em class="ln"/>免费提供无限制的私人回购，这就不再有必要了。</p><p id="24e0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然而，我缺少的一点是用Bash脚本自动创建repos的能力，这是我用我的私人Git服务器配置的，它是使用<a class="ae lm" href="https://gitea.io/en-us/" rel="noopener ugc nofollow" target="_blank"> Gitea </a>托管的。Gitea为此提供了一个API，事实证明，GitHub也是如此！</p><p id="cf09" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你想看GitHub API文档，可以在这里找到<a class="ae lm" href="https://developer.github.com/v3/repos/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="9f66" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我将介绍如何使用GitHub的repository API创建一个简单的Bash脚本，并向您展示如何在您的编程环境中实现这一点。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="63db" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">开始之前</h1><p id="ad76" class="pw-post-body-paragraph kq kr it ks b kt mn ju kv kw mo jx ky kz mp lb lc ld mq lf lg lh mr lj lk ll im bi translated">本教程假设您使用的是Mac，但是，这些相同的步骤在任何Linux机器上都可以很好地工作。它还假设您已经安装了Git或Xcode命令行工具，其中包括Git。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="63a8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">生成个人访问令牌</h1><p id="768b" class="pw-post-body-paragraph kq kr it ks b kt mn ju kv kw mo jx ky kz mp lb lc ld mq lf lg lh mr lj lk ll im bi translated">为了访问GitHub的API，我们需要一个个人访问令牌。这个令牌被用作GitHub and的授权，只对<em class="ln">你的账户</em>发出请求，所以<strong class="ks iu">保证它的安全非常重要——不要把令牌交给GitHub，也不要和任何人分享。</strong></p><p id="a60c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先登录你的GitHub账户，选择右上角的用户菜单，然后选择设置。从“设置”菜单中，选择左下角的“开发人员设置”。在那里，点击右上角的<code class="fe ms mt mu mv b">Generate new token</code>按钮。迷路的话看看下面的GIF。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/da4a866c741bd46f429834b735733855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*a87daDcZ6hP3wwJpW-MGKg.gif"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">导航GitHub菜单以生成个人访问令牌。</p></figure><p id="4e85" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在“注释”字段中，为您的令牌提供一个易于识别其用途的名称或短语。我用了“回购管理”。</p><p id="aed9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">请注意，我们使用的API<strong class="ks iu">也可以用来以重要的方式修改您的GitHub帐户，</strong>所以您可能希望限制令牌这样做。我的设置被配置为允许使用令牌在存储库上执行<a class="ae lm" href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" rel="noopener ugc nofollow" target="_blank"> CRUD </a>操作，但不进行任何帐户更改。</p><p id="c29a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在下面的复选框字段中，在“选择范围”下，您可以确定此令牌允许的各种访问级别。我在下面附上了我的令牌设置的截图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/774f708a53fd2a3e7208b10ef96afe2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dsEiSQknY4CdhDVEGnTfsg.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">选择令牌权限可以控制令牌可以用于哪些API函数。明智地选择。</p></figure><p id="df62" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">选择您的令牌权限后，滚动到底部并单击<code class="fe ms mt mu mv b">Generate token</code>按钮确认您的设置。您将看到要复制的令牌—您可以单击蓝色剪贴板图标以简单的方式完成此操作。<strong class="ks iu">务必现在复制令牌<em class="ln">，因为在此之后<em class="ln">你将永远</em>没有机会再这样做。</em></strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nf"><img src="../Images/93ceaa32424cf1467c710becabaa4cc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MTWzexfF-aX2gTU0D6Bhvg.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">创建令牌后复制它。现在就做，否则你得重新开始！</p></figure><p id="685f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">请特别注意记下令牌，并安全存放，</strong>因为一旦丢失就无法找回，但您可以<em class="ln">生成另一个。对于我们正在创建的脚本来说，这可能不是一个大问题，但如果您想要创建使用令牌的其他脚本或应用程序，您会希望将它放在手边。或者，您可以为每个用例生成一个单独的令牌。</em></p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="b1aa" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">创建Bash脚本</h1><p id="ca88" class="pw-post-body-paragraph kq kr it ks b kt mn ju kv kw mo jx ky kz mp lb lc ld mq lf lg lh mr lj lk ll im bi translated">我们有自己的API访问令牌，所以让我们创建bash脚本来远程创建GitHub repos。这将允许我们在终端的任何地方使用一个命令在GitHub上创建一个新的repo。它还将为我们的项目初始化git。</p><p id="50f6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用您最喜欢的文本编辑器，在您的主目录中创建新文件。您可以随意命名它，但是我将我的命名为<code class="fe ms mt mu mv b">setup-repo</code>——这也将是用于运行脚本的命令。注意，您不需要像普通的bash脚本一样在末尾包含<code class="fe ms mt mu mv b">.sh</code>。我对像二进制文件一样使用的脚本这样做(它们提供了像二进制文件一样的命令)，但是如果您愿意，也可以使用文件扩展名。</p><p id="d6cc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一定要用自己的GitHub令牌替换<code class="fe ms mt mu mv b">GH_API_TOKEN</code>的值。确保保留单引号。对<code class="fe ms mt mu mv b">GH_USER</code>做同样的事情，并提供你的GitHub用户名。</p><p id="7d54" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您需要确保 <code class="fe ms mt mu mv b"><strong class="ks iu">curl</strong></code> <strong class="ks iu">语句中的所有内容都显示为一行</strong>，没有回车；在培养基上可能会有不同的表现。</p><p id="715e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我会在要点下面解释脚本在做什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">帮助在GitHub上自动远程创建repos的脚本。</p></figure><p id="4cb1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们到底在这里做什么？我将在这里概述脚本中的每个步骤:</p><ol class=""><li id="c601" class="ni nj it ks b kt ku kw kx kz nk ld nl lh nm ll nn no np nq bi translated">我们定义了一个名为<code class="fe ms mt mu mv b">GH_API_TOKEN</code>的Bash变量来存储我们的API令牌。如果令牌发生变化，编辑起来会更容易一些，而不是用API调用硬编码。</li><li id="08e5" class="ni nj it ks b kt nr kw ns kz nt ld nu lh nv ll nn no np nq bi translated"><code class="fe ms mt mu mv b">GH_USER</code>当然是你的GitHub用户名。</li><li id="5e09" class="ni nj it ks b kt nr kw ns kz nt ld nu lh nv ll nn no np nq bi translated"><code class="fe ms mt mu mv b">NEW_REPO_NAME</code>是一个Bash变量，它将存储脚本的第一个命令行参数；<code class="fe ms mt mu mv b">$1</code>永远是第一个参数。我们将用它来命名我们的回购协议，就像<code class="fe ms mt mu mv b">setup-repo new-repo-name</code>。在这个上下文中，<code class="fe ms mt mu mv b">new-repo-name</code>将被存储在<code class="fe ms mt mu mv b">$1</code>中。</li><li id="9043" class="ni nj it ks b kt nr kw ns kz nt ld nu lh nv ll nn no np nq bi translated"><code class="fe ms mt mu mv b">CURRENT_DIR</code>正在使用<code class="fe ms mt mu mv b">pwd</code>命令存储当前工作目录的值，或者我们现在所在的目录<em class="ln">。</em></li><li id="23ff" class="ni nj it ks b kt nr kw ns kz nt ld nu lh nv ll nn no np nq bi translated"><code class="fe ms mt mu mv b">PROJECT_DIR</code>将我们的项目目录的默认值定义为<code class="fe ms mt mu mv b">CURRENT_DIR</code>，或者允许我们可选地为这个值提供一个参数。这将在我们运行<code class="fe ms mt mu mv b">git init</code>时使用，它也默认为当前工作目录，或者为此接受一个可选值。</li><li id="f2ad" class="ni nj it ks b kt nr kw ns kz nt ld nu lh nv ll nn no np nq bi translated"><code class="fe ms mt mu mv b">curl</code>命令正在调用GitHub repos API的“创建”端点，这里详述<a class="ae lm" href="https://developer.github.com/v3/repos/#create" rel="noopener ugc nofollow" target="_blank">的</a>。它插入了我们的令牌和回购名称变量，这样我们就可以在每次使用新的回购名称运行脚本时动态调用它。</li><li id="08c0" class="ni nj it ks b kt nr kw ns kz nt ld nu lh nv ll nn no np nq bi translated"><code class="fe ms mt mu mv b">git init</code>命令正在我们的项目目录中初始化Git。我们传入<code class="fe ms mt mu mv b">PROJECT_DIR</code>值，或者将它作为当前工作目录，或者将我们的项目目录参数值传递给它。当我们实际运行脚本时，我将在下面对此进行更多的解释。</li><li id="23a8" class="ni nj it ks b kt nr kw ns kz nt ld nu lh nv ll nn no np nq bi translated">最后，使用<code class="fe ms mt mu mv b">git remote add origin</code>,我们将远程添加到项目目录中的Git配置中。</li></ol></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="0641" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">配置我们的提示</h1><p id="0b07" class="pw-post-body-paragraph kq kr it ks b kt mn ju kv kw mo jx ky kz mp lb lc ld mq lf lg lh mr lj lk ll im bi translated">太好了，我们已经创建了我们的脚本，现在我们明白了它是如何工作的，但是我们如何使用它来创建一个新的回购呢？首先，我们需要让命令在提示符下可用。我使用的是Zsh，但这也适用于Bash，我将在下面介绍这一点。</p><p id="52a3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们需要使脚本可执行，然后以某种方式将其添加到我们的路径中。让我们打开终端来做这件事。进入终端后，运行以下命令以确保您在主目录中，并编辑脚本的权限。如果您没有用自己的文件名替换这个命令，我假设您使用了名称<code class="fe ms mt mu mv b">setup-repo</code>。</p><pre class="kj kk kl km gt nw mv nx ny aw nz bi"><span id="548b" class="oa lw it mv b gy ob oc l od oe">cd ~<br/>chmod 0500 setup-repo</span></pre><p id="be85" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">命令<code class="fe ms mt mu mv b">chmod</code>允许我们修改文件的权限。请注意，将权限设置为<code class="fe ms mt mu mv b">0500</code>将允许您的用户读取和执行它，同时限制所有其他权限，包括您的用户将写入文件的能力。这是故意的；我们只想对我们的任何文件拥有绝对必要的最高级别的权限。如果出于某种原因你需要再次编辑它，你可以使用<code class="fe ms mt mu mv b">chmod 0700</code>将文件设置为可写，但是当你完成后一定要将其切换回来。</p><p id="61d2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们现在可以执行这个脚本，但是我们希望能够在任何地方运行它<em class="ln">;</em>我们不希望必须在我们的主目录中才能工作。要做到这一点，最简单的解决方案就是在您的概要文件中添加一个别名。</p><p id="27de" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果您使用Bash，这将是文件<code class="fe ms mt mu mv b">~/.bashrc</code>，如果您使用Zsh，编辑您的<code class="fe ms mt mu mv b">~/.zshrc</code>文件并添加以下行。请注意，您可以将别名命名为任何名称，而不考虑脚本的文件名。</p><pre class="kj kk kl km gt nw mv nx ny aw nz bi"><span id="b23d" class="oa lw it mv b gy ob oc l od oe">alias setup-repo=~/setup-repo</span></pre><p id="3fa5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">保存文件后，您可以使用命令<code class="fe ms mt mu mv b">source ~/.bashrc</code>或<code class="fe ms mt mu mv b">source ~/.zshrc</code>在当前终端会话中使这一更改生效。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="7756" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用新命令</h1><p id="f7d6" class="pw-post-body-paragraph kq kr it ks b kt mn ju kv kw mo jx ky kz mp lb lc ld mq lf lg lh mr lj lk ll im bi translated">现在我们已经准备好了脚本并配置了提示设置，我们可以使用如下所示的脚本了。你可以<strong class="ks iu">在Mac上的终端中的任何目录下执行这个操作</strong>它就会工作。</p><pre class="kj kk kl km gt nw mv nx ny aw nz bi"><span id="01bf" class="oa lw it mv b gy ob oc l od oe">setup-repo [repo name] [path to project]</span><span id="13ef" class="oa lw it mv b gy of oc l od oe"># Example - when already in the project directory, there is no <br/># need to provide [path to project]</span><span id="8bef" class="oa lw it mv b gy of oc l od oe">setup-repo awesome-repo</span><span id="4b3f" class="oa lw it mv b gy of oc l od oe"># Example - when not in the project directory, you can specify<br/># the exact path. In this example, my project is in the <strong class="mv iu"><em class="ln">code</em></strong> folder <br/># in my home directory.</span><span id="1c8d" class="oa lw it mv b gy of oc l od oe">setup-repo awesome-repo ~/code/awesome-repo</span></pre><p id="384c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当我们回顾我们的脚本之前在做什么时，我们创建了一个名为<code class="fe ms mt mu mv b">PROJECT_DIR</code>的变量。当我们在第二个参数中调用上面的命令<code class="fe ms mt mu mv b">~/code/awesome-repo</code>时，我们将提供该值，但这是可选的。正如代码注释所指出的，在没有这个选项的情况下运行命令将在当前工作目录中初始化repo。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="da8b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="15c2" class="pw-post-body-paragraph kq kr it ks b kt mn ju kv kw mo jx ky kz mp lb lc ld mq lf lg lh mr lj lk ll im bi translated">这只是自动化您的工作流程并减少每天完成编码任务所需的认知开销的一部分，但每一点都有帮助。希望这能为您节省一些时间，并简化您的Git管理。</p><p id="b8c6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">请在评论中留下反馈和问题，我会尽快回复。</p><p id="0bdb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">感谢阅读！</p></div></div>    
</body>
</html>