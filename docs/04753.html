<html>
<head>
<title>Create an Automated Build Pipeline for Kotlin in Gitlab</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Gitlab中为Kotlin创建一个自动化构建管道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-an-automated-build-pipeline-for-kotlin-in-gitlab-3a163d2cf270?source=collection_archive---------7-----------------------#2020-05-06">https://betterprogramming.pub/create-an-automated-build-pipeline-for-kotlin-in-gitlab-3a163d2cf270?source=collection_archive---------7-----------------------#2020-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5002" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用Gitlab pipelines和Gradle自动化构建和测试您的Kotlin代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1a5cae146bd7470e0153a89a7f6ddb15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SoaNt6d9EeE_RlBbgBnuvQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">潘卡杰·帕特尔在<a class="ae ky" href="https://unsplash.com/s/photos/gitlab?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的几个月里，为了工作中的一个新项目，我学习了一些Gradle和Kotlin的知识。</p><p id="3cd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在工作中，我们使用没有任何持续集成或自动化构建过程的内部代码库，因此由我们在本地机器上手动运行测试。不幸的是，我们经常忘记这样做，错误可能会被忽视。</p><p id="2ef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当从事个人项目时，我试图从我们的工作中学习(好的和坏的)，并且我努力总是建立测试自动化。在大多数情况下，这意味着使用Gitlab管道来构建和测试每一个提交。这篇文章描述了我是如何为Kotlin设置的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="627a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是Gitlab管道？</h1><p id="d218" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Gitlab管道背后的想法很简单:定义一组构建和测试代码的步骤，将这些步骤存储在存储库中的一个文件中，使用Docker容器运行定义的步骤，最后报告结果。这是一个简单的概念，但它非常强大。</p><p id="e203" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的截图显示了用于构建和测试Gitlab自己的代码库的大规模构建管道的一部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/98f372f1c3a56b24139b3e31fc76ebb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYvPkvYp_bcnQbVmc7ZtDg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Gitlab构建管道截图</p></figure><p id="0fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="na">注:Gitlab软件是开源的，托管在</em><a class="ae ky" href="https://gitlab.com/gitlab-org/gitlab" rel="noopener ugc nofollow" target="_blank"><em class="na">gitlab.com</em></a><em class="na">上。Gitlab就是用这些管道来建造自己的。</em></p><p id="ea3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过查看管道，您可以了解它正在做的所有事情。编译各种资产，运行测试，生成覆盖报告，等等。涉及数百个步骤，分布在多个阶段。它们都是自动化的，每次提交时都会运行。</p><p id="cd93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对你有什么帮助？</p><p id="795c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">管道的灵活性给了你无限的可能性。您可以定义使用什么Docker容器、需要什么阶段、每个阶段适合什么步骤，以及每个阶段要运行什么命令。有各种各样的事情可以自动化。例如:</p><ul class=""><li id="2ca5" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">测试您的代码。</li><li id="0e45" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">运行静态代码分析来寻找反模式。</li><li id="d5f4" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">运行样式检查器来查找样式错误。</li><li id="9859" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">运行漏洞扫描。</li><li id="6775" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">检查过时的依赖关系。</li><li id="411f" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">验证提交消息以确保它们遵循给定的标准。</li><li id="826a" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">在不同的分支/标签上运行不同的步骤(例如，仅在主分支上运行特殊的发布脚本)。</li><li id="6397" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">构建并托管一个静态站点(<a class="ae ky" href="https://docs.gitlab.com/ee/user/project/pages/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>)。</li><li id="3a92" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">针对多个数据库引擎运行测试以确保兼容性。</li></ul><p id="47b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有很多其他的。您可以阅读<a class="ae ky" href="https://docs.gitlab.com/ee/ci/README.html" rel="noopener ugc nofollow" target="_blank">文档</a>获取灵感，或者查看<a class="ae ky" href="https://docs.gitlab.com/ee/ci/examples/README.html" rel="noopener ugc nofollow" target="_blank">示例</a>页面。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2525" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">运用到科特林身上</h1><p id="ae10" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">自从开始在工作中使用Kotlin和Gradle，我也开始在一些个人项目中使用它。为我的Kotlin代码找出一个可以在Gitlab中使用的管道是我的首要任务。</p><p id="b501" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于本文的目的，我创建了一个演示项目来演示我提出的解决方案。你可以在这里找到它:<a class="ae ky" href="https://gitlab.com/org.hsmith.medium/kotlin-build-pipeline" rel="noopener ugc nofollow" target="_blank"> Kotlin构建管道</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/5687a9c87595b2fd3ed213d710f09cdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*lnyZx7NvkcloSiexSspXSA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">演示项目构建管道的屏幕截图</p></figure><p id="63e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在高层次上，这就是它所做的。</p><p id="9aae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一阶段是编译代码。这个阶段有一个使用Gradle编译的步骤。</p><p id="cc8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二阶段是测试代码。我把它分成两种类型:</p><ul class=""><li id="7c49" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">运行<a class="ae ky" href="https://github.com/pinterest/ktlint" rel="noopener ugc nofollow" target="_blank"> Ktlint </a>查找样式错误——此处的失败将被解释为警告，流水线将继续运行。</li><li id="100e" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">运行项目中定义的所有单元测试——这里的失败意味着管道失败。</li></ul><p id="aa3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，用要发布的所有依赖项构建一个“fat jar”文件。</p><p id="777a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我只需要用正确的指令在存储库的根目录下创建<code class="fe nq nr ns nt b">.gitlab-ci.yml</code>文件。Gitlab处理剩下的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">。Kotlin的gitlab-ci.yml文件</p></figure><p id="6367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么这个文件实际上在做什么呢？</p><ul class=""><li id="1767" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated"><code class="fe nq nr ns nt b">image</code>:第一行是定义使用哪个Docker容器。在本例中，我使用一个安装了Java JDK 11的容器。演示应用程序是针对Java版本11构建的，但是可以针对不同版本的Java进行调整。</li><li id="8d94" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><code class="fe nq nr ns nt b">stages</code>:下一部分定义了构建过程的各个阶段。对于一个简单的项目，我定义了三个阶段:编译、测试和打包。</li><li id="8c6e" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><code class="fe nq nr ns nt b">before_script &amp; cache:</code><code class="fe nq nr ns nt b">before_script</code>部分定义了在每一步之前运行的命令。在这种情况下，我将系统变量<code class="fe nq nr ns nt b">GRADLE_USER_HOME</code>设置为正确的路径。这补充了下面的<code class="fe nq nr ns nt b">cache</code>部分，在步骤之间将<code class="fe nq nr ns nt b">.gradle/</code>文件夹存储在共享缓存中。这些步骤不是必需的，但是它们使流水线运行得更快。</li><li id="2f23" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><code class="fe nq nr ns nt b">compile</code>:<code class="fe nq nr ns nt b">compile</code>部分是第一个实际的构建步骤。它属于<code class="fe nq nr ns nt b">compile</code>阶段，其目的是编译代码并确保没有构建错误。该步骤运行<code class="fe nq nr ns nt b">gradle assemble</code>命令。</li><li id="52d4" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><code class="fe nq nr ns nt b">test</code>:顾名思义，<code class="fe nq nr ns nt b">test</code>部分的目的是运行测试。这一步运行<code class="fe nq nr ns nt b">gradle test</code>命令来运行所有的测试。在这个项目中，测试是使用JUnit5框架创建的。</li><li id="735d" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><code class="fe nq nr ns nt b">code_style</code> : <strong class="lb iu"> </strong>本节定义了如何检查代码中的代码风格错误。我用<code class="fe nq nr ns nt b">Ktlint</code>是因为它很容易设置和使用。t是在<code class="fe nq nr ns nt b">build.gradle</code>文件中配置的，我对默认配置做了以下两处调整。</li><li id="ebc3" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">用<code class="fe nq nr ns nt b">build/ktlint.xml</code>的结果生成一个输出文件</li><li id="41ef" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">允许通配符导入。默认情况下<code class="fe nq nr ns nt b">Ktlint</code>会将通配符导入标记为错误。然而，这与我的IDE ( <code class="fe nq nr ns nt b">IntelliJ</code>)的默认行为相冲突，它将尽可能使用通配符导入。这是一个有争议的话题，但我选择允许他们。您可以通过更新<code class="fe nq nr ns nt b">build.gradle</code>文件来重新启用此规则，并删除Ktlint设置:<code class="fe nq nr ns nt b">"--disabled_rules=no-wildcard-imports"</code>中禁用规则的标志</li><li id="f920" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">这是构建的最后一步。这是<code class="fe nq nr ns nt b">package</code>阶段的一部分，它的目的是将项目编译成一个单独的“胖罐子”,并作为工件存储起来以备后用。这一步使用<a class="ae ky" href="https://github.com/johnrengelman/shadow" rel="noopener ugc nofollow" target="_blank">影子Jar </a> Gradle插件来生成Jar文件。如果对您的项目有意义，您可以更新这个文件，只在某些分支上运行这个步骤(例如，只在主分支上)，以避免为仍在开发中的代码生成构建工件。</li></ul><p id="819f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于用这个文件设置构建管道的信息，你可以在<a class="ae ky" href="https://docs.gitlab.com/ee/ci/yaml/README.html" rel="noopener ugc nofollow" target="_blank">文档</a>中阅读更多。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="784d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="ae08" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我主要关注构建和测试Kotlin代码，但是Gitlab管道功能并不局限于Kotlin或Gradle。有很多其他创造性的方法可以将管道用于各种语言。</p><p id="dafd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这有助于您为自己的个人或专业项目设置构建自动化。或者至少让你思考一下。</p><p id="5958" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果出于某种原因，你执意使用Github，Gitlab甚至提供了为Github上托管的外部项目运行管道的选项。在<a class="ae ky" href="https://gitlab.com/help/user/project/integrations/github" rel="noopener ugc nofollow" target="_blank">文档</a>中了解更多信息。</p><p id="dd98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。你会建造什么？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a359" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="aecf" class="nb nc it lb b lc mu lf mv li nw lm nx lq ny lu ng nh ni nj bi translated"><a class="ae ky" href="https://gitlab.com/org.hsmith.medium/kotlin-build-pipeline" rel="noopener ugc nofollow" target="_blank">演示项目</a></li><li id="4989" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><a class="ae ky" href="https://docs.gitlab.com/" rel="noopener ugc nofollow" target="_blank"> Gitlab文档</a></li><li id="816d" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><a class="ae ky" href="https://docs.gitlab.com/ee/ci/README.html" rel="noopener ugc nofollow" target="_blank">关于构建管道的文档</a></li><li id="4766" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><code class="fe nq nr ns nt b"><a class="ae ky" href="https://docs.gitlab.com/ee/ci/yaml/README.html" rel="noopener ugc nofollow" target="_blank">.gitlab-ci.yml</a></code> <a class="ae ky" href="https://docs.gitlab.com/ee/ci/yaml/README.html" rel="noopener ugc nofollow" target="_blank">参考</a></li><li id="cb3f" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><a class="ae ky" href="https://docs.gitlab.com/ee/user/project/pages/index.html" rel="noopener ugc nofollow" target="_blank">git lab静态网站上的文档</a></li><li id="5087" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><a class="ae ky" href="https://gitlab.com/help/user/project/integrations/github" rel="noopener ugc nofollow" target="_blank">Github项目的git lab CI</a></li><li id="ab8e" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><a class="ae ky" href="https://github.com/pinterest/ktlint" rel="noopener ugc nofollow" target="_blank"> Ktlint </a></li><li id="e49c" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><a class="ae ky" href="https://github.com/johnrengelman/shadow" rel="noopener ugc nofollow" target="_blank">暗影箭</a></li></ul></div></div>    
</body>
</html>