<html>
<head>
<title>So, You Want To Understand Monads?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你想了解单子吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/so-you-want-to-understand-monads-36ba110b8991?source=collection_archive---------8-----------------------#2021-02-18">https://betterprogramming.pub/so-you-want-to-understand-monads-36ba110b8991?source=collection_archive---------8-----------------------#2021-02-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bea8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对一个不必要地令人困惑的函数式编程概念的直观解释</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e93101f036f4e207a738ccbb9f1c7a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FR0OwacLpVc8ttTO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@pakata?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">帕卡塔·高</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="32b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我刚刚读了一篇文章，文章中一个可怜的灵魂非常努力地试图向读者解释单子是什么，但悲惨地失败了，因为他自己并没有真正理解它。出于帮助他的愿望，我认为写一篇文章让人们先理解单子背后的直觉是有意义的，而不必进入疯狂的函数式语言语法。</p><p id="bf0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我是否成功地做到了这一点，这要由你来判断，但是让我们马上开始吧。</p><p id="d762" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我第一次遇到单子是在Eugenio Moggi将它们作为一种构建编程语言语义的方式引入的时候。这个公式非常简洁，并且清楚地给了一个非常大的编程语言构造类一个很好的数学模型，在此之前，这个类只是被孤立地处理。</p><p id="ff7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">莫吉在那篇论文(如果你能遵守数学的话)中提出的是对计算的深度理解，这在一代人中只会出现一次。没错，是一篇<em class="lv">深刻</em>直观的论文，将计算机科学的直观映射到坚实的数学基础上。在这里，我将把大量的数学知识从论述中剔除，但我确实希望传授直觉。</p><p id="1f8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说一个很简单的表达:<code class="fe lw lx ly lz b">getc()</code>。c程序员可能认为这类似于从文件中获取一个字符的函数。这里不是一个文件，假设它从键盘上获取一个字符。这是一个产生单个字符的简单函数。您可以在任何可以使用字符表达式的地方使用这个函数(也就是说，它名义上有类型<code class="fe lw lx ly lz b">char</code>)。例如，如果我们想检查用户是否按下了键<em class="lv"> q </em>，我们可以做<code class="fe lw lx ly lz b">(getc() == ‘q’)</code>。</p><p id="b9e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是从计算上来说，<code class="fe lw lx ly lz b">getc()</code>绝不是简单的<code class="fe lw lx ly lz b">char</code>。它涉及到与程序外部环境的一系列复杂的交互，包括操作系统、硬件和用户。当我们考虑程序时，传统的智慧(继承自λ演算)是只对值进行推理。当你处理完全在程序内部的实体时，这很好。但是<code class="fe lw lx ly lz b">getc()</code>在这里，我们不得不面对这样一个事实:在这个项目之外，还有一个我们必须应对的世界。它带来的事实是I/O操作可能会失败，或者它们并不总是产生相同的值，以及用户可能根本不会按键的事实。</p><p id="027f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是莫吉天才的第一部分。他凭直觉认为，价值与产生价值的计算有质的不同。换句话说，<code class="fe lw lx ly lz b">getc()</code> <strong class="lb iu"> </strong>是一个<em class="lv">计算</em>产生一个<em class="lv"/><code class="fe lw lx ly lz b">char</code><em class="lv">不应该把</em>和一个<em class="lv"> </em> <code class="fe lw lx ly lz b">char</code> <em class="lv">混为一谈。</em></p><p id="5eba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，与其给<code class="fe lw lx ly lz b">getc()</code>赋予类型<code class="fe lw lx ly lz b">char</code>，不如给它赋予类型<code class="fe lw lx ly lz b">T[char]</code>，这是产生<code class="fe lw lx ly lz b">char</code>的计算<strong class="lb iu"> T </strong>的简称。起初，这似乎是一种倒退。现在我们不能在所有可以使用<code class="fe lw lx ly lz b">char</code>的地方使用<code class="fe lw lx ly lz b">getc()</code> <strong class="lb iu"> </strong>，所以<code class="fe lw lx ly lz b">(getc() == ‘q’)</code>不再正确，因为<code class="fe lw lx ly lz b">==</code>两边的类型不同。我们现在该怎么办？</p><p id="ca74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给大家介绍一对新词:<em class="lv">注射</em>和<em class="lv">投射</em>。当我们获取一个类型为<code class="fe lw lx ly lz b">char</code>的值并将其嵌入另一个类型(如<code class="fe lw lx ly lz b">T[char]</code>)时，这被称为<em class="lv">注入</em>。喷射的逆过程称为<em class="lv">投影</em>。这是我们从嵌入中提取注入值的地方。换句话说，我们将<code class="fe lw lx ly lz b">char</code>从<code class="fe lw lx ly lz b">T[char]</code>中投影出来。一般来说，注入和投射总是被设计成彼此相反的:它们组成了恒等函数。</p><p id="2c33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，投影算子现在会允许我们从<code class="fe lw lx ly lz b">T[char]</code>中得到<code class="fe lw lx ly lz b">char</code>吗？这个投影看起来像什么？对于像<code class="fe lw lx ly lz b">getc()</code>这样的计算过程，我们通过等待I/O调用终止来“投射<em class="lv"/><code class="fe lw lx ly lz b">T[char]</code>，给出值，然后处理值，就像使用另一个char和从它派生的任何其他值一样使用它。然而，一旦我们脱离了计算领域，进入了价值领域，我们现在已经完全掩盖了这样一个事实，即有一整套计算产生了价值，并将我们推回到起点(即，无法抓住<code class="fe lw lx ly lz b">getc()</code>将我们拖入的外部世界)。)</p><p id="8b86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是莫吉天才的第二部分发挥作用的地方。他提出了一个有点受限的投影算子，他称之为<code class="fe lw lx ly lz b">let</code>，用它我们可以像这样重写上面的简单测试(这不是最终的形式，但它是一个很好的起点):</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="cb60" class="me mf it lz b gy mg mh l mi mj">let c = getc() in (c == ‘q’)</span></pre><p id="0865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我来解释一下。这里，<code class="fe lw lx ly lz b">c</code>的类型是<code class="fe lw lx ly lz b">char</code> —而不是<code class="fe lw lx ly lz b">T[char]</code>。<strong class="lb iu">在这种情况下，投影意味着等待<code class="fe lw lx ly lz b">getc()</code>返回一个字符。</strong></p><p id="b1aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe lw lx ly lz b">let</code>正在执行一个标准的投影操作，这个表达式将在最后产生一个布尔值。然而，整个表达式<em class="lv">仍然</em>有一个I/O操作(即一个计算)参与产生这个布尔运算。这意味着这个表达式并不真正代表一个布尔值，而是一个产生布尔值的<em class="lv">计算</em>。所以正确的做法是给整个<code class="fe lw lx ly lz b">let</code>表达式赋予类型<code class="fe lw lx ly lz b">T[boolean]</code>，这意味着<code class="fe lw lx ly lz b">let</code>的主体必须返回类型<code class="fe lw lx ly lz b">T[boolean]</code>。</p><p id="afc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Moggi的公式中，这种类型对于所有投射的<code class="fe lw lx ly lz b">let</code> <strong class="lb iu"> </strong>表达式都是<em class="lv">必需的</em>，并且由类型检查器强制执行。为了确保我们能够满足这个需求，我们引入了一个操作符<code class="fe lw lx ly lz b">η</code>，它的惟一目的是将一个<code class="fe lw lx ly lz b">τ</code>类型的值注入到<code class="fe lw lx ly lz b">Τ[<em class="lv">τ</em>]</code> <strong class="lb iu">中。它迫使我们记住这个值是通过计算产生的。所以我们把上面的<code class="fe lw lx ly lz b">let</code>改写成这样:</strong></p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="207f" class="me mf it lz b gy mg mh l mi mj">let c = getc() in η(c == ‘q’)</span></pre><p id="708a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这个表达式的类型是<code class="fe lw lx ly lz b">T[boolean]</code>。一般来说，这意味着从计算中产生一个值的事实永远不会被忘记。如果我们必须在其他地方使用这个<code class="fe lw lx ly lz b">let</code>产生的值，我们必须记住它是一个<code class="fe lw lx ly lz b">T[boolean]</code>。要提取这个布尔值，我们需要另一个<code class="fe lw lx ly lz b">let</code>，其主体是<code class="fe lw lx ly lz b">T[something]</code>等等。如果你已经理解了这一段，并想向你的朋友炫耀，把“单子的结合律”这几个字扔过来。</p><p id="d5e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由此得出逻辑结论，任何使用计算的程序最终总是产生类型为<code class="fe lw lx ly lz b">T[x]</code> <strong class="lb iu"> </strong>的答案，而不是类型为<code class="fe lw lx ly lz b">x</code>的值。单子肮脏的小秘密是，我们需要做最后一个投影来从<code class="fe lw lx ly lz b">T[x]</code>中提取<code class="fe lw lx ly lz b">x</code>。在实践中，每个<code class="fe lw lx ly lz b">T</code>总是伴随着这样的投影操作，但是它必须只用于非常明确的区域，在这些区域中我们不再寻求保留<code class="fe lw lx ly lz b">T[]</code>的计算属性。</p><p id="b249" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型<code class="fe lw lx ly lz b">T[]</code>连同伴随的<code class="fe lw lx ly lz b">η</code>和<code class="fe lw lx ly lz b">let</code>是单子(有时也被赋予有趣的名字“Kleisli triple”)。实际的名字来自于一个范畴理论结构，这个结构用比大多数人需要知道的更多的数学来形式化这个想法。就是这样。虽然在我们的例子中,<code class="fe lw lx ly lz b">T[]</code>是涉及I/O的计算的替身，但是它也可以代替我们将在下面看到的各种不同类型的计算。</p><p id="3de8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单子只有这些了。这个公式的目的是，它清楚地将不良的计算世界划分为<code class="fe lw lx ly lz b">let </code>的绑定(在<code class="fe lw lx ly lz b">in</code>之前的<code class="fe lw lx ly lz b">let</code>部分，其将名称绑定到从计算中投影出来的值)和<code class="fe lw lx ly lz b">let</code>主体中的良好的功能世界。绑定内的世界充满了与绑定相关的不确定性，但是主体内的世界是干净的，并且保留了值是从计算中获得的事实。</p><p id="de70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，即使我的程序中有“效果”(这是我们给这些计算起的名字)，我也可以对程序的大部分内容进行推理，而不用过多考虑效果，因为它们现在已经被很好地打包在<code class="fe lw lx ly lz b">T[]</code>中了。<code class="fe lw lx ly lz b">let</code>的规则不要让我忘记什么时候我在处理一个计算，什么时候我在处理这个计算产生的一个值。</p><p id="58a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以这样处理的计算范围很大。I/O就是上面的一个例子。另一种常用的计算类型是“不确定性”，即一个值可能存在也可能不存在。例如，您可能在哈希表中查找一个可能找到也可能找不到的键。这种类型的计算被打包到<code class="fe lw lx ly lz b">Option</code> monad中。考虑这一点的方法是，如果<code class="fe lw lx ly lz b">let</code>在从计算中提取值时遇到不存在(即哈希表没有我们要找的键)，整个<code class="fe lw lx ly lz b">let</code>将不存在。否则，当该值存在时，<code class="fe lw lx ly lz b">let</code>的体也将有一个值。在<code class="fe lw lx ly lz b">Option</code>中，使用Scala中的<code class="fe lw lx ly lz b">Some</code>或Haskell中的<code class="fe lw lx ly lz b">Just</code>进行值(<code class="fe lw lx ly lz b">η</code>)的注射。其他原语(例如哈希表中的<code class="fe lw lx ly lz b">get</code>，在这种情况下，类似于<code class="fe lw lx ly lz b">getc</code>)会自动在<code class="fe lw lx ly lz b">Option</code>中产生一个值。</p><p id="dba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种常用的计算类型是“异步”在这种情况下，计算是异步发生的——可能是在另一个系统中(比如数据库)——并且这个计算将生成感兴趣的值。这种类型的计算通常被打包成<code class="fe lw lx ly lz b">Future</code>单子。<code class="fe lw lx ly lz b">Future</code>代表一种计算，它将产生我们最终将得到的值。<code class="fe lw lx ly lz b">let</code>中的绑定等待计算产生这个值，只有当值准备好时才评估主体。此外，<code class="fe lw lx ly lz b">let</code>现在作为一个整体代表了一个计算，它将在某个时候在<code class="fe lw lx ly lz b">let</code>的主体中产生值。与我们对<code class="fe lw lx ly lz b">let</code>工作方式的理解一致，<code class="fe lw lx ly lz b">let</code>表达式本身就是一个<code class="fe lw lx ly lz b">Future</code>。</p><p id="e308" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种非常简洁的方式来构建包含效果的程序。莫吉用它来定义像可变状态、延续等效果的语义。但是是Phil Wadler把它们的使用扩展到了函数式编程。与西蒙·佩顿·琼斯和其他人一起，他领导他们加入哈斯克尔。随后，它们被并入许多其他编程语言，包括Scala和Swift。</p><p id="a5c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们为计算选择的特定的<code class="fe lw lx ly lz b">T[]</code>通常有自己的运算，所以你可以影响/观察实际的计算本身。例如，您可以在一个<code class="fe lw lx ly lz b">Future</code>上设置一个超时，而不必改变程序中只处理<code class="fe lw lx ly lz b">Future</code>值的部分。或者，向计算提供恢复选项(因为您<em class="lv">知道</em>它是一个计算！).</p><p id="4c8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，这就对了。单子在概念上非常简单。那么，为什么他们周围会有这些混乱和戏剧性的事情呢？现在请允许我把这些非常简单的想法用真实的语言映射成一些具体的结构，你就会明白为什么会搞砸了。</p><p id="e9a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">莫吉非常优雅的<code class="fe lw lx ly lz b">let … in …</code> <strong class="lb iu"> </strong>构造在Scala(和Swift)中被重新表述为不幸命名的<code class="fe lw lx ly lz b">for … yield …</code>和在Haskell中更不幸命名的<code class="fe lw lx ly lz b">do … return …</code>(它们在语义上也略有不同)。注意，两种语言都选择将<em class="lv">绑定</em>操作命名为<em class="lv">命令性</em>操作，我认为这是一个非常令人遗憾的设计决定。任何阅读带有这些单词的程序的人都会立即感到困惑，因为它不是把它们带到一个“绑定”的地方，而是把它们带到一个“循环”的地方，或者更令人困惑的是，强制地从某个地方“返回”。</p><p id="a844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，这背后有多年的历史原因，但深入一点会有所帮助。</p><p id="36a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在随后的<a class="ae ky" href="https://ncatlab.org/nlab/files/WadlerMonads.pdf" rel="noopener ugc nofollow" target="_blank">论文</a>中，Wadler注意到并利用了列表和单子共享相似的代数属性的事实，这种相似性可以通过将一些列表函数扩展到一般的<em class="lv">所有</em>单子来利用。例如，我们有一个列表函数<code class="fe lw lx ly lz b">map</code>，它接受一个类型为<code class="fe lw lx ly lz b">(a -&gt;b)</code> <strong class="lb iu"> </strong>的函数，并将它映射到一个<code class="fe lw lx ly lz b">List[a]</code>上以产生一个<code class="fe lw lx ly lz b">List[b]</code>。Wadler观察到这种相似性可以用于单子，除了用类型<code class="fe lw lx ly lz b">T[a]</code>和<code class="fe lw lx ly lz b">T[b]</code>代替<code class="fe lw lx ly lz b">List[a]</code> <strong class="lb iu"> </strong>和<code class="fe lw lx ly lz b">List[b]</code>。因此，对于任何给定的单子类型<code class="fe lw lx ly lz b">T</code>，我们可以定义:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="27b0" class="me mf it lz b gy mg mh l mi mj">map (f: (a-&gt;b), m:T[a]) : T[b] = let v = m in η(f v)</span></pre><p id="14b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你迈出了这一步，许多其他事情就会接踵而至。你会得到像<code class="fe lw lx ly lz b">flatMap</code>这样的怪物，它们在列表的上下文中是有意义的，但是完全没有意义的单子符号。对于那些不知道<code class="fe lw lx ly lz b">flatMap</code> <em class="lv"> </em>是什么的人来说，当我们在一个列表上映射一个函数，结果是一个列表的列表时，<code class="fe lw lx ly lz b">flatMap</code>会将所有那些子列表附加在一起，产生一个平面列表。</p><p id="47cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道什么是<code class="fe lw lx ly lz b">Future</code>，我也知道什么是<code class="fe lw lx ly lz b">flatMap</code> <strong class="lb iu"> </strong>。但是<code class="fe lw lx ly lz b">flatMapping</code>一<code class="fe lw lx ly lz b">Future</code>呢？啊？那连<strong class="lb iu"> <em class="lv"> </em> </strong> <em class="lv">是什么意思</em>，到底是什么意思？不幸的是，在某些语言中(比如Scala和Swift)，它实际上<em class="lv">并不意味着什么。事实上，它是某些东西的名字，是<em class="lv"> </em>单子最初定义的一部分。它是<code class="fe lw lx ly lz b">bind</code>操作符，也就是<code class="fe lw lx ly lz b">let</code>被分解成:<code class="fe lw lx ly lz b">Exp_1</code>中的<code class="fe lw lx ly lz b">let v = Exp_0</code>翻译成<code class="fe lw lx ly lz b">bind(Exp_0, λv. Exp_1)</code>。它在数学上用<code class="fe lw lx ly lz b">‘*’</code>表示，Haskell称之为<code class="fe lw lx ly lz b">&gt;&gt;=</code>。</em></p><p id="f16e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，称之为<code class="fe lw lx ly lz b">flatMap</code>是完全错误的。事实上，我读过的一篇Swift文章甚至说，如果你能为一个数据结构定义<code class="fe lw lx ly lz b">flatMap</code>，它就是一个单子。我都不知道该说些什么。这就是我们把人们的头脑搞得有多糟糕。</p><p id="c87c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，列表上的<code class="fe lw lx ly lz b">for</code>(即循环)在列表世界中是合理的理解(最终基于集合论中常见的集合理解)，在单子上变成了完全无意义的循环(例如，允许我用<code class="fe lw lx ly lz b">Option</code> <strong class="lb iu">来循环你)。</strong> <em class="lv">嗯？</em>)。</p><p id="05b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样令人沮丧的是，并不是所有的列表函数都扩展到单子。例如，我多少能看出<code class="fe lw lx ly lz b">Future</code>的<code class="fe lw lx ly lz b">head</code>可能是什么。但是一个<code class="fe lw lx ly lz b">Future</code>的<code class="fe lw lx ly lz b">tail</code>是什么鬼？在之后剩下的<em class="lv">一个计算结束了，或者可能是<em class="lv">是</em>的计算，所以我可以再运行一次？好的好的好的。我知道代数是非常相似的，而且它在数学上是可行的，但是程序是为<em class="lv">阅读</em>而设计的，它们的意图很重要。任何一个<code class="fe lw lx ly lz b">flatMap</code>与<code class="fe lw lx ly lz b">bind</code> <em class="lv"> </em>相同的世界都是一个错得离谱的世界。</em></p><p id="90a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么不坚持简单优雅的装订呢？<em class="lv"> </em>真的有那么难吗？由于过度设计的工具，一代又一代的新手一直在为计算和值的简单分离而奋斗(可能现在仍然在奋斗)。是的，<code class="fe lw lx ly lz b">let</code>在大多数其他语言中确实有其他含义，但是这个问题很容易通过像<code class="fe lw lx ly lz b">mlet</code>、<code class="fe lw lx ly lz b">let[T]</code>(例如<code class="fe lw lx ly lz b">let[Option] c = … in …</code>)或其他同样有意义的语法来解决。或者冒着稍微复杂一点的风险，坚持使用<code class="fe lw lx ly lz b">bind</code>操作符，不用语法就能完成同样的任务。</p><p id="8054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果你对任何语言中的单子都不熟悉，找到你感兴趣的<code class="fe lw lx ly lz b">T[]</code> <strong class="lb iu"> </strong>的对等词，确定它所代表的计算和<code class="fe lw lx ly lz b">let … in …</code>的对等词，这就是你需要的全部。其他的都是噪音。</p></div></div>    
</body>
</html>