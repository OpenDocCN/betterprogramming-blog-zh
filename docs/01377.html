<html>
<head>
<title>Conquering ReactiveSwift: Disposable and Lifetime (Part 7)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">征服反应Swift:一次性和终生(第七部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/conquering-reactiveswift-disposable-and-lifetime-part-7-9e3b5f933337?source=collection_archive---------10-----------------------#2019-09-04">https://betterprogramming.pub/conquering-reactiveswift-disposable-and-lifetime-part-7-9e3b5f933337?source=collection_archive---------10-----------------------#2019-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c659" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用作用域原语控制交互</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f6e951c9ccc053327e6fdae5cc3a269a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYioZhZ62mzrwyEtns77mA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@madfishdigital?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">狂鱼数码</a>在<a class="ae ky" href="https://unsplash.com/search/photos/throw-your-laptop-away?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="fcb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">欢迎来到我的“征服<a class="ae ky" href="https://github.com/ReactiveCocoa/ReactiveSwift" rel="noopener ugc nofollow" target="_blank">反应Swift </a>”系列的第7部分。<a class="ae ky" href="https://medium.com/fueled-engineering/https-medium-com-hsusmita-conquering-reactiveswift-action-tutorial-6-58dae11300b5" rel="noopener">第6部分</a>详细处理了<em class="lv">动作</em> <strong class="lb iu"> </strong>。在本文中，我们将在类别s <em class="lv"> cope </em>下讨论原语。范围原语有助于指定<em class="lv">源</em>和<em class="lv">消费者</em>原语之间的交互的生存期。在这个品类中，我们有<em class="lv">一次性</em>和<em class="lv">终身</em>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="a672" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">可任意处理的</h1><p id="a340" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">ReactiveSwift的作者对“一次性”的定义如下:</p><blockquote class="na"><p id="97df" class="nb nc it bd nd ne nf ng nh ni nj lu dk translated">表示可以“释放”的东西，通常与释放资源或取消工作相关联。</p></blockquote><p id="77a9" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">为了理解它的用例，让我们回顾一下上一篇文章中的问题:每隔五秒钟打印一条经过时间的消息。</p><p id="87fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了做到这一点，我们创建了一个信号，在接下来的50秒内每5秒钟发出一个整数值。然后，我们创建了一个观察器，它观察信号并打印信号发出的整数。当它附着在一个信号上时，它就被那个信号所保留。假设我们只想观察前五次出现的信号。为了实现这一点，我们需要保存由<code class="fe np nq nr ns b">signal.observe(signalObserver)</code>返回的一次性数据，并在五次发生后调用<code class="fe np nq nr ns b">disposable.dispose</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单一次性的使用案例</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d281" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">一次性的变体</h1><p id="c0ba" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">让我们更深入地了解一次性用品。<code class="fe np nq nr ns b">Disposable</code>是一种协议，其定义如下:</p><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="2593" class="nz me it ns b gy oa ob l oc od">public protocol Disposable: class {</span><span id="dc92" class="nz me it ns b gy oe ob l oc od">   var isDisposed: Bool { get }</span><span id="cb05" class="nz me it ns b gy oe ob l oc od">   func dispose()</span><span id="8bbe" class="nz me it ns b gy oe ob l oc od">}</span></pre><p id="717b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一次性用品有三种类型:系列型、范围型和复合型。</p><h2 id="9772" class="nz me it bd mf of og dn mj oh oi dp mn li oj ok mp lm ol om mr lq on oo mt op bi translated">系列一次性用品</h2><p id="918e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe np nq nr ns b">SerialDisposable</code>处理包装好的一次性用品，并允许更换。这在您希望前一个观察在新观察开始时结束的情况下非常有用。</p><h2 id="1e9c" class="nz me it bd mf of og dn mj oh oi dp mn li oj ok mp lm ol om mr lq on oo mt op bi translated">范围内的一次性用品</h2><p id="62fd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe np nq nr ns b">ScopedDisposable</code>在废弃时处理包装好的一次性用品。</p><h2 id="a9de" class="nz me it bd mf of og dn mj oh oi dp mn li oj ok mp lm ol om mr lq on oo mt op bi translated"><strong class="ak">复合一次性用品</strong></h2><p id="8af2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">保留一系列其他一次性用品。当它的<code class="fe np nq nr ns b">dispose</code>方法被调用时，所有可处置的集合被处置。当你想停止监听所有的信号和当一个类被释放时的<code class="fe np nq nr ns b">signalProducers</code>时，这个可支配是有用的。</p><p id="6c1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解每种类型的用例，让我们看一个例子。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7e6a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">示例:类计时器</h1><p id="b026" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">让我们用一个名为<code class="fe np nq nr ns b">start(interval: Int)</code>的方法构建一个类<code class="fe np nq nr ns b">Timer</code>，打印给定时间间隔内经过的时间。</p><p id="159a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此我们可以利用我们在<a class="ae ky" href="https://medium.com/fueled-engineering/https-medium-com-hsusmita-conquering-reactiveswift-action-tutorial-6-58dae11300b5" rel="noopener">第六部分</a>中写的<code class="fe np nq nr ns b">signalProducerGenerator</code>。这将一个整数作为参数，并返回一个可以在给定的时间间隔内发出值的<code class="fe np nq nr ns b">signalProducer</code>。这是我们的<code class="fe np nq nr ns b">Timer</code>类的样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8ec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们运行下面的代码片段。</p><h2 id="bc24" class="nz me it bd mf of og dn mj oh oi dp mn li oj ok mp lm ol om mr lq on oo mt op bi translated">片段1</h2><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="150d" class="nz me it ns b gy oa ob l oc od">let timer = Timer()</span><span id="7e96" class="nz me it ns b gy oe ob l oc od">timer.start(interval: 2)</span><span id="6152" class="nz me it ns b gy oe ob l oc od">DispatchQueue.main.asyncAfter(deadline: .now() + 4.0) {</span><span id="b199" class="nz me it ns b gy oe ob l oc od">   timer.start(interval: 1)</span><span id="d4c0" class="nz me it ns b gy oe ob l oc od">}</span></pre><p id="ff2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将为我们提供以下输出:</p><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="8ecf" class="nz me it ns b gy oa ob l oc od">timeElapsed = 0 : interval = 2</span><span id="ed1b" class="nz me it ns b gy oe ob l oc od">timeElapsed = 2 : interval = 2</span><span id="e2e8" class="nz me it ns b gy oe ob l oc od">timeElapsed = 4 : interval = 2</span><span id="3905" class="nz me it ns b gy oe ob l oc od">timeElapsed = 0 : interval = 1</span><span id="accf" class="nz me it ns b gy oe ob l oc od">timeElapsed = 1 : interval = 1</span><span id="3484" class="nz me it ns b gy oe ob l oc od">timeElapsed = 6 : interval = 2</span><span id="06a4" class="nz me it ns b gy oe ob l oc od">timeElapsed = 2 : interval = 1</span><span id="57f6" class="nz me it ns b gy oe ob l oc od">timeElapsed = 3 : interval = 1</span><span id="86d0" class="nz me it ns b gy oe ob l oc od">timeElapsed = 8 : interval = 2</span><span id="0842" class="nz me it ns b gy oe ob l oc od">timeElapsed = 4 : interval = 1</span><span id="5208" class="nz me it ns b gy oe ob l oc od">timeElapsed = 5 : interval = 1</span><span id="8ec2" class="nz me it ns b gy oe ob l oc od">timeElapsed = 10 : interval = 2</span><span id="257c" class="nz me it ns b gy oe ob l oc od">timeElapsed = 6 : interval = 1</span><span id="8a3d" class="nz me it ns b gy oe ob l oc od">timeElapsed = 7 : interval = 1</span><span id="e930" class="nz me it ns b gy oe ob l oc od">timeElapsed = 12 : interval = 2</span><span id="fb55" class="nz me it ns b gy oe ob l oc od">timeElapsed = 8 : interval = 1</span><span id="5e05" class="nz me it ns b gy oe ob l oc od">timeElapsed = 9 : interval = 1</span><span id="6766" class="nz me it ns b gy oe ob l oc od">timeElapsed = 14 : interval = 2</span><span id="fcdd" class="nz me it ns b gy oe ob l oc od">timeElapsed = 16 : interval = 2</span><span id="fdff" class="nz me it ns b gy oe ob l oc od">timeElapsed = 18 : interval = 2</span></pre><p id="d423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，两个观察都是活动的。然而，现在我们希望当我们再次调用start方法时，前面的观察停止。对此，我们可以利用<code class="fe np nq nr ns b">SerialDisposable</code>。<code class="fe np nq nr ns b">SerialDisposable</code>有一个名为<code class="fe np nq nr ns b">inner</code>的属性，类型为<code class="fe np nq nr ns b">Disposable</code>。当我们给这个<code class="fe np nq nr ns b">inner</code>属性分配任意观察的一次性物品时，它将处理旧的内部一次性物品。</p><p id="e252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过以下方式实现这一目标:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5cfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们运行代码片段1 <strong class="lb iu">，</strong>时，我们得到以下输出。注意对<code class="fe np nq nr ns b">interval = 2</code>的观察已经停止。</p><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="f8d0" class="nz me it ns b gy oa ob l oc od">timeElapsed = 0 : interval = 2</span><span id="6162" class="nz me it ns b gy oe ob l oc od">timeElapsed = 2 : interval = 2</span><span id="7b6b" class="nz me it ns b gy oe ob l oc od">timeElapsed = 4 : interval = 2</span><span id="6196" class="nz me it ns b gy oe ob l oc od">timeElapsed = 0 : interval = 1</span><span id="8c84" class="nz me it ns b gy oe ob l oc od">timeElapsed = 1 : interval = 1</span><span id="0187" class="nz me it ns b gy oe ob l oc od">timeElapsed = 2 : interval = 1</span><span id="063b" class="nz me it ns b gy oe ob l oc od">timeElapsed = 3 : interval = 1</span><span id="0260" class="nz me it ns b gy oe ob l oc od">timeElapsed = 4 : interval = 1</span><span id="864a" class="nz me it ns b gy oe ob l oc od">timeElapsed = 5 : interval = 1</span><span id="25f4" class="nz me it ns b gy oe ob l oc od">timeElapsed = 6 : interval = 1</span><span id="5c5d" class="nz me it ns b gy oe ob l oc od">timeElapsed = 7 : interval = 1</span><span id="190f" class="nz me it ns b gy oe ob l oc od">timeElapsed = 8 : interval = 1</span><span id="27ff" class="nz me it ns b gy oe ob l oc od">timeElapsed = 9 : interval = 1</span></pre><p id="73c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们还有另一个问题。如果对象被释放，当前的观察不会结束。让我们运行下面的代码片段。</p><h2 id="ac30" class="nz me it bd mf of og dn mj oh oi dp mn li oj ok mp lm ol om mr lq on oo mt op bi translated"><strong class="ak">片段二</strong></h2><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="3abe" class="nz me it ns b gy oa ob l oc od">var timer: Timer? = Timer()</span><span id="a774" class="nz me it ns b gy oe ob l oc od">timer?.start(interval: 2)</span><span id="eaee" class="nz me it ns b gy oe ob l oc od">DispatchQueue.main.asyncAfter(deadline: .now() + 4.0) {</span><span id="5d7f" class="nz me it ns b gy oe ob l oc od">  timer?.start(interval: 1)</span><span id="f231" class="nz me it ns b gy oe ob l oc od">}</span><span id="97aa" class="nz me it ns b gy oe ob l oc od">DispatchQueue.main.asyncAfter(deadline: .now() + 6.0) {</span><span id="481f" class="nz me it ns b gy oe ob l oc od">  timer = nil</span><span id="4ed1" class="nz me it ns b gy oe ob l oc od">}</span></pre><p id="4602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到以下输出:</p><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="7922" class="nz me it ns b gy oa ob l oc od">timeElapsed = 0 : interval = 2</span><span id="2e48" class="nz me it ns b gy oe ob l oc od">timeElapsed = 2 : interval = 2</span><span id="5e93" class="nz me it ns b gy oe ob l oc od">timeElapsed = 4 : interval = 2</span><span id="7c3b" class="nz me it ns b gy oe ob l oc od">timeElapsed = 0 : interval = 1</span><span id="097a" class="nz me it ns b gy oe ob l oc od">timeElapsed = 1 : interval = 1</span><span id="d478" class="nz me it ns b gy oe ob l oc od">timeElapsed = 2 : interval = 1</span><span id="c5af" class="nz me it ns b gy oe ob l oc od">timeElapsed = 3 : interval = 1</span><span id="79c7" class="nz me it ns b gy oe ob l oc od">timeElapsed = 4 : interval = 1</span><span id="8e15" class="nz me it ns b gy oe ob l oc od">timeElapsed = 5 : interval = 1</span><span id="c01c" class="nz me it ns b gy oe ob l oc od">timeElapsed = 6 : interval = 1</span><span id="2c2a" class="nz me it ns b gy oe ob l oc od">timeElapsed = 7 : interval = 1</span><span id="3ab2" class="nz me it ns b gy oe ob l oc od">timeElapsed = 8 : interval = 1</span><span id="4e37" class="nz me it ns b gy oe ob l oc od">timeElapsed = 9 : interval = 1</span></pre><p id="5b0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，让我们使用<code class="fe np nq nr ns b">ScopedDisposable</code>。它有另一个名为<code class="fe np nq nr ns b">inner</code> disposable的属性，当<code class="fe np nq nr ns b">ScopedDisposable</code>释放时，这个属性被释放。所以我们需要把<code class="fe np nq nr ns b">SerialDisposable</code>包装成<code class="fe np nq nr ns b">ScopedDisposable</code> <strong class="lb iu">。</strong>这是它的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e9be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们现在运行代码片段2 <strong class="lb iu"> </strong>时，我们得到以下输出。请注意，当<code class="fe np nq nr ns b">timer</code>变为零时，所有观察在6秒钟后停止。</p><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="d177" class="nz me it ns b gy oa ob l oc od">timeElapsed = 0 : interval = 2</span><span id="5147" class="nz me it ns b gy oe ob l oc od">timeElapsed = 2 : interval = 2</span><span id="d470" class="nz me it ns b gy oe ob l oc od">timeElapsed = 4 : interval = 2</span><span id="1b5b" class="nz me it ns b gy oe ob l oc od">timeElapsed = 0 : interval = 1</span><span id="2d84" class="nz me it ns b gy oe ob l oc od">timeElapsed = 1 : interval = 1</span></pre><p id="3df3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们考虑另一个场景。假设我们不希望旧的观察在新的观察开始时结束。但是我们希望所有这些都在对象变为零时结束，并且只有在对象变为零时。这里我们需要的是<code class="fe np nq nr ns b">compositeDisposable</code>而不是<code class="fe np nq nr ns b">serialDisposable</code>。为此，我们将修改<code class="fe np nq nr ns b">start(interval: Int)</code>,继续将所有一次性用品添加到<code class="fe np nq nr ns b">CompositeDisposable</code>,如下所示:</p><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="b040" class="nz me it ns b gy oa ob l oc od"><strong class="ns iu">self</strong>.compositeDisposable += <br/><strong class="ns iu">self</strong>.timerSignalProducer(interval: interval)<br/>.startWithValues { value <strong class="ns iu">in<br/>   </strong>print("timeElapsed = \(value) : interval = \(interval)")<br/>}</span></pre><p id="e4b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须将这个<code class="fe np nq nr ns b">compositeDisposable</code>包装在<code class="fe np nq nr ns b">scopedDisposable</code>中，这样当<code class="fe np nq nr ns b">timer</code>变为零时，它就会被处理掉。</p><p id="aa62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是完整的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e952" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们现在运行代码片段2时，我们得到以下输出。注意，两个观察器都是活动的，直到<code class="fe np nq nr ns b">timer</code>变为零。</p><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="a58f" class="nz me it ns b gy oa ob l oc od">timeElapsed = 0 : interval = 2</span><span id="1461" class="nz me it ns b gy oe ob l oc od">timeElapsed = 2 : interval = 2</span><span id="771e" class="nz me it ns b gy oe ob l oc od">timeElapsed = 4 : interval = 2</span><span id="2094" class="nz me it ns b gy oe ob l oc od">timeElapsed = 0 : interval = 1</span><span id="5373" class="nz me it ns b gy oe ob l oc od">timeElapsed = 1 : interval = 1</span><span id="5ec1" class="nz me it ns b gy oe ob l oc od">timeElapsed = 6 : interval = 2</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e54a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">一生</h1><p id="4f2f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">文档对<em class="lv">寿命</em>的描述如下。</p><blockquote class="na"><p id="9070" class="nb nc it bd nd ne nf ng nh ni nj lu dk translated">表示对象的生存期，并提供一个钩子来观察对象何时被初始化。</p></blockquote><p id="9450" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">生命有一些有用的属性，可以帮助我们做决定。</p><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="83f7" class="nz me it ns b gy oa ob l oc od">public var ended: Signal&lt;Never, Never&gt;</span><span id="79d3" class="nz me it ns b gy oe ob l oc od"><strong class="ns iu">public var</strong> hasEnded: Bool</span></pre><p id="aa0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，当观察<code class="fe np nq nr ns b">Signal</code>或<code class="fe np nq nr ns b">SignalProducer</code>时，如果不再有任何东西观察它们，那么继续发射值就没有意义。这就是为什么在<code class="fe np nq nr ns b">func timerSignalProducer(interval: Int) -&gt; SignalProducer&lt;Int, Never&gt;</code>中，我们只在<code class="fe np nq nr ns b">lifetime.hasEnded</code>为假时才发送值。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="16de" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="9854" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这都是一次性和终身的。在下一篇文章中，我们将讨论ReactiveSwift中可用的操作符。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="8e87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是您可能想要关注的文章的完整列表:</p><ol class=""><li id="d9df" class="oq or it lb b lc ld lf lg li os lm ot lq ou lu ov ow ox oy bi translated"><a class="ae ky" href="https://medium.com/@hsusmita4/reactive-programming-introduction-to-reactiveswift-c3fcef5e896" rel="noopener">反应Swift简介(第一部分)</a></li><li id="3841" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated"><a class="ae ky" href="https://medium.com/@hsusmita4/conquering-reactiveswift-primitives-part-2-3f39d47d7bc" rel="noopener">征服反动派Swift:原语(下)</a></li><li id="1a39" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated"><a class="ae ky" href="https://medium.com/@hsusmita4/conquering-reactiveswift-signal-and-observer-part-3-8b7da35fe33a" rel="noopener">征服反应Swift:信号与观测器(第三部分)</a></li><li id="b20a" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated">征服反动派:信号生产者(第四部分)</li><li id="f614" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated"><a class="ae ky" href="https://medium.com/@hsusmita/https-medium-com-hsusmita-conquering-reactiveswift-property-tutorial-5-c4e3dd38e94d" rel="noopener">征服反应Swift:属性(第五部分)</a></li><li id="a3a1" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated"><a class="ae ky" href="https://medium.com/@hsusmita/https-medium-com-hsusmita-conquering-reactiveswift-action-tutorial-6-58dae11300b5" rel="noopener">征服反动Swift:行动(第六部分)</a></li></ol></div></div>    
</body>
</html>