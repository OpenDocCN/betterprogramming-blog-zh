<html>
<head>
<title>Use Binary Encoding Instead of JSON</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用二进制编码代替JSON</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-binary-encoding-instead-of-json-dec745ec09b6?source=collection_archive---------0-----------------------#2020-06-16">https://betterprogramming.pub/use-binary-encoding-instead-of-json-dec745ec09b6?source=collection_archive---------0-----------------------#2020-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="79db" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用少得多的字节编码相同的数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0f7d9032fa45c96b981f9245a86e9ecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ccx9xWjo-5pKk79i"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯多夫·高尔在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="aabc" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">我为什么要在乎？</h1><p id="0daf" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在内存中，数据以数据结构的形式保存，如对象、列表、数组等。但是，当您想通过网络发送数据或将其存储在文件中时，您需要将数据编码为自包含的字节序列。从内存表示到字节序列的转换称为编码<em class="mu">T5，相反的称为解码<em class="mu">。随着时间的推移，应用程序处理或存储的数据模式可能会发生变化，可能会添加新字段，也可能会删除旧字段。因此，所使用的编码需要同时支持向后(新代码应该能够读取旧代码写入的数据)和向前(旧代码应该能够读取新代码写入的数据)兼容性。</em></em></p><p id="217b" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在本文中，我们将讨论不同的编码格式，二进制编码格式如何优于JSON、XML，以及它们如何支持模式进化。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="45e6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">编码格式的类型</h1><p id="a995" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">有两种类型的编码格式:</p><ol class=""><li id="3cea" class="na nb it ma b mb mv me mw mh nc ml nd mp ne mt nf ng nh ni bi translated">文本格式</li><li id="7ae4" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">二进制格式</li></ol></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="18a7" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">文本格式</h1><p id="7b53" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">文本格式在某种程度上是人类可读的。一些常见的格式是JSON、CSV和XML。文本格式易于使用和理解，但可能会导致不同的问题:</p><ol class=""><li id="0202" class="na nb it ma b mb mv me mw mh nc ml nd mp ne mt nf ng nh ni bi translated">文本格式可能包含很多歧义。例如，在XML和CSV中，您无法区分字符串和数字。JSON可以区分字符串和数字，但是不能区分整数和浮点数，并且不指定精度。这在处理大数时就成了问题。大于253的数字的一个例子出现在Twitter上，它使用64位数字来标识每条推文。Twitter的API返回的JSON包含两次tweet IDs一次作为JSON数字，一次作为十进制字符串——以解决JavaScript应用程序不能正确解析数字的问题。</li><li id="1c71" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">CSV不包含任何模式，让应用程序来定义每行和每列的含义。</li><li id="db3c" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">文本格式比二进制编码占用更多空间。例如，由于JSON和XML是无模式的，所以它们也需要包含字段名。</li></ol><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="a419" class="nt lh it np b gy nu nv l nw nx">{<br/>    "userName": "Martin",<br/>    "favoriteNumber": 1337,<br/>    "interests": ["daydreaming", "hacking"]<br/>}</span></pre><p id="4cc9" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">它的JSON编码在去掉所有的空格后消耗了82个字节。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ee90" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">二进制编码</h1><p id="578b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">对于仅在组织内部使用的数据，您可以选择更紧凑或解析速度更快的格式。尽管JSON没有XML冗长，但与二进制格式相比，它们仍然占用大量空间。在本文中，我们将讨论三种不同的二进制编码格式:</p><ol class=""><li id="56e4" class="na nb it ma b mb mv me mw mh nc ml nd mp ne mt nf ng nh ni bi translated">节约</li><li id="7a84" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">协议缓冲区</li><li id="f92e" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">Avro</li></ol><p id="a807" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这三者都使用模式提供了高效的、跨语言的数据序列化，并且都有代码生成工具。这三者都通过确保向后和向前的兼容性来支持模式演进。</p><h2 id="b524" class="nt lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">节约和协议缓冲区</h2><p id="1d4e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">节俭是由脸书开发的，协议缓冲是由谷歌开发的。它们都需要模式来对数据进行编码。在Thrift中，模式是使用Thrift的接口定义语言(IDL)定义的。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="d3ee" class="nt lh it np b gy nu nv l nw nx">struct Person {<br/>  1: string       userName,<br/>  2: optional i64 favouriteNumber,<br/>  3: list&lt;string&gt; interests<br/>}</span></pre><p id="4b06" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">协议缓冲区的等效模式是:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="b592" class="nt lh it np b gy nu nv l nw nx">message Person {<br/>    required string user_name        = 1;<br/>    optional int64  favourite_number = 2;<br/>    repeated string interests        = 3;<br/>}</span></pre><p id="297c" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如您所见，两者都为每个字段定义了数据类型和标签号(如<code class="fe oj ok ol np b">1</code>、<code class="fe oj ok ol np b">2</code>和<code class="fe oj ok ol np b">3</code>)。Thrift有两种不同的二进制编码格式:<code class="fe oj ok ol np b">BinaryProtocol</code> <em class="mu"> </em>和<code class="fe oj ok ol np b">CompactProtocol</code> <em class="mu">。</em>二进制格式很简单，如下所示，需要59个字节对上面的数据进行编码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/2cde707dba7f8188ce99bbf08dc0f6e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zJz27ZodpRf8EKAE.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用Thrift的二进制协议编码——图片来自设计数据密集型应用程序。</p></figure><p id="c5c1" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">紧凑协议在语义上等同于二进制协议，但是将相同的信息封装在仅仅34个字节中。它通过将字段类型和标签号打包在一个字节中来实现这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/4794a999576528e456a5b8c0ec52a96d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xf46zdmcYG_PkczX.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用节俭压缩协议编码-图片来自设计数据密集型应用程序。</p></figure><p id="70a4" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">协议缓冲区也对数据进行编码，类似于Thrift的压缩协议，需要33个字节对相同的数据进行编码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/150e121548fc69cebb1f3f2f22f5c352.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0t_-jel4nLebtNZo.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用协议缓冲区编码——图片来自设计数据密集型应用程序。</p></figure><p id="b0bc" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">标签号确保节约和协议缓冲区中的模式进化。如果旧代码试图读取用新模式写入的数据，它将简单地忽略带有新标签号的字段。类似地，新代码可以读取旧模式写入的数据，方法是将丢失的标签号的值设为<code class="fe oj ok ol np b">null</code>。</p><h2 id="96a6" class="nt lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">Avro</h2><p id="10a3" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Avro不同于协议缓冲区和节俭。Avro也使用模式来定义数据。可以使用Avro的IDL定义模式(便于阅读):</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="7cb3" class="nt lh it np b gy nu nv l nw nx">record Person {<br/>    string               userName;<br/>    union { null, long } favouriteNumber;<br/>    array&lt;string&gt;        interests;<br/>}</span></pre><p id="7585" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">或者JSON(更机器可读):</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="ff86" class="nt lh it np b gy nu nv l nw nx">"type": "record",<br/>    "name": "Person",<br/>    "fields": [<br/>        {"name": "userName",        "type": "string"},<br/>        {"name": "favouriteNumber", "type": ["null", "long"]},<br/>        {"name": "interests",       "type": {"type": "array",      "items": "string"}}<br/>    ]<br/>}</span></pre><p id="5108" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">请注意，每个字段都没有标签号。Avro编码只需要32个字节来编码相同的数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/1bb0297ce8f2efac86b60db4e6c7d054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WKuVDaBVbdO6CMtr.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用Avro编码—图片来自设计数据密集型应用程序。</p></figure><p id="c7bd" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">正如您在上面的字节序列中所看到的，没有办法识别一个字段(就像在Thrift和协议缓冲区中使用标签号)或它的数据类型。这些值只是简单地连接在一起。这是否意味着解码时模式的任何改变都会产生不正确的数据？Avro的关键思想是，作者和读者的模式不需要相同，但它们需要兼容。当数据被解码时，Avro的库通过查看两种模式并将数据从作者的模式转换到读者的模式来解决差异。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/da29650fba7803cd36cd35effea0906d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RvWxYl5EZt4PqAhU.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">解决读者和作者模式之间的差异——来自设计数据密集型应用程序的照片。</p></figure><p id="e751" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">你必须考虑读者如何知道作者的模式。这取决于使用这种编码的用例。</p><ol class=""><li id="60f3" class="na nb it ma b mb mv me mw mh nc ml nd mp ne mt nf ng nh ni bi translated">为了传输大型文件或数据，编写器可以在文件开头包含一次它们的架构。</li><li id="293e" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">对于具有单独写入记录的数据库，可以用不同的模式写入每一行。最简单的解决方案是在每个记录的开头包含一个版本号，并保留模式列表。</li><li id="81cb" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated">为了通过网络发送记录，读取器和写入器可以在连接建立时协商模式。</li></ol><p id="0273" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">使用Avro格式的主要优势之一是它支持动态生成的模式。因为它不使用标记号，所以您可以使用版本控制来保存用不同模式编码的不同记录。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="26d1" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="cfae" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在本文中，我们研究了文本和二进制编码格式，同样的数据如何使用JSON编码需要82个字节，使用Thrift和协议缓冲区需要33个字节，而使用Avro编码只需要32个字节。对于在内部服务之间通过网络发送数据，二进制格式提供了几个优于JSON的优势。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="729e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">资源</h1><p id="5a08" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">要了解更多关于编码和设计数据密集型应用程序的知识，我强烈推荐阅读Martin Kleppmann的书<em class="mu">设计数据密集型应用程序</em>。</p></div></div>    
</body>
</html>