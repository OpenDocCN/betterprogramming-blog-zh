<html>
<head>
<title>React Router Architecture That’s Simple, Scalable, and Protected</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单、可扩展且受保护的React路由器架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-router-architecture-thats-simple-scalable-and-protected-da896827f946?source=collection_archive---------3-----------------------#2020-01-07">https://betterprogramming.pub/react-router-architecture-thats-simple-scalable-and-protected-da896827f946?source=collection_archive---------3-----------------------#2020-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="22c6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在单页React应用程序中设置高级路由的教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/89c25bcf69929b513550290cc9732741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*65mFHbpLzMhxk5aI-S7xSg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@diegojimenez" rel="noopener ugc nofollow" target="_blank">迭戈·希门尼斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/route" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的原图</p></figure><p id="8d22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React中的路由，通常使用流行的<a class="ae ky" href="https://reacttraining.com/react-router/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank"> React路由器</a>库，会很快变得混乱。</p><ul class=""><li id="1bf7" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我如何管理所有这些路线？</li><li id="1ca6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">实现认证/保护路由的最佳方式是什么？</li><li id="97a3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我应该如何处理嵌套路由？</li></ul><p id="8cd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这些问题显然有很多很好的答案，但在我将在本教程中介绍的方法之前，我已经尝试了几种不令人满意的方法，我发现对于我正在开发的一个<a class="ae ky" href="https://github.com/ryanjyost/react-spa-starter" rel="noopener ugc nofollow" target="_blank">开源React/Redux样板</a>来说，这是一个很好的实现。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="cccc" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">先决条件</h1><ul class=""><li id="b82e" class="lv lw it lb b lc ni lf nj li nk lm nl lq nm lu ma mb mc md bi translated">对现代反应堆(钩子等)有扎实的理解。).</li><li id="39b7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">熟悉<a class="ae ky" href="https://reacttraining.com/react-router/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank"> React路由器</a>。</li><li id="3dda" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://reacttraining.com/react-router/web/example/route-config" rel="noopener ugc nofollow" target="_blank">使用路线配置的代码示例</a>。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4b76" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">设置项目</h1><p id="8a2f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">用<a class="ae ky" href="https://github.com/facebook/create-react-app#readme" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>和cd创建一个新的React应用程序到项目中。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="5469" class="nv mr it nr b gy nw nx l ny nz">npx create-react-app routing-tutorial <br/>cd routing-tutorial <br/>npm install</span></pre><p id="0c6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装React路由器库。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="db73" class="nv mr it nr b gy nw nx l ny nz">npm install react-router-dom</span></pre><p id="75b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启动应用程序，并在教程的剩余部分保持运行。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="35c0" class="nv mr it nr b gy nw nx l ny nz">npm start</span></pre><p id="97cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了能够在我们的应用程序中使用路线，我们需要将应用程序包装在<code class="fe oa ob oc nr b">react-router</code>的<code class="fe oa ob oc nr b">&lt;BrowserRouter /&gt;</code>组件中。所以，打开<code class="fe oa ob oc nr b">index.js</code>文件，用下面的代码更新它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="983a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还希望一些基本的UI结构最终显示所有路线链接的菜单，然后显示我们所在的特定路线的内容。因此，打开<code class="fe oa ob oc nr b">App.js</code>文件，用以下代码替换其中的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码更新后，您应该会在浏览器中看到以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/02cd87723711fc9d281d18dcfb94d55e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tDF-ouKN42Sa8ZRZ.png"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4e5f" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">路线配置</h1><p id="28bb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">React中实现路由的基本方法是直接渲染<code class="fe oa ob oc nr b">&lt;Route/&gt;</code>组件，如下面的<a class="ae ky" href="https://reacttraining.com/react-router/web/example/basic" rel="noopener ugc nofollow" target="_blank">示例</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="676a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这种方法没有任何问题，但在构建一个重要的应用程序时，它可能会变得非常冗长/重复，使其难以重构，并且只是简单地跟踪您的路由发生了什么。</p><p id="74c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现路由的一种更程序化和更有组织的方式是设置路由配置，即路由配置的数组和对象，它们可以循环通过并呈现为<code class="fe oa ob oc nr b">&lt;Route/&gt;</code>。</p><p id="300d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe oa ob oc nr b">react-router</code> <a class="ae ky" href="https://reacttraining.com/react-router/web/example/route-config" rel="noopener ugc nofollow" target="_blank"> docs </a>的话说:</p><blockquote class="og oh oi"><p id="82ed" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">有些人发现了集中式路由配置的价值。路由配置只是数据。React擅长将数据映射成组件，而<code class="fe oa ob oc nr b">&lt;Route/&gt;</code>就是一个组件。</p><p id="7094" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">我们的route config只是一个带有<code class="fe oa ob oc nr b">path</code>和<code class="fe oa ob oc nr b">component</code>道具的逻辑“routes”数组，排序方式与在<code class="fe oa ob oc nr b">&lt;Switch/&gt;</code>中相同。</p></blockquote><p id="a10c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为这个应用程序创建自己的基本路线配置，具有以下特征:</p><ul class=""><li id="28fa" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe oa ob oc nr b">/</code> —用户可以登录应用程序的索引路线。</li><li id="0406" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oa ob oc nr b">/app</code> —认证用户的路由。</li></ul><p id="d98e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个文件<code class="fe oa ob oc nr b">routes.js</code>，并将下面的代码粘贴到其中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="394d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意上面代码的以下内容:</p><ul class=""><li id="e51b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe oa ob oc nr b">ROUTES</code>数组的结构模仿了app的路由结构。嵌套路由只是嵌套的<code class="fe oa ob oc nr b">routes</code>数组。</li><li id="2fd2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">每个特定的路由配置对象都具有以下属性:</li><li id="6b9e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oa ob oc nr b">path</code> —该配置处理的路线。</li><li id="7583" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oa ob oc nr b">key</code> —路线的唯一标识符。我们在教程中不会真正使用它们，但是当您想要引用/链接到没有硬编码路径的路径时，它们会变得非常有用，因为这些路径可能会被重新配置。</li><li id="8459" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oa ob oc nr b">exact</code> —一个布尔值，它确定<code class="fe oa ob oc nr b">path</code>是应该完全匹配，还是部分匹配。点击此处了解更多信息。</li><li id="f8bc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oa ob oc nr b">component</code>—app在特定<code class="fe oa ob oc nr b">path</code>时呈现的组件。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="1a74" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">渲染路线</h1><p id="16cf" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">我们需要根据配置实际呈现路线，这需要一些额外的有用组件。</p><h2 id="a5f2" class="nv mr it bd ms on oo dn mw op oq dp na li or os nc lm ot ou ne lq ov ow ng ox bi translated">助手组件</h2><p id="4e93" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">在<code class="fe oa ob oc nr b">routes.js</code>中，进行以下更新。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a7f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果适用，该组件允许呈现子路线。用官方文件的话说:</p><blockquote class="oy"><p id="c50a" class="oz pa it bd pb pc pd pe pf pg ph lu dk translated">一个用于<code class="fe oa ob oc nr b">&lt;Route/&gt;</code>的特殊包装器，它知道如何通过在<code class="fe oa ob oc nr b">routes</code> prop中将“子”路由传递给它所呈现的组件来处理它们</p></blockquote><p id="1201" class="pw-post-body-paragraph kz la it lb b lc pi ju le lf pj jx lh li pk lk ll lm pl lo lp lq pm ls lt lu im bi translated">使用上面组件，我们可以呈现一条单独的路线，但是我们还需要能够呈现一组在我们的<code class="fe oa ob oc nr b">ROUTES</code>配置中指定的路线。</p><p id="16d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在<code class="fe oa ob oc nr b">RouteWithSubRoutes</code>声明下面，为新组件<code class="fe oa ob oc nr b">RenderRoutes</code>添加下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="89d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意这里的“未找到”路线，如果在<code class="fe oa ob oc nr b">Switch</code>中没有匹配的路线，它将被渲染。</p><p id="4aa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种架构在每个嵌套层处理未定义的路线，所以理论上你可以留在应用程序的嵌套部分(如<code class="fe oa ob oc nr b">/app</code>)，而不是有一个通用的顶级“404-未找到”页面。</p><p id="85bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以自定义未定义路径和不同部分的功能。</p><h2 id="cbde" class="nv mr it bd ms on oo dn mw op oq dp na li or os nc lm ot ou ne lq ov ow ng ox bi translated">更新路线配置</h2><p id="a19b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">我们需要对这里的<code class="fe oa ob oc nr b">routes.js</code>文件进行的最后一次更新是使用<code class="fe oa ob oc nr b">RenderRoutes</code>作为<code class="fe oa ob oc nr b">APP</code>配置的<code class="fe oa ob oc nr b">component</code>，该配置在<code class="fe oa ob oc nr b">/app</code>路径名空间中声明了嵌套路由。</p><p id="27d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，用下面的代码更新<code class="fe oa ob oc nr b">ROUTES</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="48a0" class="nv mr it bd ms on oo dn mw op oq dp na li or os nc lm ot ou ne lq ov ow ng ox bi translated">实际渲染路线</h2><p id="f027" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">现在，打开您的<code class="fe oa ob oc nr b">App.js</code>文件，并将<code class="fe oa ob oc nr b">RenderRoutes</code>组件添加到应用程序的内容部分。这是顶层<code class="fe oa ob oc nr b">ROUTES</code>进入<code class="fe oa ob oc nr b">RenderRoutes</code>组件的地方。</p><p id="6576" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何路由配置的嵌套数组也使用这个<code class="fe oa ob oc nr b">RenderRoutes</code>组件，如前一步所示。</p><h2 id="b221" class="nv mr it bd ms on oo dn mw op oq dp na li or os nc lm ot ou ne lq ov ow ng ox bi translated">测试您的基本路由</h2><p id="6069" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">现在，您应该能够手动更新应用程序<code class="fe oa ob oc nr b">localhost:3000</code>之后的路径名，以查看应用程序右侧呈现的正确内容。</p><ul class=""><li id="06ab" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe oa ob oc nr b">/</code>应显示“登录”。</li><li id="efb3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oa ob oc nr b">/fake</code>应显示“未找到”。</li><li id="e8d3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oa ob oc nr b">/app</code>应显示“应用程序索引”。</li><li id="cf71" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oa ob oc nr b">/app/page</code>应显示“应用程序页面”。</li><li id="377c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oa ob oc nr b">/app/fake</code>应显示“未找到”。</li></ul><p id="9ae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是React中路由的基础！请继续阅读，以实现一个根据路由配置以编程方式构建的菜单，并保护路由免受未授权用户的访问。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="cf12" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">呈现任意嵌套的路线菜单/树</h1><p id="0cf0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">大多数应用程序都有一个链接菜单，便于用户导航应用程序，所以让我们实现一种方法来呈现一个菜单，该菜单反映了用<code class="fe oa ob oc nr b">ROUTES</code>配置定义的嵌套路线结构。</p><p id="2a56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们不能确定嵌套路由有多深，所以每次路由配置有另一个<code class="fe oa ob oc nr b">routes</code>数组时，我们都需要使用一些递归。</p><p id="74fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是完全更新的<code class="fe oa ob oc nr b">App.js</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="1f7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通读<code class="fe oa ob oc nr b">displayRouteMenu</code>函数的注释，感受一下它是如何工作的。</p><p id="d7ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了上面的更新，你应该能够点击左侧菜单中的链接，并在应用程序中导航。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="354f" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">限制登录用户的路由</h1><p id="4850" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">大多数应用程序都有某种身份验证，以便访问应用程序的某些区域。让我们做同样的事情(以一种非常基本/虚假的方式来保持教程的简单)并且只允许“登录”用户访问<code class="fe oa ob oc nr b">/app</code>路线。</p><p id="e3a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将使用<code class="fe oa ob oc nr b">localStorage</code>来保存一个用户名，并模仿该应用程序跟踪一个认证用户。</p><blockquote class="og oh oi"><p id="5701" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">显然，在合法的应用程序中，会有一些实际的登录机制、服务器端或第三方身份验证/授权、集中式用户/状态管理、保存到本地存储的任何身份验证令牌的到期日期，以及超出本教程范围的其他安全协议。</p><p id="989b" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">本教程是为了让事情进展得过于简单，但不应该成为现实生活中应用程序的蓝图。拉斐尔·布扎托·德·坎波斯指出了我之前解释中的一些混乱🙌</p></blockquote><h2 id="f57b" class="nv mr it bd ms on oo dn mw op oq dp na li or os nc lm ot ou ne lq ov ow ng ox bi translated">登录组件</h2><p id="41a0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">首先，我们需要制作一个非常基本的登录组件。因此，创建一个名为<code class="fe oa ob oc nr b">Login.js</code>的新文件，并将下面的代码粘贴到其中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="d711" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该组件让用户提供用户名并点击“登录”，将用户名保存到<code class="fe oa ob oc nr b">localStorage</code>并将用户重定向到<code class="fe oa ob oc nr b">/app</code>，即允许他们进入应用程序。</p><p id="ae77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在<code class="fe oa ob oc nr b">/</code>路径上呈现<code class="fe oa ob oc nr b">Login</code>组件，您需要更新<code class="fe oa ob oc nr b">routes.js</code>中正确的路径配置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="05e4" class="nv mr it bd ms on oo dn mw op oq dp na li or os nc lm ot ou ne lq ov ow ng ox bi translated">注销按钮</h2><p id="52f2" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">为了让测试应用程序和路由如何工作变得简单，我们还可以在<code class="fe oa ob oc nr b">App.js</code>文件的左侧栏添加一个注销按钮。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="03c0" class="nv mr it bd ms on oo dn mw op oq dp na li or os nc lm ot ou ne lq ov ow ng ox bi translated">测试路线功能(到目前为止…)</h2><p id="be5b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">好的，让我们看看到目前为止路由是如何工作的。</p><ul class=""><li id="0a0b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">转到<code class="fe oa ob oc nr b">/</code>路线，输入姓名，点击“登录”。你应该被引导到<code class="fe oa ob oc nr b">/app</code>路线。</li><li id="2cbc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">访问<code class="fe oa ob oc nr b">ROOT (/)</code>路线，您应该会被重定向回<code class="fe oa ob oc nr b">/app</code>，因为您已经登录。</li><li id="6ecf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">点击“注销”按钮，这将把您重新引导回<code class="fe oa ob oc nr b">/</code>路线。</li><li id="1610" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">尝试进入<code class="fe oa ob oc nr b">/app</code>路线<em class="oj">——哎呦！我们仍然需要限制“未经认证”的流量。</em>您已不再登录，因此应该无法访问这些路线！！！</li></ul><h2 id="1ae8" class="nv mr it bd ms on oo dn mw op oq dp na li or os nc lm ot ou ne lq ov ow ng ox bi translated">不允许未经身份验证的用户访问应用程序路由</h2><p id="6cd8" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">为了防止未经身份验证的用户(在本例中，在<code class="fe oa ob oc nr b">localStorage</code>中没有<code class="fe oa ob oc nr b">user</code>的任何访问者)，我们需要进行更新，将未经身份验证的流量重定向回登录屏幕。</p><p id="bb2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oj">你也可以显示一个警告屏幕来代替重定向，但是在这个例子中我们只是重定向。</em></p><p id="64d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我见过的许多例子都使用了某种类型的<code class="fe oa ob oc nr b">ProtectedRoute</code>高阶组件，我发现这是次优的，而且在使用大量路由时处理起来有点烦人。</p><p id="4040" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，与其保护每一个单独的路由，我们可以通过用一个组件包装它们来保护路由的一部分，该组件检查经过身份验证的用户，然后正常地呈现路由或者重定向到另一个页面。</p><p id="2dd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个简单的例子，我们所要做的就是更新当前只使用<code class="fe oa ob oc nr b">RenderRoutes</code>组件重定向未认证流量的<code class="fe oa ob oc nr b">APP</code>路由配置。</p><p id="cb80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，打开<code class="fe oa ob oc nr b">routes.js</code>，导入<code class="fe oa ob oc nr b">Redirect</code>组件，并用以下内容更新<code class="fe oa ob oc nr b">ROUTES</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="bd2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，确保你已经退出并尝试访问<code class="fe oa ob oc nr b">/app</code>路线，它不会让你，胜利！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="11f4" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">就是这样！</h1><p id="af2b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">显然，这种范式可以扩展到处理任何数量的高级/奇怪的路由设置，但希望本基础教程向您展示如何在React中开始使用可靠的路由。</p><p id="ac57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更高级的例子，你可以<a class="ae ky" href="https://github.com/ryanjyost/react-spa-starter" rel="noopener ugc nofollow" target="_blank">看看这个回购</a>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="13e6" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">资源</h1><ul class=""><li id="e41d" class="lv lw it lb b lc ni lf nj li nk lm nl lq nm lu ma mb mc md bi translated"><a class="ae ky" href="https://reacttraining.com/react-router/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank"> React路由器官方文档</a></li><li id="deb4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/ryanjyost/react-spa-starter" rel="noopener ugc nofollow" target="_blank"> React SPA启动器</a></li><li id="b385" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://reacttraining.com/react-router/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank"> React路由器快速启动</a></li><li id="992f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://reacttraining.com/react-router/web/example/route-config" rel="noopener ugc nofollow" target="_blank"> React路由器路由配置示例</a></li><li id="e85d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">创建-反应-应用程序</li><li id="12a5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://reacttraining.com/react-router/web/example/basic" rel="noopener ugc nofollow" target="_blank"> React路由器基本示例</a></li></ul></div></div>    
</body>
</html>