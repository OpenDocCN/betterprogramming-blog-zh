<html>
<head>
<title>The Ultimate Guide to Building a Chrome Extension</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建Chrome扩展的终极指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-ultimate-guide-to-building-a-chrome-extension-4c01834c63ec?source=collection_archive---------2-----------------------#2020-02-20">https://betterprogramming.pub/the-ultimate-guide-to-building-a-chrome-extension-4c01834c63ec?source=collection_archive---------2-----------------------#2020-02-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c0d7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">快速轻松地构建Chrome扩展</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dd113f2dfbe44e637a4e53a0f8b2067b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NG1J_m36-jvDOGTsxyh19g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.pexels.com/photo/two-people-on-mountain-cliff-1647962/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae ky" href="https://www.pexels.com/@valdemaras-d-784301?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Valdemaras D. </a>摄影</p></figure><p id="0f4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程将帮助你建立创建Chrome扩展所需的心智模型。在我们构建扩展的过程中，我将介绍核心概念。</p><p id="4059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从头开始构建一个Chrome扩展，让你可以替换一篇中型文章中的任何文本。这是最终结果的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/f2309238d059bfc10fdbecc64f06c36c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LOByOJ_i3kEy065XFKoUMg.gif"/></div></div></figure><p id="25dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我建议您在阅读时在您最喜欢的文本编辑器中构建扩展。在我们介绍完每个关键概念后，我会继续在GitHub上添加代码链接，这样你就可以跟踪到目前为止我们已经构建了什么。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7ada" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="28ed" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我将本文分成了五个主要概念，在构建任何扩展时，您都需要了解这五个概念，即清单文件、内容脚本、后台脚本、消息传递和扩展弹出窗口。</p><p id="575c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还从头开始构建了一个扩展，因为我们涵盖了上面提到的每个主题。你可以在这里找到扩展<a class="ae ky" href="https://github.com/prateek3255/replacely" rel="noopener ugc nofollow" target="_blank">的最终代码。</a></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b109" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">先决条件</h1><p id="c475" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我假设你熟悉基本的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTML" rel="noopener ugc nofollow" target="_blank"> HTML </a>、<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS" rel="noopener ugc nofollow" target="_blank"> CSS </a>和<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>，并且至少对<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API" rel="noopener ugc nofollow" target="_blank">HTML DOM API</a>有一个模糊的了解。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="117b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">初始设置</h1><p id="b304" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">您将需要创建一个新文件夹，所有与该扩展相关的文件都将保存在其中，还需要一个代码编辑器和一个Chrome或Chrome浏览器来开发和测试该扩展。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b70b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">清单文件</h1><p id="6aac" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">每个扩展都需要一个清单文件来安装和运行。这个文件就像你的Chrome扩展的蓝图。它告诉扩展它是什么，允许它做什么，以及什么时候允许它做。</p><p id="f64a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个名为<code class="fe na nb nc nd b">manifest.json</code>的新文件，并将以下代码片段粘贴到其中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6ede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来分解一下:</p><ul class=""><li id="1b1c" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">属性是扩展的主要标识符，将在扩展管理UI和Chrome网络商店中使用。它只有45个字符的限制。</li><li id="f9f4" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">接下来是<code class="fe na nb nc nd b">description</code>键，用来描述你的分机。它也用于扩展管理UI和Chrome网络商店。它的字符限制稍大，为132个字符。</li><li id="49d3" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe na nb nc nd b">version</code>键定义了你的扩展的当前版本(我们从0.1开始)。每当您想要发布一个新版本的扩展时，您都需要更新这个字段。</li><li id="98b0" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">最后但同样重要的是，<code class="fe na nb nc nd b">manifest_version</code>指定了我们的包目标的清单规范。我们应该使用第二版，因为第一版很久以前就被废弃了。如果你对第一版到第二版的变化感到好奇，你可以在这里找到变更日志<a class="ae ky" href="https://developer.chrome.com/extensions/manifestVersion" rel="noopener ugc nofollow" target="_blank">。</a></li></ul><p id="2abf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你猜怎么着？我们已经有足够的内容在浏览器中加载我们的扩展:</p><ul class=""><li id="4fe4" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">只需转到<code class="fe na nb nc nd b">chrome://extensions</code>并从右上角打开开发者模式:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/d98db93efc1c03a88d62c3562582c221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2lq9GvoSQrwJF4_I"/></div></div></figure><ul class=""><li id="0712" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">然后点击<code class="fe na nb nc nd b">Load unpacked</code>，选择包含我们刚刚创建的清单文件的文件夹:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/d99859070af98baf79ebce0ac22265a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t97nZNjMwUhbGBNI"/></div></div></figure><ul class=""><li id="ed62" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">好了，我们的扩展很快就启动并运行了。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/746e52fb77e699273b90319538df58e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aVYkrAXSj6CRmKn4"/></div></div></figure><p id="f21a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这个扩展没有合适的图标看起来还是有点怪，所以我们来添加一个。</p><ul class=""><li id="53c1" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">创建一个名为images的文件夹，并将这些图像下载并解压到该文件夹中。</li><li id="1297" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">然后将其粘贴到您的清单文件中:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><ul class=""><li id="1f85" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">现在返回到扩展管理页面，单击扩展卡上的重新加载按钮。瞧，我们的扩展现在开始看起来像一个真正的扩展了！</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/38755a1313cd09c7172e56b22c561e92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mSlYtEjt5Erfp6Wk"/></div></div></figure><p id="1f94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么这是如何工作的，为什么这里需要两个不同的键，即使它们有相同的值？</p><p id="5f32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我给你的图片文件夹对于同一张图片有不同的文件大小。我们使用size作为键，使用相应大小的图像路径作为值。</p><p id="fe86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">page_action</code>下的<code class="fe na nb nc nd b">default_icon</code>键用于指定将用于浏览器工具栏的图标，而<code class="fe na nb nc nd b">icons</code>键指定将用于其他任何地方的图标，例如扩展管理页面和Chrome网络商店。</p><p id="e8b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>只有<code class="fe na nb nc nd b">name</code>、<code class="fe na nb nc nd b">manifest_version</code>和扩展<code class="fe na nb nc nd b">version</code>是必需键。此外，这里使用的所有路径都是相对于清单文件的。</p><p id="565e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里了解更多关于清单文件<a class="ae ky" href="https://developer.chrome.com/extensions/manifest" rel="noopener ugc nofollow" target="_blank">中使用的不同键及其角色的信息。此外，该步骤的代码可在</a><a class="ae ky" href="https://github.com/prateek3255/replacely/tree/ae684e7fe75d15c6eea6576e3a890cce03378299" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="098a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">内容脚本</h1><p id="6805" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在最后一步中，我们在浏览器中安装并运行了扩展。现在让我们替换一些文本。</p><p id="97b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是内容脚本的用武之地。它们允许您修改网页DOM，与原始网页JavaScript隔离工作。</p><p id="cbb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网页上的扩展可以执行多个内容脚本。这些脚本中的每一个都将在它们自己的孤立世界中运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/a9e7e5b81e8cce05c6080f14f4f4b503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4JMwpOfsTl2dwFl3"/></div></div></figure><p id="284f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个孤立的世界都有自己的JavaScript环境，确保库之间不会冲突。</p><p id="0609" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DOM在所有内容脚本和原始网页的JavaScript之间共享。</p><p id="fa3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的扩展，我们还需要访问DOM来修改网页的内容，所以我们需要一个内容脚本。</p><p id="d25b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以以编程方式注入脚本<a class="ae ky" href="https://developer.chrome.com/extensions/content_scripts#programmatic" rel="noopener ugc nofollow" target="_blank">(从后台或弹出文件)或以声明方式注入</a><a class="ae ky" href="https://developer.chrome.com/extensions/content_scripts#declaratively" rel="noopener ugc nofollow" target="_blank">(在特定页面上自动执行脚本)。</a></p><p id="5fc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们希望这个脚本在中型文章中执行，所以现在我们将使用声明性方法。</p><p id="55d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将以下代码片段添加到您的清单文件中:</p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="0c26" class="oc me it nd b gy od oe l of og">{<br/> "name": "Replacely",<br/> .<br/> .<br/> .<br/> "content_scripts": [<br/>      {<br/>        "matches": ["<a class="ae ky" href="https://medium.com/*" rel="noopener">https://medium.com/*</a>"],<br/>        "js": ["contentScript.js"]<br/>      }<br/>    ]<br/>}</span></pre><p id="d933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">content_scripts</code>是一个对象数组，其中每个对象具有以下属性:</p><ul class=""><li id="7e33" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><code class="fe na nb nc nd b">matches</code>—<a class="ae ky" href="https://regexr.com/" rel="noopener ugc nofollow" target="_blank">regex</a>字符串数组，指定内容脚本将被注入的页面。</li><li id="8895" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe na nb nc nd b">js</code> -表示应该在匹配页面上执行的文件的字符串数组。</li></ul><p id="364e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一些其他的属性，你可以在这里找到<a class="ae ky" href="https://developer.chrome.com/extensions/content_scripts#declaratively" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="d566" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们创建一个名为<code class="fe na nb nc nd b">contentScript.js</code>的新文件，并将这个日志添加到其中:</p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="88e9" class="oc me it nd b gy od oe l of og">console.log("Content script running...");</span></pre><p id="6acd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在重新加载扩展，打开任何您喜欢的中型文章，并检查控制台。如果一切都按预期运行，您将在控制台中看到以下日志。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/30638309c942d6751370804fac80d842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/0*MKhgBPyuneigH9DC"/></div></figure><p id="4003" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="oi">注意:</em> </strong> <em class="oi">每次我们对扩展进行修改时，您都需要重新加载扩展。</em></p><p id="db27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们现在已经准备好了内容脚本，所以让我们添加创建这个扩展的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a1b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码选择媒体页面上所有不同种类的标签，在它们的文本内容中找到<code class="fe na nb nc nd b">FIND</code>字符串，并用<code class="fe na nb nc nd b">REPLACE_WITH</code>字符串替换它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/ad0cd9fd8d1ef856b655902d1a3de2ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-RIunq80WvOuFKly"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正在运行的内容脚本，将单词“The”替换为“replacely”。好玩不是吗；).</p></figure><p id="9acc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过对不同媒体文章的<code class="fe na nb nc nd b">FIND</code>和<code class="fe na nb nc nd b">REPLACE_WITH</code>变量使用不同的值，试着按照代码进行操作。</p><p id="2f87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总结这一节，我们学习了内容脚本如何让我们访问网页的DOM，允许我们独立于网页JavaScript操作它。你可以在这里找到到目前为止<a class="ae ky" href="https://github.com/prateek3255/replacely/tree/271c38c317250ba9a91bc08222b86a4604c52ed4" rel="noopener ugc nofollow" target="_blank">的代码。</a></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="efd6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">背景脚本</h1><p id="98e0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这个脚本在后台监听特定的事件，比如更改标签、URL更新和添加书签，它还做各种其他事情来影响浏览器的整体行为。</p><p id="bfc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与内容脚本不同，它作为一个整体为浏览器工作，而不是在单独的选项卡中有单独的实例。尽管一个扩展可以有多个后台脚本。</p><p id="5c52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，浏览器一启动，后台脚本就被执行，而内容脚本在要执行脚本的网页加载时被执行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/7748ef69d8defacc1a34f3e555b341d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CeMIJkbkNrIdekhb"/></div></div></figure><p id="8ab2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建一个背景脚本，请将下面的代码片段添加到您的<code class="fe na nb nc nd b">mainfest.json</code>中:</p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="599d" class="oc me it nd b gy od oe l of og">{<br/> "name": "Replacely",<br/> .<br/> .<br/> .<br/> "background": {<br/>     "scripts": ["background.js"],<br/>     "persistent": false<br/> }<br/>}</span></pre><p id="cf72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与内容脚本类似，<code class="fe na nb nc nd b">background</code>键也接受一组通过<code class="fe na nb nc nd b">scripts</code>键执行的脚本。</p><p id="c4da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您的扩展使用<a class="ae ky" href="https://developer.chrome.com/extensions/webRequest" rel="noopener ugc nofollow" target="_blank"> chrome.webRequest </a> API来阻止或修改网络请求时，需要将<code class="fe na nb nc nd b">persistent</code>键设置为true。当持久键为false时，浏览器会在几秒钟不活动后自动挂起脚本。</p><p id="9b6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个名为<code class="fe na nb nc nd b">backgound.js</code>的新文件，向其中添加以下日志，然后重新加载扩展。</p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="e681" class="oc me it nd b gy od oe l of og">console.log("Background script running...");</span></pre><p id="adbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在再次打开您最喜欢的中型文章并检查控制台:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/caf5cab031d52aaf63a81826a2ba8703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/0*4Fcls8Czv0BynYkF"/></div></figure><p id="da23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等，什么？这是我们在内容脚本中添加的控制台。那么后台脚本在哪里被记录呢？</p><p id="85c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，如前所述，它作为一个整体为浏览器工作——您将无法在网页的控制台上查看日志。相反，它有自己的一套开发工具。转到您的扩展管理页面，然后单击“检查视图背景页面”链接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/7a944c8268ea572915f1db107a0f3837.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/0*xOMmFMUnVyttnxbF"/></div></figure><p id="ac30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们可爱的小圆木:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/b48b24e245d478a17a5f3f59c384f45b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/0*ezY8n1HDs2DLvv6N"/></div></figure><p id="b8f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们知道了什么是后台脚本，让我们用我们的扩展来尝试这些事件。首先，对于非中等URL，我们将使浏览器工具栏中的扩展图标变灰。</p><p id="0bc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要使用<code class="fe na nb nc nd b"><a class="ae ky" href="https://developer.chrome.com/declarativeContent" rel="noopener ugc nofollow" target="_blank">chrome.declarativeContent</a></code> API，它允许我们根据页面的内容或URL采取行动，而不需要获得读取页面内容的许可。</p><p id="7f29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数API，比如我们将要使用的API，需要在清单文件中的<code class="fe na nb nc nd b">permissions</code>键下注册，以便扩展使用它们:</p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="38bb" class="oc me it nd b gy od oe l of og">{<br/> "name": "Replacely",<br/> .<br/> .<br/> .<br/> "permissions": ["declarativeContent"], <br/> .<br/> .<br/> .<br/>}</span></pre><p id="02c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在将下面的片段添加到<code class="fe na nb nc nd b">background.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2a4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能看起来有点吓人，但实际上不是。我们创建了一个名为<code class="fe na nb nc nd b">iconRules</code>的数组，其中包含了我们扩展的所有规则。我们现在只有一条规则。</p><p id="8410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个规则都是一个带有两个键的对象:<code class="fe na nb nc nd b">conditions</code>和<code class="fe na nb nc nd b">actions</code>。它们指定了条件以及在满足这些条件时要执行的相应操作。</p><p id="9006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，唯一的条件是主机应该等于<code class="fe na nb nc nd b">medium.com</code>并且要执行的动作是显示页面动作，这是该页面的一个活动工具栏图标。</p><p id="20c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面几行中，我们通过将<code class="fe na nb nc nd b">undefined</code>传递给<code class="fe na nb nc nd b">chrome.declarativeContent.onPageChanged.removeRules</code>来删除页面发生变化时的所有现有规则。在回调中，我们传递刚刚使用<code class="fe na nb nc nd b">chrome.declarativeContent.onPageChanged.addRules</code> API创建的规则。</p><p id="0e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在重新加载扩展并访问任何非介质URL时，您应该在浏览器工具栏中看到以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/5fffcdfed91628621a2ffdf9d32595e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/0*2yT8fKr-_uWE-bE2"/></div></figure><p id="c3b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在中等URL上，您应该会看到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/b9d092b5351ae40d25d59e92080076fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/0*16M9tEJi5vWydvY8"/></div></figure><p id="1db3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，在本节中，我们看到了后台脚本如何帮助我们监听浏览器事件并使用它们采取行动。</p><p id="c1f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里了解更多关于后台脚本<a class="ae ky" href="https://developer.chrome.com/extensions/background_pages" rel="noopener ugc nofollow" target="_blank">的内容，在这里</a>找到到此为止的代码<a class="ae ky" href="https://github.com/prateek3255/replacely/tree/3d9d3e710dd4e073b4661f9ed6de82ec559369ac" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="93b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将看到如何通过消息传递将后台脚本和内容脚本的功能结合起来。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="54e5" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">信息传递</h1><p id="f444" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">到目前为止，我们已经了解了如何使用内容脚本来操作网页数据，以及如何通过在后台脚本中监听浏览器事件来执行一些浏览器级的操作。</p><p id="309e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果你想通过监听一些浏览器事件来操纵网页，或者反之亦然，该怎么办呢？这就是消息传递的由来。</p><p id="0652" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过消息传递，您可以在内容脚本和扩展之间进行通信。任何一端都可以侦听从另一端发送的消息，并在同一信道上做出响应。消息可以包含任何有效的JSON对象(null、boolean、number、string、array或object)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/67a54fd18ca8a067aeccd954a7b21078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rl8klDGPtTe6XNBm"/></div></div></figure><p id="e3ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种类型的消息传递API可用——一种用于简单的一次性请求，另一种更复杂，用于需要在内容脚本和扩展之间共享状态的长期连接。</p><p id="ee9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的例子，我们将使用简单的一次性请求消息传递。</p><p id="be66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，只要中等文章加载，扩展就会替换文本，现在让我们只在单击浏览器工具栏中的扩展图标时替换文本。</p><p id="8e70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要在后台脚本中监听扩展图标上的点击事件，然后向内容脚本发送一条消息，在收到该消息时替换文本。</p><p id="26b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将下面的片段添加到您的<code class="fe na nb nc nd b">background.js</code>文件中:</p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="b895" class="oc me it nd b gy od oe l of og">.<br/>.<br/>.<br/>chrome.pageAction.onClicked.addListener(function(){<br/>    chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {<br/>        chrome.tabs.sendMessage(tabs[0].id, {action: "REPLACE_TEXT"});<br/>    })<br/>});</span></pre><p id="c904" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b"><a class="ae ky" href="https://developer.chrome.com/extensions/pageAction#event-onClicked" rel="noopener ugc nofollow" target="_blank">chrome.pageAction.onClicked</a></code> API接受一个回调，每当单击浏览器工具栏中的扩展图标时，就会触发这个回调。</p><p id="b281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于浏览器中可以打开多个标签页，我们只想将消息发送到当前活动的标签页，所以我们使用<code class="fe na nb nc nd b"><a class="ae ky" href="https://developer.chrome.com/extensions/tabs#method-query" rel="noopener ugc nofollow" target="_blank">chrome.tabs.query</a></code> API在当前窗口中查找当前活动的标签页。它接受一个回调，该回调包含一个满足上述查询的选项卡数组作为它的参数。</p><p id="d08e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们使用上述回调函数中的<code class="fe na nb nc nd b"><a class="ae ky" href="https://developer.chrome.com/extensions/runtime#method-sendMessage" rel="noopener ugc nofollow" target="_blank">chrome.tabs.sendMessage</a></code> API向活动选项卡发送消息。它将选项卡ID作为第一个参数，将消息作为第二个参数。</p><p id="b866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe na nb nc nd b">contentScript.js</code>文件中添加下面的代码片段来监听任何消息:</p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="adb4" class="oc me it nd b gy od oe l of og">.<br/>.<br/>.<br/>chrome.runtime.onMessage.addListener(function(message){<br/>    console.log(message);<br/>});</span></pre><p id="8f05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，无论何时收到消息，都会执行对<code class="fe na nb nc nd b"><a class="ae ky" href="https://developer.chrome.com/extensions/runtime#event-onMessage" rel="noopener ugc nofollow" target="_blank">chrome.runtime.onMessage</a></code>的回调，第一个参数是它收到的消息。</p><p id="0e33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在重新加载扩展，打开一篇中型文章，点击扩展图标。如果一切正常，每次单击图标时，您都会在浏览器控制台中看到以下消息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/68bb3cbba5bfed1ae2125f2092d3a1d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/0*pI42uqxQdwoFYiqv"/></div></figure><p id="5a0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们只需要在收到上述消息时替换文本。用下面的代码片段替换您的<code class="fe na nb nc nd b">contentScript.js</code>文件中的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="11c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只是将我们的replacer逻辑包装在一个名为<code class="fe na nb nc nd b">replaceText</code>的函数中，并且只有当我们收到一个action属性的值为<code class="fe na nb nc nd b">REPLACE_TEXT</code>的消息时才执行它。</p><p id="5052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在重新加载扩展来看看神奇之处:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/6617bf4e92a9bb69570a3e786fbe264a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DIqH-bAK1pjvSbn9"/></div></div></figure><p id="cd6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一节中，我们看到了如何在消息传递中结合使用内容脚本和后台脚本。你可以在这里找到到目前为止的代码<a class="ae ky" href="https://github.com/prateek3255/replacely/tree/09f92bc3471b45dc7b6f1e52c7cd154ee0a108f6" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1ce9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">扩展弹出菜单</h1><p id="f320" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">到目前为止，当我们点击图标时，我们的扩展可以替换文本，但是如果我们需要控制<code class="fe na nb nc nd b">FIND</code>和<code class="fe na nb nc nd b">REPLACE_WITH</code>字符串，我们仍然需要修改代码。</p><p id="b795" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一个用户界面，以便用户可以决定查找和替换字符串。弹出窗口是Chrome扩展可以提供的几种用户界面类型之一。</p><p id="d572" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你曾经安装过Chrome扩展，你可能已经知道什么是弹出窗口。它们通常在单击浏览器工具栏中的扩展图标时出现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/7995c8af982cb43bf95b13c288e9c943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ScHmX12rrWqd10_c"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一些流行扩展的弹出窗口</p></figure><p id="b827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，将下面一行添加到清单文件中的<code class="fe na nb nc nd b">page_action</code>:</p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="2d90" class="oc me it nd b gy od oe l of og">{<br/> .<br/> .<br/> .<br/> "page_action": {<br/>        "default_popup": "popup.html",<br/>    .<br/>    .<br/> }<br/> .<br/> .<br/>}</span></pre><p id="b353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在创建一个名为<code class="fe na nb nc nd b">popup.html</code>的文件，并将下面的代码片段粘贴到其中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后创建一个名为<code class="fe na nb nc nd b">popup.css</code>的文件，并将这个 CSS粘贴到<a class="ae ky" href="https://raw.githubusercontent.com/prateek3255/replacely/92bd878257af950e0dbe53fde4c6f4d66e2c3705/popup.css" rel="noopener ugc nofollow" target="_blank">文件中。</a></p><p id="fdcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，重新加载扩展并单击浏览器工具栏中的图标，您将能够看到我们刚刚创建的弹出窗口。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/bc666a6a90d6523c0fe99237e848a954.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*1pGtHhjaCajc0VBpJw_-Bg.png"/></div></figure><p id="177d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还会注意到，我们在上一节中添加的文本替换操作停止了。这是因为<code class="fe na nb nc nd b">chrome.pageAction.onClicked</code> API只有在扩展中没有弹出窗口时才起作用。所以，你可以从<code class="fe na nb nc nd b">background.js</code>文件中删除<a class="ae ky" href="https://github.com/prateek3255/replacely/blob/09f92bc3471b45dc7b6f1e52c7cd154ee0a108f6/background.js#L16-L20" rel="noopener ugc nofollow" target="_blank">代码，因为它现在已经没用了。</a></p><p id="3add" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe na nb nc nd b">popup.html</code>的底部，我们还包含了一个名为<code class="fe na nb nc nd b">popup.js</code>的脚本——它将包含表单提交时需要执行的代码。</p><p id="936d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用下面的代码创建一个名为<code class="fe na nb nc nd b">popup.js</code>的文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4e79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将<code class="fe na nb nc nd b">onsubmit</code>处理程序附加到表单上，在该处理程序中，我们向内容脚本发送了一条消息——类似于我们在上一节中所做的。然而，这一次我们还在消息中添加了<code class="fe na nb nc nd b">find</code>和<code class="fe na nb nc nd b">replace</code>文本，并将在各自输入中输入的文本作为它们的值。</p><p id="abd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们还需要稍微修改一下<code class="fe na nb nc nd b">contentScript.js</code>，因为之前我们已经对查找和替换文本进行了硬编码。将以下代码片段粘贴到内容脚本文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0d2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经更新了<code class="fe na nb nc nd b">replaceText</code>函数，它现在接受两个包含<code class="fe na nb nc nd b">find</code>和<code class="fe na nb nc nd b">replace</code>字符串的参数，这在以前是硬编码的。</p><p id="5840" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在最后一次重新加载扩展，查看运行中的扩展(这次您可能还需要重新加载中型文章)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/13cee887fa28eee43faf6b568e8f51a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JKHz668LcxOeBkPo"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="19d2" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="bd3d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果你已经读到这里，我希望你已经很好的理解了Chrome扩展是如何工作的，它们能做什么，最重要的是，你如何创建一个。如果你有任何疑问，请在下面的评论中写下来，或者在<a class="ae ky" href="https://twitter.com/@psuranas" rel="noopener ugc nofollow" target="_blank"> twitter </a>上ping我。</p><p id="c24e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果您想探索更多的内容，可以尝试使用<code class="fe na nb nc nd b"><a class="ae ky" href="https://developer.chrome.com/apps/storage" rel="noopener ugc nofollow" target="_blank">chrome.storage</a></code> API持久化查找和替换更改，并在弹出菜单中添加一个清除按钮来清除所有当前的更改。对着<a class="ae ky" href="https://github.com/prateek3255/replacely" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>开个PR，够好我再审核合并。</p><p id="6b2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oi">感谢阅读！</em></p></div></div>    
</body>
</html>