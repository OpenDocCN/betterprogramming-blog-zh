<html>
<head>
<title>How to Build a Kotlin Spring Boot Application With Spring WebFlux and WireMock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Spring WebFlux和WireMock构建一个Kotlin Spring Boot应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/part-i-how-to-unit-test-your-kotlin-springboot-webflux-webclient-that-is-calling-external-api-714ccaa186c?source=collection_archive---------5-----------------------#2019-08-28">https://betterprogramming.pub/part-i-how-to-unit-test-your-kotlin-springboot-webflux-webclient-that-is-calling-external-api-714ccaa186c?source=collection_archive---------5-----------------------#2019-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9024" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">干净、现代的科特林</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d594cbbe97ef72998d1d24ff791b1d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-nk2nlnGkNtkh1cJ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Spring Boot框架下的科特林</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="038d" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">介绍</h1><p id="9d17" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated"><a class="ae mt" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank">科特林</a>、<a class="ae mt" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>和<a class="ae mt" href="http://wiremock.org/" rel="noopener ugc nofollow" target="_blank"> WireMock </a>是构建REST API服务时使用的强大组合。我是Spring Boot的新手，但是已经喜欢上它了，因为它提供了无缝的API，例如使用<code class="fe mu mv mw mx b">@Configuration</code>、<code class="fe mu mv mw mx b">@Component</code>和<code class="fe mu mv mw mx b">@Bean</code>的依赖注入。</p><p id="282b" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">Kotlin作为一种语言是非常好和方便的。它的语法很简单(我知道，简单是相对的)，很现代(不管这是什么意思)。WireMock是一个非常好的单元测试工具，尤其是当您的服务调用外部API提供者时。</p><p id="4692" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">本教程将涵盖以下内容:</p><ul class=""><li id="479b" class="nd ne it lz b ma my md mz mg nf mk ng mo nh ms ni nj nk nl bi translated">使用科特林、Spring Boot和Spring <a class="ae mt" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux" rel="noopener ugc nofollow" target="_blank"> WebFlux </a>建立一个简单的REST API服务。这个API服务将调用<a class="ae mt" href="https://openweathermap.org/api" rel="noopener ugc nofollow" target="_blank">开放天气</a> API。</li><li id="bebd" class="nd ne it lz b ma nm md nn mg no mk np mo nq ms ni nj nk nl bi translated">使用WireMock编写单元测试来模拟Open Weather API服务器响应。</li></ul></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="4032" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">生成科特林Spring Boot项目</h1><ul class=""><li id="7584" class="nd ne it lz b ma mb md me mg nr mk ns mo nt ms ni nj nk nl bi translated">转到<a class="ae mt" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank">https://start . spring . io</a>。</li><li id="a759" class="nd ne it lz b ma nm md nn mg no mk np mo nq ms ni nj nk nl bi translated">生成一个Kotlin <a class="ae mt" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> Gradle </a>项目并添加<a class="ae mt" href="https://docs.spring.io/spring-framework/docs/5.0.0.M1/spring-framework-reference/html/web-reactive.html" rel="noopener ugc nofollow" target="_blank"> Spring Reactive Web </a>作为依赖项。</li><li id="ca07" class="nd ne it lz b ma nm md nn mg no mk np mo nq ms ni nj nk nl bi translated">最后，点击<em class="nu">生成项目</em>。这将下载一个包含项目结构的ZIP文件。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/00dcde1bdce9ead8de7fe40cd5056c2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-btPLbn0c7XjUeH3-_CStA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">弹簧初始化r</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="cb24" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">构建API路由和处理函数</h1><ul class=""><li id="3dea" class="nd ne it lz b ma mb md me mg nr mk ns mo nt ms ni nj nk nl bi translated">解压缩文件，并使用IDE打开它。ZIP文件包含以下项目结构。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/9f2b548c1a3671c8bac92d05732ab749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*ZR7E9YGmatLZxZPGNAIB2g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">初始项目结构</p></figure><ul class=""><li id="fb69" class="nd ne it lz b ma my md mz mg nf mk ng mo nh ms ni nj nk nl bi translated">让我们构建我们的API路线。</li></ul><p id="8c76" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">注意<code class="fe mu mv mw mx b">@Suppress("unused")</code>注释。这是为了摆脱IntelliJ的“类路径从未被使用”的代码检查，因为我们不会在任何地方直接使用T4类。(顺便说一句，这不是必须的，只有当您看到IntelliJ的代码检查突出显示未使用的类时，才会感到恼火。)</p><p id="93a4" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">这样做的原因是Spring Boot实际上通过<code class="fe mu mv mw mx b">@Configuration</code>和<code class="fe mu mv mw mx b">@Bean</code>注释来管理路由的注册。</p><p id="5468" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">Spring WebFlux还提供了路由DSL，你可以在<code class="fe mu mv mw mx b">route</code>函数中看到。这里，我们指定我们的API基本路由以<code class="fe mu mv mw mx b">/api</code>为前缀，并接受一个内容类型<code class="fe mu mv mw mx b">application/json</code>。</p><p id="7721" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">我们使用<code class="fe mu mv mw mx b">nest</code>，它基本上是块内定义的任何路线的前缀；这种情况下是<code class="fe mu mv mw mx b">/current-weather</code>。</p><p id="3120" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">所以，如果你将来想增加更多的路线，你可以把它们放在这个街区。它们将自动继承<code class="fe mu mv mw mx b">/api</code>前缀和<code class="fe mu mv mw mx b">application/json</code>内容类型。</p><p id="7cb4" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">我们的route的方法是<code class="fe mu mv mw mx b">POST</code>，任何点击这个route的请求的处理函数是<code class="fe mu mv mw mx b">getCurrentWeather</code>，由实现<code class="fe mu mv mw mx b">WeatherService</code>的类提供。稍后将详细介绍。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Route.kt</p></figure><ul class=""><li id="5c0d" class="nd ne it lz b ma my md mz mg nf mk ng mo nh ms ni nj nk nl bi translated">让我们定义我们的接口、实现类和数据模型。</li></ul><h2 id="eb2c" class="nz lg it bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv ok bi translated"><strong class="ak">界面</strong></h2><p id="816e" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">这个接口定义了API契约，并将由真正的<code class="fe mu mv mw mx b">WeatherService</code>类实现，该类传递给上面的<code class="fe mu mv mw mx b">Route</code>类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">WeatherService.kt</p></figure><h2 id="b9d2" class="nz lg it bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv ok bi translated"><strong class="ak">实现类</strong></h2><p id="4abd" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated"><code class="fe mu mv mw mx b">@Component</code>标注是我很喜欢的另一个Spring“魔术”。它基本上在应用程序上下文中注册了这个类，这样我们上面的<code class="fe mu mv mw mx b">Route</code>类就知道它应该使用这个实现类。</p><p id="5426" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">注意<code class="fe mu mv mw mx b">Route</code>类需要<code class="fe mu mv mw mx b">WeatherService</code>，而<code class="fe mu mv mw mx b">OpenWeatherImpl</code>是实现<code class="fe mu mv mw mx b">WeatherService</code>的类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">OpenWeatherImpl.kt</p></figure><p id="dc03" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">让我们通过添加调用外部API的功能来继续我们的实现类。</p><p id="beb2" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">Spring WebFlux提供了一个<code class="fe mu mv mw mx b">WebClient</code>，我们可以用它来进行HTTP调用。我们需要把这个传给我们的<code class="fe mu mv mw mx b">OpenWeatherImpl</code>班。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有工作实现的OpenWeatherImpl.kt</p></figure><p id="005d" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">我们需要另一个类来处理实现类中所需的<code class="fe mu mv mw mx b">WebClient</code>的创建。这样做的目的是使我们的单元测试更容易，因为我们可以模仿<code class="fe mu mv mw mx b">WebClient</code>或者配置它。</p><p id="095b" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">注意<code class="fe mu mv mw mx b">createWebClient</code>函数上的<code class="fe mu mv mw mx b">@Bean</code>注释。这就是我们的<code class="fe mu mv mw mx b">OpenWeatherImpl</code>如何获得对<code class="fe mu mv mw mx b">WebClient</code>对象的依赖。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">OpenWeatherConfig.kt</p></figure><p id="1bd4" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">此外，我们需要在我们的<code class="fe mu mv mw mx b">application.properties</code>文件中添加开放天气API基础URL。</p><p id="5b5e" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">我们通过<code class="fe mu mv mw mx b">@Value</code>注释将这个值传递给上面的<code class="fe mu mv mw mx b">OpenWeatherConfig</code>类。对于本教程，我们的API密匙将存储为一个环境变量<code class="fe mu mv mw mx b">OPENWEATHER_API_KEY</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用程序.属性</p></figure><h2 id="de19" class="nz lg it bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv ok bi translated"><strong class="ak">数据模型</strong></h2><p id="2c0e" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">这个文件定义了我们发送给Open Weather API的对象的模型，以及我们期望从Open Weather API接收的对象的模型。(请注意，我们只捕获了一个字段<code class="fe mu mv mw mx b">main</code>，真实响应有更多字段。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Model.kt</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="4503" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">运行应用程序并调用API端点</h1><ul class=""><li id="9c38" class="nd ne it lz b ma mb md me mg nr mk ns mo nt ms ni nj nk nl bi translated">我们的API端点已经准备就绪，让我们运行应用程序。转到<code class="fe mu mv mw mx b">WiremockdemoApplication.kt</code>并运行<code class="fe mu mv mw mx b">main</code>功能。</li><li id="d983" class="nd ne it lz b ma nm md nn mg no mk np mo nq ms ni nj nk nl bi translated">您可以通过像<code class="fe mu mv mw mx b"><a class="ae mt" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank">Postman</a></code>这样的工具或者只是简单地从命令行调用这个端点。如果你想从命令行进入，这里是<code class="fe mu mv mw mx b">curl</code>命令。</li></ul><pre class="kj kk kl km gt ol mx om on aw oo bi"><span id="0c5c" class="nz lg it mx b gy op oq l or os">curl -X POST \<br/>  <a class="ae mt" href="http://localhost:8080/api/current-weather" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/current-weather</a> \<br/>  -H 'Content-Type: application/json' \<br/>  -d '{"cityId": "6619279"}'</span><span id="8bb1" class="nz lg it mx b gy ot oq l or os"># The cityId in this example is for Sydney, Australia, for other cities, please go to openweathermap.org</span></pre><p id="1cc2" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">你应该会得到这样的回应。</p><pre class="kj kk kl km gt ol mx om on aw oo bi"><span id="fe51" class="nz lg it mx b gy op oq l or os">STATUS - 200 OK</span><span id="551d" class="nz lg it mx b gy ot oq l or os">Response body<br/>{<br/>  "main": {<br/>    "temp": 284.35,<br/>    "pressure": 1019,<br/>    "humidity": 62,<br/>    "temp_min": 282,<br/>    "temp_max": 287<br/>  }<br/>}</span></pre><p id="a1fd" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">瞧啊。您已经完成了API路由及其处理函数的设置。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="fbca" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">编写单元测试</h1><p id="913e" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">在教程的这一部分，我们将添加单元测试依赖，并为我们的应用程序编写测试用例。</p><h2 id="5252" class="nz lg it bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv ok bi translated">将WireMock添加到项目依赖项中</h2><p id="447e" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">首先，我们需要将WireMock包包含在我们的项目依赖项中，以便Gradle可以下载并将其导入到我们的项目中。</p><p id="538a" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">在您的<code class="fe mu mv mw mx b">build.gradle.kts</code>中，将下面的包<code class="fe mu mv mw mx b">com.github.tomakehurst:wiremock-jre8:2.25.1</code>添加到<code class="fe mu mv mw mx b">dependencies</code>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="6772" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">概括一下，你的<code class="fe mu mv mw mx b">build.gradle.kts</code>现在应该是这样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有WireMock包的build.gradle.kts</p></figure><p id="1459" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">完成后，点击编辑器中的Gradle工具，并点击<em class="nu">重新导入所有Gradle项目</em>以确保WireMock包被添加到项目中，这样我们就可以开始在我们的测试类中使用它了。</p><h2 id="e5d1" class="nz lg it bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv ok bi translated">准备来自开放天气API的模拟响应</h2><p id="be88" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">为了模拟实际的开放天气API，我们需要知道响应是什么样子的。因此，让我们通过Postman发出请求并保存响应。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/39ee0f9d3281fea57aacdde1d93725f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2IwOlyzFYpdq1ZnP4BxC9Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">邮递员要求打开天气预报</p></figure><p id="9e39" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">来自Open Weather API的成功响应是<code class="fe mu mv mw mx b">200 OK</code>,其响应体如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">开放天气API响应主体</p></figure><p id="41ff" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">让我们把它保存在<code class="fe mu mv mw mx b">src/test/kotlin/resources</code>文件夹中的一个名为<code class="fe mu mv mw mx b">openweather-api-response.json</code>的文件中。我们稍后将使用这个文件来模拟测试用例中开放天气下的API响应。</p><h2 id="de04" class="nz lg it bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv ok bi translated">创建一个application.properties文件来指定本地开放天气端点</h2><p id="bf4a" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">因为我们将使用一个<code class="fe mu mv mw mx b">WireMock</code>服务器来模拟真实的开放天气端点，我们需要配置我们的测试应用程序来指向<code class="fe mu mv mw mx b">localhost</code>而不是真实的端点。</p><p id="6207" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">为此，我们只需要在<code class="fe mu mv mw mx b">src/test/kotlin/resources</code>文件夹中创建一个<code class="fe mu mv mw mx b">application.properties</code>文件，并像这样指定本地端点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">指向本地开放天气</p></figure><h2 id="c366" class="nz lg it bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv ok bi translated">为测试类设置初始结构</h2><p id="fddb" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">让我们继续到测试类。首先，在<code class="fe mu mv mw mx b">src/test/kotlin/io/codebrews/wiremockdemo</code>文件夹中创建一个新的Kotlin文件/类，并将其命名为<code class="fe mu mv mw mx b">RouteTest.kt</code>。</p><p id="ec88" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">我们将用下面的内容来注释我们的<code class="fe mu mv mw mx b">RouteTest</code>类:</p><ul class=""><li id="f594" class="nd ne it lz b ma my md mz mg nf mk ng mo nh ms ni nj nk nl bi translated"><code class="fe mu mv mw mx b">@SpringBootTest</code>:它创建了Spring的<code class="fe mu mv mw mx b">ApplicationContext</code>，并引导我们应用程序的整个容器进行测试。</li><li id="72af" class="nd ne it lz b ma nm md nn mg no mk np mo nq ms ni nj nk nl bi translated"><code class="fe mu mv mw mx b">@RunWith(SpringRunner.class)</code>:它允许我们在<a class="ae mt" href="https://junit.org/junit5/" rel="noopener ugc nofollow" target="_blank"> JUnit </a>测试中使用Spring Boot特性。它支持加载Spring的<code class="fe mu mv mw mx b">ApplicationContext</code>和通过<code class="fe mu mv mw mx b">@Autowired</code>注释注入beans。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">RouteTest.kt —初始结构</p></figure><h2 id="f6c9" class="nz lg it bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv ok bi translated">设置WebTestClient和WireMock服务器</h2><p id="d20b" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">我们需要能够测试我们的应用程序的组件是:</p><ul class=""><li id="16c0" class="nd ne it lz b ma my md mz mg nf mk ng mo nh ms ni nj nk nl bi translated"><code class="fe mu mv mw mx b">WebTestClient</code>:它是Spring提供的一个HTTP客户端，用来测试我们的反应式HTTP端点。注意<code class="fe mu mv mw mx b">@Autowired</code>注释。这是因为我们希望Spring注入我们的<code class="fe mu mv mw mx b">WebTestClient</code>，而不是自己初始化。我们的<code class="fe mu mv mw mx b">client</code>的<code class="fe mu mv mw mx b">private lateinit var</code>访问修饰符是必需的，否则<code class="fe mu mv mw mx b">@Autowired</code>将无法工作。</li><li id="d8c8" class="nd ne it lz b ma nm md nn mg no mk np mo nq ms ni nj nk nl bi translated"><code class="fe mu mv mw mx b">WireMockRule</code>:这个组件将在任何测试用例执行之前启动我们的WireMock服务器，并在所有测试用例完成之后关闭服务器(在<code class="fe mu mv mw mx b">@ClassRule</code>上做一些谷歌搜索)。它被放在<code class="fe mu mv mw mx b">companion object</code>中，并由<code class="fe mu mv mw mx b">@JvmField</code>进行注释，因为我们希望它的行为像一个Java静态对象(作为一个类级变量)。(当然，还有另一种方法。)</li><li id="a5f7" class="nd ne it lz b ma nm md nn mg no mk np mo nq ms ni nj nk nl bi translated"><code class="fe mu mv mw mx b">fun stubResponse</code>:这是一个告诉WireMock服务器如何运行的函数，例如，它应该尝试匹配哪个URL，它是否应该返回一个响应，如果是，响应应该是什么。这个函数应该在测试用例开始的时候被调用。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">RouteTest.kt —具有Wiremock规则和存根函数</p></figure><h2 id="8777" class="nz lg it bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv ok bi translated">测试是否加载了开放天气API响应</h2><p id="f5d4" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">为此，我们将把<code class="fe mu mv mw mx b">openweather-api-response.json</code>文件内容的<code class="fe mu mv mw mx b">String</code>表示记录到控制台，并断言它的Kotlin对象不是<code class="fe mu mv mw mx b">null</code>。</p><p id="147f" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">将文件内容加载到Kotlin <code class="fe mu mv mw mx b">String</code>对象的代码行是<code class="fe mu mv mw mx b">private val openWeatherApiResponse: String? = this::class.<em class="nu">java</em>.<em class="nu">classLoader</em>.getResource(apiResponseFileName)?.<em class="nu">readText</em>()</code>。</p><p id="2dc4" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">如果您运行这个测试，您应该看到控制台中记录了<code class="fe mu mv mw mx b">openweather-api-response.json</code>的内容，并且您的测试成功执行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">加载了API响应和AutoConfigureWebTestClient注释的RouteTest.kt</p></figure><p id="c38f" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">请注意，有一个注释被添加到我们的<code class="fe mu mv mw mx b">RouteTest</code>类中，即<code class="fe mu mv mw mx b">@AutoConfigureWebTestClient</code>。这个注释为我们的测试类提供了对<code class="fe mu mv mw mx b">WebTestClient</code>对象的自动配置，这样我们就可以在以后使用它来运行我们的测试用例。</p><p id="9e08" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">我们需要注释，因为我们使用<code class="fe mu mv mw mx b">@SpringBootTest</code>来运行我们的测试。作为替代，您可以尝试使用<code class="fe mu mv mw mx b">@WebFluxTest</code>注释(本教程不涉及)。</p><p id="c0c3" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">仅供参考，如果您在没有添加<code class="fe mu mv mw mx b">@AutoConfigureWebTestClient</code>的情况下运行测试类，您将会得到以下异常:</p><pre class="kj kk kl km gt ol mx om on aw oo bi"><span id="fa7a" class="nz lg it mx b gy op oq l or os">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'io.codebrews.wiremockdemo.RouteTest': Unsatisfied dependency expressed through field 'client'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'org.springframework.test.web.reactive.server.WebTestClient' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {<a class="ae mt" href="http://twitter.com/org" rel="noopener ugc nofollow" target="_blank">@org</a>.springframework.beans.factory.annotation.Autowired(required=true)}</span></pre><h2 id="317c" class="nz lg it bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv ok bi translated">为我们的应用程序的API端点编写测试用例</h2><p id="6922" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">是时候为我们的应用程序的端点编写测试用例了。</p><p id="1c8f" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">我们将通过WireMock服务器实例模拟来自真实Open Weather端点的API响应，该实例将返回响应，就像它是真实的Open Weather端点一样。</p><p id="eb1e" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">我想强调一下Spring Boot框架的一些优点:</p><ul class=""><li id="3fb5" class="nd ne it lz b ma my md mz mg nf mk ng mo nh ms ni nj nk nl bi translated"><code class="fe mu mv mw mx b">@SpringBootTest</code>注释将启动我们的Spring Boot应用程序进行测试，这包括Spring的应用程序上下文管理，即我们的应用程序运行所需的所有组件和beans的依赖注入。</li><li id="5c4e" class="nd ne it lz b ma nm md nn mg no mk np mo nq ms ni nj nk nl bi translated"><code class="fe mu mv mw mx b">@AutoConfigureWebTestClient</code>将绑定<code class="fe mu mv mw mx b">WebTestClient</code>实例，这样它就知道要访问我们的测试Spring Boot应用程序，也就是说，它将配置应用程序端口并将其绑定到<code class="fe mu mv mw mx b">WebTestClient</code>。另外，请注意，<code class="fe mu mv mw mx b">WebTestClient</code>实例是由Spring通过<code class="fe mu mv mw mx b">@Autowired</code>设置的。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有测试用例的RouteTest.kt</p></figure><p id="0288" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">我们配置由<code class="fe mu mv mw mx b">WireMockRule</code>提供的WireMock服务器，以返回我们设置为<code class="fe mu mv mw mx b">openWeatherApiResponse</code>的JSON响应。</p><p id="2d6b" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">在通过我们的<code class="fe mu mv mw mx b">WebTestClient</code>对象发出任何HTTP请求之前做<code class="fe mu mv mw mx b">stubResponse(url, openWeatherApiResponse!!)</code>是很重要的，否则WireMock服务器不知道如何响应我们的HTTP请求。</p><p id="186d" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">然后，这是我们通过<code class="fe mu mv mw mx b">WebTestClient</code>对象向测试应用程序的端点发出HTTP请求的部分。</p><pre class="kj kk kl km gt ol mx om on aw oo bi"><span id="fbce" class="nz lg it mx b gy op oq l or os">client.post()<br/>    .uri("/api/current-weather")<br/>    .body(Mono.just(requestBody), CityId::class.<em class="nu">java</em>)<br/>    .exchange()<br/>    .expectStatus().<em class="nu">isOk<br/>    </em>.expectBody().json(responseBody)</span></pre><p id="cb52" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">注意，我们不需要在<code class="fe mu mv mw mx b">.uri(“/api/current-weather”)</code>上指定基本URL，因为Spring通过<code class="fe mu mv mw mx b">@AutoConfigureWebTestClient</code>为我们管理它。</p><p id="0e0f" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">我们的单元测试断言我们的应用程序将返回一个状态<code class="fe mu mv mw mx b">200 OK</code>，并带有一个对应于<code class="fe mu mv mw mx b">openweather-api-response.json</code>中内容的响应体。(请记住，我们的应用程序只从Open Weather API响应中提取了几个字段。)</p><p id="b008" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">最后，我们的单元测试还验证了我们的应用程序通过<code class="fe mu mv mw mx b">verify(getRequestedFor(urlEqualTo(url)))</code>发出HTTP请求的URL。</p><p id="a316" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">注意，我们也没有为此指定基本路径，原因是基本路径取自我们的<code class="fe mu mv mw mx b">application.properties</code>文件。这个验证是为了确保我们真正的<code class="fe mu mv mw mx b">WebClient</code>正在向正确的资源URL发出HTTP请求。</p><p id="118c" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">继续运行测试类。您应该看到两个测试用例都成功运行了。万岁！</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="32f2" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">最后的话</h1><p id="722d" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">如果您已经做到了这一步，您将会学到以下内容:</p><ul class=""><li id="191a" class="nd ne it lz b ma my md mz mg nf mk ng mo nh ms ni nj nk nl bi translated">设置一个具有API端点的Kotlin Spring Boot应用程序，该应用程序调用外部API。</li><li id="b8ae" class="nd ne it lz b ma nm md nn mg no mk np mo nq ms ni nj nk nl bi translated">利用Spring WebFlux提供的<code class="fe mu mv mw mx b">WebClient</code>来管理外部API调用。</li><li id="2231" class="nd ne it lz b ma nm md nn mg no mk np mo nq ms ni nj nk nl bi translated">通过WireMock编写单元测试的测试用例。</li></ul><p id="7790" class="pw-post-body-paragraph lx ly it lz b ma my ju mc md mz jx mf mg na mi mj mk nb mm mn mo nc mq mr ms im bi translated">太棒了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/a2af2bd3ace8c29020c05395a953e912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5-qp6qAIthCbssNm"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杰森·霍根在<a class="ae mt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="809d" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">参考</h1><p id="1b28" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">该项目的GitHub repo可从<a class="ae mt" href="https://github.com/billydh/wiremockdemo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>获得。</p></div></div>    
</body>
</html>