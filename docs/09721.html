<html>
<head>
<title>Create a Graph Database and API With PostgreSQL and Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用PostgreSQL和Node.js创建一个图形数据库和API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-graph-database-and-api-with-postgresql-and-node-js-d7bddcc00bbb?source=collection_archive---------0-----------------------#2021-10-03">https://betterprogramming.pub/create-a-graph-database-and-api-with-postgresql-and-node-js-d7bddcc00bbb?source=collection_archive---------0-----------------------#2021-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7ff5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用PostgreSQL中JSON和表分区的强大功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/98e835adac456ab74c518b877dbb07b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YECeOxlko9KoOJNw8RNm3A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@alinnnaaaa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Alina Grubnyak </a>在<a class="ae ky" href="https://unsplash.com/s/photos/data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="a62c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，你没看错，每当我们听到“SQL”时，我们脑海中出现的第一个概念是关系数据库、外键、表管理，我们在早期计算机科学时代学到的一切……我们可能是对的，因为<a class="ae ky" href="https://searchdatamanagement.techtarget.com/definition/SQL" rel="noopener ugc nofollow" target="_blank"> SQL是为管理关系数据库而设计的</a>，其中每个数据抽象都将由表来表示，这些表之间的关系将由外键约束来强制实施，例如一对一、一对多或多对多。</p><p id="b668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这种结构已经过时间的检验，但对于某些项目或应用程序来说，它并不是很好。假设我们正在做一个社交媒体项目。我们如何在关系范式中对其建模？</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="03e6" class="ma mb it lw b gy mc md l me mf">Person (id, name, email, ...) /* Table for a Person */</span><span id="70a4" class="ma mb it lw b gy mg md l me mf">PersonFriends (id_1, id_2) /* N-N relation for Friends */</span></pre><p id="ff1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次一个<code class="fe mh mi mj lw b">Person</code>添加一个<code class="fe mh mi mj lw b">friend</code>，这个关系就会被添加到<code class="fe mh mi mj lw b">PersonFriends</code>表中两次，因为这个关系是双向的。假设我们的数据库中有两个人，<code class="fe mh mi mj lw b">Nick</code>和<code class="fe mh mi mj lw b">Melissa</code>，他们的id分别是<code class="fe mh mi mj lw b">1</code>和<code class="fe mh mi mj lw b">2</code>，为了在他们之间创建一个关系，我们必须运行以下SQL语句:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="04d0" class="ma mb it lw b gy mc md l me mf">INSERT INTO PersonFriends VALUES ('1', '2'), ('2', '1');</span></pre><p id="60f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只对一个关系使用两行，为什么要这样做？如果我们想得到尼克的朋友，我们会:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0a45" class="ma mb it lw b gy mc md l me mf">SELECT person2_id FROM PersonFriends WHERE person1_id = 1;<br/>-- Or use '2' in the WHERE clause to find Melissa's friends</span></pre><p id="7828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用一行来表示这种关系，但是这会导致复杂和低效的查询，所以我们牺牲一些空间来节省时间；)</p><p id="108d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们给我们的例子增加一点复杂性，一个新的表:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f1cc" class="ma mb it lw b gy mc md l me mf">Group (id, name)</span></pre><p id="d2e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们可以加入的组，在这种情况下，这是多对多关系(或N-N)——一个组可以有多个人，但每个<code class="fe mh mi mj lw b">Person</code>也可以是多个组的成员。</p><p id="e9ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案是实施与<code class="fe mh mi mj lw b">PersonFriends</code>相同的策略，因此我们需要另一个表来实现它…</p><p id="59bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的模型设计来说，一切都很顺利，直到我们被要求一个新的特性；如果<code class="fe mh mi mj lw b">Person</code>是<code class="fe mh mi mj lw b">Group</code>的成员，则创建<code class="fe mh mi mj lw b">Posts</code>的功能。在这种情况下，我们将需要创建另一个关系表来列出属于一个组的文章，但也使用作者的外键，作者是一个人。</p><p id="1060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你知道这是怎么回事吗？模型的水平缩放给我们带来了很多麻烦，我们可能只想切换到NoSQL数据库，在那里这些问题可以得到解决，或者使用像Neo4j或Dgraph这样的原生图形数据库。</p><p id="2bec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们热爱SQL，我们热爱它是因为它是一个经典，而且它已经成为一个标准很多年了，它将继续保持下去，因为我们可以用SQL做一些非常酷的事情，甚至一些新的DBMS都做不到。让我们只是用不同的方式…</p><h1 id="6a35" class="mk mb it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">图论</h1><p id="7929" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">一个图通常是由点和线组成的，是的，就是这么简单，一个点被称为顶点，线是链接或边，在我们的应用程序中，我们可以认为顶点是对象，链接是它们之间的关系。</p><p id="acc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以我们的社交网络为例，创建一个简单的图形模型:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/78b57ccbcfdd737efe6ea100adcc4897.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*clXn5it9mjCH5FRMx8uxbA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">社交网络示例的图形模型</p></figure><p id="dd86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在图中，我们可以看到3种类型的对象，<code class="fe mh mi mj lw b">Person</code>、<code class="fe mh mi mj lw b">Group</code>和<code class="fe mh mi mj lw b">Post</code>。在这种情况下，这些对象的每个实例都是图中所示的顶点。</p><p id="b84d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有3个人，<code class="fe mh mi mj lw b">Nick</code>是一个群的成员，有两个朋友，而这个群有多个帖子，其中一个是<code class="fe mh mi mj lw b">Nick</code>。</p><p id="31d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来很简单，但是我们如何在数据库管理系统中实现它呢？更具体地说，使用PostgreSQL？</p><p id="0a98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从写下基础开始，图由两个主要部分组成，顶点和链接。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="7002" class="mk mb it bd ml mm no mo mp mq np ms mt jz nq ka mv kc nr kd mx kf ns kg mz na bi translated">头顶</h1><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5d87" class="ma mb it lw b gy mc md l me mf">CREATE TABLE Vertices (<br/>   id UUID NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),<br/>   fields JSONB NOT NULL,<br/>   type VARCHAR(255) NOT NULL,<br/>   <!-- -->created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),<br/>   updated_at <!-- -->TIMESTAMPTZ NOT NULL DEFAULT NOW()<br/>)</span></pre><p id="fad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">折点表字段:</p><ul class=""><li id="7c81" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated"><code class="fe mh mi mj lw b">id</code>将是UUID类型(<a class="ae ky" href="https://www.postgresql.org/docs/current/functions-uuid.html" rel="noopener ugc nofollow" target="_blank">官方文件</a>)，如果你想要自动增加，你可以使用<code class="fe mh mi mj lw b">serial</code>类型</li><li id="c0bd" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><code class="fe mh mi mj lw b">fields</code>将包含当前顶点的数据，因为我们将有多个具有不同值的对象，我们使用Postgres支持的<code class="fe mh mi mj lw b">JSONB</code>类型，漂亮。</li><li id="015b" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><code class="fe mh mi mj lw b">type </code> —此<code class="fe mh mi mj lw b">Vertex</code>的类型，如果在我们的示例中是<code class="fe mh mi mj lw b">Person</code>、<code class="fe mh mi mj lw b">Group</code>或<code class="fe mh mi mj lw b">Post</code>。</li><li id="9dca" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><code class="fe mh mi mj lw b">created_at</code>和<code class="fe mh mi mj lw b">updated_at</code>只是所有对象都会有的一些助手时间戳。</li></ul><p id="c9d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，这是我们数据库中所有节点或对象的通用结构，不要添加任何只在单一节点类型上可用的字段。</p><p id="5ba8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先不要运行查询，我们需要决定这个表的分区。原因是，数据库中的所有对象都将存在于<code class="fe mh mi mj lw b">Vertices</code>表中，所以随着时间的推移，它会变得非常大，所以我们需要通过<code class="fe mh mi mj lw b">Vertex</code>持有的对象的<code class="fe mh mi mj lw b">type</code>对表进行分区。</p><p id="e2bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是它变得有趣的地方，我们现在可能知道我们需要哪些类型，目前，我们有三个:<code class="fe mh mi mj lw b">Person</code>、<code class="fe mh mi mj lw b">Group</code>和<code class="fe mh mi mj lw b">Post</code>，但在未来，我们将添加更多类型，这不会干扰我们的结构，并且它将保证水平可伸缩性，因为我们只需要从<code class="fe mh mi mj lw b">Vertices</code>表为我们将拥有的每种类型<strong class="lb iu"> </strong>创建一个分区，让我们将它添加到我们的create table语句并修改我们的主键:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b693" class="ma mb it lw b gy mc md l me mf">CREATE TABLE Vertices (<br/>   id UUID NOT NULL DEFAULT gen_random_uuid(),<br/>   fields JSON NOT NULL,<br/>   type VARCHAR(255) NOT NULL,<br/>   <!-- -->created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),<br/>   updated_at <!-- -->TIMESTAMPTZ NOT NULL DEFAULT NOW(),<br/>   CONSTRAINT pkey_vertices PRIMARY KEY (id, type)<br/>) PARTITION BY LIST(type);</span></pre><p id="8e10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的主键需要由<code class="fe mh mi mj lw b">id</code> <strong class="lb iu"> </strong>和<code class="fe mh mi mj lw b">type</code>组成。这是因为分区表的唯一约束必须包括所有分区键列，如果我们不这样做，将会导致错误。</p><p id="c1cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行该查询，我们已经成功地创建了顶点定义，现在让我们尝试插入一些值(剧透:它不会工作)。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2d1b" class="ma mb it lw b gy mc md l me mf">INSERT INTO Vertices (type, fields)<br/>VALUES ('person', '{"name": "Nick"}');</span></pre><p id="99f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到以下有趣的错误:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fbdf" class="ma mb it lw b gy mc md l me mf">ERROR: no partition of relation "vertices" found for row<br/>DETAIL: Partition key of the failing row contains (type) = (person).</span></pre><p id="2bbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这告诉我们，我们没有为<code class="fe mh mi mj lw b">person</code>类型创建分区，因为我们已经定义了这个表由一个列表<code class="fe mh mi mj lw b">types</code>进行分区。因此，让我们创建该分区:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="cd87" class="ma mb it lw b gy mc md l me mf">CREATE TABLE Vertices_person PARTITION OF Vertices FOR VALUES IN ('person');</span></pre><p id="09e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并尝试再次运行插入查询:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4588" class="ma mb it lw b gy mc md l me mf">INSERT INTO Vertices (type, fields) VALUES ('person', '{"name": "Nick"}');</span><span id="c918" class="ma mb it lw b gy mg md l me mf">INSERT 0 1</span></pre><p id="1029" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于分区的名字，我喜欢使用惯例<code class="fe mh mi mj lw b">Vertices_&lt;type&gt;</code></p><p id="472b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以创建多级分区，如果你想分割你的<code class="fe mh mi mj lw b">Vertices_person</code>表，查看<a class="ae ky" href="https://www.enterprisedb.com/postgres-tutorials/how-use-table-partitioning-scale-postgresql" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p><p id="4909" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好，现在让我们看看扩展这个模型有多容易，让我们为<code class="fe mh mi mj lw b">Post</code>类型添加一个新分区:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0c3a" class="ma mb it lw b gy mc md l me mf">CREATE TABLE Vertices_post PARTITION OF Vertices FOR VALUES IN ('post');</span></pre><p id="5bfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们插入一个帖子</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="cb61" class="ma mb it lw b gy mc md l me mf">INSERT INTO Vertices (type, fields) VALUES ('post', '{"title": "My First Post", "content": "This is my first post"}');</span></pre><p id="e8bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过运行以下命令来检查关于<code class="fe mh mi mj lw b">Vertices</code>表的详细信息:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d509" class="ma mb it lw b gy mc md l me mf">\d+ Vertices;</span></pre><p id="eef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在底部，我们将看到有关分区的信息:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e0de" class="ma mb it lw b gy mc md l me mf">...<br/>Partition key: LIST (type)<br/>Indexes:<br/>    "pkey_vertices" PRIMARY KEY, btree (id, type)<br/>Partitions: vertices_person FOR VALUES IN ('person'),<br/>            vertices_post FOR VALUES IN ('post')</span></pre><p id="acb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们实际上可以像查询普通表一样查询这些表:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="42be" class="ma mb it lw b gy mc md l me mf">SELECT id FROM vertices_person;</span><span id="064c" class="ma mb it lw b gy mg md l me mf">                  id<br/>--------------------------------------<br/> 4630ee69-32de-4127-b354-4216f2e25f9a<br/>(1 row)</span></pre><p id="e981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者我们可以查询所有的<code class="fe mh mi mj lw b">Vertices</code>表并找到这些行属于哪个分区:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="cae2" class="ma mb it lw b gy mc md l me mf">SELECT tableoid::regclass, id FROM vertices;</span><span id="3141" class="ma mb it lw b gy mg md l me mf">    tableoid     |                  id<br/>-----------------+--------------------------------------<br/> vertices_person | 4630ee69-32de-4127-b354-4216f2e25f9a<br/> vertices_post   | ccf24086-c9a1-44b1-b3e6-42575b7bcd69<br/>(2 rows)</span></pre><p id="1258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以说我们已经完成了顶点的实现，是时候移动到链接了。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="9507" class="mk mb it bd ml mm no mo mp mq np ms mt jz nq ka mv kc nr kd mx kf ns kg mz na bi translated">链接</h1><p id="4d3e" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">让我们稍微回顾一下图论，我们知道链接是连接两个顶点的线，这个链接可以是单向的，也可以是双向的。例如，如果我们想要获得由一个<code class="fe mh mi mj lw b">Person</code>写的<code class="fe mh mi mj lw b">Posts</code>，我们将需要一个从<code class="fe mh mi mj lw b">Person</code>到他拥有的每一个<code class="fe mh mi mj lw b">Posts</code>的连接，如果我们需要获得单个帖子的作者，我们需要另一个从<code class="fe mh mi mj lw b">Post</code>到<code class="fe mh mi mj lw b">Person</code>的连接，所以这将是一个双向链接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/14322de49db2bbfacf499619e16634a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*cfGgP81ozsJULDVAzlCtnQ.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">人与岗位关系示意图</p></figure><p id="5a28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们确定一个链接的主要组成部分:</p><ul class=""><li id="a91d" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">来源或起点(id和类型)</li><li id="04e7" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">目的地点或终点(id和类型)</li><li id="f2e0" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">姓名(作者、文章)</li></ul><p id="a209" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们可以添加更多信息，如体重，这将用于机器学习相关的解决方案，但在这种情况下，我们试图保持简单。</p><p id="376c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们的<code class="fe mh mi mj lw b">Links</code>表的SQL定义:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9d1d" class="ma mb it lw b gy mc md l me mf">CREATE TABLE Links (<br/>   source UUID NOT NULL,<br/>   dest UUID NOT NULL,<br/>   name VARCHAR(255) NOT NULL,<br/>   <!-- -->CONSTRAINT pkey_link PRIMARY KEY (source, dest, name)<br/>);</span></pre><p id="6873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的主键由源、目的地和名称组成，所以我们不能拥有同一个链接多次。我们没有包括任何类型的分区，因为我们将一直通过它们的主键访问值，这将是快速的。</p><p id="c13c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试将我们的<code class="fe mh mi mj lw b">Person</code>连接到我们创建的<code class="fe mh mi mj lw b">Post</code>:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7404" class="ma mb it lw b gy mc md l me mf">INSERT INTO Links VALUES (<br/>   '4630ee69-32de-4127-b354-4216f2e25f9a', -- Source id<br/>   'ccf24086-c9a1-44b1-b3e6-42575b7bcd69', -- Destination id<br/>   'posts'                                 -- Link name<br/>);</span></pre><p id="d447" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在有了连接的第一部分，这就是我们如何从<code class="fe mh mi mj lw b">Person</code>中获得<code class="fe mh mi mj lw b">Posts</code>id:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bbad" class="ma mb it lw b gy mc md l me mf">SELECT dest FROM Link WHERE source = '4630ee69-32de-4127-b354-4216f2e25f9a' AND name = 'posts';</span><span id="495e" class="ma mb it lw b gy mg md l me mf">               dest<br/>--------------------------------------<br/> ccf24086-c9a1-44b1-b3e6-42575b7bcd69</span></pre><p id="8d97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用它作为子查询来查找我们要找的顶点:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1229" class="ma mb it lw b gy mc md l me mf">SELECT * FROM Vertices WHERE type = 'post' AND id IN<br/>(SELECT dest FROM Link WHERE source = '4630ee69-32de-4127-b354-4216f2e25f9a' AND name = 'posts');</span></pre><p id="0bf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们实际上<code class="fe mh mi mj lw b">EXPLAIN</code>这个查询看看发生了什么:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="68ff" class="ma mb it lw b gy mc md l me mf">EXPLAIN SELECT * FROM Vertices WHERE type = 'post' AND id IN<br/>(SELECT dest FROM Link WHERE source = '4630ee69-32de-4127-b354-4216f2e25f9a' AND name = 'posts');<br/><br/>Nested Loop  (cost=0.29..16.34 rows=1 width=580)<br/>   -&gt;  Index Scan using pkey_link on link  (cost=0.14..8.16 rows=1 width=16)<br/>         Index Cond: (source = '4630ee69-32de-4127-b354-4216f2e25f9a'::uuid)<br/>         Filter: ((name)::text = 'posts'::text)<br/>   -&gt;  Index Scan using vertices_post_pkey on vertices_post vertices  (cost=0.14..8.16 rows=1 width=580)<br/>         Index Cond: ((id = link.dest) AND ((type)::text = 'post'::text))</span></pre><p id="2ae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看表分区如何识别我们正在访问的类型，这是因为我们在查询中使用了<code class="fe mh mi mj lw b">WHERE type = 'post'</code>，索引也帮助我们实现了这个结果，非常好。这只是为了展示我们如何在Postgres本身中做到这一点，稍后当我们集成Node.js时，这将容易得多。</p><p id="f5cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们添加反向连接，从帖子到人，一个叫做<code class="fe mh mi mj lw b">author</code>的链接</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e297" class="ma mb it lw b gy mc md l me mf">INSERT INTO Links VALUES ('ccf24086-c9a1-44b1-b3e6-42575b7bcd69', '4630ee69-32de-4127-b354-4216f2e25f9a', 'author');</span></pre><p id="a2b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们在<code class="fe mh mi mj lw b">Person</code>和<code class="fe mh mi mj lw b">Post</code>之间有了一个双向连接。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="edd5" class="mk mb it bd ml mm no mo mp mq np ms mt jz nq ka mv kc nr kd mx kf ns kg mz na bi translated">API</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/6b6cb332f4f5e1b18e3b34352c11f2ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MAYvQkafAsbLpBeWA2wVwg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克林特·王茂林在<a class="ae ky" href="https://unsplash.com/s/photos/connection?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="27d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这些类型的应用程序，我们需要一个API，它将确保:</p><ul class=""><li id="52ec" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">读取、创建、更新和删除顶点的能力。</li><li id="b769" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">创建和删除链接。</li><li id="f840" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">验证<code class="fe mh mi mj lw b">fields</code>对某些顶点类型有效。</li><li id="031f" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">为数据操作提供端点。</li></ul><p id="2f00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在Express framework中使用Node.js，因为用它创建API非常快，而且因为我们使用JSON字段，JavaScript将对我们有很大帮助。</p><p id="65a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个新文件夹，我将其命名为<code class="fe mh mi mj lw b">graph-api</code>，然后我们将初始化一个Node.js项目并安装所需的依赖项:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ac90" class="ma mb it lw b gy mc md l me mf">mkdir graph-api<br/>cd graph-api<br/>yarn init</span><span id="c9b6" class="ma mb it lw b gy mg md l me mf">...<br/>success Saved package.json<br/>yarn add express pg</span></pre><p id="52c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这段代码添加到一个新的<code class="fe mh mi mj lw b">index.js</code>项目的根目录上:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7d7f" class="ma mb it lw b gy mc md l me mf">const express = require('express');<br/>const { Pool } = require('pg');<br/>const app = express();</span><span id="f001" class="ma mb it lw b gy mg md l me mf">// Adjust your connection depending on your configuration</span><span id="09ed" class="ma mb it lw b gy mg md l me mf">const pool = new Pool({<br/>   user: 'postgres',<br/>   host: 'localhost',<br/>   database: 'postgres',<br/>   password: 'mysecretpassword',<br/>   port: 49153<br/>});</span><span id="f4bb" class="ma mb it lw b gy mg md l me mf">app.listen('4000', async () =&gt; {<br/>   const { rows } = await pool.query('SELECT * FROM Vertices');<br/>   console.log(rows);<br/>});</span></pre><p id="fe51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行<code class="fe mh mi mj lw b">node index.js</code>时，应该会得到以下结果:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="00b4" class="ma mb it lw b gy mc md l me mf">[<br/>  {<br/>    id: '64b99562-5c03-461f-971e-915995845cab',<br/>    fields: { name: 'Nick' },<br/>    type: 'person',<br/>    created_at: 2021-09-30T21:15:34.986Z,<br/>    updated_at: 2021-09-30T21:15:34.986Z<br/>  },<br/>  {<br/>    id: 'f6bfca20-ecb2-4a05-9e67-072252307f85',<br/>    fields: { title: 'My First Post', content: 'This is my first post' },<br/>    type: 'post',<br/>    created_at: 2021-09-30T21:15:47.081Z,<br/>    updated_at: 2021-09-30T21:15:47.081Z<br/>  }<br/>]</span></pre><p id="7256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个新文件，叫它<code class="fe mh mi mj lw b">vertices.js</code>，我们将在那里定义所有与顶点相关的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="59e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们还包含了一个名为<code class="fe mh mi mj lw b">parseVertex</code>的函数，它只接受一个普通的SQL行，并返回一个带有所需属性的JSON对象。</p><p id="db5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要函数来处理顶点之间的链接:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="020b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我们的API的一些示例:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="965e" class="ma mb it lw b gy mc md l me mf">app.get('/:id', async (<em class="ol">req</em>, <em class="ol">res</em>) =&gt; {<br/>   const vertex = await vertices.getVertex(<em class="ol">req</em>.params.id)<br/>   <em class="ol">res</em>.json(vertex);<br/>})</span><span id="0e6c" class="ma mb it lw b gy mg md l me mf">app.get('/:id/:link', async (<em class="ol">req</em>, <em class="ol">res</em>) =&gt; {<br/>   const resp = await links.getLinks(<em class="ol">req</em>.params.id, <em class="ol">req</em>.params.link)<br/>   <em class="ol">res</em>.json(resp);<br/>})</span><span id="53e7" class="ma mb it lw b gy mg md l me mf">app.get('/:id/:link/:linkid', async (<em class="ol">req</em>, <em class="ol">res</em>) =&gt; {<br/>   const resp = await links.getLink(<em class="ol">req</em>.params.id, <em class="ol">req</em>.params.link, -<em class="ol">req</em>.params.linkid)<br/>   <em class="ol">res</em>.json(resp);<br/>})</span><span id="4857" class="ma mb it lw b gy mg md l me mf">...</span></pre><p id="53f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…你明白了。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="b935" class="mk mb it bd ml mm no mo mp mq np ms mt jz nq ka mv kc nr kd mx kf ns kg mz na bi translated">结论</h1><p id="6b15" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">恭喜你！你做到了！一种完全不同的使用顶点和链接来存储数据的方式，您现在有了一个可伸缩的数据库模型！嗯……差不多，你仍然需要实现双向链接，而且无论何时你删除一个<code class="fe mh mi mj lw b">Vertex</code>都需要创建一个触发器来删除链接(这样你就不会有数据泄露)，但是你已经理解了这种方法的主要目的。</p><p id="2407" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你对Postgres中的图形数据库系统有所了解，如果你有任何问题，欢迎在评论中提出，以及任何建设性的批评，也许我错过了什么，或者你知道更好的存储数据的方法…有这么多的想法，我很想听听。</p></div></div>    
</body>
</html>