<html>
<head>
<title>A PHP Pattern To Avoid Try/Catch Blocks Repetition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免Try/Catch块重复的PHP模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-php-pattern-to-avoid-try-catch-blocks-repetition-1e3fe2038dc1?source=collection_archive---------1-----------------------#2022-05-04">https://betterprogramming.pub/a-php-pattern-to-avoid-try-catch-blocks-repetition-1e3fe2038dc1?source=collection_archive---------1-----------------------#2022-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="340a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">保持简单</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/740e0b2e2735599c12ec6b14fe331b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OhjRsgW1Z8M9zqKn"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">比亚·安德拉德在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="638e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几天前，我从一个强烈推荐的YouTube频道上看到了这个<a class="ae kv" href="https://youtube.com/shorts/ITogH7lJTyE?feature=share" rel="noopener ugc nofollow" target="_blank"> YouTube短片</a>，它展示了一种非常优雅的处理JavaScript中的try/catch块嵌套和重复的方式，我想是否可以对PHP做类似的事情。</p><p id="7a3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在PHP中使用<a class="ae kv" href="https://www.php.net/manual/en/language.exceptions.php" rel="noopener ugc nofollow" target="_blank"> try/catch </a>块来使我们的程序容错，或者在一定程度上提供错误处理。使用try/catch块，我们可以优雅地处理运行时可能发生的某些错误，而不必让我们的应用程序停止。</p><p id="901b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">错误处理可能包括向最终用户提供反馈，让他们知道哪里出错了，向日志记录服务发送状态和调试数据以供以后进一步分析，通过使用一些默认配置来纠正错误，甚至不采取任何措施就忽略错误。</p><p id="40ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多PHP原生函数、第三方库和框架在执行过程中如果发生了意想不到的事情，就会抛出某些类型的错误/异常。根据错误的类型、执行上下文以及它们各自实现的错误处理策略，可能会抛出不同的特定类型的异常，并且可能需要以特定的方式处理其中的每一种异常，从而导致客户端代码看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="13cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下，这种重复的模式在许多其他函数或方法中传播，使用起来肯定会非常冗长和麻烦，并且会使代码更加复杂。</p><h1 id="4762" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">模式</h1><p id="34cd" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">通过将容易出错的代码封装在一个<a class="ae kv" href="https://sourcemaking.com/design_patterns/command" rel="noopener ugc nofollow" target="_blank">命令</a>中，我们可以轻松地将它与一个错误处理程序包装在一起，该错误处理程序将负责管理错误并处理try/catch逻辑:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="c096" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个由<a class="ae kv" href="https://sourcemaking.com/design_patterns/command" rel="noopener ugc nofollow" target="_blank">命令</a>、<a class="ae kv" href="https://sourcemaking.com/design_patterns/template_method" rel="noopener ugc nofollow" target="_blank">模板方法</a>和<a class="ae kv" href="https://sourcemaking.com/design_patterns/decorator" rel="noopener ugc nofollow" target="_blank">装饰器</a>设计模式组合而成的非常灵活的错误处理机制，不会将try/catch块分散到所有代码库中。通过提供<code class="fe mr ms mt mu b">handleError</code>方法的不同实现，可以达到不同的抽象和灵活性级别，并且可以支持不同的错误处理方法。</p><h1 id="0e4d" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">用法示例</h1><p id="50a7" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在本节中，我将提供一些使用示例，展示如何实现<em class="mv"> handleError </em>方法以适应不同的错误处理策略和场景，以及这种模式的灵活性。我希望这有助于您理解这种模式是如何工作的，并为读者提供一些见解，让他们思考更多可以应用这种模式的例子和场景。</p><h2 id="5f5c" class="mw lv iq bd lw mx my dn ma mz na dp me lf nb nc mg lj nd ne mi ln nf ng mk nh bi translated">示例1:在包装器本身中处理错误</h2><p id="bd46" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">根据错误的类型和我们的程序可能使用的错误处理方法，我们可能希望报告发生的一些特定类型的错误(例如，使用外部日志服务)，而忽略其余的错误。可以配置一个错误处理程序包装器来报告某些错误并忽略其他错误，这可能适用于这种情况，其实现类似于以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h2 id="7e20" class="mw lv iq bd lw mx my dn ma mz na dp me lf nb nc mg lj nd ne mi ln nf ng mk nh bi translated">例子#2:使用误差累加器</h2><p id="feff" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">通常，如果出现X类型的错误，执行流程和对最终用户的响应可能与出现Y类型的错误不同。例如，我们可能会认为，命令的执行结果可能会受到所发生的特定类型错误的影响。</p><p id="65d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">支持这些场景的第一种方法是让命令本身处理执行过程中出现的任何错误。第二个更复杂的方法是使用一个错误累加器，它保存程序关于错误和异常的当前状态:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="0304" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个非常简单的错误累加器版本可能是一个更复杂的版本，它除了记录发生的任何错误之外，还将日志发送到外部日志记录服务，在程序级别启用一些警告状态，或者触发一些后台健康检查过程。</p><h2 id="2dc4" class="mw lv iq bd lw mx my dn ma mz na dp me lf nb nc mg lj nd ne mi ln nf ng mk nh bi translated">示例3:错误处理程序的组成</h2><p id="ca73" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">通过将这种模式与<a class="ae kv" href="https://sourcemaking.com/design_patterns/chain_of_responsibility" rel="noopener ugc nofollow" target="_blank">责任链</a>设计模式相结合，可以实现这种模式的更复杂但高度灵活的版本，因此，允许我们定制我们的错误处理逻辑，以便不将其绑定到特定的实现。看看下面的片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="aadd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一个例子展示了一种非常灵活的方法。我提供了一个默认的实现，作为最后一个链钢，它不处理以前的钢没有处理的错误。这可以更改为抛出未处理的异常，以避免在这种不报告的逻辑背后隐藏不希望的错误。</p><p id="de64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，一个灵活的错误处理器子类也可以创建为一个<code class="fe mr ms mt mu b">ErrorHandler</code>子类，它利用两个客户端定义的PHP回调函数来评估<code class="fe mr ms mt mu b">canHandle</code>方法并执行错误处理。这将允许您通过回调定义一个定制的动态错误处理程序。</p><p id="60c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些只是我提供的一些基本例子，用来说明如何使用这种模式。从这个起点可以产生更多好的见解和奇特的设计，这可能有助于你处理try/catch块的传播。</p><p id="bcb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你可能已经注意到的，通过组合设计模式，我们得到了非常丰富、强大和灵活的解决方案，因此我鼓励你这样做，但要始终意识到不要过度设计那些可以用更简单的方法解决的事情。</p></div></div>    
</body>
</html>