<html>
<head>
<title>The Best Way to Convert a String to a Number in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中将字符串转换成数字的最佳方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-the-best-way-to-convert-a-string-to-a-number-in-javascript-67052a1706c6?source=collection_archive---------4-----------------------#2020-02-10">https://betterprogramming.pub/what-is-the-best-way-to-convert-a-string-to-a-number-in-javascript-67052a1706c6?source=collection_archive---------4-----------------------#2020-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eb4a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让辩论开始吧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/52e34d0adf3c0da4bd39714b7322010d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nZbq_ckBATX-BfBvuKfxTw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@volkanolmez?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">沃尔坎·奥尔梅斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/numbers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8d6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经知道，在JavaScript中有多种方法可以将字符串转换成整数。然而，对于开发人员来说，哪种方法是“最好的”方法还有待讨论。让我们来看看一些选项。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3b27" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">parseInt()</h1><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="b68e" class="mz md it mv b gy na nb l nc nd">parseInt(string, radix)</span></pre><p id="e9a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从<code class="fe ne nf ng mv b">parseInt()</code>开始，它有两个参数，一个字符串和一个基数。该函数返回从给定字符串解析的整数。</p><p id="5d04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果第一个参数不是字符串，使用<code class="fe ne nf ng mv b">ToString()</code>自动将其转换为字符串。无论哪种方式，任何前导空格都会被忽略。</p><p id="36f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ne nf ng mv b">parseInt()</code>方法从位置0开始，确定在那里找到的字符是否可以转换成有效的数字。如果不是，该方法返回<code class="fe ne nf ng mv b">NaN</code>并停止。这里有一个例子:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="6079" class="mz md it mv b gy na nb l nc nd">const str = “What’s funnier than 24?”,</span><span id="d173" class="mz md it mv b gy nh nb l nc nd">console.log(parseInt(str)) // NaN</span></pre><p id="3db1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出将是<code class="fe ne nf ng mv b">NaN</code>，尽管字符串包含一个数字。</p><p id="6b7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果位置0处的字符有效，则该方法继续执行相同的测试。这种情况一直持续到<code class="fe ne nf ng mv b">parseInt()</code>遇到一个无效数字，这时它会将当前字符串转换成一个数字。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="1852" class="mz md it mv b gy na nb l nc nd">console.log(parseInt(“24haha25”)) // 24</span></pre><p id="612c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将返回<code class="fe ne nf ng mv b">24</code>，因为它将在<code class="fe ne nf ng mv b">haha</code>即<code class="fe ne nf ng mv b">NaN</code>处停止解析。</p><p id="f022" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MDN建议，当使用<code class="fe ne nf ng mv b">parseInt()</code>时，您应该“总是指定一个<code class="fe ne nf ng mv b">radix</code>来避免……不可靠的行为。”</p><p id="c19c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为ECMAScript 5之前的版本，<code class="fe ne nf ng mv b">parseInt()</code>使用八进制基数(8)作为字符串以“0”开头的默认值。从ECMAScript 5开始，默认值为十进制基数(10):</p><blockquote class="ni"><p id="bdae" class="nj nk it bd nl nm nn no np nq nr lu dk translated">如果基数为<code class="fe ne nf ng mv b">undefined</code>或<code class="fe ne nf ng mv b">0</code>，则假定为<code class="fe ne nf ng mv b">10</code>，除非数字以字符对<code class="fe ne nf ng mv b">0x</code>或<code class="fe ne nf ng mv b">0X</code>开头，在这种情况下假定基数为<code class="fe ne nf ng mv b">16</code>— MDN文档</p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6c92" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">parseFloat()</h1><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="e215" class="mz md it mv b gy na nb l nc nd">parseFloat(string)</span></pre><p id="30ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ne nf ng mv b">parseFloat()</code>和<code class="fe ne nf ng mv b">parseInt()</code>很像，主要有两个区别。</p><p id="3be9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一，<code class="fe ne nf ng mv b">parseFloat()</code>与<code class="fe ne nf ng mv b">parseInt()</code>不同，它不把一个基数作为自变量。这意味着string必须以十进制(基数10)表示浮点数，而不是八进制(基数8)或十六进制(基数6)。</p><p id="c758" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二，当使用<code class="fe ne nf ng mv b">parseFloat()</code>时，小数点是一个有效字符，但只有第一次遇到时才有效。如果到达第二个小数点，该方法将在该位置停止解析。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="6ab1" class="mz md it mv b gy na nb l nc nd">console.log(parseFloat(“3.141.59”)) // 3.141</span></pre><p id="084b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，<code class="fe ne nf ng mv b">parseInt()</code>的其他行为在这里也有:</p><ul class=""><li id="a5bd" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">只返回字符串中的第一个数字。</li><li id="9aa3" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">允许并忽略前导和尾随空格。</li><li id="578c" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">如果第一个字符不是有效数字，则返回<code class="fe ne nf ng mv b">NaN</code>。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="740e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数字( )</h1><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="9b7b" class="mz md it mv b gy na nb l nc nd">Number(value)</span></pre><p id="66e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解析函数和<code class="fe ne nf ng mv b">Number()</code>在很大程度上是可以互换的。<code class="fe ne nf ng mv b">Number()</code>可以处理一个小数，但也会被抛出一个以上的小数点。前导和尾随空白仍然被接受和忽略。</p><p id="8eef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一些不同之处。顾名思义，解析方法试图在转换字符串时逐段解析字符串，<code class="fe ne nf ng mv b">Number()</code>试图一次将整个字符串参数转换成数字。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="6548" class="mz md it mv b gy na nb l nc nd"><strong class="mv iu">const</strong> str = '123abc';<br/>Number(str); <em class="og">// NaN (attempts to convert entire string, cannot)</em><br/>parseInt(s); <em class="og">// 123 (stops as soon as it hits `a`) </em></span></pre><p id="409f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ne nf ng mv b">Number()</code>是作为函数调用的JavaScript <code class="fe ne nf ng mv b">Number</code>构造函数，它执行<em class="og">类型转换。</em>它<em class="og"> </em>试图将<em class="og">的任何</em>值转换成一个数字:</p><ul class=""><li id="4ac1" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated"><code class="fe ne nf ng mv b">false</code>变成<code class="fe ne nf ng mv b">0</code>，<code class="fe ne nf ng mv b">true</code>变成<code class="fe ne nf ng mv b">1</code>。</li><li id="657b" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe ne nf ng mv b">null</code>变成<code class="fe ne nf ng mv b">0</code>，<code class="fe ne nf ng mv b">undefined</code>变成<code class="fe ne nf ng mv b">NaN</code>。</li><li id="1b00" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">空字符串<code class="fe ne nf ng mv b">''</code>变为<code class="fe ne nf ng mv b">0</code>，非数字字符串变为<code class="fe ne nf ng mv b">NaN</code>。</li><li id="5db4" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe ne nf ng mv b">Number('')</code>赐<code class="fe ne nf ng mv b">0</code>；<code class="fe ne nf ng mv b">parseInt('')</code>给出<code class="fe ne nf ng mv b">NaN</code>。</li></ul><p id="de60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是来自W3Schools<a class="ae ky" href="https://www.w3schools.com/" rel="noopener ugc nofollow" target="_blank">的<code class="fe ne nf ng mv b">Number()</code>概述:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4cb2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">一元+运算符</h1><p id="8c9c" class="pw-post-body-paragraph kz la it lb b lc oj ju le lf ok jx lh li ol lk ll lm om lo lp lq on ls lt lu im bi translated">您可能知道也可能不知道<code class="fe ne nf ng mv b">+</code>一元运算符在JavaScript中将字符串转换成数字的能力。例如:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="764d" class="mz md it mv b gy na nb l nc nd">+"123" // 123<br/>+"123.456" // 123.456<br/>+"123.456.789" // NaN<br/>+"I'm a number" // NaN</span></pre><p id="643a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">据我所知，以这种方式使用一元运算符<code class="fe ne nf ng mv b">+</code>完全模仿了<code class="fe ne nf ng mv b">Number()</code>的行为，没有任何例外。那么，为什么要使用<code class="fe ne nf ng mv b">Number()</code>？</p><p id="7f32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些人将<code class="fe ne nf ng mv b">+</code>操作符视为一种语法糖，因为它可以用来简化解析函数或<code class="fe ne nf ng mv b">Number()</code>功能。</p><p id="90d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，更少的代码并不总是等于更简洁的代码。在做出关于这种捷径的决定时，应当考虑清楚。</p><p id="a973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不是每个人都知道这种行为，这可能会给阅读您代码的人带来困惑，而<code class="fe ne nf ng mv b">parseInt()</code>是清晰简洁的。</p><p id="2b3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，一般来说，你应该使用描述它做什么的代码，而不是使用非操作副作用的代码</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1cda" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">乘以1</h1><p id="b6b6" class="pw-post-body-paragraph kz la it lb b lc oj ju le lf ok jx lh li ol lk ll lm om lo lp lq on ls lt lu im bi translated">另一种快捷方式是，如果你知道你要转换的字符串是一个数字，你可以把它乘以1来转换它:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="0c7b" class="mz md it mv b gy na nb l nc nd">"123"*1 // 123<br/>"123.456"*1 // 123.456<br/>"123.456.789"*1 // NaN<br/>"I'm a number"*1 // NaN</span></pre><p id="8791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，这个方法的行为与<code class="fe ne nf ng mv b">Number()</code>相同，我已经看到它被吹捧为最快的转换方法。然而，我以前对这种语法糖的有用性的担心在这里也适用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="52ee" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">正则表达式</h1><p id="a9c4" class="pw-post-body-paragraph kz la it lb b lc oj ju le lf ok jx lh li ol lk ll lm om lo lp lq on ls lt lu im bi translated">允许定制的一个选项是在您自己构造的函数中实现正则表达式。以下是MDN的一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="56ea" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">那么，哪种方法最好呢？</h1><p id="a510" class="pw-post-body-paragraph kz la it lb b lc oj ju le lf ok jx lh li ol lk ll lm om lo lp lq on ls lt lu im bi translated">亲爱的读者，我真诚地问你这个问题！现在我们已经讨论了一些(但不是全部)选项，我很想听听你认为哪种(或哪些)方法是最好的(以及为什么)。</p><p id="0f47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我确信你们中的许多人对性能时间的了解比我多得多，尽管操作符和函数的性能会随着浏览器中JavaScript引擎的优化而改变。</p><p id="cd7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望阅读一些有益和健康的辩论，如果没有别的，我希望这是一个很好的回顾，也许你甚至学到了一些新的东西。</p><p id="ecf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>