<html>
<head>
<title>Build the Most Common App Navigation Patterns With React Navigation 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React Navigation 5构建最常见的应用导航模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-the-most-common-app-navigation-pattern-with-react-navigation-5-41fe4ddbe61d?source=collection_archive---------4-----------------------#2021-02-15">https://betterprogramming.pub/how-to-build-the-most-common-app-navigation-pattern-with-react-navigation-5-41fe4ddbe61d?source=collection_archive---------4-----------------------#2021-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="979e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用TypeScript设置您的跨平台应用程序的流程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a85a3bf7e787791e05a27388fd9e2a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oDgXSIVxtJgJuhs-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@alvarordesign?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿尔瓦罗·雷耶斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="e232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毫无疑问，<a class="ae ky" href="https://reactnative.dev/" rel="noopener ugc nofollow" target="_blank"> React Native </a>已经成为创建移动应用的强大且广泛使用的工具。在撰写本文时，它是构建跨平台应用程序使用最多的库。</p><p id="b538" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果你看一看商店里的应用程序(至少在iOS上)，你可以看到在数千个应用程序中重复的导航模式。我说的是从登录屏幕开始，然后在标签或抽屉导航中移动到主屏幕的应用程序。在选项卡或抽屉导航内的每个屏幕上，用户通常可以使用堆栈或模态导航导航到其他屏幕。</p><p id="457f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将看到如何使用<a class="ae ky" href="https://reactnavigation.org/" rel="noopener ugc nofollow" target="_blank"> React Navigation </a>版本5的一些特性来构建这个导航模式。我们将使用TypeScript来完成它，这可能会带来一些挑战，因为还没有太多关于这个主题的文档。</p><p id="d879" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是我们的应用程序将具有的屏幕:</p><ul class=""><li id="a169" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">注册</li><li id="ccf3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">主页</li><li id="ac22" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">设置</li><li id="834e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">细节</li><li id="0ffc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">编辑</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/f9ef59a929d20cc6ba960064f438579a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4pyoxyJQp7vqNYq0U_paZg.png"/></div></div></figure><p id="616e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个例子，我们将使用标签导航，尽管它可以很容易地转换为抽屉导航。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="1cb1" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">做好准备</h1><p id="779e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">首先，使用TypeScript模板创建一个React本机应用程序:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="190b" class="nt ms it np b gy nu nv l nw nx">npx react-native init NavigationCommonPattern --template react-native-template-typescript</span></pre><p id="93eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，通过运行以下命令，将React导航所需的所有依赖项添加到项目中:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="a908" class="nt ms it np b gy nu nv l nw nx">yarn add @react-navigation/native @react-navigation/stack @react-navigation/bottom-tabs</span><span id="df9f" class="nt ms it np b gy ny nv l nw nx">yarn add react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context <a class="ae ky" href="http://twitter.com/react" rel="noopener ugc nofollow" target="_blank">@react</a>-native-community/masked-view</span></pre><p id="acf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在开发iOS应用程序，请运行以下命令来安装pod:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="54d4" class="nt ms it np b gy nu nv l nw nx">npx pod-install ios</span></pre><p id="de91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，为了能够使用React导航，转到<code class="fe nz oa ob np b">index.js</code>文件，将这一行放在最开始(甚至在React导入之前):</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="2178" class="nt ms it np b gy nu nv l nw nx">import 'react-native-gesture-handler';</span></pre><p id="4e95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在一切都准备好了，您可以开始编写应用程序的代码。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="7031" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">认证流程</h1><p id="493d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">此时的目标是拥有两个屏幕(登录和主页)，用户只有在正确登录的情况下才能导航到主页屏幕。此外，如果用户在打开应用程序时已经登录，我们将直接显示主屏幕。为此，我们将使用以下结构的StackNavigator:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/ca08d52d25bf376c8d53ff6ac0c0ead4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4g8BmOo3rfL7SIbyBudPoQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个简单的双屏幕堆栈导航器</p></figure><p id="dd3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了控制登录状态，我们将使用带有两个函数的<a class="ae ky" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React Context </a>:一个用于登录，一个用于注销。将以下代码放在名为<code class="fe nz oa ob np b">AuthContext.tsx</code>的文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="9c12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，使用以下代码为登录和主屏幕创建两个文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="0f0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们是如何使用我们创建的上下文中的函数的。</p><p id="b97b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在转到<code class="fe nz oa ob np b">App.tsx</code> <strong class="lb iu"> <em class="of"> </em> </strong>文件并删除所有内容。我们不会使用那里的任何东西。相反，请使用以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a487" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们分析一下这段代码:</p><ul class=""><li id="2142" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在第15行，我们使用第9行定义的<code class="fe nz oa ob np b">RootStackParamList</code>类型初始化StackNavigator。这意味着我们将有两个屏幕(登录和主页),现在不接收任何参数——因此是<code class="fe nz oa ob np b">undefined</code>类型。</li><li id="4a5e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在第19行，我们正在为<code class="fe nz oa ob np b">AuthContext</code>定义初始值，这是我们声明的两个函数的定义。在这些函数中，我们只是根据用户是登录还是退出来改变第17行定义的状态变量<code class="fe nz oa ob np b">isLoggedIn</code>为<code class="fe nz oa ob np b">true</code>或<code class="fe nz oa ob np b">false</code>。</li><li id="c46c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最后，我们可以在第32行看到，我们通过创建一个导航器并附加我们之前创建的两个屏幕来定义导航。此外，我们用<code class="fe nz oa ob np b">AuthContext</code>包装所有东西。这里重要的部分是在第35行和第39行之间。我们可以看到，如果<code class="fe nz oa ob np b">isLoggedIn</code>变量是<code class="fe nz oa ob np b">true</code>，我们只显示主屏幕，否则显示<code class="fe nz oa ob np b">Login</code>屏幕。</li></ul><p id="4057" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以在下图中看到，如果我们试图使用未定义的屏幕名称，TypeScript如何通过显示错误来帮助我们避免运行时错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/5d5c6e20f1eccde1fbd303de6de871a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vz18qSOSpU6JqAf1ZgnOgA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Typescript智能感知</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="1fe6" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">添加TabNavigator</h1><p id="cd88" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">现在我们将从根栈中取出主屏幕，并将它与一个名为Settings的新屏幕放在一个TabNavigator中。然后，我们将使用TabNavigator作为RootStack屏幕。这将创建以下导航结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/945d5c8c7fb136920feb076d15a0658e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ue43-F0X-wFmsJC_01WwBw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">嵌套在StackNavigator内部的TabNavigator</p></figure><p id="57cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，创建一个名为<code class="fe nz oa ob np b">Settings.tsx</code>的新文件，并粘贴以下代码来创建设置屏幕，其中只有一个简单的文本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="bde8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，使用以下代码更新<code class="fe nz oa ob np b">App.tsx</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a836" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看发生了什么变化:</p><ul class=""><li id="0ba8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在第21行，我们创建了一个名为<code class="fe nz oa ob np b">RootTabParamList</code>的新类型，它定义了选项卡将包含的屏幕列表。在第18行，我们用一个使用新类型的名为<code class="fe nz oa ob np b">RootTab</code>的新属性替换了<code class="fe nz oa ob np b">RootStackParamList</code>上的<code class="fe nz oa ob np b">Home</code>属性。</li><li id="4ddf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在第43行，我们创建了TabNavigator。在第59行，我们定义了将包含在选项卡内的屏幕(主页和设置)。</li><li id="1be9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最后，在第71行，我们用整个TabNavigator替换了主屏幕。</li></ul><p id="0b7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们现在使用整个导航器作为一个屏幕，所以选项卡内所有屏幕的标题都将具有父屏幕的名称(在本例中为<code class="fe nz oa ob np b">RootTab</code>)。为了能够使用实际的名字或我们想要的任何其他名字，我们在第26行<em class="of">上添加了函数<code class="fe nz oa ob np b">getTabHeaderTitle</code>。你可以查看<a class="ae ky" href="https://reactnavigation.org/docs/screen-options-resolution/#setting-parent-screen-options-based-on-child-navigators-state" rel="noopener ugc nofollow" target="_blank">文档</a>了解更多信息。</em></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="7a0e" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">添加更多屏幕和导航类型</h1><p id="3ab2" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在这一点上，我们已经为许多应用程序打下了良好的基础。但是我们通常希望从选项卡屏幕导航到其他屏幕(例如，从主屏幕导航到详细信息屏幕)。让我们在申请中包括这一点。此外，从详细信息屏幕，我们将导航到一个编辑屏幕，其中将有一个全屏模式。</p><p id="b34d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来的更改将导致以下导航结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/850f0460c92a1c4b9f14342eb72a796a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uW3V5I0J6CkG6EjnOLWdNw.png"/></div></div></figure><p id="e441" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和前面一样，首先为详细信息和编辑屏幕创建两个文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e43e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后更新<code class="fe nz oa ob np b">App.tsx</code>文件以包含以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="7de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看发生了什么变化:</p><ul class=""><li id="1e31" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">尽管React导航中的模态也是StackNavigators，但是模态设置是在整个堆栈中设置的。这意味着里面的所有屏幕都将作为模态导航。为了避免这种情况，我们可以将另一个StackNavigator嵌套在带有模态属性的stack navigator中，就像我们在第88行和第115行之间所做的那样。编辑屏幕将作为模式导航，包含在<code class="fe nz oa ob np b">HomeNonModalStackScreens</code>中的屏幕将正常导航。</li><li id="7fc3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在第22行和第34行之间，我们为新的栈创建了新的类型:<code class="fe nz oa ob np b">HomeStackParamList</code>、<code class="fe nz oa ob np b">HomeNonModalStackParamList</code>和<code class="fe nz oa ob np b">SettingsStackParamList</code>。我们正在为Settings屏幕创建一个新的堆栈，因为我们在选项卡中嵌套了一个堆栈，所以我们需要从选项卡中移除标题(第132行)。否则会导致双头。因此，设置屏幕没有标题。获得标题最简单的方法是将屏幕放在StackNavigator中。</li><li id="b1e5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">43号线上发生了什么？当使用<code class="fe nz oa ob np b">TransitionPresets.ModalPresentationIOS</code>属性时(以便模态在调用它的屏幕前打开)，标题采用双倍高度。这段代码是为了删除它。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/509cf6eb084d0d526daf3b5db1374b6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/0*aOUVZjRPHq5i8JR5.png"/></div></figure><p id="2a2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在文档中查看关于此<a class="ae ky" href="https://reactnavigation.org/docs/stack-navigator/#transitionpresets" rel="noopener ugc nofollow" target="_blank">的更多信息。</a></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="17f6" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结果</h1><p id="4534" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">这是我们完成代码后应用程序的外观和导航方式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/751325fd37ed04bda71aaae7c30ff76c.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/1*KqGi2ayBpDgmbI7nQW6ICg.gif"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="ceb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个GitHub项目，包含我们在本文中编写的代码，您可以将其用作模板，它包括一个更适合生产项目的文件夹结构。</p><div class="ol om gp gr on oo"><a href="https://github.com/drac94/react-native-common-navigation" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">drac 94/react-native-common-导航</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">在GitHub上创建一个帐户，为drac 94/react-native-common-navigation开发做出贡献。</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">github.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div><h1 id="fd42" class="mr ms it bd mt mu pd mw mx my pe na nb jz pf ka nd kc pg kd nf kf ph kg nh ni bi translated">结论</h1><p id="bc53" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">正如我们在编写这个导航模式的代码时所看到的，React Navigation中用来实现它的最常用的特性是嵌套导航器。在这个例子的最后，我们有三个嵌套导航器的深度，这是理想的。嵌套的导航器越多，我们的代码就变得越复杂，性能就越差。</p><p id="bc8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用嵌套导航器有一些缺点和建议，你可以在官方文档中读到。确保你仔细阅读它，了解一切是如何工作的。</p></div></div>    
</body>
</html>