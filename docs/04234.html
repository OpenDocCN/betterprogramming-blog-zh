<html>
<head>
<title>A Simple Combine Publisher, Subscriber, and Operator With Back Pressure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个简单的结合了发布者、订阅者和操作者的反压力</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/simple-combine-publisher-subscriber-and-operator-with-back-pressure-c19188049533?source=collection_archive---------9-----------------------#2020-03-31">https://betterprogramming.pub/simple-combine-publisher-subscriber-and-operator-with-back-pressure-c19188049533?source=collection_archive---------9-----------------------#2020-03-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b8c2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们学习联合收割机</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/81ae576e18e2ac60d93af696fe48d8e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kp-s2hWRXC6oAGy1MRUjfg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@realaxer" rel="noopener ugc nofollow" target="_blank">田宽</a>在<a class="ae kv" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="3f8d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">摘要</h1><p id="ee8d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">看了很多<code class="fe mk ml mm mn b">Combine</code>的教程和深度治疗——花了很长时间才得到<em class="mo"> </em>它。</p><p id="bee9" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">苹果给了我们各种组件的协议定义和一个包含许多预建组件的框架——但不幸的是还没有示例代码。</p><p id="e5ba" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">所以我开始着手一个项目，构建一个简单的、最基本的<code class="fe mk ml mm mn b">Publisher</code>、<code class="fe mk ml mm mn b">Subscriber</code>、<code class="fe mk ml mm mn b">Publisher-Subscriber</code>(我的术语，在这里我称之为<code class="fe mk ml mm mn b">Complex Publisher</code>)和<code class="fe mk ml mm mn b">Operator</code>。</p><p id="8c6c" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">我还想探索<code class="fe mk ml mm mn b">backpressure</code>是如何工作的，在我自己的代码中支持它，并寻找任何有问题的边缘情况(我确实找到了一些)。</p><p id="3a3b" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">我将首先展示一个简单的UNIX shell管道，然后使用<code class="fe mk ml mm mn b">Combine</code>重新构建它。您将看到<code class="fe mk ml mm mn b">Combine</code>的<code class="fe mk ml mm mn b">backpressure</code>是如何工作的，以及如何改编一个<code class="fe mk ml mm mn b">Complex Publisher</code>来构造一个<code class="fe mk ml mm mn b">Operator</code>。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="7200" class="kw kx iq bd ky kz nb lb lc ld nc lf lg jw nd jx li jz ne ka lk kc nf kd lm ln bi translated">介绍</h1><p id="2e15" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">几十年前我开始接触C和UNIX。2005年，我努力理解Objective C的面向对象编程。然后，去年夏天，苹果推出了利用函数式反应编程概念的<code class="fe mk ml mm mn b">SwiftUI</code>和<code class="fe mk ml mm mn b">Combine</code>。似曾相识的感觉又来了！</p><p id="112d" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">浏览Medium和其他地方，我发现了许多做复杂事情的复杂例子，但是它们太多了！我想要一些非常简单的东西，这样我就可以把我的头脑包裹在各种各样的概念中。没有找到任何东西，我决定自己创造一些。</p><p id="2303" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">还有另一个<code class="fe mk ml mm mn b">Combine</code>组件——<code class="fe mk ml mm mn b">Subjects</code>——您可以通过编程来控制它。他们得到了大量的报道，所以我不会提到他们。下面是普通的旧Swift代码。</p><p id="9f1a" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">在许多方面，<code class="fe mk ml mm mn b">Combine</code>网络看起来像<a class="ae kv" href="https://toroid.org/unix-pipe-implementation" rel="noopener ugc nofollow" target="_blank"> UNIX管道</a>。第一个组件(<code class="fe mk ml mm mn b">Publisher</code>)生成数据并将其发送到下游。中间组件(<code class="fe mk ml mm mn b">Operators</code>)在转发输入数据之前对其进行修改。然后，最终组件(<code class="fe mk ml mm mn b">Subscriber</code>)接收最终结果。<code class="fe mk ml mm mn b">Combine</code>支持更复杂的图形，但这是基本的。</p><p id="0aad" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">在UNIX中，这里有一个非常简单的shell管道:</p><pre class="kg kh ki kj gt ng mn nh ni aw nj bi"><span id="9a9a" class="nk kx iq mn b gy nl nm l nn no">echo "Hello World" | tr "[:lower:]" "[:upper:]" | awk -v FS="" '{<br/>    for (i=1;i&lt;=NF;i++) {<br/>        if(i == 1) {<br/>            printf "Chars: " $i<br/>        }  else {<br/>            printf " "$i<br/>        }<br/>    }<br/>}'</span></pre><p id="3e83" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated"><code class="fe mk ml mm mn b">Echo</code>是<code class="fe mk ml mm mn b">Publisher</code> <em class="mo"> </em>(字符串的)<code class="fe mk ml mm mn b">tr</code>是<code class="fe mk ml mm mn b">Operator</code>(将小写转换成大写)<code class="fe mk ml mm mn b">awk</code>是<code class="fe mk ml mm mn b">Subscriber</code>(打印每个字符，用空格隔开)<em class="mo">。</em></p><p id="0dd8" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">输入:<code class="fe mk ml mm mn b">Hello World</code></p><p id="5c00" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">输出:<code class="fe mk ml mm mn b">Chars: H E L L O W O R L D</code></p><p id="c048" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">我们将使用<code class="fe mk ml mm mn b">Combine</code>元素来复制它。两者都支持<code class="fe mk ml mm mn b">backpressure</code>，这意味着<code class="fe mk ml mm mn b">Operators</code>和<code class="fe mk ml mm mn b">Subscribers</code>可以节流上游<code class="fe mk ml mm mn b">Publishers </code> <em class="mo"> — </em> UNIX <code class="fe mk ml mm mn b">pipes</code>本身提供了这一点(而不是单独的程序)。<code class="fe mk ml mm mn b">Combine</code>通过限制<code class="fe mk ml mm mn b">Publishers</code>仅输出达到<code class="fe mk ml mm mn b">Subscriber</code>指定限制的数据来协同工作。</p><p id="65c1" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">有一件事我花了很长时间才明白:虽然一个简单的<code class="fe mk ml mm mn b">Publisher</code>只产生发送给下游的数据，但是一个<code class="fe mk ml mm mn b">Complex Publisher</code>(我的术语)也提供了一个<code class="fe mk ml mm mn b">Subscriber</code>接口来连接到上游的<code class="fe mk ml mm mn b">Publisher</code>。</p><p id="e9d2" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">然后就是<code class="fe mk ml mm mn b">Operator</code>。<code class="fe mk ml mm mn b">Operator</code>是<code class="fe mk ml mm mn b">Publisher</code>扩展中的一个普通函数，它可以包装<code class="fe mk ml mm mn b"><em class="mo">Complex Publisher</em></code>(或<code class="fe mk ml mm mn b">Subscriber</code>)，从而允许它在函数链中使用。</p><p id="ee6b" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">我还没有讨论错误和取消(有很多文章涉及这些主题)——但是完整的代码(在<a class="ae kv" href="https://github.com/dhoerl/MediumCombineExamples" rel="noopener ugc nofollow" target="_blank"> Github </a>上)支持取消，如果<code class="fe mk ml mm mn b">String</code>参数为空，就会生成一个错误。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="e13e" class="kw kx iq bd ky kz nb lb lc ld nc lf lg jw nd jx li jz ne ka lk kc nf kd lm ln bi translated">简单发布者</h1><p id="ee8e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我见过的大多数例子都使用一个<code class="fe mk ml mm mn b">struct</code>来符合<code class="fe mk ml mm mn b">Publisher</code>协议，但是一个<code class="fe mk ml mm mn b">Class</code>也应该可以。我们的<code class="fe mk ml mm mn b">Publisher</code>示例将模仿<code class="fe mk ml mm mn b">echo</code><em class="mo"/>“Hello World”事情是这样开始的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="f836" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated"><code class="fe mk ml mm mn b">Publishers</code>是通用的，所以它们有关联的类型<code class="fe mk ml mm mn b">Output</code>和<code class="fe mk ml mm mn b">Failure</code>，<em class="mo"> </em>如上图所示。通过提供一个<code class="fe mk ml mm mn b">String</code>(即<code class="fe mk ml mm mn b">StringPublisher(string: “Hello World”)</code>)来创建一个<code class="fe mk ml mm mn b">StringPublisher</code>。</p><p id="631a" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">一旦创建，在<code class="fe mk ml mm mn b">Subscriber</code>通过<code class="fe mk ml mm mn b">receive</code>函数订阅它之前不会发生任何事情。注意<code class="fe mk ml mm mn b">Subscriber</code>的输入必须与<code class="fe mk ml mm mn b">Publisher</code>的输出相匹配。</p><p id="5cb8" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">我见过的所有自定义<code class="fe mk ml mm mn b"><em class="mo">Publisher</em></code>示例都使用一个类对象来创建一个自定义<code class="fe mk ml mm mn b">Subscription</code>，这就是我们在这里要做的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e2ed" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">它需要知道<code class="fe mk ml mm mn b">subscriber</code>和数据，因为它将在稍后被请求时发送该数据。它可以用任意多的参数初始化——对于这个简单的<code class="fe mk ml mm mn b">Publisher</code>,它只是将<code class="fe mk ml mm mn b">String</code>变形为一个<code class="fe mk ml mm mn b">Character</code>数组。这个对象也可以是一个<code class="fe mk ml mm mn b">NSObject</code>子类，这使得它有可能成为基于Objective C的对象的代表。</p><p id="c166" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">你可以在发布者内部编写你的类，这是一种流行的技术。</p><h2 id="9cb4" class="nk kx iq bd ky nr ns dn lc nt nu dp lg lx nv nw li mb nx ny lk mf nz oa lm ob bi translated">需求</h2><p id="970d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe mk ml mm mn b">Subscription</code>有一个<code class="fe mk ml mm mn b">receive</code>函数，下游的<code class="fe mk ml mm mn b">Subscriber</code>用它来请求数据。然而，对于一定量的数据，该函数只获得一个<code class="fe mk ml mm mn b">Demand</code>(即<code class="fe mk ml mm mn b">request</code>)。<code class="fe mk ml mm mn b">Demand</code>很有趣，因为它要么是<code class="fe mk ml mm mn b">infinite</code>要么是<code class="fe mk ml mm mn b">Int</code>—<code class="fe mk ml mm mn b">Int</code>可能意味着一个字节、一个对象或整个文件。</p><p id="666e" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">看起来每个<code class="fe mk ml mm mn b">demand</code>应该是在之前请求的数据之外减去发送的任何数据，尽管苹果的文档并没有真正说明这一点。因此，每个<code class="fe mk ml mm mn b">receive</code>的<code class="fe mk ml mm mn b">demand</code>被加到一个累计<code class="fe mk ml mm mn b">demand</code>上，并且每次<code class="fe mk ml mm mn b">Subscription</code>发送数据时，累计<code class="fe mk ml mm mn b">demand</code>被减少相同的发送量。</p><p id="c920" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">数据通过<code class="fe mk ml mm mn b">receive</code>功能发送到<code class="fe mk ml mm mn b">Subscriber</code>。该函数返回一个<code class="fe mk ml mm mn b">demand</code>，苹果称其为<em class="mo">还需要多少个元素</em>。理论上，在我看来，它应该与该时刻计算的累计值<code class="fe mk ml mm mn b">demand</code>相同。</p><p id="c51d" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated"><code class="fe mk ml mm mn b">Demand</code>有一个<code class="fe mk ml mm mn b">max</code>属性，当<code class="fe mk ml mm mn b">demand</code>为<code class="fe mk ml mm mn b">infinite</code>时为<code class="fe mk ml mm mn b">nil</code>。我见过的大部分代码都假设了这一点，并且没有限制输出。然而，<code class="fe mk ml mm mn b">Combine</code>文档强调<code class="fe mk ml mm mn b">Publishers</code>决不能发送超过请求的数据。这里所有的<em class="mo">订阅者</em>只请求一个元素，这样我们就可以探究代码的含义。</p><h2 id="bfd4" class="nk kx iq bd ky nr ns dn lc nt nu dp lg lx nv nw li mb nx ny lk mf nz oa lm ob bi translated">通过<em class="oc">发送数据，接收</em></h2><p id="cd4d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当一个<code class="fe mk ml mm mn b">Subscription</code>有一个非零<code class="fe mk ml mm mn b">demand</code>并且它有或接收数据时，它应该异步发送它，直到未完成的<code class="fe mk ml mm mn b">demand</code>。因此，现实世界中的<code class="fe mk ml mm mn b">Subscription</code>必须有某种弹性缓冲区(如果<code class="fe mk ml mm mn b">demand</code>是无限的，那就没有意义了，但是任何给定的<code class="fe mk ml mm mn b">Publisher</code>都不知道会被请求什么)，除非你认为你的数据可能会被丢弃(下面会进一步讨论)。</p><p id="9b61" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">这个架构提出了一个有趣的问题，即<code class="fe mk ml mm mn b">Subscription</code>应该何时以及如何发送数据。想象一下它有一个巨大的数据量——为100个元素获取一个<code class="fe mk ml mm mn b">request</code>,然后发送100个元素。在其<code class="fe mk ml mm mn b">receive</code>功能中，<code class="fe mk ml mm mn b">Subscriber</code>请求100个以上，等等。我个人认为，代码需要考虑到这一点，而不是在堆栈上无限递归。</p><h2 id="262b" class="nk kx iq bd ky nr ns dn lc nt nu dp lg lx nv nw li mb nx ny lk mf nz oa lm ob bi translated">简单接收</h2><p id="9e4f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在示例<code class="fe mk ml mm mn b">Publisher</code>中，直接发送<code class="fe mk ml mm mn b">Subscriber</code>消息:</p><pre class="kg kh ki kj gt ng mn nh ni aw nj bi"><span id="d3f2" class="nk kx iq mn b gy nl nm l nn no">func request(_ demand: Subscribers.Demand) {<br/> guard !isFinished else { return }<br/> guard let subscriber = subscriber else { return }<br/> guard data.count &gt; 0 else {return sendError(.inputStringWasEmpty)}</span><span id="605c" class="nk kx iq mn b gy od nm l nn no"> runningDemand += demand</span></pre><p id="cb85" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">在确保我们可以继续后，<code class="fe mk ml mm mn b">runningDemand</code>增加了<code class="fe mk ml mm mn b">demand</code>参数(显然如果原来是<code class="fe mk ml mm mn b">infinite</code>，这没有影响):</p><pre class="kg kh ki kj gt ng mn nh ni aw nj bi"><span id="75cf" class="nk kx iq mn b gy nl nm l nn no">if isProcessingRequest == true {<br/> return<br/>} else {<br/> isProcessingRequest = true<br/>}</span></pre><p id="7c11" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">如果<code class="fe mk ml mm mn b">Subscriber</code>在<code class="fe mk ml mm mn b">receive</code>消息中用另一个请求发送消息，上面的测试可以防止递归:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2b2d" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">while循环的存在是因为<code class="fe mk ml mm mn b">Subscriber</code>可以在<code class="fe mk ml mm mn b">receive</code>内部发送<code class="fe mk ml mm mn b">request</code>。既然它可能做到了这一点(并增加了<code class="fe mk ml mm mn b">runningDemand</code> <em class="mo">)，</em>我们就这样循环下去，直到供需平衡。</p><p id="d13c" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">一旦<code class="fe mk ml mm mn b">Subscription</code> <em class="mo">的</em>数据用完，则<code class="fe mk ml mm mn b">subscriber</code>被告知<code class="fe mk ml mm mn b">Subscription</code>已经完成。下面是完整的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="a3e0" class="nk kx iq bd ky nr ns dn lc nt nu dp lg lx nv nw li mb nx ny lk mf nz oa lm ob bi translated">试验</h2><p id="333f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们可以使用一个内置的<code class="fe mk ml mm mn b">sink Subscriber</code>来测试我们的<code class="fe mk ml mm mn b">Publisher</code>，它需要无限个元素:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="992c" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">输出:<code class="fe mk ml mm mn b">Char: H e l l o W o r l d FINISHED</code></p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="0639" class="kw kx iq bd ky kz nb lb lc ld nc lf lg jw nd jx li jz ne ka lk kc nf kd lm ln bi translated">订户</h1><p id="c7ca" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这个简单的<code class="fe mk ml mm mn b">Subscriber</code>将请求一个单字符，然后，在每个<code class="fe mk ml mm mn b"><em class="mo">receive request</em></code>、<em class="mo">、</em>内多一个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="e28c" class="nk kx iq bd ky nr ns dn lc nt nu dp lg lx nv nw li mb nx ny lk mf nz oa lm ob bi translated">试验</h2><p id="0b6a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们现在可以连接<code class="fe mk ml mm mn b">Publisher</code>和<code class="fe mk ml mm mn b">Subscriber</code>:</p><pre class="kg kh ki kj gt ng mn nh ni aw nj bi"><span id="cc51" class="nk kx iq mn b gy nl nm l nn no">let publisher = StringPublisher(string: "Hello World")<br/>let subcriber = StringSubscriber()<br/>publisher.subscribe(subcriber)</span></pre><p id="93a4" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">输出:<code class="fe mk ml mm mn b">Char: H e l l o W o r l d Subscriber completion finished</code></p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="465a" class="kw kx iq bd ky kz nb lb lc ld nc lf lg jw nd jx li jz ne ka lk kc nf kd lm ln bi translated">复杂发布者(即订阅者-发布者)</h1><p id="f3f6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们现在要创建一个同时满足<code class="fe mk ml mm mn b">Publisher</code>和<code class="fe mk ml mm mn b">Subscriber</code>协议的组件。这就有点棘手了。</p><p id="5989" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">这段代码归功于<a class="ae kv" href="https://www.cocoawithlove.com/about/" rel="noopener ugc nofollow" target="_blank">马特·加拉格尔</a>，因为我遵循了他出色的<code class="fe mk ml mm mn b"><a class="ae kv" href="https://www.cocoawithlove.com/blog/twenty-two-short-tests-of-combine-part-1.html" rel="noopener ugc nofollow" target="_blank">Combine</a></code>文章中列出的步骤(参见<em class="mo">自定义实现</em>)。</p><p id="026c" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">这个<code class="fe mk ml mm mn b">Publisher</code>产生的<code class="fe mk ml mm mn b">Subscription</code>也必须采用<code class="fe mk ml mm mn b">Subscriber</code> <em class="mo"> </em>协议:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b060" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">你可以看到我们需要为<code class="fe mk ml mm mn b">UpperCasePublisher</code>提供上游<code class="fe mk ml mm mn b">Publisher</code>。它维护该引用，直到收到来自下游的订阅请求。该<code class="fe mk ml mm mn b">receive</code>消息提示它创建一个<code class="fe mk ml mm mn b">subscription</code>对象，并将其传递给上游的<code class="fe mk ml mm mn b">Publisher</code>。此时，<code class="fe mk ml mm mn b">UpperCasePublisher</code>结构可以被丢弃，因为<code class="fe mk ml mm mn b">Publisher</code>只存在很短的时间，直到它们产生一个<code class="fe mk ml mm mn b">Subscription</code>。</p><p id="e62d" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated"><code class="fe mk ml mm mn b">UpperCaseSubscription</code>本质上合并了已经呈现的<code class="fe mk ml mm mn b">Subscription</code>和<code class="fe mk ml mm mn b">Subscriber</code>代码。它需要适应需求超过供应的情况，反之亦然，所以它有点复杂:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7907" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">您可以看到它同时具有<code class="fe mk ml mm mn b">Subscriber</code>和<code class="fe mk ml mm mn b">Publisher</code>引用(ivars):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8eec" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">上面最大的不同是<code class="fe mk ml mm mn b">data</code>可以在上游<code class="fe mk ml mm mn b">Publisher</code>还在运行的时候清空——所以我们需要等待，直到它向我们发出它已经完成的信号。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="71ad" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">这里最大的补充是，在<code class="fe mk ml mm mn b">receive</code>中，数据现在从小写转换成大写。同样，在处理和转发接收到的数据后，它返回一个<code class="fe mk ml mm mn b">1</code>的<code class="fe mk ml mm mn b">demand</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="4de9" class="nk kx iq bd ky nr ns dn lc nt nu dp lg lx nv nw li mb nx ny lk mf nz oa lm ob bi translated">试验</h2><p id="a52b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在，我们已经具备了建立像UNIX命令行这样的链所需的所有条件:</p><pre class="kg kh ki kj gt ng mn nh ni aw nj bi"><span id="8b60" class="nk kx iq mn b gy nl nm l nn no">let p1 = StringPublisher(string: "Hello World")<br/>let p2 = UpperCasePublisher(upstream: p1.eraseToAnyPublisher())</span><span id="2e79" class="nk kx iq mn b gy od nm l nn no">let subscriber = StringSubscriber()<br/>p2.subscribe(subscriber)</span></pre><p id="4479" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">输出:<code class="fe mk ml mm mn b"> Char: H e l l o W o r l d Subscriber completion finished</code></p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="601d" class="kw kx iq bd ky kz nb lb lc ld nc lf lg jw nd jx li jz ne ka lk kc nf kd lm ln bi translated">操作员</h1><p id="41c1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我很快就理解了<code class="fe mk ml mm mn b">Publisher</code>和<code class="fe mk ml mm mn b">Subscriber</code>。我<em class="mo">有点得到了</em>一个<code class="fe mk ml mm mn b">Complex Publisher</code>一个<em class="mo">的概念。</em>但是我真的很纠结<code class="fe mk ml mm mn b">Operator</code>。</p><p id="ed10" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">你会读到一个<code class="fe mk ml mm mn b">Operator</code>是一个可以组合成一个<code class="fe mk ml mm mn b">Publisher-Subscriber</code>的函数，但是我很难将它作为一个函数应用到另一个<code class="fe mk ml mm mn b">Publisher</code>中。</p><p id="d1b1" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">最后看着别人的代码，突然<em class="mo">得到了</em>它。该功能只是一种利用实际<code class="fe mk ml mm mn b">Complex Publisher</code>的机制。根据定义，该函数是对<code class="fe mk ml mm mn b">Publisher</code>的扩展，因此它可以应用于任何发布者(给定<em class="mo">关联类型</em>约束)。</p><p id="04fa" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">所以让我们为上面的<code class="fe mk ml mm mn b">UpperCasePublish</code> <em class="mo"> er </em>创建一个<code class="fe mk ml mm mn b">Operator</code>:</p><pre class="kg kh ki kj gt ng mn nh ni aw nj bi"><span id="b6f7" class="nk kx iq mn b gy nl nm l nn no">extension Publisher where Output == [Character], Failure == Error {<br/> func toUpper() -&gt; AnyPublisher&lt;Output, Failure&gt; {<br/>  let p2 = UpperCasePublisher(upstream: self.eraseToAnyPublisher())<br/>  return p2.eraseToAnyPublisher()<br/> }<br/>}</span></pre><p id="570e" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">使用中:</p><pre class="kg kh ki kj gt ng mn nh ni aw nj bi"><span id="9144" class="nk kx iq mn b gy nl nm l nn no">let p2 = StringPublisher(string: "Hello World").toUpper()<br/>let subscriber = StringSubscriber()<br/>p2.subscribe(subscriber)</span></pre><p id="7bdf" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">或者，使用<code class="fe mk ml mm mn b">sink</code>:</p><pre class="kg kh ki kj gt ng mn nh ni aw nj bi"><span id="8d88" class="nk kx iq mn b gy nl nm l nn no">var count = 0<br/>let _ = StringPublisher(string: "Hello World")<br/>.toUpper()<br/>.sink(<br/> receiveCompletion: { completion in<br/>  switch completion {<br/>  case .failure(let err):<br/>   print("\nERROR: ", err)<br/>  case .finished:<br/>   print("\nFINISHED")<br/>  }<br/> }) { (chars: [Character]) in<br/>  chars.forEach({ print(count == 0 ? "Char:" : " ", $0, terminator: ""); count += 1 })<br/> }</span></pre><p id="a734" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">这将输出与先前测试完全相同的文本</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="02bf" class="kw kx iq bd ky kz nb lb lc ld nc lf lg jw nd jx li jz ne ka lk kc nf kd lm ln bi translated">背压，重新访问</h1><p id="4784" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我发现了三个关于反压力的讨论，它们对于<code class="fe mk ml mm mn b">Publishers</code>应该如何对待两种类型的<code class="fe mk ml mm mn b">demand</code> ( <code class="fe mk ml mm mn b">receive</code>消息，从<code class="fe mk ml mm mn b">request</code>返回<code class="fe mk ml mm mn b">demand</code>)都有略微不同的看法。我对此没有什么特别的见解，除了我对苹果的少量文档的看法。</p><ul class=""><li id="8839" class="oe of iq lq b lr mp lu mq lx og mb oh mf oi mj oj ok ol om bi translated"><a class="ae kv" href="https://www.cocoawithlove.com/blog/twenty-two-short-tests-of-combine-part-3.html" rel="noopener ugc nofollow" target="_blank">供需</a>，马特·加拉格尔，来自2019年8月</li><li id="c160" class="oe of iq lq b lr on lu oo lx op mb oq mf or mj oj ok ol om bi translated"><a class="ae kv" href="https://heckj.github.io/swiftui-notes/" rel="noopener ugc nofollow" target="_blank">背压</a>，乔·赫克，2020年3月</li><li id="c1f5" class="oe of iq lq b lr on lu oo lx op mb oq mf or mj oj ok ol om bi translated"><a class="ae kv" href="https://www.apeth.com/UnderstandingCombine/publishers/publisherscustom.html" rel="noopener ugc nofollow" target="_blank">应对背压</a>，马特·纽堡，2020年3月</li><li id="3f58" class="oe of iq lq b lr on lu oo lx op mb oq mf or mj oj ok ol om bi translated"><a class="ae kv" href="https://www.donnywals.com/understanding-combines-publishers-and-subscribers/" rel="noopener ugc nofollow" target="_blank">了解联合收割机的出版商和订户</a>，唐尼·瓦尔斯</li></ul><p id="8a70" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">马特·加拉格尔说如果没有当前的<code class="fe mk ml mm mn b">demand</code>，那么<code class="fe mk ml mm mn b">Publishers</code>应该丢弃数据，作为一个来自UNIX世界的开发人员，这是我永远无法接受的(注意我的代码提供了一个弹性缓冲)。也就是说，维护一个连接上游<code class="fe mk ml mm mn b">Publisher</code>和下游<code class="fe mk ml mm mn b">Subscriber</code>的缓冲区，就像许多<code class="fe mk ml mm mn b">Operators</code>所做的那样，提出了许多关于线程同步的问题，我希望在以后的文章中探讨这些问题。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="124e" class="kw kx iq bd ky kz nb lb lc ld nc lf lg jw nd jx li jz ne ka lk kc nf kd lm ln bi translated">结论</h1><p id="af07" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我喜欢<code class="fe mk ml mm mn b">Combine</code>并且每天都在继续学习。我正在升级我的几个开源项目，这些项目目前支持<code class="fe mk ml mm mn b">Steams</code>来提供<code class="fe mk ml mm mn b">Combine</code>接口。我为本文编写的代码对我个人更好地理解<code class="fe mk ml mm mn b">Combine</code>，尤其是<code class="fe mk ml mm mn b">Complex Publisher</code>和<code class="fe mk ml mm mn b">Operator</code>概念有很大的帮助。再次感谢马特·加拉格尔！</p><p id="029b" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">自从我开始写这篇文章以来，已经出现了许多其他的文章，它们也涵盖了用<code class="fe mk ml mm mn b">back pressure</code>编写定制的<code class="fe mk ml mm mn b">Combine</code>组件。如果你想深入研究，我在下面添加了一些链接。</p><p id="0736" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">以上所有代码都可以在一个<a class="ae kv" href="https://github.com/dhoerl/MediumCombineExamples" rel="noopener ugc nofollow" target="_blank"> Github游乐场</a>找到。</p><p id="a952" class="pw-post-body-paragraph lo lp iq lq b lr mp jr lt lu mq ju lw lx mr lz ma mb ms md me mf mt mh mi mj ij bi translated">非常感谢你的阅读——我希望你能从中得到一些有用的东西！</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="4fc5" class="kw kx iq bd ky kz nb lb lc ld nc lf lg jw nd jx li jz ne ka lk kc nf kd lm ln bi translated">乐章结尾部</h1><p id="4025" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">关于使用<code class="fe mk ml mm mn b">Combine</code>和编写<code class="fe mk ml mm mn b">Combine</code>组件的文章太多了，我无法一一列举(而且列表每天都在变长！).也就是说，我想重点介绍一些之前提到过的:</p><ul class=""><li id="d8c3" class="oe of iq lq b lr mp lu mq lx og mb oh mf oi mj oj ok ol om bi translated"><a class="ae kv" href="https://www.apeth.com/UnderstandingCombine/start.html" rel="noopener ugc nofollow" target="_blank">“联合收割机简介</a>”作者Matt Neuburg。Matt已经写了非常有用的苹果文档，追溯到<em class="mo"> AppleScript </em>，以及最近覆盖每个iOS版本的大部头(刚刚出版:<a class="ae kv" href="https://www.amazon.com/Programming-iOS-13-Controllers-Frameworks/dp/1492074616" rel="noopener ugc nofollow" target="_blank">编程iOS 13:深入研究视图、视图控制器和框架</a>)。这些书中的讨论确实帮助我理解了困难和复杂的主题，我怎么推荐他的作品都不为过！</li><li id="1ae5" class="oe of iq lq b lr on lu oo lx op mb oq mf or mj oj ok ol om bi translated"><a class="ae kv" href="https://www.cocoawithlove.com/blog/twenty-two-short-tests-of-combine-part-1.html" rel="noopener ugc nofollow" target="_blank">“联合收割机的22项简短测试</a>”作者Matt Gallaher。为了更好地理解<code class="fe mk ml mm mn b">Combine</code>，Matt编写了一系列测试来探索它的内部结构。虽然这三篇文章读起来很慢，但它们提供了对<code class="fe mk ml mm mn b">Combine</code>的方法和原因的真正见解。</li><li id="6682" class="oe of iq lq b lr on lu oo lx op mb oq mf or mj oj ok ol om bi translated">乔·赫克的《联合收割机的使用》。乔的书是我第一次深入了解<code class="fe mk ml mm mn b">Combine</code>。虽然它更侧重于使用，但也有许多关于内部的见解。</li></ul></div></div>    
</body>
</html>