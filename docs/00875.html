<html>
<head>
<title>The Secret to Building Performance Libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建性能库的秘密</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/2-reasons-why-you-must-understand-delegate-prototypes-right-now-6dac719d31f4?source=collection_archive---------8-----------------------#2019-07-23">https://betterprogramming.pub/2-reasons-why-you-must-understand-delegate-prototypes-right-now-6dac719d31f4?source=collection_archive---------8-----------------------#2019-07-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="746e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你<em class="ki">需要</em>理解JavaScript中委托原型的两个关键原因</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/fac5a2cce2d2f6845177747e40992b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mArujJrl3c374Czbn_7dbg.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@firsara" rel="noopener ugc nofollow" target="_blank"> Fabian Irsara </a> @ Unsplash拍摄</p></figure><p id="59ea" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我正在读一本关于JavaScript的书，我遇到了一个问题(也是这个问题产生的概念的力量),我想写下来。我认为这对JavaScript新手特别有帮助——即使你很有经验，你也可能学到一些新东西！</p><p id="9d98" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">本文将讨论一个已知的具有委托原型的反模式。如果您是React用户，您可能对这种反模式的概念很熟悉。我们还将看看如何使用这个概念来大大提高应用程序的性能——就像今天大多数JavaScript库所做的那样。</p><p id="786b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所以，如果你想用JavaScript创建一个库，我强烈建议你学习如何通过委托原型来优化你的应用。这被称为<a class="ae kz" href="https://www.dofactory.com/javascript/flyweight-design-pattern" rel="noopener ugc nofollow" target="_blank">飞锤模式</a>，将在本文中解释。</p><p id="7889" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果你不知道什么是原型，它们是JavaScript用来建模其他对象的对象。你可以说它们类似于类，因为它们可以构造对象的多个实例，但是它们本身也是对象。</p><p id="c320" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在JavaScript中，所有对象都有一些对委托原型的内部引用。当通过属性或方法查询对象时，JavaScript首先检查当前对象。如果不存在，则继续检查对象的原型，哪个<em class="lw">是委托原型</em>，然后继续该原型的原型，依此类推。当它到达原型链的末端时，最后一站在根<code class="fe lx ly lz ma b">Object</code>原型处结束。创建对象会在根级别附加根<code class="fe lx ly lz ma b">Object</code>原型。您可以用Object.create()设置不同的直接原型来分支对象。</p><p id="aa39" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们看看下面的代码片段:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="75dd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们这里有两个工厂功能。其中一个是<code class="fe lx ly lz ma b">makeSorceress</code>，它以一个女巫<code class="fe lx ly lz ma b">type</code>作为参数，并返回一个女巫能力的对象。另一个是<code class="fe lx ly lz ma b">makeWarrior</code>，它以一个战士的<code class="fe lx ly lz ma b">type</code>作为参数，返回一个战士能力的对象。</p><p id="7624" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们实例化了一个类型为<code class="fe lx ly lz ma b">knight</code>的warrior类的新实例，以及一个类型为<code class="fe lx ly lz ma b">fire</code>的女巫。</p><p id="1ff1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然后，我们使用<code class="fe lx ly lz ma b">Object.create</code>为bob、joe和lucy创建新的对象，另外为每个对象委派原型对象。</p><p id="f038" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Bob、joe和lucy在实例中以他们的名字命名，因此我们要求并期待他们自己的属性。最后，鲍勃用<code class="fe lx ly lz ma b">bash</code>攻击露西，降低她10点生命值。</p><p id="6ebe" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">乍一看，这个例子似乎没有什么问题。但是实际上有一个问题。我们希望鲍勃和乔有他们自己的属性和方法副本，这就是为什么我们使用了<code class="fe lx ly lz ma b">Object.create</code>。当bob猛击lucy并将最后一个目标名称插入到<code class="fe lx ly lz ma b">this.lastTargets.names</code>数组中时，该数组将包含新目标的名称。</p><p id="4fdd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以注销并亲自查看:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="3ed4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这种行为是意料之中的，但是当我们<em class="lw">还记录了<code class="fe lx ly lz ma b">joe</code>的最后一个目标名字</em>时，我们会看到:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="d1c3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这说不通吧？攻击露西的人是鲍勃，从上面可以清楚地看到。但是为什么乔会参与其中呢？那一行代码显式地写了<code class="fe lx ly lz ma b">bob.bash(lucy)</code>，仅此而已。</p><p id="259a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所以问题是bob和joe实际上共享了<em class="lw">相同的状态</em>！</p><p id="d0e9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但是等等，这没有任何意义，因为当我们使用<code class="fe lx ly lz ma b">Object.create</code>的时候，我们应该已经创建了他们自己单独的副本…或者我们是这样假设的。</p><p id="e113" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">甚至MDN的<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" rel="noopener ugc nofollow" target="_blank">文档也明确说Object.create()方法创建了一个<em class="lw">新对象</em> </a>。它确实创建了一个新对象——它确实创建了——但这里的问题是，如果您在<em class="lw">原型</em>属性上改变对象或数组属性，这种改变将<em class="lw">泄漏</em>,并影响原型链上与该原型有某种链接的其他实例。相反，如果您替换原型上的整个属性<em class="lw">，那么实例上只会发生<em class="lw">的变化。</em></em></p><p id="e110" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">例如:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="2071" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您更改了<code class="fe lx ly lz ma b">this.lastTargets.names</code>属性，它将会被链接到原型的其他对象所反映。然而，当您更改原型的属性(<code class="fe lx ly lz ma b">this.lastTargets</code>)时，它将只为那个实例覆盖那个属性<em class="lw">。对于一个新的开发者来说，这可能有点难以理解。</em></p><p id="065b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们中一些经常使用React开发应用程序的人在管理整个应用程序的状态时经常会遇到这个问题。我们可能从来没有注意到这个概念是如何通过JavaScript语言本身产生的。所以，更清楚地说，这是JavaScript语言本身的问题，它是一个反模式。</p><p id="d6a3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但是为什么这甚至是一个反模式呢？不能是好事吗？</p><p id="fbb4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在某些方面，它<em class="lw">可能</em>是一件好事，因为你可以通过委托方法来优化你的应用程序，从而节省内存资源。毕竟，每个对象只需要<em class="lw">一个方法的副本</em>，并且方法可以在所有实例中共享，除非该实例需要覆盖它以获得额外的功能。</p><p id="a8dc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">例如，让我们回头看看<code class="fe lx ly lz ma b">makeWarrior</code>函数:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="fc77" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">由所有原型共享<code class="fe lx ly lz ma b">battleCry</code>函数可能是安全的，因为除了在实例化时已经设置的<code class="fe lx ly lz ma b">hp</code>属性之外，它不依赖于任何条件来正确运行。这个函数新创建的实例不一定需要自己的<code class="fe lx ly lz ma b">battleCry</code>副本，而是可以委托给最初定义这个方法的原型对象。</p><p id="ce4e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在同一个原型的实例之间共享数据是一种反模式，因为意外改变共享属性或不应该改变的数据会变得非常容易。这一直是JavaScript应用程序常见的错误来源。</p><p id="c3ad" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">事实上，这种做法的使用是有充分理由的。看看流行的<a class="ae kz" href="https://github.com/request/request" rel="noopener ugc nofollow" target="_blank">请求</a>包是如何在<a class="ae kz" href="https://github.com/request/request/blob/master/lib/har.js" rel="noopener ugc nofollow" target="_blank">这个源代码</a>中实例化<code class="fe lx ly lz ma b">Har</code>函数的:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="b52b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">那么为什么<code class="fe lx ly lz ma b">Har.prototype.reducer</code>不这样定义呢？</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="ab26" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如前所述，如果要实例化新的实例，实际上会降低应用程序的性能，因为这会(在每次实例化时重新创建新方法)，这就是<code class="fe lx ly lz ma b">reducer</code>函数。</p><p id="5641" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当我们有单独的<code class="fe lx ly lz ma b">Har</code>实例时:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="7032" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们实际上在内存中创建了<em class="lw"> 5个单独的</em> <code class="fe lx ly lz ma b"><em class="lw">this.reducer</em></code> <em class="lw">副本，因为该方法是在实例级定义的。如果reducer是直接在原型上定义的，那么<code class="fe lx ly lz ma b">Har</code>的多个实例将<em class="lw">将</em>的<code class="fe lx ly lz ma b">reducer</code>功能委托给原型上定义的方法！</em></p><p id="1178" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这是一个如何利用委托原型并提高应用程序性能的例子。</p></div></div>    
</body>
</html>