<html>
<head>
<title>Assignment vs. Shallow Copy vs. Deep Copy in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的赋值与浅拷贝和深拷贝</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/assignment-vs-shallow-copy-vs-deep-copy-in-python-246ea4d36b3c?source=collection_archive---------14-----------------------#2020-04-06">https://betterprogramming.pub/assignment-vs-shallow-copy-vs-deep-copy-in-python-246ea4d36b3c?source=collection_archive---------14-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ae70" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以正确的方式复制数据以避免错误</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/26549beb6f2c1af128946254a493fa90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pbfTfzXYLmZpUFCavZeVQQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lysanderyuen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">吕山德元</a>在<a class="ae ky" href="https://unsplash.com/s/photos/copy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们将讨论Python中的副本。我们有三种方法可以做这件事。在本文中，您将了解每个操作的作用以及它们的不同之处。</p><ol class=""><li id="2741" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">赋值运算符<code class="fe me mf mg mh b">(=)</code></li><li id="6ebf" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">浅拷贝</li><li id="4473" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">深层拷贝</li></ol></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="6338" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">赋值运算符(=)</h1><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="4500" class="nq mv it mh b gy nr ns l nt nu">&gt;&gt;&gt; a = [1, 2, 3, 4, 5]<br/>&gt;&gt;&gt; b = a</span></pre><p id="c1b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的赋值操作符的例子中，它没有复制Python对象。相反，它将一个内存地址(或指针)从<code class="fe me mf mg mh b">a</code>复制到<code class="fe me mf mg mh b">b</code>、<code class="fe me mf mg mh b">(b=a)</code>。这意味着<code class="fe me mf mg mh b">a</code>和<code class="fe me mf mg mh b">b</code>指向同一个内存地址。</p><p id="20dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们可以使用<code class="fe me mf mg mh b">id()</code>方法来获取对象在内存中的地址，并检查两个列表是否指向同一个内存。</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="76bc" class="nq mv it mh b gy nr ns l nt nu">&gt;&gt;&gt; id(a) == id(b)<br/>True</span><span id="9460" class="nq mv it mh b gy nv ns l nt nu">&gt;&gt;&gt; print('id of a - {}, id of b - {}'.format(id(a), id(b)))<br/>id of a - 140665942562048, id of b - 140665942562048</span></pre><p id="3db3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在这里，如果您要编辑新列表，它也会在原始列表中得到更新:</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="442b" class="nq mv it mh b gy nr ns l nt nu">&gt;&gt;&gt; b.append(6) </span><span id="992d" class="nq mv it mh b gy nv ns l nt nu">&gt;&gt;&gt; a<br/>[1, 2, 3, 4, 5, 6]</span><span id="6d4f" class="nq mv it mh b gy nv ns l nt nu">&gt;&gt;&gt; b<br/>[1, 2, 3, 4, 5, 6]</span></pre><p id="af29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为在存储器中只有该列表的一个实例。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="285d" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">浅拷贝</h1><p id="b218" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">浅层拷贝构造一个新的复合对象，然后(尽可能地)向其中插入对原始对象的引用。</p><p id="46fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有三种不同的方法来创建浅层拷贝:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3e78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，上述所有列表都包含与原始列表相同的值:</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="46ba" class="nq mv it mh b gy nr ns l nt nu">&gt;&gt;&gt; print(nums == m1 == m2 == m3)<br/>True</span></pre><p id="d2d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，每个的内存地址是不同的。</p><pre class="kj kk kl km gt nm mh nn no aw np bi"><span id="6a6a" class="nq mv it mh b gy nr ns l nt nu">&gt;&gt;&gt; print('nums_id - {}, m1_id - {}, m2_id - {}, m3_id = {}'.format(id(nums), id(m1), id(m2), id(m3)))</span><span id="c73a" class="nq mv it mh b gy nv ns l nt nu">nums_id - 140665942650624, m1_id - 140665942758976, m2_id - 140665942759056, m3_id = 140665942692000</span></pre><p id="9ae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着这一次，每个列表的对象都有自己独立的内存地址。</p><p id="7211" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们进入更有趣的部分。如果原始列表是复合对象(例如，列表的列表)，那么在浅层复制之后，新的列表元素仍然引用原始元素。</p><p id="55e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果您修改可变元素，比如列表，那么这些变化将会反映在原始元素上。让我们看看下面的例子，以便更好地理解:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d562" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你在上面的例子中看到的，当我们在新列表中修改内部列表元素时，它也在原始列表中被更新，因为<code class="fe me mf mg mh b">a[0]</code>和<code class="fe me mf mg mh b">b[0]</code>仍然指向相同的内存地址(原始列表)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="969a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，新的列表<code class="fe me mf mg mh b">b</code>有自己的内存地址，但是它的元素没有。这是因为，在浅层复制中，不是将列表的元素复制到新对象，而是简单地将引用复制到它们的内存地址。</p><p id="08dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当我们对原始对象进行更改时，它会反映在复制的对象中，反之亦然。</p><p id="fd1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是浅抄的一个特点。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0f12" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">深层拷贝</h1><p id="1f45" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">深度拷贝构造一个新的复合对象，然后递归地将原始对象的拷贝插入其中。</p><p id="64be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建深层副本比较慢，因为您要为所有内容创建新副本。</p><p id="e571" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，它不只是复制复合对象的地址，而是简单地复制原始列表的所有列表元素(简单和复合对象),并为新列表分配不同的内存地址，然后将复制的元素分配给它们。</p><p id="21c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现深度复制，我们必须导入<code class="fe me mf mg mh b">copy</code>模块。并使用<code class="fe me mf mg mh b">copy.deepcopy()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="8259" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，原始列表不受影响。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="67b8" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="de4e" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">浅层复制和深层复制的区别只与复合对象(包含其他对象的对象，如列表或类实例)相关。</p><p id="76c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢赋值操作符、浅拷贝和深拷贝的解释。不过，如果你对Python中的复制有任何疑问或改进，请在评论区提问。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="8dd4" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">参考</h1><ul class=""><li id="e5e3" class="lv lw it lb b lc nw lf nx li od lm oe lq of lu og mb mc md bi translated"><a class="ae ky" href="https://docs.python.org/2/library/copy.html" rel="noopener ugc nofollow" target="_blank"> Python文档</a></li></ul></div></div>    
</body>
</html>