<html>
<head>
<title>Clean Code Applied to JavaScript (Part 6: Avoid Conditional Complexity)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用于JavaScript的干净代码(第6部分:避免条件复杂性)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/clean-code-applied-to-javascript-part-6-avoid-conditional-complexity-5ee9cbb1b26a?source=collection_archive---------4-----------------------#2020-01-10">https://betterprogramming.pub/clean-code-applied-to-javascript-part-6-avoid-conditional-complexity-5ee9cbb1b26a?source=collection_archive---------4-----------------------#2020-01-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="13fa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于编写和维护干净代码的惊人好处的系列文章</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f3270d77c4ae716df6fc5096fc47ce05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3i7iQFvymrlm4qQRsqPlQQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安妮·斯普拉特在<a class="ae ky" href="https://unsplash.com/s/photos/team?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="1bc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文是深入研究干净代码主题(应用于JavaScript)的系列文章的第六篇。</p><p id="440e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本系列中，我们将讨论每个程序员都应该知道的关于干净代码的经典技巧，并将它们应用于特定的JavaScript/TypeScript语言。</p><ul class=""><li id="3b8a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/clean-code-applied-to-javascript-part-1-9f3badd5715" rel="noopener">第1部分:开始之前</a></li><li id="f38c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/clean-code-applied-to-javascript-part-ii-variables-8302f01e539c" rel="noopener">第二部分:变量</a></li><li id="cbfa" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/@ccaballero/clean-code-applied-to-javascript-part-3-functions-f9f26b221736" rel="noopener">第3部分:功能</a></li><li id="9575" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/clean-code-applied-to-javascript-part-4-3f6db21ee4e5" rel="noopener">第4部分:注释</a></li><li id="fdfc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/clean-code-applied-to-javascript-part-5-exceptions-d46e07691c19" rel="noopener">第5部分:例外情况</a></li><li id="5641" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/clean-code-applied-to-javascript-part-6-avoid-conditional-complexity-5ee9cbb1b26a" rel="noopener">第6部分:避免条件复杂性</a></li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="631e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">介绍</h1><p id="015c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">条件复杂性导致代码更难理解，因此更难维护。此外，条件复杂度通常是代码耦合的一个指标。</p><p id="45fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们想要提高代码质量的情况下，避免生成有条件复杂性的代码是明智的。</p><p id="0e75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将介绍一些可以应用于任何代码以避免条件复杂性的技术和建议。</p><p id="51b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种特定的情况下，我们将使用JavaScript/TypeScript编程语言，但我们在这篇文章中讨论的概念可以推广到任何编程语言，因为我们所做的是给出建议和技术，而不是针对特定编程语言的技巧</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="67b2" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">不要使用标志作为函数参数</h1><p id="f0c6" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">为了避免复杂性，我必须给你的第一个建议是消除作为函数参数的标志。</p><p id="d670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们必须创建两个函数来实现我们问题的逻辑，而不是使用一个函数，其中我们有两个功能的逻辑，因为它们是不同的。</p><p id="7826" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个例子展示了如何使用参数<code class="fe nn no np nq b">isPremium</code>，它将决定使用一个函数还是另一个函数。</p><p id="95a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，最正确的途径是我们用两个不同的函数用声明的方式来描述这两个功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="974d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">封装条件</h1><p id="e549" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">不要让我思考！请将条件封装在具有语义值的函数中。</p><p id="91a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一个例子中，你可以看到有一个复杂的条件是如何让任何人思考的，而在第二个例子中，当阅读函数的名称时，它是很容易理解的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3691" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">用保护子句替换嵌套的条件句</h1><p id="41ca" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这个建议在程序员的生活中至关重要。你不应该有嵌套的条件。</p><p id="fefb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">允许我们避免嵌套条件的主要技术之一是保护子句技术。想象一下，开发时完全不需要<code class="fe nn no np nq b">else</code>关键字。</p><p id="f7aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的示例显示了演示代码中的guard子句，通过一种甚至可以由IDE自动执行的技术，代码的阅读能力得到了很大的提高。</p><p id="fa1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当它有趣时，不要犹豫使用它，你只需要想到他们在编程课程中教给你的相反的逻辑。</p><p id="47e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想更深入地研究你所保留的守卫条款，我推荐你阅读我的具体文章:<a class="ae ky" href="https://medium.com/better-programming/refactoring-guard-clauses-2ceeaa1a9da" rel="noopener"> <em class="nt">守卫条款</em> </a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8c20" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">空对象模式</h1><p id="5937" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在初级程序员的代码中可以看到的另一个常见错误是不断检查对象是否为空，并根据这一点检查默认操作是否显示。这种模式被称为空对象模式。</p><p id="ecf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子展示了当动物为空或者不能发出声音时，如何检查数组中的每个对象。</p><p id="77b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，如果我们创建一个封装了空对象行为的对象，我们就不需要执行所述验证，如应用该模式的代码所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="591e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想更深入的了解这个模式，推荐你阅读我的具体文章:<a class="ae ky" href="https://medium.com/better-programming/design-patterns-null-object-5ee839e37892" rel="noopener"> <em class="nt">空对象模式</em> </a> <em class="nt">。</em></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a524" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">使用多态性删除条件</h1><p id="8713" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果(不管他们是否有不同的行为)我们应该考虑其他的事情，大多数程序员认为<code class="fe nn no np nq b">switch</code>控制结构是一个比嵌套更干净的工具。</p><p id="eb12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的代码中有一个<code class="fe nn no np nq b">switch</code>,我们一定会认为我们刚刚给代码引入了巨大的复杂性，这最终会让我们想得太多。</p><p id="eb8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子显示了这些条件的误用，根据对象的类型来定义方法的逻辑。</p><p id="adef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们可以利用基于继承的解决方案，该方案利用多态性来避免这种复杂性，因为将为这些特定类型中的每一个创建一个类。</p><p id="719a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们将有一个更具声明性的解决方案，因为我们将在每种具体对象类型中有方法的定义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8142" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">使用策略模式(组合)/命令模式删除条件</h1><p id="09c7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">允许我们在代码中避免条件复杂性的其他模式是策略和命令设计模式的应用。</p><p id="b279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于这两种模式的知识，我推荐你阅读我曾深入研究过这些模式的具体文章:<a class="ae ky" href="https://medium.com/better-programming/design-patterns-using-the-strategy-pattern-in-javascript-3c12af58fd8a" rel="noopener"> <em class="nt">策略模式</em> </a> <em class="nt">和c </em> <a class="ae ky" href="https://medium.com/better-programming/the-command-design-pattern-2313909122b5" rel="noopener"> <em class="nt"> ommand模式</em> </a>。</p><p id="2b41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在说明本节的具体示例中，您可以看到动态选择策略的策略模式。</p><p id="a683" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe nn no np nq b">switch</code>控制结构的复杂性是如何通过使用不同的策略来解决这个问题的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="60e2" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="90f9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在这篇文章中，我们提出了一些避免条件复杂性的建议。</p><p id="7c5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">条件复杂性使得代码阅读起来更加复杂。此外，这通常表明代码是耦合的，因此不太灵活。</p><p id="441c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，介绍了不同的技术和建议，通过使代码攀登一个质量台阶，允许我们避免代码中的条件复杂性。</p><p id="d27e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们讨论的要点如下:</p><ul class=""><li id="6483" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">不要使用标志作为函数参数。</li><li id="2971" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">封装条件句。</li><li id="5a72" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">用<a class="ae ky" href="https://medium.com/better-programming/refactoring-guard-clauses-2ceeaa1a9da" rel="noopener">保护子句</a>替换嵌套条件。</li><li id="99b9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">移除使用多态性的条件。</li><li id="0543" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用<a class="ae ky" href="https://medium.com/better-programming/design-patterns-null-object-5ee839e37892" rel="noopener">空对象模式</a>删除条件。</li><li id="8e52" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用<a class="ae ky" href="https://medium.com/better-programming/design-patterns-using-the-strategy-pattern-in-javascript-3c12af58fd8a" rel="noopener">策略模式</a> <a class="ae ky" href="https://carloscaballero.io/stategy-pattern-in-javascript-typescript/)(composition)" rel="noopener ugc nofollow" target="_blank">(组合)</a>移除条件句。</li><li id="011d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用<a class="ae ky" href="https://medium.com/better-programming/design-patterns-using-the-strategy-pattern-in-javascript-3c12af58fd8a" rel="noopener">命令模式</a>删除条件。</li></ul></div></div>    
</body>
</html>