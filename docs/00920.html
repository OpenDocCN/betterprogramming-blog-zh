<html>
<head>
<title>Introduction to Binary Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二叉树简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-binary-trees-deaabd5832bd?source=collection_archive---------5-----------------------#2019-07-28">https://betterprogramming.pub/introduction-to-binary-trees-deaabd5832bd?source=collection_archive---------5-----------------------#2019-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ee84" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">和C中的其他树形数据结构</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/a8adf7485595e6ec030f256b4a3bd90a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XYuh4DfcJoHTS58cCNG9dw.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@davidvig?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">大卫·维格</a>在<a class="ae kz" href="https://unsplash.com/search/photos/tree?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8570" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在计算机科学中，<em class="lw">二叉树</em>是由链接在一起的节点构成的层次数据结构<strong class="lc iu"> </strong>。第一个节点称为根节点，每个节点最多可以有两个子节点，一个左节点和一个右节点。</p><p id="7ef7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">单独来看，它们的用途似乎有限，但是当作为二分搜索法树或二进制堆实现时，它们提供了快速排序和搜索数据的方法。它们也是一个很好的学习机会，因为在C中用来实现它们的大多数函数都涉及到递归、指针交换和其他高级但有趣的编程概念。让我们看看如何用c实现它们。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="2533" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">二叉树:术语</h1><p id="bd00" class="pw-post-body-paragraph la lb it lc b ld mw ju lf lg mx jx li lj my ll lm ln mz lp lq lr na lt lu lv im bi translated">正如我们在引言中提到的，二叉树由一个根节点和子节点定义，每个节点最多有两个子节点。在继续之前，我们需要知道几个关键词。</p><ul class=""><li id="0136" class="nb nc it lc b ld le lg lh lj nd ln ne lr nf lv ng nh ni nj bi translated"><em class="lw">高度— </em>节点的高度是将该节点与叶子分开的最大边数(见叶子)。</li><li id="f589" class="nb nc it lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated"><em class="lw">深度— </em>节点的深度是将该节点与根节点分开的边的数量。</li><li id="7328" class="nb nc it lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated"><em class="lw">大小— </em>一棵树的大小是它包含的节点数。</li><li id="d265" class="nb nc it lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated"><em class="lw">平衡— </em>节点的平衡因子是其左侧子树的高度与其右侧子树的高度之差。</li><li id="2226" class="nb nc it lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated"><em class="lw">叶子— </em>叶子是一个没有任何子节点的节点，换句话说，是一个结束节点。</li></ul></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="cd80" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated"><strong class="ak">二叉树的基本操作</strong></h1><p id="35a5" class="pw-post-body-paragraph la lb it lc b ld mw ju lf lg mx jx li lj my ll lm ln mz lp lq lr na lt lu lv im bi translated">现在我们已经掌握了二叉树的术语，让我们看看如何操作它们。</p><p id="817f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于我们的例子，我们将使用这个结构定义:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7836" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">注意，我们在<code class="fe nr ns nt nu b">bt_t</code>中输入了<code class="fe nr ns nt nu b">struct binary_tree</code>。这样我们在使用这个结构时就可以使用名字<code class="fe nr ns nt nu b">bt_t</code>,而且更短。</p><p id="f9a2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">每个节点只包含一个int，一个指向当前节点父节点的指针，一个指向左边子节点的指针，和一个指向右边子节点的指针。下面是添加几个节点后二叉树的简单表示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nv"><img src="../Images/bb14b83d2a7611839c8b089fdf942884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x2Qg0Yco3PvdLt5gR_zSag.jpeg"/></div></div></figure><h2 id="db80" class="nw mf it bd mg nx ny dn mk nz oa dp mo lj ob oc mq ln od oe ms lr of og mu oh bi translated">确定树的高度</h2><p id="83a8" class="pw-post-body-paragraph la lb it lc b ld mw ju lf lg mx jx li lj my ll lm ln mz lp lq lr na lt lu lv im bi translated">下面是一个返回节点高度的简单函数:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3c5e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们来分析一下这个函数。返回类型是<code class="fe nr ns nt nu b">size_t</code>，类似于<code class="fe nr ns nt nu b">unsigned integer</code>，因为高度不能低于零。传递给它的参数是一棵<code class="fe nr ns nt nu b">bt_t</code>树的<code class="fe nr ns nt nu b">pointer</code>。</p><p id="411b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们首先声明两个变量:一个用于左子树的高度，一个用于右子树的高度。然后我们有了<code class="fe nr ns nt nu b">base case</code>，它将停止递归。如果<code class="fe nr ns nt nu b">tree</code>指向<code class="fe nr ns nt nu b">NULL</code>，则返回零。</p><p id="93c0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然后我们用<em class="lw">三元运算符</em>求出我们的两个高度(左右子树)。如果当前节点树有一个左子节点，那么<code class="fe nr ns nt nu b">height_l</code>的值等于1加上对左子节点上的函数的递归调用的返回值。如果不是，则该值被设置为零。</p><p id="8f05" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们对右边的子树重复相同的操作，并将其分配给<code class="fe nr ns nt nu b">height_r</code>。最后，用另一个三元运算符，我们确定哪个高度最大，我们返回它。</p><p id="3f94" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">递归部分可能会让大多数人迷惑，但是它背后的思想很简单。我们遍历树，直到我们到达树叶，每次增加一个高度，并将该值返回到我们的高度变量，或者在左边或者在右边。</p><p id="47ef" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了这篇文章的目的，我们不会演示我们可以在二叉树上做的每一个操作。但是，节点高度的计算是一个简单且非常有代表性的算法。</p><h2 id="955d" class="nw mf it bd mg nx ny dn mk nz oa dp mo lj ob oc mq ln od oe ms lr of og mu oh bi translated">不同类型的遍历</h2><p id="7a33" class="pw-post-body-paragraph la lb it lc b ld mw ju lf lg mx jx li lj my ll lm ln mz lp lq lr na lt lu lv im bi translated">由于二叉树不像数组或链表那样是线性的，我们可以用很多方式遍历它们(循环遍历每个节点)——前序、按序和后序。</p><p id="dd8d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但是首先，我们为什么要遍历二叉树呢？如果我们想对树的每个节点进行操作，我们需要遍历它。</p><p id="ea3b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们构建三个类似的遍历二叉树的函数。它们都有一个指向树的指针和一个指向接受int的函数的指针(就像我们的struct中的<code class="fe nr ns nt nu b">n</code>元素一样)。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ff10" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以注意到，在所有情况下，我们在<code class="fe nr ns nt nu b">tree</code>节点的<code class="fe nr ns nt nu b">n</code>元素上调用函数指针<code class="fe nr ns nt nu b">func</code>，并且我们在左右子树上递归。该函数将在递归的每个阶段执行，直到我们到达基本情况:到达树的末端(一片叶子)。</p><p id="3355" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">例如，我们的<code class="fe nr ns nt nu b">func</code>参数可以是一个指向打印整数的函数的指针。使用上面的函数，我们将看到为树的每个节点打印的<code class="fe nr ns nt nu b">n</code>元素。</p><p id="3e21" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这三种情况下，操作顺序都不同:</p><ul class=""><li id="2cce" class="nb nc it lc b ld le lg lh lj nd ln ne lr nf lv ng nh ni nj bi translated">对于<em class="lw">前序遍历</em>，我们先访问根节点，然后是左子树，再是右子树。</li><li id="54c8" class="nb nc it lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">对于<em class="lw">的有序遍历</em>，我们访问左边的子树，然后是根节点，然后是右边的子树。</li><li id="035a" class="nb nc it lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">对于<em class="lw">后序遍历</em>，我们先访问左边的子树，然后是右边的，最后是根节点。</li></ul><p id="96dd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">换句话说，pre、In、post只是根节点在遍历顺序中的位置。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="86cd" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">其他类型的树</h1><p id="4b30" class="pw-post-body-paragraph la lb it lc b ld mw ju lf lg mx jx li lj my ll lm ln mz lp lq lr na lt lu lv im bi translated">二叉树很容易理解，与其他有趣的树状结构相比，它可能不是特权数据结构。</p><h2 id="c947" class="nw mf it bd mg nx ny dn mk nz oa dp mo lj ob oc mq ln od oe ms lr of og mu oh bi translated">二分搜索法树</h2><p id="04af" class="pw-post-body-paragraph la lb it lc b ld mw ju lf lg mx jx li lj my ll lm ln mz lp lq lr na lt lu lv im bi translated">这种数据结构与二叉树相同，只是它的排序遵循以下规则:</p><ul class=""><li id="b14d" class="nb nc it lc b ld le lg lh lj nd ln ne lr nf lv ng nh ni nj bi translated">每个节点的左子节点的值必须小于节点本身的值。</li><li id="a742" class="nb nc it lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">每个节点的右子节点必须具有比节点本身更大的值。</li><li id="431c" class="nb nc it lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">每个节点的左右子树也必须遵循这些规则。</li></ul><p id="54d9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这种结构允许更快的搜索和插入/删除，因为每个值在树中都有一个唯一的位置。二叉查找树上这些操作的平均时间复杂度是O(log(n))。</p><h2 id="364c" class="nw mf it bd mg nx ny dn mk nz oa dp mo lj ob oc mq ln od oe ms lr of og mu oh bi translated">AVL树</h2><p id="5869" class="pw-post-body-paragraph la lb it lc b ld mw ju lf lg mx jx li lj my ll lm ln mz lp lq lr na lt lu lv im bi translated">这些树以发明家阿德尔森-维尔斯基和兰迪斯的名字命名，是平衡的二分搜索法树。这意味着每个节点的左右子树之差的绝对值必须是1或0。</p><p id="4a70" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">换句话说，左子树的叶子不能比右子树的叶子多一层或少一层。通过确保树的高度保持平衡，我们避免了增加树中搜索操作的时间复杂度。</p><h2 id="6936" class="nw mf it bd mg nx ny dn mk nz oa dp mo lj ob oc mq ln od oe ms lr of og mu oh bi translated">堆二叉树</h2><p id="7528" class="pw-post-body-paragraph la lb it lc b ld mw ju lf lg mx jx li lj my ll lm ln mz lp lq lr na lt lu lv im bi translated">这种数据结构类似于二分搜索法树，但是节点的顺序不同，树是完整的。一个完整的树是一个所有级别都被填充的树，除了最后一级。这使得堆树非常适合将它们存储到数组中。</p><p id="52d5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有两种有序堆:最小和最大。在最大堆中，最大值必须是根的值，并且每个节点的每个子节点的值必须小于该节点的值。这意味着值是从顶层到底层排序的。在min堆中，情况正好相反。在堆树上搜索、插入和删除的时间和复杂度平均为O(n ),这是相当快的。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="506d" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">结论</h1><p id="856f" class="pw-post-body-paragraph la lb it lc b ld mw ju lf lg mx jx li lj my ll lm ln mz lp lq lr na lt lu lv im bi translated">当我们学习如何编程时，了解二叉树是掌握数据结构的重要一步。它们可以通过多种方式实现，并具有多种有趣的属性。用C编程语言实现它们可能很有挑战性，但也很有价值，绝对值得！</p><h2 id="9434" class="nw mf it bd mg nx ny dn mk nz oa dp mo lj ob oc mq ln od oe ms lr of og mu oh bi translated">来源</h2><div class="oi oj gp gr ok ol"><a href="https://www.quora.com/What-is-the-height-size-and-depth-of-a-binary-tree" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">二叉树的高度、大小和深度是多少？</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">回答(第1题，共4题):树有三个重要的属性:高度、深度和水平，以及边缘和路径…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">www.quora.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz kt ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://www.geeksforgeeks.org/binary-search-tree-data-structure/" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">二叉查找树极客书店</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">二叉查找树是一种基于节点的二叉树数据结构，它具有以下特性:a的左子树…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz kt ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://www.tutorialspoint.com/data_structures_algorithms/tree_data_structure.htm" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">数据结构和算法树</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">数据结构和算法树-学习数据结构和算法使用C，C++和Java在简单和容易…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">www.tutorialspoint.com</p></div></div><div class="ou l"><div class="pb l ow ox oy ou oz kt ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://www.geeksforgeeks.org/avl-tree-set-1-insertion/" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">AVL树|集合1(插入)- GeeksforGeeks</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">AVL树是一种自平衡二叉查找树(BST ),其中左右子树的高度差…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="ou l"><div class="pc l ow ox oy ou oz kt ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://www.geeksforgeeks.org/binary-heap/" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">二进制堆- GeeksforGeeks</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">二进制堆是具有以下属性的二叉树。1)这是一个完整的树(所有级别都完全填满了…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="ou l"><div class="pd l ow ox oy ou oz kt ol"/></div></div></a></div></div></div>    
</body>
</html>