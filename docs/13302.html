<html>
<head>
<title>Understanding String Comparison of Databases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解数据库的字符串比较</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-string-comparison-of-databases-9bde87f2006d?source=collection_archive---------18-----------------------#2022-08-15">https://betterprogramming.pub/understanding-string-comparison-of-databases-9bde87f2006d?source=collection_archive---------18-----------------------#2022-08-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3333" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">加快字符串比较的三种方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a07dadb4308137b817632443672baffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9H0IbpQViE2eivTV.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@niko_photos" rel="noopener ugc nofollow" target="_blank"> Niko Photos </a>在<a class="ae kv" href="https://unsplash.com/photos/tGTVxeOr_Rs" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b621" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上一篇文章中，我们简要讨论了基于B树的数据库如何使用<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/partial-indexing-faq-55d6f1e10c08">部分索引</a>来提高性能。在这篇文章中，我们将谈论另一个索引的故事。</p><p id="061c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，基于B树的数据库索引有一个特点，就是最左匹配。以MySQL为例，如果<code class="fe ls lt lu lv b">WHERE</code>条件是<code class="fe ls lt lu lv b">a = 1 AND b = 2 AND c = "Hello"</code>，那么索引必须按照这个顺序建立，即<code class="fe ls lt lu lv b">(a, b, c)</code>。</p><p id="ca6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，如果索引是<code class="fe ls lt lu lv b">(a, b, c, d)</code>，那么可以基于最左匹配原则应用相同的查询。</p><p id="ac21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，如果我们要查询的条件是<code class="fe ls lt lu lv b">c</code>字段中的字符串匹配，例如<code class="fe ls lt lu lv b">WHERE a = 1 AND b = 2 AND c LIKE "Hello%"</code>，这样的条件仍然可以应用于<code class="fe ls lt lu lv b">(a, b, c)</code>索引。因为最左边的匹配规则，即使使用了<code class="fe ls lt lu lv b">LIKE</code>，字符串的最左边已经被指定了，所以仍然符合规则。</p><p id="c4ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，如果查询条件变为<code class="fe ls lt lu lv b">WHERE a = 1 AND b = 2 AND c LIKE "%World"</code>，那么只有<code class="fe ls lt lu lv b">a</code>和<code class="fe ls lt lu lv b">b</code>字段可以被索引，而<code class="fe ls lt lu lv b">c</code>字段必须比较所有匹配<code class="fe ls lt lu lv b">(a, b)</code>值的行，这将使用数据库的大量CPU计算，换句话说，非常消耗资源。</p><h1 id="da73" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">如何改善？</h1><p id="ca7e" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">改善这种情况的最简单的解决方案是去掉字符串中间和后面的百分号。然而，首先必须有这样使用它的用例，所以本文不会要求您简单地放弃它，而是提供一些替代方案。</p><h1 id="83df" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">修改最外层的客户端</h1><p id="fb55" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">修改原始字符串模式，以便颠倒索引顺序。</p><p id="b0bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，原始查询需要将字符串模式<code class="fe ls lt lu lv b">"PREFIX_ABC_SUFFIX"</code>与类似<code class="fe ls lt lu lv b">a LIKE "%ABC%"</code>的查询进行匹配。</p><p id="4149" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后反转原来的字符串模式，改成<code class="fe ls lt lu lv b">"ABC_PREFIX_SUFFIX"</code>。通过这一更改，您可以删除顶部的百分号，并将查询更改为最左侧的匹配。</p><h1 id="1300" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">修改数据库模式</h1><p id="9051" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">向原始数据库表添加一个新的布尔字段<code class="fe ls lt lu lv b">abc_matched</code>。数据库客户端在写入数据时，会预先判断原始字段是否满足条件，并设置相应的标志。</p><p id="949b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也就是说，原来的查询<code class="fe ls lt lu lv b">a LIKE "%ABC%"</code>可以改成<code class="fe ls lt lu lv b">abc_matched = 1</code>。</p><p id="a4b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这样做，数据库计算可以转移到数据库客户端，从而有效地减少数据库开销。</p><p id="d11b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种做法在数据科学中也很常见，被称为数据预处理。它用一个操作代替了后续查询的N个操作。</p><h1 id="32c7" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">修改索引类型</h1><p id="bc8b" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在MySQL中，没有办法进行这种查询。</p><p id="a605" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在Postgres和MongoDB中都有相应的索引类型，可以有效地处理模糊字符串比较。</p><p id="3dba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Postgres使用<code class="fe ls lt lu lv b">GIN</code>索引而不是默认的<code class="fe ls lt lu lv b">Bitmap</code>类型，而MongoDB使用<code class="fe ls lt lu lv b">text</code>索引而不是常规索引。</p><p id="2005" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过修改索引类型，即使是字符串的模糊比较也能以良好的性能完成。然而，所有的技术选择都有优点和缺点；GIN或text类型的索引占用大量空间，是默认类型的几倍，并且建立索引的过程非常耗时。</p><p id="2961" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，在资源有限的情况下，即使解决方案看起来非常容易实现，我也不那么推荐。</p><h1 id="4aa7" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="890c" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在软件开发中，总是有许多方法来解决现有的问题，每种方法都有优点和缺点。</p><p id="2786" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以本文中提到的三种方法为例。</p><p id="1cf3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">修改最外层客户端的成本最高，但设计新功能的成本最低。</p><p id="d3d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为客户端的修改之后是新旧版本的兼容，此外，最外层的客户端可能是一个移动应用，不仅部署困难，而且难以推广。</p><p id="4382" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果一开始设计是正确的，那么实现成本是非常低的，因为它只是原始字符串的逆序。</p><p id="228a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">修改数据库模式的成本第二高，虽然不一定需要更改最外层的客户端，但也需要更改数据库的客户端。</p><p id="73c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据库模式的修改需要旧数据的迁移，这也需要时间和人力。</p><p id="9de0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，数据的预处理提供了除提高查询性能之外的额外好处，例如更显式的特征矩阵，这可以有效地提高机器学习期间模型的准确性。</p><p id="363a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">修改索引类型的实现成本最低，只需修改一次索引，基本不需要修改应用的实现。</p><p id="6a75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这是系统的最高成本。</p><p id="fcbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，这样的索引类型占用了非常大的内存空间，在数据量很大的情况下是不能忽略的。</p><p id="07a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其次，当索引太大而不适合数据库内存大小或者必须频繁交换时，它也会影响其他查询的性能。</p><p id="9256" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，索引的复杂性会影响写操作的性能，如果这是一个高频率的写系统，那么这是一个必须仔细考虑的开销。</p><p id="9362" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，虽然有三种方法，但是对于哪一种适合还是需要权衡的，并且每个系统的答案也不尽相同。</p></div></div>    
</body>
</html>