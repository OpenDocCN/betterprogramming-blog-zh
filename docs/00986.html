<html>
<head>
<title>Creating a Simple App With React.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React.js创建简单的应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-a-simple-app-with-react-js-f6aa88998952?source=collection_archive---------1-----------------------#2019-08-04">https://betterprogramming.pub/creating-a-simple-app-with-react-js-f6aa88998952?source=collection_archive---------1-----------------------#2019-08-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="84c5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用React从头开始构建一个简单的任务跟踪应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e640a4a54eb8c2205c483f8c3c2e3517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jahP67vkFLeU5LrLZePhTQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.wix.com/blog/design/2018/07/illustration-animation-web-design/" rel="noopener ugc nofollow" target="_blank">Wix.com</a></p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="41d9" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">什么是反应？</h1><p id="b3e5" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React文档</a>将React定义为:</p><blockquote class="mu"><p id="8031" class="mv mw it bd mx my mz na nb nc nd mt dk translated"><em class="ne">“用于构建用户界面的JavaScript库”</em></p></blockquote><p id="4e80" class="pw-post-body-paragraph ly lz it ma b mb nf ju md me ng jx mg mh nh mj mk ml ni mn mo mp nj mr ms mt im bi translated">但是<em class="nk">库</em>在软件工程界是什么意思呢？我们经常听到术语<em class="nk">框架</em>用来描述其他开发者编写的解决问题和简单任务的代码。</p><p id="8419" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">具体说区别，一个框架对你的app有更多的控制权；它描绘了您的应用程序赖以生存的更广阔的图景，并规定了项目的架构。</p><p id="c106" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">另一方面，一个库通常有一个更窄的、<em class="nk">主要</em>用例，程序员可以链接他们的应用程序以获得对功能的访问。</p><p id="5601" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">React在某些事情上非常好用——比如构建漂亮的网站和相当快速地设置web应用程序——但是对于其他事情，比如构建游戏，它可能不是最好的选择。</p><p id="ca63" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">React使开发人员能够为相对复杂的应用程序构建创造性的交互式UI，这些应用程序需要在页面上呈现多个可重用的组件。</p><p id="8f82" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">相反，React在构建一个逻辑主要存在于一个组件中的游戏时增加的价值较少。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="dbe6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">声明性的、基于组件的、可重用的</h1><p id="da21" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">React有三个主要特征:</p><ul class=""><li id="5489" class="nq nr it ma b mb nl me nm mh ns ml nt mp nu mt nv nw nx ny bi translated">它使用<em class="nk">声明性的</em>视图。</li><li id="97d1" class="nq nr it ma b mb nz me oa mh ob ml oc mp od mt nv nw nx ny bi translated">它建立在管理自己状态的组件上。</li><li id="545b" class="nq nr it ma b mb nz me oa mh ob ml oc mp od mt nv nw nx ny bi translated">它的代码可以被不同的浏览器和技术重用。</li></ul><p id="91c0" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">让我们更详细地看看这意味着什么。</p><h2 id="e61f" class="oe lh it bd li of og dn lm oh oi dp lq mh oj ok ls ml ol om lu mp on oo lw op bi translated"><strong class="ak"> <em class="ne">宣示性</em> </strong></h2><p id="9b72" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">有两种类型的编程—命令式和声明式。</p><p id="1911" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated"><em class="nk">命令式</em>编程定义了实现预期结果的具体步骤(如何做事)。相比之下，<em class="nk">声明式</em>编程表达的是逻辑和数据流，没有明确列出命令或步骤(做什么)。</p><p id="6bc3" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">我们以做卷饼为例。</p><p id="0cb5" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">如果我们试图通过一种强制性的方法来做墨西哥卷饼，我们首先会得到我们的玉米粉圆饼，切蔬菜，煮肉，磨碎奶酪，将所有的配料放在玉米粉圆饼上，卷起来，然后上桌！</p><p id="2eea" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">然而，声明性方法更像Chipotle的工作方式。顾客不需要经历制作玉米煎饼的每一个步骤；你只需要指定你想要什么样的蔬菜、蛋白质和奶酪，卷饼就是从这些原料中为你做的。</p><p id="1be8" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">由于使用了声明式编程，React应用程序使代码更容易预测和调试。此外，应用程序将知道何时根据数据或输入的变化重新呈现页面。</p><h2 id="ad10" class="oe lh it bd li of og dn lm oh oi dp lq mh oj ok ls ml ol om lu mp on oo lw op bi translated"><strong class="ak"> <em class="ne">组件</em> </strong></h2><p id="bf68" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">React应用程序是由组件构成的，这些组件实质上是web页面的可重用构件。</p><p id="be74" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">为了更好地理解，我们来看看Airbnb的主页，它是基于React构建的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/4bd183144b7027798202d0c6a9657fff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7KCwc_f53HH1IzjGyaYBiA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">AirBnb主页</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/0efceb1b77eb956293ce494ce3224347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qpygBsXUnYiuFrZTcX65gA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Airbnb页面的组件结构</p></figure><p id="9743" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">上图展示了Airbnb组件的大致结构。我们在顶部有一个<em class="nk">导航条</em>组件，其中包含子组件，如<em class="nk">搜索栏</em>和<em class="nk">用户控制器栏</em>(“添加列表”、“消息”…等等)。</p><p id="23cc" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">在<em class="nk">导航栏</em>组件的正下方，您可能有一个<em class="nk">主容器</em>组件，它充当其子组件的父组件，例如<em class="nk">类别容器</em>(“我们能帮您找到什么？”section)和一个<em class="nk">广告容器</em>(“Airbnb Luxe简介”部分)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/ec0d4ad448e065a07e8f5b86477eb16f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zTR_0z3iqNmwSDeBRA51rA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Airbnb类别容器特写</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/ad56fa206a58c8aae2f8792cad6118c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qMVApJIZqt17sl91x36z9Q.png"/></div></div></figure><p id="7aaf" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">如果您看一下我们称之为<em class="nk">类别容器</em>的内部，这个组件包含多个子组件，显示各个类别(“住宿”、“体验”、“冒险”和“餐馆”)。</p><p id="582f" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">除了每张卡片上显示的信息之外，这些独立的卡片看起来几乎完全相同。这就是React中的组件变得有用的地方。</p><p id="b2ba" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">如果您编写了类别卡的单个组件，您可以重用相同的组件，但相应地提供不同的信息。</p><p id="9228" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">从概念上讲，组件有点像JavaScript函数，根据输入呈现不同的输出。在这种情况下，输出是呈现在页面上的HTML。</p><p id="3e28" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">组件的另一个重要概念是<em class="nk">状态</em>。</p><p id="0857" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">某些组件管理它们自己的状态，这些状态包含指示页面将呈现什么的信息。</p><p id="5656" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">类似于函数中声明的变量，状态只适用于它所属的组件，除非有目的地作为<em class="nk">道具</em>传递给其他子组件。</p><p id="2842" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">状态还充当我们的<em class="nk">唯一真实来源</em>，这意味着组件的信息将只保存在其状态内，而不会保存在其他地方。</p><p id="ba75" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">我们把从父组件向下传递到其子组件的信息称为<em class="nk"> prop </em>。你可以把props想象成JavaScript中的函数参数。</p><p id="b073" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">Props可以采用任何JavaScript数据类型的形式——从简单的字符串到函数。程序员决定是否传递一个道具，这取决于在子组件中需要呈现或调用什么功能。</p><p id="08b3" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">这里要记住的重要一点是，道具只能传承，不能传承。就像瀑布一样，道具可以下落，但不能克服重力向上移动。</p><h2 id="f7eb" class="oe lh it bd li of og dn lm oh oi dp lq mh oj ok ls ml ol om lu mp on oo lw op bi translated"><strong class="ak"> <em class="ne">可重用</em> </strong></h2><p id="30e1" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">因为React代码对于所有浏览器和所有技术(笔记本电脑、手机、平板电脑等)都是以相同的方式编写的。)，React应用程序可以跨多个方面和平台进行编程。</p><p id="a09a" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">例如，开发人员可以使用React Native轻松构建移动应用程序，React Native是一个使用React的移动应用程序框架。</p><p id="f3aa" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">随着浏览器和设备之间的web响应和兼容性越来越重要，React的可重用代码变得非常方便。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="faaf" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">构建简单的任务应用程序</h1><p id="7379" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">现在我们已经对React有了基本的了解，让我们来看看构建一个简单的React应用程序的步骤。出于这个练习的目的，我决定构建一个简单的任务跟踪器应用程序。</p><h2 id="95e1" class="oe lh it bd li of og dn lm oh oi dp lq mh oj ok ls ml ol om lu mp on oo lw op bi translated"><strong class="ak">第一步</strong>。<strong class="ak"> <em class="ne">在你的终端上创建React app</em></strong></h2><p id="f7ae" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在您的终端上，运行以下命令。这将在当前文件夹中创建一个新目录(<code class="fe ou ov ow ox b">my-app</code>)。</p><p id="f9b3" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">在这个新生成的目录中，该命令会自动创建一个初始项目结构，并安装可传递的依赖项。在创建的多个文件夹中，您的Javascript代码将保存在<code class="fe ou ov ow ox b">src</code>中。</p><pre class="kj kk kl km gt oy ox oz pa aw pb bi"><span id="cb99" class="oe lh it ox b gy pc pd l pe pf">npm init react-app my-app</span></pre><h2 id="c325" class="oe lh it bd li of og dn lm oh oi dp lq mh oj ok ls ml ol om lu mp on oo lw op bi translated"><strong class="ak">第二步</strong>。<strong class="ak"> <em class="ne">启动React app </em> </strong></h2><p id="6751" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">进入您新生成的目录(<code class="fe ou ov ow ox b">my-app</code>)并运行<code class="fe ou ov ow ox b">npm start</code>来启动您的应用程序。</p><p id="47dd" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">这应该会自动在您的浏览器上打开一个HTML页面，看起来像下面的页面。</p><pre class="kj kk kl km gt oy ox oz pa aw pb bi"><span id="6b0d" class="oe lh it ox b gy pc pd l pe pf">cd my-app<br/>npm start</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/11113d67637a2c25957cec3473d9261a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*egIpXw5TYcgEd9iI3Es3Zw.png"/></div></div></figure><p id="4dbb" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">我没有写任何代码，我们已经有一个功能的网站！</p><p id="6b9f" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">如果我们查看<code class="fe ou ov ow ox b">my-app</code>目录下的<code class="fe ou ov ow ox b">src</code>文件夹，你会发现一个名为<code class="fe ou ov ow ox b">App.js</code>的文件。</p><p id="e079" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">在应用程序初始化时，这个文件默认为下面显示的HTML代码，它呈现在主页上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/e111ea3bb5016a5eb5858a86070be262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I4l_Z7spPbDKmIUwcV4iwg.png"/></div></div></figure><p id="8cd9" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">按照惯例，<code class="fe ou ov ow ox b">App.js</code>充当React应用程序结构中最高级别的组件。</p><p id="fc2d" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">在同一个文件夹下，您还可以找到<code class="fe ou ov ow ox b">index.js</code>文件，该文件保存了您的应用程序的配置，并包含了诸如<a class="ae ky" href="https://github.com/ReactTraining/react-router" rel="noopener ugc nofollow" target="_blank"> React-Router </a>和<a class="ae ky" href="https://react-redux.js.org/" rel="noopener ugc nofollow" target="_blank"> React-Redux </a>之类的依赖项(更多信息请参见另一篇博文。)</p><h2 id="6cb0" class="oe lh it bd li of og dn lm oh oi dp lq mh oj ok ls ml ol om lu mp on oo lw op bi translated"><strong class="ak">第三步</strong>。<strong class="ak"> <em class="ne">设置构件结构</em> </strong></h2><p id="631a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">现在，是时候决定您的应用程序需要哪些组件了。下面，我为我的任务跟踪应用程序设计了组件结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/c2804887fc0370e74835eca4d0580ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x_w1QwStrbGuth5Id8tEzg.png"/></div></div></figure><p id="8b21" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">在React中，您将组件编写为JavaScript函数或类。</p><p id="9e1e" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated"><em class="nk">功能性</em>(也称为<em class="nk">表象性</em>)组件通常呈现简单的HTML，没有自己的状态。</p><p id="207c" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">相反，<em class="nk">类</em>组件有自己的单个或多个状态，也可以有所谓的<a class="ae ky" href="https://reactjs.org/docs/state-and-lifecycle.html" rel="noopener ugc nofollow" target="_blank">生命周期方法</a>。</p><p id="5523" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">通常，这两种类型由应用程序中各自的文件夹分开。开发人员可以选择如何组织文件，但是，这种约定使得可视化一般组件层次结构变得容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/fbe75b35fa8d8a9a943b9e1ec92ed08b.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*KM-gwwpo6UPH7YSGPKal9Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文件组织结构示例</p></figure><h2 id="7055" class="oe lh it bd li of og dn lm oh oi dp lq mh oj ok ls ml ol om lu mp on oo lw op bi translated"><strong class="ak">第四步</strong>。<strong class="ak"> <em class="ne">使用Rails API </em> </strong>设置后端</h2><p id="c0d6" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">对于这个项目的后端，我使用Ruby on Rails创建了两个模型，卡片和列表。卡片有许多列表，一个列表属于一张卡片(一个简单的has-many-belongs-to关系模型)。</p><p id="9c46" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">在这里，我不会详细介绍如何设置后端，但作为参考，请参见下面的命令行代码。</p><pre class="kj kk kl km gt oy ox oz pa aw pb bi"><span id="5dc9" class="oe lh it ox b gy pc pd l pe pf">rails new my-app-api --api<br/>rails g resource card title<br/>rails g resource list description completed:boolean card:references</span></pre><p id="1940" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">建立了基本的后端结构后，我现在为卡片和列表模型创建合适的控制器方法。</p><p id="2131" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">对于Rails API，记得安装<code class="fe ou ov ow ox b"><a class="ae ky" href="https://github.com/cyu/rack-cors" rel="noopener ugc nofollow" target="_blank">rack-cors</a></code>(处理跨源资源共享的中间件。换句话说，您的前端能够访问后端生成的API。</p><p id="6060" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">如果您使用它来组织JSON数据，请安装<code class="fe ou ov ow ox b">active-model-serializer</code>。</p><pre class="kj kk kl km gt oy ox oz pa aw pb bi"><span id="60fd" class="oe lh it ox b gy pc pd l pe pf">//Gemfile<br/>gem 'rack-cors'<br/>gem 'active_model_serializers'</span><span id="a4c8" class="oe lh it ox b gy pk pd l pe pf">bundle install</span></pre><h2 id="8595" class="oe lh it bd li of og dn lm oh oi dp lq mh oj ok ls ml ol om lu mp on oo lw op bi translated"><strong class="ak">第五步</strong>。<strong class="ak"> <em class="ne"> App组件</em> </strong></h2><p id="1c83" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如前所述，<code class="fe ou ov ow ox b">App</code>组件将是我的应用程序组件树的最高层次。</p><p id="0786" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">如果你回头参考我的组件层次结构图，<code class="fe ou ov ow ox b">App</code>呈现了两个子组件:<code class="fe ou ov ow ox b">MainContainer</code>和<code class="fe ou ov ow ox b">Nav</code>。</p><p id="895c" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">我们先把<code class="fe ou ov ow ox b">App.js</code>下面的这些“分支”写出来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/33690d2579fb261e714c3c7ad6aef190.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*-T_jlmJCK2lmJ-Ll11S7PA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">App.js</p></figure><p id="2fad" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">我的<code class="fe ou ov ow ox b">App</code>函数的返回值看起来像HTML…！</p><p id="d946" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">这实际上被称为<a class="ae ky" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank"><em class="nk">JSX</em></a>——JavaScript的一种语法扩展，在React中用来描述UI应该是什么样子。</p><p id="df20" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">JSX本质上允许开发者编写混合了JavaScript语法的HTML代码。嵌套在div标签(<code class="fe ou ov ow ox b">&lt;Nav /&gt;</code>和<code class="fe ou ov ow ox b">&lt;MainContainer /&gt;</code>)中的元素是我们希望<code class="fe ou ov ow ox b">App</code>组件呈现的组件子元素。</p><p id="142f" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">组件只返回一个元素，这意味着无论返回值中有多少个元素，这些元素都必须放在一个元素标记下。</p><p id="a750" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">这里，我将<code class="fe ou ov ow ox b">Nav</code>和<code class="fe ou ov ow ox b">MainContainer</code>组件包装在一个<code class="fe ou ov ow ox b">div</code>标签下。</p><p id="c5a5" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">分别位于文件顶部和底部的<code class="fe ou ov ow ox b">import</code>和<code class="fe ou ov ow ox b">export</code>允许访问不同文件之间的组件，因此也允许访问组件之间的组件。</p><p id="095f" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">在<code class="fe ou ov ow ox b">App</code>组件中，我们需要访问<code class="fe ou ov ow ox b">Nav</code>和<code class="fe ou ov ow ox b">MainContainer</code>组件，所以我们直接从它们的相对路径导入它们。类似地，我们导出了<code class="fe ou ov ow ox b">App</code>组件，以便<code class="fe ou ov ow ox b">index.js</code>文件可以呈现整个应用程序。</p><h2 id="a070" class="oe lh it bd li of og dn lm oh oi dp lq mh oj ok ls ml ol om lu mp on oo lw op bi translated"><strong class="ak">第六步</strong>。<strong class="ak"> <em class="ne">导航组件</em> </strong></h2><p id="bcf2" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我只需要用于演示的<code class="fe ou ov ow ox b">Nav</code>组件，其中包含我的应用程序的徽标。所以，我把<code class="fe ou ov ow ox b">Nav</code>组件做成了功能组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/d5a174e0b699f76691952100f368b71a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*UlODDb_BKRu1ZziQ8dAdYw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">导航. js</p></figure><p id="acbf" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">就这样，网站会自动刷新我的新导航栏，取代默认的React主页。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/e0ab4dbd3b2d20a7fcf1bf1a80327daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9oEVtLFrYckw1falX6kO9Q.png"/></div></div></figure><h2 id="f8c7" class="oe lh it bd li of og dn lm oh oi dp lq mh oj ok ls ml ol om lu mp on oo lw op bi translated"><strong class="ak">步骤7。<em class="ne">创建卡片组件控制表单</em> </strong></h2><p id="612d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">有了一个简单的不需要继承任何逻辑的<code class="fe ou ov ow ox b">Nav</code>组件(它只会呈现一个logo)，我们就不需要在<code class="fe ou ov ow ox b">App</code>组件中包含整个应用程序逻辑。</p><p id="4809" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">当我们再次查看我们的组件层次结构时，<code class="fe ou ov ow ox b">MainContainer</code>组件似乎是保存整个应用程序的大部分逻辑和状态的合理位置，这些逻辑和状态将作为道具传递给其子组件。</p><p id="d842" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">因此，应该将<code class="fe ou ov ow ox b">MainContainer</code>组件设置为类组件。</p><p id="2567" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">最终，我们希望<code class="fe ou ov ow ox b">MainContainer</code>向后端发出一个获取请求，检索所有已经创建的卡片，并将这些卡片传递给<code class="fe ou ov ow ox b">ToDoContainer</code>进行渲染。</p><p id="61c8" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">但是现在，我们还没有创建任何卡片！所以，让我们先研究一下<code class="fe ou ov ow ox b">CreateCard</code>组件。</p><p id="4e37" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">顾名思义，<code class="fe ou ov ow ox b">CreateCard</code>组件呈现一个简单的表单，该表单将接受一个标题为<em class="nk">标题为</em>的用户输入，并将该输入发送到后端以创建一个<code class="fe ou ov ow ox b">Card</code>的新实例。</p><p id="bfe8" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">React中有两种类型的表单——受控的和非受控的(在这里了解更多信息)。</p><p id="3b39" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">主要区别在于，在受<em class="nk">控制的</em>表单中，React组件处理表单数据，而在不受<em class="nk">控制的</em>表单中，DOM处理数据。</p><p id="5737" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">由于<code class="fe ou ov ow ox b">CreateCard</code>组件呈现一个简单的表单，我们可以使用一个不受控制的表单。但是，养成编写受控表单的习惯是一个好习惯，因为在构建更复杂、更大规模的应用程序时，它允许更多的灵活性和附加功能。</p><p id="ec70" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">受控窗体要求呈现窗体的组件保持自己的状态，以跟踪不断变化的输入。因此，我们将使用类组件来构建<code class="fe ou ov ow ox b">CreateCard</code>组件。</p><p id="d981" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">输入将保存在组件的状态中。每次输入改变时，<code class="fe ou ov ow ox b">CreateCard</code>组件的状态将反映更新的输入。</p><p id="9269" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">为此，我们首先将状态设置为空字符串输入。我们还需要在<code class="fe ou ov ow ox b">CreateCard</code>类中有一个函数来处理输入的变化。</p><pre class="kj kk kl km gt oy ox oz pa aw pb bi"><span id="d8f5" class="oe lh it ox b gy pc pd l pe pf">state = {<br/>  input: ""<br/>} </span><span id="2501" class="oe lh it ox b gy pk pd l pe pf">handleInput = (event) =&gt; {<br/>   event.persist()<br/>   this.setState({<br/>     input: event.target.value<br/>   })<br/>}</span></pre><p id="dcaa" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">由于React使用事件池，这意味着事件的属性只在回调活动时存在，<code class="fe ou ov ow ox b">event.persist()</code>允许我们引用事件来获取函数中相关的值和方法。</p><p id="b415" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">这里，我们需要<code class="fe ou ov ow ox b">event.target.value</code>来捕获表单中输入的内容。<code class="fe ou ov ow ox b">this.setState</code>是一个React方法，它将新状态设置为作为参数传入的任何内容。</p><p id="9881" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">每当表单识别到更新时，<code class="fe ou ov ow ox b">handleInput</code>函数将<code class="fe ou ov ow ox b">CreateCard</code>组件的状态重置为新的输入。</p><p id="72bf" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">我们需要做的最后一件事是在呈现的表单中插入一个事件监听器，将表单链接到<code class="fe ou ov ow ox b">handleInput</code>函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/a488362967304ebdeeb135f4c96da2db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgjUYq7nTMTC3pXWhjWk3g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建卡片. js</p></figure><p id="8d25" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">请注意，JSX同时使用了类似HTML的代码和纯JavaScript代码，这些代码都包含在花括号内<code class="fe ou ov ow ox b">{}</code>。</p><p id="79c7" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">在输入标签中，我们有一个名为<code class="fe ou ov ow ox b">onChange</code>的事件监听器，它指向我们上面写的<code class="fe ou ov ow ox b">handleInput</code>函数的引用。<code class="fe ou ov ow ox b">this</code>关键字指向父对象，在本例中是整个<code class="fe ou ov ow ox b">CreateCard</code>类。</p><p id="7bcb" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">我们只指出了对<code class="fe ou ov ow ox b">handleInput</code>函数的引用，只有当表单输入发生变化时才会被调用。</p><p id="b4c3" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">当我们<code class="fe ou ov ow ox b">console.log</code>取出组件的状态时，我们可以观察到每次用户输入时，状态都会更新。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/1b6aacd883a4867d169f861836001aff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*n_uaT7_wfxM0s4vCIwINOw.gif"/></div></div></figure><p id="bf2f" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">最后，当用户实际提交表单时，我们需要另一个事件处理程序。让我们再次看看我们的组件树。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/c2804887fc0370e74835eca4d0580ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x_w1QwStrbGuth5Id8tEzg.png"/></div></div></figure><p id="98db" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">当我们将输入从<code class="fe ou ov ow ox b">CreateCard</code>组件传递到后端以创建一个新的<code class="fe ou ov ow ox b">Card</code>实例，并最终添加这个新的卡片以在<code class="fe ou ov ow ox b">ToDoCardContainer</code>下呈现时，我们需要整个逻辑生活在<code class="fe ou ov ow ox b">MainContainer</code>组件下，这是<code class="fe ou ov ow ox b">CreateCard</code>组件和<code class="fe ou ov ow ox b">ToDoCardContainer</code>组件之间的最低共同祖先。</p><h2 id="a0a2" class="oe lh it bd li of og dn lm oh oi dp lq mh oj ok ls ml ol om lu mp on oo lw op bi translated"><strong class="ak">第八步。<em class="ne">主组件—新建卡片</em> </strong></h2><p id="2696" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如上所述，我们最终希望<code class="fe ou ov ow ox b">MainComponent</code>能够跟踪所有从我们后端呈现在页面上的卡片。</p><p id="d295" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">我们要做的第一件事是将状态设置为一个空的卡片数组。</p><pre class="kj kk kl km gt oy ox oz pa aw pb bi"><span id="16f6" class="oe lh it ox b gy pc pd l pe pf">state = {<br/>  cards: []<br/>}</span></pre><p id="4775" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">接下来，我们将编写<code class="fe ou ov ow ox b">createNewCard</code>函数，它最终将作为道具传递给<code class="fe ou ov ow ox b">CreateCard</code>组件。</p><p id="6857" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">该函数负责将提交的输入提取到我们的后端，接收新创建的card对象，并将该对象添加到状态中的cards数组。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/6125e6d3e0abd4a5dbbf8f3d705915e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*tNbQdqg_uMGig1OXDuxZEw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">App.js</p></figure><p id="33f7" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">现在，我们将对该函数的引用作为道具传递给<code class="fe ou ov ow ox b">CreateCard</code>组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/6e99fd4864dafe6fcad2f75c8f2bbd36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*YW2s3XbJdN3r3fKuJoLzeg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">App.js</p></figure><p id="dcf2" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">注意，我们没有调用<code class="fe ou ov ow ox b">createNewCard</code>函数。我们简单地将<em class="nk">引用</em>传递给函数，当用户提交表单时将调用该函数。</p><p id="8d69" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">回到我们的<code class="fe ou ov ow ox b">CreateCard</code>组件内部，我们将编写另一个函数来首先阻止提交按钮的默认动作，并调用从<code class="fe ou ov ow ox b">MainContainer</code>组件传递过来的<code class="fe ou ov ow ox b">createNewCard</code>方法。</p><p id="0846" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">对于类组件，我们使用<code class="fe ou ov ow ox b">this.props</code>访问所有属性，对于功能组件，我们只使用<code class="fe ou ov ow ox b">props</code>(确保将<em class="nk">属性</em>作为函数的参数传递下去)。</p><p id="4768" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">由于我们的输入保存在<code class="fe ou ov ow ox b">CreateCard</code>组件的状态下，我们只需将状态作为参数传递给<code class="fe ou ov ow ox b">createNewCard</code>函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/80be9c4571befa0f97174acf77358566.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*jYbceG0meM0M5c4-4DlPiA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建卡片. js</p></figure><h2 id="8091" class="oe lh it bd li of og dn lm oh oi dp lq mh oj ok ls ml ol om lu mp on oo lw op bi translated"><strong class="ak">第九步。<em class="ne">从后端取数据—生命周期方法</em> </strong></h2><p id="357e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">现在我们可以创建卡片了，让我们在页面上渲染它们吧！</p><p id="9dc9" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">如果我们回头参考我们的组件层次结构，<code class="fe ou ov ow ox b">MainContainer</code>呈现了<code class="fe ou ov ow ox b">ToDoCardContainer</code>，而T5又呈现了单个的<code class="fe ou ov ow ox b">ToDoCard</code>组件。</p><p id="e0af" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">首先，我们需要向后端创建一个获取请求，以获取所有现有的卡，我们最终会将这些卡传递给<code class="fe ou ov ow ox b">ToDoCardContainer</code>。</p><p id="dd63" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">请记住，获取请求是异步的。如果我们试图在获取请求返回之前呈现卡片，我们将得到一个错误，站点将无法加载。</p><p id="3e80" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">这就是React的组件生命周期方法发挥作用的地方。</p><p id="304a" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">使用方法<code class="fe ou ov ow ox b">componentDidMount</code>，我们能够在页面的初始呈现之后运行一个异步事件<em class="nk">。一旦获取请求完成，<code class="fe ou ov ow ox b">this.setState</code>将触发重新渲染，并将从获取请求返回的适当数据显示在网页上。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/4d0f462c81bc5f2d971960a6de961103.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*vqyFfvalqUZRMPZ-aRKh4w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">App.js</p></figure><p id="5633" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">一旦我们在<code class="fe ou ov ow ox b">MainContainer</code>的状态中保存了所有卡片的实例，我们将把它作为道具传递给<code class="fe ou ov ow ox b">ToDoCardContainer</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/fbb1e5cd84f7e51978c4572a2f8e6881.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*8HUG8aTITh8sSEd-X68lxQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">App.js</p></figure><h2 id="340c" class="oe lh it bd li of og dn lm oh oi dp lq mh oj ok ls ml ol om lu mp on oo lw op bi translated"><strong class="ak">第十步。<em class="ne">ToDoCardContainer</em>T34】</strong></h2><p id="8ef8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe ou ov ow ox b">ToDoCardContainer</code>组件单独负责渲染所有的<code class="fe ou ov ow ox b">ToDoCard</code>组件。因此，我们将使它成为一个功能组件。</p><p id="2b9c" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">我们将所有的卡片作为道具传递下来，所以我们可以映射<code class="fe ou ov ow ox b">props.cards</code>来为每个卡片对象创建一个<code class="fe ou ov ow ox b">ToDoCard</code>组件。</p><p id="2137" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">由于<code class="fe ou ov ow ox b">ToDoCard</code>组件需要每张卡片的信息(即卡片的标题，以及最终与每张卡片相关的列表)，我们将卡片对象作为道具传递下去。</p><p id="0804" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">传递一个<code class="fe ou ov ow ox b">key</code>道具也是一个好主意，使用卡片的唯一ID来跟踪我们所有的<code class="fe ou ov ow ox b">ToDoCard</code>组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/5b22e6cede3294cb774712a446f964fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*BybXpQJR17tw0Qc9TKf6tg.png"/></div></figure><h2 id="8a8a" class="oe lh it bd li of og dn lm oh oi dp lq mh oj ok ls ml ol om lu mp on oo lw op bi translated"><strong class="ak">第十一步。<em class="ne">ToDoCard——渲染卡片</em> </strong></h2><p id="9e82" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">首先，让我们看看可以在页面上呈现新创建的卡片。在<code class="fe ou ov ow ox b">ToDoCard</code>组件中，我们返回一个包含卡片对象标题的<code class="fe ou ov ow ox b">div</code>，它是作为道具从<code class="fe ou ov ow ox b">ToDoCardContainer</code>传递过来的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/bd183989a228d190d2d38d341fc45f85.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*1OxSdNvLtVV4ck_ljP-UEg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ToDoCard.js</p></figure><p id="d8e8" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">酷！卡片现在呈现在页面上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/03e783200305bf3be4269754e6121503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DjmuCSQpBQvBCbrVX2wdgA.gif"/></div></div></figure><h2 id="77b3" class="oe lh it bd li of og dn lm oh oi dp lq mh oj ok ls ml ol om lu mp on oo lw op bi translated"><strong class="ak">第十二步。<em class="ne">向卡片添加列表</em> </strong></h2><p id="be2a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">现在我们已经能够在DOM上呈现各个卡片了，让我们在每张卡片上添加另一个控件表单，允许用户为每张卡片添加一个列表项。</p><p id="80b2" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">我们将使用与在<code class="fe ou ov ow ox b">CreateCard</code>组件中相同的受控表单格式。输入状态将存在于<code class="fe ou ov ow ox b">ToDoCard</code>下，但是提交功能将从<code class="fe ou ov ow ox b">MainContainer</code>一直向下传递。</p><p id="23b1" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">首先，我们将在<code class="fe ou ov ow ox b">ToDoCard</code>中编写受控表单。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi py"><img src="../Images/928e490066074976d252ff588cbc9feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*giKOmWwX5SSKLDJjblf8JA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ToDoCard.js</p></figure><p id="e688" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated"><code class="fe ou ov ow ox b">addList</code>回调函数应该使用输入(描述)和相关的卡ID创建一个新的<code class="fe ou ov ow ox b">List</code>实例。</p><p id="4fed" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">一旦在后端创建了新的列表并返回到前端，我们就需要将这个新的列表对象添加到<code class="fe ou ov ow ox b">cards</code>状态中适当的卡片列表数组中。</p><p id="f0c0" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">为此，我们首先使用返回的列表对象的<code class="fe ou ov ow ox b">card_id</code>找到相关的卡片。</p><pre class="kj kk kl km gt oy ox oz pa aw pb bi"><span id="05d8" class="oe lh it ox b gy pc pd l pe pf">const foundCard = {...this.state.cards.find(card =&gt; card.id === cardId)}</span></pre><p id="d2e2" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">然后，我们将新的列表对象连接到那个卡的<em class="nk">的现有列表数组上。</em></p><pre class="kj kk kl km gt oy ox oz pa aw pb bi"><span id="abbe" class="oe lh it ox b gy pc pd l pe pf">foundCard.lists = [...foundCard.lists, newList]</span></pre><p id="c2e8" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">然后，我们映射存储在状态中的现有cards数组，用带有附加列表项的新的、更新的card对象替换有问题的card对象。</p><pre class="kj kk kl km gt oy ox oz pa aw pb bi"><span id="dc10" class="oe lh it ox b gy pc pd l pe pf">const newCards = this.state.cards.map(card =&gt; {<br/>     if (card.id === cardId){<br/>       return foundCard<br/>     } else {<br/>       return card<br/>     }<br/>})</span></pre><p id="ce81" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">最后，我们将<code class="fe ou ov ow ox b">setState</code>中的卡片放到新的卡片数组中。</p><pre class="kj kk kl km gt oy ox oz pa aw pb bi"><span id="6911" class="oe lh it ox b gy pc pd l pe pf">this.setState({<br/>   cards: newCards<br/>})</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/504ff7daedf4fd28b3ddd056cadacead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6N1DVH0xpVDSX8aopmmoYA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">MainContainer.js</p></figure><h2 id="d950" class="oe lh it bd li of og dn lm oh oi dp lq mh oj ok ls ml ol om lu mp on oo lw op bi translated"><strong class="ak">第十三步。<em class="ne"> ToDoList —每张卡的渲染列表</em> </strong></h2><p id="4d60" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">太好了！现在我们可以在卡片上添加列表。</p><p id="084f" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">让我们看看是否可以在适当的卡片下呈现列表。</p><p id="51fb" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">就像我们之前渲染单张卡片一样，我们映射每张卡片的列表(作为道具传递)来渲染一个<code class="fe ou ov ow ox b">ToDoList</code>组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/5b8b760620e8f4d09505b786c7c60bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x6NYUKGIAXSlP9OPyNgu8Q.png"/></div></div></figure><p id="b372" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">让我们看看这是否有效…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/71307286048e08d3adc9c2821a0d25d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3IMQ_-r1OO6Q8qVms7T-eg.gif"/></div></div></figure><p id="d761" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">厉害！列表呈现在适当的<code class="fe ou ov ow ox b">ToDoCard</code>下！</p><h2 id="f8f0" class="oe lh it bd li of og dn lm oh oi dp lq mh oj ok ls ml ol om lu mp on oo lw op bi translated"><strong class="ak">第14步。<em class="ne">核对清单项目</em>T30】</strong></h2><p id="15c6" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">作为我的最后一个功能，我希望用户能够点击一个列表项，并检查列表，如果它已经完成。</p><p id="497c" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">列表项有一个属性<code class="fe ou ov ow ox b">completed</code>，初始化时设置为<code class="fe ou ov ow ox b">false</code>。我们希望每当项目被点击时，将这个布尔值更新为<code class="fe ou ov ow ox b">true</code>。</p><p id="6bda" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">当我们改变列表对象的属性时，它在<code class="fe ou ov ow ox b">MainContainer</code>的状态中被跟踪，我们将再次在我们的<code class="fe ou ov ow ox b">MainContainer</code>组件中编写函数。</p><p id="bbf6" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">我们正在编写的函数将接受列表ID和卡ID作为它的参数。</p><p id="0321" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">我们首先要确定被点击的列表项的属性是<code class="fe ou ov ow ox b">true</code>还是<code class="fe ou ov ow ox b">false</code>。如果是<code class="fe ou ov ow ox b">false</code>，我们要把状态改成<code class="fe ou ov ow ox b">true</code>，反之亦然。</p><p id="5e79" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">然后，我们传递这个新状态来更新(或发送一个<code class="fe ou ov ow ox b">PATCH</code>请求)我们的数据库。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/cb989a0999b2a69d326a5e2b53bb97b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UL3yOmALcyu1Uo9RF18zrw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">MainContainer.js</p></figure><p id="1b5f" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">一旦后端更新并返回新的列表对象，我们必须更新我们的卡的状态以反映这一变化。这里，我们使用类似的映射技术来替换状态数组中更新的对象。</p><p id="295a" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">然而，由于列表是状态中的嵌套数组，我们需要首先创建一个新的更新列表数组，<em class="nk">然后</em>更新卡片数组。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/106807dc45f2dc6cbd9308e8ff19e94a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*FXmET_w9zwo17inrU8F_cg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">MainContainer.js</p></figure><p id="e920" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">我们可以将这个<code class="fe ou ov ow ox b">handleClickList</code>函数传递给我们的<code class="fe ou ov ow ox b">ToDoContainer</code>，然后传递给<code class="fe ou ov ow ox b">ToDoCard</code>，最后传递给我们的<code class="fe ou ov ow ox b">ToDoList</code>。</p><p id="6b2b" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">这样，每个<code class="fe ou ov ow ox b">ToDoList</code>组件都将<code class="fe ou ov ow ox b">handleClickList</code>函数作为其道具，并可以在每个事件发生时调用该函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qe"><img src="../Images/ec05de772032ee30773deb48187f2d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KauxXwv41hp7ieiCBNKaxQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ToDoList.js</p></figure><p id="f94b" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">在包含<code class="fe ou ov ow ox b">ToDoList</code>描述的<code class="fe ou ov ow ox b">h3</code>标签中，我使用了<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" rel="noopener ugc nofollow" target="_blank">三元运算符</a>来添加一些样式，以指示列表是否已经完成。</p><p id="b03a" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">如果列表的完成属性是<code class="fe ou ov ow ox b">true</code>，那么<code class="fe ou ov ow ox b">h3</code>标签的<code class="fe ou ov ow ox b">className</code>将是<code class="fe ou ov ow ox b">completed-list</code>——显示一个勾号并删除描述。</p><p id="e622" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">否则，<code class="fe ou ov ow ox b">className</code>将是<code class="fe ou ov ow ox b">to-do-list</code>而没有额外的样式。</p><p id="bd2c" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">让我们来看看实际情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qf"><img src="../Images/e589c11d079f156408bb21e4dcb26a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uwE9_4aTbgtyuD_gkimWAA.gif"/></div></div></figure><p id="6b42" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">现在你知道了！一个简单的任务跟踪程序。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="d7c6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="3a68" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">虽然本文远非完整的React指南，但我想介绍React的核心支柱，并启发您尝试使用该库从头构建一个简单的应用程序。</p><p id="af9f" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">从我的经验来看，自己创造东西，自己动手，是最好的学习方式。祝你好运，但最重要的是，玩得开心！</p><p id="58d2" class="pw-post-body-paragraph ly lz it ma b mb nl ju md me nm jx mg mh nn mj mk ml no mn mo mp np mr ms mt im bi translated">这里是GitHub上完整资源库的链接。随意克隆，仔细看看，甚至可能添加更多的功能！</p></div></div>    
</body>
</html>