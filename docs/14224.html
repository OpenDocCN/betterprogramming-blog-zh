<html>
<head>
<title>Validation With Regex in Swift 5.7 Using SwiftUI and Combine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift 5.7中使用SwiftUI和Combine进行正则表达式验证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/validation-with-regex-before-ios-16-using-swiftui-and-combine-567817909d1?source=collection_archive---------4-----------------------#2022-11-18">https://betterprogramming.pub/validation-with-regex-before-ios-16-using-swiftui-and-combine-567817909d1?source=collection_archive---------4-----------------------#2022-11-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2f20" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用新的正则表达式语法验证用户输入</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/50ac4815051b3f120c011e996d17f0cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4gC1impUDWiczJjJ8n16Nw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">关于正则表达式变体的幻灯片|来自<a class="ae ky" href="https://developer.apple.com/forums/thread/707822" rel="noopener ugc nofollow" target="_blank">苹果开发者文档</a>的代码</p></figure><p id="6e24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将Regex的历史追溯到美国数学家，<a class="ae ky" href="https://en.wikipedia.org/wiki/Stephen_Cole_Kleene" rel="noopener ugc nofollow" target="_blank">斯蒂芬·科尔·克莱尼</a>，他在1951年提出了使用各种数学表达式来表示模式的想法。然而，直到1967年Ken Thompson 决定在他的编辑器Qed和ED中使用它，他的工作才开始起步，在UNIX下运行，UNIX是OSX、iOS和Android的前身。</p><p id="fc5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然你可能认为正则表达式的简洁几乎肯定影响了世界上最流行的编程语言之一的语法，即C语言，它直到1972年才问世。目标C的先行者，现在是斯威夫特。</p><p id="43f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管Regex没有进入C语言，但它已经被集成到许多UNIX实用程序中，如grep、awk和vi，以及大多数现代编程语言中。所以，苹果花了将近40年才在Objective C中采用Regex，直到2010年，这多少有点令人惊讶(至少对我来说)。</p><p id="aed9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个十年前，他们试图在WWDC2022中通过重写语法来更新它，使它更加用户友好。和我一起用一些更现代的正则表达式来更新这篇文章和它的同行。虽然我将在新的命令框架中在很大程度上使用原来的语法。</p><h1 id="5123" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我们的基本代码</h1><p id="e80c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我开始之前，我想用正则表达式语法定义12条规则。正如我所说的，这里的语法和1967年的几乎一样，所以——非常确定。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="e4fa" class="mx lw it mt b be my mz l na nb">enum Rules:String, CaseIterable {<br/>    case alphaRule = "[A-Za-z]+"<br/>    case digitRule = "[0-9]+"<br/>    case limitedAlphaNumericCombined = "[A-Za-z0-9]{4,12}"<br/>    case limitedAlphaNumericSplit = "[A-Za-z]{4,12}[0-9]{2,4}"<br/>    case currencyRule = "(\\w*)[£$€]+(\\w*)"<br/>    case wordRule = "(\\w+)"<br/>    case numericRule = "(\\d+)"<br/>    case numberFirst = "^(\\d+)(\\w*)"<br/>    case numberLast = "(\\w*)(\\d+)$"<br/>    case spaceRule = "[\\S]"<br/>    case capitalFirst = "^[A-Z]+[A-Za-z]*"<br/>    case punctuationCharacters = "[:punct:]"<br/>}</span></pre><p id="2835" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，方括号表示指定范围内的字符；加号表示一个或多个。花括号中的数字是最小和最大字符数。后跟小写字母的双斜线是字符类，后跟大写字母的双斜线是所述类的逆。星号表示零或更多。如果在方括号之外，帽子意味着必须以下列字符开头。</p><p id="9085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，如果在方括号内，帽子也有相反的意思。美元手段必须以上述模式结束。最后，您有一个POSIX类<code class="fe nc nd ne mt b">[:punct:]</code>，它是不言自明的。</p><p id="24bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一组错误消息[以相同的顺序]链接到所述正则表达式。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="c354" class="mx lw it mt b be my mz l na nb">enum Crips:String, CaseIterable {<br/>    case alphaRule = "MUST be alpha only"<br/>    case digitRule = "MUST be numeric ONLY"<br/>    case limitRuleCombined = "MIN 4 AlphaNumeric MAX 12 AlphaNumeric"<br/>    case limitRuleSplit = "START MIN 4 Alpha MAX 12 Alpha, FINISH MIN 2 numeric, MAX 4 numeric"<br/>    case currencyRule = "MUST contain $£€"<br/>    case wordRule = "MUST be alphanumeric"<br/>    case numericRule = "MUST be numeric"<br/>    case numberFirst = "MUST start with a number"<br/>    case numberLast = "MUST finish with a number"<br/>    case noSpaces  = "MUST not contain spaces or tabs"<br/>    case leadingCapital = "MUST start with am uppercase letter"<br/>    case punctuationCharacters = "MUST contain punctuation characters"<br/>    <br/>    static var cripList: [String] {<br/>        return Crips.allCases.map { $0.rawValue }<br/>    }<br/>}</span></pre><p id="d1f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，在我开始之前，这里有一个我用来帮助我将第一组枚举映射到第二组枚举的扩展。它返回提交给它的枚举的索引。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="43d7" class="mx lw it mt b be my mz l na nb">extension CaseIterable where Self: Equatable {<br/>    public func ordinal() -&gt; Self.AllCases.Index {<br/>        return Self.allCases.firstIndex(of: self)!<br/>    }<br/>}</span></pre><p id="1e27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，接下来是主菜。我想尽可能简单。我首先定义一个结构，在这个结构中，我将使用链接到与我的密码字符串不匹配的正则表达式的消息。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="7061" class="mx lw it mt b be my mz l na nb">struct Diag: Hashable, Codable, Identifiable {<br/>    var id = UUID()<br/>    var message = ""<br/>}</span></pre><p id="6520" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我创建了一个结构<code class="fe nc nd ne mt b">Hashable</code>、<code class="fe nc nd ne mt b">Codable</code>和<code class="fe nc nd ne mt b">Identifiable</code>，这样我就可以在SwiftUI循环中使用它。现在来看主菜，主菜有两个主要功能。这里的第一个是匹配我的枚举中的正则表达式。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="bf8e" class="mx lw it mt b be my mz l na nb">fileprivate func matchRegex() {<br/>        for rule in Rules.allCases {<br/>            let formulae = try! Regex(rule.rawValue)<br/>            if let _ = passText.wholeMatch(of: formulae) {<br/>                // is good, right size alpha upper + lower &amp; numeric<br/>            } else {<br/>                let diag = Crips.cripList[rule.ordinal()]<br/>                diagMsgs.append(Diag(message: "\(diag)"))<br/>                let foo = /\a/<br/>                print(foo)<br/>            }<br/>        }<br/>    }</span></pre><p id="a7ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它贯穿了我的集合中的所有正则表达式。为所有匹配失败的诊断消息构建一个数组。</p><p id="5e13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，第二个功能显示了一个类似控制台的诊断列表，如果它变得太大，就会从屏幕上滚下来。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="b737" class="mx lw it mt b be my mz l na nb">fileprivate func displaceFailedMatches() -&gt; ScrollViewReader&lt;ScrollView&lt;VStack&lt;some View&gt;&gt;&gt; {<br/>        return ScrollViewReader { moveTo in<br/>            ScrollView(.vertical) {<br/>                VStack(alignment: .leading) {<br/>                    ForEach(diagMsgs, id: \.id) { text in<br/>                        Text("\(text.message)")<br/>                            .font(Fonts.neutonRegular(size: 16))<br/>                            .id(text.id)<br/>                    }.onChange(of: diagMsgs) { _ in<br/>                        moveTo.scrollTo(diagMsgs.last?.id, anchor: .bottom)<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    }</span></pre><p id="6368" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我有主体。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="af98" class="mx lw it mt b be my mz l na nb">var body: some View {<br/>        VStack {<br/>            HStack {<br/>                Spacer(minLength: 4)<br/>                TextField("Pass ", text: $passText)<br/>                    .font(Fonts.neutonRegular(size: 32))<br/>                    <br/>                    .onChange(of: passText) { newValue in<br/>                        diagMsgs.removeAll()<br/>                        matchRegex()<br/>                        if passText.isEmpty {<br/>                            diagMsgs.removeAll()<br/>                        }<br/>                    }<br/>                    .border(Color.black)<br/>                    .padding(.top, 64)<br/>                Spacer()<br/>            }<br/>            displaceFailedMatches()<br/>        }<br/>    }</span></pre><p id="ce42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要用所示的双态变量定义的主体，在已经提到的方法中引用。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="ce8c" class="mx lw it mt b be my mz l na nb">struct ContentView: View {<br/>    @State var passText = ""<br/>    @State var diagMsgs:[Diag] = []</span></pre><p id="4bef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把这些放在一起，你会在屏幕的顶部看到一个区域，你可以在那里输入一个单词。对所有数组正则表达式测试一个单词，报告失败的匹配。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/ffbc7ceecdbdddae1e3bf041a35d28ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*r_cZI85xDGvzX_2ThawJig.gif"/></div></div></figure><p id="917c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，清除所有的错误消息是不可能的，因为我有冲突的集合。我让读者来决定他们需要取消哪些来获得一些工作集。</p><p id="95e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些都让我想到这篇短文的结尾。如果您有兴趣了解更多信息，请花点时间观看WWDC2022视频。苹果已经为正则表达式开发了一种新的语法，尽管我提醒读者，也许他们应该先学习已经存在了60年甚至更久的版本(如本文所示)。</p><p id="1c20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是你在其他任何地方都能找到的Regex风格。</p></div></div>    
</body>
</html>