<html>
<head>
<title>How To Use Lowercase Types for Primitives and Objects in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在TypeScript中对基元和对象使用小写类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-lowercase-types-for-primitives-and-objects-in-typescript-ddd00273849a?source=collection_archive---------10-----------------------#2021-11-16">https://betterprogramming.pub/how-to-use-lowercase-types-for-primitives-and-objects-in-typescript-ddd00273849a?source=collection_archive---------10-----------------------#2021-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="22eb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于数字、大整数、字符串、布尔、符号和对象的完整指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ed36116b3ae2332e488685c48bac2e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gsakwRlYxXRn901q"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@d_kuruvilla?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼尔·库鲁维拉</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="966c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript是一种基于JavaScript的强类型编程语言。类型安全在TypeScript中至关重要。它阻止或防止由不同数据类型之间的差异导致的类型错误。</p><p id="2c04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript有原语类型、对象类型、<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/a-complete-guide-to-enums-in-typescript-6f76da009146">枚举类型</a>、联合类型、元组类型、交集类型、<code class="fe lv lw lx ly b">keyof</code>类型、<code class="fe lv lw lx ly b">typeof</code>类型、模板文字类型、索引访问类型、映射类型、条件类型、接口类型、类类型、泛型类型等。</p><p id="477b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不仅种类繁多，有些种类还有两种形态，比如<code class="fe lv lw lx ly b">boolean</code> vs <code class="fe lv lw lx ly b">Boolean</code>，甚至还有三种形态，比如<code class="fe lv lw lx ly b">object</code>、<code class="fe lv lw lx ly b">Object</code>、<code class="fe lv lw lx ly b">{}</code>。</p><p id="0ce1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html" rel="noopener ugc nofollow" target="_blank">打字手册</a>中有说明:</p><ul class=""><li id="9cdc" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">不要使用类型<code class="fe lv lw lx ly b">Number</code>、<code class="fe lv lw lx ly b">String</code>、<code class="fe lv lw lx ly b">Boolean</code>、<code class="fe lv lw lx ly b">Symbol</code>或<code class="fe lv lw lx ly b">Object</code>。</li><li id="198d" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">务必使用<code class="fe lv lw lx ly b">number</code>、<code class="fe lv lw lx ly b">string</code>、<code class="fe lv lw lx ly b">boolean</code>和<code class="fe lv lw lx ly b">symbol</code>类型。使用非原语类型<code class="fe lv lw lx ly b">object</code>代替<code class="fe lv lw lx ly b">Object</code>。</li></ul><p id="23fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，<code class="fe lv lw lx ly b">BigInt</code>在列表中缺失。但是规则是一样的:用<code class="fe lv lw lx ly b">bigint</code>代替<code class="fe lv lw lx ly b">BigInt</code>。</p><p id="caf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们详细检查一下这些内置类型。</p><h1 id="9c8a" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">JavaScript类型</h1><p id="9ae3" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">JavaScript是一种松散类型的动态语言。JavaScript中的变量不直接与任何特定的值类型相关联。任何变量都可以被赋值和重新赋值。</p><p id="6c45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript变量分为两种类型:</p><ul class=""><li id="2933" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">原始类型:除了定义不可变值的对象之外的所有类型。</li><li id="9dbc" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">对象类型:类型定义了属性的集合。它包括所有不是基元的类型。</li></ul><p id="b002" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本类型可以进一步分为以下类型:</p><ul class=""><li id="b18e" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">boolean</code></li><li id="8a9c" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">string</code></li><li id="f262" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">symbol</code></li><li id="25ae" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">number</code></li><li id="ffb5" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">bigint</code></li><li id="edf0" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">null</code></li><li id="7692" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">undefined</code></li></ul><p id="569e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript是JavaScript的超集。它加强了对JavaScript松散类型本质的限制，从而防止了类型错误。</p><h1 id="9fe6" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated"><code class="fe lv lw lx ly b">boolean</code>对<code class="fe lv lw lx ly b">Boolean</code></h1><p id="e631" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><code class="fe lv lw lx ly b">boolean</code>是逻辑值的基本类型，只能是<code class="fe lv lw lx ly b">true</code>或<code class="fe lv lw lx ly b">false</code>。</p><p id="1c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Boolean</code>是一个<code class="fe lv lw lx ly b">boolean</code>值的对象包装器(函数)。</p><p id="9819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">new Boolean()</code>创建一个<code class="fe lv lw lx ly b">Boolean</code>的对象实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e3a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe lv lw lx ly b">Boolean</code>用作类型时，它不引用对象包装器。相反，它是一个TypeScript接口，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="83bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">new Boolean()</code>从本地构造函数创建一个对象实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3c37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">boolean</code>被视为<code class="fe lv lw lx ly b">Boolean</code>的一个子类型。我们可以给<code class="fe lv lw lx ly b">Boolean</code>分配一个原始的<code class="fe lv lw lx ly b">boolean</code>值，但反之则不然。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2bb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，最好的做法是用<code class="fe lv lw lx ly b">boolean</code>代替<code class="fe lv lw lx ly b">Boolean</code>。</p><h1 id="a3f2" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated"><code class="fe lv lw lx ly b">number</code>对<code class="fe lv lw lx ly b">Number</code></h1><p id="deab" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><code class="fe lv lw lx ly b">number</code>是在<code class="fe lv lw lx ly b">[-(2⁵³ − 1), 2⁵³ − 1]</code>范围内的双精度64位二进制格式IEEE 754值的基本类型。除了表示浮点数外，它还有三个符号值:<code class="fe lv lw lx ly b">+Infinity</code>、<code class="fe lv lw lx ly b">-Infinity</code>、<code class="fe lv lw lx ly b">NaN</code>(<strong class="lb iu">N</strong>ot<strong class="lb iu">a</strong>T41】Number)。</p><p id="ec5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Number</code>是<code class="fe lv lw lx ly b">number</code>值的对象包装器(函数)。</p><p id="3247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">new Number()</code>创建一个<code class="fe lv lw lx ly b">Number</code>的对象实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="df8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe lv lw lx ly b">Number</code>用作类型时，它不引用对象包装器。相反，它是一个TypeScript接口，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c25a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从本地构造函数创建一个对象实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="22bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">number</code>被视为<code class="fe lv lw lx ly b">Number</code>的子类型。我们可以将一个原始的<code class="fe lv lw lx ly b">number</code>值赋给<code class="fe lv lw lx ly b">Number</code>，但反之则不然。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ee8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，最好的做法是使用<code class="fe lv lw lx ly b">number</code>而不是<code class="fe lv lw lx ly b">Number</code>。</p><h1 id="7825" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated"><code class="fe lv lw lx ly b">bigint vs. </code> BigInt</h1><p id="d6d7" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><code class="fe lv lw lx ly b">bigint</code>是表示任意精度整数的数值的基本类型。通过将<code class="fe lv lw lx ly b">n</code>追加到整数的末尾或者通过调用构造函数<code class="fe lv lw lx ly b">BigInt</code>来创建<code class="fe lv lw lx ly b">bigint</code>值。</p><p id="6d16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">BigInt</code>是一个<code class="fe lv lw lx ly b">bigint</code>值的对象包装器(函数)。</p><p id="6283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">BigInt</code>没有<code class="fe lv lw lx ly b">new</code>操作员。它也不打算被子类化。它可以用作类定义的<code class="fe lv lw lx ly b">extends</code>子句的值，但是对<code class="fe lv lw lx ly b">BigInt</code>构造函数的<code class="fe lv lw lx ly b">super</code>调用将导致异常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1ec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe lv lw lx ly b">BigInt</code>用作类型时，它不引用对象包装器。相反，它是一个类型脚本接口。在下面的<code class="fe lv lw lx ly b">BigIntConstructor</code>界面(第17行)中，没有<code class="fe lv lw lx ly b">new</code>操作符。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">bigint</code>被视为<code class="fe lv lw lx ly b">BigInt</code>的一个亚型。我们可以给<code class="fe lv lw lx ly b">BigInt</code>分配一个原始的<code class="fe lv lw lx ly b">bigint</code>值，但反之则不然。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a44e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，最好的做法是用<code class="fe lv lw lx ly b">bigint</code>代替<code class="fe lv lw lx ly b">BigInt</code>。</p><h1 id="7297" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated"><code class="fe lv lw lx ly b">string</code>对<code class="fe lv lw lx ly b">String</code></h1><p id="9d33" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><code class="fe lv lw lx ly b">string</code>是文本值的基本类型。字符串是不可变的——字符串一旦创建，就不能修改。</p><p id="8559" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">String</code>是<code class="fe lv lw lx ly b">string</code>值的对象包装器(函数)。</p><p id="cb52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">new String()</code>创建一个<code class="fe lv lw lx ly b">String</code>的对象实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe lv lw lx ly b">String</code>用作类型时，它不引用对象包装器。相反，它是一个类型脚本接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="38bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从本地构造函数创建一个对象实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">string</code>被视为<code class="fe lv lw lx ly b">String</code>的子类型。我们可以将一个原始的<code class="fe lv lw lx ly b">string</code>值赋给<code class="fe lv lw lx ly b">String</code>，但反之则不然。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="50bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，最好的做法是使用<code class="fe lv lw lx ly b">string</code>而不是<code class="fe lv lw lx ly b">String</code>。</p><h1 id="16f9" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated"><code class="fe lv lw lx ly b">symbol</code>对<code class="fe lv lw lx ly b">Symbol</code></h1><p id="4be7" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><code class="fe lv lw lx ly b">symbol</code>是唯一且不可变的值的基本类型，可用作对象属性的键。</p><p id="ac0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Symbol</code>是一个<code class="fe lv lw lx ly b">symbol</code>值的对象包装器(函数)。</p><p id="8178" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">new Symbol()</code>无效，因为它没有构造函数。</p><p id="405d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，符号不会自动转换为字符串。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8e70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe lv lw lx ly b">Symbol</code>用作类型时，它不引用对象包装器。相反，它是一个类型脚本接口。在下面的接口定义中，没有<code class="fe lv lw lx ly b">SymbolConstructor</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3e80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">symbol</code>被视为<code class="fe lv lw lx ly b">Symbol</code>的子类型。我们可以给<code class="fe lv lw lx ly b">Symbol</code>分配一个原始的<code class="fe lv lw lx ly b">symbol</code>值，但反之则不然。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="227d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，最好的做法是使用<code class="fe lv lw lx ly b">symbol</code>而不是<code class="fe lv lw lx ly b">Symbol</code>。</p><h1 id="6365" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">空且未定义</h1><p id="4938" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">类型只有一个值:<code class="fe lv lw lx ly b">null</code>。一个<code class="fe lv lw lx ly b">null</code>值代表一个指向不存在的对象的引用。<code class="fe lv lw lx ly b">null</code>的行为像一个原语，但是<code class="fe lv lw lx ly b">typeof null</code>返回<code class="fe lv lw lx ly b">"object"</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d4d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型只有一个值<code class="fe lv lw lx ly b">undefined</code>。任何已声明但未赋值的变量都有值<code class="fe lv lw lx ly b">undefined</code>。<code class="fe lv lw lx ly b">typeof undefined</code>返回<code class="fe lv lw lx ly b">"undefined"</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6806" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">null</code>和<code class="fe lv lw lx ly b">undefined</code>都只有小写选项。</p><p id="351c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">null</code>和<code class="fe lv lw lx ly b">undefined</code>常用于一个活接头类型，如<code class="fe lv lw lx ly b">string | null</code>、<code class="fe lv lw lx ly b">number | undefined</code>等。</p><h1 id="1c7b" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">对象、对象和{}</h1><p id="6200" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">任何非原始类型都被认为是一个<code class="fe lv lw lx ly b">object</code>类型，它是属性的集合。对象的<code class="fe lv lw lx ly b">typeof</code>将返回<code class="fe lv lw lx ly b">"object"</code>或<code class="fe lv lw lx ly b">"function"</code>。</p><p id="9135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么是<code class="fe lv lw lx ly b">"function"</code>？</p><p id="08a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数是一级对象，因为它们可以像任何其他对象一样拥有属性和方法。历史上，<code class="fe lv lw lx ly b">typeof &lt;function&gt;</code>返回<code class="fe lv lw lx ly b">"function"</code>，而不是<code class="fe lv lw lx ly b">"object"</code>。函数原型对象被指定为函数对象，以确保与在ECMAScript 2015规范之前创建的ECMAScript代码兼容。</p><p id="242e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何非原始值都可以赋给<code class="fe lv lw lx ly b">object</code>类型变量，如下图所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="83c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object</code>是一个<code class="fe lv lw lx ly b">interface</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2a17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">new Object()</code>从本地构造函数创建一个对象实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="207a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object</code>不如<code class="fe lv lw lx ly b">object</code>具体。除了<code class="fe lv lw lx ly b">null</code>和<code class="fe lv lw lx ly b">undefined</code>之外，任何东西都可以分配给<code class="fe lv lw lx ly b">Object</code>类型的变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="44d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外还有这个空型，<code class="fe lv lw lx ly b">{}</code>。<code class="fe lv lw lx ly b">{}</code>在运行时与<code class="fe lv lw lx ly b">Object</code>相同——除了<code class="fe lv lw lx ly b">null</code>和<code class="fe lv lw lx ly b">undefined</code>之外，任何东西都可以分配给<code class="fe lv lw lx ly b">{}</code>类型的变量。</p><p id="6fdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在编译时，<code class="fe lv lw lx ly b">{}</code>没有<code class="fe lv lw lx ly b">Object</code>的任何成员— <code class="fe lv lw lx ly b">{}</code>没有<code class="fe lv lw lx ly b">Object</code>那么具体。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="152c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe lv lw lx ly b">Object</code>接口有一个成员<code class="fe lv lw lx ly b">toString()</code>，它返回<code class="fe lv lw lx ly b">string</code>。第3行显示一个关于返回<code class="fe lv lw lx ly b">number</code> (3)的错误。</p><p id="c49f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，<code class="fe lv lw lx ly b">{}</code>和<code class="fe lv lw lx ly b">object</code>没有此限制。</p><p id="af8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，<code class="fe lv lw lx ly b">object</code>、<code class="fe lv lw lx ly b">Object</code>、<code class="fe lv lw lx ly b">{}</code>都不太具体。它们可以相互分配。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="df81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，定义为<code class="fe lv lw lx ly b">object</code>、<code class="fe lv lw lx ly b">Object</code>或<code class="fe lv lw lx ly b">{}</code>的变量不能访问它们的属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0b0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">据说:不用<code class="fe lv lw lx ly b">Object</code>，用非原语<code class="fe lv lw lx ly b">object</code>类型。</p><p id="ff29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我们的经验，我们建议不要使用这些通用对象类型。<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/typescript-anonymous-types-type-aliases-and-interface-declarations-b60bc8a08f8c">类型别名或接口声明，甚至匿名类型</a>，是指定类型的更好方法。</p><h1 id="9baa" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="7ac7" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们已经研究了TypeScript中的许多内置类型，以下是我们的建议:</p><ul class=""><li id="1eb4" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">不要使用类型<code class="fe lv lw lx ly b">Number</code>、<code class="fe lv lw lx ly b">BigInt</code>、<code class="fe lv lw lx ly b">String</code>、<code class="fe lv lw lx ly b">Boolean</code>、<code class="fe lv lw lx ly b">Symbol</code>、<code class="fe lv lw lx ly b">Object</code>或<code class="fe lv lw lx ly b">{}</code>。</li><li id="a0bd" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">务必使用<code class="fe lv lw lx ly b">number</code>、<code class="fe lv lw lx ly b">bigint</code>、<code class="fe lv lw lx ly b">string</code>、<code class="fe lv lw lx ly b">boolean</code>、<code class="fe lv lw lx ly b">symbol</code>类型。</li><li id="87c9" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">如果有必要，使用<code class="fe lv lw lx ly b">object</code>类型，但是首先考虑类型别名、接口声明，甚至匿名类型。</li></ul><p id="3795" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。如果你有兴趣，可以看看<a class="ae ky" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener">我的其他媒体文章</a>。</p></div></div>    
</body>
</html>