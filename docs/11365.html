<html>
<head>
<title>Is Bun the Next Big Thing After Webpack?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Bun是继Webpack之后的下一个大事件吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/is-bun-the-next-big-thing-after-webpack-d683441f77b9?source=collection_archive---------1-----------------------#2022-03-14">https://betterprogramming.pub/is-bun-the-next-big-thing-after-webpack-d683441f77b9?source=collection_archive---------1-----------------------#2022-03-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d62f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">bun vs . SWC vs . es build vs . NPM vs . babel等等。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8267b9d1573b87dfe7f3e65f9f57b6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yhoRCSTt_6GbRmVamG_IpA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ce6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JavaScript工具的未来远离JavaScript语言。像Webpack和Babel这样的工具正日益失去其相关性。为什么？</p><p id="795a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像<code class="fe lu lv lw lx b">Rust</code>、<code class="fe lu lv lw lx b">Go</code>甚至<code class="fe lu lv lw lx b">Zig</code>这样的语言已经被证明在捆绑、传输和编译过程中比JavaScript更高效。它们不是单线程的，这在处理大量文件时是有益的。</p><p id="681e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在JavaScript中保留生态系统工具的原因是什么？这些工具应该在开发人员的机器上执行，而不是在浏览器上。此外，JS开发人员不需要调试它们的内部。</p><p id="8699" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">SWC</code>是JavaScript之外最早的工具项目之一。不久之后，<code class="fe lu lv lw lx b">esbuild</code>宣布了，每个人都为此大肆宣传。由于他们的表现，两人都是真正的游戏规则改变者。</p><p id="025e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">Vite 2.0</code>项目现在正在幕后使用<code class="fe lu lv lw lx b">esbuild</code>来提供一种高性能的建筑体验。</p><p id="cfc1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最近，我们看到了JavaScript工具生态系统中的一个新玩家:<code class="fe lu lv lw lx b">bun</code>。它旨在使整个JavaScript开发更快。这是一个包含所有电池的工具。它不仅加速了编译和解析，还提供了自己的依赖管理器工具和捆绑。</p><p id="d217" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它还没有准备好投入生产，但是这个工具的前景看起来很光明。在本文中，我们将通过<code class="fe lu lv lw lx b">npm</code>、<code class="fe lu lv lw lx b">esbuild</code>、<code class="fe lu lv lw lx b">babel</code>和<code class="fe lu lv lw lx b">Webpack</code>来检查这一新工具及其地位。</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="bbd0" class="mc md it lx b gy me mf l mg mh"><strong class="lx iu"><em class="mi">Update: </em></strong><em class="mi">the Bun tool has been made more exciting after the release of this article. It is now also a JavaScript runtime execution and is adding more features by the day.</em></span></pre><h1 id="bb7e" class="mj md it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">概观</h1><p id="54a9" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated"><code class="fe lu lv lw lx b">bun</code>没有像它的顶级竞争对手一样被写成<code class="fe lu lv lw lx b">Rust</code>或者<code class="fe lu lv lw lx b">Go</code>，而是用<code class="fe lu lv lw lx b">Zig</code>打造。<code class="fe lu lv lw lx b">Zig</code>是一种通用编程语言和工具链，用于维护健壮、最优和可重用的软件。</p><p id="b03f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">即使它是从零开始构建的，开发者也是基于<code class="fe lu lv lw lx b">esbuild</code>项目来开发的。</p><p id="2308" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">bun</code>工具支持开箱即用的复杂特性，如<code class="fe lu lv lw lx b">TypeScript</code>、<code class="fe lu lv lw lx b">CSS in Js</code>、<code class="fe lu lv lw lx b">JSX</code>。它仍然缺少一些基本功能，如<code class="fe lu lv lw lx b">Source Maps</code>、<code class="fe lu lv lw lx b">Minifier</code>、<code class="fe lu lv lw lx b">Tree-shaking</code>等等。</p><p id="bf88" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个显著的特性是<code class="fe lu lv lw lx b">bun</code>有自己的节点模块解析器实现。这是最引人注目的优化之一。</p><p id="0f5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就像<code class="fe lu lv lw lx b">Npm</code>和<code class="fe lu lv lw lx b">Yarn</code>会创建一些关联的锁文件一样，<code class="fe lu lv lw lx b">bun</code>也会。它将创造一个<code class="fe lu lv lw lx b">bun.lockb</code>。有一个小小的警告。它不是生成一个纯文本文件，而是生成一个二进制文件。为什么是二进制的？因为性能原因。我们将不得不处理无法轻易检查减贫战略变化的不利方面。</p><p id="8b5d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">检查这个锁文件的唯一方法是通过以下命令:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="6ea9" class="mc md it lx b gy me mf l mg mh">bun install -y</span></pre><p id="86ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">Bun</code>像现在一样支持以下装载机:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/cfac11b002f82dcbb78e05971c449cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*xDCHqV-Ho5H0dIU6GkdiZQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从https://github.com/jarred-sumner/bun<a class="ae ng" href="https://github.com/jarred-sumner/bun" rel="noopener ugc nofollow" target="_blank">捕获</a></p></figure><h1 id="b58b" class="mj md it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">建立</h1><p id="b0cd" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated"><code class="fe lu lv lw lx b">bun</code>项目还没有公开。你必须在这里加入他们的不和<a class="ae ng" href="https://bun.sh/discord" rel="noopener ugc nofollow" target="_blank">才能得到邀请。一旦你加入，你需要做的就是导航到他们的<code class="fe lu lv lw lx b">#invites</code>频道。在那里，您可以通过在频道<code class="fe lu lv lw lx b">I want bun</code>上写信来请求邀请。</a></p><p id="fddf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您将获得一个一次性的<code class="fe lu lv lw lx b">jarred-sumner/bun</code>资源库邀请。</p><p id="0199" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要安装<code class="fe lu lv lw lx b">bun</code>，您需要执行以下命令:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="f1ad" class="mc md it lx b gy me mf l mg mh">curl -fsSL https://bun.sh/install | bash</span><span id="442f" class="mc md it lx b gy nh mf l mg mh"><em class="mi"># Manually add the directory to your $HOME/.bashrc (or similar)<br/></em>BUN_INSTALL="/home/jgranja/.bun"<br/>PATH="$BUN_INSTALL/bin:$PATH"</span></pre><p id="d546" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要检查它是否正常工作:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="c322" class="mc md it lx b gy me mf l mg mh"><strong class="lx iu">bun --version</strong></span></pre><p id="cf88" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你会注意到它还没有到达<code class="fe lu lv lw lx b">1.0.0</code>版本。正如我之前提到的，它还没有准备好投入生产。</p><h1 id="b681" class="mj md it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">使用</h1><p id="076f" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">它的用法很简单。如果你熟悉<code class="fe lu lv lw lx b">yarn</code>或<code class="fe lu lv lw lx b">npm</code>的话，结果也差不多。</p><p id="ee8a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要安装软件包:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="e379" class="mc md it lx b gy me mf l mg mh">bun install</span></pre><p id="7161" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就像<code class="fe lu lv lw lx b">yarn</code>一样，它将使用现有的<code class="fe lu lv lw lx b">package.json</code>和锁文件(如果存在的话)。</p><p id="8503" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要添加或删除任何软件包:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="6c56" class="mc md it lx b gy me mf l mg mh">bun remove react<br/>bun add preact</span></pre><p id="3b1e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用<code class="fe lu lv lw lx b">bun</code>作为跑步者:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="67dd" class="mc md it lx b gy me mf l mg mh"><em class="mi"># instead of `npm run clean`<br/></em>bun run clean</span><span id="9fb5" class="mc md it lx b gy nh mf l mg mh"><em class="mi"># if added to the `scripts` in package.json<br/></em>bun clean</span></pre><p id="84ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它确实通过最新的React生态系统的<code class="fe lu lv lw lx b">create</code>命令提供了一些集成。</p><p id="a123" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个Next.js应用程序:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="40f5" class="mc md it lx b gy me mf l mg mh">bun create next ./app<br/>cd app<br/>bun</span></pre><p id="d463" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个Create React应用程序:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="aac7" class="mc md it lx b gy me mf l mg mh">bun create react ./app<br/>cd app<br/>bun</span></pre><p id="3ba2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如何生成捆绑文件？</p><p id="0311" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过运行<code class="fe lu lv lw lx b">bun bun ./path-to.js</code>，我们生成了<code class="fe lu lv lw lx b">node_modules.bun</code>文件。它包含所有导入的依赖项。</p><p id="711b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只要做<code class="fe lu lv lw lx b">./node_modules.bun &gt; build.js</code>就可以检查内容。</p><h1 id="8fdd" class="mj md it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">基准</h1><p id="003c" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">让我们运行几个基准测试来了解它的速度。当然，这些都是近似的测量值，会因计算机而异。因为这是开发人员的工具，所以我将重点放在最常见的开发任务上:</p><ul class=""><li id="4c42" class="ni nj it la b lb lc le lf lh nk ll nl lp nm lt nn no np nq bi translated">启动开发服务器</li><li id="5ed4" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">在文件中进行更改</li><li id="d184" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">安装软件包</li><li id="794c" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">建立生产分布</li><li id="d7ec" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">创建新的web应用程序</li></ul><p id="2692" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mi">作为参考，我的笔记本电脑运行的是16GB的AMD雷禅7，使用的是Ubuntu 20.04。</em></p><p id="4a7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用了一个生成随机<code class="fe lu lv lw lx b">jsx</code>文件的工具。你可以在这里查看<a class="ae ng" href="https://github.com/multiprocessio/react-benchmark-generator" rel="noopener ugc nofollow" target="_blank"/>。我已经生成了一组21个随机的<code class="fe lu lv lw lx b">jsx</code>文件，我已经将它们包含在所有创建的测试项目中。</p><h2 id="7646" class="mc md it bd mk nw nx dn mo ny nz dp ms lh oa ob mu ll oc od mw lp oe of my og bi translated">1.面包大战巴别塔</h2><p id="d366" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这不是一场真正公平的战斗，但它凸显了与传统使用的工具相比，这个工具有多快。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/426f6866bc26453b7a149c59750d0548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aARhOEOkpx_EbOg7boFEmw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">bun vs. babel传输React文件</p></figure><h2 id="c980" class="mc md it bd mk nw nx dn mo ny nz dp ms lh oa ob mu ll oc od mw lp oe of my og bi translated">2.创建一个创建-反应应用程序</h2><p id="e782" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">我们可以看到通过<code class="fe lu lv lw lx b">bun</code>或<code class="fe lu lv lw lx b">webpack + npm</code>创造一个<code class="fe lu lv lw lx b">Create React App</code>的明显区别。使用前者几乎没有任何延迟，只需要<code class="fe lu lv lw lx b">4.4s</code>就能让你一切就绪。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/b6f01c288cded0e66390d056eb68665d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*-Hs-K-JOKXfGvWeWlO29UQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">bun与webpack创建CRA</p></figure><h2 id="5b8b" class="mc md it bd mk nw nx dn mo ny nz dp ms lh oa ob mu ll oc od mw lp oe of my og bi translated">3.创建Next.js应用程序</h2><p id="1965" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">之前的惊人结果并不令人印象深刻。我们习惯了工具痛打<code class="fe lu lv lw lx b">Webpack</code>。让我们来一场公平的比赛。现在让我们比较一下<code class="fe lu lv lw lx b">bun</code>和内部使用<code class="fe lu lv lw lx b">swc</code>的<code class="fe lu lv lw lx b">Next.js</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/3e721dd418a468587e2365f618662325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ytkD4WK9QN19X5OlcGm6Iw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Next.js框架的bun与swc</p></figure><p id="a869" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">两者之间的差异非常明显。尤其是在处理文件更改方面的差异。在我的笔记本电脑上，<code class="fe lu lv lw lx b">bun</code>只需要<code class="fe lu lv lw lx b">10ms</code>，而<code class="fe lu lv lw lx b">SWC</code>则需要<code class="fe lu lv lw lx b">70ms</code>。</p><h2 id="9bd9" class="mc md it bd mk nw nx dn mo ny nz dp ms lh oa ob mu ll oc od mw lp oe of my og bi translated">4.包管理器</h2><p id="d4c1" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">在模块中，安装和操作是<code class="fe lu lv lw lx b">bun</code>的基础。其他工具依靠<code class="fe lu lv lw lx b">npm</code>或<code class="fe lu lv lw lx b">yarn</code>来完成工作。它的性能比<code class="fe lu lv lw lx b">npm</code>快大约<code class="fe lu lv lw lx b">4x — 100x</code>倍。</p><p id="588b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经看到了<code class="fe lu lv lw lx b">2. Create React App</code>步骤中的巨大差异。然而，现在让我们做一个更基本的例子。让我们创建一个具有以下依赖关系的<code class="fe lu lv lw lx b">package.json</code>文件:</p><ul class=""><li id="ab8e" class="ni nj it la b lb lc le lf lh nk ll nl lp nm lt nn no np nq bi translated">日期-fns@2.28.0 — 89.5 kB</li><li id="a6f0" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">jspdf@2.5.1 — 339.1kB</li><li id="3281" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">反应@17.0.2 — 6.9 kB</li></ul><p id="465b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们可以测试它在<code class="fe lu lv lw lx b">first install</code>和<code class="fe lu lv lw lx b">cached installs</code>上的表现。我选择了一个像<code class="fe lu lv lw lx b">jspdf</code>这样的大型库，让差异更加明显。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/deddb3490d162fe2c3b8946f1dcc0bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MFbxKjhDhgg4RLvmvWNYJA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">bun与npm安装包</p></figure><p id="0687" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">时差很明显。使用网络时速度更快，从缓存中解析包时速度更快。</p><h2 id="f8b3" class="mc md it bd mk nw nx dn mo ny nz dp ms lh oa ob mu ll oc od mw lp oe of my og bi translated">5.维特vs. bun</h2><p id="d391" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated"><code class="fe lu lv lw lx b">esbuild</code>才是真正的竞争对手或者小圆面包。对于这个测试，我使用了内部有<code class="fe lu lv lw lx b">esbuild</code>的<code class="fe lu lv lw lx b">Vite</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/11a24d9cfb3cd9dd31d81b7ef9756645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_3lh3Y2sfHbxSDuopRe6cQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">开发服务器上的bun与vite</p></figure><p id="8b8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用了上面相同的代码来生成三个主要竞争对手的包。值得记住的是，不建议将<code class="fe lu lv lw lx b">bun</code>用于生产，因为它仍然缺少一些功能。尽管结果令人印象深刻，但也不能全信。</p><p id="92a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还要注意，在最坏的情况下，最大构建时间是<code class="fe lu lv lw lx b">5 secs</code>。这不是不合理的，这三个工具在这里做了一个可怕的工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/4b7eaeb6f84ee5afc89bf874434b5172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zb2yPsRYnDsDJjAWAjNpTA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">bun、vite和swc在构建产品包时</p></figure><h1 id="d9f6" class="mj md it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">包裹</h1><p id="35ae" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">JavaScript工具看起来从来没有这么好过。即使这个工具还没有准备好投入生产，看到新的竞争对手也是很棒的。Webpack的未来并不明朗，它在JavaScript领域内外都有很多竞争对手。</p><p id="a0d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">bun</code>工具不是万能工具。它有一个特定的用例:构建网站和web应用程序。构建库，bun团队推荐<code class="fe lu lv lw lx b">esbuild</code>甚至<code class="fe lu lv lw lx b">Rollup</code>。</p><p id="d9d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在重点还是不在生产上。它专注于开发以及与现有框架和工具的兼容性。</p><div class="om on gp gr oo op"><a rel="noopener  ugc nofollow" target="_blank" href="/5-awesome-http-headers-web-developers-should-master-332a1a332084"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">Web开发人员应该掌握的5个非常棒的HTTP头</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">以更简洁的方式提高页面安全性和性能</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">better编程. pub</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a rel="noopener  ugc nofollow" target="_blank" href="/6-javascript-dos-and-don-t-e020a4228dfa"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">6 JavaScript应该做和不应该做的事情</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">优化和拥有可读一致代码的技巧</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">better编程. pub</p></div></div><div class="oy l"><div class="pe l pa pb pc oy pd ks op"/></div></div></a></div></div></div>    
</body>
</html>