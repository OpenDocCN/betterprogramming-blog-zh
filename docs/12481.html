<html>
<head>
<title>Scaling Kafka Ingestion Using REST APIs in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rust中使用REST APIs扩展Kafka摄取</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/scaling-kafka-ingestion-using-rest-apis-in-rust-high-throughput-data-ingestion-system-a60cc0c2366?source=collection_archive---------7-----------------------#2022-06-08">https://betterprogramming.pub/scaling-kafka-ingestion-using-rest-apis-in-rust-high-throughput-data-ingestion-system-a60cc0c2366?source=collection_archive---------7-----------------------#2022-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ac55" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">高吞吐量数据摄取系统</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/63aa6ef8fdd3884646302a633c8f56ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YJSj5HQbXD3-bS31ojXmgw.jpeg"/></div></div></figure><p id="d4bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章是关于卡夫卡和鲁斯特的。作为一个想法，我试图建立一个数据摄取服务，接受半结构化的Json有效载荷并将它们发布到Kafka。更具体地说，我想达到以Kafka为缓冲的摄取服务的理论最大值，并尝试调整它来测量性能。</p><p id="42c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将分享如何使用Rust编写REST API，并运行一个简单的HTTP性能调优基准。我还将使用<code class="fe lq lr ls lt b">rdkafka,</code>展示不同的生产者类型，它们可用于获得良好的持久性和高级用例的极高吞吐量。一切都已在Rust中实现。我们将查看Kafka调整前后的数字来测试性能。剧透一下——我可以在一台8C32M服务器上实现大约96K事件/秒的发布速率。我会在这篇文章中分享细节。</p><p id="1d23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有的代码都在我的知识库中。<a class="ae lu" href="https://github.com/shanmukhsista/rust-kafka-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/shanmukhsista/rust-kafka-demo</a></p><p id="1f9f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们开始吧！</p><h1 id="08c6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">应用程序设置</h1><p id="6ee8" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">这个应用程序设置很简单。它通过REST API ( POST Call)接受JSON数据(事件)的有效负载，并将这些<code class="fe lq lr ls lt b">events </code>发布到Kafka主题。出版给卡夫卡是有趣的部分。我们将讨论两种不同场景的发布。</p><ol class=""><li id="bae8" class="ms mt it kw b kx ky la lb ld mu lh mv ll mw lp mx my mz na bi translated">发布以获得某种程度的持久性。在这种情况下，我们确保消息在某种程度上被传递给卡夫卡。</li><li id="02a8" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated">以优化的方式发布以获得更高的性能。在这种情况下，我们将考虑使用一个在发布前缓冲一些事件的生成器，并在不阻塞任何响应的情况下优化最佳性能。</li></ol><p id="8bab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于性能至关重要，我们将编写一个基准测试，并使用一个简单的HTTP测试工具(<code class="fe lq lr ls lt b">plow</code>)对其进行测量。</p><p id="52b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">顺便提一下，在rust中编写API时使用Kafka Producer的目的也是为了突出向RUST中的处理程序传递一些状态/服务的能力。在编写真实世界的应用程序时，这是很常见的。它甚至可能是一个数据库池服务或自定义资源管理器。理解这一点很重要，因为Rust中的编程范式与Java、C# …</p><p id="b216" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这个演示，我们将使用Actix Framework(Web)来编写API和发布事件。让我们开始吧。</p><h1 id="8860" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">创建新的二进制应用程序</h1><p id="2b38" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">让我们从创建一个新的应用程序开始。</p><pre class="kj kk kl km gt ng lt nh ni aw nj bi"><span id="563c" class="nk lw it lt b gy nl nm l nn no">cargo new rust-rdkafka-demo</span></pre><p id="0e31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在您的<code class="fe lq lr ls lt b">Cargo.toml</code>中添加以下依赖项。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c3f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们添加了<code class="fe lq lr ls lt b">serde</code>依赖来解析请求JSON，并在发布数据之前将其反序列化为Rust结构。</p><blockquote class="nr ns nt"><p id="2e4c" class="ku kv nu kw b kx ky ju kz la lb jx lc nv le lf lg nw li lj lk nx lm ln lo lp im bi translated">这个应用程序的另一个先决条件是<strong class="kw iu">在您的本地机器</strong>上安装kafka，或者准备好远程代理URL来编写服务。我们将从应用程序内部连接到这个kafka集群。</p></blockquote><h1 id="161d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">阻塞生成器(等待响应)</h1><p id="8e02" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">在第一种情况下，我们将与Kafka生产者合作，确保消息在返回响应之前被发送到Kafka。这意味着会有延迟和性能问题，因为我们在等待一些网络操作，以及Kafka对消息的确认。</p><h2 id="a03e" class="nk lw it bd lx ny nz dn mb oa ob dp mf ld oc od mh lh oe of mj ll og oh ml oi bi translated">初始化生成器</h2><p id="c5c4" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">我们通过设置一些默认的配置变量来初始化生产者，并在这个函数中返回生产者的所有权。</p><p id="6bf2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个生产者是一个<code class="fe lq lr ls lt b">FutureProducer</code>实例，可以跨线程共享。因为克隆对于这个生产者来说是廉价的，所以我们可以为每个请求发布一个事件，并为高吞吐量进行伸缩。这个制作人也为每一个出版的事件制作一个未来。因此，我们必须执行一个<code class="fe lq lr ls lt b">await</code>来发布并从Kafka获得结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="67d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，我们使用最低要求的配置创建生成器。</p><h2 id="9e66" class="nk lw it bd lx ny nz dn mb oa ob dp mf ld oc od mh lh oe of mj ll og oh ml oi bi translated">定义有效负载结构</h2><p id="d12d" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">现在，让我们把我们的有效载荷数据定义为一个锈<code class="fe lq lr ls lt b">struct</code>。出于本演示的目的，有效负载是一个带有相关名称的事件对象，由一个<code class="fe lq lr ls lt b">data</code>部分组成，它可以保存发送到服务器的任意键-值对。这只是作为键值对发送的半结构化JSON数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="fff6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">确保添加了派生属性，以便在JSON中序列化和反序列化有效负载。</p><p id="fa23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经有了基本的应用程序设置，我们还需要编写最后一部分来处理请求。</p><h2 id="d802" class="nk lw it bd lx ny nz dn mb oa ob dp mf ld oc od mh lh oe of mj ll og oh ml oi bi translated">定义API处理程序</h2><p id="5d08" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">用于执行我们的API逻辑的API处理程序如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b88e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">collect_events</code>将在每次对根<code class="fe lq lr ls lt b">/</code>端点进行POST调用时被调用。在这个方法中，我们还将Kafka Producer作为数据依赖项。我们可以用它来直接发布事件并返回响应。</p><p id="fefc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，Kafka制作者默认是一个<code class="fe lq lr ls lt b">FutureProducer</code>。除非我们<code class="fe lq lr ls lt b">await</code>上了生产者(第17行)，否则不会有消息发布给卡夫卡。对于初始版本，让我们执行一个<code class="fe lq lr ls lt b">await</code>操作并测量一些请求延迟。我们很快就会看到另一种方法。</p><p id="31ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个函数中，我们为这个事件生成一个新的event_id。并将这一事件送回卡夫卡。</p><p id="d6d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还要注意，我们再次进行反序列化和序列化，中间没有应用任何逻辑。在现实世界的应用中，也可能会有一些丰富的内容。因此，我们需要这一步。更好的选择是使用<code class="fe lq lr ls lt b">Protocol Buffers</code>而不是JSON序列化/反序列化来降低序列化成本并更好地标准化有效负载。</p><p id="f59f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦发布了事件，我们返回一个带有<strong class="kw iu"> event_id </strong>的文本响应。</p><h2 id="32f5" class="nk lw it bd lx ny nz dn mb oa ob dp mf ld oc od mh lh oe of mj ll og oh ml oi bi translated">主要功能</h2><p id="4659" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">完成我们的应用程序的最后一步是集成一切并更新我们的主要功能。参考下面的代码来检查一下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="92fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在main中，我们首先初始化我们的kafka生成器。这个生产者将被所有在<code class="fe lq lr ls lt b">actix-web</code>中创建的线程共享。Main函数获得该数据的所有权，然后负责该变量的生存期。</p><p id="f240" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们使用Actix-Web的服务器工厂来定义服务器及其路由。这里需要注意的一点是，Actix只定义了布局和初始化。在收到客户端的请求之前，我们不会初始化并开始使用Kafka producer。输入到<code class="fe lq lr ls lt b">HttpServer.new</code>的λ只是一个工厂。我们的服务器会为收到的每个请求创建一个新的实例。</p><p id="da34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在处理路由时，我们在处理程序中获得了有效负载的<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/understanding-rust-ownership-model-by-example-5d586ec5e8e4">所有权。这个处理程序还获得了共享的<code class="fe lq lr ls lt b">kafka_producer</code>引用以及有效负载。这就是运行我们的应用程序所需的全部内容。</a></p><h2 id="3a22" class="nk lw it bd lx ny nz dn mb oa ob dp mf ld oc od mh lh oe of mj ll og oh ml oi bi translated">运行和测试应用程序</h2><p id="c261" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">要运行应用程序，请在项目的根目录下执行下面的命令。</p><pre class="kj kk kl km gt ng lt nh ni aw nj bi"><span id="5f12" class="nk lw it lt b gy nl nm l nn no">cargo run</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="08f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">触发一个POST请求来测试向我们的服务发布事件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c8f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果一切正常，您应该期望响应中有一个新的事件id作为纯文本输出。</p><pre class="kj kk kl km gt ng lt nh ni aw nj bi"><span id="a898" class="nk lw it lt b gy nl nm l nn no">9502ea0e-9856-4626-b621-2c6fd0d35cfe</span></pre><h1 id="4480" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">无阻塞方法</h1><p id="537b" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">上面显示的方法在向Kafka发布事件后等待异步未来。即使这是一个异步操作，也可能会有一些等待，不管网络有多好。</p><p id="6f44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将研究另一种方法来进一步优化它。一个不需要等待期货的非阻塞生产者。</p><p id="f959" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将利用低级的<code class="fe lq lr ls lt b">ThreadedProducer</code>类来发送事件。在内部，这个类有自己的专用线程来缓冲和发布事件。在这个实现中，我们将用这个类创建一个生产者来发送事件。这应该会给我们带来显著更高的吞吐量，而无需对代码做太多的修改。下面是代码的变化。</p><h2 id="2761" class="nk lw it bd lx ny nz dn mb oa ob dp mf ld oc od mh lh oe of mj ll og oh ml oi bi translated">初始化生成器</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="5cd1" class="nk lw it bd lx ny nz dn mb oa ob dp mf ld oc od mh lh oe of mj ll og oh ml oi bi translated">API处理程序</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="f482" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在这里可以看到，我们没有等待Kafka发送操作完成。我们只是发布并立即回复。有互斥体来保证线程安全，以共享生产者，而没有任何副作用。</p><h2 id="8b8f" class="nk lw it bd lx ny nz dn mb oa ob dp mf ld oc od mh lh oe of mj ll og oh ml oi bi translated">主要功能</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="13df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有了这两种方法，让我们看看一些性能数字。</p><h1 id="76bc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">性能试验</h1><p id="acc4" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">为了测量性能，我们将在GCP使用一组远程机器来执行测试。这是一个从另一台远程机器上执行的简单HTTP测试。创建了一个全新的VM来在一个<strong class="kw iu">实例上托管我们的应用程序。</strong>我们将比较两个生产商，看看延迟和带宽的分布。</p><h2 id="e50e" class="nk lw it bd lx ny nz dn mb oa ob dp mf ld oc od mh lh oe of mj ll og oh ml oi bi translated">设置</h2><p id="b8e3" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated"><em class="nu"> API服务器:8核32 GB内存——GCP实例</em></p><p id="7283" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nu"> Kafka —同一个本地网络中的通用Kafka集群。</em></p><p id="671c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nu">负载测试从同一网络内的</em> <strong class="kw iu"> <em class="nu">单独的机器上运行。</em>T12】</strong></p><h2 id="655d" class="nk lw it bd lx ny nz dn mb oa ob dp mf ld oc od mh lh oe of mj ll og oh ml oi bi translated">期货生产商(等待操作)</h2><p id="9776" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">对于这两个生成器，我们将从<code class="fe lq lr ls lt b"><a class="ae lu" href="https://github.com/six-ddc/plow" rel="noopener ugc nofollow" target="_blank">Plow</a></code>开始，在1分钟的时间内发出50个并发请求。下面是相同的截图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/05786b33c117cf50407134397850c21d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q_tRMsahLY8er1fmbLL8jg.png"/></div></div></figure><p id="61bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这个设置，我注意到在以高吞吐量接收事件之前有一个初始延迟。吞吐量在几秒钟内从4000 /秒扩展到45k。这就是最初大约6毫秒的延迟。考虑到我们正在向卡夫卡发布每一张唱片并等待回复，这一点都不坏。现在让我们看看另一种方法。</p><h1 id="bf96" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">非阻塞方法(无等待)</h1><p id="1f61" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">现在，让我们来看看一种可以显著提高服务性能的方法。这可能不是最准确的方法，但它确实显著提高了性能。我仍在研究一些方法，并了解最佳方法的底层库。</p><p id="4485" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，我们使用这种方法的目标是为我们的摄取服务提供高吞吐量。在这个案例中，我们使用了一个不需要我们等待未来的制作人。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/d956d33b1041c4fd52be5952c404e326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zt6NRYTdo3DMg3sNNw0Szg.png"/></div></div></figure><blockquote class="nr ns nt"><p id="606a" class="ku kv nu kw b kx ky ju kz la lb jx lc nv le lf lg nw li lj lk nx lm ln lo lp im bi translated">该服务被Kafka接收的事件数达到了每秒95，000个。延迟也没有太多变化。尽管这只是一个基本的设置，但我还是对这一表现印象深刻。</p></blockquote><h1 id="a631" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摘要</h1><p id="417b" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">总之，这是一个非常简单的实现。我对我看到的数字印象深刻。很快，我将尝试对数据有效载荷执行一些昂贵的操作，并看看这些数字是如何受到影响的。</p><p id="bdf5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但就个人而言，如果我要设计一个高吞吐量的分析数据收集服务，我会在其他考虑和因素中选择Rust。不仅因为性能，还因为能效:)</p></div></div>    
</body>
</html>