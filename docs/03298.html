<html>
<head>
<title>Asynchronous JavaScript: An Introduction to JavaScript Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步JavaScript:JavaScript承诺介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/asynchronous-javascript-introduction-to-javascript-promises-3142eeea9b38?source=collection_archive---------8-----------------------#2020-02-02">https://betterprogramming.pub/asynchronous-javascript-introduction-to-javascript-promises-3142eeea9b38?source=collection_archive---------8-----------------------#2020-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6b8e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">漂亮清晰地处理异步代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/155a02a6121d3e3cf432998fe8ea4279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mhhzAiiFX0lxMJ0U.png"/></div></div></figure><p id="941a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着语言的成熟，异步处理是JavaScript获得的最重要的能力之一。</p><p id="f157" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript的异步功能支持更复杂、更灵敏的用户界面。它们还使得实现基于SOAP和REST等标准的分布式web应用程序架构成为可能。</p><p id="9fc2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript承诺是目前内置于语言本身的最强大、最灵活的异步技术。这篇文章将解释它们是如何工作的，并通过一些实际例子让你写下自己的承诺。</p><p id="d924" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">承诺有很多好处:</p><ul class=""><li id="5bfc" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">一个承诺可以被多次调用。</li><li id="ddf7" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">承诺可以连在一起。</li><li id="6b34" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">承诺可以包括错误拒绝事件。</li><li id="2e3f" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">承诺链中的错误只需处理一次(错误传播)。</li><li id="51cf" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">承诺可以用来包装旧式的回调功能。</li><li id="9ed9" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">承诺总是在当前执行堆栈为空后执行。</li></ul><p id="2ba6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您刚刚开始使用JavaScript的异步功能，前面的几点可能对您没有太大的意义。幸运的是，本系列的前两篇文章介绍了基础知识，为您理解承诺的工作原理打下了坚实的基础:</p><ul class=""><li id="fcb8" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><a class="ae me" href="https://medium.com/swlh/asynchronous-javascript-understanding-callbacks-8c288c555b23" rel="noopener">异步JavaScript:理解回调</a></li><li id="b793" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><a class="ae me" href="https://medium.com/javascript-in-plain-english/asynchronous-javascript-organizing-callbacks-for-readability-and-reusability-32ad912f2faf" rel="noopener">异步JavaScript:为了可读性和可重用性组织回调</a></li></ul><p id="d204" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些帖子解释了JavaScript事件循环、回调队列和执行堆栈。它们还向您展示了如何创建实用的回调并将它们组织成可读的代码。</p><p id="9e04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您已经对这些主题有了很好的理解，并且想要了解JavaScript Promises，那么您可以深入研究。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="90b4" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">先决条件</h1><p id="dfa0" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">为了完成这篇文章中的任务，你需要:</p><ul class=""><li id="4ae2" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><a class="ae me" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js和npm</a>(node . js安装也会安装NPM。)</li></ul><p id="1f39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还应该了解JavaScript的核心元素，包括对象构造函数和匿名函数。如果您不熟悉JavaScript事件模型，请阅读本系列的第一篇文章。</p><p id="7c5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">GitHub上有这篇文章的配套资源库。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="05c4" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">设置项目</h1><p id="60d2" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">如果您已经完成了来自<a class="ae me" href="https://medium.com/javascript-in-plain-english/asynchronous-javascript-organizing-callbacks-for-readability-and-reusability-32ad912f2faf" rel="noopener">异步Javascript:为可读性和可重用性组织回调</a>帖子的项目，那么您可以继续为该帖子编写代码。如果你熟悉事件循环机制或者想从头开始，可以从GitHub获取代码。</p><p id="9a41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过在要创建项目根目录的目录中执行以下命令行指令来克隆项目:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="d596" class="no mn it nk b gy np nq l nr ns">git clone <a class="ae me" href="https://github.com/maciejtreder/asynchronous-javascript.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/asynchronous-javascript.git</a><br/>cd asynchronous-javascript<br/>git checkout step3<br/>npm install<br/>mkdir promises<br/>cd promises</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="20a6" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">理解JavaScript承诺</h1><p id="7806" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">JavaScript <code class="fe nt nu nv nk b"><a class="ae me" href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects" rel="noopener ugc nofollow" target="_blank">Promise</a></code>对象是在2015年第六版JavaScript中引入的，最初称为ECMAScript 6 (ES6)，后来更名为ECMAScript 2015 (ES2015)。你会看到这两个名字可以互换使用。</p><p id="6445" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nt nu nv nk b">Promise</code>对象是一个代理，代表延迟操作的最终完成或失败，它几乎总是(但不要求)异步的。这种典型的异步操作是对远程API的REST调用或从本地文件系统读取文件。</p><p id="1186" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">承诺可以处理异步活动的结果，并决定是<em class="nw">解决</em>还是<em class="nw">拒绝</em>承诺。然后相应地设置返回的承诺对象的状态。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="f4e7" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">承诺术语</h1><p id="d74f" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">承诺为<em class="nw">履行、拒绝、</em>或<em class="nw">待定。</em>承诺的状态设置为<em class="nw">履行</em>表示执行成功。承诺的状态被设置为<em class="nw">拒绝</em>以指示活动失败。否则承诺就是<em class="nw">待定</em>:等待一个活动的结果。</p><p id="3fe4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果一个承诺被履行或者被拒绝，它就是确定的。</p><p id="08a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果一个承诺被解决或锁定在以匹配另一个承诺的状态，则该承诺被<em class="nw">解决</em>。因为一个承诺可能被锁定到另一个承诺的状态，而另一个承诺本身可能是待定的，所以一个已解决的承诺可能是待定的、履行的或拒绝的。</p><p id="d601" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果一个承诺没有兑现，它就是没有兑现。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="09ce" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">Promise构造函数语法</h1><p id="29bc" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">创建<code class="fe nt nu nv nk b">Promise</code>对象的通用语法是:<code class="fe nt nu nv nk b">new Promise(<em class="nw">executor</em>)</code>。</p><p id="5039" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nt nu nv nk b">executor</code>是一个带两个参数的函数，<code class="fe nt nu nv nk b">resolve</code>和<code class="fe nt nu nv nk b">reject</code>；两者都是可选的。它们是履行或拒绝承诺的函数。</p><p id="c317" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">executor函数通常会启动一些异步工作，并根据异步活动的结果调用<code class="fe nt nu nv nk b">resolve</code>或<code class="fe nt nu nv nk b">reject</code>函数。</p><p id="6d19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">包括executor函数的结构，<code class="fe nt nu nv nk b">Promise</code>的构造函数包括:</p><ul class=""><li id="87d4" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><code class="fe nt nu nv nk b">const</code>关键字、名称、<code class="fe nt nu nv nk b">new</code>关键字、<code class="fe nt nu nv nk b">Promise</code>类型。</li><li id="73f9" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">带有两个可选函数参数<code class="fe nt nu nv nk b">resolve</code>和<code class="fe nt nu nv nk b">reject</code>的executor匿名函数。</li><li id="85fb" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">语句组成了executor函数的主体，其中包括两个方法:<code class="fe nt nu nv nk b">resolve(value)</code>和<code class="fe nt nu nv nk b">reject(reason)</code>。</li></ul><p id="cb47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个简单的例子是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b68e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用<code class="fe nt nu nv nk b">if … else</code>测试一个函数的返回值只是确定一个承诺是被履行还是被拒绝的众多方法之一。</p><p id="5620" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有可能有一个刚刚解决的承诺，在这种情况下，声明可以像这样缩短:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="6cd7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用由<code class="fe nt nu nv nk b">someFunction()</code>返回的值来完成<code class="fe nt nu nv nk b">mySimplePromise</code>——假设<code class="fe nt nu nv nk b">someFunction()</code>返回一个值，而不是爆炸或运行，直到宇宙热寂(或直到有人杀死该进程)。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="9c56" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">调用承诺对象</h1><p id="8b2f" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">要在代码中实现承诺，您需要知道如何使用它们以及声明它们。通过调用承诺<a class="ae me" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes" rel="noopener ugc nofollow" target="_blank">原型</a>的<code class="fe nt nu nv nk b"><a class="ae me" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" rel="noopener ugc nofollow" target="_blank">then</a></code>方法来使用承诺。</p><p id="7a66" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">被拒绝的承诺可以用两种方式处理:用<code class="fe nt nu nv nk b">then</code>方法的参数或用<code class="fe nt nu nv nk b">catch</code>方法。</p><p id="738a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">附加的原型方法支持更高级的承诺使用，比如评估一组承诺。这些功能将在本系列的下一篇文章中讨论。</p><p id="72d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nt nu nv nk b">.then</code>方法有两个参数，都是可选的。第一个指定了承诺实现时要调用的函数，第二个指定了承诺被拒绝时要做什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4693" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实际上，一个简单的例子如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4f6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在大多数情况下，您会看到省略第二个参数并将拒绝处理放在<code class="fe nt nu nv nk b">.catch</code>方法中的实现，如下所示。(稍后将详细介绍这一点。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="2d89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在实现承诺的代码中，异步函数返回承诺也很常见，许多库函数都是这样做的。下面是一个简单的异步函数，它返回一个承诺和使用实现的承诺的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4f63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，<code class="fe nt nu nv nk b">reject</code>方法的返回值通常是一个“原因”，可以是字符串，也可以是更复杂的类型。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="68e1" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">理解承诺中的异步行为</h1><p id="be11" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">当一个承诺被实现或拒绝时，一个处理函数被放在事件循环中，供当前线程异步执行。这类似于本系列第二部分中描述的异步回调，<a class="ae me" href="https://medium.com/swlh/asynchronous-javascript-understanding-callbacks-8c288c555b23" rel="noopener">异步JavaScript:理解回调</a>。</p><p id="0db5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由<code class="fe nt nu nv nk b">.then</code>方法返回的<code class="fe nt nu nv nk b">Promise</code>对象要么被满足，要么被拒绝，这取决于<code class="fe nt nu nv nk b">onFulfilled</code>或<code class="fe nt nu nv nk b">onRejected</code>处理程序方法的返回值。返回值有一组特定的规则<a class="ae me" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then#Return_value" rel="noopener ugc nofollow" target="_blank">可能是:</a></p><ul class=""><li id="4501" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">用<code class="fe nt nu nv nk b">onFulfilled</code>处理函数的值解决。</li><li id="dd0b" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">因<code class="fe nt nu nv nk b">onRejected</code>处理函数抛出的错误或错误而被拒绝。</li><li id="f868" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">履行了与履行了的承诺相关的价值。</li><li id="1b30" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">拒绝，原因与被拒绝的关联承诺相关联。</li><li id="3e21" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">将使用关联承诺的值结算的待定承诺对象。</li><li id="f355" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">未定义。</li></ul><p id="a389" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了更好地理解promises是如何实现异步处理的，看看它在代码中是如何实现的会很有帮助。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="fc51" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">理解何时确定承诺状态</h1><p id="498d" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">承诺的状态由executor函数的结果决定。它开始时是未决的，随着执行程序功能的进展，它变成已解决的<em class="nw"> </em>或被拒绝的<em class="nw"> </em>。当承诺状态被解析时，承诺也将有一个值，即<code class="fe nt nu nv nk b">resolve</code>方法的返回值。</p><p id="090f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为Promise的状态是由executor函数的结果决定的，所以它将保持<code class="fe nt nu nv nk b">pending</code>状态，直到任何异步代码被执行。</p><p id="bf5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据当前调用堆栈中的代码在处理移动到回调队列中的<code class="fe nt nu nv nk b">resolve</code>或<code class="fe nt nu nv nk b">reject</code>方法代码之前执行的时间，或者根据异步函数返回结果的时间，可能需要一些时间来确定承诺的状态。承诺可能依赖于其他承诺，这也可能导致延迟。</p><p id="69ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在代码中使用承诺的状态。这些技术将在本系列的下一篇文章中介绍，它将解释如何使用像<code class="fe nt nu nv nk b">.all</code>和<code class="fe nt nu nv nk b">.race</code>这样的承诺方法来评估一组承诺。</p><p id="12bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，重要的是要知道你可以通过下面的代码看到一个承诺的当前状态，其中<code class="fe nt nu nv nk b">promise</code>是一个特定承诺名称的通用占位符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="1fde" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的例子将向您展示在executor函数只包含同步代码的承诺和executor函数调用异步代码的承诺之间，承诺状态的计时是如何不同的。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="96ec" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">使用带有同步功能的承诺</h1><p id="fbb2" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">在<code class="fe nt nu nv nk b">asynchronous-javascript</code>项目的<em class="nw"> promises </em>目录下，新建一个名为<em class="nw"> promises </em>的目录，并在promises目录下新建一个名为<code class="fe nt nu nv nk b">blocking.js</code>的文件。</p><p id="457d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe nt nu nv nk b">blocking.js</code>中插入以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="3dee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过执行以下命令行指令来运行此代码:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="176a" class="no mn it nk b gy np nq l nr ns">node blocking.js</span></pre><p id="4281" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您应该会看到以下输出:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="0910" class="no mn it nk b gy np nq l nr ns">Inside the promise1 executor code<br/>Promise { 'Value from the promise1 resolve method' }<br/>After the promise1 constructor<br/>After promise1.then is called and fulfilled<br/>Value from the promise1 resolve method</span></pre><p id="9e88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果仔细观察，您会发现只有文本的第一行立即显示，控制台输出的其余部分在两秒钟的延迟后才显示。这包括显示在“promise1构造函数之后”的消息。</p><p id="54d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还会看到来自<code class="fe nt nu nv nk b">resolve</code>方法的消息出现在消息之后的<em class="nw">，表明承诺已经被“调用并履行”，与它们在代码中的顺序相反。</em></p><p id="37b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么？</p><p id="5103" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里发生了三件事:</p><ol class=""><li id="1b15" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp nz lw lx ly bi translated">Promise executor函数与其他JavaScript代码<strong class="kw iu">一样<em class="nw">同步</em>。</strong></li><li id="b20d" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nz lw lx ly bi translated">在设置承诺状态(已解决，已拒绝)之前，立即执行承诺构造函数。</li><li id="c61b" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nz lw lx ly bi translated">在当前调用堆栈为空之前，不会执行promise方法。</li></ol><p id="bb32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事情的顺序是这样的:</p><ol class=""><li id="59ef" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp nz lw lx ly bi translated"><code class="fe nt nu nv nk b">promise1</code>执行器被放入堆栈并开始执行。</li><li id="c02e" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nz lw lx ly bi translated">将带有参数“在promise1构造函数内部”的<code class="fe nt nu nv nk b">console.log</code>函数放入堆栈并执行；将显示该消息。</li><li id="9de6" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nz lw lx ly bi translated">同步的<code class="fe nt nu nv nk b">wait</code>调用导致<code class="fe nt nu nv nk b">wait</code>函数被加载到堆栈上并执行，在处理中引入了一个可察觉的延迟。</li><li id="aaf7" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nz lw lx ly bi translated">执行<code class="fe nt nu nv nk b">promise1</code> <code class="fe nt nu nv nk b">resolve</code>方法。</li><li id="040f" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nz lw lx ly bi translated"><code class="fe nt nu nv nk b">promise1</code>构造器执行器函数执行完毕，并从堆栈中移除。此时，<code class="fe nt nu nv nk b">promise1</code>状态是<code class="fe nt nu nv nk b">resolved</code>，而<code class="fe nt nu nv nk b">promise1</code>值是来自<code class="fe nt nu nv nk b">resolve</code>方法的返回值。</li><li id="a645" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nz lw lx ly bi translated">将带有参数“在promise1构造函数之后”的<code class="fe nt nu nv nk b">console.log</code>函数放入堆栈并执行；将显示该消息。</li><li id="3a71" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nz lw lx ly bi translated">带参数的<code class="fe nt nu nv nk b">console.log</code>函数“promise1被调用并履行后”消息被放入堆栈并被执行；将显示该消息。</li><li id="7418" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nz lw lx ly bi translated">此时，当前执行堆栈是空的，因此处理移到事件队列。</li><li id="b7e1" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nz lw lx ly bi translated"><code class="fe nt nu nv nk b">resolve</code>方法的值，返回字符串“来自promise1 resolve方法的值”。</li><li id="6374" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nz lw lx ly bi translated"><code class="fe nt nu nv nk b">.then</code>方法使用<code class="fe nt nu nv nk b">promise1</code>状态值来确定是否执行<code class="fe nt nu nv nk b">onResolved</code>功能。(由于没有提供<code class="fe nt nu nv nk b">onRejected</code>参数函数，如果承诺被解决，唯一的选择是调用<code class="fe nt nu nv nk b">onResolved</code>函数。)</li><li id="bab0" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nz lw lx ly bi translated"><code class="fe nt nu nv nk b">.then</code>方法使用<code class="fe nt nu nv nk b">resolve</code>方法的返回值执行<code class="fe nt nu nv nk b">onResolve</code>参数功能。在这种情况下，<code class="fe nt nu nv nk b">onResolve</code>是一个匿名函数，它显示<code class="fe nt nu nv nk b">promise1</code>构造函数的<code class="fe nt nu nv nk b">resolve</code>方法的返回值，即字符串“来自promise1 resolve方法的值”。</li><li id="7387" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nz lw lx ly bi translated">堆栈和回调队列为空，处理完成。</li></ol><p id="731a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当与同步函数一起使用时，承诺可以阻止执行，直到函数完成执行，但承诺本身仍将异步实现。</p><p id="2e10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请参见下图所示的事件顺序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/170dffd07b9b88ee98a6dbce4b887640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0M9wOVp66s6a40uk.jpg"/></div></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="d9ff" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">对异步函数使用承诺</h1><p id="f0d2" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">用承诺包装的异步操作呢？尝试类似的构造，但是使用异步<code class="fe nt nu nv nk b">setTimeout</code>函数，而不是同步<code class="fe nt nu nv nk b">wait</code>函数调用。</p><p id="602d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe nt nu nv nk b">non-blocking.js</code>文件中插入以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="f56f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用以下命令行指令运行程序:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="2941" class="no mn it nk b gy np nq l nr ns">node non-blocking.js</span></pre><p id="b7a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您应该会看到类似的输出，但是只有最后一行被延迟了。您还会看到两条线表示<code class="fe nt nu nv nk b">promise1a</code>的当前状态是<code class="fe nt nu nv nk b">pending</code>。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="e1a5" class="no mn it nk b gy np nq l nr ns">Inside the promise1a executor code<br/>After the promise1a constructor<br/>Promise { &lt;pending&gt; }<br/>After promise1a is called<br/>Promise { &lt;pending&gt; }<br/>Value from promise1a resolve method</span></pre><p id="471f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种差异是由什么造成的？</p><p id="e33c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您会记得<code class="fe nt nu nv nk b">setTimeout()</code>是一个<em class="nw">异步</em>函数。(详见本系列<a class="ae me" href="https://www.twilio.com/blog/asynchronous-javascript-understanding-callbacks" rel="noopener ugc nofollow" target="_blank">第一部分</a>。)</p><p id="c83f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当<code class="fe nt nu nv nk b">promise1a</code> executor函数在堆栈上被处理时，异步的<code class="fe nt nu nv nk b">setTimeout()</code>函数调用和<code class="fe nt nu nv nk b">resolve</code>函数调用一起被放入回调队列，以便在堆栈为空时执行。</p><p id="732f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于<code class="fe nt nu nv nk b">setTimeout()</code>函数对处理中的延迟负责，所以延迟直到堆栈上剩余的可执行指令被执行后才被调用。程序中的其他语句可以毫不延迟地执行。</p><p id="5611" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为<code class="fe nt nu nv nk b">promise1a</code>的<code class="fe nt nu nv nk b">resolve</code>方法是<code class="fe nt nu nv nk b">setTimeout()</code>函数的第一个参数，所以直到堆栈为空并且处理移动到回调队列时才会执行。</p><p id="ade1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为两秒钟的时间间隔被指定为<code class="fe nt nu nv nk b">setTimeout()</code>的第二个参数，所以<code class="fe nt nu nv nk b">resolve</code>方法的值不会返回给<code class="fe nt nu nv nk b">.then</code>方法，直到时间间隔结束。</p><p id="fa7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当处理移动到回调队列并且两秒钟的间隔已经过去时，<code class="fe nt nu nv nk b">resolve</code>方法可以返回它的值；<code class="fe nt nu nv nk b">promise1a</code>的状态变为<code class="fe nt nu nv nk b">fulfilled</code>并且<code class="fe nt nu nv nk b">.then</code>方法可以评估是否应该调用<code class="fe nt nu nv nk b">onResolved</code>方法。此时，可以显示<code class="fe nt nu nv nk b">resolve</code>方法的返回值。</p><p id="7617" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还可以看到，当<code class="fe nt nu nv nk b">promise1a</code>的返回值变为<code class="fe nt nu nv nk b">Value from promise1a resolve method</code>时，承诺状态如何从<code class="fe nt nu nv nk b">&lt;pending&gt;</code>变为<em class="nw">已解决</em>状态。请随意试验这段代码，以了解更多关于承诺执行时间的信息。</p><p id="a902" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下图说明了这种行为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/37499b64b7fa6cc231a90b3624b9edb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EzkWfCm8u29-R54I.jpg"/></div></div></figure><p id="2b17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您还没有开始编写代码，并且希望使用GitHub上的配套资源库赶上这一步，请在您希望创建项目目录的目录中执行以下命令:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="7726" class="no mn it nk b gy np nq l nr ns">git clone <a class="ae me" href="https://github.com/maciejtreder/asynchronous-javascript.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/asynchronous-javascript.git</a><br/>cd asynchronous-javascript<br/>git checkout step4<br/>npm install<br/>mkdir promises<br/>cd promises</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="5787" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">JavaScript入门承诺</h1><p id="9ad8" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">对于第一次使用的人来说，前面所有关于如何创造和消费承诺的信息可能看起来有些吓人。</p><p id="27df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，与许多编程语言特性一样，您可以从基础开始，充分利用它们，随着经验的增长和代码变得更加复杂，进入更高级的场景。</p><p id="6f4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以从用<code class="fe nt nu nv nk b">resolve</code>和<code class="fe nt nu nv nk b">reject</code>方法实现一个基本承诺开始，并在代码中使用它。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="e307" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">解决和拒绝承诺</h1><p id="9120" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">在大多数实际应用程序中，您将使用调用一些异步代码的承诺，并根据函数调用的结果来解决或拒绝。你会想以某种方式利用承诺的结果，这取决于承诺是被解决还是被拒绝。</p><p id="d5f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下面的示例中，您将创建一个异步产生结果的函数。然后，您将创建另一个函数，该函数使用已履行(已解决或已拒绝)来根据承诺的状态采取行动。</p><p id="bc2a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在项目的<em class="nw">承诺</em>目录下创建新文件<code class="fe nt nu nv nk b">practical.js</code>，并插入以下JavaScript代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="73df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用以下命令行指令运行代码:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="61c1" class="no mn it nk b gy np nq l nr ns">node practical.js</span></pre><p id="e188" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据随机数生成器的结果，您应该会看到类似于下面的输出:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="9612" class="no mn it nk b gy np nq l nr ns">That's a bad pour. Glass 1 failed! Try again.<br/>That's a good pour! Glass 2 is 97% full. Drink up.<br/>That's a bad pour. Glass 3 failed! Try again.<br/>That's a bad pour. Glass 4 failed! Try again.<br/>That's a good pour! Glass 5 is 78% full. Drink up.<br/>That's a good pour! Glass 6 is 76% full. Drink up.<br/>That's a bad pour. Glass 7 failed! Try again.<br/>That's a bad pour. Glass 8 failed! Try again.<br/>That's a bad pour. Glass 9 failed! Try again.<br/>That's a good pour! Glass 10 is 93% full. Drink up.</span></pre><p id="9ddc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe nt nu nv nk b">practical.js</code>中，您可以看到许多在真实世界代码中有用的技术。异步<code class="fe nt nu nv nk b">fillGlass</code>函数返回一个承诺。(它是异步的，因为它包含了<code class="fe nt nu nv nk b">setTimeout</code>函数，这是异步的。)</p><p id="dd11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，向返回承诺的函数传递参数没有问题。</p><p id="9a5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将参数传递给<code class="fe nt nu nv nk b">.then</code>方法的<code class="fe nt nu nv nk b">onResolved</code>和<code class="fe nt nu nv nk b">onRejected</code>方法也没有问题。您还可以迭代调用返回承诺的函数，并使用承诺状态(已解决或已拒绝)对与承诺相关联的对象执行进一步的操作。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="b1f9" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">捕捉承诺拒绝和例外</h1><p id="5c2a" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">在<em class="nw"> </em> <code class="fe nt nu nv nk b">pratical.js</code>中，被拒绝的承诺通过承诺对象的<code class="fe nt nu nv nk b">.then</code>方法的<code class="fe nt nu nv nk b">onRejected</code>参数处理:<code class="fe nt nu nv nk b">fillGlass(pourtime).then</code>在承诺被拒绝时调用<code class="fe nt nu nv nk b">returnGlass</code>。</p><p id="032a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你只处理一个承诺时，这很好，但是在你想要处理一系列承诺的时候呢？</p><p id="254b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这时候Promise <code class="fe nt nu nv nk b">.catch</code>方法就有用了。和<code class="fe nt nu nv nk b">.then</code>一样，它返回一个承诺。由<code class="fe nt nu nv nk b">.then</code>方法产生的一组解析承诺和由<code class="fe nt nu nv nk b">.catch</code>方法产生的承诺可以在程序逻辑中一起评估。</p><p id="a1d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本系列的下一篇文章将讨论处理由<code class="fe nt nu nv nk b">.catch</code>返回的承诺的技术，以及处理承诺集合的方法。</p><p id="709a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下示例将向您展示如何使用<code class="fe nt nu nv nk b">.catch</code>来代替<code class="fe nt nu nv nk b">.then</code>的<code class="fe nt nu nv nk b">onRejection</code>参数。他们还将展示<code class="fe nt nu nv nk b">.catch</code>中需要特别注意的一些方面。</p><p id="ef06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为<code class="fe nt nu nv nk b">.catch</code>方法更灵活，通常会产生更可读的代码，所以优先使用<code class="fe nt nu nv nk b">.then</code>方法中的<code class="fe nt nu nv nk b">onRejected</code>方法已经成为惯例。</p><p id="3e64" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，需要注意的是，它们并不等同，在某些情况下会产生不同的结果。</p><p id="4885" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过复制<code class="fe nt nu nv nk b">practical.js</code>在<em class="nw">承诺</em>目录下创建一个新文件<code class="fe nt nu nv nk b">catch.js</code>:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="5590" class="no mn it nk b gy np nq l nr ns">cp practical.js catch.js</span></pre><p id="3bf6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">修改<code class="fe nt nu nv nk b">pour</code>函数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="d685" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用以下命令行指令运行修改后的程序:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="5749" class="no mn it nk b gy np nq l nr ns">node catch.js</span></pre><p id="4253" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">考虑到随机数序列的变化，在运行几次代码后，您应该会看到类似下面的输出:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="1ac2" class="no mn it nk b gy np nq l nr ns">That's a good pour! Glass 2 is 74% full. Drink up.<br/>That's a good pour! Glass 3 is 81% full. Drink up.<br/>That's a good pour! Glass 4 is 86% full. Drink up.<br/>That's a good pour! Glass 5 is 78% full. Drink up.<br/>That's a good pour! Glass 7 is 84% full. Drink up.<br/>That's a bad pour. Glass 1 failed! Try again.<br/>That's a bad pour. Glass 6 failed! Try again.<br/>That's a bad pour. Glass 8 failed! Try again.<br/>That's a bad pour. Glass 9 failed! Try again.<br/>That's a bad pour. Glass 10 failed! Try again.</span></pre><p id="a744" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有成功的<code class="fe nt nu nv nk b">pour</code>操作都出现在失败之前。那是怎么回事？</p><p id="53a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在使用<code class="fe nt nu nv nk b">.then</code>方法的<code class="fe nt nu nv nk b">onRejected</code>事件处理函数的原始代码中，返回的承诺中的错误由相同的方法处理。</p><p id="570c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在新代码中，返回一个状态为<code class="fe nt nu nv nk b">rejected</code>的新承诺。该承诺由<code class="fe nt nu nv nk b">.catch</code>方法的函数参数处理。被拒绝的操作需要一个额外的步骤，因此它们在回调队列中重新排队，并在成功的操作之后被处理。</p><p id="3c8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您希望您的结果出现在调用的顺序中，而不必收集和排序它们，这是要记住的事情。</p><p id="ee32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">拒绝承诺时抛出一个错误也被认为是好的做法。您可以很容易地修改<code class="fe nt nu nv nk b">fillGlass</code>函数，使它返回的承诺在被拒绝时传递错误。</p><p id="3b32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用以下代码替换<code class="fe nt nu nv nk b">catch.js</code>中的<code class="fe nt nu nv nk b">fillGlass</code>功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="5f44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再次运行<code class="fe nt nu nv nk b">catch.js</code>。现在你应该看到对失败的倒酒操作的解释:“漏了杯子！”</p><p id="fecb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意<em class="nw"> : </em>如果你的promise构造函数包含一个<code class="fe nt nu nv nk b">reject</code>方法，你必须使用一个<code class="fe nt nu nv nk b">.then</code>方法的<code class="fe nt nu nv nk b">onRejected</code>函数参数或者使用一个<code class="fe nt nu nv nk b">.catch</code>方法。未能处理您的承诺拒绝将导致如下错误:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="4879" class="no mn it nk b gy np nq l nr ns">(node:20932) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing</span><span id="4082" class="no mn it nk b gy ob nq l nr ns">inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 8)</span></pre><p id="b7e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过修改<code class="fe nt nu nv nk b">practical.js</code>和<code class="fe nt nu nv nk b">catch.js</code>可以看到promise构造函数中的<code class="fe nt nu nv nk b">reject</code>方法与<code class="fe nt nu nv nk b">.then</code>方法和<code class="fe nt nu nv nk b">.catch</code>方法的<code class="fe nt nu nv nk b">onRejected</code>参数是如何协同工作的。当您开始删除所需的错误处理时，这些程序将开始产生错误。</p><p id="9fc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您还没有开始编写代码，并且希望使用GitHub上的配套资源库赶上这一步，请在您希望创建项目目录的目录中执行以下命令:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="8170" class="no mn it nk b gy np nq l nr ns">git clone <a class="ae me" href="https://github.com/maciejtreder/asynchronous-javascript.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/asynchronous-javascript.git</a><br/>cd asynchronous-javascript<br/>git checkout step5<br/>npm install<br/>mkdir promises<br/>cd promises</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="e92a" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">用。最终方法</h1><p id="fc08" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated"><code class="fe nt nu nv nk b">.then</code>和<code class="fe nt nu nv nk b">.catch</code>方法使您能够处理通过决议或拒绝实现的承诺。</p><p id="aa37" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只要您想要执行的所有操作都符合其中一个类别，那就没问题，但是当您有无论承诺是被解决还是被拒绝都应该执行的代码时，您该怎么办呢？</p><p id="42b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">ECMAScript 2018向Promise原型添加了<code class="fe nt nu nv nk b">.finally</code>方法，使您能够在承诺完成后对其执行操作，无论它是已解决还是被拒绝。在此之前，您必须在<code class="fe nt nu nv nk b">.then</code>和<code class="fe nt nu nv nk b">.catch</code>中包含相同的代码。</p><p id="d61d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nt nu nv nk b">.finally</code>方法不接受任何参数，因为它不可能知道承诺是被履行还是被拒绝。因此，无论承诺的状态如何，一旦确定下来，你用<code class="fe nt nu nv nk b">.finally</code>方法做的任何事情都必须适用。</p><p id="5078" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个常见的用例是在从远程API检索数据时在网页上显示一个旋转图形。您还可以在控制台命令行上使用<a class="ae me" href="https://www.npmjs.com/package/ora" rel="noopener ugc nofollow" target="_blank"> ora </a>库实现一个微调器，以便在Node.js环境中执行远程操作时显示活动。</p><p id="2498" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以使用类似于您刚才看到的代码来尝试一下。</p><p id="8e67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过在promises目录中执行以下命令行指令来安装ora包:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="fc6c" class="no mn it nk b gy np nq l nr ns">npm install ora</span></pre><p id="bdba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在项目的promises目录中创建一个新文件<code class="fe nt nu nv nk b">finally.js</code>，并插入以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="548c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用以下命令行指令运行程序:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="f22e" class="no mn it nk b gy np nq l nr ns">node finally.js</span></pre><p id="f9fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于在<code class="fe nt nu nv nk b">promise2</code>构造函数的<code class="fe nt nu nv nk b">setTimeout</code>函数中指定的时间长度，您应该看到ora微调器和“加载承诺”。</p><p id="09e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">超时后，您应该会看到以下输出行:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="c97e" class="no mn it nk b gy np nq l nr ns">This will be always executed.</span></pre><p id="113f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其后应该是下面两行输出中的一行:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="6477" class="no mn it nk b gy np nq l nr ns">Promise resolved<br/>Promise rejected</span></pre><p id="04c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码的重复执行应该在50%的时间里产生每个结果(在足够多的重复次数之后),并且您应该在每次重复期间看到微调器。</p><p id="a529" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您想使用GitHub上的配套存储库将代码赶上这一步，请在您想要创建项目目录的目录中执行以下命令:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="5cbd" class="no mn it nk b gy np nq l nr ns">git clone <a class="ae me" href="https://github.com/maciejtreder/asynchronous-javascript.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/asynchronous-javascript.git</a><br/>cd asynchronous-javascript<br/>git checkout step6<br/>npm install</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="4dcf" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">摘要</h1><p id="687d" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">这篇文章介绍了JavaScript Promises，建立在回调的解释和JavaScript事件循环的基础上，这在本系列关于<a class="ae me" href="https://www.twilio.com/blog/search?q=asynchronous+javascript" rel="noopener ugc nofollow" target="_blank">异步JavaScript </a>的前两篇文章中可以找到。</p><p id="e45e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它解释了基本的JavaScript概念和术语，展示了如何编写Promise构造函数，并解释了在代码中使用Promise的基础知识。</p><p id="32ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章包括使用<code class="fe nt nu nv nk b">.then</code>、<code class="fe nt nu nv nk b">.catch</code>和<code class="fe nt nu nv nk b">.finally</code>方法的示例代码，并附有GitHub上的配套库。</p><p id="9498" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">异步JavaScript系列的下一期将深入研究使用承诺的更高级的方法，并解释<code class="fe nt nu nv nk b">.all</code>和<code class="fe nt nu nv nk b">.race</code>方法。</p><p id="4a9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一步:<a class="ae me" href="https://medium.com/@maciejtreder/asynchronous-javascript-advanced-promises-with-node-js-1d4c4b82e8ce" rel="noopener">异步JavaScript:node . js的高级承诺</a></p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="6312" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">额外资源</h1><ul class=""><li id="0bbf" class="lq lr it kw b kx ne la nf ld oc lh od ll oe lp lv lw lx ly bi translated"><a class="ae me" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">Promise</a>—Promise对象构造器的Mozilla Developer Network (MDN)文档。</li><li id="c065" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><a class="ae me" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises" rel="noopener ugc nofollow" target="_blank">使用承诺</a> —关于在代码中使用承诺的Mozilla Developer Network (MDN)文档，包括原型方法<code class="fe nt nu nv nk b">.then</code>、<code class="fe nt nu nv nk b">,catch</code>和<code class="fe nt nu nv nk b">.finally</code>。</li><li id="8e51" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><a class="ae me" href="https://javascript.info/promise-basics" rel="noopener ugc nofollow" target="_blank"> Promises，async/await</a>—<a class="ae me" href="https://javascript.info/" rel="noopener ugc nofollow" target="_blank">javascript . info</a>提供了JavaScript中异步技术的精彩部分，包括回调、Promises和async/await。它很吸引人地放在一起，包括执行良好的图表。</li></ul><p id="2d8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">网上还有许多关于JavaScript承诺的博客文章和文章，其中很多都不准确、不完整或令人困惑。回调函数总是一个很难写的话题，承诺中的时间考虑使它们变得更加困难。</p><p id="90d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你对承诺的介绍有任何问题，请告诉作者，这样我们可以解决它。</p></div></div>    
</body>
</html>