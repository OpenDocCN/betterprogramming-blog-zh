<html>
<head>
<title>We Automated Resolving Merge Conflicts, and Here’s How</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们自动解决合并冲突，下面是方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/we-automated-resolving-merge-conflicts-and-heres-how-b0320c206e10?source=collection_archive---------3-----------------------#2022-05-28">https://betterprogramming.pub/we-automated-resolving-merge-conflicts-and-heres-how-b0320c206e10?source=collection_archive---------3-----------------------#2022-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5ab2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一天可以避免冲突</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/8654c4bf0e842ff0cd57a6761e4d0e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TYXiHW7RearTlKiQ"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@daveballew?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> David Ballew </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a72c" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在开源的世界里，维护或贡献一个活跃的知识库并不像看起来那么简单，合并冲突是每个人都必须处理的事情，但是没有人喜欢它。B̶u̶t在<a class="ae kz" href="https://felvin.com/" rel="noopener ugc nofollow" target="_blank">菲尔文</a>，w̶e̶̶l̶o̶v̶e̶̶m̶e̶r̶g̶e̶̶c̶o̶n̶f̶l̶i̶c̶t̶s也没什么不同。</p><p id="35ac" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这篇文章将带你了解以下内容:</p><ul class=""><li id="53ad" class="lw lx iq lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">Felvin和即时应用</li><li id="5ef8" class="lw lx iq lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">即时应用程序的结构</li><li id="6e4b" class="lw lx iq lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">创建即时应用程序</li><li id="ae23" class="lw lx iq lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">合并我们面临的冲突</li><li id="bb1b" class="lw lx iq lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">自动化和解决合并冲突</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="9f5d" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">Felvin和即时应用</h1><p id="16d1" class="pw-post-body-paragraph la lb iq lc b ld nj jr lf lg nk ju li lj nl ll lm ln nm lp lq lr nn lt lu lv ij bi translated">Felvin  ，一种非常强大的人们查找信息的方式，通过将你在搜索引擎上看到的一切转换成一个插件来实现。</p><p id="5b5d" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">要了解更多关于Felvin和Felvin如何工作的信息，请点击<a class="ae kz" href="https://docs.felvin.com/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="deb5" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ir">即时应用</strong>是你在搜索查询中得到的小互动卡。我们可以为各种用例构建即时应用程序，如字典、查看足球比分、股票价格或你的想法笔记，甚至从公司slack或任何东西中搜索历史记录！点击<a class="ae kz" href="https://felvin.com/" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多！</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="1434" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">结构</h1><p id="d36d" class="pw-post-body-paragraph la lb iq lc b ld nj jr lf lg nk ju li lj nl ll lm ln nm lp lq lr nn lt lu lv ij bi translated">顾名思义，<a class="ae kz" href="https://github.com/felvin-search/instant-apps" rel="noopener ugc nofollow" target="_blank"> instant-apps </a>是在开源社区的帮助下创建的应用程序集合，以及测试这些应用程序的沙箱，所有这些都在一个存储库中。</p><p id="ab38" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们通过创建单独的react应用程序，然后将所有应用程序作为节点模块导出到单个react应用程序来实现这一点。</p><p id="8452" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">下面是回购的文件夹结构。社区创建的应用在<code class="fe kf kg kh ki b">apps/</code>下，例如:app1和app2。这些应用程序都有自己的<code class="fe kf kg kh ki b">package.json</code>、<code class="fe kf kg kh ki b">App.jsx</code>和<code class="fe kf kg kh ki b">index.ts</code>。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi no"><img src="../Images/1bbe602c82281ec1522dc1dd077c7ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nmjJciImgLlDAIKEukWAWg.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><a class="ae kz" href="https://github.com/felvin-search/instant-apps" rel="noopener ugc nofollow" target="_blank">即时应用</a>的文件夹结构</p></figure><p id="2299" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><code class="fe kf kg kh ki b">packages/apps</code>导入所有应用程序，然后将其导出到沙盒中。</p><p id="60fd" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><code class="fe kf kg kh ki b">packages/apps/src/index.ts</code>:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="57f0" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><code class="fe kf kg kh ki b">packages/apps/package.json</code>:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="622b" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">最后，<code class="fe kf kg kh ki b">yarn.lock</code>文件看起来像这样:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="de64" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在，我们已经对结构有了基本的了解，让我们看看一个新的即时应用程序是如何创建的，以及它如何影响回购。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="42ed" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">创建即时应用程序</h1><p id="9358" class="pw-post-body-paragraph la lb iq lc b ld nj jr lf lg nk ju li lj nl ll lm ln nm lp lq lr nn lt lu lv ij bi translated">运行<code class="fe kf kg kh ki b">yarn create-app</code>可以创建一个新的即时应用。</p><p id="a515" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">创建新应用程序将会生成以下内容:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/c01fc4f4a8b105a56baf83b82c6a8073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*-HmL9-eZSf9Dxd5ZZtIppg.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">新应用程序的文件夹结构(app1)</p></figure><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="f3cb" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">并更新<code class="fe kf kg kh ki b">./packages/apps/src/index.ts</code>、<code class="fe kf kg kh ki b">./packages/apps/package.json</code>和<code class="fe kf kg kh ki b">./yarn.lock</code></p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="a7e0" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">合并冲突</h1><p id="8e07" class="pw-post-body-paragraph la lb iq lc b ld nj jr lf lg nk ju li lj nl ll lm ln nm lp lq lr nn lt lu lv ij bi translated">通过创建一个新的应用程序，我们知道有几个文件(准确地说是3个)被更新了，这些通常是合并冲突背后的罪魁祸首。</p><p id="951c" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">让我们看一个例子来更好地理解这一点。</p><p id="e092" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">下图显示了我们通常是如何遇到合并冲突的。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ns"><img src="../Images/8775a4304f2268d0f334e8faff59423e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AaMODTb-gocgZe9ZiwsBlg.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">数字流程图</p></figure><p id="f261" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们创建了一个新的分支，并在App1 v1.0.0发布后立即开始开发App2 v1.0.0。当我们在开发App2的时候，已经有了App1的新版本，即v1.0.1。</p><p id="ba25" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">其他人从App1 v1.0.1发布开始为App3 v1.0.0创建了一个新的分支，他们设法在我们之前完成了他们的应用。于是，他们的分公司就并入了我们之前的<code class="fe kf kg kh ki b">master</code> <strong class="lc ir"> </strong>分公司。</p><p id="c71c" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">当我们最终完成App2 v1.0.0并准备合并到<code class="fe kf kg kh ki b">master</code> <strong class="lc ir"> </strong>分支时，我们会面临以下合并冲突，并且有一个模式:</p><h2 id="02c6" class="nt ms iq bd mt nu nv dn mx nw nx dp nb lj ny nz nd ln oa ob nf lr oc od nh oe bi translated"><code class="fe kf kg kh ki b">1. /packages/apps/src/index.ts</code></h2><p id="e453" class="pw-post-body-paragraph la lb iq lc b ld nj jr lf lg nk ju li lj nl ll lm ln nm lp lq lr nn lt lu lv ij bi translated">在<code class="fe kf kg kh ki b">index.ts</code>文件中，冲突并不复杂。它可以通过接受当前和即将到来的更改来解决，但需要我们使用正则表达式或文本编辑器来解决这个问题。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="fe15" class="nt ms iq bd mt nu nv dn mx nw nx dp nb lj ny nz nd ln oa ob nf lr oc od nh oe bi translated">2.<code class="fe kf kg kh ki b">packages/apps/package.json</code></h2><p id="c94b" class="pw-post-body-paragraph la lb iq lc b ld nj jr lf lg nk ju li lj nl ll lm ln nm lp lq lr nn lt lu lv ij bi translated">在<code class="fe kf kg kh ki b">package.json</code>的情况下，事情就大不一样了。这有点复杂，因为涉及到应用程序的多个版本。Git确实可以选择接受基于文件的传入(<code class="fe kf kg kh ki b">— theirs</code>)和当前(<code class="fe kf kg kh ki b">— ours</code>)变更，但是这对我们没有用。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="2de1" class="nt ms iq bd mt nu nv dn mx nw nx dp nb lj ny nz nd ln oa ob nf lr oc od nh oe bi translated">3.<code class="fe kf kg kh ki b">yarn.lock</code></h2><p id="36cd" class="pw-post-body-paragraph la lb iq lc b ld nj jr lf lg nk ju li lj nl ll lm ln nm lp lq lr nn lt lu lv ij bi translated">与<code class="fe kf kg kh ki b">package.json</code>类似，<code class="fe kf kg kh ki b">yarn.lock</code>也有冲突的应用程序版本，但是，如果<code class="fe kf kg kh ki b">package.json</code>已经解决，只需运行<code class="fe kf kg kh ki b">yarn</code>或<code class="fe kf kg kh ki b">yarn install</code>就可以解决冲突。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="d64f" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在这一点上，我们可以重定基础，然后尝试合并它，但重定基础是一个坏主意。你可以在这里阅读为什么这不是个好主意。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><blockquote class="of"><p id="df67" class="og oh iq bd oi oj ok ol om on oo lv dk translated">……你可以肯定，真实的T21历史将比改写的(或伪造的)历史更有用。</p><p id="681f" class="og oh iq bd oi oj ok ol om on oo lv dk translated"><a class="oq or ep" href="https://medium.com/u/800b98e64951?source=post_page-----b0320c206e10--------------------------------" rel="noopener" target="_blank">-弗雷德里克·莫尔肯</a></p></blockquote></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="3e25" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">自动化和解决合并冲突</h1><p id="da46" class="pw-post-body-paragraph la lb iq lc b ld nj jr lf lg nk ju li lj nl ll lm ln nm lp lq lr nn lt lu lv ij bi translated">为了自动化合并和解决冲突的过程，我们选择使用python和shell的组合。像<strong class="lc ir"> glob </strong>、<strong class="lc ir"> os </strong>和<strong class="lc ir"> json </strong>这样的内置python库已经足够了。我们还使用来自<code class="fe kf kg kh ki b">./packages/apps/src/index.ts</code>和<code class="fe kf kg kh ki b">./packages/apps/package.json</code>的样板代码作为常量。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b19c" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">要解决合并冲突，这里最好的方法是从头开始生成<code class="fe kf kg kh ki b">./packages/apps/src/index.ts</code>和<code class="fe kf kg kh ki b">./packages/apps/package.json</code>，方法是遍历存储库中的所有应用程序，并获取这些应用程序的名称和版本。我们写了一个类来做同样的事情。首先，我们初始化一堆与获取每个应用程序路径相关的东西，它们是<code class="fe kf kg kh ki b">package.json</code>、<code class="fe kf kg kh ki b">./packages/apps/src/index.ts</code>和<code class="fe kf kg kh ki b">./packages/apps/package.json</code>。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="dcf4" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">然后我们迭代每个应用程序的<code class="fe kf kg kh ki b">package.json</code>来获得名称和版本。<br/>为了便于理解，从现在开始，将提供注释来更好地说明每一步发生了什么。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="b2e2" class="nt ms iq bd mt nu nv dn mx nw nx dp nb lj ny nz nd ln oa ob nf lr oc od nh oe bi translated">1.解析'<code class="fe kf kg kh ki b">./packages/apps/src/index.ts'</code></h2><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="4c8b" class="nt ms iq bd mt nu nv dn mx nw nx dp nb lj ny nz nd ln oa ob nf lr oc od nh oe bi translated">2.解析'<code class="fe kf kg kh ki b">./packages/apps/package.json'</code></h2><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="c2c0" class="nt ms iq bd mt nu nv dn mx nw nx dp nb lj ny nz nd ln oa ob nf lr oc od nh oe bi translated">3.解析'<code class="fe kf kg kh ki b">yarn.lock'</code></h2><p id="faf4" class="pw-post-body-paragraph la lb iq lc b ld nj jr lf lg nk ju li lj nl ll lm ln nm lp lq lr nn lt lu lv ij bi translated">如前所述，生成<code class="fe kf kg kh ki b">yarn.lock</code>只需要我们在解析完其他两个文件后立即运行<code class="fe kf kg kh ki b">yarn</code>或<code class="fe kf kg kh ki b">yarn install</code>。为此，我们:</p><p id="f5a0" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">a)首先，获取当前分支的名称<br/> b)然后运行<code class="fe kf kg kh ki b">git merge master</code>，由于存在冲突，在合并之前会停止。<br/> c)运行<code class="fe kf kg kh ki b">yarn</code>或<code class="fe kf kg kh ki b">yarn install</code>T35】d)暂存所有文件<br/> e)使用默认合并消息完成合并，我们也可以使用<code class="fe kf kg kh ki b">--continue</code>标志继续合并，但这需要我们更改合并日志并通过vim进行编辑。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9fe6" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">你可以在这里看一下实际代码<a class="ae kz" href="https://github.com/felvin-search/instant-apps/tree/master/scripts" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="85b2" class="mr ms iq bd mt mu os mw mx my ot na nb jw ou jx nd jz ov ka nf kc ow kd nh ni bi translated">摘要</h1><p id="a6d8" class="pw-post-body-paragraph la lb iq lc b ld nj jr lf lg nk ju li lj nl ll lm ln nm lp lq lr nn lt lu lv ij bi translated">合并冲突有时可能是痛苦的，但是如果您发现冲突的重复模式，您可能可以驯服它，或者通过自动化它使它成为您的伙伴。这篇文章不是为了帮助大众，而是为了记录我的经历，或者甚至是为那些面临类似情况的人激发灵感，因为当我们试图找出解决合并冲突的方法时，我们找不到太多。你需要问自己的唯一问题是——<em class="ox">“我们的合并冲突有模式吗？”</em></p><p id="86dd" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">特别感谢<a class="oq or ep" href="https://medium.com/u/8efd95d5df6e?source=post_page-----b0320c206e10--------------------------------" rel="noopener" target="_blank">哈什·古普塔</a>促使我写这篇博客</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/f6a7409ef4f97cb49faf3791227ffaf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*Z2IqfaTJqKtz9it6.png"/></div></figure></div></div>    
</body>
</html>