<html>
<head>
<title>Lazy-Load Images With the Intersection Observer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用交叉点观察器延迟加载图像</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lazy-loading-images-with-the-intersection-observer-e8ad57a1682c?source=collection_archive---------0-----------------------#2018-04-05">https://betterprogramming.pub/lazy-loading-images-with-the-intersection-observer-e8ad57a1682c?source=collection_archive---------0-----------------------#2018-04-05</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="6b4a" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">使用高效加载的图像加速一切</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/c0474ba7a7d4dcd7aac4da79da589efc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HzI6z9f-Hy5_ZxzyY_wuMA.png"/></div></div></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="kv kw l"/></div></figure><p id="6e15" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">去年，我试图越来越多地关注网站和网络应用的性能。在所有大型框架和库的世界中，这是一个相当大的挑战。</p><p id="5e49" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">希望您知道加载图像会耗费更多的时间和数据。但是幸运的是，有一种叫做延迟加载图像的技术。</p></div><div class="ab cl lt lu hy lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="in io ip iq ir"><h1 id="02d6" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">加载图像</h1><p id="21ed" class="pw-post-body-paragraph kx ky iu kz b la ms jv lc ld mt jy lf lg mu li lj lk mv lm ln lo mw lq lr ls in bi translated">用普通的<code class="fe mx my mz na b">&lt;img&gt;</code>标签加载图像让浏览器等待，直到所有的图像都被加载。</p><pre class="kk kl km kn gu nb na nc nd aw ne bi"><span id="37bb" class="nf mb iu na b gz ng nh l ni nj">&lt;img src="https://loadyourimages.nl/image-nam.jpg" src="This is my awesome image"&gt;</span></pre><p id="1c99" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">特别是如果你有一个有很多图片的网站，在用户有一个交互式页面之前，可能需要十秒钟。</p><p id="8b73" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">移动连接可能会更糟。如果连接不好或很慢，用户有时会等待几十秒甚至几分钟。</p><p id="2789" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">但是我们都知道那些用户不想等那么久。他们会在几秒钟后离开！</p></div><div class="ab cl lt lu hy lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="in io ip iq ir"><h1 id="0a84" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">延迟加载图像</h1><p id="3ae5" class="pw-post-body-paragraph kx ky iu kz b la ms jv lc ld mt jy lf lg mu li lj lk mv lm ln lo mw lq lr ls in bi translated">我们希望我们的网页加载速度越快越好。我们的目标应该是零到五秒，这是用户能够耐心等待页面加载的时间。</p><p id="c18e" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">因此，如果我们避免正常的<code class="fe mx my mz na b">&lt;img src="url"&gt;</code>，我们的页面将加载得更快。</p><p id="c358" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">如果我们使用一个数据属性来放入图像的URL，我们可以将它放入src属性中，以便当它在视口中时加载它们。</p><p id="2f4c" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">大多数开发人员将使用库进行延迟加载，在<code class="fe mx my mz na b">scroll</code>事件上使用<code class="fe mx my mz na b">eventListener</code>来检查元素是否在视口中。但是我们需要更好的东西，因为卷轴上的<code class="fe mx my mz na b">eventListener</code>在某些设备上有点重。</p></div><div class="ab cl lt lu hy lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="in io ip iq ir"><h1 id="c842" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">交叉观察者</h1><p id="54d5" class="pw-post-body-paragraph kx ky iu kz b la ms jv lc ld mt jy lf lg mu li lj lk mv lm ln lo mw lq lr ls in bi translated">交叉点观察器很好地检测了某个元素是否在浏览器的可见部分中。</p><blockquote class="nk"><p id="770e" class="nl nm iu bd nn no np nq nr ns nt ls dk translated">“交集观察器API提供了一种异步观察目标元素与祖先元素或顶级文档的视口的交集的方式。”— <a class="ae nu" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> Mozilla Docs </strong> </a></p></blockquote><p id="3c8b" class="pw-post-body-paragraph kx ky iu kz b la nv jv lc ld nw jy lf lg nx li lj lk ny lm ln lo nz lq lr ls in bi translated">使用这个API，我们可以监听一个元素是否在视口中，以及它们是否与视口相交。</p></div><div class="ab cl lt lu hy lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="in io ip iq ir"><h1 id="928a" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">配置交叉点观察点</h1><p id="dc9b" class="pw-post-body-paragraph kx ky iu kz b la ms jv lc ld mt jy lf lg mu li lj lk mv lm ln lo mw lq lr ls in bi translated">我们有几个配置观察器的选项。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oa kw l"/></div></figure><h2 id="2c81" class="nf mb iu bd mc ob oc dn mg od oe dp mk lg of og mm lk oh oi mo lo oj ok mq ol bi translated">根</h2><p id="b31c" class="pw-post-body-paragraph kx ky iu kz b la ms jv lc ld mt jy lf lg mu li lj lk mv lm ln lo mw lq lr ls in bi translated">在<code class="fe mx my mz na b">root</code>属性中，定义将被设置为视口的元素。</p><p id="35e7" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">请记住，如果您的目标是一个元素(或身体)，当它的高度是自动的，那么所有的元素将被设置为可见。</p><p id="a61c" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">因此，如果设置一个元素，请设置一个非自动的高度。否则就达不到预期的效果。如果不定义该属性，它将自动使用浏览器视口。</p><h2 id="2b50" class="nf mb iu bd mc ob oc dn mg od oe dp mk lg of og mm lk oh oi mo lo oj ok mq ol bi translated">根缘</h2><p id="b800" class="pw-post-body-paragraph kx ky iu kz b la ms jv lc ld mt jy lf lg mu li lj lk mv lm ln lo mw lq lr ls in bi translated">如果<code class="fe mx my mz na b">rootMargin</code>值被设置为0，它将不会查看<code class="fe mx my mz na b">root</code>元素之外的内容。如果你输入10px，它会提前检查一个元素是否被滚动到它的<code class="fe mx my mz na b">root</code>元素中。</p><h2 id="63f9" class="nf mb iu bd mc ob oc dn mg od oe dp mk lg of og mm lk oh oi mo lo oj ok mq ol bi translated">阈值</h2><p id="1980" class="pw-post-body-paragraph kx ky iu kz b la ms jv lc ld mt jy lf lg mu li lj lk mv lm ln lo mw lq lr ls in bi translated">如果<code class="fe mx my mz na b">threshold</code>的值为0，当元素的1px在<code class="fe mx my mz na b">root</code>元素内部时，它将运行回调。当值为1.0时，它将在100%位于<code class="fe mx my mz na b">root</code>元素内部时触发回调。</p><p id="7b2f" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">但是如果您希望回调在元素的50%位于<code class="fe mx my mz na b">root</code>元素内部时被调用，请输入值0.5。</p></div><div class="ab cl lt lu hy lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="in io ip iq ir"><h1 id="9b92" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">目标元素</h1><p id="f978" class="pw-post-body-paragraph kx ky iu kz b la ms jv lc ld mt jy lf lg mu li lj lk mv lm ln lo mw lq lr ls in bi translated">要使用交集观察器，我们需要元素来观察一些元素！</p><p id="eaf7" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">我们想要观察的元素有一个类名<code class="fe mx my mz na b">fake-image</code>，我们将遍历这些元素，为每个<code class="fe mx my mz na b">fake-image</code>元素启动一个观察器。</p><p id="0c25" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">我们还希望确保当元素在我们的根元素中时，观察将被停止。这可以节省电脑或设备的一些电量。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oa kw l"/></div></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="om kw l"/></div></figure></div><div class="ab cl lt lu hy lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="in io ip iq ir"><h1 id="1db0" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">演示</h1><p id="bda8" class="pw-post-body-paragraph kx ky iu kz b la ms jv lc ld mt jy lf lg mu li lj lk mv lm ln lo mw lq lr ls in bi translated">让我们试试这个！</p><p id="169c" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">我已经创建了一个小的演示，向您展示交叉点观察器的工作真的很流畅。</p><p id="3066" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">开始滚动，每次一个元素100%可见，就会变成绿色，文本就会“加载！”</p></div><div class="ab cl lt lu hy lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="in io ip iq ir"><h1 id="2b0c" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">浏览器支持</h1><p id="8955" class="pw-post-body-paragraph kx ky iu kz b la ms jv lc ld mt jy lf lg mu li lj lk mv lm ln lo mw lq lr ls in bi translated"><a class="ae nu" href="https://caniuse.com/#feat=intersectionobserver" rel="noopener ugc nofollow" target="_blank">对交叉点观察器</a>的支持非常好。它在Chrome(桌面和移动)、Firefox、Edge和Android浏览器中实现。所以，它在IE11和Safari(桌面和移动)中是缺失的。</p><p id="356e" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated"><a class="ae nu" href="https://webkit.org/status/#specification-intersection-observer" rel="noopener ugc nofollow" target="_blank"> webkit团队正在努力工作</a>，因为它被标记为“开发中”，所以希望它很快能在Safari中得到支持(2018年3月)。</p><p id="6b2b" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">为了支持还不支持这个很酷的API的浏览器，我们可以使用polyfill。我们可以通过npm: <a class="ae nu" href="https://www.npmjs.com/package/intersection-observer" rel="noopener ugc nofollow" target="_blank">交集-观察者</a>:</p><pre class="kk kl km kn gu nb na nc nd aw ne bi"><span id="0ecb" class="nf mb iu na b gz ng nh l ni nj">npm install intersection-observer --save</span></pre></div><div class="ab cl lt lu hy lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="in io ip iq ir"><h1 id="6aed" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">让我们构建延迟加载的图像</h1><p id="9b12" class="pw-post-body-paragraph kx ky iu kz b la ms jv lc ld mt jy lf lg mu li lj lk mv lm ln lo mw lq lr ls in bi translated">现在我们知道了如何使用交叉点观察器，我们将让我们的图像在可见视口中异步加载到我们的浏览器中。</p><p id="9059" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">在这篇博文的开始，我向您展示了大部分惰性加载功能是如何在过去几年中构建的。因此，让我们为交叉点观察器替换滚动事件监听器。</p></div><div class="ab cl lt lu hy lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="in io ip iq ir"><h1 id="e9cb" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">超文本标记语言</h1><p id="762b" class="pw-post-body-paragraph kx ky iu kz b la ms jv lc ld mt jy lf lg mu li lj lk mv lm ln lo mw lq lr ls in bi translated">如果你记得我们在之前的例子中使用的HTML，那么你会看到我们只需要添加一个带有数据属性<code class="fe mx my mz na b">data-src</code>的<code class="fe mx my mz na b">&lt;img&gt;</code>标签。</p><p id="34c3" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">数据属性是放入URL的完美解决方案，所以我们可以把URL放在那里。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oa kw l"/></div></figure></div><div class="ab cl lt lu hy lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="in io ip iq ir"><h1 id="9324" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">Java Script语言</h1><p id="c149" class="pw-post-body-paragraph kx ky iu kz b la ms jv lc ld mt jy lf lg mu li lj lk mv lm ln lo mw lq lr ls in bi translated">对于JavaScript，我们只需要一个函数来加载我们的图像。调用交叉点观察器内部的函数。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oa kw l"/></div></figure><p id="4393" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">我们在函数中唯一需要做的事情是将URL从<code class="fe mx my mz na b">data-src</code>属性放入<code class="fe mx my mz na b">src</code>属性。</p><p id="cc61" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">当<code class="fe mx my mz na b">src</code>属性出现时，图像将加载到浏览器中。</p><p id="deae" class="pw-post-body-paragraph kx ky iu kz b la lb jv lc ld le jy lf lg lh li lj lk ll lm ln lo lp lq lr ls in bi translated">在JavaScript代码中，我设置了一秒钟的超时时间来观察加载过程。</p></div><div class="ab cl lt lu hy lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="in io ip iq ir"><h1 id="3845" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">例子</h1><p id="6757" class="pw-post-body-paragraph kx ky iu kz b la ms jv lc ld mt jy lf lg mu li lj lk mv lm ln lo mw lq lr ls in bi translated">让我们来看看这个例子。向下滚动视图，这样您就可以看到它是如何工作的。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="om kw l"/></div></figure></div><div class="ab cl lt lu hy lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="in io ip iq ir"><h1 id="e715" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">谢谢</h1><p id="6172" class="pw-post-body-paragraph kx ky iu kz b la ms jv lc ld mt jy lf lg mu li lj lk mv lm ln lo mw lq lr ls in bi translated">如果你从<code class="fe mx my mz na b">querySelectorAll</code>中学到了什么或者有其他方法可以绕过<code class="fe mx my mz na b">NodeList</code>T4，请告诉我。</p></div></div>    
</body>
</html>