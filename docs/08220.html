<html>
<head>
<title>3 Mistakes That I Find in Most Django-Based Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在大多数基于Django的项目中发现的3个错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mistakes-that-i-am-still-finding-in-django-based-projects-cc40e2e118b3?source=collection_archive---------6-----------------------#2021-04-07">https://betterprogramming.pub/mistakes-that-i-am-still-finding-in-django-based-projects-cc40e2e118b3?source=collection_archive---------6-----------------------#2021-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="359f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Django代码库中应该避免的模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/307763e917d838bf79e55998e188f183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GW6S9-5htcu1PA3Yf7DOfQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">有些错误是致命的。</p></figure><p id="9efa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我已经足够老了，还记得使用Django框架的1.3版本。那是2011年，我刚刚开始在Python生态系统中进行专业的web开发。后来框架成熟了(已经3.2了)，我也成熟了。在此期间，我大概参与了50多个以Django为主要框架的项目。这是因为它是一个很好的框架，通过良好的工具、ORM和一个真正伟大的社区，使开发人员能够更快地交付特性。</p><p id="a395" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管如此，我仍然在基于Django的代码库中发现一些解决方案，这些解决方案很糟糕或者是不可接受的，尽管事实上我们现在在Django网页中已经有了<em class="lu">反模式</em>。在本文中，我将讨论其中的一些，以帮助开发人员理解我的意思——尤其是年轻的开发人员。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9f3a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">项目设置</h1><p id="19df" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">如果您想跟随代码，这里是如何设置项目。您也可以跳过这一部分，进入下一部分。</p><p id="b654" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="09f9" class="ne md it na b gy nf ng l nh ni">django-admin startproject &lt;project_name&gt;  # this will create project for you<br/>cd &lt;project_name&gt;<br/>django-admin startapp articles  # this will setup a basic app for you</span></pre><p id="470e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在您的<code class="fe nj nk nl na b">articles/models.py</code>中，添加以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="93bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将<code class="fe nj nk nl na b">articles</code>应用程序添加到Django设置文件中的<code class="fe nj nk nl na b">INSTALLED_APPS</code>中，创建迁移，并应用它们。</p><p id="1697" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在您的<code class="fe nj nk nl na b">articles/forms.py</code>中，添加以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a119" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而在你的<code class="fe nj nk nl na b">articles/views.py</code>里，这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="368d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">设置一个简单的HTML页面来显示表单，并配置<code class="fe nj nk nl na b">articles/urls.py</code>和<code class="fe nj nk nl na b">ROOT_URLCONF</code>文件。</p><p id="1c60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们都准备好了。实验的其余代码将在下面的小节中提供。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="56f3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.基于模型的固定选择</h1><p id="976c" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">有时候，你想在Django中使用一个定制表单来处理不同的逻辑或UX。一般来说，你最终会处于一个<code class="fe nj nk nl na b">ModelForm</code>不可选择的境地。这就是乐趣的开始。在上面的模型定义中，您可以看到<code class="fe nj nk nl na b">Article</code>实例可以通过<code class="fe nj nk nl na b">ManyToManyField</code>分配多个标签。我在表单级别上对它进行了简化，只允许每篇文章有一个标签向您展示一些东西。</p><p id="ac6c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nj nk nl na b">AddArticleForm</code>有一个从<code class="fe nj nk nl na b">Tag</code>模型中显式提取的带有定制选项的<code class="fe nj nk nl na b">ChoiceField</code>，列表在那里构建。在页面上，它看起来或多或少像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/7ded4a8e03c46655632c2c21cfeb5831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*3ZRnh4eN1TKPUUV1uOIxBQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加新文章表单</p></figure><p id="ab7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在管理面板中定义了一个新的标签来注册上面的模型。您需要在您的<code class="fe nj nk nl na b">articles/admin.py</code>中执行以下操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5ab9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么这不好呢？那么，当您现在在管理面板中添加一个新标签时(或者反过来)，表单将看不到它，直到您重新启动开发服务器(或者任何其他服务器，如果这出于某种原因影响到其他环境)。这是为什么呢？这样的代码是在类定义层上执行的，这意味着当我们导入表单<code class="fe nj nk nl na b">AddArticleForm</code>时它就会被执行，而那些<code class="fe nj nk nl na b">choices</code>将永远存在，直到应用服务器重新加载。</p><p id="5ea6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这似乎有点违反直觉，我认为主要原因是开发人员仍然无法完全理解ORM和Python是如何工作的。另一个原因是开发人员习惯于在<code class="fe nj nk nl na b">choices</code>中放一些东西，比如<code class="fe nj nk nl na b">choices=[("EUR", "EURO"), ("USD", "DOLLAR")]</code>，在这种情况下这是完全有意义的(因为我们不希望这经常改变)。但是对于存储在数据库级别的实体，情况就不同了。</p><p id="25f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么应该怎么做呢？</p><p id="8457" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在表单上使用<code class="fe nj nk nl na b">__init__</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="cad6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，您可以始终确保重新加载页面也会重新加载可能的选项。</p><p id="b266" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法还有一个不太明显的问题(从类级别的模型实例构建的选择):它很可能会破坏您的初始项目设置，因为它要求您已经在数据库中有了<code class="fe nj nk nl na b">Tag</code>。一个糟糕的开发人员可以不费吹灰之力就阻止新的开发人员加入，而不需要数据库转储。</p><p id="49e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你会惊讶于我在现有的、严肃的、生产就绪的代码库中发现的这个问题的变体的数量。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="28c8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.忽略选择相关和预取相关</h1><p id="7dd5" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在这里搭建游乐场，打开一个Django shell ( <code class="fe nj nk nl na b">python manage.py shell</code>)，导入<code class="fe nj nk nl na b">Article</code>和<code class="fe nj nk nl na b">Tag</code>模型(<code class="fe nj nk nl na b">from articles.models import Article, Tag</code>)。此外，在shell中执行以下操作:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bfe8" class="ne md it na b gy nf ng l nh ni">import logging<br/>l = logging.getLogger('django.db.backends')<br/>l.setLevel(logging.DEBUG)<br/>l.addHandler(logging.StreamHandler())</span></pre><p id="8f23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将允许您实时查看数据库查询。</p><p id="e7e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建一些标签和一些文章。现在这样做:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c8ef" class="ne md it na b gy nf ng l nh ni">for article in Article.objects.all():<br/>    print(article.content)</span></pre><p id="da3a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为输出，您应该看到类似这样的内容:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4d1a" class="ne md it na b gy nf ng l nh ni">(0.000) SELECT "articles_article"."id", "articles_article"."content" FROM "articles_article"; args=()<br/>content0<br/>content1</span></pre><p id="1777" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我们有一个<code class="fe nj nk nl na b">SELECT</code>查询，并为每个<code class="fe nj nk nl na b">Article</code>实例打印了<code class="fe nj nk nl na b">content</code>属性。</p><p id="d142" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果我们想访问<code class="fe nj nk nl na b">tags</code>属性，会发生什么呢？是的，你是对的。我们将对每个<code class="fe nj nk nl na b">for</code>循环进行额外的查询:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="dd2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您在这里看到的，我们首先使用<code class="fe nj nk nl na b">SELECT</code>从数据库中获取所有的文章。在每个<code class="fe nj nk nl na b">for</code>循环的后面，我们有一个额外的查询来查找第一个标签。</p><p id="8705" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们稍微修改一下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="f97c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，使用<code class="fe nj nk nl na b">prefetch_related</code>已经将查询数量减少到两个——第一个<code class="fe nj nk nl na b">SELECT</code>获取文章，第二个获取分配给文章的所有标签。</p><p id="5f6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，我只有两篇文章和两个标签，但是现在想象一下，有人正在对数千个条目进行操作。作为一名后端开发人员，您应该尽量减少查询次数。这是一个开销很大的I/O操作，会影响应用程序的性能。</p><p id="741e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有一些工具可以帮助你理解这一部分(例如<a class="ae np" href="https://github.com/jazzband/django-silk" rel="noopener ugc nofollow" target="_blank"> django-silk </a>)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="94fa" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.不知道update_fields的用途</h1><p id="2c41" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">很简单。它将只更新列表中指定的模型字段。例如:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="720b" class="ne md it na b gy nf ng l nh ni">article.save(update_fields=["content"])</span></pre><p id="16f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将只更新一个文章实例的<code class="fe nj nk nl na b">content</code>字段。</p><p id="c5bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">哪里有用？嗯，在web开发中，并发写入同一个对象是很正常的。当你总是全力扑救时，这不是一个大问题。最后一个胜出，但这里重要的是两个相同的对象在不同的节点上可以处于完全不同的状态。</p><p id="8de9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设应用程序的第一个节点从数据库获取对象，然后使用ORM将其转换为Python对象。然后，它有一些耗时的操作，最后，它将修改后的对象保存到数据库中。在这个耗时的窗口中，第二个节点获取对象并将其加载到Python对象中。第二个节点在第一个节点之后稍晚一点进行保存。然后，在第一个节点上所做的更改将被覆盖，这是一个<code class="fe nj nk nl na b">update_fields</code>拯救我们的例子(也有不同的技术来处理这一点)。</p><p id="a07f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当第一个和第二个节点对对象做完全不同的事情，并且对不同的属性感兴趣的时候<code class="fe nj nk nl na b">update_fields</code>会特别有帮助(但是你需要这样考虑和设计系统)。</p><p id="beac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您在代码中的某些地方只更新单个字段时，这一点尤其重要。<code class="fe nj nk nl na b">status</code>就是一个很好的例子。如果在此过程中没有更新其他字段，则应该是:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0994" class="ne md it na b gy nf ng l nh ni">instance.save(update_fields=["status"])</span></pre><p id="4b89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为这样的字段通常存储重要的业务逻辑，所以不丢失它更重要。</p><p id="c7df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。</p></div></div>    
</body>
</html>