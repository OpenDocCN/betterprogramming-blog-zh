<html>
<head>
<title>Struct vs Classes in Swift: The Differences Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的结构与类:差异解释</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/struct-vs-classes-in-swift-the-differences-explained-1e164a22efa6?source=collection_archive---------11-----------------------#2019-08-27">https://betterprogramming.pub/struct-vs-classes-in-swift-the-differences-explained-1e164a22efa6?source=collection_archive---------11-----------------------#2019-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1793" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么时候应该使用struct，什么时候应该使用class？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/63bc162f8396bd8589c33a84dec14aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQsEqRx5QHTONZ9UZ0YYTA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@maxcodes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马克斯·尼尔森</a>在<a class="ae ky" href="https://unsplash.com/search/photos/swift?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><blockquote class="kz"><p id="26d5" class="la lb it bd lc ld le lf lg lh li lj dk translated">无法分配给属性:函数调用返回不可变的值</p></blockquote><p id="f22a" class="pw-post-body-paragraph lk ll it lm b ln lo ju lp lq lr jx ls lt lu lv lw lx ly lz ma mb mc md me lj im bi translated">当出现上述错误时，您可能不是第一个将类型改为类的人，因为结构往往更难处理。希望读完这篇文章后，你能更容易地使用结构！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="c64b" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">Swift中的类是什么？</h1><p id="1408" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">Swift中的类是一种引用类型，可以包含:</p><ul class=""><li id="e3c0" class="nj nk it lm b ln nl lq nm lt nn lx no mb np lj nq nr ns nt bi translated">性能</li><li id="f866" class="nj nk it lm b ln nu lq nv lt nw lx nx mb ny lj nq nr ns nt bi translated">方法</li><li id="1892" class="nj nk it lm b ln nu lq nv lt nw lx nx mb ny lj nq nr ns nt bi translated">下标</li><li id="84c5" class="nj nk it lm b ln nu lq nv lt nw lx nx mb ny lj nq nr ns nt bi translated">初始值设定项</li><li id="0216" class="nj nk it lm b ln nu lq nv lt nw lx nx mb ny lj nq nr ns nt bi translated">协议一致性</li><li id="6ca5" class="nj nk it lm b ln nu lq nv lt nw lx nx mb ny lj nq nr ns nt bi translated">延长</li></ul><p id="e77a" class="pw-post-body-paragraph lk ll it lm b ln nl ju lp lq nm jx ls lt nz lv lw lx oa lz ma mb ob md me lj im bi translated">它通常被描述为一个对象的模板定义，就像下面的<code class="fe oc od oe of b">Article</code>实例定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="b3b6" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">Swift中的结构是什么？</h1><p id="0099" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">Swift中的结构是一种值类型，与类一样，可以包含:</p><ul class=""><li id="6df3" class="nj nk it lm b ln nl lq nm lt nn lx no mb np lj nq nr ns nt bi translated">性能</li><li id="6d02" class="nj nk it lm b ln nu lq nv lt nw lx nx mb ny lj nq nr ns nt bi translated">方法</li><li id="a7fd" class="nj nk it lm b ln nu lq nv lt nw lx nx mb ny lj nq nr ns nt bi translated">下标</li><li id="8382" class="nj nk it lm b ln nu lq nv lt nw lx nx mb ny lj nq nr ns nt bi translated">初始值设定项</li><li id="d780" class="nj nk it lm b ln nu lq nv lt nw lx nx mb ny lj nq nr ns nt bi translated">协议一致性</li><li id="226d" class="nj nk it lm b ln nu lq nv lt nw lx nx mb ny lj nq nr ns nt bi translated">延长</li></ul><p id="aeb4" class="pw-post-body-paragraph lk ll it lm b ln nl ju lp lq nm jx ls lt nz lv lw lx oa lz ma mb ob md me lj im bi translated">它也可以被看作一个对象的模板定义，就像下面的<code class="fe oc od oe of b">Article</code>实例定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="ea33" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结构和类之间有什么区别？</h1><p id="16b7" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">是的，你是对的，上面的例子看起来几乎一样！这就是结构和类的问题，它们非常相似。尽管如此，还是有很多重要的区别需要注意。</p><h2 id="fc93" class="oi mn it bd mo oj ok dn ms ol om dp mw lt on oo my lx op oq na mb or os nc ot bi translated">值类型与引用类型</h2><p id="98fc" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">最重要的区别之一是，结构是值类型，而类是引用类型。尽管这可能是一篇独立的博文，但简短的解释应该足以理解这种差异。</p><p id="c8c6" class="pw-post-body-paragraph lk ll it lm b ln nl ju lp lq nm jx ls lt nz lv lw lx oa lz ma mb ob md me lj im bi translated">对类实例的引用共享单个数据，这意味着该类中的任何更改对每个引用都是可用的。下面的代码示例显示了这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="bd0e" class="pw-post-body-paragraph lk ll it lm b ln nl ju lp lq nm jx ls lt nz lv lw lx oa lz ma mb ob md me lj im bi translated">结构是一种值类型，将为每个新引用创建一个唯一的副本。您可以看到这一重要区别，因为读取计数仅在引用实例上更新:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="5bf8" class="oi mn it bd mo oj ok dn ms ol om dp mw lt on oo my lx op oq na mb or os nc ot bi translated">安全突变的好处</h2><p id="76dd" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">有了这一点，结构就有了安全突变的好处，因为你可以相信应用程序的其他部分不会同时改变数据。这使得操作代码变得更加容易，在多线程环境中尤其有用，因为在多线程环境中，不同的线程可能会同时改变数据。这可能会产生难以调试的令人讨厌的错误。</p><p id="6598" class="pw-post-body-paragraph lk ll it lm b ln nl ju lp lq nm jx ls lt nz lv lw lx oa lz ma mb ob md me lj im bi translated">在没有变异的情况下，两个类和结构的行为完全相同，变异的好处不再起作用。</p><h2 id="6712" class="oi mn it bd mo oj ok dn ms ol om dp mw lt on oo my lx op oq na mb or os nc ot bi translated">结构和常数</h2><p id="db69" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">值类型的另一个相关区别是常量的使用。如果你够敏锐的话，你会发现<code class="fe oc od oe of b">articleStruct</code>被定义为一个变量，而不是像我们对<code class="fe oc od oe of b">articleClass</code>那样的<code class="fe oc od oe of b">let</code>常数。您可能对以下错误很熟悉:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/473c6cbe044404152e98e9c043888a0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*24a_pwFDIOv7M_yw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结构与类以及与常量的区别</p></figure><p id="2e6d" class="pw-post-body-paragraph lk ll it lm b ln nl ju lp lq nm jx ls lt nz lv lw lx oa lz ma mb ob md me lj im bi translated">只有当结构被定义为变量时，它才能被变异，并且它只会更新引用实例。</p><h2 id="74d6" class="oi mn it bd mo oj ok dn ms ol om dp mw lt on oo my lx op oq na mb or os nc ot bi translated">结构免费获得一个初始化器</h2><p id="42eb" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">如果你回头比较上面的代码示例，你会发现<code class="fe oc od oe of b">ArticleClass</code>有一个定义好的初始化器，这是类所需要的。然而，结构可以免费获得一个初始化器。</p><p id="c897" class="pw-post-body-paragraph lk ll it lm b ln nl ju lp lq nm jx ls lt nz lv lw lx oa lz ma mb ob md me lj im bi translated">这在Swift 5.1中实现的<a class="ae ky" href="https://github.com/apple/swift-evolution/blob/master/proposals/0242-default-values-memberwise.md" rel="noopener ugc nofollow" target="_blank"> SE-242 </a>中变得更好，它为结构添加了成员式初始化器。这意味着以下区别:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="2161" class="oi mn it bd mo oj ok dn ms ol om dp mw lt on oo my lx op oq na mb or os nc ot bi translated">类允许继承</h2><p id="002f" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">类可以继承另一个类的特征，这样就像抽象类一样。一个常见的例子是从<code class="fe oc od oe of b">UIViewController</code>继承而来的定制视图控制器。</p><p id="002e" class="pw-post-body-paragraph lk ll it lm b ln nl ju lp lq nm jx ls lt nz lv lw lx oa lz ma mb ob md me lj im bi translated">有了Swift中的协议，这通常不再需要，可以用协议替代。协议可以用于类和结构，而继承只能用于类。</p><h2 id="7fb2" class="oi mn it bd mo oj ok dn ms ol om dp mw lt on oo my lx op oq na mb or os nc ot bi translated">类可以被取消初始化</h2><p id="7d6a" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">一个类允许在代码被破坏之前通过使用一个<code class="fe oc od oe of b">deinit</code>方法来执行代码。当你在一个结构中定义相同的<code class="fe oc od oe of b">deinit</code>方法时，你会得到下面的错误:</p><blockquote class="ov ow ox"><p id="bba0" class="lk ll oy lm b ln nl ju lp lq nm jx ls oz nz lv lw pa oa lz ma pb ob md me lj im bi translated">反初始化器只能在一个类中声明</p></blockquote></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="a775" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">什么时候应该使用结构或类？</h1><p id="df1f" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">Swift文档对该决定的描述如下:</p><blockquote class="ov ow ox"><p id="1d85" class="lk ll oy lm b ln nl ju lp lq nm jx ls oz nz lv lw pa oa lz ma pb ob md me lj im bi translated">类支持的额外功能是以增加复杂性为代价的。一般来说，最好使用结构，因为它们更容易推理，并在适当或必要时使用类。实际上，这意味着您定义的大多数自定义数据类型将是结构和枚举。</p></blockquote><p id="e058" class="pw-post-body-paragraph lk ll it lm b ln nl ju lp lq nm jx ls lt nz lv lw lx oa lz ma mb ob md me lj im bi translated">这解释了我们上面讨论的大多数主题。此外，当使用Cocoa类时，通常需要从<code class="fe oc od oe of b">NSObject</code>继承子类，这需要使用一个类。</p><p id="a1ef" class="pw-post-body-paragraph lk ll it lm b ln nl ju lp lq nm jx ls lt nz lv lw lx oa lz ma mb ob md me lj im bi translated">一个简单的要点列表会让你更容易做出决定。在以下情况下，您应该使用类:</p><ul class=""><li id="7aeb" class="nj nk it lm b ln nl lq nm lt nn lx no mb np lj nq nr ns nt bi translated">需要使用<code class="fe oc od oe of b">===</code>比较实例身份</li><li id="9c33" class="nj nk it lm b ln nu lq nv lt nw lx nx mb ny lj nq nr ns nt bi translated">需要共享可变状态</li><li id="50e2" class="nj nk it lm b ln nu lq nv lt nw lx nx mb ny lj nq nr ns nt bi translated">目标-C互操作性是必需的</li></ul><p id="f6f7" class="pw-post-body-paragraph lk ll it lm b ln nl ju lp lq nm jx ls lt nz lv lw lx oa lz ma mb ob md me lj im bi translated">在下列情况下，应该使用结构:</p><ul class=""><li id="474b" class="nj nk it lm b ln nl lq nm lt nn lx no mb np lj nq nr ns nt bi translated">使用<code class="fe oc od oe of b">==</code>需要比较实例数据</li><li id="7e98" class="nj nk it lm b ln nu lq nv lt nw lx nx mb ny lj nq nr ns nt bi translated">需要具有独立状态的唯一副本</li><li id="be11" class="nj nk it lm b ln nu lq nv lt nw lx nx mb ny lj nq nr ns nt bi translated">数据在多个线程中使用</li></ul><h2 id="b2f2" class="oi mn it bd mo oj ok dn ms ol om dp mw lt on oo my lx op oq na mb or os nc ot bi translated">你能给出什么黄金提示吗？</h2><p id="02bb" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">是的，我可以！尝试使用默认的结构。结构使您的代码更容易推理，并使其更容易在多线程环境中工作，这是我们在Swift中开发时经常遇到的。</p><p id="7675" class="pw-post-body-paragraph lk ll it lm b ln nl ju lp lq nm jx ls lt nz lv lw lx oa lz ma mb ob md me lj im bi translated">此外，如果您决定使用一个类，考虑将它标记为<code class="fe oc od oe of b">final</code>，并告诉编译器没有其他类继承您定义的类，以此来帮助编译器。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="4f43" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结论</h1><p id="8958" class="pw-post-body-paragraph lk ll it lm b ln ne ju lp lq nf jx ls lt ng lv lw lx nh lz ma mb ni md me lj im bi translated">希望您能够选择使用类还是结构。使用struct肯定不总是容易或可能的，但在Swift编程时，应将其视为默认选项。一旦你更频繁地使用结构，我很肯定你会习惯使用它们。</p><p id="0232" class="pw-post-body-paragraph lk ll it lm b ln nl ju lp lq nm jx ls lt nz lv lw lx oa lz ma mb ob md me lj im bi translated">如果你发现自己经常纠结于决策，你可能也会对以下内容感兴趣:</p><ul class=""><li id="a10e" class="nj nk it lm b ln nl lq nm lt nn lx no mb np lj nq nr ns nt bi translated"><a class="ae ky" href="https://www.avanderlee.com/swift/fileprivate-private-differences-explained/" rel="noopener ugc nofollow" target="_blank">文件私有vs私有</a></li><li id="25b3" class="nj nk it lm b ln nu lq nv lt nw lx nx mb ny lj nq nr ns nt bi translated"><a class="ae ky" href="https://www.avanderlee.com/swift/alamofire-vs-urlsession/" rel="noopener ugc nofollow" target="_blank">阿拉莫菲尔vs URLSession </a></li><li id="d38c" class="nj nk it lm b ln nu lq nv lt nw lx nx mb ny lj nq nr ns nt bi translated"><a class="ae ky" href="https://www.avanderlee.com/swift/compactmap-flatmap-differences-explained/" rel="noopener ugc nofollow" target="_blank">压缩图vs平面图</a></li></ul><p id="b10b" class="pw-post-body-paragraph lk ll it lm b ln nl ju lp lq nm jx ls lt nz lv lw lx oa lz ma mb ob md me lj im bi translated">谢谢！</p></div></div>    
</body>
</html>