<html>
<head>
<title>A Detailed Guide for Room Database with Kotlin, Rx, and MVVM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林、Rx和MVVM的客房数据库详细指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-detailed-guide-on-room-database-with-kotlin-rx-mvvm-ea982e9c5abe?source=collection_archive---------2-----------------------#2019-12-22">https://betterprogramming.pub/a-detailed-guide-on-room-database-with-kotlin-rx-mvvm-ea982e9c5abe?source=collection_archive---------2-----------------------#2019-12-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cad3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">浏览房间数据库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9c66c5e7736c9511c546a652f231ef4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hKaMBoqnq_DxSIrLQ82WnA.png"/></div></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="6cca" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">什么是房间数据库？</h1><p id="f917" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">在开发一些应用程序如聊天应用程序时，我们需要一个本地数据库来存储数据，以处理减少频繁加载或离线处理等情况。如果您是很久以前的开发人员，您可能已经使用SQLite数据库和SQLiteOpenHelper类来执行数据库操作。随着时间的推移，许多图书馆蓬勃发展，使开发人员的生活更容易。一个这样的图书馆是房间。</p><p id="9446" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">Room在SQLite上提供了一个抽象层，在充分利用SQLite的能力的同时，允许更健壮的数据库访问。</p><p id="2620" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">简单地说，Room是SQLite上的一个抽象层，以提供简化的编码。如今，我们可以看到许多应用程序使用Room，因为它提供了很多好处。如果您在应用程序中使用SQLite，请迁移到Room。Room持久性库非常方便易用。</p><h2 id="ed50" class="mu lc it bd ld mv mw dn lh mx my dp ll mc mz na ln mg nb nc lp mk nd ne lr nf bi translated">为什么使用房间？</h2><ol class=""><li id="f391" class="ng nh it lv b lw lx lz ma mc ni mg nj mk nk mo nl nm nn no bi translated">我们可以消除与SQLite数据库相关的大部分样板代码</li><li id="169b" class="ng nh it lv b lw np lz nq mc nr mg ns mk nt mo nl nm nn no bi translated">对于SQLite，没有对原始SQLite查询的编译时验证。但是在Room中，有一个SQL查询的编译时验证。<code class="fe nu nv nw nx b">@Query</code>和<code class="fe nu nv nw nx b">@Entity</code>在编译时被检查，以消除运行时的问题。它不仅检查语法，还检查丢失的表。</li><li id="3723" class="ng nh it lv b lw np lz nq mc nr mg ns mk nt mo nl nm nn no bi translated">更容易实现和维护。</li><li id="cdfd" class="ng nh it lv b lw np lz nq mc nr mg ns mk nt mo nl nm nn no bi translated">这个房间是为了配合LiveData和RxJava进行数据观察而构建的，而SQLite不是。</li></ol></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="b682" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">房间的组成</h1><p id="6fd7" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">在深入研究代码之前，让我们先了解一下Room的基本原理。我们主要需要了解三个组件。它们是:</p><h2 id="e524" class="mu lc it bd ld mv mw dn lh mx my dp ll mc mz na ln mg nb nc lp mk nd ne lr nf bi translated">实体</h2><p id="38de" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">一个实体代表数据库中的一个表。教室为每个有<code class="fe nu nv nw nx b">@Entity</code>注释的班级创建一个表格。类中的每个字段都是表中的一列，我们可以通过用<code class="fe nu nv nw nx b">@ColumnInfo</code> (name = "column_name ")注释该字段来为该列指定一个特定的名称。我们使用注释<code class="fe nu nv nw nx b">@PrimaryKey</code>指定的每个表应该至少有一个主键字段。</p><h2 id="1eff" class="mu lc it bd ld mv mw dn lh mx my dp ll mc mz na ln mg nb nc lp mk nd ne lr nf bi translated">数据访问对象(Data Access Object)</h2><p id="7871" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">数据访问对象(DAO)是一个带有注释<code class="fe nu nv nw nx b">@Dao</code>的接口，它包含用于访问数据库的方法。我们将在Dao中创建抽象方法来执行CRUD操作。房间支持道<code class="fe nu nv nw nx b">@Insert</code>、<code class="fe nu nv nw nx b">@Update</code>、<code class="fe nu nv nw nx b">@Delete</code>、<code class="fe nu nv nw nx b">@Query</code>中的以下标注。以前<strong class="lv iu"> </strong>我们在SQLite中使用光标对象，但是在Dao中我们简单地用注释定义各自的查询。一切都简化了。</p><h2 id="34aa" class="mu lc it bd ld mv mw dn lh mx my dp ll mc mz na ln mg nb nc lp mk nd ne lr nf bi translated">数据库ˌ资料库</h2><p id="7751" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">该数据库包含数据库容器，并作为应用程序持久化关系数据的底层连接的主要访问点。</p><p id="5192" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">用<code class="fe nu nv nw nx b">@Database</code>标注的类应该满足以下条件:</p><ul class=""><li id="abf8" class="ng nh it lv b lw mp lz mq mc ny mg nz mk oa mo ob nm nn no bi translated">做一个扩展<code class="fe nu nv nw nx b">RoomDatabase</code>的抽象类。</li><li id="ec51" class="ng nh it lv b lw np lz nq mc nr mg ns mk nt mo ob nm nn no bi translated">包括所有<code class="fe nu nv nw nx b">entities</code> <strong class="lv iu"> </strong>和<strong class="lv iu"> </strong> <code class="fe nu nv nw nx b">database version</code> <strong class="lv iu"> </strong>与数据库相关的列表。</li><li id="f293" class="ng nh it lv b lw np lz nq mc nr mg ns mk nt mo ob nm nn no bi translated">包含一个没有参数的抽象方法，并返回用<code class="fe nu nv nw nx b">@Dao</code>注释的类。</li></ul><p id="b313" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">属性<code class="fe nu nv nw nx b">version</code>用于定义数据库的版本，而<code class="fe nu nv nw nx b">entities</code>用于定义该数据库将包含的所有表的列表。在运行时，您可以通过调用<code class="fe nu nv nw nx b">Room.databaseBuilder()</code>或<code class="fe nu nv nw nx b">Room.inMemoryDatabaseBuilder()</code>来获取Databse的实例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/dd67d768b026da2ae533204e92da624c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*jT94pc71uD_A2TPN_E2ulg.png"/></div><p class="od oe gj gh gi of og bd b be z dk translated">三个部分之间的关系。图片来源:developer.android.com</p></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="f1f6" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">让我们开始编码吧</h1><p id="920f" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">我们在这里要讨论的例子是在单击第一个按钮时保存以简单形式给出的细节，并在单击第二个按钮时检索它们。还有一个删除记录的删除按钮。在这里，我们将使用科特林，Rx与MVVM，使我们的工作更容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/72865fce00ca6ed3385baeee52eeea61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CRvnDK8qXqHeJQ9VwHqmZA.jpeg"/></div></div></figure><blockquote class="oi oj ok"><p id="36de" class="lt lu ol lv b lw mp ju ly lz mq jx mb om mr me mf on ms mi mj oo mt mm mn mo im bi translated"><em class="it">从2.1.0-alpha01开始，标注有</em> <code class="fe nu nv nw nx b"><em class="it">@Insert</em></code> <em class="it">、</em> <code class="fe nu nv nw nx b"><em class="it">@Delete</em></code> <em class="it">或</em> <code class="fe nu nv nw nx b"><em class="it">@Update</em></code> <em class="it">的刀方法支持Rx返回类型</em> <code class="fe nu nv nw nx b"><em class="it">Completable</em></code> <em class="it">、</em> <code class="fe nu nv nw nx b"><em class="it">Maybe&lt;T&gt;</em></code> <em class="it">和</em> <code class="fe nu nv nw nx b"><em class="it"> Single&lt;T&gt;</em></code> <em class="it">。</em></p></blockquote><h2 id="9914" class="mu lc it bd ld mv mw dn lh mx my dp ll mc mz na ln mg nb nc lp mk nd ne lr nf bi translated"><strong class="ak">第一步</strong>:在<strong class="ak"> build.gradle </strong>中添加依赖关系</h2><pre class="kj kk kl km gt op nx oq or aw os bi"><span id="7cf1" class="mu lc it nx b gy ot ou l ov ow">// Room Database with Rx<br/>implementation "androidx.room:room-runtime:2.2.2"<br/>implementation "androidx.room:room-rxjava2:2.2.2"<br/>kapt "androidx.room:room-compiler:2.2.2"<br/>implementation 'io.reactivex.rxjava2:rxandroid:2.1.1'</span><span id="8fcd" class="mu lc it nx b gy ox ou l ov ow">implementation"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"<br/>implementation 'androidx.appcompat:appcompat:1.1.0'<br/>implementation 'androidx.core:core-ktx:1.1.0'<br/>implementation 'androidx.constraintlayout:constraintlayout:1.1.3'<br/>implementation 'androidx.recyclerview:recyclerview:1.1.0'<br/><br/>// Lifecycle<br/>implementation "androidx.lifecycle:lifecycle-extensions:2.1.0"<br/>annotationProcessor "androidx.lifecycle:lifecycle-compiler:2.1.0"<br/>kapt "androidx.lifecycle:lifecycle-compiler:2.1.0"</span></pre><h2 id="d493" class="mu lc it bd ld mv mw dn lh mx my dp ll mc mz na ln mg nb nc lp mk nd ne lr nf bi translated"><strong class="ak">步骤2: </strong>创建一个模型类实体</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="c747" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">如上所述，每个实体代表一个表。在我们的例子中，<code class="fe nu nv nw nx b">PersonData</code>类将是数据库中的表。</p><h2 id="5f2d" class="mu lc it bd ld mv mw dn lh mx my dp ll mc mz na ln mg nb nc lp mk nd ne lr nf bi translated"><strong class="ak">第三步:</strong>让我们创建一个<strong class="ak">刀</strong></h2><p id="2cf0" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">我们已经定义了表结构，现在是时候按照我们的要求定义CRUD操作了。数据访问对象(DAO) <strong class="lv iu"> </strong>只不过是一个我们定义方法的接口。<code class="fe nu nv nw nx b">PersobalDataDao</code> <strong class="lv iu"> </strong>是我们这里的刀，有基本的<code class="fe nu nv nw nx b">@Insert</code>、<code class="fe nu nv nw nx b">@Delete</code>、<code class="fe nu nv nw nx b">@Query</code> <strong class="lv iu"> </strong>操作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="ec1c" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated"><code class="fe nu nv nw nx b">@Insert</code>有一个参数<code class="fe nu nv nw nx b">onConflict </code>，当我们试图插入一个已经在表中的带有键的列时，这个参数很有用，<code class="fe nu nv nw nx b">OnConflictStrategy</code> <strong class="lv iu"> </strong>有三个选项Abort、Replace和Ignore。</p><p id="3120" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">中止:<strong class="lv iu"> </strong>中止交易。交易被滚动。</p><p id="6dec" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">替换:<strong class="lv iu"> </strong>替换旧数据，继续交易。</p><p id="c7fa" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">忽略:<strong class="lv iu"> </strong>忽略冲突。</p><p id="b517" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated"><code class="fe nu nv nw nx b">@Query</code>注释帮助我们编写与数据相关的SQL查询。</p><h2 id="1b6a" class="mu lc it bd ld mv mw dn lh mx my dp ll mc mz na ln mg nb nc lp mk nd ne lr nf bi translated">步骤4:现在是时候创建我们的数据库类了</h2><p id="25c2" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">为了创建一个数据库类，我们需要创建一个扩展<code class="fe nu nv nw nx b">RoomDatabase</code>的抽象类。这个类用<code class="fe nu nv nw nx b">@Database</code>标注，有所有<code class="fe nu nv nw nx b">entities</code>、<code class="fe nu nv nw nx b">database</code>、<code class="fe nu nv nw nx b">version</code>和<code class="fe nu nv nw nx b">Dao</code>的详细信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="051b" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">现在我们完成了与数据库相关的事情。让我们创建一个活动和视图模型来执行操作。</p><p id="847a" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">第一步:创建一个XML文件</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="9574" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">第二步:创建一个<code class="fe nu nv nw nx b">ViewModel</code>类</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="e12e" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated"><strong class="lv iu">第三步</strong>:创建一个<code class="fe nu nv nw nx b">MainActivity</code>类</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="fd81" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated"><strong class="lv iu">步骤4: </strong>由于我们使用了一个适配器来显示已保存项目的列表，所以让我们来看看它的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="04b3" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">由于一切都已设置好，如果我们现在运行应用程序，我们将会看到如下表格，我们可以在其中保存数据。在输入详细信息后，我们可以检索已保存数据的列表并将其填充到<code class="fe nu nv nw nx b">RecyclerView</code>中，并且可以在单击删除按钮时删除已保存的记录。</p><p id="ea01" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">对于高级的东西，让它更深入。</p><p id="3b45" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">技巧1:我们可以通过一次尝试将单个项目或项目数组或可变数量的项目插入数据库。</p><pre class="kj kk kl km gt op nx oq or aw os bi"><span id="3598" class="mu lc it nx b gy ot ou l ov ow">@Dao<br/>interface PersonalDataDao {<br/><br/>    @Insert(onConflict = OnConflictStrategy.<em class="ol">REPLACE</em>)<br/>    fun insertPersonData(data:PersonData) : Completable<br/><br/>    @Insert(onConflict = OnConflictStrategy.<em class="ol">REPLACE</em>)<br/>    fun insertPersonDataList(dataList:ArrayList&lt;PersonData&gt;):   .   Completable<br/><br/>    @Insert(onConflict = OnConflictStrategy.<em class="ol">REPLACE</em>)<br/>    fun insertPersonDatas(data:PersonData,data2:PersonData) : Completable<br/><br/>}</span></pre><p id="413f" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">同样的情况可以用<code class="fe nu nv nw nx b">@Update</code> <strong class="lv iu"> </strong>和<code class="fe nu nv nw nx b">@Delete</code>来表示</p><p id="be51" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">技巧2: <strong class="lv iu"> </strong>我们已经看到了关于原语插入；让我们探索对象类型插入。<code class="fe nu nv nw nx b">@Embedded</code>用于存储SQL不直接支持的<code class="fe nu nv nw nx b">data-types</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="530c" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">提示3: <code class="fe nu nv nw nx b">TypeConverter</code> <strong class="lv iu"> </strong>允许您将特定的自定义类型持久化到数据库类型中。<code class="fe nu nv nw nx b">TypeConverter</code>被添加到元素的作用域中，所以如果你把它放在一个类/接口上，实体和DAO中的所有方法/字段都可以使用转换器。</p><pre class="kj kk kl km gt op nx oq or aw os bi"><span id="58b2" class="mu lc it nx b gy ot ou l ov ow">data class PersonData{<br/> @TypeConverters(SampleConverter::class)<br/> @ColumnInfo(name = "list_parents")<br/> var listParent: List&lt;Parent&gt;?<br/>}</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="7843" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">目前就这些。我将在以后的文章中写更多关于房间的高级概念。我希望你喜欢阅读这篇文章。如果你觉得有用，请分享给你的朋友。</p><p id="ca08" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">请让我知道你的建议和意见。</p><p id="0489" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">感谢阅读…</p></div></div>    
</body>
</html>