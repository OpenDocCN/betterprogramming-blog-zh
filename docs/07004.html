<html>
<head>
<title>Fun (or Not) With Golang Errors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang错误有趣(或不有趣)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/fun-or-not-with-golang-errors-26b2b0e231c5?source=collection_archive---------5-----------------------#2020-11-25">https://betterprogramming.pub/fun-or-not-with-golang-errors-26b2b0e231c5?source=collection_archive---------5-----------------------#2020-11-25</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="381c" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">我试图解决的6个与错误相关的问题</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/345d4f2f463067dc133866ff067d8c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aK0Ytcj17w9xohTJ"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@gerandeklerk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Geran de Klerk </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="0c3d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我喜欢Go，并且已经用它写了近十年的代码，但是处理错误一直是一场斗争。我之前的公司是世界上第一批在生产中使用Golang的公司之一，从第一天起，我就一直在思考如何最好地处理错误。不知何故，事情总是感觉不对，所以最近我开始真正地用它们做实验，让使用它们感觉良好。</p><p id="d4a6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这些是我想解决的问题:</p><ul class=""><li id="7499" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">如何在错误发生的地方获得堆栈跟踪？</li><li id="7e90" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">我应该在何时何地为错误写日志输出？</li><li id="f651" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">如何区分我想向用户显示的错误和我想在日志中显示的内容？</li><li id="044f" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">当我想记录错误时，如何添加上下文以便使用结构化日志记录？</li><li id="8647" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">如何减少错误处理和日志记录的代码量？</li><li id="2be6" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">我如何遵循常见的围棋最佳实践，比如戴夫·切尼<a class="ae kz" href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" rel="noopener ugc nofollow" target="_blank">建议的那些实践，并完成上述任务？</a></li></ul><p id="108f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">什么都试过至少一次，就是想看看感觉如何。</p><p id="6443" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，在最深处进行日志记录，这样我就可以在日志和适当的上下文中获得堆栈跟踪，然后返回错误。像<a class="ae kz" href="https://github.com/uber-go/zap" rel="noopener ugc nofollow" target="_blank">优步的Zap </a>这样的日志库将打印堆栈跟踪和结构化内容:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mk ml l"/></div></figure><p id="14a1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这对我来说总是有点难看，因为每当你得到一个错误时，它需要额外的一行来记录。这也意味着通过显式地将<code class="fe mm mn mo mp b">logger</code>作为参数添加到每个函数或者<a class="ae kz" href="https://blog.gopheracademy.com/advent-2016/context-logging/" rel="noopener ugc nofollow" target="_blank">使用上下文</a>来传递<code class="fe mm mn mo mp b">logger</code>(更简洁的方式)。有些人会说把它加到上下文中也不是一个好主意。</p><p id="ff45" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您不小心，并且没有更深入地检查，您不可避免地会不止一次地记录同一个错误。所以你会得到这样的结果:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mk ml l"/></div></figure><p id="6020" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以看到这是怎么回事，这不是一个快乐的地方！</p><p id="7c74" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当你在开发一个API时(可能是我们大多数人)，事情会变得更糟，比如这样的代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mk ml l"/></div></figure><p id="52e4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在变得非常非常丑陋。所有这些多余的无用代码在每次错误检查中都随处可见(在Go中，到处都有错误检查)。</p><p id="9921" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">那么一个可怜的围棋开发者该怎么办呢？</p></div><div class="ab cl mq mr hy ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="in io ip iq ir"><h1 id="8e8a" class="mx my iu bd mz na nb nc nd ne nf ng nh ka ni kb nj kd nk ke nl kg nm kh nn no bi translated">我最近的围棋错误实验</h1><p id="1274" class="pw-post-body-paragraph la lb iu lc b ld np jv lf lg nq jy li lj nr ll lm ln ns lp lq lr nt lt lu lv in bi translated">我想我终于找到了一种相当优雅的方式来处理上面的一切，同时将错误处理代码保持在最少。我自己心中的一个启示。</p><p id="5240" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我有一些用于实验的GitHub repos，在这一节中我将特别提到一个叫做<a class="ae kz" href="https://github.com/treeder/gotils" rel="noopener ugc nofollow" target="_blank"> gotils </a>的。</p><h2 id="75a5" class="nu my iu bd mz nv nw dn nd nx ny dp nh lj nz oa nj ln ob oc nl lr od oe nn of bi translated">步骤1:向上下文添加上下文</h2><p id="9191" class="pw-post-body-paragraph la lb iu lc b ld np jv lf lg nq jy li lj nr ll lm ln ns lp lq lr nt lt lu lv in bi translated">与其将上下文添加到您的<code class="fe mm mn mo mp b">logger</code>(结构化字段)，不如将它们添加到Go上下文:</p><pre class="kk kl km kn gu og mp oh oi aw oj bi"><span id="951d" class="nu my iu mp b gz ok ol l om on">ctx = gotils.With(ctx, "foo", "bar")</span></pre><p id="6101" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这样做的好处是，您可以在任何地方使用这些上下文字段，而不仅仅是日志库。这只是一个基本的条目图。在上下文中添加上下文看起来很合适。</p><h2 id="6327" class="nu my iu bd mz nv nw dn nd nx ny dp nh lj nz oa nj ln ob oc nl lr od oe nn of bi translated">步骤2:向错误添加上下文和堆栈跟踪</h2><p id="65b9" class="pw-post-body-paragraph la lb iu lc b ld np jv lf lg nq jy li lj nr ll lm ln ns lp lq lr nt lt lu lv in bi translated">让我们将堆栈和上下文添加到我们返回的错误中，而不是尝试深入记录以便获得正确的堆栈跟踪和上下文:</p><pre class="kk kl km kn gu og mp oh oi aw oj bi"><span id="8f9d" class="nu my iu mp b gz ok ol l om on">if err != nil {<br/>    return gotils.C(ctx).Errorf("error on x: %v", err)<br/>}</span></pre><p id="3520" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe mm mn mo mp b">gotils.Errorf</code>函数包装您的错误，添加当前堆栈以及上下文字段映射，并返回一个包含该信息的新错误。</p><h2 id="88bc" class="nu my iu bd mz nv nw dn nd nx ny dp nh lj nz oa nj ln ob oc nl lr od oe nn of bi translated">步骤3:在入口点记录并向用户返回错误响应</h2><p id="bed1" class="pw-post-body-paragraph la lb iu lc b ld np jv lf lg nq jy li lj nr ll lm ln ns lp lq lr nt lt lu lv in bi translated">如果这是一个API，并且我们得到了一个错误，那么我们只在入口点(即HTTP处理程序)处理错误:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mk ml l"/></div></figure><p id="00de" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以现在我们已经从应用程序的内部删除了所有难看的错误处理和日志代码，我们只在边缘<strong class="lc iv">做一次<em class="oo">。</em></strong></p><h2 id="9a15" class="nu my iu bd mz nv nw dn nd nx ny dp nh lj nz oa nj ln ob oc nl lr od oe nn of bi translated">进一步减少日志记录和错误处理</h2><p id="b2c5" class="pw-post-body-paragraph la lb iu lc b ld np jv lf lg nq jy li lj nr ll lm ln ns lp lq lr nt lt lu lv in bi translated">为了更好地进行这种处理，可以尝试使用一个<code class="fe mm mn mo mp b">ErrorHandler</code>，让您的HTTP处理程序返回一个错误。这意味着我们不需要在每个处理程序中处理错误——只需要在一个地方包装所有其他的处理程序。这看起来像下面这样:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mk ml l"/></div></figure><p id="2853" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后在整个应用程序中有一个地方处理日志记录和返回错误。</p><p id="fcfb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以看到一个<a class="ae kz" href="https://github.com/treeder/gotils/blob/master/http.go#L53" rel="noopener ugc nofollow" target="_blank">处理<code class="fe mm mn mo mp b">UserErrors</code>之类的</a>T3的完整例子。</p><h2 id="06cb" class="nu my iu bd mz nv nw dn nd nx ny dp nh lj nz oa nj ln ob oc nl lr od oe nn of bi translated">特定于用户的错误，向用户隐藏内部错误并返回信息性消息</h2><p id="12be" class="pw-post-body-paragraph la lb iu lc b ld np jv lf lg nq jy li lj nr ll lm ln ns lp lq lr nt lt lu lv in bi translated">通常，您不希望您的用户看到程序内部发生的错误(例如，数据库错误)。您可能不想将<code class="fe mm mn mo mp b">sql.ErrTxDone</code>发送回您的用户，但是您可能希望记录它或者以某种方式处理它。</p><p id="ed7a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">处理它的一种方法是只返回一般性的错误，比如一个500内部服务器错误，如果一个错误发生了，但是这是非常严格的，你不能向用户返回一个关于到底哪里出错了的详细响应。例如，如果只是无效的输入，您可能希望返回类似“字段X无效”的消息</p><p id="6b79" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以我们需要一种方法来区分内部使用的错误消息和用户使用的错误消息。为此，我做了一个<code class="fe mm mn mo mp b">UserError</code>界面:</p><pre class="kk kl km kn gu og mp oh oi aw oj bi"><span id="6ca2" class="nu my iu mp b gz ok ol l om on">type UserError interface {<br/>   error<br/>   UserError() string<br/>}</span></pre><p id="6733" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它是这样使用的:</p><pre class="kk kl km kn gu og mp oh oi aw oj bi"><span id="eebb" class="nu my iu mp b gz ok ol l om on">return gotils.UserErrorf(err, "field %v is invalid", fieldname)</span></pre><p id="254c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后到了该回复的时候:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mk ml l"/></div></figure><p id="b628" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您想返回特定的HTTP状态代码，还有一个<code class="fe mm mn mo mp b">gotils.HTTPError</code>。</p><h2 id="bcf5" class="nu my iu bd mz nv nw dn nd nx ny dp nh lj nz oa nj ln ob oc nl lr od oe nn of bi translated">如何在日志库中使用它们</h2><p id="8e6f" class="pw-post-body-paragraph la lb iu lc b ld np jv lf lg nq jy li lj nr ll lm ln ns lp lq lr nt lt lu lv in bi translated">您的日志库不知道如何自动提取堆栈或字段，但幸运的是，这相当容易。更好的是，在你的整个应用程序中可能只有一行真正使用了你的日志库！</p><p id="9293" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您在自己的代码中尝试上述方法，请确保有几个方法可以从错误中获取上下文字段和堆栈。<code class="fe mm mn mo mp b">gotils</code>有<code class="fe mm mn mo mp b">Stacked</code>和<code class="fe mm mn mo mp b">Fielded</code>接口提供这些方法，如果你愿意，你可以复制或者直接使用:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mk ml l"/></div></figure><p id="f5a5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">调用它们来获得正确的信息，并将其传递给日志库。</p><p id="104e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<a class="ae kz" href="https://github.com/treeder/gcputils" rel="noopener ugc nofollow" target="_blank"> gcputils repo </a>中有一个这样的例子，它会以Google Cloud logging的适当格式记录所有这些内容，只需简单地调用:</p><pre class="kk kl km kn gu og mp oh oi aw oj bi"><span id="b484" class="nu my iu mp b gz ok ol l om on">gcputils.Printf("%v", err)</span></pre></div><div class="ab cl mq mr hy ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="in io ip iq ir"><h1 id="7246" class="mx my iu bd mz na nb nc nd ne nf ng nh ka ni kb nj kd nk ke nl kg nm kh nn no bi translated">结论</h1><p id="704c" class="pw-post-body-paragraph la lb iu lc b ld np jv lf lg nq jy li lj nr ll lm ln ns lp lq lr nt lt lu lv in bi translated">这些事情让我清理了许多总是困扰我的混乱代码，但我太忙了(或者说太懒了)以至于想不出更好的方法。直到最近，也就是说，当我有足够的时间和精力去尝试日志和错误处理的时候。</p><p id="d1ae" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">尝试这里讨论的一些概念，看看你有什么想法。我很想听到你的反馈，或者了解你是如何处理这些事情的。</p><blockquote class="op"><p id="426c" class="oq or iu bd os ot ou ov ow ox oy lv dk translated">“犯错是人之常情；宽恕，神圣的。”——<a class="ae kz" href="https://www.brainyquote.com/quotes/alexander_pope_101451" rel="noopener ugc nofollow" target="_blank">亚历山大·波普</a></p></blockquote></div></div>    
</body>
</html>