<html>
<head>
<title>A Look at the New “Async Swift Algorithms” Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">看看新的“异步Swift算法”包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/new-package-look-at-swift-async-algorithms-3f1a25e8efd9?source=collection_archive---------8-----------------------#2022-04-28">https://betterprogramming.pub/new-package-look-at-swift-async-algorithms-3f1a25e8efd9?source=collection_archive---------8-----------------------#2022-04-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6afc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">苹果发布了一个异步swift算法包，介绍了使用异步序列的有用方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/25027787d1a3169fd7e2c710f45f1160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pjysqw3GBFdQfUqwqRiAgg.png"/></div></div></figure><p id="cb6a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大约一个月前，苹果发布了第一个版本的<a class="ae ln" href="https://github.com/apple/swift-async-algorithms" rel="noopener ugc nofollow" target="_blank">异步swift算法</a>包。它提供了与不久前引入的异步序列一起使用的工具和算法。这个包专注于实现已经众所周知的工具，如<code class="fe lo lp lq lr b">zip</code>以及及时处理的新特性(wow)。它还提供了创建和管理异步序列的更复杂的方法。</p><blockquote class="ls lt lu"><p id="14c2" class="kr ks lv kt b ku kv jr kw kx ky ju kz lw lb lc ld lx lf lg lh ly lj lk ll lm ij bi translated">💥该模块的最新版本是<code class="fe lo lp lq lr b">0.0.1</code>，这意味着它仍在开发中。所以，有些方法还不可用，有些可能会改变或出现。大多数情况下，这篇文章是为了了解新的特性，可能的话，规划你的代码，记住这些特性将来会出现</p></blockquote><h1 id="75f9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">装置</h1><p id="06ac" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">新包通过Swift PM分发。要将其添加到您的项目中，您需要将其作为一个依赖项添加到Xcode项目<code class="fe lo lp lq lr b">File &gt; Add Packages</code>中。</p><p id="6207" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">或者将其添加到您的<code class="fe lo lp lq lr b">Package.swift</code>文件中:</p><pre class="kg kh ki kj gt mw lr mx my aw mz bi"><span id="f493" class="na ma iq lr b gy nb nc l nd ne">.package(url: "https://github.com/apple/swift-async-algorithms"),</span></pre><p id="2ee6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不要忘记将依赖项添加到可执行文件中:</p><pre class="kg kh ki kj gt mw lr mx my aw mz bi"><span id="6498" class="na ma iq lr b gy nb nc l nd ne">.target(name: "&lt;target&gt;", dependencies: [<br/>    .product(name: "AsyncAlgorithms", package: "swift-async-algorithms"),<br/>]),</span></pre><p id="3226" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">添加<code class="fe lo lp lq lr b">import AsyncAlgorithms</code>后，该模块将在您的项目中可用。</p><blockquote class="ls lt lu"><p id="9092" class="kr ks lv kt b ku kv jr kw kx ky ju kz lw lb lc ld lx lf lg lh ly lj lk ll lm ij bi translated">💥正如我提到的，该模块仍在开发中。因此，您需要安装<a class="ae ln" href="https://www.swift.org/download/#trunk-development-main" rel="noopener ugc nofollow" target="_blank"> Swift主干开发工具链</a>来访问所有功能。不过，其中一些马上就有了！</p></blockquote><h1 id="0cf9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">创建异步序列</h1><p id="3036" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">为了测试新模块提供的所有漂亮的功能，我们首先需要创建一个异步序列。该软件包引入了新的方法来做到这一点。</p><h2 id="5c66" class="na ma iq bd mb nf ng dn mf nh ni dp mj la nj nk ml le nl nm mn li nn no mp np bi translated">属性<code class="fe lo lp lq lr b">async</code></h2><p id="be91" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">该模块为<code class="fe lo lp lq lr b">Sequence</code>协议增加了如下扩展。</p><pre class="kg kh ki kj gt mw lr mx my aw mz bi"><span id="e47d" class="na ma iq lr b gy nb nc l nd ne">extension Sequence {<br/>  public var async: AsyncLazySequence&lt;Self&gt; { get }<br/>}</span></pre><p id="f48c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其中<code class="fe lo lp lq lr b">AsyncLazySequence</code>符合<code class="fe lo lp lq lr b">AsyncSequence</code>。</p><pre class="kg kh ki kj gt mw lr mx my aw mz bi"><span id="a050" class="na ma iq lr b gy nb nc l nd ne">public struct AsyncLazySequence&lt;Base: Sequence&gt;: AsyncSequence {<br/>}<br/><br/>extension AsyncLazySequence: Sendable where Base: Sendable {<br/>	...<br/>}<br/>extension AsyncLazySequence.Iterator: Sendable where Base.Iterator: Sendable {<br/>}</span></pre><blockquote class="ls lt lu"><p id="2c72" class="kr ks lv kt b ku kv jr kw kx ky ju kz lw lb lc ld lx lf lg lh ly lj lk ll lm ij bi translated">💡例如，使用<code class="fe lo lp lq lr b">async</code>属性，我们可以将任何现有的序列转换成<code class="fe lo lp lq lr b">AsyncSequence</code>，以便在一些异步API中使用它们。</p></blockquote><pre class="kg kh ki kj gt mw lr mx my aw mz bi"><span id="5dd2" class="na ma iq lr b gy nb nc l nd ne">let numbers = [1, 2, 3, 4].async<br/>let characters = "Hello, world".async<br/>let items = [1: "one", 2: "two", 3: "three"].async</span></pre><p id="9b34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，以这种方式创建<code class="fe lo lp lq lr b">AsyncSequence</code>并没有真正带来好处，因为所有的元素都已经在这里了，并且可以立即使用。创建<code class="fe lo lp lq lr b">AsyncSequence</code>还有更有用的方法。</p><h2 id="0610" class="na ma iq bd mb nf ng dn mf nh ni dp mj la nj nk ml le nl nm mn li nn no mp np bi translated">异步信道和异步增长信道</h2><p id="cacc" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">如果你知道其他语言中的<code class="fe lo lp lq lr b">Future</code>或<code class="fe lo lp lq lr b">Promise</code>是什么，那么<code class="fe lo lp lq lr b">AsyncChannel</code>你一定会很熟悉。除了它提供了一种传输值的序列<strong class="kt ir">的方式。</strong></p><blockquote class="ls lt lu"><p id="f87e" class="kr ks lv kt b ku kv jr kw kx ky ju kz lw lb lc ld lx lf lg lh ly lj lk ll lm ij bi translated">❗Channel's元素必须符合<code class="fe lo lp lq lr b">Sendable</code>协议，这基本上意味着跨并发域使用公共API是安全的。<br/> <br/>所有基本类型自动符合它。对于自定义类型，您需要在使用前添加一致性。</p></blockquote><p id="0706" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有一个关于<code class="fe lo lp lq lr b">AsyncChannel</code>用法的非常简单的例子。</p><pre class="kg kh ki kj gt mw lr mx my aw mz bi"><span id="9f91" class="na ma iq lr b gy nb nc l nd ne">let channel = AsyncChannel&lt;String&gt;()<br/>Task {<br/>    for word in ["Hello", "from", "async", "channel"] {<br/>      await channel.send(word)<br/>    }<br/>    await channel.finish()<br/>}<br/><br/>for await message in channel {<br/>    print(message)<br/>}</span></pre><p id="95c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出:</p><pre class="kg kh ki kj gt mw lr mx my aw mz bi"><span id="2c28" class="na ma iq lr b gy nb nc l nd ne">Hello<br/>from<br/>async<br/>channel</span></pre><p id="1674" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意<code class="fe lo lp lq lr b">await</code>关键字与send和finish一起使用。这是因为通道<strong class="kt ir">实际上双向同步</strong>。这意味着<code class="fe lo lp lq lr b">send</code>等待消费，反之亦然。</p><blockquote class="ls lt lu"><p id="84f8" class="kr ks lv kt b ku kv jr kw kx ky ju kz lw lb lc ld lx lf lg lh ly lj lk ll lm ij bi translated">💡<code class="fe lo lp lq lr b">await channel.send()</code>等待，直到发送的值以任何方式被使用。这样，为通道产生价值的一方不会产生比接收方能够消耗的更多的价值</p></blockquote><p id="a890" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lo lp lq lr b">AsyncThrowingStream</code>几乎相同，除了它提供了<code class="fe lo lp lq lr b">fail(_ error: Error)</code>方法，可用于向通道的消费者抛出异常。</p><pre class="kg kh ki kj gt mw lr mx my aw mz bi"><span id="e0e1" class="na ma iq lr b gy nb nc l nd ne">let channel = AsyncThrowingChannel&lt;String, Error&gt;()<br/><br/>...<br/><br/>for try await message in channel {<br/>    print(message)<br/>}</span></pre><h2 id="530f" class="na ma iq bd mb nf ng dn mf nh ni dp mj la nj nk ml le nl nm mn li nn no mp np bi translated">并转换回来</h2><p id="ed6d" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">该模块为三种主要类型添加了初始化器:<code class="fe lo lp lq lr b">Array</code>、<code class="fe lo lp lq lr b">Dictionary</code>和<code class="fe lo lp lq lr b">Set</code>，它们允许您通过在init期间获取所有元素来将异步序列转换为常规序列。</p><pre class="kg kh ki kj gt mw lr mx my aw mz bi"><span id="2ad3" class="na ma iq lr b gy nb nc l nd ne">let table = await Dictionary(uniqueKeysWithValues: zip(keys, values))<br/>let allItems = await Set(items.prefix(10))<br/>let allMessages = await Array(channel)</span></pre><h1 id="8124" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">操纵异步序列</h1><p id="862e" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">该模块还提供了组合异步序列的新方法。这些函数非常简单。</p><ul class=""><li id="8cf4" class="nq nr iq kt b ku kv kx ky la ns le nt li nu lm nv nw nx ny bi translated"><code class="fe lo lp lq lr b">chain(_ s1: AsyncSequence, _ s2: AsyncSequence)</code></li></ul><p id="1e40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将两个或三个异步序列按顺序链接在一起，其中结果中的元素按顺序从第一个异步序列的元素开始，然后是第二个异步序列的元素(依此类推)，或者直到出现错误。序列必须具有相同的<code class="fe lo lp lq lr b">Element</code>类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><blockquote class="ls lt lu"><p id="60a4" class="kr ks lv kt b ku kv jr kw kx ky ju kz lw lb lc ld lx lf lg lh ly lj lk ll lm ij bi translated">💥苹果注意到它可以用于两个<strong class="kt ir">或者更多的</strong>序列。不过，现在只有两三个论点可用。</p></blockquote><ul class=""><li id="6bcc" class="nq nr iq kt b ku kv kx ky la ns le nt li nu lm nv nw nx ny bi translated"><code class="fe lo lp lq lr b">joined()</code>或<code class="fe lo lp lq lr b">joined(separator: AsyncSequence)</code></li></ul><p id="fda4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将异步序列的异步序列串联在一起，其中结果按顺序从第一个异步序列的元素开始，然后是第二个异步序列的元素(依此类推)，或者直到出现错误。类似于<code class="fe lo lp lq lr b">chain()</code>，除了要连接的异步序列的数量事先未知。也可以指定分隔符。</p><ul class=""><li id="0742" class="nq nr iq kt b ku kv kx ky la ns le nt li nu lm nv nw nx ny bi translated"><code class="fe lo lp lq lr b">combineLatest(_ base1: AsyncSequence, _ base2: AsyncSequence)</code></li></ul><p id="b557" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">组合两个<em class="lv">或更多</em>序列，生成序列中可用的最新值的元组。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><ul class=""><li id="617e" class="nq nr iq kt b ku kv kx ky la ns le nt li nu lm nv nw nx ny bi translated"><code class="fe lo lp lq lr b">merge(_ base1: AsyncSequence, _ base2: AsyncSequence)</code></li></ul><p id="7a16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将序列合并成一个新序列。结果是来自两个序列的结果的组合。序列必须具有相同的<code class="fe lo lp lq lr b">Element</code>类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><blockquote class="ls lt lu"><p id="4cc7" class="kr ks lv kt b ku kv jr kw kx ky ju kz lw lb lc ld lx lf lg lh ly lj lk ll lm ij bi translated">💡考虑到没有定义哪个序列元素出现得更快，元素的顺序可以是任意的</p></blockquote><ul class=""><li id="26aa" class="nq nr iq kt b ku kv kx ky la ns le nt li nu lm nv nw nx ny bi translated"><code class="fe lo lp lq lr b">zip(_ base1: AsyncSequence, _ base2: AsyncSequence)</code></li></ul><p id="d859" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与普通的<code class="fe lo lp lq lr b">zip</code>相同，但为<code class="fe lo lp lq lr b">AsyncSequence</code>。与<code class="fe lo lp lq lr b">combineLatest</code>不同，它会等到第二个值可用，而不使用最后一个值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="2f65" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">与时间相关的函数</h1><p id="7c1b" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">听起来很棒，但是Swift不够强大，无法将<code class="fe lo lp lq lr b">await</code>放在时间本身之前。当事件发生的速度可能比预期的消耗速度快时，有一些方法可以处理这种情况。这些功能允许将<code class="fe lo lp lq lr b">AsyncSequences</code>与时间联系起来。它们可以适用于任何<code class="fe lo lp lq lr b">AsyncSequence</code>。</p><p id="9e4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于列出的两种方法，都可以指定自定义时钟。默认是<code class="fe lo lp lq lr b">ContinuousClock</code></p><h2 id="a15b" class="na ma iq bd mb nf ng dn mf nh ni dp mj la nj nk ml le nl nm mn li nn no mp np bi translated">去抖</h2><pre class="kg kh ki kj gt mw lr mx my aw mz bi"><span id="51d5" class="na ma iq lr b gy nb nc l nd ne">public func debounce&lt;C: Clock&gt;(<br/>    for interval: C.Instant.Duration, <br/>    tolerance: C.Instant.Duration? = nil, <br/>    clock: C<br/>  ) -&gt; AsyncDebounceSequence&lt;Self, C&gt;</span></pre><p id="a2f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">去抖算法在事件之间经过特定持续时间后产生元素。如果有许多事件发生，去抖将等到从最后一个事件起至少经过<code class="fe lo lp lq lr b">interval</code>时间后才发出值。</p><pre class="kg kh ki kj gt mw lr mx my aw mz bi"><span id="fa05" class="na ma iq lr b gy nb nc l nd ne">seq.debounce(for: .seconds(1))</span></pre><p id="0208" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，它将一个潜在的快速异步事件序列转换为一个等待1秒钟的窗口<strong class="kt ir">而没有事件</strong>过去的序列，然后发出一个值。</p><h2 id="36da" class="na ma iq bd mb nf ng dn mf nh ni dp mj la nj nk ml le nl nm mn li nn no mp np bi translated">喉咙</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="b26a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">节流算法产生元素，使得它们之间至少经过了特定的间隔。如果值是由base <code class="fe lo lp lq lr b">AsyncSequence</code>产生的，那么节流器不会恢复它的下一个迭代器，直到周期过去或者除非遇到一个终止事件。与<code class="fe lo lp lq lr b">debounce</code>类似，可以指定自定义时钟。</p><pre class="kg kh ki kj gt mw lr mx my aw mz bi"><span id="3b2e" class="na ma iq lr b gy nb nc l nd ne">seq.throttle(for: .seconds(1))</span></pre><p id="2cf2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，throttle会将一个潜在的快速异步事件序列转换为一个在发出值之前等待1秒钟的窗口。</p><blockquote class="ls lt lu"><p id="95d6" class="kr ks lv kt b ku kv jr kw kx ky ju kz lw lb lc ld lx lf lg lh ly lj lk ll lm ij bi translated">💡注意，去抖等待一个没有事件的窗口<strong class="kt ir"/>，而节流只是等待一个窗口。</p></blockquote><h1 id="ef0e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">最终注释</h1><p id="c9d2" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">坦率地说，观看Swift如何展现新功能以及如何开发这些新功能非常有趣。一定要查看参考资料中提到的项目GitHub，查看模块的源代码。</p><p id="035c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您对相对较新的swift并发功能没有信心，请查看我的Swift异步/等待快速指南。</p><div class="ob oc gp gr od oe"><a href="http://alexdremov.me/quick-guide-to-async-await-in-swift/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">Swift异步等待快速指南| Alex Dremov</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">Alex dre mov iniOS &amp; Swift——您需要了解的关于Swift异步新功能的一切。异步等待，主要演员…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">alexdremov.me</p></div></div><div class="on l"><div class="oo l op oq or on os kp oe"/></div></div></a></div><pre class="kg kh ki kj gt mw lr mx my aw mz bi"><span id="4ff2" class="na ma iq lr b gy nb nc l nd ne"><strong class="lr ir">Want to Connect?</strong></span><span id="42aa" class="na ma iq lr b gy ot nc l nd ne">This post was originally published on <a class="ae ln" href="https://alexdremov.me/swift-async-algorithms-module/" rel="noopener ugc nofollow" target="_blank">alexdremov.me</a></span></pre><h1 id="0d4a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">参考</h1><div class="ob oc gp gr od oe"><a href="https://github.com/apple/swift-async-algorithms" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">GitHub-apple/Swift-Async-Algorithms:Swift的异步算法</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">Swift Async Algorithms是一个异步序列和高级算法的开源包，涉及…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">github.com</p></div></div><div class="on l"><div class="ou l op oq or on os kp oe"/></div></div></a></div></div></div>    
</body>
</html>