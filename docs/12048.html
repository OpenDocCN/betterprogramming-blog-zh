<html>
<head>
<title>Kotlin/Native vs. C++ vs. Freepascal vs. Python: Measuring FPS, RAM and CPU Usage, Size of the Compiled Executable Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">kot Lin/Native vs . c++ vs . free Pascal vs . Python:测量FPS、RAM和CPU使用情况、编译后可执行文件的大小</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kotlin-native-vs-c-vs-freepascal-vs-python-a-comparison-part-2-1be9007ecf41?source=collection_archive---------3-----------------------#2022-05-08">https://betterprogramming.pub/kotlin-native-vs-c-vs-freepascal-vs-python-a-comparison-part-2-1be9007ecf41?source=collection_archive---------3-----------------------#2022-05-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5a69" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">代码库之间的比较</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f6a96ed7e444d91191691ea16b5ae295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dR8f9iZFW0iBPPQuewlrnw.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Python应用程序的Starfield动画</p></figure><p id="8864" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">大家好！正如我在这个博客系列的第一部分中所承诺的，我很高兴欢迎你进入我们旅程的第二部分，在这里我试图通过Kotlin/Native与C++、Freepascal和Python的性能以及openGL图形和编码的乐趣来找到比较的真相。</p><h2 id="92d6" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">内容</h2><ol class=""><li id="3747" class="mk ml iq kx b ky mm lb mn le mo li mp lm mq lq mr ms mt mu bi translated"><a class="ae mv" rel="noopener ugc nofollow" target="_blank" href="/kotlin-native-vs-c-freepascal-python-c1dba39752cf">原生应用的简单数学，或者今晚谁这么聪明？</a></li><li id="3c19" class="mk ml iq kx b ky mw lb mx le my li mz lm na lq mr ms mt mu bi translated">使用SDL2进行图形测试，或使用Norton Commander进行跨宇宙测试。<em class="nb"> —你在这里— </em></li></ol></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h2 id="cf7b" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">动机</h2><p id="df53" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">维亚切斯拉夫·阿尔希波夫的这篇文章启发我开始了这项研究。如果你是老极客，你应该记得旧的电脑CRT显示器有老化效应。</p><blockquote class="nm nn no"><p id="bf84" class="kv kw nb kx b ky kz jr la lb lc ju ld np lf lg lh nq lj lk ll nr ln lo lp lq ij bi translated"><em class="iq"> Wiki: </em> <a class="ae mv" href="https://en.wikipedia.org/wiki/Cathode-ray_tube#Burn-in" rel="noopener ugc nofollow" target="_blank">烧屏</a>是图像被物理“烧”入CRT的屏幕；这是由于磷光体的长时间电子轰击导致磷光体退化而发生的，并且当固定的图像或标志在屏幕上停留太长时间时发生，导致它作为“重影”图像出现，或者在严重的情况下，当CRT关闭时也发生。为了解决这个问题，电脑中使用了屏保来减少老化。老化不仅仅发生在CRT上，等离子显示器和有机发光二极管显示器也会发生老化。</p></blockquote><p id="790c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中一个著名的PC屏保是Starfield，你可以在这篇文章的标题下面看到。想象你是眼镜蛇MK3 中的指挥官詹姆森，你正在宇宙中搜寻塔戈伊德飞船。星星在四处奔忙，你比闪电快一百倍…</p><h2 id="9be7" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">从Python开始</h2><p id="ebc4" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">我对原始源代码做了一些更新，在窗口标题中打印FPS，使用其他绘图函数来获得反走样效果，并为星星添加可变半径属性，这样星星就获得了平滑的生长效果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5fca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是Python中的完整代码，但是如果你想在你的机器上重现这个，不要忘记安装<code class="fe nu nv nw nx b"><a class="ae mv" href="https://www.pygame.org/news" rel="noopener ugc nofollow" target="_blank">Pygame</a></code>库。</p><p id="4b3a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最难的是把它翻译成其他语言。<code class="fe nu nv nw nx b">Pygame</code>库本身使用<code class="fe nu nv nw nx b"><a class="ae mv" href="https://www.libsdl.org/" rel="noopener ugc nofollow" target="_blank">SDL</a></code>图形库封装与<code class="fe nu nv nw nx b">openGL</code>(或者Windows上的<code class="fe nu nv nw nx b">DirectX</code>)的底层接口。我们所需要的就是为每种语言编写我们自己的<code class="fe nu nv nw nx b">xxGame</code>引擎……Uuh。我们走吧。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h2 id="4a62" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">C++极点位置</h2><p id="69db" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">我认为，开始的简单方法是在SDL的原生平台上实现Starfield is，即C++语言，然后将其转换为Kotlin或Freepascal变体。</p><blockquote class="nm nn no"><p id="ad97" class="kv kw nb kx b ky kz jr la lb lc ju ld np lf lg lh nq lj lk ll nr ln lo lp lq ij bi translated"><em class="iq">免责声明:</em>因为我不太熟悉C++上的直接SDL编程，所以我从YouTube上Carl Birch的视频系列中学习了它的基础知识<a class="ae mv" href="https://www.youtube.com/playlist?list=PLhfAbcv9cehhkG7ZQK0nfIGJC_C-wSLrx" rel="noopener ugc nofollow" target="_blank">这里</a>我推荐它们作为一个完美的开始。</p></blockquote><p id="129b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们远离上面的Python代码，使用语言的++优势。C++有两种类可供我们使用:<code class="fe nu nv nw nx b"><strong class="kx ir">class</strong></code>本身和<code class="fe nu nv nw nx b"><strong class="kx ir">struct</strong></code>。它们之间的区别在于默认情况下类成员是如何声明的，是私有成员还是公共成员。否则，类和结构都是相似的。</p><p id="ee83" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我声明了<code class="fe nu nv nw nx b">struct <strong class="kx ir">Star</strong></code>并封装了它的创建、更新和恢复行为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="558b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它有一个默认的构造函数来调用<code class="fe nu nv nw nx b">newStar</code>函数，当这个星星离开屏幕时也会发生类似的情况。我们将使用一个<code class="fe nu nv nw nx b">Star</code>对象的数组(C++ STL中的vector ),而不是Python中的带有未命名参数的全局列表。</p><p id="af1f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，我们可以在普通的C++中使用静态数组来代替动态向量，因为我们已经知道它的大小，但是我更喜欢用一些未来增强的机会来编写代码。例如，我们可以在运行时用vector动态地增加或减少星星的数量。</p><p id="ed99" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在C++程序中我们的<code class="fe nu nv nw nx b">main</code>函数开始时，我们应该准备SDL引擎来绘图:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="41fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里将为SDL窗口和渲染上下文创建两个指针。是的，我们可以用SDL创建任意数量的窗口和渲染上下文。接下来使用的所有执行绘图的SDL函数都应该使用渲染上下文，其他一些函数需要一个窗口指针来执行。</p><p id="bdd7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是有一个小问题… SDL没有从盒子里画一个实心或空心圆的功能！多亏了Github，我在几秒钟内就找到了必要的算法。<a class="ae mv" href="https://gist.github.com/Gumichan01/332c26f6197a432db91cc4327fcabb1c" rel="noopener ugc nofollow" target="_blank">那个代码</a>使用<a class="ae mv" href="https://en.wikipedia.org/wiki/Midpoint_circle_algorithm" rel="noopener ugc nofollow" target="_blank"> Bresenham的圆算法</a>，由<a class="ae mv" href="https://gumichan01.github.io/" rel="noopener ugc nofollow" target="_blank"> Gumichan01 </a>在麻省理工学院许可下提供给我们。太棒了——就是！看，画一个光栅化的圆有多简单:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/24a3780f273adb10e29d39e5369a3391.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/1*rsV2fKwYhF2Fk7URr_XGkg.gif"/></div></figure><p id="978e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，现在我们准备好了主代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="d940" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我跳过了部分代码，但是你可以从我的<a class="ae mv" href="https://github.com/alexmaryin/sdl-test" rel="noopener ugc nofollow" target="_blank">库</a>中克隆整个项目。</p><p id="bbcb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，正如你所看到的，我用C++写了一个非常简单的代码，它几乎类似于Python代码，唯一的区别是使用了struct并封装了一些行为。这段代码应该是下一段代码的起点。让我们看看，如何在不影响性能的情况下增强这段代码。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="ffbe" class="nz ls iq bd lt oa ob oc lw od oe of lz jw og jx mc jz oh ka mf kc oi kd mi oj bi translated">科特林式的</h1><p id="69a3" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">在普通的openGL和SDL上编程是一个坚固的函数结构序列，内部没有任何逻辑块或函数作用域。下面的伪代码从字面上说明了我的意思:</p><pre class="kg kh ki kj gt ok nx ol om aw on bi"><span id="1797" class="lr ls iq nx b gy oo op l oq or">init all;<br/>clear screen; // suppose, 1st frame<br/>draw point;<br/>swap buffers;<br/>clear screen; // 2nd frame<br/>draw lines;<br/>draw triangles;<br/>draw anything else;<br/>swap buffers;<br/>clear screen; // 3rd frame, etc.</span></pre><p id="dd08" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个可以在任何C/C++程序中运行的标准流程。当然，您可以自己使用逻辑块和组织绘图框架，但是框架不会强迫您这样做。</p><p id="b8dc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Kotlin带来了使用DSL以声明式风格构建代码的机会。使用DSL，您可以将一个逻辑块包装到另一个逻辑块中，并使用清晰简洁的语法为逻辑块的调用范围或顺序指定限制。如果你已经熟悉了<code class="fe nu nv nw nx b"><a class="ae mv" href="https://ktor.io/" rel="noopener ugc nofollow" target="_blank">Ktor</a></code>或者另一个用DSL风格构建的Kotlin框架，你就明白我的意思了。顺便说一下，JVM世界中著名的2D游戏引擎<code class="fe nu nv nw nx b"><a class="ae mv" href="https://libgdx.com/" rel="noopener ugc nofollow" target="_blank">LibGDX</a></code>有一个叫做<code class="fe nu nv nw nx b"><a class="ae mv" href="https://libktx.github.io/" rel="noopener ugc nofollow" target="_blank">LibKTX</a></code>的Kotlin增强功能，它可以使用DSL风格，用清晰的自动解释代码更快地开发游戏。</p><p id="1d7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我一直在研究如何在Quillraven的一系列视频中使用这个框架，直到我创建了我的第一个简单的多平台游戏。现在Quillraven正在使用Kotlin DSL在LibGDX的基础上构建自己的轻量级引擎<code class="fe nu nv nw nx b">ECS (<a class="ae mv" href="https://en.wikipedia.org/wiki/Entity_component_system" rel="noopener ugc nofollow" target="_blank">entity component system</a>)</code>,名为<code class="fe nu nv nw nx b"><a class="ae mv" href="https://github.com/Quillraven/Fleks" rel="noopener ugc nofollow" target="_blank">Fleks</a></code>。</p><p id="8664" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，没话说！让代码来说明我的意思:</p><pre class="kg kh ki kj gt ok nx ol om aw on bi"><span id="a490" class="lr ls iq nx b gy oo op l oq or">SDL Engine {<br/>    init Engine()<br/>    init Environment()<br/>    add Event Listener <strong class="nx ir">{<br/>        </strong>for quit event -&gt; stop engine and close app<br/>    <strong class="nx ir">}<br/>    </strong>start Infinite Loop <strong class="nx ir">{<br/>        </strong>on Each Frame <strong class="nx ir">{<br/>            </strong>draw magic<br/>            show FPS        <br/>        <strong class="nx ir">}<br/>    }<br/></strong>}</span></pre><p id="25a0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我就是这么想象科特林变种星域的主要代码的！您可能会惊讶于DSL允许将Kotlin中的伪代码变成一对一的形式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="93a0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很漂亮，不是吗？这是一个完整的主要功能。<code class="fe nu nv nw nx b"><strong class="kx ir">SDLEngine</strong></code>是一个带有<code class="fe nu nv nw nx b"><strong class="kx ir">Engine</strong></code>类接收方的函数。在lambda(函数的最后一个参数)内部，这个类的实例作为<code class="fe nu nv nw nx b"><em class="nb">this</em></code>变量可用，如果它不干扰任何其他向上作用域的接收器，您可以在码字<code class="fe nu nv nw nx b"><em class="nb">this</em></code> <em class="nb"> </em>中排除它。</p><p id="a5ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我把引擎初始化参数移到了<code class="fe nu nv nw nx b"><strong class="kx ir">SDLEngine</strong></code>函数中——窗口的宽度和高度。<code class="fe nu nv nw nx b"><strong class="kx ir">addEventListener</strong></code>是引擎范围内的一个函数，将在引擎的每个事件上被调用。</p><p id="8cae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nu nv nw nx b"><strong class="kx ir">startInfiniteLoop</strong></code>也是引擎范围内打开图形渲染器的功能。在我的简单引擎中，这个函数将一直运行，直到窗口关闭。<code class="fe nu nv nw nx b"><strong class="kx ir">onEachFrame</strong></code>是带有<code class="fe nu nv nw nx b">SDL Renderer</code>指针接收器的函数，需要任何SDL绘图功能。我将<code class="fe nu nv nw nx b"><em class="nb">renderer</em></code>声明为<code class="fe nu nv nw nx b"><strong class="kx ir">Engine</strong></code>类的私有成员，你不会在<code class="fe nu nv nw nx b"><strong class="kx ir">onEachFrame</strong></code>函数之外得到它，所以你不能在框架之外画任何东西。</p><p id="15bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我看来，声明式风格可以让你避免错误，并带来更多的清晰和简单。但是第一次…</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h2 id="3ad9" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">如何在Kotlin/Native中包含SDL库</h2><p id="4b96" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">这是我发现中非常复杂的一部分，但是我现在的知识可以让你更快地通过这条路。首先，你应该把它安装到你的机器上。我用的是Ubuntu，我需要的是<code class="fe nu nv nw nx b">sudo apt install libsdl2-dev</code>。<a class="ae mv" href="https://www.libsdl.org/download-2.0.php" rel="noopener ugc nofollow" target="_blank">其他平台的安装更加不同</a>。</p><p id="66c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，您应该仔细研究Kotlin官方文档的后续教程和文章:</p><ol class=""><li id="79da" class="mk ml iq kx b ky kz lb lc le os li ot lm ou lq mr ms mt mu bi translated"><a class="ae mv" href="https://kotlinlang.org/docs/native-get-started.html" rel="noopener ugc nofollow" target="_blank">IntelliJ IDEA中的Kotlin/Native入门。</a>本教程介绍了使用IDEA在Kotlin中构建本地应用程序的基础知识。</li><li id="8744" class="mk ml iq kx b ky mw lb mx le my li mz lm na lq mr ms mt mu bi translated"><a class="ae mv" href="https://kotlinlang.org/docs/native-c-interop.html" rel="noopener ugc nofollow" target="_blank">与c的互操作性</a>这是最重要的部分！它描述了如何将第三方动态库包含到您的项目中。每个图书馆都有许多具体的事情只与它有关。不要跳过绑定的部分！如果你打算使用C++类型，比如指针、枚举、类/结构和回调，这是非常非常重要的。</li><li id="f858" class="mk ml iq kx b ky mw lb mx le my li mz lm na lq mr ms mt mu bi translated"><a class="ae mv" href="https://kotlinlang.org/docs/mapping-primitive-data-types-from-c.html" rel="noopener ugc nofollow" target="_blank">从C语言映射原始数据类型</a>。我没有说过这也是非常重要的一部分？</li></ol><p id="e0c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，考虑到这些教程，我在项目中创建了下一个目录:<code class="fe nu nv nw nx b">project/src/nativeInterop/citerop</code>并将文件<code class="fe nu nv nw nx b">sdl2.def</code>放入其中。该文件包含以下内容:</p><pre class="kg kh ki kj gt ok nx ol om aw on bi"><span id="d058" class="lr ls iq nx b gy oo op l oq or">package = platform.SDL2<br/>headers = SDL2/SDL.h<br/>compilerOpts = -I/usr/include -I/usr/include/x86_64-linux-gnu -I/usr/include/SDL2 -D_POSIX_SOURCE<br/>compilerOpts.linux = -D_REENTRANT<br/>linkerOpts = -L/usr/lib/x86_64-linux-gnu/ -L/usr/lib64 -lSDL2</span></pre><p id="a0f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我编辑了<code class="fe nu nv nw nx b">build.gradle.kts</code>项目文件，添加到<code class="fe nu nv nw nx b">kotlin/nativeTarget</code>扩展名如下:</p><pre class="kg kh ki kj gt ok nx ol om aw on bi"><span id="aa90" class="lr ls iq nx b gy oo op l oq or">compilations.getByName("main") <strong class="nx ir">{<br/>    </strong>cinterops <strong class="nx ir">{<br/>        </strong>val sdl2 by <em class="nb">creating<br/>    </em><strong class="nx ir">}<br/>}</strong></span></pre><p id="315d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">之后(当然还有Gradle sync)我在Gradle tasks工具窗口中发现了一个名为<code class="fe nu nv nw nx b">cinteropSdl2Native</code>的新任务。在尝试使用*中的任何标题之前，有必要运行此任务。def文件。</p><p id="f0cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还没完呢！完成所有这些之后，是时候重建项目了。现在我们可以导入新的包<code class="fe nu nv nw nx b">platform.SDL2</code>(名称在<code class="fe nu nv nw nx b">.def</code>文件中定义)。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="9f9f" class="nz ls iq bd lt oa ob oc lw od oe of lz jw og jx mc jz oh ka mf kc oi kd mi oj bi translated">科特林DSL中的SDL引擎</h1><p id="625d" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">所以，现在我们可以把DSL转向SDL了！那是一个漂亮的变位词。以下是我的SDL引擎的完整代码文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b9db" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它和他的C++兄弟做着同样的事情，但是把它封装在远离用户(SDL)的地方。我定义的类是一个普通的类，而不是数据类，因为它允许避免不必要的代码生成，这些代码在数据类相互比较时是有用的。我的程序不需要这个。</p><p id="8634" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在我的Github 上找到包含其他代码的库<a class="ae mv" href="https://github.com/alexmaryin/StarfieldKt" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h2 id="01fa" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">自由帕斯卡SDL用法</h2><p id="d584" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">从版本2.2.2开始，Freepascal i <a class="ae mv" href="https://wiki.lazarus.freepascal.org/FPC_and_SDL" rel="noopener ugc nofollow" target="_blank">包含了来自盒子</a>的SDL头文件。但是我们需要SDL2报头。https://www.freepascal-meets-sdl.net/网站可以帮助我们。此外，如果您对Pascal不熟悉，这也是开始学习SDL2的绝佳地方。</p><p id="128c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从这个Github repo 的<a class="ae mv" href="https://github.com/PascalGameDevelopment/SDL2-for-Pascal" rel="noopener ugc nofollow" target="_blank">中下载<code class="fe nu nv nw nx b">SDL2</code>的Pascal头文件，并将其放入首选目录(我总是设置Lazarus在<code class="fe nu nv nw nx b">/home/user/.lazarus</code>中创建的默认目录)。</a></p><p id="7231" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么请仔细阅读来自上述网站的教程和来自存储库的read.me，因为Pascal互操作模块还有其他与C++类型不相似的类型名。以及科特林c-interop准备，不是吗？</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="21ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是Freepascal中从C++转换来的用于画圆的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0b27" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是Freepascal的完整代码，类似于C++变体:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h2 id="b30d" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">竞赛和结果</h2><p id="0671" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">最后，我们可以从我们最初的想法开始。让我们为每一种语言(我知道，我知道，Python，你不会)建立一个发布，看看它有多快，有多小。</p><p id="2fb3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我用来编码和测试的笔记本电脑的规格:宏碁Aspire 3，8 Gb RAM，CPU Intel Core i3–1005 G1，240 Gb NVME m.2磁盘，Ubuntu 22.04 x64，OpenGL 4.6，SDL2，以及Intellij IDEA的最新版本，VS Code，Lazarus和PyCharm，用于屏幕捕捉的OBS。</p><p id="2474" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我已经测量了可执行文件的大小，FPS为200星，并使用了内存和CPU负载。我用OBS捕捉了所有程序的运行情况，但OBS吃掉了几乎一半的资源，这就是为什么视频中的FPS比纯测试中的要小:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov nt l"/></div></figure><p id="b721" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我用星域200颗星得到了以下纯结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/4bef710c1ae42c460077163c2dc195ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*97DxXVoGxfBypsIg9Cjb7w.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/ab4554110d735bcd7718db38231f17b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*n4wpdOr6y8CLBu2mDkuR6A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">200颗星的FPS</p></figure><p id="72d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果是所有证明的证明。但是想想，如果说C++、Freepascal、Kotlin之间的一点点差别只是统计上的，我也不会走这么远。</p><p id="8e27" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">说到Python，我想，<code class="fe nu nv nw nx b">PyGame</code>有自己的优化策略，FPS小于500不是悲剧的理由。还有，我也不知道<code class="fe nu nv nw nx b">PyGame</code>到底用的是什么圆算法，不过好像和我们给别人定制的有点不一样。</p><p id="fdb0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不过还是抖机吧，远离幼稚的东西。谁需要200颗星星？让它抽5000！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov nt l"/></div></figure><p id="4db0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在屏幕截图中，当OBS再次吃掉一半的资源时(我的膝盖被笔记本电脑的热量灼伤了),我们所有参赛者的FPS几乎是一样的！对我来说太棒了。但是纯测试的结果更让我吃惊:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/5117c8b142cef973b0af1de1b156aaa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*Rd-u0tYAe_uvTAZukL0hDg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/4fa43be03ff53e66ed7afd05abf1a6c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*JaAn3IeaS9sN_t8K9EvQ_Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">5000颗星星的FPS</p></figure><p id="0fd8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你看到了吗？纯C++程序、纯Freepascal程序和纯Kotlin/Native程序使用完全相同的资源并给出完全相同的FPS。但是如果你向上滚动，就会发现Kotlin程序的代码比C++和Freepascal one的代码更复杂。为了方便起见，我们后来编写了一个复杂的DSL逻辑，但它不会影响运行时性能——它需要与较小的低级代码相同的RAM和CPU负载。甚至exe文件的大小也比Freepascal文件小3倍(没有调试信息)。</p><p id="6b4e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，作为一种年轻的语言，Kotlin没有像C#的Unity3D或C++的UnrealEngine这样的大型商业图形引擎，但它有很大的机会在这个世界上找到自己的位置。我相信这只是一个伟大而漫长的故事的开始！</p><p id="5a2e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对我来说，我有所有的证据证明选择Kotlin是我近年来的正确决定:Android移动、后端、桌面应用、2D和3D游戏——所有这些道路都为Kotlin敞开。</p><p id="e1c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢您完整阅读到此终点线！</p></div></div>    
</body>
</html>