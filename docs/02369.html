<html>
<head>
<title>Understanding the Iterator Design Pattern Using the Dev.to and Medium Social Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用开发人员和中型社交网络理解迭代器设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-design-patterns-iterator-using-dev-to-and-medium-social-networks-fa2e096f3c00?source=collection_archive---------25-----------------------#2019-11-25">https://betterprogramming.pub/understanding-design-patterns-iterator-using-dev-to-and-medium-social-networks-fa2e096f3c00?source=collection_archive---------25-----------------------#2019-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="26f6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入研究并迭代</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/507e6f35ddcb2fea3282a0a3b89f0f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GgbEcNd042RzahqfOPoCPg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nordwood?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">诺德伍德主题</a>在<a class="ae ky" href="https://unsplash.com/s/photos/social-networks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0c85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原著中描述的经典设计模式有23种，<code class="fe lv lw lx ly b">Design Patterns: Elements of Reusable Object-Oriented Software</code>。这些模式为软件开发中经常重复出现的特定问题提供解决方案。</p><p id="7fea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将描述什么是<strong class="lb iu">迭代器模式</strong>以及如何和何时应用它。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8a23" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">迭代器模式:基本思想</h1><blockquote class="my mz na"><p id="9cf5" class="kz la nb lb b lc ld ju le lf lg jx lh nc lj lk ll nd ln lo lp ne lr ls lt lu im bi translated"><em class="it">在面向对象编程中，</em> <strong class="lb iu"> <em class="it">迭代器模式</em> </strong> <em class="it">是一种使用迭代器遍历容器并访问容器元素的设计模式。迭代器模式将算法从容器中分离出来；在某些情况下，算法必然是特定于容器的，因此无法解耦。</em> —维基百科</p><p id="be05" class="kz la nb lb b lc ld ju le lf lg jx lh nc lj lk ll nd ln lo lp ne lr ls lt lu im bi translated"><em class="it">提供一种方法来顺序访问一个集合对象的元素<br/>而不暴露其底层表示。—设计模式:可重用面向对象软件的要素</em></p></blockquote><p id="7032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种模式的主要特点是，它允许您遍历集合的元素，而不暴露其底层表示(数组、映射、树等)。).因此，这是该模式解决的两个问题:</p><ol class=""><li id="2011" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">它允许我们在不改变算法实现的情况下改变集合的内部实现。</li><li id="51ae" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">它允许我们添加适用于所有现有集合类型的新算法。</li></ol><p id="2c4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，迭代器模式对客户端隐藏了集合的内部实现。这个模式的UML图如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/38831df1f57976e1ebc6bc6ff513415e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hHpQUQuhVPSs50_E.png"/></div></div></figure><p id="1de3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Iterator</code>类是一个接口，它定义了导航到集合的不同操作(<code class="fe lv lw lx ly b">next</code>或<code class="fe lv lw lx ly b">hasNext</code>)，而<code class="fe lv lw lx ly b">Aggregate</code>类将创建<code class="fe lv lw lx ly b">Iterator</code>。最后，系统将使用<code class="fe lv lw lx ly b">ConcreteAggregate</code>和<code class="fe lv lw lx ly b">ConcreteIterator</code>。</p><ol class=""><li id="fb8e" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">您的集合有一个复杂的数据结构，但是您想对客户隐藏它的复杂性。</li><li id="4591" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">您需要减少应用程序中遍历代码的重复。</li><li id="fe01" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">您希望您的代码能够遍历不同的数据结构。</li></ol><p id="c20c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代器模式有几个优点，总结如下:</p><ul class=""><li id="f5e9" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nu nl nm nn bi translated">由于迭代器使用了<strong class="lb iu">单一责任</strong>和<strong class="lb iu">打开/关闭</strong>的可靠原则，代码<strong class="lb iu">更容易使用、理解和测试</strong>。</li><li id="e64b" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nu nl nm nn bi translated">单一责任原则允许我们清理客户端和遍历算法的集合。</li><li id="eafb" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nu nl nm nn bi translated"><strong class="lb iu">开/闭原则</strong>允许实现新类型的集合和迭代器，而不会破坏任何东西。</li><li id="3249" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nu nl nm nn bi translated"><strong class="lb iu">在同一个集合上并行迭代</strong>，因为每个迭代器对象都包含自己的迭代状态。</li><li id="f690" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nu nl nm nn bi translated"><strong class="lb iu">干净的代码</strong>因为客户端/上下文不使用复杂的接口，系统更加<strong class="lb iu">灵活和可重用</strong>。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5d45" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">第一个例子:单词集合</h1><p id="ff3b" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">我现在将向您展示如何使用JavaScript/TypeScript实现这种模式。在我们的例子中，我编了一个问题，其中有一个名为<code class="fe lv lw lx ly b">WordsCollection</code>的类，它定义了一个单词的列表(<code class="fe lv lw lx ly b">items</code>)和它的一组get和add方法(<code class="fe lv lw lx ly b">getItems</code>和<code class="fe lv lw lx ly b">addItem</code>)。这个类由使用控制结构的<code class="fe lv lw lx ly b">client</code>使用，例如<code class="fe lv lw lx ly b">for</code>或<code class="fe lv lw lx ly b">forEach</code>。下面的UML图显示了我刚刚描述的场景。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/446f9543ed0f901877d14271f5b7a790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*K6qdhzIeopivu09U.jpg"/></div></div></figure><p id="6990" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相关的<code class="fe lv lw lx ly b">WordsCollection</code>代码如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/0d8bcb76498f2d98b72a8d5f6abadea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4CpCEy-pR1CmJdYpVLGB4Q.png"/></div></div></figure><p id="a524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">client</code>代码关联是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/0182f59ec84c7fa4e9ea1be83157b1f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fl0_neuLmC6YnmkdIfH5BA.png"/></div></div></figure><p id="a9c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种解决方案的主要问题是代码是耦合的。这意味着客户端需要知道集合的内部结构是如何实现两个被遍历的方法的(<code class="fe lv lw lx ly b">Straight</code>和<code class="fe lv lw lx ly b">Reverse</code>)。假设您需要将数据结构从<code class="fe lv lw lx ly b">Array</code>更改为<code class="fe lv lw lx ly b">Map</code>——与客户端相关的代码由于耦合而中断。迭代器模式的另一个有趣的用例是当您需要一种新的方法来迭代集合时，例如，<code class="fe lv lw lx ly b">AlphabeticalOrdered</code>。</p><p id="1da2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案是使用迭代器模式，新的UML图使用下面的模式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/0f1eeeb7553efd89589fa87414271af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ENaMizA2pN5MlN5O.jpg"/></div></div></figure><p id="006e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，该解决方案由一个接口类(<code class="fe lv lw lx ly b">Iterator</code>)组成，该接口类定义了遍历集合的方法:</p><ol class=""><li id="2ff6" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">current()</code> : T。</li><li id="4621" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">key()</code>:编号。</li><li id="0879" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">hasMoreElements()</code>:布尔型。</li><li id="cc2e" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">rewind</code>:作废。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/e0eb58d2718cb02ac7d0b55277f36b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D5CiaX8YzlobDHJRc3_tOQ.png"/></div></div></figure><p id="0878" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类<code class="fe lv lw lx ly b">AlphabeticalOrderIterator</code>是迭代器，负责实现以正确的方式遍历集合的方法。迭代器需要使用聚合的(<code class="fe lv lw lx ly b">WordsCollection</code>)集合和迭代的方式(反向或正向)。所以，与<code class="fe lv lw lx ly b">AlphabeticalOrderIterator</code>相关的代码是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/4fc69b58605612aa90b026fa844407a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fz71E9r84pais_SJfrHcyQ.png"/></div></div></figure><p id="28bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步包括定义<code class="fe lv lw lx ly b">Aggregator</code>接口和修改集合来实现这个接口。所以，与<code class="fe lv lw lx ly b">Aggregator</code>相关的代码是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/b2867399dfa5cf36594a38efaa5ff0ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4cyH_J0fyGA6zlhgvlM9rg.png"/></div></div></figure><p id="6965" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，<code class="fe lv lw lx ly b">Aggregator</code>接口定义了创建新迭代器的方法。在这个问题中，我们需要两个迭代器:正向迭代器和反向迭代器。因此，<code class="fe lv lw lx ly b">WordsCollection</code>被修改为包含这些方法，正如您在下面的代码中看到的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/c9cfb6f6b8319d696d5f07b20db45b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0QVdMb6sA_Y0-0sbLHYXaQ.png"/></div></div></figure><p id="9e48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以在客户端代码中使用迭代器，现在已经解耦了，如下面的代码所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/a8207cab17ffeb26c33c0e40feca0b24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-QznAC3VvcsZQYyj6TxfA.png"/></div></div></figure><p id="1285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端从<code class="fe lv lw lx ly b">WordsCollection class</code> ( <em class="nb">单一责任</em>)的内部结构中分离出来，你可以扩展软件实现新的迭代器(<em class="nb">打开/关闭</em>)。</p><p id="f54b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在应用迭代器模式后，我创建了几个NPM脚本来运行这里显示的代码示例。</p><p id="2834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">npm run example1-problem</code> <br/> <code class="fe lv lw lx ly b">npm run example1-iterator-solution-1</code></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ccea" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">示例:中型和开发型</h1><p id="8da3" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">假设我们必须开发一个软件，允许我们向社交网络中的联系人发送电子邮件，并考虑到我们将区分发送的邮件类型。在我们的人际网络中，我们有两类联系人:朋友和同事。要发送的电子邮件会更正式，这取决于电子邮件要发送到的联系人的类型。</p><p id="38a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们有来自两个著名社交网络的联系人:Dev.to和Medium(我们不必澄清哪个是我的最爱，你们都知道！).每个社交网络的数据结构的实现是不同的——在Dev.to中使用数组来维护联系人，而在Medium中使用地图。</p><p id="78e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代器模式允许我们将代码与我们的联系人和社交网络完全解耦，因此我们可以将自己从每个社交网络的内部实现中抽象出来。我们甚至有能力添加新的社交网络(尽管…对于我们这些极客来说，其他社交网络甚至还存在吗？！)</p><p id="4ce4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在下面的gif中找到使用我们整个结构的客户端(我已经做了一个小的CLI例子)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/cfb37105c843f69a7d39f5fe38076ba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E7w0vHwE6PQIA3dy.gif"/></div></div></figure><p id="0d10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的UML图中，您可以看到针对此问题提出的解决方案:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/0052b4c83a85ef0d3af7ba588ba596e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IaPLkQoP5t7-LthS.jpg"/></div></div></figure><p id="b569" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，这个问题中的模型不是一个字符串，而是一个用户的配置文件，正如您在下面的代码中看到的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/2ff5e69d80c771f15d07d6c4b2056b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3c1-bfFTmAgWkte5kvV5WQ.png"/></div></div></figure><p id="8e0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">Profile</code>类中，我们有一个<code class="fe lv lw lx ly b">getContactsByType</code>方法，它返回朋友或同事的联系人。</p><p id="8047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是定义迭代器接口(<code class="fe lv lw lx ly b">ProfileIterator</code>)和聚合器接口(<code class="fe lv lw lx ly b">SocialNetwork</code>)，后者定义了每个迭代器和聚合器必须实现的方法。</p><p id="8a2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，与这些接口相关的代码如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/2c868ed67a9fbb33e67d9bd51809ef84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_7rmockSrJt5T9ZD_7vdQ.png"/></div></div></figure><p id="6267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要实现前面接口的具体实现来解决我们的问题。我们将解析的第一个社交网络是Dev.to。聚合器和迭代器的实现如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/543f2e95a4e1ba64c9e92548279302f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UrY0Oex6QhBd2LzDLf7x1A.png"/></div></div></figure><p id="c865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，存储联系人的集合是一个数组，并且实现了<code class="fe lv lw lx ly b">createFriendsIterator</code>和<code class="fe lv lw lx ly b">createCoworkersIterator</code>。它有几个方法来模拟到远程API的连接以获取联系人。</p><p id="36f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是与<code class="fe lv lw lx ly b">DevToIterator</code>类相关的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/8b6f176fc3269ef53a901be56e328f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vpRIs93NW_pZJ2MvE9s8yw.png"/></div></div></figure><p id="5ebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面代码中最重要的部分是接口实现。具体实现基于集合(数组)的内部数据结构。您可能会注意到，我开发了一个请求联系人的惰性方法(仔细考虑一下——从一个朋友请求所有朋友可能会导致无限循环)。</p><p id="a035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们应该创建只使用接口的<code class="fe lv lw lx ly b">SocialSpammer</code>类。正如您在这里看到的,<code class="fe lv lw lx ly b">SocialSpammer</code>类与任何具体的类都是解耦的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/306fbc6a81b7deeb44f5ba5f3c98e641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NZQa_4899K_2UbPfy9RLrA.png"/></div></div></figure><p id="9705" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面的代码根据电子邮件是发给朋友还是同事来使用迭代器。</p><p id="eae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以在下面的客户端中使用代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/7c0e08c208c4d615685efae9c9e228ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C5owptV83rPZ8Sr6TNEjvw.png"/></div></div></figure><p id="a03d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是时候检查我们是否可以通过创建一个新的社交网络及其迭代器来利用开放/封闭原则，而不破坏我们的应用程序。</p><p id="d248" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是与<code class="fe lv lw lx ly b">medium</code>类相关的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/eadf174e74e9e990e2c658ab6d4051cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n07Bn8wTSsADOtOqtqNdZg.png"/></div></div></figure><p id="d105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用继承来简化Dev.to和Medium之间的代码，但为了不扩展这篇文章，我们更喜欢重复代码。您可以看到，Medium类使用不同的数据结构来存储联系人。</p><p id="e55c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这是<code class="fe lv lw lx ly b">medium-iterator</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/d32352c3258165a906639717b43b595f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hwotGmvQtmc1kX-p36Mw2Q.png"/></div></div></figure><p id="7113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在应用迭代器模式和CLI接口后，我创建了一个NPM脚本来运行这里显示的示例。</p><p id="c7ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">npm run example2-iterator-solution1</code></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5d87" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="910d" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">迭代器模式可以帮助您避免项目中的耦合代码。当集合中有多种算法和数据结构时，迭代器模式非常适合。这意味着你的代码会更干净，因为你应用了两个著名的原则，比如<strong class="lb iu">单一责任</strong>和<strong class="lb iu">打开/关闭</strong>。</p><p id="1037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的事情不是实现我向你展示的模式，而是能够认识到这个特定模式可以解决的问题，以及你何时可以或不可以实现这个模式。这一点至关重要，因为实现会因您使用的编程语言而异。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="aad3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nb">原载于2019年6月12日</em><a class="ae ky" href="http://www.carloscaballero.io/design-patterns-iterator/" rel="noopener ugc nofollow" target="_blank"><em class="nb">https://www . carloscaballero . io</em></a><em class="nb">。</em></p></div></div>    
</body>
</html>