<html>
<head>
<title>Clean Node.js Architecture —With NestJs and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NestJs和TypeScript清理Node.js架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/clean-node-js-architecture-with-nestjs-and-typescript-34b9398d790f?source=collection_archive---------0-----------------------#2022-01-26">https://betterprogramming.pub/clean-node-js-architecture-with-nestjs-and-typescript-34b9398d790f?source=collection_archive---------0-----------------------#2022-01-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cd1b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">“你的架构应该告诉读者关于系统的信息，而不是你在系统中使用的框架。”——罗伯特·c·马丁</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2b6acf5ec51d9a6199ac5bc671483382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kvHz1ZkrPXlocl3h"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">萨曼莎·加德斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3e63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">距离我上一篇关于如何在Node.js应用程序上<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/node-clean-architecture-deep-dive-ab68e523554b">实现干净架构的文章</a>已经有一段时间了。在与NestJs和TypeScript合作之后，我认为回来就这个主题写一篇新文章是个好主意。这一次，我们将利用typescript的强大功能和NestJs的方法和工具，并利用它们为我们带来好处。</p><p id="6f1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将从头开始解释干净的架构，所以如果你读了前一篇文章，请随意跳到实现部分。</p><p id="4f8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你也可以在Node TLV 2022大会上查看我关于这个主题的讲座<a class="ae kv" href="https://www.youtube.com/watch?v=jjczRbgHvVg&amp;t=1s" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="bc5c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">那么什么是清洁建筑呢？</h1><blockquote class="mk ml mm"><p id="69d5" class="kw kx mn ky b kz la jr lb lc ld ju le mo lg lh li mp lk ll lm mq lo lp lq lr ij bi translated">你的架构应该告诉读者关于系统，而不是你在系统中使用的框架</p></blockquote><p id="c0e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该建筑试图将一些领先的现代建筑，如<a class="ae kv" href="https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)" rel="noopener ugc nofollow" target="_blank">六边形建筑</a>、<a class="ae kv" href="http://jeffreypalermo.com/blog/the-onion-architecture-part-1/" rel="noopener ugc nofollow" target="_blank">洋葱建筑</a>和<a class="ae kv" href="http://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html" rel="noopener ugc nofollow" target="_blank">尖叫建筑</a>整合成一个主建筑。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl mr"><img src="../Images/0c12b203efe4f6b9916e2761fc054434.png" data-original-src="https://miro.medium.com/v2/format:webp/0*x318bLrEpHGA5GxA.jpg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">节点清洁架构图，图片由Robert C. Martin提供</p></figure><p id="2f4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这张图表摘自罗伯特·c·马丁的官方文章。我建议在深入研究节点实现之前阅读他的文章。这是关于该架构的最佳来源知识。</p><p id="2840" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于这个图以及如何阅读它的一些话(如果您还不理解它，请不要担心，我们将在本文中深入研究每一层):</p><ul class=""><li id="4905" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">层:每个环代表应用程序中的一个隔离层。</li><li id="5739" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">依赖:依赖方向是由外向内。这意味着实体层是独立的，而框架层(web、UI等)是独立的。)取决于所有其他层。</li><li id="c3d0" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">实体:包含构建我们的应用程序的所有业务实体。</li><li id="682e" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">用例:这是我们集中逻辑的地方。每个用例为一个特定的业务用例编排所有的逻辑(例如向系统添加新的客户)。</li><li id="cd37" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">控制器和表示器:我们的控制器、表示器和网关是中间层。您可以将它们视为用例的入口和出口。</li><li id="e597" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">框架:这一层有所有的具体实现。数据库、web框架、错误处理框架等。Robert C. Martin描述了这一层:“<em class="mn">这一层是所有细节的所在。网络是一个细节。数据库是一个细节。我们把这些东西放在外面，让它们伤害很小。”</em></li></ul><p id="c22d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，您可能会对自己说:“数据库在外层，数据库是一个细节？”数据库应该是我的核心层。</p><p id="bf56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢这个建筑，因为它背后有一个聪明的动机:</p><p id="bb09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种架构关注的不是框架和工具，而是应用程序的业务逻辑。它是独立于框架的(尽可能独立)。</p><p id="3754" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着无论您使用哪个数据库、开发框架、UI或外部服务，应用程序的实体和业务逻辑都将保持不变。</p><p id="27fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在不改变逻辑的情况下改变以上所有内容。这使得测试用这种架构构建的应用程序变得如此容易。如果您还不理解这一点，请不要担心，我们将一步一步地探索它。</p><p id="10f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将通过一个示例应用程序的例子来慢慢解开架构的不同层。</p><p id="f1fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像任何其他架构一样，有许多不同的方法来实现它，每种方法都有自己的考虑和权衡。</p><p id="0174" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将解释如何用NestJs在Node中实现这种架构。我将试着解释在这个过程中不同的实现考虑。</p><p id="9b3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们仔细看看这个示例应用程序。</p><h1 id="4361" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">示例应用程序</h1><p id="1a88" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我们的示例应用程序将代表一个简单的微服务，它支持图书存储库上的CRUD操作。</p><p id="8e4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将逐层实现服务API。你可以在<a class="ae kv" href="https://github.com/royib/clean-architecture-nestJS" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到所有代码。本文包含了部分代码，但是最好的方法(在我看来)是在阅读本文的同时探索代码。</p><p id="5cad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的实现中，我们将使用<a class="ae kv" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NetsJS </a>。</p><blockquote class="mk ml mm"><p id="3812" class="kw kx mn ky b kz la jr lb lc ld ju le mo lg lh li mp lk ll lm mq lo lp lq lr ij bi translated">Nest是一个用于构建高效、可伸缩的Node.js服务器端应用程序的框架。它使用现代JavaScript，用TypeScript构建(保持与纯JavaScript的兼容性)，并结合了OOP(面向对象编程)、FP(函数式编程)和FRP(函数式反应编程)的元素。— <a class="ae kv" href="https://www.npmjs.com/package/@nestjs/core" rel="noopener ugc nofollow" target="_blank"> Nest官方npm回购</a></p></blockquote><p id="67c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上Node.js也允许你以任何你想要的方式构建服务器端应用程序，这在某些情况下是一件好事，但也可能是一个问题，因为每个团队都以不同的方式构建自己的应用程序，每个人都有自己的观点。你的项目没有统一性，如果你不知道自己在做什么，事情会很快变得一团糟。NestJs是一个固执己见的Node.js框架，它提供了如下工具:</p><ul class=""><li id="a54c" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">依赖注入</li><li id="6664" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">代码与模块的分离</li><li id="7a40" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">控制器</li><li id="0647" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">中间件</li><li id="2d6e" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">过滤</li><li id="e9f7" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">护卫队</li></ul><p id="5c5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这不是一篇NestJs文章，但我将在本文中尝试解释一些基本原则。</p><h1 id="95fe" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">实体和用例层</h1><blockquote class="mk ml mm"><p id="947e" class="kw kx mn ky b kz la jr lb lc ld ju le mo lg lh li mp lk ll lm mq lo lp lq lr ij bi translated">这一层中的代码包含特定于应用程序的业务规则。它封装并实现了系统的所有用例。这些用例编排了实体之间的数据流，并指导这些实体使用它们企业范围的业务规则来实现用例的目标。— <em class="iq">罗伯特·c·马丁</em></p></blockquote><p id="8933" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在应用程序的核心，我们有两层:</p><ul class=""><li id="880a" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">实体层:包含构建我们的应用程序的所有业务实体。</li><li id="3959" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">用例层:包含我们的应用程序支持的所有业务场景。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/a01dec6342abd54fd4fc3dd08d0d9bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JkSjWvfGMsxV4eEyXcxUMg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">核心层</p></figure><p id="df4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将从内到外，或者从依赖规则的相反方向，遍历架构。</p><p id="b508" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在内部，我们有独立的核心层。这些层包含业务实体和业务逻辑。框架在这些领域是罕见的生物，这些层应该是变化的，主要是由于业务的变化。</p><p id="d4c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们进入外层时，我们会发现更多的框架和更多的代码由于技术或效率的原因而随时间改变。</p><p id="b4aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实体是一个独立的层，用例只依赖于它们。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="be6c" class="ls lt iq bd lu lv nt lx ly lz nu mb mc jw nv jx me jz nw ka mg kc nx kd mi mj bi translated">实体</h1><p id="a83e" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我们应用程序中的业务实体包括:</p><h2 id="2c07" class="ny lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">作者</h2><ul class=""><li id="484d" class="ms mt iq ky b kz ng lc nh lf ok lj ol ln om lr mx my mz na bi translated">身份</li><li id="6178" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">西方人名的第一个字</li><li id="f441" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">姓</li></ul><h2 id="41d3" class="ny lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">类型</h2><ul class=""><li id="f50b" class="ms mt iq ky b kz ng lc nh lf ok lj ol ln om lr mx my mz na bi translated">名字</li></ul><h2 id="7d1b" class="ny lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">书</h2><ul class=""><li id="67b9" class="ms mt iq ky b kz ng lc nh lf ok lj ol ln om lr mx my mz na bi translated">身份</li><li id="2b06" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">标题</li><li id="b2f5" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">作者</li><li id="ce2b" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">类型</li><li id="28b0" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">出版日期</li></ul><p id="10a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一层是独立的，这意味着您将从不同的层导入模块。</p><p id="16d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一层不会受到服务、路由或控制器等外部变化的影响</p><p id="fbd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在我们的示例应用程序中的<a class="ae kv" href="https://github.com/royib/clean-architecture-nestJS/tree/main/src/core/entities" rel="noopener ugc nofollow" target="_blank"> src/core/entities </a>文件夹下找到所有的实体代码</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><h1 id="7de6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">用例</h1><p id="e985" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">这是我们集中逻辑的地方。每个用例为一个特定的业务用例编排所有的逻辑。我们的应用程序API需要支持这些用例(我选择了其中的一个例子):</p><ul class=""><li id="df71" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">获取所有书籍的列表。</li><li id="469a" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">获取单本详细信息。</li><li id="4e62" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">添加新书。</li><li id="76c2" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">添加新作者。</li></ul><h2 id="5512" class="ny lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">添加图书用例</h2><p id="95d5" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">让我们检查并深入“添加新书”用例。用例的主要职责是:</p><ul class=""><li id="6be1" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">业务规则验证。</li><li id="8ade" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">检查DB中是否不存在该书。</li><li id="7d3e" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">创建新的book对象。</li><li id="20e6" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">将我们的新书保存在数据库中。</li><li id="a153" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">更新图书馆CRM系统。</li></ul><p id="77e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过查看用例的职责，我们可以看到用例有两个依赖项:</p><ul class=""><li id="306c" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">数据库服务:用例需要持久化图书细节，并检查它在系统中是否不存在。例如，这个功能可以实现为一个调用SQL或MongoDB的类。</li><li id="41b4" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">CRM服务:用例需要通知图书馆CRM应用程序关于新书的信息。该功能可以作为调用外部系统(可以是任何系统)的服务来实现。</li></ul><p id="9d8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一种选择是在用例本身中要求数据库和CRM服务的具体实现(例如，直接调用SQL SDK)。该选项将使我们的数据库和CRM服务的具体实现与我们的用例紧密耦合。</p><p id="ae48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据库/CRM服务的任何变化(如SDK的变化)都会导致我们用例的变化。这个选项将打破我们清晰的架构假设，即用例表达业务流程，框架(如数据库和外部服务)对它们是不可见的。</p><p id="03a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的用例只知道实体和业务逻辑。此外，测试用例逻辑将变得更加困难。</p><p id="1aed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，让我们假设用例不知道任何关于具体数据库的事情，比如SQL或者<a class="ae kv" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>。它仍然需要与它们进行交互来执行任务(比如在数据库中保存一本书)，但是如果它不知道它们，它怎么能做到这一点呢？</p><p id="c93d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决方案是在用例与外部世界之间建立一个网关。</p><p id="f80e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是抽象和依赖注入的救援之处。我们不是创建对特定数据库或特定财务系统的依赖，而是创建对抽象的依赖。但是，抽象到底是什么？</p><p id="4e0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">抽象是创建服务蓝图而不实现它们的方式。我们只定义我们需要的服务功能。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/fdb7c025e8d0a3fe9849fad4e752ef6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q1m_l6R_IfD5o_ML10EjmQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">抽象依赖</p></figure><p id="935b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过抽象，我们将定义用例与框架之间的契约。基本上，契约是所需服务的功能签名。例如，CRM服务需要提供一个“notify”函数，该函数获取一个Book对象作为参数，并返回一个带有布尔值的承诺。</p><h2 id="5a81" class="ny lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">用例依赖</h2><p id="6779" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">让我们定义我们的抽象，我们需要:</p><ul class=""><li id="e6f6" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">数据服务抽象</li><li id="7335" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">CRM服务抽象</li></ul><p id="b664" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的数据服务抽象需要公开3个存储库:</p><ul class=""><li id="0f27" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">图书仓库</li><li id="402f" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">作者知识库</li><li id="5562" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">流派知识库</li></ul><p id="5d7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些仓库中的每一个都需要为我们提供CRUD功能，比如:查找、findById、插入、更新、删除等等</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/9edfe6773d1c55c7a3f0f038d1764b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mSpjRw74EIwlXI5TD6dCiA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用例抽象</p></figure><h2 id="84f4" class="ny lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">主要抽象</h2><p id="01e8" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">您可以在<a class="ae kv" href="https://github.com/royib/clean-architecture-nestJS/tree/main/src/core/abstracts" rel="noopener ugc nofollow" target="_blank"> src/core/abstracts </a>找到我们示例应用程序中的所有抽象。</p><p id="4e92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们看看我们的数据服务抽象:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="ecee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在我写的一篇关于这个主题的文章中读到更多的内容— <a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/implementing-a-generic-repository-pattern-using-nestjs-fb4db1b61cce">使用NestJS实现通用存储库模式</a></p><ul class=""><li id="d2b2" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated"><strong class="ky ir">通用知识库</strong> —每个实体知识库都需要支持基本的crud操作。我已经创建了一个通用存储库，它将作为所有实体存储库的抽象类，如果我们需要每个存储库的不同功能，您可以单独定义它们。我只选择了基本的存储库功能，在您的实际应用程序中，您可以为所有/每个存储库定义您需要的功能。</li><li id="78c6" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><strong class="ky ir">数据服务</strong> — <strong class="ky ir"> </strong>公开所有的实体库。</li></ul><p id="fd47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的CRM服务抽象如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="f6ea" class="ny lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">用例代码</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><ul class=""><li id="2498" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">我们的add book用例只依赖于抽象。在构造函数中，我们只注入IDataServices和ICrmServices。</li><li id="8cf9" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">我们使用我们的服务，却不知道它们的真正实现是什么。</li><li id="8e36" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">外部服务实现的变化不会影响我们的用例业务逻辑。</li></ul><p id="178d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谁将这些服务的具体实现注入到我们的用例构造器中？请继续关注，您将很快在框架部分找到答案</p><h1 id="821c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">控制器和演示者</h1><blockquote class="mk ml mm"><p id="074b" class="kw kx mn ky b kz la jr lb lc ld ju le mo lg lh li mp lk ll lm mq lo lp lq lr ij bi translated"><em class="iq"> " </em>这一层的软件是一组适配器，将数据从对用例及实体最方便的格式转换成对某些外部机构(如数据库或web)最方便的格式。例如，正是这一层将完全包含GUI的MVC架构。演示者、视图和控制器都属于这里”——罗伯特·c·马丁</p></blockquote><p id="8323" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上一节中，我们讨论了我们的核心业务层，以及它们如何只依赖于它们定义的抽象。现在我们将讨论适配器，因此您在这里不会看到任何业务逻辑或框架。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/311605b41411bea3e0be62473fe9b8a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xKNJsh-x3F1u93KBrjhpBA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">控制器</p></figure><p id="57c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的控制器、演示者和网关是中间层。你可以把它们想象成一个适配器，把我们的用例与外部世界粘合起来，反之亦然。</p><p id="1bee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">外界是谁？</p><p id="7db1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你来自MVC世界，你可能听说过控制器。在经典的MVC中，你有某种指向不同控制器的路由机制。控制器的工作是响应用户输入，验证它，做一些业务逻辑的事情，并且通常改变应用程序的状态。</p><p id="08ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，表示器从某种存储库中接收数据，并为视图/api层格式化数据。</p><h1 id="dff7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">控制器</h1><p id="49cb" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在干净的架构中，控制器的工作是:</p><ul class=""><li id="79d4" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">接收用户输入——某种类型的<a class="ae kv" href="https://en.wikipedia.org/wiki/Data_transfer_object" rel="noopener ugc nofollow" target="_blank"> DTO </a>。</li><li id="b863" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">验证用户输入-净化。</li><li id="5b76" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">将用户输入转换成用例期望的模型。例如，做日期格式和字符串到整数的转换。</li><li id="abc8" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">调用用例，并传递给它新的模型。</li></ul><p id="592b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">控制器是一个适配器，我们不需要任何业务逻辑，只需要数据格式化逻辑。</p><h1 id="58f7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">提出者</h1><p id="35d1" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">演示者将从应用程序存储库中获取数据，然后为客户机构建一个格式化的响应。其主要职责包括:</p><ul class=""><li id="bcae" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">格式化字符串和日期。</li><li id="3ff7" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">添加演示数据，如标志。</li><li id="bc13" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">准备要在UI中显示的数据。</li></ul><p id="ffc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的节点实现中，我们将一起实现控制器和表示器，就像我们在MVC项目中所做的一样。我们将使用NestJs功能来实现我们的<a class="ae kv" href="https://docs.nestjs.com/controllers" rel="noopener ugc nofollow" target="_blank">控制器</a>。我们将使用<a class="ae kv" href="https://docs.nestjs.com/techniques/validation" rel="noopener ugc nofollow" target="_blank">验证管道</a>验证我们的用户输入，并使用<a class="ae kv" href="https://docs.nestjs.com/pipes" rel="noopener ugc nofollow" target="_blank">转换管道</a>将我们的DTO转换为业务对象。</p><p id="8974" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先让我们创建我们的<a class="ae kv" href="https://github.com/royib/clean-architecture-nestJS/blob/main/src/core/dtos/book.dto.ts" rel="noopener ugc nofollow" target="_blank"> DTO图书对象</a>。我们将从我们的api消费者那里接收这个对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="7460" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://docs.nestjs.com/techniques/validation" rel="noopener ugc nofollow" target="_blank"> NestsJS在幕后使用了类验证器</a>，所以我们可以使用<a class="ae kv" href="https://github.com/typestack/class-validator" rel="noopener ugc nofollow" target="_blank">类验证器装饰器</a>来验证我们的DTO对象。我们还可以添加自定义验证器，例如，我们可以添加一个自定义验证器来检查这本书是否已经存在。</p><p id="e541" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是将返回给我们的消费者的响应对象:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="03d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">图书控制器代码如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><ul class=""><li id="225a" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">验证是由NestJs在bookDto对象上进行的</li><li id="79e0" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">我们使用<code class="fe os ot ou ov b">bookFactoryService</code>将我们的DTO转换成一个商业书籍对象</li><li id="83c6" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">致电我们的用例服务</li><li id="771f" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">创建对消费者的响应</li></ul><h1 id="cf06" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结构</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/a5b2a6882126719c327ecdb459b84009.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/0*Y0GCjnpQUbvOrQhb"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">节点清洁架构—框架</p></figure><blockquote class="mk ml mm"><p id="0bc3" class="kw kx mn ky b kz la jr lb lc ld ju le mo lg lh li mp lk ll lm mq lo lp lq lr ij bi translated">“这一层是所有细节的所在。网络是一个细节。数据库是一个细节。我们把这些东西放在外面，让它们伤害很小”——罗伯特·c·马丁</p></blockquote><p id="a89f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上一节中，我们讨论了适配器层，以及它们如何作为用例的入口和出口。</p><p id="0a89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将讨论框架层，这一层包括我们所有的具体实现，如数据库、监控、计费、错误处理等。</p><p id="9ffe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，我们只讨论了实体、业务逻辑、适配器，并且除了我们的构建模块框架NestJs之外，我们没有使用任何框架。你可以说我们写了一个“纯”代码。</p><p id="516c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的示例项目中，框架被实现为:</p><ul class=""><li id="7709" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">web应用框架是由NestJs实现的(构建于express之上)。</li><li id="6118" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">数据库服务使用<a class="ae kv" href="https://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank">mongose</a>实现。</li><li id="040f" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">CRM服务是一个简单的模拟服务。</li></ul><h2 id="5477" class="ny lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">数据服务实现</h2><p id="a232" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">Mongo通用存储库的代码如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><ul class=""><li id="91be" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">存储库使用mongoose实现我们的抽象<code class="fe os ot ou ov b">IGenericRepository</code>类</li><li id="ffb6" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><code class="fe os ot ou ov b">T</code>代表一个db实体，每个实体都具有所有期望的功能</li></ul><p id="dd6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Mongo数据服务代码如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><ul class=""><li id="c1fe" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated"><code class="fe os ot ou ov b">MongoDataServices</code>实现了<code class="fe os ot ou ov b">IDataServices</code>抽象类</li><li id="1044" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">它根据需要公开3个存储库，每个实体一个</li><li id="2d25" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">您可以查阅<a class="ae kv" href="https://docs.nestjs.com/techniques/mongodb" rel="noopener ugc nofollow" target="_blank"> NestJs文档</a>来更好地理解mongo实现，这超出了本文的范围。</li></ul><p id="fee1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">CRM服务:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><h1 id="9c7d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">依赖注入</h1><p id="298e" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">正如我们之前讨论的，我们的用例依赖于契约而不是实现。这些契约需要在运行时通过依赖注入来满足。</p><p id="a6cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您不熟悉依赖注入的概念，我鼓励您看一看Fun Fun Fun Function博客上的两个很好的视频，它们完美地解释了这个主题:</p><ul class=""><li id="5404" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=0X1Ns2NRfks" rel="noopener ugc nofollow" target="_blank">依赖注入基础知识</a></li><li id="bc70" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=-kpEP4JeEdc" rel="noopener ugc nofollow" target="_blank">控制反转</a></li></ul><p id="c74e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，NestJs有一个内置的<a class="ae kv" href="https://docs.nestjs.com/fundamentals/custom-providers" rel="noopener ugc nofollow" target="_blank">依赖注入</a>功能。我们所要做的就是将我们的依赖注入到我们的服务构造函数中，在运行时NestJs会负责注入一个实例。</p><p id="8d7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我们将注入抽象服务，在运行时，DI引擎将创建正确实现的实例。</p><p id="a516" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://github.com/royib/clean-architecture-nestJS/blob/main/src/frameworks/data-services/mongo/mongo-data-services.module.ts" rel="noopener ugc nofollow" target="_blank">模块声明</a>中，我们告诉NestJs我们想要每个抽象的哪个实现。例如，当我们请求<code class="fe os ot ou ov b">DataServices</code>时，我们实际上想要得到<code class="fe os ot ou ov b">MongoDataServices</code>的一个实例。</p><p id="9342" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">美妙之处在于，我们的服务对<code class="fe os ot ou ov b">MongoDataServices</code>一无所知，并且仍然在运行时使用它。</p><p id="e6a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据服务模块的代码如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="212d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当有人请求<code class="fe os ot ou ov b">IDataServices</code>时，NestJs将注入<code class="fe os ot ou ov b">MongoDataServices</code>实例</p><p id="cf1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果我们想用sql替换mongo，我们需要做的就是:</p><ul class=""><li id="6d99" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">创建使用sql的新数据服务类和存储库，并遵循数据服务抽象。</li><li id="c15f" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">在模块文件中，告诉Nest.js使用我们新的sql数据服务</li></ul><h1 id="7f7b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摘要</h1><p id="7baa" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在本文中，我们展示了如何构建一个健壮的结构，一层一层地将我们的核心业务逻辑从框架中分离出来。</p><p id="66b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以轻松地用Sql替换我们的数据库，或者迁移到一个新的CRM系统，所有这些都不涉及我们的业务逻辑。</p><p id="088e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还可以通过只接触框架层来对我们的一个框架中的SDK变化做出反应。由于各层的松散耦合架构，测试也变得很容易。</p><p id="b983" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在复杂的项目中，保持所有层的整洁是困难的，有时甚至是乏味的。它总是关于架构中的权衡，并且我们不时需要妥协和打破我们的界限以获得另一个好处。</p><p id="1308" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我相信，如果我们努力遵守这些规则，我们将在未来获得巨大的利益。</p></div></div>    
</body>
</html>