<html>
<head>
<title>Implementing a Web App With Rocket</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Rocket实现Web应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-a-web-app-with-rocket-5e56c7e484a0?source=collection_archive---------4-----------------------#2022-04-30">https://betterprogramming.pub/implementing-a-web-app-with-rocket-5e56c7e484a0?source=collection_archive---------4-----------------------#2022-04-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="13b9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用这个成熟的Rust框架的力量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/63397820e3b0a9b13700a6fefb298ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fttqmqpq6DKNX7nJlAGgPw.png"/></div></div></figure><p id="426c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个故事中，我想向你展示一个例子，如何在<a class="ae lq" href="https://rocket.rs/" rel="noopener ugc nofollow" target="_blank"> Rocket framework </a>之上创建一个带有后端的web应用程序。</p><p id="592c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们将通过构建docker映像来容器化应用程序。这个应用程序被认为做了一些非常简单的事情。它将提供随机点的凸包的可视化，正如我在最近的帖子<a class="ae lq" href="https://applied-math-coding.medium.com/grahams-scan-algorithm-an-implementation-in-rust-39c7536591b5" rel="noopener">这里</a>中所承诺的。如果你对所使用的算法感兴趣，你可以参考前面提到的文章，但是为了理解后面的内容，这并不是不可避免的。如果你对Rust完全陌生，在阅读这篇文章之前，你可能想先从一些介绍开始，比如这里的<a class="ae lq" href="https://medium.com/@applied-math-coding/an-introduction-into-rust-part-1-installation-variables-types-functions-3ed7846b21b6" rel="noopener"/>。</p><p id="3da7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在这个故事中的目标如下:</p><ol class=""><li id="c000" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">创建一个火箭服务器并通过一个API服务于Graham的扫描算法</li><li id="2899" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">创建基于浏览器的前端，请求服务器对一组随机点运行上述算法</li><li id="3205" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">将前端作为静态资源托管在Rocket服务器上</li><li id="8262" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">创建构建前端、后端和运行服务器的docker文件</li></ol></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="c3c3" class="mm mn it bd mo mp mq dn mr ms mt dp mu ld mv mw mx lh my mz na ll nb nc nd ne bi translated">创建服务器:</h2><p id="70ca" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">首先，Rocket是一个相对成熟的用Rust构建web应用的框架。它支持许多功能，并执行良好和安全的标准。</p><p id="6c2a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们通过以下方式创建一个项目…</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="b959" class="mm mn it nl b gy np nq l nr ns">cargo init --bin</span></pre><p id="d6ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">…在某个项目文件夹中。这为我们创造了必要的<code class="fe nt nu nv nl b">Cargo.toml</code>。</p><p id="9df9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了能够使用Rocket，我们需要添加以下依赖项:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="b325" class="mm mn it nl b gy np nq l nr ns">...</span><span id="d39b" class="mm mn it nl b gy nw nq l nr ns">[dependencies]<br/><strong class="nl iu">serde </strong>= { version = "1.0.136", features = ["derive"] }<br/><strong class="nl iu">rocket </strong>= { version = "0.5.0-rc.1", features= ["json"] }</span></pre><p id="c9cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nt nu nv nl b">serde</code>用于支持请求/响应数据的解序列化，对于<code class="fe nt nu nv nl b">rocket</code>，我们设置了特性<code class="fe nt nu nv nl b">json</code>。</p><p id="9290" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nt nu nv nl b">Features</code>是一个货物的概念，可以很好的减少建筑尺寸。特别是，<code class="fe nt nu nv nl b">json</code>特性支持<code class="fe nt nu nv nl b">json</code>数据请求/响应，而<code class="fe nt nu nv nl b">serde</code>的<code class="fe nt nu nv nl b">derive</code>特性包含一些实用程序，可以轻松地为我们的Rust数据类型“派生”解编/序列化特征。我们将很快看到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="f12e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这段代码很容易定义两个端点:</p><ul class=""><li id="6c7c" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp nz lx ly lz bi translated"><code class="fe nt nu nv nl b">GET /test</code>只返回字符串<code class="fe nt nu nv nl b">hello world</code></li><li id="5262" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp nz lx ly lz bi translated">这需要一个JSON编码的<code class="fe nt nu nv nl b">Point</code>列表，在这些点上调用Graham扫描算法并返回结果，即一个JSON编码的<code class="fe nt nu nv nl b">Point</code>列表</li></ul><p id="aae8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在后一个端点中，宏包含参数<code class="fe nt nu nv nl b">data</code>。这应该将解析后的请求体的结果与变量<code class="fe nt nu nv nl b">points</code>粘合在一起。</p><p id="3083" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，用<code class="fe nt nu nv nl b">#[launch]</code>标注的函数<code class="fe nt nu nv nl b">rocket</code>提供了实际的main方法。这里，构建了<code class="fe nt nu nv nl b">rocket</code>的一个实例(服务器)，并且针对上述端点安装了几个路径。</p><p id="195a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像<code class="fe nt nu nv nl b">.mount("/api", routes![convex_hull, index])</code>一样<code class="fe nt nu nv nl b">mount</code>的调用使得<code class="fe nt nu nv nl b">convex_hull</code>中定义的端点分别。<code class="fe nt nu nv nl b">index</code>在普通路线<code class="fe nt nu nv nl b">/api</code>下可用。对<code class="fe nt nu nv nl b">mount</code>的第一次调用在路径<code class="fe nt nu nv nl b">/</code>下绑定了整个文件系统，即<code class="fe nt nu nv nl b">/client/dist</code>。这使得放置在<code class="fe nt nu nv nl b">/client/dist</code>中的文件直接可用。我们将使用它来托管所有静态前端资产，如<code class="fe nt nu nv nl b">index.html</code>等。</p><p id="5b50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我想，再简单不过了。此外，这种结构类似于一种典型的建立服务器的现代方式(例如参见<a class="ae lq" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>)。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="258a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了这些，我们就可以像往常一样通过<code class="fe nt nu nv nl b">cargo run</code>运行项目，并将浏览器指向<code class="fe nt nu nv nl b"><a class="ae lq" href="http://localhost:8000/test" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/test</a></code>以获取字符串<code class="fe nt nu nv nl b">hello world</code>。</p><p id="51ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在<code class="fe nt nu nv nl b">main.rs</code>中增加了一项内容，这是对我们端点的e-2-e测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="a7b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在一个更大的项目中，您可能会将它放在另一个文件中，但是出于我们的目的，它可以放在<code class="fe nt nu nv nl b">main.rs</code>中。这也是铁锈和火箭一起发光的地方。首先，测试通常是通过添加一个用<code class="fe nt nu nv nl b">#[cfg(test)]</code>标注的模块来建立的。所以我们已经知道了将运行所有测试的测试员:<code class="fe nt nu nv nl b">cargo test</code>。</p><p id="ce37" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其次，Rocket在一个模块<code class="fe nt nu nv nl b">local</code>中提供了各种工具，支持针对端点测试客户端请求。正是这个部分创建了一个HTTP客户端并向<code class="fe nt nu nv nl b">/api/convex-hull</code>发出POST请求:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="6e6b" class="mm mn it nl b gy np nq l nr ns">// creating a client<br/>let client = Client::tracked(super::rocket()).unwrap();</span><span id="b1c5" class="mm mn it nl b gy nw nq l nr ns">// making a POST request with JSON-encoded body<br/>let response = client<br/>   .post("/api/convex-hull").json(&amp;points).dispatch();</span></pre><p id="da43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">剩下的代码只是使用通常的<code class="fe nt nu nv nl b">assertEq!</code>来验证产生的响应是否与我们的预期一致。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="9ac2" class="mm mn it bd mo mp mq dn mr ms mt dp mu ld mv mw mx lh my mz na ll nb nc nd ne bi translated">创建客户端</h2><p id="8b03" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">这个应用程序的特定客户端是一个用<a class="ae lq" href="https://vitejs.dev/" rel="noopener ugc nofollow" target="_blank"> Vite </a>构建的<a class="ae lq" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue </a>项目。由于客户端不是我们在这个故事中的主要焦点，我不会给出比下面更多的细节。</p><p id="4a07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如上所述，服务器被设置为针对目录<code class="fe nt nu nv nl b">/client/dist</code>安装路由<code class="fe nt nu nv nl b">/</code>。因此，无论客户端是什么，它的<code class="fe nt nu nv nl b">html, js, css</code>资源都必须在这个文件夹中可用。</p><p id="cf40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我将Vue与TypeScript和Sass一起使用，所以需要一个构建步骤来生成所有浏览器可读的工件，并将它们放入提到的文件夹中。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="8dff" class="mm mn it bd mo mp mq dn mr ms mt dp mu ld mv mw mx lh my mz na ll nb nc nd ne bi translated">集装箱化(码头工人)</h2><p id="5a4e" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">Docker是一种发布或部署应用程序的好方法。对于接下来的内容，我们假设环境中已经安装了某个版本的docker，并且您对docker有一些基本的了解。</p><p id="2aa4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">多阶段构建应用程序的docker文件如下:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="43fe" class="mm mn it nl b gy np nq l nr ns">FROM node:16.13.1 AS <strong class="nl iu">client</strong><br/>WORKDIR /app<br/>COPY ./client .<br/>RUN npm i<br/>RUN npm run build</span><span id="022e" class="mm mn it nl b gy nw nq l nr ns">FROM rust:1.60 AS <strong class="nl iu">server</strong><br/>WORKDIR /app<br/>COPY . .<br/>COPY --from=client /app/dist ./client/dist<br/>RUN cargo build --release<br/>CMD ["./target/release/convex-hull"]</span></pre><p id="90c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一部分是关于构建前端。这是在包含Node.js并运行Vite的所有构建步骤的映像上完成的。</p><p id="933d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第二部分是构建我们的服务器。来自上述前端构建的工件被复制到这个阶段，然后我们指示cargo构建项目:<code class="fe nt nu nv nl b">cargo build --release</code>。</p><p id="0437" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后一个命令(<code class="fe nt nu nv nl b">CMD</code>)只有在我们稍后运行容器中的图像时才会执行。</p><p id="fc83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面这个<code class="fe nt nu nv nl b">Dockerfile</code>是这样执行的:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="af96" class="mm mn it nl b gy np nq l nr ns">docker build -t convexhull .</span></pre><p id="727e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，我们可以通过执行以下操作来验证图像是否已经创建</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="101e" class="mm mn it nl b gy np nq l nr ns">docker image ls</span></pre><p id="b67c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们可以运行映像并进行端口映射，以确保我们能够从外部访问服务器:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="d5d8" class="mm mn it nl b gy np nq l nr ns">docker run -it -p 8000:8000  convexhull</span></pre><p id="4e9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了这个，我们可以将我们的浏览器指向<code class="fe nt nu nv nl b"><a class="ae lq" href="http://localhost:8000/" rel="noopener ugc nofollow" target="_blank">http:\\localhost:8000</a></code>,并且希望，下面的不那么压倒性的用户界面会出现:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/26a13eedc2000817d98036e4eda03fed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5SLK3X9U_2wZFq00FwkpaA.png"/></div></div></figure><p id="616a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，上面的docker文件只是为了快速共享一个原型项目。它远远没有被优化，并且存在许多选择来显著减小它的尺寸。</p><p id="c9a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">docker的一个非常好的特性是<a class="ae lq" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> docker-hub </a>。如果您在这里创建了一个帐户，您可以将上面构建的映像推送到一个存储库中，并与其他人共享。你只需要做以下步骤:</p><p id="21b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，在docker-hub创建一个新的存储库。然后执行以下步骤:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="11b2" class="mm mn it nl b gy np nq l nr ns">docker login  // this will ask you to authenticate</span><span id="e283" class="mm mn it nl b gy nw nq l nr ns">docker tag convexhull:latest YOURACCOUNT/REPONAME:convexhull</span><span id="b8e0" class="mm mn it nl b gy nw nq l nr ns">docker push YOURACCOUNT/REPONAME:convexhull</span></pre><p id="17af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将把图像<code class="fe nt nu nv nl b">convexhull</code>推送到相应的存储库。请确保用您选择的名称替换<code class="fe nt nu nv nl b">YOURACCOUNT/REPONAME</code>。</p><p id="0eb0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽你所能告诉你想分享你的图片的人去做</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="fa4a" class="mm mn it nl b gy np nq l nr ns">docker pull YOURACCOUNT/REPONAME:convexhull</span><span id="4f50" class="mm mn it nl b gy nw nq l nr ns">docker run -it -p 8000:8000 YOURACCOUNT/REPONAME:convexhull</span></pre><p id="fe70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想用我的，你可以这样做</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="6914" class="mm mn it nl b gy np nq l nr ns">docker pull appliedmathcoding/convexhull:convexhull<br/>docker run -it -p 8000:8000 appliedmathcoding/convexhull:convexhull</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="bd82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以从这个<a class="ae lq" href="https://github.com/applied-math-coding/convex-hull" rel="noopener ugc nofollow" target="_blank">库</a>中看到并克隆整个项目。一定要跑</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="cad6" class="mm mn it nl b gy np nq l nr ns">git checkout v1.0</span></pre><p id="7bc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从克隆的存储库中查看与本文对应的版本。</p><p id="0f17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，这个故事只讲述了用Rocket开发web应用程序的基础知识，但是更多的内容还在后面的文章中。</p><p id="f71a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读！</p></div></div>    
</body>
</html>