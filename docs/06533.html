<html>
<head>
<title>Decorator Pattern and Python Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">装饰模式和Python装饰器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/decorator-pattern-and-python-decorators-b0b573f4c1ce?source=collection_archive---------5-----------------------#2020-10-09">https://betterprogramming.pub/decorator-pattern-and-python-decorators-b0b573f4c1ce?source=collection_archive---------5-----------------------#2020-10-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a8ab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么它们不一样？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d256673ff833f6f7826f35edb1cba104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y-CN5rJfknSpaOKP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@coffeegeek?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">咖啡极客</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><blockquote class="kz la lb"><p id="8031" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><a class="ae ky" href="http://c2.com/cgi/wiki?DecoratorPattern" rel="noopener ugc nofollow" target="_blank">装饰图案</a>是在<a class="ae ky" href="http://c2.com/cgi/wiki?DesignPatternsBook" rel="noopener ugc nofollow" target="_blank">设计图案手册</a>中描述的图案。这是一种明显修改对象行为的方式，通过用一个相似的接口将它封装在一个装饰对象中。</p><p id="4b46" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这不要与<a class="ae ky" href="https://wiki.python.org/moin/PythonDecorators" rel="noopener ugc nofollow" target="_blank"> PythonDecorators </a>混淆，后者是一种用于动态修改函数或类的语言特性。”——<a class="ae ky" href="https://wiki.python.org/moin/DecoratorPattern" rel="noopener ugc nofollow" target="_blank">维基。蟒蛇</a></p></blockquote><p id="e9e8" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">Python有一个特性叫做Decorator，不要和设计模式Decorator模式混淆。在本文中，我将通过装饰模式和Python装饰器的例子来帮助区分这两者。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="9b8a" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">装饰图案</h1><p id="77f6" class="pw-post-body-paragraph lc ld it lf b lg nb ju li lj nc jx ll lz nd lo lp ma ne ls lt mb nf lw lx ly im bi translated">所以让我们把注意力集中在上面的定义上:“这是一种明显修改对象行为的方式，通过用一个相似的接口把它封装在一个装饰对象中。”</p><h2 id="91d7" class="ng mk it bd ml nh ni dn mp nj nk dp mt lz nl nm mv ma nn no mx mb np nq mz nr bi translated">行为矫正</h2><p id="0738" class="pw-post-body-paragraph lc ld it lf b lg nb ju li lj nc jx ll lz nd lo lp ma ne ls lt mb nf lw lx ly im bi translated">让我们想象一个对象a，如果对它调用方法<code class="fe ns nt nu nv b">foo</code>，它会以某种方式表现。装饰模式修改了这种行为。所以当对象A被修饰时，同样的<code class="fe ns nt nu nv b">foo</code> <em class="le"> </em>方法<em class="le"> </em>现在表现不同。</p><p id="3ab7" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">对于一个具体的例子，让我们创建一个类实现，它通过将两个数相加并返回结果来处理这两个数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="db27" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">稍微解释一下上面的代码:它实现了类<code class="fe ns nt nu nv b">Add</code> <em class="le"> </em>，这个类的构造函数有两个参数:<code class="fe ns nt nu nv b">a</code>和<code class="fe ns nt nu nv b">b</code>。方法<code class="fe ns nt nu nv b">process</code>将这两个(<code class="fe ns nt nu nv b">a</code>和<code class="fe ns nt nu nv b">b</code>)相加，并返回相加的结果。</p><p id="ad63" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">现在让我们修改它的行为，使<code class="fe ns nt nu nv b">process</code>方法的输出乘以一个指定的数字<code class="fe ns nt nu nv b">num</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="f9d8" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><code class="fe ns nt nu nv b">modify_process</code>方法通过将方法<code class="fe ns nt nu nv b">process</code>的结果乘以指定的数字<code class="fe ns nt nu nv b">num</code>来修改<code class="fe ns nt nu nv b">decorated_object</code>的行为。所以到目前为止，我们已经能够修改行为，但是还没有“用类似的接口将它封装在装饰对象中”我们就这么做吧。</p><h2 id="d009" class="ng mk it bd ml nh ni dn mp nj nk dp mt lz nl nm mv ma nn no mx mb np nq mz nr bi translated">封闭对象</h2><p id="a95c" class="pw-post-body-paragraph lc ld it lf b lg nb ju li lj nc jx ll lz nd lo lp ma ne ls lt mb nf lw lx ly im bi translated">我们的下一个任务是封装类<code class="fe ns nt nu nv b">Add</code>的对象。为此，我们将创建另一个<code class="fe ns nt nu nv b">EnclosedAdd</code>。<code class="fe ns nt nu nv b">EnclosedAdd</code> <em class="le"> </em>括住了<code class="fe ns nt nu nv b">Add</code>类的对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0f31" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">正如你所看到的，<code class="fe ns nt nu nv b">EnclosedAdd</code>没有公开任何方法，似乎我们后退了一步，因为我们失去了类<code class="fe ns nt nu nv b">Add</code>的功能。为了补救这一点，我们将创建一个类似于类<code class="fe ns nt nu nv b">Add</code>的接口，这是定义中缺少的最后一样东西。</p><h2 id="137e" class="ng mk it bd ml nh ni dn mp nj nk dp mt lz nl nm mv ma nn no mx mb np nq mz nr bi translated">增强型界面</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="b779" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">最后，为了创建一个类似的接口，我们从修饰类<code class="fe ns nt nu nv b">Multiply</code>(从<code class="fe ns nt nu nv b">EnclosedAdd</code>重命名)中公开方法<code class="fe ns nt nu nv b">process</code>。<code class="fe ns nt nu nv b">Multiply</code>用数字<code class="fe ns nt nu nv b">num</code>初始化，该数字与修饰对象上的方法<code class="fe ns nt nu nv b">process</code>的结果相乘。<code class="fe ns nt nu nv b">Multiply</code>通过封装<strong class="lf iu"> </strong>(通过构造函数)来修改对象<code class="fe ns nt nu nv b">add_object</code>的行为，并提供类似的接口<code class="fe ns nt nu nv b">process</code>。</p><h2 id="c2b8" class="ng mk it bd ml nh ni dn mp nj nk dp mt lz nl nm mv ma nn no mx mb np nq mz nr bi translated">嵌套</h2><p id="09ee" class="pw-post-body-paragraph lc ld it lf b lg nb ju li lj nc jx ll lz nd lo lp ma ne ls lt mb nf lw lx ly im bi translated">多个装饰器可以应用于被装饰的对象。让我们看看如何将它们嵌套在一起:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="2c70" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在上面的代码中，我们在链中应用了<code class="fe ns nt nu nv b">Multiply</code>和<code class="fe ns nt nu nv b">Divide</code>装饰器。当<code class="fe ns nt nu nv b">process</code>方法在<code class="fe ns nt nu nv b">divide_multiply_add_object</code>(类<code class="fe ns nt nu nv b">Divide</code>的实例)上被调用时，<code class="fe ns nt nu nv b">I am divide process</code> <strong class="lf iu"> </strong>被打印在控制台中。然后在类的修饰对象上调用<code class="fe ns nt nu nv b">process</code>。这种情况下就是<code class="fe ns nt nu nv b">multiply_add_object</code>。它打印<code class="fe ns nt nu nv b">I am multiply process</code>然后在<code class="fe ns nt nu nv b">add_object</code>(装饰对象<code class="fe ns nt nu nv b">multiply_add_object</code>)上调用<code class="fe ns nt nu nv b">process</code>。那印<code class="fe ns nt nu nv b">I am add process</code>。<code class="fe ns nt nu nv b">process</code>的结果沿链向上。<code class="fe ns nt nu nv b">add_object</code>上的<code class="fe ns nt nu nv b">process</code>方法产生<em class="le"> 1 + 4 = 5 </em>，再乘以<code class="fe ns nt nu nv b">multiply_add_object</code>的<code class="fe ns nt nu nv b">process</code>中的<em class="le"> 4 (5 * 4 = 20) </em>。最后在<code class="fe ns nt nu nv b">divide_multiply_add_object</code> <em class="le">的<code class="fe ns nt nu nv b">process</code>中用<em class="le"> 5 ( 20 / 5 = 4) </em>除<em class="le"> 20 </em>。</em></p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="64fa" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">Python装饰者</h1><p id="4dd1" class="pw-post-body-paragraph lc ld it lf b lg nb ju li lj nc jx ll lz nd lo lp ma ne ls lt mb nf lw lx ly im bi translated">现在让我们看看Python装饰器。</p><blockquote class="kz la lb"><p id="0631" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">“Python decorator是对Python语法的一种特殊改变，它允许我们更方便地修改函数和方法(以及未来版本中可能的类)。这支持更多可读的<a class="ae ky" href="https://wiki.python.org/moin/DecoratorPattern" rel="noopener ugc nofollow" target="_blank"> DecoratorPattern </a>应用程序，也支持其他用途。”— <a class="ae ky" href="https://wiki.python.org/moin/PythonDecorators" rel="noopener ugc nofollow" target="_blank">维基。Python </a></p></blockquote><h2 id="e1c1" class="ng mk it bd ml nh ni dn mp nj nk dp mt lz nl nm mv ma nn no mx mb np nq mz nr bi translated">函数与方法</h2><p id="2b90" class="pw-post-body-paragraph lc ld it lf b lg nb ju li lj nc jx ll lz nd lo lp ma ne ls lt mb nf lw lx ly im bi translated">在继续之前，我想指出这个定义是在区分函数和方法。这是一个重要的区别。方法是对象的一部分，可以改变对象的状态，而函数是独立的，不是对象的一部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="1a0f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在上面的代码中，<code class="fe ns nt nu nv b">process</code>是一个方法，而<code class="fe ns nt nu nv b">add_process</code>是一个函数。<code class="fe ns nt nu nv b">process</code>将是类<code class="fe ns nt nu nv b">Add</code>对象的一部分，而<code class="fe ns nt nu nv b">add_process</code>是独立的。我希望这澄清了函数和方法之间的区别。在这一节中，我将介绍Python decorators的函数和方法的例子。</p><h2 id="4047" class="ng mk it bd ml nh ni dn mp nj nk dp mt lz nl nm mv ma nn no mx mb np nq mz nr bi translated">函数上的Python装饰器</h2><p id="b3a2" class="pw-post-body-paragraph lc ld it lf b lg nb ju li lj nc jx ll lz nd lo lp ma ne ls lt mb nf lw lx ly im bi translated">在我们进入更复杂的Python装饰器之前，让我们看一个简单的装饰器。我先从一个简单的<code class="fe ns nt nu nv b">add</code>方法开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="1154" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">上面的函数只需要两个参数:<code class="fe ns nt nu nv b">a</code>和<code class="fe ns nt nu nv b">b</code>。该函数的行为是将这两个输入参数相加，并返回相加的结果。</p><p id="37dc" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">现在我要装饰这个方法，这样方法<code class="fe ns nt nu nv b">add</code>的结果乘以2:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="d189" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">为了实现这一点，我创建了函数<code class="fe ns nt nu nv b">multiply_by_two</code> <em class="le">。</em> <code class="fe ns nt nu nv b">multiply_by_two</code>将另一个函数<code class="fe ns nt nu nv b">func</code>作为输入。它创建了另一个函数<code class="fe ns nt nu nv b">_multiply_by_two</code>，该函数有两个参数，这两个参数随后被传递给输入函数<code class="fe ns nt nu nv b">func</code>——其结果乘以2。<code class="fe ns nt nu nv b">multiply_by_two</code> <em class="le"> </em>返回构造的方法<code class="fe ns nt nu nv b">_multiply_by_two</code>。</p><p id="91a3" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我所做的是创建装饰器<code class="fe ns nt nu nv b">multiply_by_two</code>，它基本上是通过将输入函数<code class="fe ns nt nu nv b">func</code>乘以2来装饰它的功能(顾名思义)。现在让我们来看看它的运行情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="2794" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">上面的代码用<code class="fe ns nt nu nv b">multiply_by_two</code> <em class="le">修饰了函数<code class="fe ns nt nu nv b">add</code>。</em>这样做的构造是在被修饰的函数(<code class="fe ns nt nu nv b">add</code>)之前，将<code class="fe ns nt nu nv b">@</code>符号用于被修饰的函数(<code class="fe ns nt nu nv b">multiply_by_two</code> ) <em class="le"> </em>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="8448" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在上面的代码中，同一个装饰器被应用于一个减法函数。在这种情况下，输出为<em class="le"> -8 </em>。所以很容易看出装修工是多才多艺的。它们可以相当普遍地应用。</p><h2 id="56e0" class="ng mk it bd ml nh ni dn mp nj nk dp mt lz nl nm mv ma nn no mx mb np nq mz nr bi translated">方法上的Python装饰器</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="6afd" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在上面的代码中，<code class="fe ns nt nu nv b">add</code>是一个方法，也是类<code class="fe ns nt nu nv b">DecoratedAdd</code>的一部分。我们用一个类似的函数(<code class="fe ns nt nu nv b">multiply_by_two</code> ) <em class="le"> </em>来装饰它。如果我们执行上面的代码，我们得到<em class="le"> 12 </em>，根据意图是<em class="le"> (1 + 5) *2 </em>。需要注意的一点是，在<code class="fe ns nt nu nv b">_multiply_by_two</code>中，<code class="fe ns nt nu nv b">self</code>是一个参数，因为<code class="fe ns nt nu nv b">add</code>将<code class="fe ns nt nu nv b">self</code>作为参数，是类<code class="fe ns nt nu nv b">Add</code>的实例的一个方法。我们可以这样概括，一个单独的<code class="fe ns nt nu nv b">multiply_by_two</code> <em class="le"> </em>既可以用来修饰函数，也可以用来修饰方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0092" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">现在，我们不是传递预先确定的参数，而是传递<code class="fe ns nt nu nv b">*args, **kw</code>来概括它。</p><h2 id="89d1" class="ng mk it bd ml nh ni dn mp nj nk dp mt lz nl nm mv ma nn no mx mb np nq mz nr bi translated">嵌套</h2><p id="1df4" class="pw-post-body-paragraph lc ld it lf b lg nb ju li lj nc jx ll lz nd lo lp ma ne ls lt mb nf lw lx ly im bi translated">现在让我们来看看Python decorators的嵌套，decorator可以一个接一个地应用于一个函数。保持算术主题，我现在将创建另一个方法，<code class="fe ns nt nu nv b">divide_by_three</code>，它与<code class="fe ns nt nu nv b">multiply_by_two</code>相同，只是它使用输入<code class="fe ns nt nu nv b">num</code>将修饰方法的结果除以3。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="c3a3" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">要嵌套decorators，需要在实际的被修饰方法之前，使用与之前使用的<code class="fe ns nt nu nv b">@</code>符号相同的机制，一次指定一个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="05c2" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">就像上面的代码一样，我先用<code class="fe ns nt nu nv b">multiply_by_two</code>然后用<code class="fe ns nt nu nv b">divide_by_three</code>来装饰方法<code class="fe ns nt nu nv b">add</code>。这产生了嵌套，因为应用了第一个<code class="fe ns nt nu nv b">multiply_by_two</code>和第二个<code class="fe ns nt nu nv b">divide_by_three</code>装饰器。应用程序的顺序与它们在代码中出现的顺序相反，这一点值得注意。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="015a" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="789f" class="pw-post-body-paragraph lc ld it lf b lg nb ju li lj nc jx ll lz nd lo lp ma ne ls lt mb nf lw lx ly im bi translated">在本文中，我通过给出代码示例讨论了Decorator模式和Python decorators之间的区别。此外，嵌套还解释了如何将多个decorators应用于同一个对象或方法。希望你觉得有用！</p></div></div>    
</body>
</html>