<html>
<head>
<title>React Router and Client-Side Routing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应路由器和客户端路由</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-router-and-client-side-routing-2e483452fbfb?source=collection_archive---------4-----------------------#2019-09-24">https://betterprogramming.pub/react-router-and-client-side-routing-2e483452fbfb?source=collection_archive---------4-----------------------#2019-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a4fb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对React路由器的服务器端和客户端路由有更深入的了解</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/48799daf154e735a6861fac8b85174a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DU5n6M4z1mRlxEl_Co6EGg.jpeg"/></div></div></figure><p id="c7d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您一直在使用React编程，或者考虑过使用React，那么很有可能在对话中出现了React路由器,作为React中处理客户端路由的一种方式。</p><p id="3d3b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章旨在涵盖对服务器和客户端路由的更高层次的理解，以及如果您能够利用React Router的强大功能，它将如何成为您的绝佳选择。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="aa26" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">服务器端路由和客户端路由的区别</h1><h2 id="026c" class="mn lw iq bd lx mo mp dn mb mq mr dp mf la ms mt mh le mu mv mj li mw mx ml my bi translated">服务器端路由</h2><p id="7149" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">处理路由更常见的方法是服务器端路由。服务器端路由不是React路由器的一部分，但它仍然是处理路由的最常见形式。</p><p id="a5ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用服务器端路由，用户单击一个链接，向服务器(另一台计算机)请求新页面或新数据。然后向用户提供新的数据或文档。</p><p id="c662" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们再细分一下:</p><p id="2d4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当用户点击网页上的链接时，另一个完整的页面被加载并呈现在屏幕上。URL路径被更新以匹配用户在网页的当前状态中的位置。</p><p id="6e1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">加载和呈现的“整个页面”是通过服务器完成的。服务器端路由是导致整个页面刷新的原因，因为我们向服务器发出了另一个请求，服务器为我们提供了一个全新的页面来显示。</p><p id="637a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">逐步:</p><ol class=""><li id="f930" class="ne nf iq kt b ku kv kx ky la ng le nh li ni lm nj nk nl nm bi translated">用户点击网页上的链接。</li></ol><p id="2ae2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.该链接向服务器(另一台计算机)发送请求。</p><p id="5df3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.服务器用新内容进行响应。</p><p id="44bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">4.该内容刷新用户屏幕上的信息。</p><p id="bd62" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">5.URL被更新以反映用户在网页上的位置。</p><p id="b3e5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">服务器为浏览器提供内容和文件，以便向用户显示。</p><p id="8dbf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用服务器端路由的主要缺点是内容显示在页面上所需的时间各不相同。如果用户请求的页面仍然有页眉和页脚信息显示在屏幕上，那么我们为什么需要重新加载这些信息呢？</p><p id="bb5b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是服务器不知道我们不需要重新加载那些信息，因为它已经被显示了。服务器将发回需要显示的文件，然后调用完全刷新来显示这个新文件。</p><p id="ef0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">随着全面更新，我们现在将互联网速度纳入等式。网速增加了显示在网页上的时间。</p><p id="bf90" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，我们如何防止这种完全的页面刷新，并可能减缓我们的渲染时间呢？</p><h2 id="5420" class="mn lw iq bd lx mo mp dn mb mq mr dp mf la ms mt mh le mu mv mj li mw mx ml my bi translated">客户端路由</h2><p id="e466" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">客户端路由是JS文件中呈现给前端(或客户端)的路由的内部处理。</p><p id="e05d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">客户端路由已经成为越来越多的开发人员在创建他们的应用程序时考虑的事情的原因是因为创建单页面应用程序(spa)的流行。</p><p id="3432" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用SPA，当用户单击应用程序中的内部链接时，目标将是在URL栏中看到一个变化，以显示页面发生了更新，而没有完全刷新页面。</p><p id="0328" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了SPA，我们不需要加载多个页面，只需要来自服务器的带有初始HTML、CSS和JS文件的原始请求。因此，客户端路由用于创建SPA体验，同时使路由更加统一和有组织，便于用户查看。</p><p id="43ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">路由是为了给我们的用户一个更好的整体体验，因为他们能够在应用程序的URL栏中找到他们所在的位置，而不需要我们发出多个服务器请求。</p><h2 id="0be1" class="mn lw iq bd lx mo mp dn mb mq mr dp mf la ms mt mh le mu mv mj li mw mx ml my bi translated"><strong class="ak">但是我们为什么要在乎呢？</strong></h2><p id="b7ab" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">我们关心客户端路由有几个原因:</p><ol class=""><li id="b224" class="ne nf iq kt b ku kv kx ky la ng le nh li ni lm nj nk nl nm bi translated">它给用户一个更直观的URL，让用户能够看到他们当前在应用程序中的位置。</li><li id="3bf9" class="ne nf iq kt b ku nn kx no la np le nq li nr lm nj nk nl nm bi translated">我们想让用户能够使用<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" rel="noopener ugc nofollow" target="_blank">历史API </a>在浏览器中使用“后退”和“前进”按钮。</li><li id="217f" class="ne nf iq kt b ku nn kx no la np le nq li nr lm nj nk nl nm bi translated">它使用户能够键入特定的URL，并能够在应用程序中加载特定的视图。</li><li id="333b" class="ne nf iq kt b ku nn kx no la np le nq li nr lm nj nk nl nm bi translated">应用程序在不同链接之间的延迟时间会更短，因为呈现下一个视图所需的信息已经在页面的初始加载之后加载了。</li></ol></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="9009" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">React路由器的客户端路由方法</h1><blockquote class="ns"><p id="17ea" class="nt nu iq bd nv nw nx ny nz oa ob lm dk translated"><a class="ae ln" href="https://reacttraining.com/react-router/" rel="noopener ugc nofollow" target="_blank"> <em class="oc"> "React Router是一个导航组件的集合，以声明方式与您的应用程序组合在一起。</em></a><em class="oc">”—反应训练</em></p></blockquote><p id="0d5d" class="pw-post-body-paragraph kr ks iq kt b ku od jr kw kx oe ju kz la of lc ld le og lg lh li oh lk ll lm ij bi translated">React路由器对客户端路由采取更动态而非静态的方法。但是这两者有什么区别呢？</p><h2 id="e150" class="mn lw iq bd lx mo mp dn mb mq mr dp mf la ms mt mh le mu mv mj li mw mx ml my bi translated">静态路由</h2><p id="4414" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">简而言之，对于静态路由，我们预先建立我们希望到达的路由，然后在需要时调用这些路由。这可以通过一个单独的JavaScript文件来实现，这个文件可能叫做<code class="fe oi oj ok ol b">routes.js</code>，它包含了你的应用程序需要到达的所有可能的路径。</p><p id="cb4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，每当用户点击一个链接时，它将调用您创建的那个<code class="fe oi oj ok ol b">routes.js</code>文件，并寻找与被点击的链接相匹配的端点。</p><p id="7b03" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这在单击链接后创建了一个额外的步骤，因为现在调用服务器来响应这个请求。这样做的问题是，这些请求需要时间来解决。这个新的请求时间可以根据调用服务器文件的连接强度而变化。</p><p id="8a42" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，如果你以前用过React <strong class="kt ir"> </strong>，你会很快意识到这不是做这件事的“React方式”。为了进一步证明这一点，在使用React的旧应用程序中，您可能不得不创建自己的API，其功能与您的<a class="ae ln" href="https://reactjs.org/docs/react-component.html" rel="noopener ugc nofollow" target="_blank">组件生命周期方法</a>相同。</p><h2 id="b88f" class="mn lw iq bd lx mo mp dn mb mq mr dp mf la ms mt mh le mu mv mj li mw mx ml my bi translated">动态路由</h2><p id="9a4c" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">使用动态路径，路径会随着应用程序的渲染而更新。换句话说，在URL栏中看到的路由正在更新以供客户端查看，但是，没有与任何服务器的通信来实现这一点。</p><p id="7359" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">反应路由器本质上是一个组件。这意味着向React应用程序添加路由器功能的方式与向React应用程序添加任何其他功能的方式相同。</p><p id="0593" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们深入下面的例子:</p><pre class="kg kh ki kj gt om ol on oo aw op bi"><span id="8723" class="mn lw iq ol b gy oq or l os ot">import React from "react";<br/>import ReactDOM from 'react-dom';</span><span id="47ac" class="mn lw iq ol b gy ou or l os ot"><strong class="ol ir">// import your BrowserRouter here just like importing any other functionality</strong></span><span id="3835" class="mn lw iq ol b gy ou or l os ot">import { BrowserRouter as Router, Route } from 'react-router-dom';</span><span id="52e8" class="mn lw iq ol b gy ou or l os ot">const HomePage = () =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="af3f" class="mn lw iq ol b gy ou or l os ot"><strong class="ol ir">// now &lt;Route&gt; is being wrapped around &lt;Router&gt; to have the router coordinate displayed instead</strong></span><span id="70f1" class="mn lw iq ol b gy ou or l os ot">ReactDOM.render((<br/>  &lt;Router&gt;<br/>    &lt;Route path='/' render={HomePage} /&gt;<br/>  &lt;/Router&gt;),<br/>  document.getElementById('root')<br/>);</span></pre><p id="7135" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的例子中，我们将<code class="fe oi oj ok ol b">BrowserRouter</code>导入到我们的应用程序中，并使用<code class="fe oi oj ok ol b">&lt;Router&gt;</code>功能来匹配<code class="fe oi oj ok ol b">path</code>。</p><p id="4e4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是React路由器的动态路由的真正优势在于:</p><pre class="kg kh ki kj gt om ol on oo aw op bi"><span id="fc3f" class="mn lw iq ol b gy oq or l os ot">import React from "react";<br/>import ReactDOM from 'react-dom';<br/>import { BrowserRouter as Router, Route } from 'react-router-dom';</span><span id="9fe7" class="mn lw iq ol b gy ou or l os ot">const HomePage = () =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="30f8" class="mn lw iq ol b gy ou or l os ot"><strong class="ol ir">// Using match to dynamically generate which user is being passed</strong></span><span id="e7da" class="mn lw iq ol b gy ou or l os ot">const User = ({ <strong class="ol ir">match</strong> }) =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h3&gt;{<strong class="ol ir">match</strong>.params.userId}&lt;/h3&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="4d89" class="mn lw iq ol b gy ou or l os ot">ReactDOM.render((<br/>  &lt;Router&gt;<br/>    &lt;Route path='/' render={HomePage} /&gt;</span><span id="21ca" class="mn lw iq ol b gy ou or l os ot"><strong class="ol ir">// the new path will be the user's id passed into the User component</strong><br/>    &lt;Route path='/<strong class="ol ir">:userId</strong>' component={<strong class="ol ir">User</strong>} /&gt;</span><span id="6f2f" class="mn lw iq ol b gy ou or l os ot">  &lt;/Router&gt;),<br/>  document.getElementById('root')<br/>);</span></pre><p id="40c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们刚才看到了什么？</p><p id="912b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们将URL与一个<code class="fe oi oj ok ol b">UserId</code>匹配时，将使用<code class="fe oi oj ok ol b">match</code>属性来呈现为用户显示的路线，以将特定的URL与传递给<code class="fe oi oj ok ol b">match.params.userId</code>的ID匹配到<code class="fe oi oj ok ol b">&lt;Route&gt;</code>中。</p><p id="8c7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React Router允许我们在保持React的动态渲染和路由的同时保持统一的链接，但就像技术中的其他事情一样，使用动态路由肯定有缺点。</p><p id="efd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个关键的缺点是对主页的初始请求可能需要更长的时间。由于整个页面需要在初始加载时加载，这可能会导致对主页的初始请求花费更长的时间，如果应用程序的所有内容不需要立即加载的话。</p><p id="7b93" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总之，我认为最好了解客户端和服务器端的路由，然后您可以决定您的应用程序更喜欢使用哪一个。服务器端路由仍然是标准，但是客户端引起轰动是有原因的。</p></div></div>    
</body>
</html>