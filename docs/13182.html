<html>
<head>
<title>Using the Multipeer Connectivity Framework With SwiftUI 4 to Build a Game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI 4的多对等连接框架构建游戏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-the-multipeer-connectivity-framework-with-swiftui4-b2bf97f5be79?source=collection_archive---------5-----------------------#2022-08-04">https://betterprogramming.pub/using-the-multipeer-connectivity-framework-with-swiftui4-b2bf97f5be79?source=collection_archive---------5-----------------------#2022-08-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="31ec" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">石头、纸和剪刀</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/285fda1b86f2e18f9066a529b9666eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vJIGieyLJsTElnGC"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·沃利斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="ca30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎来到我的第一个SwiftUI教程！在这个项目中，我将演示如何实现一个使用SwiftUI 4的基本多对等连接应用程序，不需要UIKit！</p><p id="a071" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事不宜迟，我们开始吧！</p><h1 id="2631" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">应用程序结构</h1><p id="5654" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们的应用程序的基本结构如下:</p><ul class=""><li id="9077" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">一个用于处理配对和与配对对等体通信的对象</li><li id="1f1d" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">PairView</code>将向用户显示一个可用的同伴列表，并允许他们邀请他们参加游戏</li><li id="c1cc" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">GameView</code>将显示游戏控件，告诉用户他们是赢了还是输了</li></ul><p id="c66d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该游戏将是一个基本的“石头，剪刀，布”游戏。用户将彼此配对，然后他们将看到三个选项，石头、布或剪刀。当用户选择一步棋时，它将被发送到对手的设备上，一旦定时器到时，结果就会显示出来。</p><p id="6b49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了基本的概述，让我们深入一些代码。</p><h1 id="2576" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">密码</h1><p id="2920" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们将从创建<code class="fe my mz na nb b">MultipeerSession</code>对象开始。首先，我们需要将<code class="fe my mz na nb b">MultipeerConnectivity</code>导入到我们的类中，并继承<code class="fe my mz na nb b">NSObject</code>和<code class="fe my mz na nb b">ObrvableObject</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="d70d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们创建了一个<code class="fe my mz na nb b">serviceType</code>字符串，它将让其他正在扫描对等点的设备知道我们正在使用<code class="fe my mz na nb b">RPS</code>应用程序，并且只在寻找<code class="fe my mz na nb b">RPS</code>对等点。这个字符串可以是任何能够将我们的多点服务与其他服务区分开来的东西。然后我们创建一些实例变量来保存我们的<code class="fe my mz na nb b">MCPeerID</code>、<code class="fe my mz na nb b">MCNearbyServiceAdvertiser</code>、<code class="fe my mz na nb b">MCNearbyServiceBrowser</code>和<code class="fe my mz na nb b">MCSession</code>。这些字段需要被公开，这样我们就可以在<code class="fe my mz na nb b">RPSMultipeerSession</code>类之外使用它们执行操作。</p><p id="1532" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们对象的<code class="fe my mz na nb b">init()</code>中，我们需要给上面创建的变量赋值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="59c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的应用程序中，我们将允许用户创建一个用户名，以便更容易地发现同行。这里，我们将提供的用户名作为初始化器中的一个参数，并从中创建一个<code class="fe my mz na nb b">MCPeerID</code>。</p><p id="7987" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样在初始化器内部，我们创建:</p><ul class=""><li id="eb0f" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><code class="fe my mz na nb b">session</code>:用于发送和接收RPS移动</li><li id="9b4f" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">用于向附近的玩家宣传我们自己</li><li id="6f2f" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">serviceBrowser</code>:用于查找附近有空的玩家</li></ul><p id="d52e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">别忘了调用<code class="fe my mz na nb b">super.init()</code>来调用超类的init方法’!</p><p id="cca1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要考虑如何从我们的对等点接收数据。稍后，我们将为我们的<code class="fe my mz na nb b">session</code>对象创建一个委托，它将从我们的对等体接收一个<code class="fe my mz na nb b">Data</code>对象，然后我们可以将它转换成更容易处理的东西。</p><p id="d321" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们实际上只有四个选项(石头、剪刀、布，没有)，所以我们将使用一个<code class="fe my mz na nb b">enum</code>来使处理响应更具可读性，也更容易操作。</p><p id="aa8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似这样的东西，放在与我们的<code class="fe my mz na nb b">RPSMultipeerSession</code>类相同的文件中，就足够了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8c20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">稍后，我们将使用我们的<code class="fe my mz na nb b">Move</code>的一个<code class="fe my mz na nb b">String</code>表示向我们的玩家显示一个图像。通过使用<code class="fe my mz na nb b">CustomStringConvertible</code>，我们可以减少这样做所需的代码量。</p><p id="96fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们已经创建并使用了<code class="fe my mz na nb b">Move</code>枚举，我们应该考虑什么类型的数据需要对我们的视图可用。我们知道我们的<code class="fe my mz na nb b">PairView</code>，将允许玩家找到他们的朋友并与他们配对，将需要访问当前可用的同伴列表。</p><p id="f39d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们收到另一个玩家的邀请时，同样的观众需要知道这个玩家是谁。<code class="fe my mz na nb b">GameView</code>需要知道我们何时收到对手的移动。</p><p id="60ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的不止一个视图可能会发现知道我们当前是否与一个玩家配对是有用的，最后，我们的<code class="fe my mz na nb b">PairView</code>将需要有某种方式来接受或拒绝另一个玩家的邀请。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="452c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，在我们的<code class="fe my mz na nb b">RPSMultipeerSession</code>中将有六个<code class="fe my mz na nb b">@Published</code>属性。制作这些变量<code class="fe my mz na nb b">@Published</code>使得我们的视图不仅可以看到变量的值，还可以在值改变时得到通知。</p><p id="f3a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样一来，我们需要为我们的<code class="fe my mz na nb b">session</code>、<code class="fe my mz na nb b">serviceAdvertiser</code>和<code class="fe my mz na nb b">serviceBrowser</code>创建一些代理。先说最长的一个，<code class="fe my mz na nb b">MCSessionDelegate</code>。</p><p id="e696" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">会话委托有方法来处理:</p><ul class=""><li id="ba7a" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">当对等体改变状态(连接、断开、连接)时</li><li id="a10c" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">当我们收到来自同行的<code class="fe my mz na nb b">Data</code></li><li id="e0e7" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">当我们收到来自对等体的<code class="fe my mz na nb b">InputStream</code></li><li id="7807" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">当我们收到来自对等方的<code class="fe my mz na nb b">Resource</code>时(有或没有进展)</li><li id="720e" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">当我们收到来自对等方的证书时(身份验证)</li></ul><p id="8a50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们实际上只关心其中的两种方法:当一个对等体改变状态时，以及当我们从一个用户接收到<code class="fe my mz na nb b">Data</code>时。尽管如此，这些方法中的每一个都需要在委托内部实现。</p><p id="bccd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Swift有一个简洁的特性，叫做<code class="fe my mz na nb b">extensions</code>。如果您不熟悉，扩展本质上允许您向任何Swift类添加代码。</p><p id="833c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">人们可以在<code class="fe my mz na nb b">String</code>类上创建一个<code class="fe my mz na nb b">extension</code>来对字符串执行任何类型的操作。s非常强大，我强烈建议查看细节，但现在这应该是足够的介绍，让我们继续下去。</p><p id="4b7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了防止我们的<code class="fe my mz na nb b">RPSMultipeerSession</code>变得太大而无法处理，我们将利用Swift的<code class="fe my mz na nb b">extension</code>来实现这些委托。我们可以简单地做:</p><pre class="kg kh ki kj gt nj nb nk nl aw nm bi"><span id="d464" class="nn lt iq nb b gy no np l nq nr">extension RPSMultipeerSession: MCSessionDelegate</span></pre><p id="b289" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并在那里实现委托函数，在主类之外，但仍然在同一个文件中。人们可以将这些委托放在单独的文件中，但是我个人选择将它们都放在一个文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="884f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像我之前说的，这是一个大问题。确保使用Xcode的自动完成功能来声明函数。</p><p id="fe11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，大多数函数只是在控制台上打印一行，实际上根本不做任何事情。这是因为我们的应用程序不支持发送或接收流或资源。不过，随着教程的进行，这种情况可能会改变。</p><p id="9b40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还没完呢！如果您按照代码进行操作，您可能已经注意到该委托实际上根本不做任何事情。我们需要实现逻辑来响应对等连接状态的变化，并从我们的对手那里接收数据。我将在第2部分详细讨论如何处理这些事件，所以现在，让我们继续。</p><p id="c5b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将实现<code class="fe my mz na nb b">MCNearbyServiceAdvertiserDelegate</code>。这个更容易理解:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="240c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务广告商有两种方法:一种是当广告商由于某种原因无法开始广告时调用，另一种是当我们收到另一个玩家的邀请时调用。后者将在第2部分再次实现！</p><p id="4167" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后但同样重要的是，我们需要实现<code class="fe my mz na nb b">MCNearbyServiceBrowserDelegate</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="61c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此委托具有在以下情况下调用的方法:</p><ul class=""><li id="0dab" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">浏览器由于某种原因没有开始浏览</li><li id="0e8e" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">浏览器发现附近的对等点正在广告我们的<code class="fe my mz na nb b">serviceType</code></li><li id="02df" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">浏览器失去了一个正在广告我们的<code class="fe my mz na nb b">serviceType</code>的邻近对等点</li></ul><p id="8a31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经设置了我们的代理，我们可以将它们应用到我们的<code class="fe my mz na nb b">session</code>、<code class="fe my mz na nb b">serviceAdvertiser</code>和<code class="fe my mz na nb b">serviceBrowser</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0d3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在调用<code class="fe my mz na nb b">super.init()</code>之后，我们将这个添加到我们的<code class="fe my mz na nb b">init()</code>中。这将分配代理，并开始向/为对等方做广告和浏览。</p><p id="7929" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们几乎完成了，但是我们不能忘记告诉我们的广告商和浏览器在<code class="fe my mz na nb b">deinit()</code>内停止</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8f7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经完成了所有这些，我们的<code class="fe my mz na nb b">RPSMultipeerSession.swift</code>文件应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="243f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在我的<a class="ae kv" href="https://github.com/TheNightmanCodeth/RPS" rel="noopener ugc nofollow" target="_blank"> GitHub回购里找到代码！</a></p><p id="243d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。这是本教程的第二部分。</p></div></div>    
</body>
</html>