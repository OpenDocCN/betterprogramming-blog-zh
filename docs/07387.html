<html>
<head>
<title>How To Write Better Functional Components in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中写出更好的功能组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-better-functional-components-in-react-bc974f777145?source=collection_archive---------1-----------------------#2021-01-11">https://betterprogramming.pub/how-to-write-better-functional-components-in-react-bc974f777145?source=collection_archive---------1-----------------------#2021-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1ef5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">可读性和优化的5个简单技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0fdde0c5543c9946ee7ddef5cbbc1389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aWK6yDaBe7x5viez2VyeMw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿诺德·弗朗西斯卡在<a class="ae ky" href="https://unsplash.com/photos/f77Bh3inUpE" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的图片。</p></figure><p id="77e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们这些在React中使用过功能组件的人都知道，钩子的引入让我们的生活变得简单多了。然而，功能组件有它们自己的复杂性和缺陷。因此，有时很难编写可读和优化的功能组件。今天，我们将看看五个简单的提示来帮助我们做到这一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bebc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.记忆复杂数据</h1><p id="440d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们来看看下面这个名为<code class="fe mz na nb nc b">SortedListView</code>的React组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该组件接受一个项目数组，根据提供的比较函数对它们进行排序，并显示它们。然而，如果项目数量大或比较功能复杂，该排序操作<em class="nf">可能会</em>花费大量时间。这可能最终成为一个瓶颈，因为组件将在每次重新渲染时重新排序项目，即使<code class="fe mz na nb nc b">items array</code>或<code class="fe mz na nb nc b">comparisonFunc</code>没有改变，但其他一些属性或状态改变了。</p><p id="5ae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是一个示例用例。在前端对大而复杂的数据进行排序应该很少见。但是，我们可以通过记忆排序操作并仅在<code class="fe mz na nb nc b">items array</code>改变时重新排序来提高CPU效率。</p><blockquote class="ng nh ni"><p id="9796" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated"><strong class="lb iu">更新:</strong>然而，对于我们自己控制的组件，我们总是可以防止不必要的重新渲染。我们可以通过避免将键值对象传递给<code class="fe mz na nb nc b">useEffect</code>和其他类似钩子的依赖数组，而是传递原始值来做到这一点。</p><p id="fd18" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">要查看<code class="fe mz na nb nc b">useMemo</code>的实际性能增益和性能权衡基准，请查看以下链接。</p></blockquote><div class="nm nn gp gr no np"><a href="https://medium.com/swlh/should-you-use-usememo-in-react-a-benchmarked-analysis-159faf6609b7" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">你应该在React中使用useMemo吗？基准分析。</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">我们的一些开发人员最近提出了一个问题，什么时候我应该在React中使用useMemo？在本文中，我们…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">medium.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ks np"/></div></div></a></div><p id="f5c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mz na nb nc b">useMemo</code>挂钩可以轻松实现记忆:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="df01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以使用<code class="fe mz na nb nc b">useMemo</code>通过交换一些内存来将结果存储或缓存到昂贵的操作中。也就是说，在操作开销不大或者对象没有被传递到任何其他组件的情况下，不需要使用<code class="fe mz na nb nc b">useMemo</code>，如上面的链接所示。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="368a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.记忆回调函数</h1><p id="ca58" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">就像数据一样，我们也可以记住一个组件传递给它所呈现的其他组件的回调函数。这样做的一个好处是，在某些情况下，它将防止无用的重新渲染。为了说明这一点，让我们看看名为<code class="fe mz na nb nc b">SortController</code>的组件如何使用上面的<code class="fe mz na nb nc b">SortedListView</code>组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe ne l"/></div></figure><p id="da99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，如果你转到结果选项卡并在文本字段中键入一个新的标题，这将导致<code class="fe mz na nb nc b">SortController</code>重新渲染。因此，<code class="fe mz na nb nc b">ascendingFn</code>和<code class="fe mz na nb nc b">descendingFn</code>将被重新创建。这导致<code class="fe mz na nb nc b">comparisonFunc</code>改变。由于<code class="fe mz na nb nc b">SortedListView</code>中的<code class="fe mz na nb nc b">useMemo</code>依赖于<code class="fe mz na nb nc b">comparisonFunc</code>，所以即使<code class="fe mz na nb nc b">comparisonFunc</code>没有逻辑变化，它也会重新排序项目。</p><p id="38e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过将<code class="fe mz na nb nc b">ascendingFn</code>和<code class="fe mz na nb nc b">descendingFn</code>包裹在<code class="fe mz na nb nc b">useCallback</code>中来解决这个问题。这个钩子是用来记忆函数的。注意，我们在这里没有为<code class="fe mz na nb nc b">useCallback</code>传递依赖数组中的任何东西，因为它们不依赖于组件内部的任何东西。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe ne l"/></div></figure><p id="b00d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像<code class="fe mz na nb nc b">useMemo</code>一样，如果函数没有传递给任何组件，并且不是任何其他钩子的依赖项，就不需要使用<code class="fe mz na nb nc b">useCallback</code>。</p><h1 id="18e5" class="mc md it bd me mf of mh mi mj og ml mm jz oh ka mo kc oi kd mq kf oj kg ms mt bi translated">3.分离不依赖于组件的功能</h1><p id="7562" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以对上面的函数进行的另一个改进是将<code class="fe mz na nb nc b">ascendingFn</code>和<code class="fe mz na nb nc b">descendingFn</code>移到<code class="fe mz na nb nc b">SortController</code>之外。这是因为这些函数不依赖于组件内部的任何东西。所以，真的没有必要在组件内部定义它们。如果我们这样做，组件的可读性会更好。此外，我们不再需要使用<code class="fe mz na nb nc b">useCallback</code>，因为这些函数不会在每次重新渲染时重新创建。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe ne l"/></div></figure><p id="6f3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以将<code class="fe mz na nb nc b">sort</code>实用函数保存在另一个文件中并导入它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1e84" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.创建子组件</h1><p id="49b8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">创建子组件是编写优化的、可读的React代码的有用方法——即使是使用类组件。子组件将代码库分成更小的、可理解的和可重用的块。这也使React更容易优化重新渲染。因此，将大组件分成小组件通常是个好主意。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="de76" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.创建和重用自定义挂钩</h1><p id="29ef" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">就像组件一样，我们可以创建定制的可重用钩子。这使得代码可读性更好，因为代码库被分成了更小的、可重用的块。在我们的例子中，我们可以将排序逻辑放在一个名为<code class="fe mz na nb nc b">useSorted</code>的定制钩子中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0b65" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="9717" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了在React中编写可读性更好、更优化的功能组件，我们可以采用这五个简单的技巧。请随意分享您自己编写更好的功能组件的技巧。</p></div></div>    
</body>
</html>