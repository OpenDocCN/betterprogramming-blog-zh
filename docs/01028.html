<html>
<head>
<title>What Is This Crazy Keyword?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这个疯狂的关键词是什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-this-crazy-keyword-25afeb2deb23?source=collection_archive---------5-----------------------#2019-08-08">https://betterprogramming.pub/what-is-this-crazy-keyword-25afeb2deb23?source=collection_archive---------5-----------------------#2019-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4ca5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">掌握JavaScript的“this”</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/75a95466beb676d10e6f2c26be346363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rBnmli_Gnr6fHCQ3PLL1Qg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自YouTube上的Mosh编程</p></figure><p id="0b19" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">任何有Java等面向对象语言经验的程序员都见过关键字<code class="fe lr ls lt lu b">this</code>或类似的Ruby和Python <code class="fe lr ls lt lu b">self</code>。在那些语言中，<code class="fe lr ls lt lu b">this</code>和<code class="fe lr ls lt lu b">self</code>仅仅是指关键字出现的类的当前实例。</p><p id="b010" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于JavaScript的编写只是表面上模仿Java的外观和语法，所以JavaScript的开发者也选择使用<code class="fe lr ls lt lu b">this</code>关键字。问题在于，在许多情况下，JavaScript的<code class="fe lr ls lt lu b">this</code>与真正面向对象语言中的<code class="fe lr ls lt lu b">self</code>和<code class="fe lr ls lt lu b">this</code>关键字完全不同。(关于JavaScript和具有类原生支持的语言之间的更多区别，请查看<a class="ae lv" href="https://medium.com/better-programming/a-tale-of-two-languages-a-story-about-class-b6b7551c795d" rel="noopener">我的上一篇文章</a>)。为了强调这种对比，下面对面向对象语言中的<code class="fe lr ls lt lu b">this</code>进行更深入的解释。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="e214" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">它在面向对象语言中是如何工作的</h1><p id="62b0" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">如上所述，在真正的面向对象语言中，方法中<code class="fe lr ls lt lu b">this</code>的值由定义方法的<em class="na">决定</em>。例如，看一下这段伪代码，它是为了模仿一些真正的面向对象语言而编写的:</p><pre class="kg kh ki kj gt nb lu nc nd aw ne bi"><span id="1006" class="nf me iq lu b gy ng nh l ni nj">class Foo:<br/>   constructor():<br/>     this.example_var = 10<br/>   end</span><span id="24af" class="nf me iq lu b gy nk nh l ni nj">   say_var():<br/>      print this.example_var<br/>   end<br/>end</span></pre><p id="b03e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，当我们定义<code class="fe lr ls lt lu b">instance = new Foo()</code>并调用<code class="fe lr ls lt lu b">instance.say_var()</code>时，<code class="fe lr ls lt lu b">say_var</code>中的<code class="fe lr ls lt lu b">this</code>将查看该方法定义的位置，在本例中，作为<code class="fe lr ls lt lu b">Foo</code>的实例方法。基于这个上下文，<code class="fe lr ls lt lu b">this</code>将引用<code class="fe lr ls lt lu b">Foo</code>的一个实例，<code class="fe lr ls lt lu b">say_var()</code>将成功打印该实例的<code class="fe lr ls lt lu b">example_var</code>属性，我们定义为10。在像Java这样的纯面向对象语言中，这就是<code class="fe lr ls lt lu b">this</code>的全部:一种访问类的当前实例的方法。此外，<code class="fe lr ls lt lu b">this</code>的值完全由出现<code class="fe lr ls lt lu b">this</code>的方法的上下文决定。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="e1a4" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">JavaScript的情况</h1><p id="70da" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">我不想撒谎。有点复杂。MDN，我们的JavaScript圣经，是这样说的:</p><blockquote class="nl nm nn"><p id="3a4c" class="kv kw na kx b ky kz jr la lb lc ju ld no lf lg lh np lj lk ll nq ln lo lp lq ij bi translated">大多数情况下，<code class="fe lr ls lt lu b">this</code>的值是由函数的调用方式决定的(运行时绑定)。在执行过程中不能通过赋值来设置，可能每次调用函数都不一样。</p></blockquote><p id="e864" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在一个过于简单的层面上，这意味着，在大多数情况下，当调用<code class="fe lr ls lt lu b">f()</code>时，函数<code class="fe lr ls lt lu b">f()</code>中的<code class="fe lr ls lt lu b">this</code>将引用出现在点左边的任何东西。在<code class="fe lr ls lt lu b">myObject.f()</code>中，<code class="fe lr ls lt lu b">this</code>将指<code class="fe lr ls lt lu b">myObject</code>。或者，当没有在任何对象上调用<code class="fe lr ls lt lu b">f()</code>时，<code class="fe lr ls lt lu b">this</code>将默认为全局上下文，通常是<code class="fe lr ls lt lu b">Window</code>对象(稍后将详细介绍)。无论如何，这里有一个例子说明<code class="fe lr ls lt lu b">this</code>的值取决于包含它的函数被调用的位置，而不是定义它的位置:</p><pre class="kg kh ki kj gt nb lu nc nd aw ne bi"><span id="ceec" class="nf me iq lu b gy ng nh l ni nj">const obj = {<br/>  attr: "whaddup",<br/>  objMethod: function(){<br/>          console.log(this.attr) <br/>    }     <br/>  }</span></pre><p id="197e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后:</p><pre class="kg kh ki kj gt nb lu nc nd aw ne bi"><span id="40d3" class="nf me iq lu b gy ng nh l ni nj">obj.objMethod()<br/>&gt;&gt;&gt; "whaddup"</span></pre><p id="7371" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有道理吗？看起来这里的<code class="fe lr ls lt lu b">this</code>与真正面向对象语言中的<code class="fe lr ls lt lu b">this</code>非常相似，都是指定义方法的对象。然而，这种行为与其说是JavaScript的特性，不如说是巧合。在这种情况下，定义<code class="fe lr ls lt lu b">this</code>的上下文<code class="fe lr ls lt lu b">obj</code>与调用它的对象一致(也是<code class="fe lr ls lt lu b">obj</code>)。但事实未必如此。观察:</p><pre class="kg kh ki kj gt nb lu nc nd aw ne bi"><span id="046c" class="nf me iq lu b gy ng nh l ni nj">const globalFunc = obj.objMethod<br/>globalFunc()<br/>&gt;&gt;&gt; undefined</span></pre><p id="7e8f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里，<code class="fe lr ls lt lu b">this</code>最初出现在<code class="fe lr ls lt lu b">objMethod</code>中，它是在对象<code class="fe lr ls lt lu b">obj</code>上定义的。但是当我们复制了<code class="fe lr ls lt lu b">objMethod</code>并调用<code class="fe lr ls lt lu b">globalFunc</code>时，<code class="fe lr ls lt lu b">globalFunc</code>的执行上下文就变成了全局对象，在基于浏览器的JavaScript中就是<code class="fe lr ls lt lu b">Window</code>。因此，调用<code class="fe lr ls lt lu b">globalFunc</code>时的<code class="fe lr ls lt lu b">this</code>指的是<code class="fe lr ls lt lu b">Window</code>，它没有<code class="fe lr ls lt lu b">attr</code>键。这解释了为什么第二个例子导致<code class="fe lr ls lt lu b">undefined</code>被打印到控制台。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="1df2" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">绑定“this”和箭头函数</h1><p id="2f84" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">通常情况下，我们更希望<code class="fe lr ls lt lu b">this</code>的值取决于包含它的方法是在哪里定义的，而不是在哪里执行的。这就是为什么在面向对象语言中<code class="fe lr ls lt lu b">this</code>是这样工作的。这就是<code class="fe lr ls lt lu b">.bind()</code>和箭头函数的用处。这些构造给了我们对<code class="fe lr ls lt lu b">this</code>的一定程度的控制，而不仅仅是在调用方法时随意绑定关键字。这里有一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="93b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后是<code class="fe lr ls lt lu b">doggo.eatSnacksFunction()</code>版画:</p><pre class="kg kh ki kj gt nb lu nc nd aw ne bi"><span id="3db2" class="nf me iq lu b gy ng nh l ni nj">&gt;&gt;&gt; is eating cabbage<br/>&gt;&gt;&gt; is eating carrots<br/>&gt;&gt;&gt; is eating bones</span></pre><p id="60aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以我们能够打印出<code class="fe lr ls lt lu b">favSnacks</code>的内容，但是无法访问doggo的<code class="fe lr ls lt lu b">name</code>。几乎是我们想要的行为，但没有雪茄。在<code class="fe lr ls lt lu b">eatSnacksFunction</code>内部，第一个<code class="fe lr ls lt lu b">this</code>成功引用了<code class="fe lr ls lt lu b">doggo</code>对象，允许我们访问<code class="fe lr ls lt lu b">favSnacks</code>。这并不奇怪，因为<code class="fe lr ls lt lu b">doggo</code>在<code class="fe lr ls lt lu b">doggo.eatSnacksFunction()</code>中点的左边。当我们进入<code class="fe lr ls lt lu b">forEach()</code>内部的回调函数时，问题就出现了。</p><p id="6df4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为这个匿名函数没有在任何对象上定义，所以它内部的<code class="fe lr ls lt lu b">this</code>引用的是<code class="fe lr ls lt lu b">Window</code>对象，该对象没有<code class="fe lr ls lt lu b">name</code>属性。那么如何才能让内部的<code class="fe lr ls lt lu b">this</code>引用<code class="fe lr ls lt lu b">doggo</code>？我们有两个选择:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="857d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，当在<code class="fe lr ls lt lu b">doggo</code>上调用这两个函数时，将成功打印:</p><pre class="kg kh ki kj gt nb lu nc nd aw ne bi"><span id="caf0" class="nf me iq lu b gy ng nh l ni nj">&gt;&gt;&gt; winfield is eating cabbage<br/>&gt;&gt;&gt; winfield is eating carrots<br/>&gt;&gt;&gt; winfield is eating bones</span></pre><p id="2268" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们来说说发生了什么。在第一个函数中，<code class="fe lr ls lt lu b">.bind(this)</code>的含义如下:使匿名函数内部的<code class="fe lr ls lt lu b">this</code>引用与外部函数<em class="na">、</em>、<code class="fe lr ls lt lu b">firstSuccessfulEatSnacks</code>相同的<code class="fe lr ls lt lu b">this</code>。因此，匿名函数中的<code class="fe lr ls lt lu b">this</code>现在是<code class="fe lr ls lt lu b">doggo</code>，给出了我们想要的行为。更一般地说，在一个函数上调用<code class="fe lr ls lt lu b">.bind(someObject)</code>会使该函数内部的<code class="fe lr ls lt lu b">this</code>引用<code class="fe lr ls lt lu b">someObject</code>。</p><p id="15c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好吧，酷。但是第二个功能呢？在某种程度上，它只是第一个的语法糖。那个花哨的<code class="fe lr ls lt lu b">=&gt;</code>箭头函数本质上的意思是:制作一个普通函数，然后将<code class="fe lr ls lt lu b">this</code>绑定到外层函数的<code class="fe lr ls lt lu b">this</code>。就像第一个例子一样，只是语法更清晰。花一点时间来回顾这段代码；这是一个复杂的话题。</p></div></div>    
</body>
</html>