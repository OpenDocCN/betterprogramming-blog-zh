<html>
<head>
<title>How To Use Templates In Golang?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Golang中使用模板？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-templates-in-golang-46194c677c7d?source=collection_archive---------5-----------------------#2022-03-01">https://betterprogramming.pub/how-to-use-templates-in-golang-46194c677c7d?source=collection_archive---------5-----------------------#2022-03-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ccb2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">标准模板包概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8cd2c7e108c485479b71da5b0fab6cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RbEgaVFdPB0m4Uj8"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克拉克·范·德·贝肯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4469" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将解释Go语言(Golang)的标准模板包的基础。这些基础知识包括在Golang模板中使用变量、条件语句、循环变量以及对变量应用函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="e198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Golang提供了用于处理开箱即用模板的<code class="fe mc md me mf b">text/template</code>和<code class="fe mc md me mf b">html/template</code>包。</p><p id="b9d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个包是最通用的——您可以用它来为所有类型的文本字符串创建模板。第二个包更适合HTML——它可以方便地处理HTML web环境中的不安全变量。</p><p id="93f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些包包含各种函数，可以加载、解析和评估模板文本或(HTML或文本)文件。</p><p id="b833" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可以使用以下函数:</p><ul class=""><li id="b9b9" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">使用<code class="fe mc md me mf b">Parse</code>解析程序中的文本字符串。</li><li id="c72c" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">使用<code class="fe mc md me mf b">ParseFiles</code>加载并解析模板文件。</li><li id="0cc8" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">使用<code class="fe mc md me mf b">Execute</code>使用特定的数据字段将模板呈现给一些输出。</li></ul><p id="af57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下文中，我将讨论在Golang中创建强大模板的基本构件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1407" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">外部(程序)变量</h1><p id="1166" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">你可以将变量从你实际的Go程序中发送到你的模板中。然后，您可以在模板中使用这些变量。</p><p id="aea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，当您希望在模板中呈现特定的动作时，您可以通过在文本字符串中的双括号<code class="fe mc md me mf b">{{}}</code>之间添加这些动作来实现。</p><p id="4b34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用它来显示你在程序中提供的变量。因此，如果您在双括号内添加一个点，您的所有数据字段都将呈现在那里。</p><p id="8c33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<code class="fe mc md me mf b">{{.}}</code>会将所有数据字段呈现为格式化字符串。</p><p id="392c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，还可以通过指定字段的名称来访问数据的特定字段。</p><p id="8281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<code class="fe mc md me mf b">{{ .Title }}</code>只会将<code class="fe mc md me mf b">Title</code>字段呈现为格式化字符串。</p><p id="61df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在下面的代码示例中看到这些操作的应用。</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="6101" class="nv mv it mf b gy nw nx l ny nz">package main </span><span id="b2e5" class="nv mv it mf b gy oa nx l ny nz">import ( <br/>    "os" <br/>    "text/template" <br/>) </span><span id="185a" class="nv mv it mf b gy oa nx l ny nz">type Book struct { <br/>    Title     string <br/>    Publisher string <br/>    Year      int <br/>} </span><span id="1a9e" class="nv mv it mf b gy oa nx l ny nz">func main() { <br/>    t1 := template.New("Template") <br/>    t1, _ = t1.Parse("External variable has the value [{{.}}]\n") <br/>    t1.Execute(os.Stdout, "Amazing") </span><span id="dc3a" class="nv mv it mf b gy oa nx l ny nz">    b := Book{"The CSound Book", "MIT Press", 2002} <br/>    t1.Execute(os.Stdout, b) </span><span id="60bf" class="nv mv it mf b gy oa nx l ny nz">    t2 := template.New("Template") <br/>    t2, _ = t2.Parse("External variable Book has the values [Title: {{.Title}}, Publisher: {{.Publisher}}, Year: {{.Year}}]\n") <br/>    t2.Execute(os.Stdout, b) <br/>}</span><span id="0204" class="nv mv it mf b gy oa nx l ny nz">// Output<br/>// External variable has the value [Amazing] <br/>// External variable has the value [{The CSound Book MIT Press 2002}] <br/>// External variable Book has the values [Title: The CSound Book, Publisher: MIT Press, Year: 2002]</span></pre><p id="c1b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://go.dev/play/p/uZ8imiNxXjW" rel="noopener ugc nofollow" target="_blank"> <em class="ob">运行这里的代码……</em></a></p><p id="6d26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先在上面的代码中用<code class="fe mc md me mf b">template.New()</code>创建一个新的空模板。然后我们使用<code class="fe mc md me mf b">Parse()</code>将一个字符串解析到这个模板中。在这个字符串中，我们在双括号之间添加了一个动作。</p><p id="8236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们在括号之间放了一个点，这就向模板呈现器发出信号，需要在这里呈现所提供的变量。</p><p id="3e4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mc md me mf b">Execute()</code>来呈现带有变量的模板。第一个参数(<code class="fe mc md me mf b">os.Stdout</code>)是渲染模板输出的位置。第二个参数(<code class="fe mc md me mf b">Amazing</code>)是我们希望在模板中呈现的变量。在这种情况下，它只是一个字符串。</p><p id="d54a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以提供一个结构，而不是向呈现器提供一个字符串。这里我们创建了一个结构来保存一本书的数据。随后，我们可以将它提供给之前创建的同一个模板。</p><p id="8631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以呈现结构的单个数据字段。为此，创建一个新的模板字符串。我们没有在双括号之间放一个点，而是在我们希望呈现的结构中放一个点，后跟数据字段的名称。请注意，该数据字段用大写字母书写，表示它是可导出的。</p><p id="3fb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，<code class="fe mc md me mf b">Parse</code>函数实际上返回了两个变量。第一个变量是解析后的模板，第二个变量是错误消息。我们不会在上面的例子中使用错误信息，所以我们只放了一个下划线。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="91f7" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">内部(模板)变量</h1><p id="da8c" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">可以定义内部变量，即只在模板中定义。</p><p id="7cd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下模式显示了如何使用模板字符串中定义的变量。首先是定义，然后是使用。内部变量应该以美元符号($)开头。</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="323c" class="nv mv it mf b gy nw nx l ny nz">{{$var:=`value`}}  ... {{$var}} ...</span></pre><p id="1049" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个简单的例子:</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="ec57" class="nv mv it mf b gy nw nx l ny nz">package main</span><span id="b8a5" class="nv mv it mf b gy oa nx l ny nz">import (<br/>    "os"<br/>    "text/template"<br/>)</span><span id="7aa2" class="nv mv it mf b gy oa nx l ny nz">func main() {<br/>    t, _ := template.New("Template").Parse("{{$var:=2150}}Internal variable has the value [{{$var}}]")</span><span id="5195" class="nv mv it mf b gy oa nx l ny nz">    t.Execute(os.Stdout, nil)<br/>}</span><span id="d39e" class="nv mv it mf b gy oa nx l ny nz">// Output:<br/>// Internal variable has the value [2150]</span></pre><p id="61a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://go.dev/play/p/CZUi54PaiYZ" rel="noopener ugc nofollow" target="_blank"> <em class="ob">运行这里的代码……</em></a></p><p id="3687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与使用点来呈现外部变量不同，这里我们提到我们之前在双括号中定义的变量。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8a68" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">条件式</h1><p id="dabc" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">下面，你可以看到条件句的一般模式:</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="2a8b" class="nv mv it mf b gy nw nx l ny nz">{{if [..]}} if-part {{end}}<br/>{{if [..]}} if-part {{else}} else-part {{end}}<br/>{{if [..]}} if-part {{if else}} if-else-part {{end}}</span></pre><p id="591b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最后一个模式中，您可以根据需要多次使用<code class="fe mc md me mf b">{{if else}}</code>部件，也可以添加一个<code class="fe mc md me mf b">{{else}}</code>部件。下面是第二种模式的简单示例:</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="cbb7" class="nv mv it mf b gy nw nx l ny nz">package main </span><span id="7595" class="nv mv it mf b gy oa nx l ny nz">import ( <br/>    "os" <br/>    "text/template" <br/>) </span><span id="cc4a" class="nv mv it mf b gy oa nx l ny nz">func main() { <br/>    t, err := template.New("Template").Parse("{{if eq . `filler`}}This is filler...{{else}}It's something else...{{end}}\n") <br/>    if err != nil { <br/>        panic(err) <br/>    } <br/>    t.Execute(os.Stdout, "filler") <br/>}</span><span id="8819" class="nv mv it mf b gy oa nx l ny nz">// Output:<br/>// This is filler...</span></pre><p id="e167" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://go.dev/play/p/QGJqP1x9g1N" rel="noopener ugc nofollow" target="_blank"> <em class="ob">运行这里的代码……</em></a></p><p id="eb87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在上面的例子中，我们还使用了从<code class="fe mc md me mf b">Parse()</code>函数返回的错误消息。如果没有错误，错误信息等于'<em class="ob"> nil </em>'。如果有错误，我们可以用<code class="fe mc md me mf b">panic()</code>函数处理错误。</p><p id="8e8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，代替等号<code class="fe mc md me mf b">eq</code> (for ==)，你也可以用:</p><ul class=""><li id="c30c" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">全盘否定<code class="fe mc md me mf b">ne</code>(为！=)</li><li id="11cf" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">低于<code class="fe mc md me mf b">lt</code>(对于&lt;)</li><li id="6604" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">低于或等于<code class="fe mc md me mf b">le</code>(对于&lt; =)</li><li id="a9d2" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">大于<code class="fe mc md me mf b">gt</code>(对于&gt;)</li><li id="24b8" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">大于或等于<code class="fe mc md me mf b">ge</code>(对于&gt; =)</li></ul><p id="67ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，可以编写一个布尔变量来代替比较语句。</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="9c7e" class="nv mv it mf b gy nw nx l ny nz">package main</span><span id="9aa5" class="nv mv it mf b gy oa nx l ny nz">import (<br/>    "os"<br/>    "text/template"<br/>)</span><span id="aac5" class="nv mv it mf b gy oa nx l ny nz">func main() {<br/>    t, _ := template.New("Template").Parse("{{if .}}This is true.{{else}}This is false.{{end}}\n")<br/>    t.Execute(os.Stdout, false)<br/>}</span><span id="185d" class="nv mv it mf b gy oa nx l ny nz">// Output:<br/>// This is false</span></pre><p id="f6a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://go.dev/play/p/pTrgHbifWU-" rel="noopener ugc nofollow" target="_blank"> <em class="ob">运行这里的代码……</em></a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="60cc" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">环</h1><p id="47ab" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在数组、切片或映射上循环时，有几种模式可以在模板中使用。首先，我们来看看最简单的形式。</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="5ad4" class="nv mv it mf b gy nw nx l ny nz">{{range .Var}}<br/>    {{.}}<br/>{{end}}</span></pre><p id="3d6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们对数组、切片或映射中的每个变量进行循环。Var)。在循环的每一步中，都有一个变量可供循环使用。</p><p id="f0c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在<code class="fe mc md me mf b">{{.}}</code>不再代表我们的模板可用的所有变量，而只代表循环中可用的变量。</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="66a7" class="nv mv it mf b gy nw nx l ny nz">package main </span><span id="b5f8" class="nv mv it mf b gy oa nx l ny nz">import ( <br/>    "os" <br/>    "text/template" <br/>) </span><span id="40ae" class="nv mv it mf b gy oa nx l ny nz">func main() { <br/>    computerList := []string{"Arduino", "Raspberri Pi", "NVidia Jetson Nano"} <br/>    t, err := template.New("Template").Parse("My favorite computers are:\n{{range .}}{{.}}\n{{end}}\n") <br/>    if err != nil { <br/>        panic(err) <br/>    } <br/>    t.Execute(os.Stdout, computerList) <br/>}</span><span id="2b8a" class="nv mv it mf b gy oa nx l ny nz">// Output:<br/>// My favorite computers are: <br/>// Arduino <br/>// Raspberri Pi <br/>// NVidia Jetson Nano</span></pre><p id="38eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://go.dev/play/p/odSFyC_hXwA" rel="noopener ugc nofollow" target="_blank"> <em class="ob">运行这里的代码……</em></a></p><p id="7a7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在对一组变量进行循环时，可以使用一种更复杂的模式，如下所示:</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="6bac" class="nv mv it mf b gy nw nx l ny nz">{{range $index, $element := . }} <br/>    {{$index}} ... {{$element}} ...<br/>{{end}}</span></pre><p id="3cf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您需要循环中可用的变量索引时，这种模式非常方便。例如，如果您希望输出一个带有编号的有序列表，您可以使用这个模板模式。</p><p id="d346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意这里的变量<code class="fe mc md me mf b">$index</code>和<code class="fe mc md me mf b">$element</code>是在模板中定义的内部变量。因此，他们也以“<em class="ob"> $ </em>”开始。</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="1cb3" class="nv mv it mf b gy nw nx l ny nz">package main </span><span id="756e" class="nv mv it mf b gy oa nx l ny nz">import ( <br/>    "os" <br/>    "text/template" <br/>) </span><span id="6dd5" class="nv mv it mf b gy oa nx l ny nz">func main() { <br/>    dishesList := []string{"Enciladas con Pollo", "Hot&amp;Spicy Pizza", "Spaghetti Bolognese"} <br/>    t, err := template.New("Template").Parse("My favorite dishes are:\n{{range $index, $item:=.}}{{$index}}) {{$item}}\n{{end}}\n") <br/>    if err != nil { <br/>        panic(err) <br/>    } <br/>    t.Execute(os.Stdout, dishesList) <br/>}</span><span id="5104" class="nv mv it mf b gy oa nx l ny nz">// Output<br/>// My favorite dishes are: <br/>// 0) Enciladas con Pollo <br/>// 1) Hot&amp;Spicy Pizza <br/>// 2) Spaghetti Bolognese</span></pre><p id="1657" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://go.dev/play/p/22s-igRk-uS" rel="noopener ugc nofollow" target="_blank"> <em class="ob">运行这里的代码……</em></a></p><p id="c9e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，这种方法有一个问题。我们从输出中得到的有序列表从0开始。原因是第一个索引总是0。</p><p id="2659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于许多应用程序来说，这不是我们想要的。我们希望有序列表从1开始。那么我们如何将每个索引递增1呢？我们需要一个函数来增加一个给定的变量。</p><p id="fe8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一部分中，我们将研究在模板字符串中运行函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2313" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">模板内的函数</h1><p id="fa49" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">可以在模板中使用函数。</p><p id="d2a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，您需要将希望使用的函数映射到您将在模板中使用的关键字。</p><p id="53ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，我们将创建一个名为<code class="fe mc md me mf b">add()</code>的加法函数。我们将在<code class="fe mc md me mf b">FuncMap()</code>函数中使用<code class="fe mc md me mf b">template.FuncMap{}</code>将其添加到函数映射中。</p><p id="7e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mc md me mf b">add</code>函数，我们将能够给<code class="fe mc md me mf b">$index</code>变量加1，从而递增它。结果将是一个可读性更好的有序列表。</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="8e34" class="nv mv it mf b gy nw nx l ny nz">package main </span><span id="d9d6" class="nv mv it mf b gy oa nx l ny nz">import ( <br/>    "os" <br/>    "text/template" <br/>) </span><span id="f4d8" class="nv mv it mf b gy oa nx l ny nz">func add(a, b int) int { <br/>    return a + b <br/>} </span><span id="c57a" class="nv mv it mf b gy oa nx l ny nz">func main() { <br/>    dishesList := []string{"Enciladas con Pollo", "Hot&amp;Spicy Pizza", "Spaghetti Bolognese"} </span><span id="cb30" class="nv mv it mf b gy oa nx l ny nz">    t, err := template.New("Template").Funcs(template.FuncMap{"add": add}).Parse("My favorite dishes are:\n{{range $index, $item:=.}}{{add $index 1}}) {{$item}}\n{{end}}\n") </span><span id="aa58" class="nv mv it mf b gy oa nx l ny nz">    if err != nil { <br/>        panic(err) <br/>    } </span><span id="656e" class="nv mv it mf b gy oa nx l ny nz">    t.Execute(os.Stdout, dishesList) <br/>}</span><span id="2b0b" class="nv mv it mf b gy oa nx l ny nz">// Output:<br/>// My favorite dishes are: <br/>// 1) Enciladas con Pollo <br/>// 2) Hot&amp;Spicy Pizza <br/>// 3) Spaghetti Bolognese</span></pre><p id="3f6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://go.dev/play/p/nDL1cdNLolH" rel="noopener ugc nofollow" target="_blank"> <em class="ob">运行这里的代码……</em></a></p><p id="8ed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在下面找到一个更复杂的例子。这里我们添加第二个函数。我们的想法是创建一个CSV样式的输出，但是当我们将“分隔符”添加到函数映射时，我们可以选择我们想要的分隔符符号。</p><p id="af52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以看到映射中使用的名称与实际的函数名称不同。</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="0c68" class="nv mv it mf b gy nw nx l ny nz">package main</span><span id="0793" class="nv mv it mf b gy oa nx l ny nz">import (<br/>    "os"<br/>    "text/template"<br/>)</span><span id="a5a8" class="nv mv it mf b gy oa nx l ny nz">func add(a, b int) int {<br/>    return a + b<br/>}</span><span id="531d" class="nv mv it mf b gy oa nx l ny nz">func delimiter(s string) func() string {<br/>    return func() string {<br/>        return s<br/>    }<br/>}</span><span id="f373" class="nv mv it mf b gy oa nx l ny nz">func main() {<br/>    dishesList := []string{"Enciladas con Pollo", "Hot&amp;Spicy Pizza", "Spaghetti Bolognese"}</span><span id="028c" class="nv mv it mf b gy oa nx l ny nz">    tmpl := "Index{{dl}}Dish\n{{range $index, $item:=.}}{{add $index 1}}{{dl}}{{$item}}\n{{end}}\n"</span><span id="d568" class="nv mv it mf b gy oa nx l ny nz">    funcMap := template.FuncMap{"add": add, "dl": delimiter(",")}</span><span id="2acc" class="nv mv it mf b gy oa nx l ny nz">    t, _ := template.New("Template").Funcs(funcMap).Parse(tmpl)</span><span id="0c95" class="nv mv it mf b gy oa nx l ny nz">    t.Execute(os.Stdout, dishesList)<br/>}</span><span id="24c6" class="nv mv it mf b gy oa nx l ny nz">// Output:<br/>// Index,Dish<br/>// 1,Enciladas con Pollo <br/>// 2,Hot&amp;Spicy Pizza <br/>// 3,Spaghetti Bolognese</span></pre><p id="b541" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://go.dev/play/p/cRDjZdztFZ7" rel="noopener ugc nofollow" target="_blank"> <em class="ob">运行这里的代码……</em></a></p><p id="2ae8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个方便的带有模板函数映射的库，叫做Sprig。这里可以找到<a class="ae ky" href="http://masterminds.github.io/sprig/" rel="noopener ugc nofollow" target="_blank">。然而，这个库似乎只适用于<code class="fe mc md me mf b">html/template</code>包。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ecad" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">例子</h1><p id="763a" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">为了进一步说明Golang中模板的使用，我创建了两个例子:</p><div class="oc od gp gr oe of"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-generate-code-using-golang-templates-942cba2e5e0c"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">如何使用Golang模板生成代码</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">如何根据构建器设计模式使用Golang模板生成代码的示例</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">better编程. pub</p></div></div><div class="oo l"><div class="op l oq or os oo ot ks of"/></div></div></a></div><div class="oc od gp gr oe of"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-generate-html-with-golang-templates-5fad0d91252"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">如何用Golang模板生成HTML</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">如何使用Go模板生成HTML页面的示例</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">better编程. pub</p></div></div><div class="oo l"><div class="ou l oq or os oo ot ks of"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="deed" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">参考</h1><ul class=""><li id="4a8b" class="mg mh it lb b lc nm lf nn li ov lm ow lq ox lu ml mm mn mo bi translated"><a class="ae ky" href="https://astaxie.gitbooks.io/build-web-application-with-golang/content/en/07.4.html" rel="noopener ugc nofollow" target="_blank">“使用Golang构建Web应用程序—第7.4章模板”，作者Astaxie </a></li><li id="32ca" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><a class="ae ky" href="https://gobyexample.com/text-templates" rel="noopener ugc nofollow" target="_blank">“以身作则:文本模板”，作者Mark McGranaghan和Eli Bendersky </a></li><li id="516c" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><a class="ae ky" href="https://pkg.go.dev/text/template" rel="noopener ugc nofollow" target="_blank">Go Dev的模板包</a></li></ul></div></div>    
</body>
</html>