<html>
<head>
<title>Use an ‘NSFetchedResultsController’ Extension to Observe Relationship Changes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用“NSFetchedResultsController”扩展来观察关系变化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-an-nsfetchedresultscontroller-extension-to-observe-relationship-changes-ff730c112913?source=collection_archive---------22-----------------------#2020-03-24">https://betterprogramming.pub/use-an-nsfetchedresultscontroller-extension-to-observe-relationship-changes-ff730c112913?source=collection_archive---------22-----------------------#2020-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fbbe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基于数据关系自动刷新内容</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4fc278874e31f63ded9f08be3af633e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V82OIP45_VsMjnIHYHHA7g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卢克·普莱斯在<a class="ae ky" href="https://commons.wikimedia.org/wiki/File:Changing_of_the_Seasons_(16136991162).jpg" rel="noopener ugc nofollow" target="_blank">维基共享资源</a>上的照片</p></figure><p id="236e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">苹果为我们提供了很棒的类，比如<code class="fe lv lw lx ly b">NSFetchedResultsController</code>来与我们应用程序中的核心数据数据库进行交互。API经过多年的发展，增加了对新的<code class="fe lv lw lx ly b">NSDiffableDataSource</code>的支持。然而，仍然存在默认API不够有用的情况。</p><p id="54c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在WeTransfer，我们大量使用核心数据。我们所有的内容都通过获取的结果控制器显示，并通过<code class="fe lv lw lx ly b">NSFetchedResultsControllerDelegate</code>回调自动刷新。我们遇到的一个问题是缺乏对观察关系变化的支持。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ac21" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">“NSFetchedResultsController”是如何工作的？</h1><p id="bc48" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了充分理解这个问题，首先理解<code class="fe lv lw lx ly b">NSFetchedResultsController</code>是如何工作的很重要。</p><p id="ee52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">NSFetchedResultsController</code>通常也被称为<em class="nd"> FRC </em>并利用一个<code class="fe lv lw lx ly b">NSFetchRequest</code>来获取其数据。FRC委托可用于更新一个<code class="fe lv lw lx ly b">UITableView</code>或<code class="fe lv lw lx ly b">UICollectionView</code>，因为我们获得了对节和单元格索引路径的插入、删除和更新的更新。这些变化是根据FRC中新旧数据集之间的比较自动计算出来的。</p><p id="9490" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例设置如下所示:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="dced" class="ni mh it ly b gy nj nk l nl nm">let fetchRequest = NSFetchRequest&lt;Content&gt;(entityName: "Content")<br/>fetchRequest.sortDescriptors = [NSSortDescriptor(keyPath: \Content.creationDate, ascending: true)]<br/>let controller = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: persistentContainer.viewContext, sectionNameKeyPath: nil, cacheName: nil)<br/><br/>do {<br/>    try controller.performFetch()<br/>} catch {<br/>    fatalError("Failed fetching content items with error: \(error)")<br/>}</span></pre><p id="08ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们获取所有的<code class="fe lv lw lx ly b">Content</code>实体并在一个列表中显示它们。FRC将确保数据集在以下情况下自动更新:</p><ul class=""><li id="e254" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">插入一个<code class="fe lv lw lx ly b">Content</code>项目</li><li id="42ef" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">一个<code class="fe lv lw lx ly b">Content</code>项目被删除</li><li id="c11a" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">一个<code class="fe lv lw lx ly b">Content</code>项目被更新</li></ul><p id="53d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些变化中的任何一个都将触发委托回调，我们可以据此更新我们的<code class="fe lv lw lx ly b">UICollectionView</code>或<code class="fe lv lw lx ly b">UITableView</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5dfb" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">问题解释:当关系属性更改时更新数据集</h1><p id="a891" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">正如我们在上一节中所解释的，我们现在知道，无论任何一个<code class="fe lv lw lx ly b">Content</code>实例发生更新，一个<code class="fe lv lw lx ly b">NSFetchedResultsController</code>都会更新它的数据集。让我们假设我们有下面的<code class="fe lv lw lx ly b">Content</code>实体，它属于一个<code class="fe lv lw lx ly b">Bucket</code>实体:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="f269" class="ni mh it ly b gy nj nk l nl nm">final class Content: NSManagedObject {<br/>    @NSManaged var name: String<br/>    @NSManaged var creationDate: Date<br/>    @NSManaged var bucket: Bucket<br/>}<br/><br/>final class Bucket: NSManagedObject {<br/>    @NSManaged var name: String<br/>    @NSManaged var content: Set&lt;Content&gt;<br/>}</span></pre><p id="5bc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种关系是一对多的，因为一个内容项目只能有一个存储桶，但是一个存储桶可以有许多内容项目。</p><p id="f968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们像以前一样配置了我们的<code class="fe lv lw lx ly b">NSFetchedResultsController</code>,这里我们使用一个根据内容创建日期排序的获取请求:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="e20d" class="ni mh it ly b gy nj nk l nl nm">let fetchRequest = NSFetchRequest&lt;Content&gt;(entityName: "Content")<br/>fetchRequest.sortDescriptors = [NSSortDescriptor(keyPath: \Content.creationDate, ascending: true)]<br/>let controller = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: persistentContainer.viewContext, sectionNameKeyPath: nil, cacheName: nil)</span></pre><p id="3a94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这导致这样一个事实，即一旦任何一个<code class="fe lv lw lx ly b">Content</code>实体属性发生变化，更新就会通过——例如，当我们更新一个内容项的名称时:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="f773" class="ni mh it ly b gy nj nk l nl nm">content.name = "Updated name"<br/>try persistentContainer.viewContext.save()</span></pre><p id="d4bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，设想我们有以下观点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/bbd451715198a36dd0aadf8046cea686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/0*sp-0JTK0FVys0N66.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由“NSFetchedResultsController”支持的“UICollectionView”的示例</p></figure><p id="26ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个由<code class="fe lv lw lx ly b">NSFetchedResultsController</code>支持的<code class="fe lv lw lx ly b">UICollectionView</code>。它显示属于许多不同存储桶的所有内容项目。</p><p id="55fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在每个图像单元中，我们显示内容和包含的存储桶名称。这意味着当单元格的包含桶获得新名称时，我们需要更新单元格:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="7e61" class="ni mh it ly b gy nj nk l nl nm">content.bucket.name = "Updated name"<br/>try persistentContainer.viewContext.save()</span></pre><p id="e1a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，事实并非如此，因为FRC被设计成只监控模型层的变化。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e8db" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">我们找到但不喜欢的解决方案</h1><p id="df12" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/7533849/nsfetchedresultscontroller-with-relationship-not-updating" rel="noopener ugc nofollow" target="_blank">网上存在的一些解决方案</a>建议通过像<code class="fe lv lw lx ly b">reloadData()</code>调用这样的硬重新加载来解决这个问题。这样做是可行的，但是有很大的性能缺点，因为我们必须重新绘制所有的单元格(包括那些没有受到这个变化影响的单元格)。</p><p id="7a63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个解决方案是通过添加一个<code class="fe lv lw lx ly b">NSNotification.Name.NSManagedObjectContextDidSave</code>观察者来观察每个单元中相关存储桶的变化。这也会对性能产生负面影响，因为我们需要为每个需要更新的单元设置多个观察器。</p><p id="4378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，一旦我们需要监控多种关系，这个问题就会变得更加严重。如果我们有一个<code class="fe lv lw lx ly b">User</code>实体，它是一个内容项目的所有者，并且我们也显示用户的名字，那会怎么样？你可以想象这很容易成为维护的大问题。</p><p id="db61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在任何时候遇到调试问题，可以考虑阅读我关于使用启动参数在Xcode中调试核心数据的博文。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6b78" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">扩展“NSFetchedResultsController”以观察关系变化</h1><p id="a093" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">是时候深入研究我们编写的解决方案了。即使你的项目中可能不需要这个，通读它仍然是非常有价值的——因为它展示了你如何很好地解决类似的问题。</p><p id="0c60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们解决方案的最终实现如下所示:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="eee6" class="ni mh it ly b gy nj nk l nl nm">let fetchRequest = RichFetchRequest&lt;Content&gt;(entityName: "Content")<br/>fetchRequest.sortDescriptors = [NSSortDescriptor(keyPath: \Content.creationDate, ascending: true)]<br/><br/>fetchRequest.relationshipKeyPathsForRefreshing = [<br/>    #keyPath(Content.bucket.name)<br/>]<br/><br/>let controller = RichFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: persistentContainer.viewContext, sectionNameKeyPath: nil, cacheName: nil)</span></pre><p id="8eed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些事情已经改变了:</p><ul class=""><li id="3875" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">我们现在有了一个<code class="fe lv lw lx ly b">RichFetchRequest</code>实例，它允许我们用定制功能来丰富默认的<code class="fe lv lw lx ly b">NSFetchRequest</code></li><li id="b14f" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">因此，我们现在也有了一个<code class="fe lv lw lx ly b">RichFetchedResultsController</code>,它只处理丰富的获取请求</li><li id="655f" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">最后，我们添加了一个新属性<code class="fe lv lw lx ly b">relationshipKeyPathsForRefreshing</code>,它采用一个关系键路径数组来观察更新</li></ul><p id="2591" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这太棒了！它看起来几乎像一个本地API，并且可以从fetch请求设置中发现。除此之外，我们还集中了描述数据集更新方式的设置。</p><p id="7c4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们深入了解一下这是如何创建的。</p><h2 id="a26a" class="ni mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">整体结构</h2><p id="5677" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这有助于了解我们在这里创建的结构的概况。我们有几个共同努力实现这一目标的例子:</p><ul class=""><li id="2b9e" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">RichFetchRequest</code></li><li id="0581" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">RichFetchedResultsController</code></li><li id="ce4d" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">RelationshipKeyPath</code></li><li id="d38a" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">RelationshipKeyPathsObserver</code></li></ul><p id="daff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">fetch请求定义了要观察的关系键路径，并将它们传递给FRC。FRC设置了一个<code class="fe lv lw lx ly b">RelationshipKeyPathsObserver</code>,负责设置所需的观察值，如果需要，还会触发所需的刷新。</p><h2 id="06a8" class="ni mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">创建<code class="fe lv lw lx ly b">'RichFetchRequest'</code>和<code class="fe lv lw lx ly b">'RichFetchedResultsController'</code></h2><p id="773b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这些类有点简单，仅用于将关系键路径传递给观察者。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="d769" class="ni mh it ly b gy nj nk l nl nm">/// An enhanced `NSFetchRequest` that has extra functionality.<br/>public final class RichFetchRequest&lt;ResultType&gt;: NSFetchRequest&lt;NSFetchRequestResult&gt; where ResultType: NSFetchRequestResult {<br/><br/>    /// A set of relationship key paths to observe when using a `RichFetchedResultsController`.<br/>    public var relationshipKeyPathsForRefreshing: Set&lt;String&gt; = []<br/>}</span></pre><p id="1a79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是采用泛型<code class="fe lv lw lx ly b">ResultType</code>的<code class="fe lv lw lx ly b">RichFetchRequest</code>。当我们从Objective-C类继承时，我们需要为我们的<code class="fe lv lw lx ly b">NSFetchRequest</code>基类设置一个强类型。这里我们还可以看到<code class="fe lv lw lx ly b">relationshipKeyPathsForRefreshing</code>属性，它收集了要观察的关系键路径。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="66fa" class="ni mh it ly b gy nj nk l nl nm">/// An enhanced `NSFetchedResultsController` that has extra functionality.<br/>public class RichFetchedResultsController&lt;ResultType: NSFetchRequestResult&gt;: NSFetchedResultsController&lt;NSFetchRequestResult&gt; {<br/><br/>    /// The relationship key paths observer that is only initialised if the fetch request has a `relationshipKeyPathsForRefreshing` set.<br/>    private var relationshipKeyPathsObserver: RelationshipKeyPathsObserver&lt;ResultType&gt;?<br/><br/>    public init(fetchRequest: RichFetchRequest&lt;ResultType&gt;, managedObjectContext context: NSManagedObjectContext, sectionNameKeyPath: String?, cacheName name: String?) {<br/>        super.init(fetchRequest: fetchRequest, managedObjectContext: context, sectionNameKeyPath: sectionNameKeyPath, cacheName: name)<br/><br/>        relationshipKeyPathsObserver = RelationshipKeyPathsObserver&lt;ResultType&gt;(keyPaths: fetchRequest.relationshipKeyPathsForRefreshing, fetchedResultsController: self)<br/>    }<br/><br/>}</span></pre><p id="0086" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是<code class="fe lv lw lx ly b">RichFetchedResultsController</code>，它保留观察器，并使用丰富的获取请求来设置观察器本身。我们只需要创建一个新的初始化器，允许将<code class="fe lv lw lx ly b">RichFetchRequest</code>作为输入。</p><h2 id="aac5" class="ni mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">构建“关系密钥路径服务器”</h2><p id="464d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这是所有奇迹发生的班级。<code class="fe lv lw lx ly b">RelationshipKeyPathsObserver</code>负责在给定的上下文上建立观察，将它与我们的关系键路径匹配，并最终确保正确的实体被刷新。</p><p id="c54a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该类使用一个<code class="fe lv lw lx ly b">RelationshipKeyPath</code>结构，它将给定的关系键路径解析成一个实例，该实例给出了与我们的FRC核心实体的关系信息。在我们的例子中，这是与我们的核心<code class="fe lv lw lx ly b">Content</code>实体的关系。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="834d" class="ni mh it ly b gy nj nk l nl nm">/// Describes a relationship key path for a Core Data entity.<br/>public struct RelationshipKeyPath: Hashable {<br/><br/>    /// The source property name of the relationship entity we're observing.<br/>    let sourcePropertyName: String<br/><br/>    let destinationEntityName: String<br/><br/>    /// The destination property name we're observing<br/>    let destinationPropertyName: String<br/><br/>    /// The inverse property name of this relationship. Can be used to get the affected object IDs.<br/>    let inverseRelationshipKeyPath: String<br/><br/>    public init(keyPath: String, relationships: [String: NSRelationshipDescription]) {<br/>        let splittedKeyPath = keyPath.split(separator: ".")<br/>        sourcePropertyName = String(splittedKeyPath.first!)<br/>        destinationPropertyName = String(splittedKeyPath.last!)<br/><br/>        let relationship = relationships[sourcePropertyName]!<br/>        destinationEntityName = relationship.destinationEntity!.name!<br/>        inverseRelationshipKeyPath = relationship.inverseRelationship!.name<br/><br/>        [sourcePropertyName, destinationEntityName, destinationPropertyName].forEach { property in<br/>            assert(!property.isEmpty, "Invalid key path is used")<br/>        }<br/>    }<br/>}</span></pre><p id="664f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些属性都用于识别<code class="fe lv lw lx ly b">managedObjectContext</code>中应该触发刷新的变化。</p><p id="1eaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的基本类设置如下所示:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="9fae" class="ni mh it ly b gy nj nk l nl nm">/// Observes relationship key paths and refreshes Core Data objects accordingly once the related managed object context saves.<br/>public final class RelationshipKeyPathsObserver&lt;ResultType: NSFetchRequestResult&gt;: NSObject {<br/>    private let keyPaths: Set&lt;RelationshipKeyPath&gt;<br/>    private let fetchedResultsController: RichFetchedResultsController&lt;ResultType&gt;<br/><br/>    private var updatedObjectIDs: Set&lt;NSManagedObjectID&gt; = []<br/><br/>    public init?(keyPaths: Set&lt;String&gt;, fetchedResultsController: RichFetchedResultsController&lt;ResultType&gt;) {<br/>        guard !keyPaths.isEmpty else { return nil }<br/><br/>        let relationships = fetchedResultsController.fetchRequest.entity!.relationshipsByName<br/>        self.keyPaths = Set(keyPaths.map { keyPath in<br/>            return RelationshipKeyPath(keyPath: keyPath, relationships: relationships)<br/>        })<br/>        self.fetchedResultsController = fetchedResultsController<br/><br/>        super.init()<br/><br/>        NotificationCenter.default.addObserver(self, selector: #selector(contextDidChangeNotification(notification:)), name: NSNotification.Name.NSManagedObjectContextObjectsDidChange, object: fetchedResultsController.managedObjectContext)<br/>        NotificationCenter.default.addObserver(self, selector: #selector(contextDidSaveNotification(notification:)), name: NSNotification.Name.NSManagedObjectContextDidSave, object: fetchedResultsController.managedObjectContext)<br/>    }<br/>}</span></pre><p id="878c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它负责将关键路径解析到我们的<code class="fe lv lw lx ly b">RelationshipKeyPath</code>实例中，并向<code class="fe lv lw lx ly b">NSFetchedResultsController</code>上下文添加两个观察者。让我们来分解这两个通知，并描述它们的作用。</p><h2 id="6d79" class="ni mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">观察'【T6]'的变化</h2><p id="a278" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们的第一个观察者利用了<code class="fe lv lw lx ly b">NSManagedObjectContextObjectsDidChange</code>通知，并负责跟踪上下文中的任何变化。我们利用这个通知，因为它允许我们使用<code class="fe lv lw lx ly b">NSManagedObject.changedValues()</code>方法读出改变的值。这个方法不会在“已保存”通知中返回任何内容，因为更改已经被合并了。</p><p id="1474" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通知回调如下所示:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="2fa4" class="ni mh it ly b gy nj nk l nl nm">@objc private func contextDidChangeNotification(notification: NSNotification) {<br/>    guard let updatedObjects = notification.userInfo?[NSUpdatedObjectsKey] as? Set&lt;NSManagedObject&gt; else { return }<br/>    guard let updatedObjectIDs = updatedObjects.updatedObjectIDs(for: keyPaths), !updatedObjectIDs.isEmpty else { return }<br/>    self.updatedObjectIDs = self.updatedObjectIDs.union(updatedObjectIDs)<br/>}</span></pre><p id="f7ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法负责将更新后的<code class="fe lv lw lx ly b">NSManagedObjectID</code>实例收集到一个<code class="fe lv lw lx ly b">Set</code>中。我们使用了一个<code class="fe lv lw lx ly b">Set </code>——因为它允许我们保存一个唯一实例的集合，并防止我们以后多次刷新一个单元格。</p><p id="9669" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们只考虑更新的对象，因为我们不关心新插入或删除的实例。这些由<code class="fe lv lw lx ly b">NSFetchedResultsController</code>正确处理，不需要任何定制的重新加载。</p><p id="b315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用的方法如下:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="8b07" class="ni mh it ly b gy nj nk l nl nm">extension Set where Element: NSManagedObject {<br/><br/>    /// Iterates over the objects and returns the object IDs that matched our observing keyPaths.<br/>    /// - Parameter keyPaths: The keyPaths to observe changes for.<br/>    func updatedObjectIDs(for keyPaths: Set&lt;RelationshipKeyPath&gt;) -&gt; Set&lt;NSManagedObjectID&gt;? {<br/>        var objectIDs: Set&lt;NSManagedObjectID&gt; = []<br/>        forEach { object in<br/>            guard let changedRelationshipKeyPath = object.changedKeyPath(from: keyPaths) else { return }<br/><br/>            let value = object.value(forKey: changedRelationshipKeyPath.inverseRelationshipKeyPath)<br/>            if let toManyObjects = value as? Set&lt;NSManagedObject&gt; {<br/>                toManyObjects.forEach {<br/>                    objectIDs.insert($0.objectID)<br/>                }<br/>            } else if let toOneObject = value as? NSManagedObject {<br/>                objectIDs.insert(toOneObject.objectID)<br/>            } else {<br/>                assertionFailure("Invalid relationship observed for keyPath: \(changedRelationshipKeyPath)")<br/>                return<br/>            }<br/>        }<br/><br/>        return objectIDs<br/>    }<br/>}<br/><br/>private extension NSManagedObject {<br/><br/>    /// Matches the given key paths to the current changes of this `NSManagedObject`.<br/>    /// - Parameter keyPaths: The key paths to match the changes for.<br/>    /// - Returns: The matching relationship key path if found. Otherwise, `nil`.<br/>    func changedKeyPath(from keyPaths: Set&lt;RelationshipKeyPath&gt;) -&gt; RelationshipKeyPath? {<br/>        return keyPaths.first { keyPath -&gt; Bool in<br/>            guard keyPath.destinationEntityName == entity.name! || keyPath.destinationEntityName == entity.superentity?.name else { return false }<br/>            return changedValues().keys.contains(keyPath.destinationPropertyName)<br/>        }<br/>    }<br/>}</span></pre><p id="112e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是相当多的消化，但通过分解，这应该是可能的。</p><ul class=""><li id="f06c" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">首先，我们尝试为更新后的对象获取更改后的键路径。如果它不匹配任何我们观察的关键路径，我们可以直接跳过这个对象。</li><li id="d538" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">基于实体匹配找到匹配</li><li id="d509" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">子实体也被考虑，例如，从<code class="fe lv lw lx ly b">Content</code>实体继承的<code class="fe lv lw lx ly b">ImageContent</code></li><li id="6f27" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">最后，使用<code class="fe lv lw lx ly b">changedValues()</code>方法来验证变化包含我们观察的关键路径</li><li id="9e3a" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">其次，我们通过获取反向关系属性从实例中获取对象id。这确保我们在多对多关系的情况下获得所有的对象id。例如，我们的拥有许多<code class="fe lv lw lx ly b">Content</code>项的<code class="fe lv lw lx ly b">Bucket</code>实体将把它们都添加到我们的对象id的<code class="fe lv lw lx ly b">Set</code>中。</li></ul><h2 id="9916" class="ni mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">观察“managedObjectContext”保存</h2><p id="9baf" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们的最后一段代码存在于监控保存到我们的上下文中。这是我们真正想要触发单元格重载的唯一时刻——因为数据最终被提交。这导致了更好的性能，否则我们将在每次未提交的更改时重新加载一个单元。</p><p id="5391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">观察值的回调如下所示:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="ea84" class="ni mh it ly b gy nj nk l nl nm">@objc private func contextDidSaveNotification(notification: NSNotification) {<br/>    guard !updatedObjectIDs.isEmpty else { return }<br/>    guard let fetchedObjects = fetchedResultsController.fetchedObjects as? [NSManagedObject], !fetchedObjects.isEmpty else { return }<br/><br/>    fetchedObjects.forEach { object in<br/>        guard updatedObjectIDs.contains(object.objectID) else { return }<br/>        fetchedResultsController.managedObjectContext.refresh(object, mergeChanges: true)<br/>    }<br/>    updatedObjectIDs.removeAll()<br/>}</span></pre><p id="de6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们确保有更新的对象要刷新。之后，我们获取当前获取的数据集，并开始对它们进行迭代，以查看是否找到匹配的更新对象标识符。</p><p id="23af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当我们找到一个，我们触发<code class="fe lv lw lx ly b">refresh(_:mergeChanges:)</code>方法，将<code class="fe lv lw lx ly b">mergeChanges</code>设置为<code class="fe lv lw lx ly b">true</code>。这确保了任何未提交的更改不会被丢弃，而是与新的可用数据合并。这个刷新方法也负责触发<code class="fe lv lw lx ly b">NSFetchedResultsController</code>，因为它是自动拾取的。您的所有委托方法都将被相应地调用，就像我们正在更新核心<code class="fe lv lw lx ly b">Content</code>实体的名称一样。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="715b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="feba" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">就是这样！我们扩展了<code class="fe lv lw lx ly b">NSFetchedResultsController</code>并创建了一个可发现且易于使用的顶级API。通过在一个集中的<code class="fe lv lw lx ly b">RelationshipKeyPathsObserver</code> observer类中观察变化，我们允许自己创建一个性能良好的解决方案来保持我们的内容对于关系变化是最新的。</p><p id="3a50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你正在考虑对你的应用进行更高性能的更新，你可以考虑阅读我在<a class="ae ky" href="https://www.avanderlee.com/swift/nsbatchdeleterequest-core-data/" rel="noopener ugc nofollow" target="_blank">上的博文，使用‘NSBatchDeleteRequest’删除核心数据</a>中的批处理。</p><p id="41ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢！</p></div></div>    
</body>
</html>