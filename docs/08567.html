<html>
<head>
<title>Build Your First Convolutional Neural Network in 14 Lines of Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用14行Python代码构建您的第一个卷积神经网络</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-your-first-convolutional-neural-network-in-14-lines-of-python-200af0fb6b13?source=collection_archive---------7-----------------------#2021-05-14">https://betterprogramming.pub/build-your-first-convolutional-neural-network-in-14-lines-of-python-200af0fb6b13?source=collection_archive---------7-----------------------#2021-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e5cf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你只需要一个浏览器就可以开始了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6ef3bd5f398f91b78d633e9d99062a74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T4W1oC6dgyK-2cqKN8EHHA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@ketut-subiyanto?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kz">赖爷</strong> </a>发自<a class="ae ky" href="https://www.pexels.com/photo/content-asian-children-building-wooden-tower-on-floor-at-home-4473569/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kz">像素</strong> </a></p></figure><p id="2023" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当我们谈论面罩检测、自动驾驶汽车、对象分割、异常检测时，任何需要相机捕捉场景并根据相机拍摄的镜头做出主动或被动决定的事情，我们都需要一个可以处理图像的神经网络。如果我们需要一个可以处理图像的神经网络，我们需要卷积神经网络。</p><p id="db54" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">本文将介绍使用Python库Keras创建卷积神经网络。我们将研究如何添加不同的层来构建我们的第一个卷积神经网络。</p><p id="91a2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">好的一面是，你不需要一个高端系统——我们将使用Google Colab来构建我们的卷积神经网络。所有的库都是在Google Colab中预装配置的，安装部分就不用担心了。<br/> <br/>如果你的机器里安装了Jupyter笔记本，你也可以跟着去那里。Google Colab提供了Jupyter笔记本的托管版本。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2fb1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">启动Google Colab</h1><p id="12cc" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">要启动Google Colab，请在您选择的浏览器中键入以下URL，然后使用您的任何Google帐户登录。要了解更多关于Google Colab的工作原理，请查看我的文章<a class="ae ky" href="https://towardsdatascience.com/this-free-gpu-enabled-python-ide-for-your-data-science-projects-acc50dd8d1dd" rel="noopener" target="_blank">。</a></p><p id="669e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在浏览器中键入网址<a class="ae ky" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank">https://colab.research.google.com/</a>，如图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/6a8cd20f633bce6a2558bc18bd244315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*o2om6VTSYiFPkchx--2aVg.gif"/></div></div></figure><h1 id="87de" class="md me it bd mf mg nb mi mj mk nc mm mn jz nd ka mp kc ne kd mr kf nf kg mt mu bi translated">导入库</h1><p id="087e" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">我们将使用Python编程和Keras库来构建我们的网络。</p><p id="1123" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果你在Google Colab上，那么你也可以使用免费的GPU功能——只需点击运行时并选择GPU，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/19746473c069c9232c8fbf068e83198a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Yf7fgBygxnxe5xG9kSJOYA.gif"/></div></div></figure><p id="c88d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">选择GPU环境后，让我们导入必要的库:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="fe49" class="nl me it nh b gy nm nn l no np">from tensorflow.keras import backend as K<br/>from tensorflow.keras.models import Model<br/>from tensorflow.keras.models import Sequential<br/>from tensorflow.keras.layers import Input, Dropout, Flatten, Conv2D, MaxPooling2D, Dense, Activation</span></pre><p id="8b4e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">键入这些库后，按<code class="fe nq nr ns nh b">shift+enter</code>运行单元。如果您在Google Colab上，该单元将成功执行，但如果您正在使用您的机器，您将需要安装TensorFlow Keras。</p><p id="842f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这些库导入模型、图层类型、删除函数、展平函数以及我们将用于模型构建的激活函数。</p><p id="1617" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，让我们从模型构建开始。</p><h1 id="65ad" class="md me it bd mf mg nb mi mj mk nc mm mn jz nd ka mp kc ne kd mr kf nf kg mt mu bi translated">构建卷积神经网络</h1><p id="a920" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">对于本文，我们将构建一个顺序模型，其中层是一个接一个添加的——一个简单的层列表。</p><p id="4da1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">键入以下代码行来定义我们的<code class="fe nq nr ns nh b">Sequential</code>网络:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="a39d" class="nl me it nh b gy nm nn l no np">model=Sequential()</span></pre><p id="5950" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，我们需要在这个空模型中添加一组层来完成它。让我们添加第一个卷积层。第一层包含模型的输入。我们需要在第一层定义图像的输入尺寸。我拍摄了尺寸为200 x 200的照片:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="e587" class="nl me it nh b gy nm nn l no np">IMAGE_SIZE=[200,200]</span><span id="b797" class="nl me it nh b gy nt nn l no np">model.add(Conv2D(16,kernel_size=(3,3),input_shape=IMAGE_SIZE + [3]))</span></pre><p id="e06f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">好了，我们刚刚定义了第一个输入卷积层。现在，对于任何卷积神经网络，我们遵循一种称为CRP的模式。CRP代表:</p><blockquote class="nu"><p id="f23b" class="nv nw it bd nx ny nz oa ob oc od lv dk translated">卷积Relu池</p></blockquote><p id="249c" class="pw-post-body-paragraph la lb it lc b ld oe ju lf lg of jx li lj og ll lm ln oh lp lq lr oi lt lu lv im bi translated">最佳实践是将这组图层添加到模型中的输入图层之后，这将获得最佳效果。此外，除了这些层，我们还可以使用丢弃层来解决过度拟合问题:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="c36a" class="nl me it nh b gy nm nn l no np">model.add(Conv2D(32, kernel_size=(3,3), activation="relu")) <br/>model.add(MaxPooling2D(pool_size=(2,2)))<br/>model.add(Dropout(0.30))</span></pre><p id="55b3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里，我们需要定义内核大小。内核也称为旋转窗口，负责检测不同的形状。因此，我们将定义旋转窗口的数量和旋转窗口的大小。</p><p id="0e8b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，让我们添加更多具有不同内核数的类似层。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="25e9" class="nl me it nh b gy nm nn l no np">model.add(Conv2D(64, kernel_size=(3,3), activation="relu"))<br/>model.add(MaxPooling2D(pool_size=(2,2)))<br/>model.add(Dropout(0.35))</span><span id="b65f" class="nl me it nh b gy nt nn l no np">model.add(Conv2D(128, kernel_size=(3,3), activation="relu"))<br/>model.add(BatchNormalization()) <br/>model.add(Dropout(0.45))</span></pre><h1 id="b25e" class="md me it bd mf mg nb mi mj mk nc mm mn jz nd ka mp kc ne kd mr kf nf kg mt mu bi translated">将这些点连接起来</h1><p id="ea58" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">卷积层为我们提供了像素更少的图像输出。为了得到作为类的数量的最终结果，我们需要将图像展平成一维向量。我们现在将根据要预测的类的数量为最后的层添加最终的激活函数。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="17c4" class="nl me it nh b gy nm nn l no np">model=Sequential()</span><span id="d128" class="nl me it nh b gy nt nn l no np">model.add(Conv2D(16,kernel_size=(3,3),input_shape=IMAGE_SIZE + [3]))</span><span id="4d70" class="nl me it nh b gy nt nn l no np">model.add(Conv2D(32, kernel_size=(3,3), activation="relu")) <br/>model.add(MaxPooling2D(pool_size=(2,2)))<br/>model.add(Dropout(0.30))</span><span id="9f0e" class="nl me it nh b gy nt nn l no np">model.add(Conv2D(64, kernel_size=(3,3), activation="relu"))<br/>model.add(MaxPooling2D(pool_size=(2,2)))<br/>model.add(Dropout(0.35))</span><span id="97bd" class="nl me it nh b gy nt nn l no np">model.add(Conv2D(128, kernel_size=(3,3), activation="relu"))<br/>model.add(BatchNormalization()) <br/>model.add(Dropout(0.45))</span><span id="1d95" class="nl me it nh b gy nt nn l no np">model.add(Flatten())<br/>model.add(Dense(64, activation="relu"))<br/>model.add(Dense(num_classes, activation="softmax"))</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7900" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="ba4c" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">呜哇！我们刚刚制作了第一个卷积神经网络。好消息是，我们不需要花费不必要的时间来设置环境——这都要感谢Google Colab。</p><p id="1014" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在接下来的文章中，我将介绍训练模型的步骤，并将其与网络摄像头配合使用。</p><p id="d600" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我希望你喜欢这篇文章。敬请期待下一期！</p><p id="0f90" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">感谢阅读！</p></div></div>    
</body>
</html>