<html>
<head>
<title>Introduction to Binary Search Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二分搜索法树简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-binary-search-trees-dde166368210?source=collection_archive---------3-----------------------#2019-06-24">https://betterprogramming.pub/introduction-to-binary-search-trees-dde166368210?source=collection_archive---------3-----------------------#2019-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8890" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何在C#中向二叉查找树添加节点</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5d4f679a1fb65d6385340698a75f8f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_EkYT82V0nWhezz4mPpBrA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@tanrenzu?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">维克多·詹布拉诺</a>在<a class="ae kv" href="https://unsplash.com/search/photos/tree?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="cb64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我叫亚历克西斯，是计算机科学和数学专业的一名大四学生。我对算法和图形很着迷，今天我想通过一个二叉查找树的例子来编码。</p><p id="7610" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">注:我不是一个完美的程序员。我知道我会犯错误，会错过使代码更好的显而易见的方法，但是现在，我只想向您展示一个简单、易于理解的二叉查找树工作模型。</em></p><p id="3d0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">二叉查找树是这样一种图，其中每个节点只能有两个子节点，一个右节点和一个左节点。左侧节点总是小于其父节点，右侧节点总是大于其父节点。总是有一个节点开始树，它被称为“根”节点。这是一个二叉查找树的例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/343b30416e83f9540835e676484c589a.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*OVuCcXW3xITx53EEaVAi3Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自<a class="ae kv" href="https://en.wikipedia.org/wiki/Binary_search_tree" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Binary_search_tree</a></p></figure><p id="e0ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在二叉查找树中添加、删除和查找节点有特定的算法，但我们将在后面介绍这些算法。</p><p id="cc0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个项目我用的是Visual Studio。所以我首先点击“创建一个新项目”并选择“控制台应用程序(。NET Core)”作为项目的类型。我将我的命名为“BinarySearchTreeExample ”,但是您可以随意命名它！然后点击创建和PRESTO！！您有一个类似如下的空白Visual Studio项目:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/eead9e4a51e63e4a029af00633a9609e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*hXi7DfQeKLrpcQwsY-e3rQ.png"/></div></figure><p id="598c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我要做的第一件事就是右键单击右侧的项目(请原谅我糟糕的突出显示):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/1b9a4b14ef70a8a8fbb0d1a097f057f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*ixiw0hpAeO3557W4q34kIg.png"/></div></figure><p id="dacc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将鼠标悬停在“添加”上，然后单击“课程…”。我把我的类命名为“Node ”,但是你可以随意命名。您应该会得到一个类似如下的新文件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/7083f7c584200c1592fa2eb95d585d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*C0KVWj5nrY_pIy9EnDN-Hw.png"/></div></figure><p id="4fb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你回头看看这篇文章开头的二叉查找树的图片，你会注意到在每个圆圈或“节点”上都有一个数字。我们将把这个数字称为我们的<code class="fe lw lx ly lz b">label</code>。因此，我在<code class="fe lw lx ly lz b">Node</code>类中创建了一个公共字段来存储我们的<code class="fe lw lx ly lz b">label</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="4c42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还会注意到每个<code class="fe lw lx ly lz b">Node</code>的左边和右边各有一个分支。我们可以通过创建代表这些节点的两个变量来添加这些边:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="a5ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">厉害！现在让我们创建一个构造函数。当我们想要创建一个新的节点来添加到我们的图中时，我们就调用构造函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="2059" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们创建一个新节点时，我们将传入我们想要给它的值，所以占位符<code class="fe lw lx ly lz b">data</code>就在这里发挥作用了。您还会注意到，我将left和right设置为<code class="fe lw lx ly lz b">null</code>，这实质上意味着它们是“空的”。我们马上将左边和右边的子节点设置为<code class="fe lw lx ly lz b">null</code>,因为这些节点在被添加到图中之前不能有子节点，而且现在它们不是图的一部分。他们刚刚被创造出来。</p><p id="6902" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧！我们有了制作节点的基础。让我们回到<code class="fe lw lx ly lz b">Program.cs</code>，开始初始化树。</p><p id="3b36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在<code class="fe lw lx ly lz b">Program.cs</code>做的第一件事就是删除<code class="fe lw lx ly lz b">Console.WriteLine(“Hello World!”);</code>，因为我们的程序不再需要它了。</p><p id="4d8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，重要的是要注意，我们不需要为图中的所有节点设置变量，因为只要我们有办法到达树的根节点，父节点和子节点之间的连接就应该能够让我们到达树中的所有其他节点。因此，我首先创建一个变量来保存我们树中的根节点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="269c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要担心<code class="fe lw lx ly lz b">root</code>下面的绿色曲线，它很快就会消失。</p><p id="6de4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要能够对我们的树做的下一件事是添加新的节点。所以，我返回到<code class="fe lw lx ly lz b">Node.cs</code>添加一个函数，允许我向树中添加新的节点。</p><p id="0070" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了将节点连接到树，我们需要能够看到树。所以我们必须为根节点传入一个引用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="3136" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想做的第一件事是确保根节点不是空的，因为如果我们试图比较新节点的值和根节点的值，但是根节点是空的，我们会得到一个错误。一个非常简单的<code class="fe lw lx ly lz b">if</code>语句检查了这一点。我添加了一个<code class="fe lw lx ly lz b">Console.WriteLine()</code>，这样如果我的程序失败了，我就可以通过查看控制台来了解原因:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="10b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">有趣的Visual Studio hack:如果你输入字母“CW”并按tab键两次，它会为你填写语法，你只需填写括号之间的部分！</em></p><p id="dd36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来我要检查的是重复值。如果你允许重复值，二分搜索法树会变得更加复杂，所以为了这个程序的目的，我们不允许这样做。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="570e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要知道向树中添加节点的算法。假设我有这棵树:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/0087f0088d4283654c9b6347ada30dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*9ns0yoaej9GTz_I3WUz0vQ.png"/></div></figure><p id="2031" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想给它加上节点23。我们将从顶部节点开始，并决定它是属于它的左边还是右边。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi md"><img src="../Images/4188d4a10de74fc246ab8c563be78808.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*g3sIWd1PrG8rlFNi9Z-O7Q.png"/></div></figure><p id="15a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于23小于63，所以属于左派。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi me"><img src="../Images/53fd0a04c98a0956644e7e923437bc7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*Rbs3yCJBxIkjBoZi6VZi7A.png"/></div></figure><p id="90ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，我们可以忽略树的某些部分。我们知道我们永远也不会碰到63或82，因为从我们所在的地方没有指向它们的箭头。我们唯一的选择就是去箭头所指的地方，也就是向下。所以，我们可以忽略这两个节点，假装我们有一个新的树。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mf"><img src="../Images/17006aa1b1f0433accc2870cf4ad4313.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*vKQXLfcxYyLdDdbW_88Yzg.png"/></div></div></figure><p id="e035" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">新的树看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/4aec7c7af52b1f9d20e8f33e6865485e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*cJbj-eFGAULTzymPSaJl8g.png"/></div></figure><p id="a879" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以比较23和30。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/47c2fffb9461dc60f8ec65b4a1edfc46.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*WjL4u1ud0QtvJwzMO-ywcw.png"/></div></figure><p id="f05f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为23小于30，所以我们向左走。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/5f4f0fffa8d632f5388ea91b29cbe6b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*Wnow6sFIpI0pRtKBNsdkdQ.png"/></div></figure><p id="135c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以重复忽略不可达节点的过程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/338103ae2ce0b68a6eb99530e24a59f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*58gmNqs4pjzhpVApu-7RrA.png"/></div></figure><p id="d49a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">新树只是一个节点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/a3e779ff0f3841958bb77b4d66ced415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*FoeOK0ZWFFCPAajGrND0lw.png"/></div></figure><p id="9534" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们必须决定它是属于17的左边还是右边。既然23大于17，就属于右。所以，我们把它移到下面，但是没有什么可以比较。所以，我们不是比较，而是成为17右边的节点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/dd13fabfa7d8287c48b07ec75835264d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*X2jRq7J1bLWGxwOigLMKJw.png"/></div></figure><p id="8c84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，这棵树看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/b54abf96c3129e5bb2a92185fa08a3f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*sfeoV9qKW1jENUtU5jF5Dg.png"/></div></figure><p id="688e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在我们的代码中实现这一点，我们进入了我们的<code class="fe lw lx ly lz b">AddNode</code>函数。在代码的这一点上，我们已经有一个新的节点位于图表的顶部。我们的第一步是决定新节点需要向左还是向右。我们通过将其与我们所在的节点进行比较来决定。所以，我们可以从添加那些if/else语句的外壳开始。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="ee9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步是确保有一个节点可以与之进行比较。所以，让我们把它加进去:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="5197" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果没有什么可以比较，那么我们知道它属于那个地方！所以，让我们加上那部分:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="d50d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关键字<code class="fe lw lx ly lz b">this</code>是C#引用我们正在查看的当前对象的方式。因此，在上面的例子中，节点23将通过使用<code class="fe lw lx ly lz b">this</code>关键字到达。</p><p id="bb70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，这是棘手的部分。如果我们有新的节点与之比较，我们需要重复整个过程，但我们不能只是重新编写，因为我们不知道我们需要重复这个过程多少次。那么，我们能做什么…</p><p id="ef9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们知道，如果我们有可以比较的东西，我们可以忽略已经经过的树的其余部分。这有点像有了一个新的根节点。那么，如果我们再次调用这个函数并传入一个新的根节点会怎么样呢？那叫递归！所以，让我们加上那部分:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="14ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过返回到<code class="fe lw lx ly lz b">Program.cs</code>并添加一个调用它的方法来测试它！</p><p id="1ef1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道我要随机地给这棵树添加数字，所以我要初始化一个新的随机变量。在C#中，这样做的方法是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="c525" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我要写一个<code class="fe lw lx ly lz b">for</code>循环。<code class="fe lw lx ly lz b">for</code>循环本质上是告诉计算机重复某件事情一定的次数。现在我想这样做五次，所以我的for循环看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="2825" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有趣的Visual Studio hack:如果你输入“for”并按tab键两次，它会为你填写所有内容，你只需改变你希望它重复的次数</p><p id="534a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从这里，我可以添加新的节点。首先要做的是，我需要创建一个随机数，并将其添加到树中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="b464" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我现在只调用了我的变量x，我让它在0到100之间选择一个随机数。</p><p id="0103" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来我们要做的是创建一个值为“x”的节点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="f4da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们可以使用我们编写的函数将n添加到图形中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="4211" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我们有一个问题。注意<code class="fe lw lx ly lz b">root</code>是如何被设置为<code class="fe lw lx ly lz b">null</code>的，并且我们将它传递给我们的函数？这是一个问题，因为在我们的<code class="fe lw lx ly lz b">AddNode</code>函数中，我们说过如果<code class="fe lw lx ly lz b">root</code>等于<code class="fe lw lx ly lz b">null</code>，什么都不做。这段代码执行五次就什么也不做了！因此，我们需要添加一种方法来检查<code class="fe lw lx ly lz b">root</code>是否是<code class="fe lw lx ly lz b">null</code>，如果是，那么我们只需将<code class="fe lw lx ly lz b">root</code>设置为我们创建的第一个节点。看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="999e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们的代码应该工作了！让我们按下这个播放按钮来试试:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/69046ad662bb2b0e03995ff6621b9534.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*TZy59Hyt8eD8HoOY-wmQsg.png"/></div></figure><p id="7fb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我得到的输出。你的会有所不同，因为我们使用了随机数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/22b08d0fd58ca2c1c8986a3ad5ef82f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*V37Lg6-VAvx-l5fPsSQRAQ.png"/></div></figure><p id="1e85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着我们试图将40、32、43、21和81添加到我们的树中。阅读这个输出并不能使图形非常容易地可视化，但是我们可以把它画出来看看是否有效！</p><p id="b849" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们从一个空图开始，然后尝试添加40，它被设置为树的根:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/cec8abba877a0fd5d45ca606375de0b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*LSuLDlxTgkM5gqNj8AFXbA.png"/></div></figure><p id="2461" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们试着加上32，它小于40，所以它向左:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/a8526835928cfdb54a64dea8a6882696.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*pnW7gCqfw1caGMR0NNrkig.png"/></div></figure><p id="2c55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不错！我们输出的第二行是正确的，我们在40的左边加了32。接下来，我们将尝试添加43。43大于40，所以它向右移动:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/400fa6cad9f765cbf17cb693b45385ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*kde_eb4rA7csFZKxwDqCTQ.png"/></div></figure><p id="0a01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着我们的第三行输出是正确的！接下来是21，小于40，所以我们向左。21小于32，所以我们也要去它的左边:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/4da11defe8052c903c98930f636ffded.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*zdwAESLqQnB3y0z89QCUAA.png"/></div></figure><p id="a3d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后我们尝试加81。81大于40，所以我们向右走。81也大于43，所以我们要把自己加到43的右边:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/573abb4a3960d35fa292200d5df0d085.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*4pKdla0P4kpp24YyZteQnw.png"/></div></div></figure><p id="4767" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着最后一行输出是正确的！完美！</p><p id="f669" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下次我们将看到如何从二叉查找树中删除项目。</p><p id="ee3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！！</p></div></div>    
</body>
</html>