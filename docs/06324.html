<html>
<head>
<title>Why Kubernetes Isn’t Always a Developer's Best Friend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么Kubernetes不总是开发人员最好的朋友</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-kubernetes-isnt-always-a-developers-best-friend-3a8b407318f6?source=collection_archive---------12-----------------------#2020-09-21">https://betterprogramming.pub/why-kubernetes-isnt-always-a-developers-best-friend-3a8b407318f6?source=collection_archive---------12-----------------------#2020-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4f20" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Kubernetes阻抗不匹配</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3de8e6635d29985de17b79f408e8fd09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ToxVyMrXz_K937l4tA52Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=91013" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/12019-12019/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=91013" rel="noopener ugc nofollow" target="_blank">大卫马克</a>的图片。</p></figure><p id="7cea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>是一款令人惊叹的编排服务。它将确保您的所有服务都已启动，重新启动那些似乎正在失败的服务，并组织您的日志和诊断。它席卷了整个行业，并成为所有云提供商之间的共同纽带。如果你了解Kubernetes，你可以相对容易地在Azure的AKS、亚马逊的EKS和谷歌的GKE之间转换。</p><p id="aeb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是一名开发人员，它有希望使开发和生产部署如此相似，以至于以前只能在生产中发现的错误可以在开发周期的早期发现。它使完全自动化的CI/CD几乎近在咫尺，无需数英里的手写脚本。</p><p id="7c18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唉，这不是所有人都能做的事情，当有选择的时候，Kubernetes团队总是倾向于产品编排方面，而开发人员则被抛在后面。完全自动化的CI/CD仍然是一项艰巨的任务，每个开发商店仍然需要DevOps编写那些长达数英里的手写脚本。在本文中，我将尝试列举Kubernetes在开发环境中的不足之处。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="578e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.码头工人</h1><p id="660c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这应该会在每个需要处理它的人心中引起恐惧。Docker不适合在自身内部运行，Kubernetes编排Docker容器。因此，如果您的管道需要Docker来构建映像，并且您的管道在Kubernetes下运行，那么您需要在Docker内部运行Docker，这让我一想到就头疼。</p><p id="ff75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题有两个解决方案。第一种是劫持外部主机的Docker套接字。这使得你的Docker容器运行在一个兄弟容器中，而不是一个子容器中。让我解释一下。Docker分为两部分:命令行界面和Docker机器。这两者通过一个众所周知的套接字进行通信，因此当您键入一个Docker命令时，命令行程序会通过套接字向Docker机器发送一条消息，由Docker机器完成大部分工作。因此，如果您从容器内部发出Docker命令行指令，它会将消息发送到外部主机的Docker机器。这种解决方案的缺点是内部容器需要被授权访问外部主机的Docker套接字。</p><p id="cc72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种解决方案是通过另一个程序模拟Docker。有太多这样的非Docker仿真程序，如<a class="ae ky" href="https://buildah.io/" rel="noopener ugc nofollow" target="_blank"> Buildah </a>或<a class="ae ky" href="https://github.com/GoogleContainerTools/kaniko" rel="noopener ugc nofollow" target="_blank"> Kaniko </a>。但是Docker实际上处理了很多任务:构建映像、处理容器注册表和运行映像。前面提到的两个程序只处理容器注册的构建和推送。其他程序可用于更多地访问容器注册表。</p><p id="8be6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，虽然有从构建过程中消除Docker的解决方案，但没有人像Docker那样做。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="983b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.Kubernetes描述符文件是静态的</h1><p id="7d0a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Kubernetes的人有意识地决定不允许外部影响描述符文件。没有环境变量，没有命令行变量。描述符文件中的内容就是正在运行的内容。您可以使用命令行来修改已经运行的服务，以受控方式更新映像版本或其他更改，但是这些更改不会反映在原始描述符文件中。</p><p id="1c01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了使用命令行以非常可控的方式更改描述(在生产中，您可能只想以非常可控的方式更改内容)，唯一的解决方法是使用模板。当然，这首先违背了静态描述符文件的目的。</p><p id="5302" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">舵图是模板化描述符文件的主要方式。它们实际上解决了许多其他问题，比如协调众多服务之间的变化。但是也很容易被掌舵图冲昏头脑，使你的部署变得复杂混乱，这是我们试图避免的。基本上，它们是DevOps团队的工作保障。</p><p id="aac1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格遵守静态描述符文件使得在开发和生产环境中很难使用相同的描述符。因此，我们的环境开始分化，你必须花时间和精力试图重新融合。所以“它在开发中有效，所以我们知道它在生产中也会有效”的梦想破灭了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="de9c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.开发环境中的就绪性检查</h1><p id="c93f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个开发人员最终合并了他们的代码，并出去喝了几杯来庆祝。然而，回到Kubernetes，服务无法启动。所以Kubernetes顺从地重启它，服务再次失败。现在，该节点将使用其所有的CPU来重新启动一个中断的服务。当然，您可以编写一个小程序来取消部署在过去一小时内每分钟重启一次的服务，或者让您的脚本智能地部署新映像，以便退出并恢复上一个映像。但这只是增加了更多原本应该降低复杂性的脚本行。开发和生产需要不同的策略，这些差异增加了我们想要避免的分歧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dbb4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.容器内外的不一致</h1><p id="5122" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时，我们需要在本地运行一个程序，以便在提交之前测试代码。为了做到这一点，我们需要所有的外部依赖，这样程序就可以在不篡改数据库、消息队列或其他服务的情况下运行。使用在Kubernetes中运行的服务是很好的，但是当一些服务在集群内部运行时有细微的差异，或者没有合适的外部端口从集群外部访问时，就会出现问题。</p><p id="ff9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我特别想到了可以有多个实例和领导者选举的服务。当您连接到一个实例时，它会返回所选领导者的IP地址。由于集群内部的网络与外部网络是不同的子网，因此IP地址不起作用。通常，需要进行非常复杂的配置，以便从集群内部和外部获得一致的访问——即使我们知道只有一个实例在集群内部运行。这不是Kubernetes本身的问题，但它仍然是在开发环境中利用容器编排的障碍。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4311" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.图像标签被认为是不可变的</h1><p id="1f96" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Docker中，图像标签本质上是可变的。有些情况下你想改变它们，有些情况下你不想改变它们，但是你有选择权，Docker会相应地采取行动。如果你的标签是语义版本，你可能永远不想改变它。它应该总是属于同一个图像。但是如果你的标签是一个抽象的条件，比如<code class="fe mz na nb nc b">stable</code>或者<code class="fe mz na nb nc b">test</code>，当一个图像在CI/CD管道中蜿蜒前进时，你可能想把它们去掉。一旦构建了一个新的图像，您可能想要从先前的图像中移除<code class="fe mz na nb nc b">test</code>标签，并将其移动到新的图像中。一旦一个新图像通过了一系列测试，你可能想要移动<code class="fe mz na nb nc b">stable</code>标签。然后，您的CI/CD管道知道在每个阶段和/或名称空间部署哪个映像。</p><p id="985a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是Kubernetes认为标签是不可变的。如果标记为<code class="fe mz na nb nc b">stable</code>的图像已经被拖到一个节点，它将永远不会检查图像是否被改变。这似乎是Kubernetes社区的一个长期争论。然而，Kubernetes可能不会有任何变化——只有外部工具可以帮助您实现这一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c4be" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="244f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我仍然喜欢在开发环境中使用容器编排的想法，并帮助自动化CI/CD流程。使用Kubernetes来运行您正在测试的管道和服务有太多的好处。</p><p id="5b0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，对于那些认为他们可以在不妥协或不复杂的情况下实现这一点的人来说，这是一个公平的警告:开发环境中的Kubernetes并不是一些人所认为的万灵药。</p></div></div>    
</body>
</html>