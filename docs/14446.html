<html>
<head>
<title>My First Impressions of Sapling — Meta’s New Git Client</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我对Sapling的第一印象——Meta的新Git客户端</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/four-ways-you-can-experiment-with-sapling-709eec0ffcb1?source=collection_archive---------0-----------------------#2022-12-16">https://betterprogramming.pub/four-ways-you-can-experiment-with-sapling-709eec0ffcb1?source=collection_archive---------0-----------------------#2022-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b4ee" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">尝试堆叠拉取请求</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/01fb5e394f4b3b7f3bd4be5662d3b0c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qi107PvsqlO3zz12Hlu-Kw.png"/></div></div></figure><p id="466d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://sapling-scm.com/docs/introduction/" rel="noopener ugc nofollow" target="_blank"> Sapling </a>是Meta开发的新源码控制系统。最近，它获得了与GitHub合作的能力。我很好奇它是如何工作的，所以我决定尝试一下，并最终在我公司的仓库中每天使用它。如果你想尝试一下，请点击查看他们的文档。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lv"><img src="../Images/3481b800e2e702a2efce2202e4fb4769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7_KD5skTj1YhPRQT7mQ7QA.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">注册功能的堆叠PRs示例</p></figure><h1 id="8e22" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">堆叠式PRs</h1><p id="a3ba" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">开发时，我通常为每个PR创建一个单独的提交，并将它们堆叠在一起。</p><p id="c908" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，假设我们正在开发注册功能:用户输入他们的电子邮件地址和密码，然后我们给他们发送一封欢迎邮件。从后端角度来看，我们需要创建一个新用户，验证该用户不存在，然后发送电子邮件。我们需要接触缓存包的实现，添加一个电子邮件包，然后最后实现注册逻辑。这可以表示为一堆PRs:</p><ol class=""><li id="93fe" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">更新缓存包以添加新方法。</li><li id="26dd" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">添加电子邮件发送系统。它使用缓存包来防止发送重复的电子邮件。</li><li id="a870" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">实现注册逻辑。就看上面两个变化了。</li></ol><p id="2f06" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好处:这有助于评审人员分离关注点。较小的、孤立的变更更容易被审查。他们可以逐个检查PR，每个PR包含独立的逻辑。当然，邮件系统仍然需要更新缓存包，但我们仍然可以孤立地审查邮件系统。</p><p id="75e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当原点得到更新时，我们将提取变更，并在原点的基础上重新构建PRs，推送变更，进行审核，并进行合并。</p><p id="9278" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">缺点:它需要纪律来保持PRs的小型和孤立。通常，在制定上层PRs时，我们需要对下层PRs进行一些更改。这可能很烦人，因为我们必须跟踪哪些PR发生了什么变化，或者不断地在PR之间切换以进行更改，然后重新调整上面的PR。</p><pre class="kg kh ki kj gt nl nm nn bn no np bi"><span id="443c" class="nq mb iq nm b be nr ns l nt nu">git checkout mybranch/signup   # checkout sign up branch<br/>vim features/signup/signup.go  # make changes to signup<br/>vim lib/email/email.go         # make changes to email package<br/><br/>git add features/signup        # commit the signup changes        <br/>git commit --amend             <br/>git stash                      # stash the email changes<br/>git checkout mybranch/email    # checkout email branch<br/>git stash pop                  # apply the email changes<br/>git add lib/email              # commit the email changes<br/>git commit --amend<br/>git checkout mybranch/signup   # checkout sign up branch again<br/>git rebase mybranch/email      # rebase the signup branch on top of email branch</span></pre><p id="abc2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">太多的切换和太多的命令需要输入。一点都不好玩。</p><h1 id="af0f" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">输入树苗</h1><p id="d5d7" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">Sapling是一个新的git客户端。它鼓励使用堆叠公关。它会自动地将PRs一个接一个地放在一起，所以我们不需要手动操作。</p><p id="c6b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">给定下面的提交结构，通过调用<code class="fe nv nw nx nm b">sl</code>命令来表示，下面是它的样子:</p><pre class="kg kh ki kj gt nl nm nn bn no np bi"><span id="b31a" class="nq mb iq nm b be nr ns l nt nu">sl<br/>  @  00f1749f6  30 minutes ago  oliver<br/>  │  implement user signup<br/>  │<br/>  @  e0dbbc80e  50 minutes ago  oliver<br/>  │  implement email package<br/>  │<br/>  o  4f6928029  Yesterday at   oliver<br/>╭─╯  update cache package<br/>│<br/>o  876f46044  Today at 07:45  remote/main</span></pre><p id="33bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">树苗的工作流程如下:</p><pre class="kg kh ki kj gt nl nm nn bn no np bi"><span id="3003" class="nq mb iq nm b be nr ns l nt nu">sl goto 00f1749f6              # checkout the sign up code<br/>vim features/signup/signup.go  # make changes to signup<br/>vim lib/email/email.go         # make changes to email package<br/><br/>sl absorb                      # magic 👻</span></pre><p id="003f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只需一个简单的命令<code class="fe nv nw nx nm b">sl absorb</code>，sapphire就会:</p><ul class=""><li id="b4d7" class="mx my iq kt b ku kv kx ky la mz le na li nb lm ny nd ne nf bi translated">修改对电子邮件提交的<code class="fe nv nw nx nm b">email.go</code>更改。</li><li id="c5de" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm ny nd ne nf bi translated">修改<code class="fe nv nw nx nm b">signup.go</code>对注册提交的更改。</li><li id="4b0b" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm ny nd ne nf bi translated">将注册提交置于电子邮件提交之上。</li></ul><p id="b16b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您的更改将被吸收到PRs中，并且PRs将在彼此之上重新建立基础。不用像以前那样手动操作了。只有一个命令。干得好！</p><h1 id="c623" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">我对树苗的体验</h1><p id="b24a" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">我已经用了几个星期了。这是一个新工具，所以有一些问题，但整体体验很好。</p><h2 id="49a6" class="nz mb iq bd mc oa ob dn mg oc od dp mk la oe of mm le og oh mo li oi oj mq ok bi translated">常用命令</h2><p id="9d9d" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">查看存储库状态:</p><ul class=""><li id="a0cf" class="mx my iq kt b ku kv kx ky la mz le na li nb lm ny nd ne nf bi translated"><code class="fe nv nw nx nm b">sl</code>:显示提交图(或智能日志)</li><li id="1631" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm ny nd ne nf bi translated"><code class="fe nv nw nx nm b">sl status</code>:显示当前分支的状态</li></ul><p id="51a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在提交之间移动:</p><ul class=""><li id="f0ea" class="mx my iq kt b ku kv kx ky la mz le na li nb lm ny nd ne nf bi translated"><code class="fe nv nw nx nm b">sl goto &lt;commit&gt;</code>:签出提交</li><li id="3ded" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm ny nd ne nf bi translated"><code class="fe nv nw nx nm b">sl next</code>、<code class="fe nv nw nx nm b">sl prev</code>:检查下一个/上一个提交</li></ul><p id="5e2b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用提交:</p><ul class=""><li id="85f3" class="mx my iq kt b ku kv kx ky la mz le na li nb lm ny nd ne nf bi translated"><code class="fe nv nw nx nm b">sl add</code>、<code class="fe nv nw nx nm b">sl remove</code>、<code class="fe nv nw nx nm b">sl forget</code>:添加/删除/取消跟踪文件</li><li id="75f1" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm ny nd ne nf bi translated"><code class="fe nv nw nx nm b">sl commit</code>:提交更改作为新的提交</li><li id="6cc6" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm ny nd ne nf bi translated"><code class="fe nv nw nx nm b">sl metaedit</code>:编辑提交消息</li><li id="d54d" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm ny nd ne nf bi translated"><code class="fe nv nw nx nm b">sl absorb</code>:将变化吸收到PRs中，并在PRs的顶部重新设定基础</li><li id="7587" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm ny nd ne nf bi translated"><code class="fe nv nw nx nm b">sl rebase</code>:将钻杆排放系统重新置于彼此之上</li></ul><p id="29f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe nv nw nx nm b">git add</code>将所有更改添加到暂存区时，包括新文件和删除的文件，相应的命令<code class="fe nv nw nx nm b">sl add</code>将只将新文件添加到暂存区。要删除文件，我们必须使用<code class="fe nv nw nx nm b">sl remove</code>。这在提交供应商文件时会有点烦人，因为我们必须列出所有删除的文件来删除它们。我不确定是否有更好的方法，但是代码看起来是这样的:</p><pre class="kg kh ki kj gt nl nm nn bn no np bi"><span id="f09d" class="nq mb iq nm b be nr ns l nt nu">$ sl status<br/><br/>? vendor/github.com/sample/cache/v2/caching.go<br/>? vendor/github.com/sample/cache/v2/stripe.go<br/>! vendor/github.com/sample/cache/v2/deprecated.go<br/>! vendor/github.com/sample/cache/v2/formatter.go</span></pre><pre class="ol nl nm nn bn no np bi"><span id="c8d6" class="nq mb iq nm b be nr ns l nt nu">$ sl add vendor<br/><br/>A vendor/github.com/sample/cache/v2/caching.go<br/>A vendor/github.com/sample/cache/v2/stripe.go<br/>! vendor/github.com/sample/cache/v2/deprecated.go<br/>! vendor/github.com/sample/cache/v2/formatter.go</span></pre><pre class="ol nl nm nn bn no np bi"><span id="a619" class="nq mb iq nm b be nr ns l nt nu"># Have to list all deleted files to remove, is there a better way? 😞<br/>$ sl remove vendor/github.com/sample/cache/v2/deprecated.go \<br/>            vendor/github.com/sample/cache/v2/formatter.go<br/><br/>A vendor/github.com/sample/cache/v2/caching.go<br/>A vendor/github.com/sample/cache/v2/stripe.go<br/>R vendor/github.com/sample/cache/v2/deprecated.go<br/>R vendor/github.com/sample/cache/v2/formatter.go  </span></pre><p id="2939" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们不能在这里使用<code class="fe nv nw nx nm b">sl remove vendor/github.com/sample/cache/v2</code>,因为它也将很乐意删除所有新的/改变的文件。我必须列出所有删除的文件，从树苗中删除它们。</p><h2 id="c796" class="nz mb iq bd mc oa ob dn mg oc od dp mk la oe of mm le og oh mo li oi oj mq ok bi translated">将PRs推送到GitHub</h2><p id="ae05" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">Sapling提供了两种将PRs推送到GitHub的方式:<code class="fe nv nw nx nm b">sl pr</code>和<code class="fe nv nw nx nm b">sl ghstack</code>。每种都有不同的权衡。我更喜欢使用<code class="fe nv nw nx nm b">sl pr</code>命令，因为它提供了以下功能:</p><ul class=""><li id="e848" class="mx my iq kt b ku kv kx ky la mz le na li nb lm ny nd ne nf bi translated">它为每次提交创建一个PR。</li><li id="276e" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm ny nd ne nf bi translated">它按照提交的顺序将PRs推送到GitHub。</li><li id="f6ee" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm ny nd ne nf bi translated">这很容易理解，因为提交相互之间很好地堆叠在一起。</li><li id="ae3b" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm ny nd ne nf bi translated">它运行良好，可以用GitHub的UI进行查看。</li><li id="6e79" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm ny nd ne nf bi translated">如果您正在执行一个fork，它不需要对存储库的写权限。</li></ul><p id="cfe1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nv nw nx nm b">sl ghstack</code>命令创建一个更复杂的钻杆排放系统网络。很多时候，它未能推动减贫战略。再试一次，还是不行。没有可用的修复程序。不得不再次复制这些PRs，并冒着向我的公司仓库发送垃圾邮件的风险。不推荐。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/c82f2a847a0deaa724251cd7c6c12f2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U11CFhxhOEeQiCL2cQJS6w.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">使用GitHub的用户界面查看树苗PRs</p></figure><h2 id="5daf" class="nz mb iq bd mc oa ob dn mg oc od dp mk la oe of mm le og oh mo li oi oj mq ok bi translated">审查PRs</h2><p id="92aa" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">Sapling建议使用<a class="ae ln" href="https://reviewstack.dev" rel="noopener ugc nofollow" target="_blank"> reviewstack </a>进行审查。但是我发现它速度慢，响应慢，有时会给出错误的文件更改。我更喜欢用GitHub的UI。当用<code class="fe nv nw nx nm b">sl pr</code>推PRs时，它为每个PR创建一个提交。这样审查者就可以打开最近的提交并审查变更。与通常的审核流程相比，只需多点击一次。以下是如何做到这一点:</p><ul class=""><li id="217c" class="mx my iq kt b ku kv kx ky la mz le na li nb lm ny nd ne nf bi translated">转到提交选项卡。</li><li id="3bdf" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm ny nd ne nf bi translated">选择最新提交。</li><li id="3232" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm ny nd ne nf bi translated">查看并添加评论。这些评论将照常出现在PR上。</li></ul><h2 id="d757" class="nz mb iq bd mc oa ob dn mg oc od dp mk la oe of mm le og oh mo li oi oj mq ok bi translated">其他事情</h2><p id="67c9" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">它需要克隆一个新的存储库，所以您不能使用您熟悉的git命令。它不能与您现有的工具、IDE等一起工作。您必须使用<code class="fe nv nw nx nm b">sl web</code> UI来查看更改。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="b15d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">小树苗很棒。虽然有一些麻烦，并且需要一个小的学习曲线，但最终还是有回报的。堆叠、推送和审查PRs要容易得多。试试看！</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="158d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">【OliverNguyen.io/w/sapling】亦发表于<a class="ae ln" href="https://olivernguyen.io/w/sapling/" rel="noopener ugc nofollow" target="_blank"><em class="on"/></a><em class="on">。</em></p><pre class="kg kh ki kj gt nl nm nn bn no np bi"><span id="61cc" class="nq mb iq nm b be nr ns l oo nu">Want to Connect?<br/><br/>Connect with me <a class="ae ln" href="https://twitter.com/@_OliverNguyen" rel="noopener ugc nofollow" target="_blank">twitter.com/@_OliverNguyen</a>. I share information about software development, <br/>JavaScript, Go, and other interesting things I learn.</span></pre></div></div>    
</body>
</html>