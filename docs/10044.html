<html>
<head>
<title>Unit Testing SDKs on iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS上的单元测试SDK</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unit-test-static-and-singleton-frameworks-on-ios-df4e7d77a7b8?source=collection_archive---------6-----------------------#2021-11-17">https://betterprogramming.pub/unit-test-static-and-singleton-frameworks-on-ios-df4e7d77a7b8?source=collection_archive---------6-----------------------#2021-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="841d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让单一和静态框架在iOS上可测试的技巧</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9ae18414593870751577e44e0b193d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zoN0YxCnWdvMs35FaP5tNA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://unsplash.com/photos/0WzeC6JtbHU" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kw"> Unsplash </strong> </a></p></figure><p id="c34a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你还不是单元测试大师，看看我的前一篇文章中关于iOS单元测试的提示。</p><p id="33a2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在开发时，我们应该考虑如何使我们的代码可测试。对第三方框架进行单元测试可能会很困难，如果它们是静态的就更困难了，因为它们不容易被注入和模仿。本文将介绍一些可以用来避免不测试SDK的技术。</p><h1 id="a2db" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">在开始测试之前👀</h1><p id="f097" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">在我们深入探讨技巧之前，请记住始终将框架与项目模块和类隔离开来，无论是通过创建包装器、<a class="ae kv" href="https://www.raywenderlich.com/books/design-patterns-by-tutorials/v3.0/chapters/17-facade-pattern" rel="noopener ugc nofollow" target="_blank"> facade </a>、<a class="ae kv" href="https://refactoring.guru/pt-br/design-patterns/adapter" rel="noopener ugc nofollow" target="_blank"> adapters、</a>还是其他方式。我们项目的架构和用例不应该依赖于外部框架，因为它们总是在变化。因此，请记住将它们隔离在一个单独的类中，该类可以很容易地更改，而不会影响实现它的类。</p><h1 id="de7f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">静态方法</h1><p id="ae3c" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">最常见的不友好框架。</p><h2 id="d31f" class="mq lu iq bd lv mr ms dn lz mt mu dp md lg mv mw mf lk mx my mh lo mz na mj nb bi translated">问题</h2><p id="d4a5" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">我们通常会看到这样的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们用<a class="ae kv" href="https://www.incognia.com/pt/" rel="noopener ugc nofollow" target="_blank">隐姓埋名的DK </a>作为例子。</p></figure><p id="db41" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这种实现限制了我们模仿，因为我们不能简单地继承期望的类并覆盖它的静态方法，仅仅因为它们是静态的。</p><h2 id="339b" class="mq lu iq bd lv mr ms dn lz mt mu dp md lg mv mw mf lk mx my mh lo mz na mj nb bi translated">解决办法</h2><p id="687c" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">幸运的是，我们可以使用Swift的<a class="ae kv" href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html" rel="noopener ugc nofollow" target="_blank">协议</a>和<a class="ae kv" href="https://docs.swift.org/swift-book/ReferenceManual/Types.html#grammar_metatype-type" rel="noopener ugc nofollow" target="_blank">元类型</a>类型。根据苹果的文档:</p><blockquote class="ne nf ng"><p id="495b" class="kx ky nh kz b la lb jr lc ld le ju lf ni lh li lj nj ll lm ln nk lp lq lr ls ij bi translated"><em class="iq">元类型类型</em>是指任何类型的类型，包括类类型、结构类型、枚举类型和协议类型。</p></blockquote><p id="9399" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这意味着我们可以声明一个变量来引用协议的元类型。</p><ol class=""><li id="c034" class="nl nm iq kz b la lb ld le lg nn lk no lo np ls nq nr ns nt bi translated">首先，您应该创建一个包含与框架类相同的方法的协议。在我们的例子中，我们只需要实现<code class="fe nu nv nw nx b">initSdk()</code>方法。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b7e8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 2。</strong>使用<strong class="kz ir">扩展</strong>使你的框架的类符合创建的协议。应该不会出现错误，因为我们已经用相同的关键字创建了完全相同的方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="60f1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">3.现在，您应该使用Swift的元类型<em class="nh">将协议注入到您的类中。</em></p><p id="f823" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe nu nv nw nx b">Type</code>关键字和使用<code class="fe nu nv nw nx b">.self</code>的框架的类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0461" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 3.1 </strong>。另一种实现是使用具体框架的类初始化器，并使用<strong class="kz ir"> </strong> <code class="fe nu nv nw nx b">type(of:)</code> <strong class="kz ir"> </strong>来访问它的方法。该实现应该与上述技术产生相同的结果，但是以不同的方式编写。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="d304" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">4.要测试它，只需创建一个符合创建的协议的测试double。测试时应该注入这个模拟的类，而不是原来的类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><h1 id="537f" class="lt lu iq bd lv lw of ly lz ma og mc md jw oh jx mf jz oi ka mh kc oj kd mj mk bi translated">一个</h1><p id="4274" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">Singleton(反)模式的主要思想是在应用程序中只运行一个对象实例，并且存在一个全局访问点。小心使用它们，因为它们违反了单一责任原则。</p><h2 id="97a3" class="mq lu iq bd lv mr ms dn lz mt mu dp md lg mv mw mf lk mx my mh lo mz na mj nb bi translated">问题</h2><p id="87e8" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">下面的类是一个普通网络类的简单实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9ce1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这样的实现使得代码不可测试。</p><h2 id="b307" class="mq lu iq bd lv mr ms dn lz mt mu dp md lg mv mw mf lk mx my mh lo mz na mj nb bi translated">解决办法</h2><p id="73f8" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">为了使这段代码能够被测试，实现我们的网络服务的类需要<strong class="kz ir">请求一个依赖项</strong>，而不是自己定义一个，所以我们将注入一个。</p><p id="dcae" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您可以选择使用协议、继承或闭包来继续。</p><p id="96e6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">1.如果选择继承，只需使用类类型声明一个变量。如果属性是公共的，可以进行属性注入。这里，我们使用构造函数注入。记住<code class="fe nu nv nw nx b">NetworkingService</code>类不要设置为<code class="fe nu nv nw nx b">final</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e6f7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因为这些方法不是静态的，所以您可以在模拟的类中覆盖它们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2b82" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">2.如果您决定使用协议，或者您的项目要求您只创建<code class="fe nu nv nw nx b">final</code>类，那么实现应该与我们使用静态框架时非常相似。只需创建一个协议，使用与符合它的类完全相同的方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b240" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要测试它，只需创建一个符合创建的协议的spy:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="d33b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">3.如果你的类允许公共属性，用闭包测试也是一种技术。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e6e3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要测试它，只需调用<code class="fe nu nv nw nx b">requestProperty</code>属性，完成应该是用于测试目的的“假”完成。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2e48" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nh">瞧！</em></p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><h1 id="df88" class="lt lu iq bd lv lw of ly lz ma og mc md jw oh jx mf jz oi ka mh kc oj kd mj mk bi translated">结论</h1><p id="b280" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">就是这样！单元测试您的应用程序保证了代码质量，并有助于避免未来的错误。所以，永远记住:</p><ul class=""><li id="2792" class="nl nm iq kz b la lb ld le lg nn lk no lo np ls ok nr ns nt bi translated">尽可能保持框架的类与其他类的分离。框架变化很大；</li><li id="e8bf" class="nl nm iq kz b la ol ld om lg on lk oo lo op ls ok nr ns nt bi translated">DI(依赖注入)使类要求依赖，这意味着你可以注入被模仿的类，例如；</li><li id="de01" class="nl nm iq kz b la ol ld om lg on lk oo lo op ls ok nr ns nt bi translated">静态方法不能被重写；</li></ul><h1 id="910f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">参考</h1><ul class=""><li id="4645" class="nl nm iq kz b la ml ld mm lg oq lk or lo os ls ok nr ns nt bi translated"><a class="ae kv" href="https://medium.com/openclassrooms-product-design-and-engineering/injecting-and-mocking-static-frameworks-in-swift-b4fc410ab3ae" rel="noopener">注入和嘲讽静态框架</a></li></ul></div></div>    
</body>
</html>