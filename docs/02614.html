<html>
<head>
<title>Introduction to TypeScript Data Types (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript数据类型介绍(第1部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-typescript-data-types-void-null-undefined-never-and-object-types-11eb839e5381?source=collection_archive---------9-----------------------#2019-12-12">https://betterprogramming.pub/introduction-to-typescript-data-types-void-null-undefined-never-and-object-types-11eb839e5381?source=collection_archive---------9-----------------------#2019-12-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="836f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">N <code class="fe ki kj kk kl b">ull</code>，v <code class="fe ki kj kk kl b">oid</code>，u <code class="fe ki kj kk kl b">ndefined</code>，n <code class="fe ki kj kk kl b">ever</code>，o <code class="fe ki kj kk kl b">bject</code>类型</h2></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/7be1cf99291c9a1ead9bb3f9da79d218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJcVGzmj7r8ZM6XVFfdtLA.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">由<a class="ae lc" href="https://unsplash.com/@campaign_creators?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">活动创建者</a>在<a class="ae lc" href="https://unsplash.com/s/photos/data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7c67" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">JavaScript和其他编程语言一样，有自己的数据结构和类型。</p><p id="152a" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">JavaScript有一些我们必须知道的数据类型，以便用它来构建程序。不同的数据可以放在一起构建更复杂的数据结构。</p><p id="9d12" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">JavaScript是一种松散类型或动态类型的语言。这意味着用一种类型声明的变量可以转换成另一种类型，而不用显式地将数据转换成另一种类型。</p><p id="8d6e" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">变量也可以在任何时候包含任何类型，这取决于赋值的内容。在动态类型语言中，如果不记录就很难确定变量的类型，我们可能会在变量中分配我们不想要的数据。</p><p id="7890" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">TypeScript纠正了这些问题，让我们为变量设置固定的类型，这样我们就可以确定类型。在本文中，我们将看看<code class="fe ki kj kk kl b">void</code>、<code class="fe ki kj kk kl b">null</code>、<code class="fe ki kj kk kl b">undefined</code>、<code class="fe ki kj kk kl b">never</code>和<code class="fe ki kj kk kl b">object</code>类型。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4ecd" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">空的</h1><p id="dd8f" class="pw-post-body-paragraph ld le it lf b lg my ju li lj mz jx ll lm na lo lp lq nb ls lt lu nc lw lx ly im bi translated"><code class="fe ki kj kk kl b">void</code>型与<code class="fe ki kj kk kl b">any</code>型正好相反。它意味着任何类型的缺失。因此，如果在运行TypeScrip编译器时没有指定<code class="fe ki kj kk kl b">--strictNullChecks</code>设置，或者可以将其设置为<code class="fe ki kj kk kl b">undefined</code>，则<code class="fe ki kj kk kl b">void</code>类型的变量只能有值<code class="fe ki kj kk kl b">null</code>。</p><p id="b4b1" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，直接给一个<code class="fe ki kj kk kl b">void</code>变量赋值不是很有用。它更多地用于指定函数的返回数据类型。具有<code class="fe ki kj kk kl b">void</code>返回类型的函数不返回任何东西。</p><p id="9d50" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">例如，我们可以对一个<code class="fe ki kj kk kl b">void</code>变量进行无用的赋值，如下面的代码所示:</p><pre class="kn ko kp kq gt nd kl ne nf aw ng bi"><span id="3bdf" class="nh mh it kl b gy ni nj l nk nl">let useless: void = undefined;</span></pre><p id="5f36" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以通过编写以下内容将箭头函数的返回类型设置为<code class="fe ki kj kk kl b">void</code>:</p><pre class="kn ko kp kq gt nd kl ne nf aw ng bi"><span id="e7fc" class="nh mh it kl b gy ni nj l nk nl">const voidFn = (): void =&gt; {<br/>  console.log("Void function returns nothing");<br/>}</span><span id="6861" class="nh mh it kl b gy nm nj l nk nl">voidFn();</span></pre><p id="0568" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">或者，我们可以将传统函数的返回类型设置为<code class="fe ki kj kk kl b">void</code>，如以下代码所示:</p><pre class="kn ko kp kq gt nd kl ne nf aw ng bi"><span id="1ec4" class="nh mh it kl b gy ni nj l nk nl">function voidFn(): void {<br/>  console.log("Void function returns nothing");<br/>}</span><span id="0c3a" class="nh mh it kl b gy nm nj l nk nl">voidFn();</span></pre><p id="580d" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">两个函数调用都将从函数内部的<code class="fe ki kj kk kl b">console.log</code>语句中输出<code class="fe ki kj kk kl b">Void function returns nothing</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="dcc6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">空</h1><p id="a853" class="pw-post-body-paragraph ld le it lf b lg my ju li lj mz jx ll lm na lo lp lq nb ls lt lu nc lw lx ly im bi translated"><code class="fe ki kj kk kl b">null</code>类型代表一个只能取值<code class="fe ki kj kk kl b">null</code>的变量。<code class="fe ki kj kk kl b">null</code>意味着变量没有值。</p><p id="6bce" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">所以，再一次，给它赋值是没有用的。我们只能将<code class="fe ki kj kk kl b">null</code>赋给一个有变量<code class="fe ki kj kk kl b">null</code>的变量。运行TypeScript编译器时设置了<code class="fe ki kj kk kl b">--strictNullChecks</code>标志，<code class="fe ki kj kk kl b">null</code>只能赋给类型为<code class="fe ki kj kk kl b">any</code>和<code class="fe ki kj kk kl b">null</code>的变量。</p><p id="f44b" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">它变得有用的地方是，我们可以用联合类型将多个变量的值赋给它。</p><p id="6d52" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后，我们可以指定一些有用的东西和<code class="fe ki kj kk kl b">null</code>类型。这与JavaScript不同，因为历史原因，值<code class="fe ki kj kk kl b">null</code>是类型<code class="fe ki kj kk kl b">object</code>而不是<code class="fe ki kj kk kl b">null</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6003" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">不明确的</h1><p id="47fb" class="pw-post-body-paragraph ld le it lf b lg my ju li lj mz jx ll lm na lo lp lq nb ls lt lu nc lw lx ly im bi translated"><code class="fe ki kj kk kl b">undefined</code>类型代表一个只能取值<code class="fe ki kj kk kl b">undefined</code>的变量。所以，再一次，给它赋值是没有用的。</p><p id="cf26" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们只能将<code class="fe ki kj kk kl b">undefined</code>赋值给一个包含变量<code class="fe ki kj kk kl b">null</code>的变量。<code class="fe ki kj kk kl b">undefined</code>只能赋给<code class="fe ki kj kk kl b">any</code>类型和<code class="fe ki kj kk kl b">undefined</code>类型的变量。</p><p id="3468" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">它变得有用的地方是，我们可以用联合类型将多个变量的值赋给它。</p><p id="7dbb" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后，我们可以指定一些有用的东西和<code class="fe ki kj kk kl b">undefined</code>类型。它本身实际上是没有用的，所以我们不应该看到很多只有<code class="fe ki kj kk kl b">undefined</code>类型变量的情况。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e7ad" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">从不</h1><p id="da50" class="pw-post-body-paragraph ld le it lf b lg my ju li lj mz jx ll lm na lo lp lq nb ls lt lu nc lw lx ly im bi translated"><code class="fe ki kj kk kl b">never</code>类型是一种表示从未发生的事情的值类型。它就像<code class="fe ki kj kk kl b">void</code>一样，对于指定一个函数永远不返回任何东西是很有用的。</p><p id="5101" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe ki kj kk kl b">never</code>类型是每个类型的子类型，并且可以分配给每个类型。然而，除了其他<code class="fe ki kj kk kl b">never</code>变量之外，没有类型是<code class="fe ki kj kk kl b">never</code>类型的子类型或可分配给<code class="fe ki kj kk kl b">never</code>类型。</p><p id="e0dd" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">具有<code class="fe ki kj kk kl b">never</code>返回类型的函数必须总是有一个不可到达的端点。例如，我们可以编写一个函数，它有一个无限循环，返回类型为<code class="fe ki kj kk kl b">never</code>，如下面的代码所示:</p><pre class="kn ko kp kq gt nd kl ne nf aw ng bi"><span id="a992" class="nh mh it kl b gy ni nj l nk nl">function infiniteFn(): never {<br/>  while (true) {<br/>  }<br/>}</span></pre><p id="fb37" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">抛出异常的函数也可能具有<code class="fe ki kj kk kl b">never</code>返回类型，如下例所示:</p><pre class="kn ko kp kq gt nd kl ne nf aw ng bi"><span id="74a6" class="nh mh it kl b gy ni nj l nk nl">function errorFn(message: string): never {<br/>  throw new Error(message);<br/>}</span><span id="9e86" class="nh mh it kl b gy nm nj l nk nl">errorFn('Error occurred');</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="00ff" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">目标</h1><p id="9380" class="pw-post-body-paragraph ld le it lf b lg my ju li lj mz jx ll lm na lo lp lq nb ls lt lu nc lw lx ly im bi translated"><code class="fe ki kj kk kl b">object</code>类型是表示非原始对象的类型。也就是说，任何不是<code class="fe ki kj kk kl b">number</code>、<code class="fe ki kj kk kl b">string</code>、<code class="fe ki kj kk kl b">boolean</code>、<code class="fe ki kj kk kl b">bigint</code>、<code class="fe ki kj kk kl b">symbol</code>、<code class="fe ki kj kk kl b">null</code>或<code class="fe ki kj kk kl b">undefined</code>的东西。</p><p id="74cd" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">它主要用在标准库中的<code class="fe ki kj kk kl b">Object</code>对象的类型定义中，以及其他不希望将原始值赋给它或传递给函数的代码中。</p><p id="e6b7" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">例如，在<code class="fe ki kj kk kl b">Object.create</code>方法的类型定义中，我们看到参数的类型被设置为<code class="fe ki kj kk kl b">object</code>，如下面的代码所示:</p><pre class="kn ko kp kq gt nd kl ne nf aw ng bi"><span id="443e" class="nh mh it kl b gy ni nj l nk nl">create(o: object | null): any;</span></pre><p id="3654" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">同样，在同一个类型声明中的<code class="fe ki kj kk kl b">setPrototypeOf</code>方法的签名中，我们看到<code class="fe ki kj kk kl b">proto</code>参数，即接受对象原型的参数，也设置了<code class="fe ki kj kk kl b">object</code>类型，如下所示:</p><pre class="kn ko kp kq gt nd kl ne nf aw ng bi"><span id="4063" class="nh mh it kl b gy ni nj l nk nl">setPrototypeOf(o: any, proto: object | null): any;</span></pre><p id="8e4f" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这样，我们就不能在TypeScript中将原始值作为参数传入这些方法。如果我们这样做，那么我们会得到一个错误。因此，如果我们的TypeScript文件中有以下代码，那么它们将被编译并运行:</p><pre class="kn ko kp kq gt nd kl ne nf aw ng bi"><span id="8ab7" class="nh mh it kl b gy ni nj l nk nl">const obj1 = Object.create({});    <br/>const obj2 = Object.create(null);<br/>console.log(obj1);<br/>console.log(obj2);</span></pre><p id="4629" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们将在两个<code class="fe ki kj kk kl b">console.log</code>语句中得到一个空对象。</p><p id="1dda" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">唯一的区别是<code class="fe ki kj kk kl b">obj2</code>是一个纯对象，这意味着它不从任何原型继承。将原始值传递给下面代码中的<code class="fe ki kj kk kl b">create</code>方法会导致编译失败:</p><pre class="kn ko kp kq gt nd kl ne nf aw ng bi"><span id="7882" class="nh mh it kl b gy ni nj l nk nl">Object.create(42); <br/>Object.create("abc"); <br/>Object.create(false);<br/>Object.create(undefined)</span></pre><p id="cd21" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">上面的代码会给我们第一个错误一个<code class="fe ki kj kk kl b">Argument of type ‘42’ is not assignable to parameter of type ‘object | null’</code>，给第二个错误一个<code class="fe ki kj kk kl b">Argument of type ‘abc’ is not assignable to parameter of type ‘object | null’</code>。</p><p id="2368" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">第三行将带给我们<code class="fe ki kj kk kl b">Argument of type ‘false’ is not assignable to parameter of type ‘object | null’</code>，最后一行将带给我们<code class="fe ki kj kk kl b">Argument of type ‘undefined’ is not assignable to parameter of type ‘object | null’</code>。</p><p id="7794" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">编译会失败，代码不会运行。</p><p id="398f" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">此外，我们可以使用它来防止原始值被分配给它。例如，如果我们写:</p><pre class="kn ko kp kq gt nd kl ne nf aw ng bi"><span id="1d10" class="nh mh it kl b gy ni nj l nk nl">let x: object = {};</span></pre><p id="42cf" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后，上面的代码将被编译并运行。但是，如果我们改为编写以下代码:</p><pre class="kn ko kp kq gt nd kl ne nf aw ng bi"><span id="1541" class="nh mh it kl b gy ni nj l nk nl">let x: object = 1;</span></pre><p id="77b6" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后我们得到<code class="fe ki kj kk kl b">Type ‘1’ is not assignable to type ‘object’</code>，代码不能用TypeScript编译器编译和运行，因为<code class="fe ki kj kk kl b">1</code>是一个原始值。</p><p id="a89a" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe ki kj kk kl b">void</code>型与<code class="fe ki kj kk kl b">any</code>型正好相反。它意味着任何类型的缺失。因此，如果在运行TypeScrip编译器时没有指定<code class="fe ki kj kk kl b">--strictNullChecks</code>设置，或者设置为<code class="fe ki kj kk kl b">undefined</code>，那么<code class="fe ki kj kk kl b">void</code>类型的变量只能有值<code class="fe ki kj kk kl b">null</code>。</p><p id="a8da" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这对于声明不返回任何内容的函数非常有用。<code class="fe ki kj kk kl b">null</code>类型变量只能取<code class="fe ki kj kk kl b">null</code>值。只能给<code class="fe ki kj kk kl b">undefined</code>类型赋值<code class="fe ki kj kk kl b">undefined</code>。</p><p id="5801" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe ki kj kk kl b">object</code>类型是一种表示非基本对象的类型。即不是<code class="fe ki kj kk kl b">number</code>、<code class="fe ki kj kk kl b">string</code>、<code class="fe ki kj kk kl b">boolean</code>、<code class="fe ki kj kk kl b">bigint</code>、<code class="fe ki kj kk kl b">symbol</code>、<code class="fe ki kj kk kl b">null</code>或<code class="fe ki kj kk kl b">undefined</code>的任何东西。</p><p id="fb3c" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">它主要用于标准库中的<code class="fe ki kj kk kl b">Object</code>对象的类型定义，以及其他不希望原始值被赋给它或传递给函数的代码。</p></div></div>    
</body>
</html>