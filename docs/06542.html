<html>
<head>
<title>Modern-Day Architecture Design Patterns for Software Professionals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向软件专业人员的现代架构设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modern-day-architecture-design-patterns-for-software-professionals-9056ee1ed977?source=collection_archive---------0-----------------------#2020-10-12">https://betterprogramming.pub/modern-day-architecture-design-patterns-for-software-professionals-9056ee1ed977?source=collection_archive---------0-----------------------#2020-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3fa9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">断路器、CQRS、事件源、边车、后端对前端和扼杀者</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e9e78ca43effb6952b5946608a7933c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3x1RQg6nwhA8093B-40FXA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源—<a class="ae ky" href="https://undraw.co/" rel="noopener ugc nofollow" target="_blank">https://undraw.co/</a></p></figure><p id="65d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多现代应用程序需要在企业规模上构建，有时甚至需要在互联网规模上构建。每个应用程序都需要满足可伸缩性、可用性、安全性、可靠性和弹性需求。</p><p id="d0b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将谈论一些可以帮助您轻松实现上述能力的设计模式。我将讨论每个模式，如何在云原生环境中使用该模式，以及何时使用，何时不使用。</p><p id="b50d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中一些模式并不新鲜，但在当前互联网规模的云世界中非常有用。</p><p id="ccf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我将在本文中讨论的模式列表:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9408" class="ma mb it lw b gy mc md l me mf">1. <a class="ae ky" href="#4c75" rel="noopener ugc nofollow">Circuit Breaker</a><br/>2. <a class="ae ky" href="#ea92" rel="noopener ugc nofollow">Command and Query Responsibility Segregation (CQRS)</a><br/>3. <a class="ae ky" href="#47f9" rel="noopener ugc nofollow">Event Sourcing</a><br/>4. <a class="ae ky" href="#4c49" rel="noopener ugc nofollow">Sidecar</a><br/>5. <a class="ae ky" href="#f4c8" rel="noopener ugc nofollow">Backend-for-Frontend</a><br/>6. <a class="ae ky" href="#c9d5" rel="noopener ugc nofollow">Strangler</a></span></pre><p id="d38b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们开始吧。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="4c75" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">断路器</h1><p id="df33" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">分布式系统的设计应该考虑到故障。如今，世界已经采用了微服务，这些服务大多依赖于其他远程服务。由于网络、应用程序负载等各种原因，这些远程服务可能无法及时响应。在大多数情况下，实施重试应该能够解决问题。</p><p id="1b3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但有时可能会出现一些重大问题，如服务质量下降或服务完全失败。在这种情况下继续重试是没有意义的。这就是断路器模式有用的地方。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/d0383c8e883db4fa216d70e4165ad50b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ObdN8WZTCUmsQDUtjHcjpQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">断路器。图片由作者提供。</p></figure><p id="cc20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图展示了断路器模式的实现，其中当服务1知道调用服务2时存在连续故障/超时，服务1不会重试，而是将调用发送到服务2并返回回退响应。</p><p id="1f4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一些流行的开源库，如<a class="ae ky" href="https://github.com/Netflix/Hystrix/wiki/How-it-Works" rel="noopener ugc nofollow" target="_blank">网飞的Hystrix </a>或<a class="ae ky" href="https://github.com/resilience4j/resilience4j" rel="noopener ugc nofollow" target="_blank"> Reselience4J </a>，可以用来非常容易地实现这种模式。</p><p id="d08d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你使用API网关或者像<a class="ae ky" href="https://medium.com/better-programming/using-envoy-proxy-to-improve-reliability-security-and-observability-of-microservices-85032e08d3f4" rel="noopener"> Envoy </a>这样的<a class="ae ky" href="https://medium.com/better-programming/using-envoy-proxy-to-improve-reliability-security-and-observability-of-microservices-85032e08d3f4" rel="noopener"> sidecar </a>代理，那么这可以在代理级别上实现。</p><p id="91cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>当电路断开时，有足够的日志记录和警报，以便跟踪在此期间收到的请求，并且操作团队意识到这一点，这一点非常重要。</p><p id="f70d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以在半电路断开的情况下实现断路器，以继续为服务质量下降的客户端提供服务。</p><h2 id="c666" class="ma mb it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">何时使用这种模式</h2><ul class=""><li id="0078" class="nv nw it lb b lc ne lf nf li nx lm ny lq nz lu oa ob oc od bi translated">当一个服务依赖于另一个远程服务时，在某些情况下可能会失败</li><li id="f3ee" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">当服务具有非常高的依赖性时(例如，主数据服务)</li></ul><h2 id="972f" class="ma mb it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">何时不使用这种模式</h2><ul class=""><li id="a57b" class="nv nw it lb b lc ne lf nf li nx lm ny lq nz lu oa ob oc od bi translated">当您处理本地依赖时，断路器可能会产生开销</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="ea92" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">指挥和查询责任分离(CQRS)</h1><p id="6b5f" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">对于涉及使用数据存储的现代应用程序来说，CQRS是一种非常有用的模式。它基于在数据存储中分离读取(查询)和写入/更新(命令)操作的原则。</p><p id="2d65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您正在构建一个应用程序，要求您将数据存储在MySQL/PostgreSQL等数据库中。众所周知，将数据写入数据存储时，操作需要采取几个步骤，如验证、建模和持久化，因此典型的写/更新操作比简单的读操作花费的时间更长。</p><p id="ad05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您使用单个数据存储同时大规模执行读写操作时，您可能会开始看到性能问题。</p><p id="ed82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，CQRS模式会很有用。CQRS模式建议对读写操作使用不同的数据模型。一些变体还建议为这些模型使用单独的数据存储。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/25afa4e1e777e4f158166dcd811f0244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Ko_R4er9q8S4C-utEUVkQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">CQRS。图片由作者提供。</p></figure><p id="e1a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>如今大多数PaaS数据库都提供了创建<em class="ok">读取副本</em><strong class="lb iu">T5】(<a class="ae ky" href="https://cloud.google.com/sql/docs/mysql/replication/create-replica" rel="noopener ugc nofollow" target="_blank">谷歌云SQL </a>、<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/azure-sql/database/read-scale-out" rel="noopener ugc nofollow" target="_blank"> Azure SQL DB </a>、<a class="ae ky" href="https://aws.amazon.com/rds/features/read-replicas/" rel="noopener ugc nofollow" target="_blank">亚马逊RDS </a>等功能。)的数据存储，这有助于更轻松地实现数据复制。</strong></p><p id="2a4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在处理本地数据库，许多企业数据库也提供这种功能。</p><p id="ef6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>现在有些人也喜欢将读取副本实现为快速和高性能的NoSQL数据库，比如MongoDB和Elasticsearch。</p><h2 id="4d6c" class="ma mb it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">何时使用这种模式</h2><ul class=""><li id="09f9" class="nv nw it lb b lc ne lf nf li nx lm ny lq nz lu oa ob oc od bi translated">当您考虑扩展一个预期有大量读写操作的应用程序时</li><li id="9836" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">当您想要分别调整读取和写入操作的性能时</li><li id="8360" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">当您的读取操作接近实时或最终一致时</li></ul><h2 id="cc4a" class="ma mb it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">何时不使用这种模式</h2><ul class=""><li id="9866" class="nv nw it lb b lc ne lf nf li nx lm ny lq nz lu oa ob oc od bi translated">当您构建一个普通的CRUD应用程序时，并不期望一次进行大量的读写操作</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="47f9" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">活动采购</h1><p id="c80f" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">事件源是一种有趣的设计模式，其中一系列领域事件被存储为日志，日志的聚合视图给出了应用程序的当前状态。</p><p id="52fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种模式通常用于负担不起数据存储锁的系统，以及需要维护审计和事件历史的系统，例如，像酒店/会议/座位预订这样的应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/caa7dab52b815a8ad5211494c3d42820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D4kfUFDr7xnNbqXJwqyF0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">活动采购。图片由作者提供。</p></figure><p id="673c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑一个酒店房间预订系统，其中用户被期望预订或取消预订。在这里，您需要将预订和取消存储为一系列事件。每次预订前，通过查看活动日志，汇总视图会显示可用房间。</p><p id="7de3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:大多数云服务提供商支持消息服务，如Google Pub/Sub、Azure Service Bus、AWS SQS等。这些服务与强大一致的数据存储相结合，可以用来实现这种模式。</p><h2 id="e559" class="ma mb it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">何时使用这种模式</h2><ul class=""><li id="6632" class="nv nw it lb b lc ne lf nf li nx lm ny lq nz lu oa ob oc od bi translated">当常规的CRUD操作不足以满足需求时</li><li id="2376" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">通常适用于座位预订系统，如公共汽车、火车、会议、电影院等。—或者由购物车操作、支付等事件组成的电子商务系统。</li><li id="2d6d" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">当需要强大的审核和事件重放来创建应用程序的当前和过去状态时</li></ul><h2 id="66f2" class="ma mb it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">何时不使用这种模式</h2><ul class=""><li id="e242" class="nv nw it lb b lc ne lf nf li nx lm ny lq nz lu oa ob oc od bi translated">当常规CRUD操作足以满足用户需求时。</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="4c49" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">边车</h1><p id="46aa" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/better-programming/using-envoy-proxy-to-improve-reliability-security-and-observability-of-microservices-85032e08d3f4" rel="noopener">边车模式</a>随着微服务的兴起而流行起来。在这种模式中，您将应用程序的组件部署到单独的流程或容器中。这有助于实现抽象和封装。</p><p id="d8f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">特使代理</a>是最流行的边车代理之一，使用广泛。它帮助您将应用程序的核心功能分开，使用sidecar来隔离常见的功能，如联网、可观察性和安全性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/a654e03cce3a5948f20f4a9d05dc603b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iw7Ctnfyw8iWxF1ehYGKHQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">边车。图片由作者提供。</p></figure><p id="3f2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种类型边车可以帮助抽象L4/L7类型的通信。像Envoy Proxies这样的Sidecars甚至通过实现相互TLS来帮助实现更高的安全性。</p><p id="eeaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将其与服务网格结合使用，以在各种微服务之间实现更好的通信和安全性。你可以在我的<a class="ae ky" href="https://medium.com/better-programming/the-roles-of-service-mesh-and-api-gateways-in-microservice-architecture-f6e7dfd61043" rel="noopener">上一篇文章</a>中了解更多。</p><h2 id="9882" class="ma mb it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">何时使用这种模式</h2><ul class=""><li id="762b" class="nv nw it lb b lc ne lf nf li nx lm ny lq nz lu oa ob oc od bi translated">当您处理产品范围内的多种异构微服务时</li><li id="5258" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">当您处理通常无法应对新时代通信和安全挑战的遗留应用程序时</li></ul><h2 id="3b5d" class="ma mb it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">何时不使用这种模式</h2><ul class=""><li id="5908" class="nv nw it lb b lc ne lf nf li nx lm ny lq nz lu oa ob oc od bi translated">当您处理需要相互通信的有限数量的服务时</li><li id="9b36" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">边车部署可能不经济或不利于操作的小型应用</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="f4c8" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">后端对前端(BFF)</h1><p id="6085" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在典型的产品开发周期中，后端工程师负责创建与数据存储交互的服务，前端工程师负责构建用户界面。如今，构建应用程序时需要考虑移动和桌面的使用。</p><p id="0731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管移动设备和桌面设备在硬件方面的差距越来越小，但移动设备的连接和使用仍然具有挑战性。</p><p id="ca06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，BFF模式变得非常方便。在这里，您应该为特定的前端构建/定制后端服务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/157858c4969df3d43b5c10443437c0fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2wpzHZhpEQqAqsDV3TecOQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">后端对前端。图片由作者提供。</p></figure><p id="361d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了优化移动客户端的性能，您可能希望构建一个单独的后端服务，以轻量级和分页的响应进行响应。</p><p id="707d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能还想使用这种模式来聚合各种服务，以减少闲聊式的交流。</p><p id="ff44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>现在，如果您使用API网关，BFF模式可以很容易地在网关中实现，并且您不需要维护单独的服务。</p><h2 id="0e62" class="ma mb it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">何时使用这种模式</h2><ul class=""><li id="eb53" class="nv nw it lb b lc ne lf nf li nx lm ny lq nz lu oa ob oc od bi translated">当您想要为不同的客户端(如桌面和移动客户端)提供产品/服务时</li><li id="e5e8" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">当您想要为特定类型的客户端优化响应时</li><li id="2878" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">当您希望减少移动客户端和各种服务之间的闲聊式通信时</li></ul><h2 id="cc57" class="ma mb it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">何时不使用这种模式</h2><ul class=""><li id="eb6b" class="nv nw it lb b lc ne lf nf li nx lm ny lq nz lu oa ob oc od bi translated">当应用程序用户预期使用单一用户界面时</li><li id="7268" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">当移动和桌面应用程序被期望展示相似的信息和提供相似的功能时</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="c9d5" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">扼杀者</h1><p id="0263" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">如果您在一个正在进行应用程序现代化的组织中工作，那么Strangler设计模式是必须的。Strangler设计模式提倡在您的遗产和新应用程序之上创建一个门面，为消费者提供一个抽象的视图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/1b9df52444703a5f084e1cf73ab1c325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKIMnWbVjSIBNOaFzC6kJg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扼杀者。图片由作者提供。</p></figure><p id="b8a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种模式将消费者与迁移活动分离开来。</p><p id="7f8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>在一个典型的IT组织中，如果你从一个ERP迁移到另一个，这种类型的模式非常有用。如果您正在使用API网关，那么在网关代理本身中实现它会变得更加容易。</p><p id="c795" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要决定是在迁移结束时保留外观还是删除它。</p><h2 id="4efc" class="ma mb it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">何时使用这种模式</h2><ul class=""><li id="a59f" class="nv nw it lb b lc ne lf nf li nx lm ny lq nz lu oa ob oc od bi translated">当您迁移或现代化复杂、高度依赖的应用程序(如ERP迁移)时</li></ul><h2 id="f84a" class="ma mb it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">何时不使用这种模式</h2><ul class=""><li id="9d95" class="nv nw it lb b lc ne lf nf li nx lm ny lq nz lu oa ob oc od bi translated">当迁移很简单并且直接替换是更好的选择时</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b69b" class="ma mb it lw b gy mc md l me mf">Hey, if you enjoyed this story, check out <a class="ae ky" href="https://deshpandetanmay.medium.com/membership" rel="noopener">Medium Membership</a>! Just $5/month!<em class="ok">Your membership fee directly supports me and other writers you read. You’ll also get full access to every story on Medium.</em></span></pre><div class="op oq gp gr or os"><a href="https://deshpandetanmay.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">每当Tanmay Deshpande发表文章时，都收到一封电子邮件。</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">每当Tanmay Deshpande发表文章时，都收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">deshpandetanmay.medium.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div></div></div>    
</body>
</html>