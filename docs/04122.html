<html>
<head>
<title>Let’s Talk About React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们谈谈反应</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/so-lets-talk-about-react-f91ea95152ad?source=collection_archive---------19-----------------------#2020-03-24">https://betterprogramming.pub/so-lets-talk-about-react-f91ea95152ad?source=collection_archive---------19-----------------------#2020-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bf8f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">涵盖React历史、语法等内容的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7c186569bec5a4fed2140131692ee625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRNlIrEgDCtBRjknh6W5sg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Giammarco Boscaro 在<a class="ae ky" href="https://unsplash.com/s/photos/history?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我从17岁开始做前端开发，但是我对<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>一无所知，直到我做了一些研究。现在，我实际上是一名经验丰富的React开发人员，将谈谈我使用React.js的经历。</p><p id="57c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今，React <strong class="lb iu"> </strong>是最重要的JavaScript库之一，我们知道有很多JavaScript库和一个巨大的社区一直在改进JavaScript特性。像jQuery一样，React在如何创建UI方面带来了惊人的变化，让我们可以更快地构建应用程序。</p><blockquote class="lv lw lx"><p id="338e" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">"在困难和障碍消失之前，耐心和毅力有一种神奇的效果."—约翰·昆西·亚当斯</p></blockquote><h2 id="b7ae" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">目录</h2><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="a7c5" class="mc md it mw b gy na nb l nc nd">1. <a class="ae ky" href="https://medium.com/p/f91ea95152ad#0b80" rel="noopener">Understanding React's history</a><br/>2. <a class="ae ky" href="https://medium.com/p/f91ea95152ad#846b" rel="noopener">Some JavaScript concepts useful in React</a><br/>3. <a class="ae ky" href="https://medium.com/p/f91ea95152ad#58fa" rel="noopener">React essentials</a><br/>4. <a class="ae ky" href="https://medium.com/p/f91ea95152ad#fea0" rel="noopener">Lifecycles in React</a><br/>5. <a class="ae ky" href="https://medium.com/p/f91ea95152ad#c05f" rel="noopener">Passing data to child components</a></span></pre></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="0b80" class="nl md it bd me nm nn no mh np nq nr mk jz ns ka mn kc nt kd mq kf nu kg mt nv bi translated">了解React的历史</h1><p id="bc53" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">由<a class="ae ky" href="https://twitter.com/jordwalke?lang=es" rel="noopener ugc nofollow" target="_blank">Jordan walker</a>创建并于2013年正式发布的React <strong class="lb iu"> </strong>已经<strong class="lb iu"> </strong>成为JavaScript中最重要的UI库之一。它被脸书、Instagram、网飞、Spotify、Medium和Twitter使用。React改变了我们构建UI界面的方式。</p><p id="0cc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像其他库一样，React使用模型-数据-控制器<a class="ae ky" href="https://www.youtube.com/watch?v=DUg2SWWK18I" rel="noopener ugc nofollow" target="_blank"> (MVC </a>)设计模式。这个后面会解释。</p><p id="eba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在了解前端开发的历史中，我们可以找到一个很好的答案，即为什么要创建React。我们都开始使用jQuery，这使得创建UI界面变得更加容易和快速。但是随着时间的推移，需求越来越大，仅仅使用像jQuery这样的技术很难满足需求。</p><p id="72e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在脸书内部，一些好的东西开始在沃克的脑海中酝酿——他有一个惊人的想法来创造一些可以使前端构建更容易和更快的东西。</p><p id="ab6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React混合了JavaScript、CSS和HTML，成为了一场革命，改变了我们构建前端的方式。最终，JSX诞生了——让阅读React代码变得更加容易。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="846b" class="nl md it bd me nm nn no mh np nq nr mk jz ns ka mn kc nt kd mq kf nu kg mt nv bi translated">React中一些有用的JavaScript概念</h1><p id="56cc" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">我记得当我15岁开始学习编程的时候。</p><p id="3f8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解JavaScript的基础知识可以帮助你快速理解一个新的框架或库，所以这些是你需要了解的关于JavaScript的一些主题:</p><ul class=""><li id="c0f6" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">同步和异步</li><li id="6272" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe op oq or mw b">this</code> <strong class="lb iu"> </strong>关键字</li><li id="2746" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">三元运算符</li><li id="af74" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">解构</li></ul><h2 id="30c9" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">同步和异步</h2><p id="1b9a" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">我们在React中一直使用的最重要的概念之一是异步性。一个很好的例子是<code class="fe op oq or mw b">setState</code>、<strong class="lb iu">、</strong>，它们使用回调<strong class="lb iu">、</strong>来显示更新后的状态值。</p><p id="23b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们看看React的内部，我们会发现<strong class="lb iu"> nodejs </strong>。这说明了很多关于React的事情，因为最广为人知的概念是异步性。</p><p id="5440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异步<strong class="lb iu"> </strong>有助于加载所有必要的数据——不管它有多大——因为我们可以同时加载大量不同的数据<strong class="lb iu"/>,不管每个任务的进度如何。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/c05e4ef01ed60cecad99edc4ddd48c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ERjH2loOK4_tCMZGJJ1bBA.png"/></div></div></figure><p id="69f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">同步</strong></p><p id="27e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单线程进程包含以单个序列执行指令。换句话说，一次处理一个命令。</p><p id="acc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">异步</strong></p><p id="0d4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不同步；也就是说，不是以预定的或规则的时间间隔发生的。术语异步通常用于描述数据可以间歇传输而不是稳定传输的通信。</p><h2 id="2eba" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><a class="ae ky" href="https://medium.com/better-programming/understanding-the-this-keyword-in-javascript-cb76d4c7c5e8" rel="noopener">对'<strong class="ak">这个'</strong>关键字</a>的解释</h2><p id="ce32" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">JavaScript <code class="fe op oq or mw b">this</code>关键字引用了它所属的对象。所以用这个关键字，你可以引用一个类的当前属性，因为它引用了当前的对象实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="c54d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如您所见，我们引用了实际的<code class="fe op oq or mw b">Hero</code> <strong class="lb iu"> </strong>类，获取了该类的实际属性，因为这个关键字引用了实际的实例。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="1609" class="mc md it mw b gy na nb l nc nd">HeroIns.greet() will return an object like this:</span><span id="dbf4" class="mc md it mw b gy ov nb l nc nd"><strong class="mw iu">Hero </strong>{<br/>   <strong class="mw iu">name</strong>: "Arthur Akward",<br/>   <strong class="mw iu">level</strong>: 100<br/> }</span></pre><h2 id="e9a6" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" rel="noopener ugc nofollow" target="_blank">三元运算符</a></h2><p id="50ea" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">对于三元运算符，我们可以使用三种不同的运算符:(1)条件运算符后跟一个<code class="fe op oq or mw b">?</code>；(2)然后，如果条件是<code class="fe op oq or mw b">true</code>，我们将执行一个代码，后面跟一个<code class="fe op oq or mw b">:</code>；(3)最后，如果条件是<code class="fe op oq or mw b">false</code>，我们将得到要执行的表达式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="e49c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您可以创建一个条件链，帮助您评估多个条件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><h2 id="d79b" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><a class="ae ky" href="https://medium.com/javascript-in-plain-english/the-elegance-of-react-1aa393a7d0f4" rel="noopener">解构</a></h2><p id="e7e5" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">在ES6中，我们有析构，这允许我们有一个短代码。如果你不知道析构是如何工作的，我们需要首先使用Mozilla  <strong class="lb iu"> <em class="ly"> </em> </strong>的始终可靠的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank"> MDN来搜索它，以理解它是如何工作的。</a></p><p id="50f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过析构，我们可以更容易地提取数组或对象内部的信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="2bbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将分别给出对象和数组中的值，<br/>。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="85ed" class="mc md it mw b gy na nb l nc nd">/* Array Destructuring */</span><span id="602f" class="mc md it mw b gy ov nb l nc nd">blueDragon -&gt; "Blue Dragon"<br/>redDragon -&gt; "Red Dragon"<br/>yellowDragon -&gt; "Yellow Dragon"</span><span id="bddf" class="mc md it mw b gy ov nb l nc nd">/* Object Dragon */</span><span id="ddb8" class="mc md it mw b gy ov nb l nc nd">blue-&gt; "Blue Dragon"<br/>red -&gt; "Red Dragon"<br/>yellow -&gt; "Yellow Dragon"</span></pre><p id="2184" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我需要说的是，如果你想对一个对象使用析构，有必要使用对象的原始名称键。</p><h2 id="67b4" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">复试</h2><p id="2706" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">回调是作为参数传递给另一个函数的函数，然后在外部函数中调用它来完成某种类型的例程或动作。</p><p id="54a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回调将在运行父函数之后被调用——这是因为你可以在API请求或类似的东西中看到这种函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="a45f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解上面代码中发生的事情，我将以不同的方式向您展示:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="73c7" class="mc md it mw b gy na nb l nc nd">const processInputData = callback =&gt; {  <br/>      var name = "Jhornan Colina";<br/>      return callback(name);<br/>};<br/>processInputData(console.log(<strong class="mw iu">name variable</strong>));</span></pre></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="58fa" class="nl md it bd me nm nn no mh np nq nr mk jz ns ka mn kc nt kd mq kf nu kg mt nv bi translated">反应要点</h1><p id="1265" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">大多数人开始使用像jQuery这样的库，这是一种非常不同的反应。主要原因是因为很多人不知道如何开始反应。</p><p id="b77c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有很多网站，需求可以变得巨大。像React、Angular或Vue这样的学习技术可以帮助你更轻松地工作。因此，在这一节中，我将尝试向您介绍在React中创建自己的应用程序所需的初始步骤。</p><h2 id="3752" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">元素</h2><p id="2be5" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">与组件不同，元素只是JSX的一小部分，没有呈现方法。</p><p id="017c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像组件一样，您通常可以使用相同的元素或重用它，而无需重写其代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="3f20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，在表格下面，我们可以看到一个简单的JavaScript对象，它将创建一个新的HTML元素，返回一个包含必要信息的对象。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="5655" class="mc md it mw b gy na nb l nc nd">{   <br/>  type: 'div',   <br/>  props: { <br/>          children: 'Login',     <br/>          id: 'login-btn'  <br/>         } <br/>}</span></pre><p id="26da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这是创建元素的第一种方式。您还可以使用语法糖更容易地创建元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="a7a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有一点不同，因为它将返回一个不同的对象和必要的信息。我会不带任何不必要的信息给你看对象。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="e7b7" class="mc md it mw b gy na nb l nc nd">{<br/>  type:"h1",<br/>  props:{<br/>       children:[<br/>                  0:"Hello, "<br/>                  1:"Jhornan colina"<br/>                ]<br/>        }</span><span id="efe0" class="mc md it mw b gy ov nb l nc nd">}</span></pre><h2 id="f274" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">成分</h2><p id="f98b" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">如果你已经听说过React，也许你已经了解了组件。这是一种在网站的其他部分重用HTML的方法。</p><p id="d57a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将向您展示一个重用组件来创建大量标题的好例子，而不用一次又一次地编写相同的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="8447" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您可以使用析构将属性传递给组件——这是传递数据的一种更容易、更简单的方式，无需编写大量代码。</p><h2 id="0b68" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">类别组件</h2><p id="afcb" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">今天，类组件可以帮助你在组件中拥有主要控制权——通过拥有不同的状态，你需要在构造函数中声明它，例如<strong class="lb iu"> <em class="ly"> </em> </strong>(我知道有一个插件可以在没有构造函数的情况下声明状态)。此外，我们现在可以更好地控制组件的生命周期。</p><p id="4247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组件有生命周期——深入了解生命周期——在类组件内部，我们有不同的方法来控制组件，取决于它当前的生命周期状态。我要谈谈最重要的生命周期:</p><ul class=""><li id="2414" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">用于渲染JSX、门户、JSX元素数组、片段和JavaScript对象的方法</li><li id="59f2" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe op oq or mw b"><strong class="lb iu">constructor</strong></code>:React组件的构造函数在组装前被调用。当实现一个<code class="fe op oq or mw b">React.Component</code>子类的构造函数时，你应该在任何其他指令之前调用<code class="fe op oq or mw b">super(props)</code>。</li><li id="f01b" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe op oq or mw b"><strong class="lb iu">componentDidMount</strong></code>:这个方法在组件输出被渲染到DOM后运行。这意味着当组件被挂载时，方法中的所有内容都将被执行。</li><li id="8cec" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe op oq or mw b"><strong class="lb iu">componentWillMount</strong></code>:该方法在组件最终安装时调用。</li><li id="cbcb" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe op oq or mw b"><strong class="lb iu">UNSAFE_componentWillUpdate</strong></code>:当组件接收到新状态和新属性时执行</li><li id="86d6" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe op oq or mw b"><strong class="lb iu">componentDidUpdate</strong></code>:通常用于评估之前的状态是否与实际状态不同</li><li id="dcd3" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe op oq or mw b"><strong class="lb iu">shouldComponentUpdate</strong></code>:通过将当前状态与下一个状态或下一个属性进行比较，了解组件是否应该更新的方法</li></ul><h2 id="de06" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">了解“render”方法</h2><p id="f0e8" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">就像一张图片一样，我们可以通过使用一个叫做<code class="fe op oq or mw b">render()</code>的<code class="fe op oq or mw b">ReactDom</code>方法在虚拟DOM中绘制组件，它允许您在虚拟DOM内部插入一个组件。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="a407" class="mc md it mw b gy na nb l nc nd">import ReactDom from 'react-dom';<br/>ReactDom.render(&lt;component&gt;,&lt;selector&gt;);</span></pre><p id="a360" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">render方法需要两个参数:其中一个参数是要呈现的组件。第二个是容器选择器——换句话说，就是创建组件的地方。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="833f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你正在使用<a class="ae ky" href="https://create-react-app.dev/docs/getting-started/" rel="noopener ugc nofollow" target="_blank">Create React App CLI、</a> <strong class="lb iu"> <em class="ly"> </em> </strong>你会注意到在<code class="fe op oq or mw b">index.js</code>文件里面，有一些类似于render的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="f3e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<strong class="lb iu"> </strong> <code class="fe op oq or mw b">index.js</code>会渲染出<code class="fe op oq or mw b">App</code> <strong class="lb iu"> </strong>组件里面的一切。当然，从一个独特的<code class="fe op oq or mw b">root</code> <strong class="lb iu"> </strong>组件或者类似的东西中加载所有东西是一个好习惯。</p><h2 id="ae50" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">状态组件</h2><p id="2312" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated"><code class="fe op oq or mw b">state</code>允许您在组件中保存属性或信息。<code class="fe op oq or mw b">state</code>是内在的——它不能变异，需要改变，回到一个新的状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="eb91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以类组件<strong class="lb iu"> </strong>最重要的一个概念就是如何改变它的状态。为此，我们需要使用<code class="fe op oq or mw b">this.setState</code>方法，它返回一个带有更新值的新状态。</p><h2 id="a097" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">“setState”方法</h2><p id="40d7" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">实际上，在类组件或功能组件内部，您不能改变状态，因为这不是一个好的做法。它会产生<a class="ae ky" href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="noopener ugc nofollow" target="_blank">副作用</a>，造成很多麻烦。</p><p id="7c5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe op oq or mw b">setState</code>方法允许您在不改变值的情况下改变类组件的状态。但是需要注意的是，这个方法使用了async <strong class="lb iu"> </strong>概念，这意味着如果你需要获得当前值，你需要使用它的回调。(如果你对回调一无所知，回到回调部分。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="874a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个如何用<code class="fe op oq or mw b">setState</code>使用回调的好例子。如您所见，我正试图从状态中获取当前数值。它会在第一个函数结束时给我一个值。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="fea0" class="nl md it bd me nm nn no mh np nq nr mk jz ns ka mn kc nt kd mq kf nu kg mt nv bi translated">React中的生命周期</h1><p id="a0e6" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">通过这些方法，您可以了解组件的当前状态。例如，如果您正在使用API，并且您的数据尚未加载，那么您可以在组件获取数据时指定重新呈现。</p><p id="43af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要了解一个组件的基本生命周期，以及一个组件是如何挂载的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/fe93b7a25cd0fdae0a95ea19e22ca9a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CfaYxw2J1ysUZlPOZ_ecDA.jpeg"/></div></div></figure><h2 id="e5e5" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><strong class="ak">安装周期</strong></h2><ul class=""><li id="31ff" class="ob oc it lb b lc nw lf nx li ox lm oy lq oz lu og oh oi oj bi translated"><code class="fe op oq or mw b"><strong class="lb iu">Constructor</strong></code>:在此步骤中，将加载状态、默认属性和可能创建的方法</li><li id="6045" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe op oq or mw b"><strong class="lb iu">componentDidMount</strong></code>:组件最终安装时</li></ul><h2 id="76fa" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><strong class="ak">更新/安装周期</strong></h2><ul class=""><li id="2c20" class="ob oc it lb b lc nw lf nx li ox lm oy lq oz lu og oh oi oj bi translated"><strong class="lb iu"> React更新DOM和refs </strong>:更新DOM和refs以挂载组件</li><li id="8602" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe op oq or mw b"><strong class="lb iu">getDerivedStateFromProps</strong></code>:这个方法在<code class="fe op oq or mw b">render</code>方法之前被调用，当你的状态依赖于属性变化时使用</li><li id="7175" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe op oq or mw b"><strong class="lb iu">render</strong></code>:给部件上漆</li></ul><h2 id="19b6" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><strong class="ak">更新周期</strong></h2><ul class=""><li id="608f" class="ob oc it lb b lc nw lf nx li ox lm oy lq oz lu og oh oi oj bi translated"><code class="fe op oq or mw b"><strong class="lb iu">shouldComponentUpdate</strong></code>:告知组件是否真的需要渲染</li><li id="acb1" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe op oq or mw b"><strong class="lb iu">getSnapshoptBeforeUpdate</strong></code>:在改变某些东西或渲染组件之前获取潜在的信息</li><li id="1631" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe op oq or mw b"><strong class="lb iu">componentDidUpdate</strong></code>:组件更新时会调用</li></ul><p id="d65f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击了解更多关于这个话题的信息<a class="ae ky" href="https://programmingwithmosh.com/javascript/react-lifecycle-methods/" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="c05f" class="nl md it bd me nm nn no mh np nq nr mk jz ns ka mn kc nt kd mq kf nu kg mt nv bi translated"><strong class="ak">向子组件传递数据</strong></h1><p id="a661" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">React中有一个好的实践，叫做<em class="ly">表示和容器组件。</em>(不需要遵循这个模式。我将以它为例)将逻辑组件与转储组件分开。)</p><p id="38b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要使用props将数据传递给我们的子组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="fb94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，通过这个简短的算法，我们可以传递包含<code class="fe op oq or mw b">h1</code>标签的文本。结果将是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/4942036bd26a2d9f1af50be5d7b9e919.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*OXzcPrTkZbvyy8jfEJcQyQ.png"/></div></figure><p id="5aa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们像传递道具一样传递事件，这是非常有用的，因为我们可以在父组件中控制这些事件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/4c610b401b9d62d8401965f90363b89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/1*PeJEgLJ175_u3-94deSWsQ.gif"/></div></figure><p id="71b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我添加了一个按钮来改变<code class="fe op oq or mw b">h1</code>标签的文本。如你所见，你可以通过道具来传递事件。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="67df" class="nl md it bd me nm nn no mh np nq nr mk jz ns ka mn kc nt kd mq kf nu kg mt nv bi translated">结论</h1><p id="74a0" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">感谢阅读。我希望你喜欢这篇文章！</p></div></div>    
</body>
</html>