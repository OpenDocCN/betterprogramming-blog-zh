<html>
<head>
<title>A Mixed Bag of SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一包混合的SwiftUI</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-mixed-bag-of-swiftui-11e018a280b7?source=collection_archive---------21-----------------------#2020-04-23">https://betterprogramming.pub/a-mixed-bag-of-swiftui-11e018a280b7?source=collection_archive---------21-----------------------#2020-04-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="05e8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当返回混合内容时，控制SwiftUI视图。常见陷阱及其解决方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/260a0c58856ef7bf64fb94169ead4987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1DX30SlqTWRd9Oq9"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@helloimnik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">你好，我是尼克🎞</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>。</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="f921" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">介绍</h1><p id="f99a" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">SwiftUI向我们介绍了一种全新的界面设计和编码方式。划分UIKit(或AppKit)类的子类和硬布线布局约束的老方法已经一去不复返了。相反，我们现在有了一个很好的、声明式的方法来构造和设计我们的控件，并确保每当新的信息或事件到来时，界面都会更新。</p><p id="84a2" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">为了促进这种新的架构，苹果的优秀人员采用了Swift的一些最佳特性(如协议、泛型、不透明类型)并将它们合并到SwiftUI中。然而，这也带来了一个隐藏的代价:如果你还不熟悉这些特性，将会有一个学习曲线，并且很可能会有很多神秘的错误信息将你送到你最喜欢的搜索引擎。本文将研究其中的一些错误消息，并解释它们的含义以及您可以做些什么来防止它们。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="0eb2" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">构建视图</h1><p id="8e05" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">当实施一个新的SwiftUI视图时，您通常从小处着手。向<code class="fe mw mx my mz b">body</code>添加一些组件，设计它们的样式，并处理任何交互。在某一点上，你的简单视图开始变得太大，或者在你的<code class="fe mw mx my mz b">body</code>中有很多条件逻辑或重复。因此，您决定将一些逻辑从<code class="fe mw mx my mz b">body</code>中移出，放到一个单独的函数中。该函数将负责为您构建一些复杂的组件，由于在SwiftUI中一切都是一个<code class="fe mw mx my mz b">View</code>，您只需像这样定义函数类型签名:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="171c" class="ne le iq mz b gy nf ng l nh ni"><strong class="mz ir">private</strong> <strong class="mz ir">func</strong> buildComplexButton() -&gt; View</span></pre><p id="bdd3" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">太好了！嗯……除了抱怨的编译器，</p><blockquote class="nj nk nl"><p id="9122" class="lv lw nm lx b ly mr jr ma mb ms ju md nn mt mg mh no mu mk ml np mv mo mp mq ij bi translated">"协议“View”只能用作一般约束，因为它具有自身或关联的类型要求。"</p></blockquote><p id="c570" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这里的问题在于错误消息的最后部分:任何符合<code class="fe mw mx my mz b">View</code>协议的对象都需要有一个<em class="nm"> </em>关联类型<code class="fe mw mx my mz b">Body</code>，它决定了视图实际上是如何实现的。试图从你的函数中返回一个普通的<code class="fe mw mx my mz b">View</code>会导致编译器放弃它的手，说:“如果没有任何关于符合这个协议的实际类型的附加信息，我不知道返回的类型会是什么。”这有点像在没有指定类型参数列表的情况下返回泛型类型(比如<code class="fe mw mx my mz b">Array</code>)(<code class="fe mw mx my mz b">Array</code>包含什么？).但这正是问题的关键！我们还不想把自己束缚在一个具体的类型上。我们的函数可能会生成具有不同具体类型的各种不同视图。幸运的是，Swift 5.1引入了关键字<code class="fe mw mx my mz b">some</code>来帮助解决这个问题，您已经在创建新视图时看到了:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="a2fe" class="ne le iq mz b gy nf ng l nh ni"><strong class="mz ir">var</strong> body: <strong class="mz ir">some</strong> View</span></pre><p id="2012" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">天真地说，这意味着你认为它意味着:我们返回<em class="nm">一些</em> <code class="fe mw mx my mz b">View</code>并且我们真的不关心什么类型。这通常被称为不透明类型:一种具有一些功能的类型(它是一个<code class="fe mw mx my mz b">View</code>)，但是我们不知道确切的<em class="nm">是什么样的</em>视图。因此，我们将我们的函数更新为新的签名，并给它一个实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a800" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">一切又都好了！嗯……只要你确保从这个函数返回的每一个可能的<code class="fe mw mx my mz b">View</code>都有完全相同的<em class="nm">类型。对不透明类型的限制是，只有当每个可用的代码路径都返回相同的具体类型时，编译器才会允许它们。我们只返回相同的按钮，所以这里没有问题。然而，假设我们正在实现一个键盘用户界面。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/b5b74aa887684f77124ac614861f37e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y_QO3TnWBcAQuAzvnBUwAA.png"/></div></div></figure><p id="7320" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我们选择将它实现为一个<code class="fe mw mx my mz b">Buttons</code>网格。因为所有的按钮或多或少都是相同的，我们不想对它们中的每一个都进行硬编码，所以我们使用一个构建器函数来创建它们。有两种主要类型的按钮:带有文本标签(数字)的按钮和带有图像的按钮(在这种情况下，删除和Face ID符号来自SF符号)。简化后，看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d6ae" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我们还在返回<code class="fe mw mx my mz b">Buttons</code>，所以这一定行得通，对吧？不幸的是，编译器拒绝了:</p><blockquote class="nj nk nl"><p id="76bd" class="lv lw nm lx b ly mr jr ma mb ms ju md nn mt mg mh no mu mk ml np mv mo mp mq ij bi translated">"函数声明了不透明的返回类型，但函数体中的返回语句没有匹配的基础类型."</p></blockquote><p id="a4aa" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">奇怪。按钮就是按钮，对吧？但是如果我们检查文档中的<a class="ae kv" href="https://developer.apple.com/documentation/swiftui/button" rel="noopener ugc nofollow" target="_blank">，我们会发现<code class="fe mw mx my mz b">Button</code>实际上是一个泛型类型，而不是像<code class="fe mw mx my mz b">Text</code>一样的普通结构:</a></p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="dc89" class="ne le iq mz b gy nf ng l nh ni">struct Button&lt;Label&gt; where Label : View</span></pre><p id="7042" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这适用于许多SwiftUI内置类型——最显著的是那些可以包含其他视图或内容的类型。因此，我们试图返回一个<code class="fe mw mx my mz b">Button&lt;Text&gt;</code>或一个<code class="fe mw mx my mz b">Button&lt;Image&gt;</code>，编译器(正确地)识别为两个不同的类型，因此拒绝合作。这是Swift的严格分类对我们不利的情况之一。</p><p id="14d1" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">幸运的是，有两种方法可以解决这个问题，这两种方法都能满足编译器的要求，使我们能够编译和运行我们的代码:</p><ol class=""><li id="cf7f" class="nt nu iq lx b ly mr mb ms me nv mi nw mm nx mq ny nz oa ob bi translated">将我们的视图嵌入到<code class="fe mw mx my mz b"><a class="ae kv" href="https://developer.apple.com/documentation/swiftui/group" rel="noopener ugc nofollow" target="_blank">Group</a></code>，<em class="nm">中，尽可能多地保留</em>类型信息。</li><li id="45c0" class="nt nu iq lx b ly oc mb od me oe mi of mm og mq ny nz oa ob bi translated">在<code class="fe mw mx my mz b"><a class="ae kv" href="https://developer.apple.com/documentation/swiftui/anyview" rel="noopener ugc nofollow" target="_blank">AnyView</a></code>中包装我们的视图，有效地<em class="nm">移除</em>类型信息。</li></ol><p id="091f" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这两种方法各有特点，最终由你来决定哪一种最适合你。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="6d3d" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">嵌入到组中</h1><p id="1943" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">这是一些人认为的“最干净”的方法，因为在<code class="fe mw mx my mz b">Group</code>中嵌入混合内容保留了所有的输入信息。然而，它引入了一些您可能想不到的类型，并且您目前仅限于使用简单的<code class="fe mw mx my mz b">if</code>语句进行条件切换。这意味着没有<code class="fe mw mx my mz b">if case let</code>或<code class="fe mw mx my mz b">switch</code>语句。如果这不是问题，那就继续吧。它看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="3df7" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">现在，这不是什么改变不透明类型工作方式的“神奇”修复。它只是引入了一些额外的类型，确保从编译器的角度来看，这个函数总是返回相同的类型。如果我们检查它，我们会看到返回的类型是:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="8e69" class="ne le iq mz b gy nf ng l nh ni">Group&lt;_ConditionalContent&lt;Button&lt;Text&gt;, Button&lt;Image&gt;&gt;&gt;</span></pre><p id="dbe4" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">同样，<code class="fe mw mx my mz b">Group</code>是一个泛型类型，但是它引入了一个额外的(泛型)类型<code class="fe mw mx my mz b">_ConditionalContent</code>，在类型参数列表中有我们的按钮类型(同样是泛型)。这实际上是SwiftUI的锦囊妙计:通过变得聪明和引入额外的类型，它可以保留所有的原始类型，并且仍然让编译器满意，因为我们总是返回相同的类型来满足<code class="fe mw mx my mz b">some View</code>返回类型。但是正如我提到的，您受到SwiftUI实际能够表达的内容的限制。因此，举例来说，任何复杂的逻辑切换现在都是不可能的。此外，要明白这是一个非常简单的例子，它已经生成了一个复杂的结果类型。现在想象有许多嵌套的逻辑和泛型类型，这将很快变得难以阅读和理解。</p><p id="09c3" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">因此，好处是我们维护了所有的类型信息，但坏处是我们将生成许多复杂的类型，并且我们受限于SwiftUI视图构建器的表达能力。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="4cfc" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">在任意视图中换行</h1><p id="13b3" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">包装在AnyView中是另一种方法，它涉及到称为类型擦除的东西，以有效地去除关于视图类型的信息，并使它们看起来都是相同的。它看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ab65" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我们在这里将视图包装在一个符合<code class="fe mw mx my mz b">View</code>协议的<code class="fe mw mx my mz b">AnyView</code>中，并将对它的任何调用委托给被包装的视图(我们的按钮)。对于外界(即编译器)，我们的函数现在总是返回完全相同的类型(<code class="fe mw mx my mz b">AnyView</code>)，不会抱怨。</p><p id="5fe4" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我们可以通过引入一个对<code class="fe mw mx my mz b">View</code>的扩展来使这变得更容易，提供一个可以为我们返回类型擦除视图的函数，并使它像许多其他修饰符一样工作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e476" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这里的好处是，我们可以在控制逻辑方面使用Swift的全部表达能力(而不仅仅是SwiftUI实现的任何东西):<code class="fe mw mx my mz b">if case let</code>或<code class="fe mw mx my mz b">switch</code>或甚至其他复杂的逻辑——这都是可能的。缺点是您实际上失去了对常规类型的访问，只能访问<code class="fe mw mx my mz b">AnyView</code>向您公开的部分。因为，大多数时候，<code class="fe mw mx my mz b">AnyView</code>中的包装是你做的最后一件事，这不是一个很大的问题，你仍然可以访问<code class="fe mw mx my mz b">View</code>协议提供的所有属性(因为<code class="fe mw mx my mz b">AnyView</code>符合<code class="fe mw mx my mz b">View</code>)。</p><p id="c236" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">由于每当<code class="fe mw mx my mz b">AnyView</code>内包装的<code class="fe mw mx my mz b">View</code>发生变化时，SwiftUI都必须破坏并重建视图层次结构，因此存在一些关于性能的担忧，但是如果您不经常<em class="nm"/>这样做(大多数用户界面不这样做)，应该不会有问题。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="c01b" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">结论</h1><p id="e43c" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">在SwiftUI中构建复杂的用户界面很快会成为一种令人沮丧的体验，因为编译器规定了我们如何处理泛型类型、具有关联类型的协议以及不透明类型。迟早，你会遇到前面提到的一些问题。我们已经看到了两种规避这些问题的方法:一种是将内容嵌入到一个<code class="fe mw mx my mz b">Group</code>(保留类型，但有一个警告，即您受限于SwiftUI可以表达的内容)和一种是通过包装在<code class="fe mw mx my mz b">AnyView</code>(有效地对编译器隐藏类型信息，但获得更多的表达能力)。这两种方法都是有效的，可以考虑在您自己的应用程序中使用，现在您应该知道为什么您会选择其中一种。</p><p id="e704" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">作为结束语，令人印象深刻的是Swift在构建视图时是如何保存所有的类型信息的，以及在编译器进行严格的类型检查的情况下，它“大部分时间”是如何工作的。如果你对此感兴趣，我建议你看看<code class="fe mw mx my mz b"><a class="ae kv" href="https://developer.apple.com/documentation/swiftui/viewbuilder" rel="noopener ugc nofollow" target="_blank">ViewBuilder</a></code>是如何工作的。这用于构建包含一个或多个子视图的SwiftUI视图，并提供支持视图模板中基本逻辑的功能，例如使用<code class="fe mw mx my mz b">TupleView</code>和<code class="fe mw mx my mz b">_ConditionalContent</code>(后者不幸被标记为私有)。<a class="ae kv" href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api/" rel="noopener ugc nofollow" target="_blank">Sundell的Swift对Swift 5.1中支持SwiftUI/ViewBuilder的许多特性进行了很好的概述</a>。</p><p id="bfd8" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我们也在某种程度上掩饰了类型擦除在Swift中的确切工作方式，但它实际上在Swift中的更多地方使用，例如<code class="fe mw mx my mz b"><a class="ae kv" href="https://developer.apple.com/documentation/swift/anysequence" rel="noopener ugc nofollow" target="_blank">AnySequence</a></code>和<code class="fe mw mx my mz b"><a class="ae kv" href="https://developer.apple.com/documentation/combine/anypublisher" rel="noopener ugc nofollow" target="_blank">AnyPublisher</a></code>。在后一种情况下，不仅对编译器，而且对其他人隐藏一些类型信息实际上是有帮助的。</p><blockquote class="nj nk nl"><p id="5eec" class="lv lw nm lx b ly mr jr ma mb ms ju md nn mt mg mh no mu mk ml np mv mo mp mq ij bi translated">以这种方式使用类型擦除时，您可以随着时间的推移更改底层发布者实施，而不会影响现有客户端— <a class="ae kv" href="https://developer.apple.com/documentation/combine/anypublisher" rel="noopener ugc nofollow" target="_blank">苹果官方文档</a></p></blockquote><p id="6d5c" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我再次向<a class="ae kv" href="https://www.swiftbysundell.com/articles/type-erasure-using-closures-in-swift/" rel="noopener ugc nofollow" target="_blank">推荐一篇由Sundell </a>撰写的Swift的文章来解决类型擦除问题。</p></div></div>    
</body>
</html>