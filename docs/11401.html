<html>
<head>
<title>How to Use Upserting in Room</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在室内使用向上插入</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/upserting-in-room-8207a100db53?source=collection_archive---------5-----------------------#2022-03-16">https://betterprogramming.pub/upserting-in-room-8207a100db53?source=collection_archive---------5-----------------------#2022-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7789" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">避免插入或替换的潜在危险</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/001b096263d0e191d0d8d440ebff9818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M7j-POLqg0gn68i04X_X9g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@hjwinunsplsh?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Jungwoo Hong </a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="ebcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SQLite在3.24版本中增加了“向上插入”功能。向上插入意味着更新已经存在的行，否则插入新行。不幸的是，SQLite版本3.24直到API级别30才在Android上可用，所以它不被Room支持(尽管团队<a class="ae kv" href="https://issuetracker.google.com/issues/208869468" rel="noopener ugc nofollow" target="_blank">已经表示计划</a>在未来的更新中添加<code class="fe ls lt lu lv b">@Upsert</code>)。但是，通过一个简单的DAO函数，我们可以在我们的Android应用程序中添加upsert功能。</p><p id="5f15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们开始之前，让我们考虑一下为什么这个话题很重要。乍一看，这似乎是一个已经解决的问题。我们已经可以使用带有替换现有行的冲突策略的insert。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="1d94" class="ma mb iq lv b gy mc md l me mf">@Insert(onConflict = OnConflictStrategy.<em class="mg">REPLACE</em>)</span></pre><p id="67e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，为什么要担心增加插入呢？微妙的答案是，这些可以是稍微不同的问题的解决方案。当我们使用“替换”冲突策略进行插入时，实际上删除了旧行，并添加了新行。当我们向上插入时，我们实际上是在<em class="mg"> </em>更新<em class="mg">现有的</em>行。这一点特别重要的一个场景是外键被配置为级联删除。这正是我所面临的情景，它引导我寻找upsert功能。</p><p id="f664" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有一个表<code class="fe ls lt lu lv b">Notebooks</code>和一个表<code class="fe ls lt lu lv b">Notes</code>，其中两者之间有一对多的关系。每个笔记本都有一个惟一的id作为主键，每个便笺都有一个外键来指示它所属的笔记本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="67fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在假设用户编辑笔记本的标题。假设我们有一个单独的添加/编辑屏幕，从这里我们调用我们的标准DAO插入函数。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="417d" class="ma mb iq lv b gy mc md l me mf">@Insert(onConflict = OnConflictStrategy.<em class="mg">REPLACE</em>)<br/>fun insertNotebook(notebook: Notebook)</span></pre><p id="3a63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将允许我们为这个笔记本插入一个新行(如果我们还没有新行的话)(如果这是一个“添加”)，或者替换现有的行(如果这是一个“编辑”)。但是你看到问题了吗？我没有。</p><p id="aab5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们使用“替换”冲突策略进行插入时，实际上删除了旧行，并添加了新行。一旦旧行被删除，级联删除就会被触发，notes表中带有这个外键的所有行都会被删除。在此操作之后，我们将在笔记本表中拥有完全相同的数据，但会从注释表中删除所有相应的注释。说一个调试噩梦。我们需要一个解决方案来更新行，而不是删除并插入它。我们需要升级。</p><p id="8cd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理想情况下，Room会为我们提供一个<code class="fe ls lt lu lv b">@Upsert</code>注释来处理这个问题。因为我们没有，所以让我们看看如何手动增加插入。首先，我们需要移除<code class="fe ls lt lu lv b">OnConflictStrategy</code>,这样插入冲突就会抛出异常。我们将在upsert函数中依赖于此，该函数将在<code class="fe ls lt lu lv b">try/catch</code>块中包装一个<code class="fe ls lt lu lv b">insert</code>。如果<code class="fe ls lt lu lv b">insert</code>抛出一个<code class="fe ls lt lu lv b">SQLiteConstraintException</code>，那么我们知道该笔记本已经有一行，我们可以调用<code class="fe ls lt lu lv b">update</code>来代替。这是代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="bbae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得一提的一个细微差别是向上排序列表。房间支持在实体列表上使用<code class="fe ls lt lu lv b">@Insert</code>或<code class="fe ls lt lu lv b">@Update</code>。这既提供了便利，也提高了性能，因为Room将批量插入作为单个事务来执行，SQLite带来了巨大的性能提升。</p><p id="43ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，我们不能像这样向上插入一个列表，因为任何一行上的冲突都会导致整个事务回滚。这意味着要向上插入一个列表，我们需要遍历列表和每个单独的插入。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="9582" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，这可能会对大型列表的性能造成重大影响。如果您在一个清单上调用upsert，而您预计该清单有20个项目，那么这种差异可以忽略不计。如果你在一个有2000个项目的列表上调用upsert，你需要密切监视它，并可能采用不同的方法。</p><p id="787d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！向上，向上插。如果你觉得这有帮助，请告诉我。更好的是，顺便提一下我在打开的问题，让房间团队知道添加一个<code class="fe ls lt lu lv b">@Upsert</code>注释会使这篇文章过时。</p></div></div>    
</body>
</html>