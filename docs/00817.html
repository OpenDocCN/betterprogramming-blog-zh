<html>
<head>
<title>Fun With Data Structures: Random Teleport Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构的乐趣:随机传送问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/fun-with-data-structures-random-teleport-problem-5499c3a7387d?source=collection_archive---------2-----------------------#2019-07-17">https://betterprogramming.pub/fun-with-data-structures-random-teleport-problem-5499c3a7387d?source=collection_archive---------2-----------------------#2019-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f945" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用众所周知的数据结构解决现实世界的问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cad90c02e11026374d74e042fcb2a495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HBUC_wEj595YkwTEa9Hu_A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.youtube.com/watch?v=LeyofQK6tRw" rel="noopener ugc nofollow" target="_blank">谢尔顿·库珀拿旗子开玩笑</a></p></figure><p id="145b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是新系列的第一部分:数据结构的乐趣。</p><p id="0bd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将使用一种众所周知的数据结构——字典(或<a class="ae kv" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank">哈希表</a>)来解决一个现实世界中的问题。</p><h2 id="17b8" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">工作</h2><p id="cf7a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们有一个多人太空生存游戏。有玩家，宇宙飞船，星系，行星…还有很多。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/44c93c9de5e57060c1676dba38f4355d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DoDopU0jznD7-1021Kr82Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://wallhere.com/en/wallpaper/138811" rel="noopener ugc nofollow" target="_blank">图像来源</a></p></figure><p id="06bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一天，我们决定引入一项新功能:</p><p id="883d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">游戏每秒钟都会从游戏中的所有飞船中随机选择一艘飞船，将其传送到另一个星系。只是为了好玩。</p><p id="5074" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简单起见，假设每艘飞船都有一个唯一的整数<code class="fe mr ms mt mu b">id</code>和<code class="fe mr ms mt mu b">name</code>。它们存储在字典中；<code class="fe mr ms mt mu b">id</code>为键，<code class="fe mr ms mt mu b">name</code>为值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/14a61cc1aedb16253949d55d67491142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmCYdtH44rM8jEAslf6Czw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一本宇宙飞船词典样本</p></figure><p id="0054" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">游戏里有几百万艘飞船。玩家不断地创造、破坏和更新宇宙飞船。</p><p id="3f85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的任务是实现一个算法，从这个字典中随机挑选一艘飞船(<em class="mw">从字典中随机返回一个项目</em>)。</p><p id="be26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">时间复杂性假设:</p><ul class=""><li id="7002" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">生成随机数:O(1)次</li><li id="4fa2" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">在字典中搜索/插入/删除:O(1)时间</li><li id="3295" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">从列表中删除一个项目，O(n)时间</li><li id="271c" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">将一个项目添加到列表中，O(1)时间</li></ul><p id="0615" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">spaceships</code>的样本字典输入:</p><pre class="kg kh ki kj gt nl mu nm nn aw no bi"><span id="7a4b" class="ls lt iq mu b gy np nq l nr ns">spaceships = {<br/>  5:   "Ghost",<br/>  40:  "Death Star",<br/>  16:  "B-wing",<br/>  ...<br/>}</span></pre><p id="9981" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">样本输出:<code class="fe mr ms mt mu b">Death Star</code>(随机抽取)</p><p id="b43c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在继续阅读之前，我强烈建议你尝试自己解决这个问题。</p><h2 id="92d2" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">第一次尝试:生成一个随机int作为密钥</h2><p id="e158" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这看起来很简单，对吗？只需创建一个随机数，并使用它作为从字典中选择一个项目的关键。我们假设每艘飞船在<code class="fe mr ms mt mu b">0</code>和<code class="fe mr ms mt mu b">100000000</code>之间都有一个<code class="fe mr ms mt mu b">id</code>。在这个区间内很容易产生一个随机数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5eb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们分析一下这个算法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/23fa5adb91e5c64b1f5b402f8af5ad46.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*HUp4sigEsah8IpDqkum_zQ.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.flaticon.com/free-icon/project_1055646" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="e359" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">时间复杂度:<strong class="ky ir"> </strong> O(1)</p><p id="0e15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">额外空间复杂度:O(1)</p><p id="9de3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哇哦。这已经是最好的了。但是这个算法真的管用吗？</p><p id="6caa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">号</strong></p><p id="34c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只有当我们确定字典中正好有100000001个条目，并且它们的id从0开始是连续的时，这种方法才有效。但是请记住，玩家可以随时创造或摧毁飞船。一次可能只有11艘宇宙飞船，而另一次可能有300万艘宇宙飞船。它们有唯一的id，这些id之间可能会有间隔。</p><h2 id="b2b8" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">第二次尝试:将键移动到列表中</h2><p id="fd85" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">好吧，从字典中随机选择一个元素并不那么简单。列表怎么样？它们有一定的顺序和长度。我们可以很容易地从列表中选择一个随机元素。</p><p id="3b6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将<code class="fe mr ms mt mu b">spaceships</code>字典中的所有键放在一个列表中，并从这个列表中选择一个随机元素:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="50f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">绝对管用。(数据赛跑怎么样？)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/c445325d29e649a457bf45b5fd391fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*v8VOsABXNib0AUNqfYcswQ.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.flaticon.com/free-icon/spaceship_139714" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="75a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">时间复杂度:<strong class="ky ir"> </strong> O(n) <strong class="ky ir"> </strong>将字典键复制到一个列表中。</p><p id="a0e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">额外的空间复杂度:O(n) <strong class="ky ir"> </strong>保持列表中的键。</p><p id="4e13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，没那么糟。我们买得起内存。</p><p id="e597" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是记住，我们每秒都会调用这个函数。这意味着每秒要花费O(n)时间。如果有几百万艘飞船，那真的会很慢。</p><p id="f0f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们真的需要在每次调用<code class="fe mr ms mt mu b">get_random_ship</code>时重新创建<code class="fe mr ms mt mu b">key_list</code>吗？我们能做得更好吗？</p><h2 id="d832" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">第三次尝试:映射器字典</h2><p id="fd51" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们可以一次创建一个新的键列表，并在每次调用时使用它，而不是每次都创建新的键列表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7906" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了正确地做到这一点，我们需要保持<code class="fe mr ms mt mu b">key_list</code>和<code class="fe mr ms mt mu b">spaceships</code>同步:</p><ul class=""><li id="1b8e" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">每当从<code class="fe mr ms mt mu b">spaceships</code>上取下一个键时，从<code class="fe mr ms mt mu b">key_list</code>上取下该键</li><li id="40ba" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">每当一个新项目被添加到<code class="fe mr ms mt mu b">spaceships</code>时，将其关键字附加到<code class="fe mr ms mt mu b">key_list</code></li></ul><p id="30f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在<strong class="ky ir"> </strong> O(1)时间里给<code class="fe mr ms mt mu b">key_list</code>追加新的键，但是移除呢？我们需要在列表中找到密钥，这将花费O(n)时间。我们还需要删除它，这将需要另一个O(n)时间。</p><p id="7ade" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们知道这个键在链表中的位置，我们可以在O(1) <strong class="ky ir"> </strong>时间内找到它，并且，通过一个聪明的技巧，我们可以在O(1)时间内删除它。</p><p id="d2dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想在O(1)时间内访问一些东西，字典是我们最好的选择。是时候引入映射器字典了，<code class="fe mr ms mt mu b">key_mappings</code>，它保存了<code class="fe mr ms mt mu b">key_list</code>中每个键的位置。</p><p id="cdd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我们使用的三种数据结构的快照:</p><pre class="kg kh ki kj gt nl mu nm nn aw no bi"><span id="f0be" class="ls lt iq mu b gy np nq l nr ns">spaceships = {<br/>  5:   "Ghost",<br/>  40:  "Death Star",<br/>  16:  "B-wing",<br/>}</span><span id="4a8a" class="ls lt iq mu b gy nw nq l nr ns">key_list = [5, 40, 16]</span><span id="7abc" class="ls lt iq mu b gy nw nq l nr ns">key_mappings = {<br/>  5:  0,  # Key 5  is at position 0 in `key_list`<br/>  40: 1,  # Key 40 is at position 1 in `key_list`<br/>  16: 2,  # Key 16 is at position 2 in `key_list`<br/>}</span></pre><p id="6433" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过查看<code class="fe mr ms mt mu b">key_mappings</code>我们知道键<code class="fe mr ms mt mu b">5</code>在<code class="fe mr ms mt mu b">key_list</code>数组中的位置<code class="fe mr ms mt mu b">0</code>，键<code class="fe mr ms mt mu b">16</code>在位置<code class="fe mr ms mt mu b">2</code>，以此类推……现在我们可以在O(1)时间内更新<code class="fe mr ms mt mu b">key_list</code>，代价是额外的O(n)空间<code class="fe mr ms mt mu b">key_mappings</code>。</p><p id="9cd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一个例子，并添加一个新的宇宙飞船，<code class="fe mr ms mt mu b">4: "Starfighter"</code></p><ol class=""><li id="782b" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nx nd ne nf bi translated">给飞船增加新价值:<code class="fe mr ms mt mu b">spaceships[4] = "Starfighter"</code></li><li id="06bd" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nx nd ne nf bi translated">将<code class="fe mr ms mt mu b">4</code>追加到key_list: <code class="fe mr ms mt mu b">key_list.append(4)</code></li><li id="258b" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nx nd ne nf bi translated">将新键的索引添加到映射:<code class="fe mr ms mt mu b">key_mappings[4] = len(key_list)</code></li></ol><pre class="kg kh ki kj gt nl mu nm nn aw no bi"><span id="c974" class="ls lt iq mu b gy np nq l nr ns">spaceships = {<br/>  5:   "Ghost",<br/>  40:  "Death Star",<br/>  16:  "B-wing",<br/>  4:   "Starfighter",<br/>}</span><span id="4f8d" class="ls lt iq mu b gy nw nq l nr ns">key_list = [5, 40, 16, 4]</span><span id="3c30" class="ls lt iq mu b gy nw nq l nr ns">key_mappings = {<br/>  5:  0,<br/>  40: 1,<br/>  16: 2,<br/>  4:  3,<br/>}</span></pre><p id="a88b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从宇宙飞船上取下钥匙<code class="fe mr ms mt mu b">40</code>。我们知道<code class="fe mr ms mt mu b">40</code>在<code class="fe mr ms mt mu b">key_list</code>的<code class="fe mr ms mt mu b">1</code>位置。诀窍是，我们可以在O(1)时间内将最后一个元素放入这个位置，而不是直接从<code class="fe mr ms mt mu b">key_list</code>中移除<code class="fe mr ms mt mu b">40</code>。</p><ol class=""><li id="a41d" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nx nd ne nf bi translated">从飞船上移除物品:<code class="fe mr ms mt mu b">del spaceships[40]</code></li><li id="44c5" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nx nd ne nf bi translated">在key_list中查找键的索引:<code class="fe mr ms mt mu b">index = key_mappings[40]</code></li><li id="c3b4" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nx nd ne nf bi translated">用最后一个键替换:<code class="fe mr ms mt mu b">key_list[index] = key_list.pop()</code></li></ol><pre class="kg kh ki kj gt nl mu nm nn aw no bi"><span id="0f5b" class="ls lt iq mu b gy np nq l nr ns">spaceships = {<br/>  5:   "Ghost",<br/>  16:  "B-wing",<br/>  4:   "Starfighter",<br/>}</span><span id="0762" class="ls lt iq mu b gy nw nq l nr ns"># Notice that how we moved last element into position 1<br/>key_list = [5, 4, 16]</span><span id="fe7a" class="ls lt iq mu b gy nw nq l nr ns"># Notice that we set the value of `4` to 1 and removed key `40`.<br/># Although we can keep key 40 there instead of removing.<br/>key_mappings = {<br/>  5:  0,  <br/>  16: 2,<br/>  4:  1,<br/>}</span></pre><p id="41ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">时间复杂度:</p><ul class=""><li id="b5b0" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">一次O(n)创建<code class="fe mr ms mt mu b">key_list</code></li><li id="5894" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">O(1)每次我们更新<code class="fe mr ms mt mu b">spaceships</code>字典。</li><li id="df96" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">O(1)得到一艘随机的宇宙飞船。</li></ul><p id="dd65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">空间复杂性:</p><ul class=""><li id="57f3" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated"><code class="fe mr ms mt mu b">key_list</code>的O(n)和<code class="fe mr ms mt mu b">key_mappings</code>的O(n)</li></ul><h2 id="1b9d" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">后续任务</h2><p id="0c9e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">尝试在关系数据库中实现相同的逻辑，在关系数据库中，飞船存储在一个表中。</p></div></div>    
</body>
</html>