<html>
<head>
<title>The Template Method Pattern in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的模板方法模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-template-method-pattern-in-python-72b7d6e95c96?source=collection_archive---------3-----------------------#2020-09-22">https://betterprogramming.pub/the-template-method-pattern-in-python-72b7d6e95c96?source=collection_archive---------3-----------------------#2020-09-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d507" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一种复用软件的简单技术，非常适合Python的半功能设计范式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bd525c547d678f1094ca46f4c0140fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5xQ4Pszg4vESnM8Z"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:<a class="ae kv" href="https://unsplash.com/@cdr6934" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>来自<a class="ae kv" href="https://unsplash.com/photos/ieic5Tq8YMk" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="4e6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你是不是一个Python开发人员，发现自己一遍又一遍地复制粘贴相同的代码，然后稍微修改一下就得到不同的函数？</p><p id="3ce9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在他的开创性著作《<a class="ae kv" href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882" rel="noopener ugc nofollow" target="_blank">干净的代码</a>》，<a class="ae kv" href="https://twitter.com/unclebobmartin" rel="noopener ugc nofollow" target="_blank">鲍伯·马丁</a>认为代码重复对任何应用程序来说都是非常不健康的，开发者应该尽一切努力避免代码重复。我将要向您介绍的模式是在面对仅在细节上不同的多个方法实现时可以做到这一点的方式之一。</p><p id="9c09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管这种技术在面向对象的社区中是众所周知的，但是像Java这样的语言的面向对象特性要求函数接口和lambda表达式形式的非平凡的样板代码开销来使模式工作。这通常会阻碍开发人员将模式投入使用，即使底层条件要求这样做。</p><p id="e5d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，Python对函数式编程范式的本地支持使得<em class="ls"> </em>模板方法模式的实现非常顺利，因此，当一个人有机会不使用它时，粉碎了所有可能的借口。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="1540" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">你将如何从这篇文章中受益？</h1><p id="ccfd" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">完成本文后，您将了解何时以及如何在Python中实现模板方法模式，以及如何为基于Python的应用程序编写更简洁、更易维护的代码。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="bfda" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">何时使用模板方法模式</h1><p id="cb50" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这种技术非常适合有几个函数的情况，每个函数都有一个小的自定义部分(即特定于该函数的代码)和一个相当大的公共部分(即所有函数共享的代码)。</p><p id="6fa6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设您正在构建一个机器学习应用程序，它从数据库中提取数据，然后根据已经训练好的不同模型计算预测。在这种情况下，每个函数将代表一个不同的模型，类似于<code class="fe mx my mz na b">predict_logistic_regression()</code>、<code class="fe mx my mz na b">predict_knn()</code>和<code class="fe mx my mz na b">predict_svm()</code>。</p><p id="6bfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">常见的部分可能是从数据库中提取数据，清理数据，从数据中构造一个特征集，一旦做出预测，就将这些数据存储回数据库。定制部分将是实际的结果预测代码，类似于:</p><p id="fe17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">y = model.predict(X)</code></p><p id="8a25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">model</code> <em class="ls"> </em>这里的<em class="ls"> </em>会因方法不同而不同。当函数的数量很大(3、4、5……)，公共部分很重要，而定制部分很小时，这种模式特别有效。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="d184" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">简单的例子</h1><p id="b400" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">遵循编程社区的最佳实践，让我们从一句“Hello，World！”用例。</p><h2 id="3325" class="nb mb iq bd mc nc nd dn mg ne nf dp mk lf ng nh mm lj ni nj mo ln nk nl mq nm bi translated">以前</h2><p id="e9b0" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">简单来说，我们有两个方法，每个方法都有两行公共部分和一行自定义部分。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在使用模板方法之前</p></figure><p id="9255" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行代码将产生:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/ece3199fe1c9a254be8d4e7bd80f7801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*6jt5JTa7VaBE1lzXYN3iPw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">脚本前输出</p></figure><p id="b67f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在成功地识别了两个函数的非平凡的公共部分之后，让我们看看如何将这个共享逻辑提取到一个模板方法中，以在保留原始功能的同时减少整个程序中的代码重复。</p><h2 id="6e0c" class="nb mb iq bd mc nc nd dn mg ne nf dp mk lf ng nh mm lj ni nj mo ln nk nl mq nm bi translated">在...之后</h2><p id="dd85" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这就是Python对函数式编程的支持发挥作用的地方。很酷的一点是，在Python中，函数可以像任何其他ole对象一样作为参数传递，没有任何额外的样板文件开销。</p><p id="2460" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们的模板方法将只是公共逻辑——在中间，我们运行作为参数传递的定制部分。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在使用模板方法之后</p></figure><p id="1af9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行代码验证结果是否与之前相同:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/fc921da6736b4025a49e81d314213686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*RGIMPY69zgWnBdasNm0m-g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">脚本前输出</p></figure><p id="7cff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看<code class="fe mx my mz na b">action_a</code>和<code class="fe mx my mz na b">action_b</code>的实现有多简单。如果您打算在将来添加更多的动作，您将能够专注于它们的定制部分，而不用担心，例如，关闭一个DB连接。</p><p id="815c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实证明，这是一个巨大的好处，尤其是在建设大型项目时。其实还有很多其他的好处，让我们仔细看看。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="db28" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">为什么要使用模板方法模式</h1><p id="9f38" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">出于我们分析的目的，让我们假设您的程序需要<em class="ls"> N </em>个不同的函数，每个函数都有一个自定义部分的<em class="ls"> X </em>行和一个公共部分的<em class="ls"> Y </em>行代码。</p><p id="37af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过实现该模式，除了让您感觉像个专家之外，您的应用程序还将从以下三个实实在在的好处中获益:</p><h2 id="f8dc" class="nb mb iq bd mc nc nd dn mg ne nf dp mk lf ng nh mm lj ni nj mo ln nk nl mq nm bi translated">需要编写的代码更少</h2><p id="903b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">假设你有五个函数，都有十行的通用部分和十行的自定义部分。你的程序有多少行？</p><p id="775a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">N * (X + Y) = 5 * (10 + 10) = 100</code></p><p id="f316" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，如果您将公共部分提取到模板方法中，那么您的程序将具有:</p><p id="cbc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">N * X + Y = 5*10 + 10 = 60</code></p><p id="de5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个显著的进步。当方法实现<em class="ls"> (N) </em>的数量增加时，节省的代码行数量变得更加明显。根据我的经验，这种情况经常发生。</p><h2 id="f96a" class="nb mb iq bd mc nc nd dn mg ne nf dp mk lf ng nh mm lj ni nj mo ln nk nl mq nm bi translated">需要维护的代码更少</h2><p id="e966" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在软件工程中，需求不断变化。想象一下，一个新的业务特性请求迫使您更改公共实现部分的五行代码。假设与上一段中的设置相同，如果这发生在您迁移到模板方法实现之前，您必须更改25行代码——5行代码位于5个不同的位置。</p><p id="7d70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用模板方法，您只需修改一次代码，也就是说，您只需在一个地方修改五行代码。这一点非常重要，因为每当你触摸某个正常工作的东西时，你就冒着它停止工作的风险。通常，在部署快速修复和新特性时，您希望最小化干预点。</p><p id="ba16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，请记住，当您接触<em class="ls"> N </em>不同的方法时，在理想世界中，您还应该为每一个<em class="ls"> N </em>方法添加适当的单元测试覆盖率。这不仅令人讨厌，而且你会创建更多的重复代码(<a class="ae kv" href="https://twitter.com/unclebobmartin" rel="noopener ugc nofollow" target="_blank">Bob叔叔</a>会不高兴的！).使用模板方法，您只需为公共部分编写一次单元测试。</p><h2 id="54ca" class="nb mb iq bd mc nc nd dn mg ne nf dp mk lf ng nh mm lj ni nj mo ln nk nl mq nm bi translated">需要记忆的代码更少</h2><p id="3522" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">例如，让我们假设一旦完成计算，每个<em class="ls"> N </em>方法都需要关闭一个数据库连接。这意味着，您需要在每个实现的末尾包含<code class="fe mx my mz na b">connection.close()</code>行。</p><p id="a427" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你曾经写过一个相当大的软件项目，你就会知道忘记包含这样一行代码是多么容易。您还知道，像这样的无意遗漏可能会导致幽灵般的错误，这些错误会在您最意想不到的时候悄悄出现，迫使您在将来花很长时间来查找和修复问题。</p><p id="c53d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在template method模式中，template方法用于封装来自自定义逻辑的样板文件，因此，它将您从枯燥的公共部分中解放出来。您只需在模板方法的末尾编写一次<code class="fe mx my mz na b">connection.close()</code>，您就可以完全忘记这一行，专注于自定义实现，这是大部分值所在的地方。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="200d" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">现实世界的例子</h1><p id="972b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">为了展示该模式在实践中的好处，让我们看一下我最近添加到我的交易引擎项目中的一个类。该类的目的是封装对外部交易API的调用，用于下单和取消订单等操作。</p><p id="7bb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每种方法都有一个重要的共同点。然后，这个复杂的逻辑被提取到一个<code class="fe mx my mz na b">__run_with_log(api_name, api_call)</code>模板方法中，这个逻辑包括登录到一个控制台，将日志存储到一个数据库中，以及在特定服务器响应的情况下处理重试。</p><p id="bf82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在每个API包装函数中，人们只关注准备特定的请求。实际的调用被委托给模板方法，这确保了枯燥但重要的样板代码得到执行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">真实世界的例子</p></figure><p id="fb24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意模板方法<code class="fe mx my mz na b">__run_with_log(api_name, api_call)</code>有多冗长。每当我添加一个新的API调用时，都必须复制并粘贴它，这有多烦人？我希望这能为该模式的有用性提供一个有说服力的案例。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="abd0" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="d84a" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">恭喜你！到目前为止，您已经准备好使用模板方法模式使您的Python代码更加整洁。如果您很乐意将新知识付诸实践，这里有一些示例用例供您探索:</p><ul class=""><li id="d1eb" class="nr ns iq ky b kz la lc ld lf nt lj nu ln nv lr nw nx ny nz bi translated"><strong class="ky ir">单元测试:</strong>测试环境初始化和模拟实例化进入模板方法</li><li id="3d23" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><strong class="ky ir">数据库访问:</strong>数据库连接的初始化和关闭进入模板</li><li id="0b3b" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><strong class="ky ir">详细日志记录:</strong>日志语句前后进入模板</li></ul><p id="3aca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您阅读我的文章。黑客快乐！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="0494" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">资源</h1><ul class=""><li id="796c" class="nr ns iq ky b kz ms lc mt lf of lj og ln oh lr nw nx ny nz bi translated"><a class="ae kv" href="https://github.com/TomasDavidYe/design-patterns-python/tree/master/template_method" rel="noopener ugc nofollow" target="_blank"> GitHub </a>本文</li><li id="be13" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">亚马逊上的<a class="ae kv" href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882" rel="noopener ugc nofollow" target="_blank">【干净代码</a></li><li id="6e68" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://twitter.com/unclebobmartin" rel="noopener ugc nofollow" target="_blank">罗伯特·c·马丁(鲍勃大叔)在推特上</a></li></ul></div></div>    
</body>
</html>