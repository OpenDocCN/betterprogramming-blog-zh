<html>
<head>
<title>The Guide I Wish I Had for JavaScript Object Creation Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我希望我有JavaScript对象创建模式的指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-guide-i-wish-i-had-for-js-object-creation-patterns-e0af3043993d?source=collection_archive---------7-----------------------#2020-11-03">https://betterprogramming.pub/the-guide-i-wish-i-had-for-js-object-creation-patterns-e0af3043993d?source=collection_archive---------7-----------------------#2020-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="de61" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于JavaScript中的对象创建，您需要知道的一切</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/489d3c7de4a6458c90c0e1da1150b7d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qdSCrV78vsfry0Dg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7777" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您正在学习JavaScript中的面向对象编程，您可能已经遇到过这些对象创建模式。对于试图锁定每种模式的心智模型、它们的优缺点以及如何对继承或财产委托建模的学生来说，本指南将非常有用。如果你是从<a class="ae kv" href="https://launchschool.com/" rel="noopener ugc nofollow" target="_blank">启动学校</a>开始的，在你完成第1-4课之前不要读这篇文章。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="444f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">对象工厂</h1><p id="4e95" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><em class="mw">对象工厂</em> <strong class="ky ir"> </strong>是返回对象的<strong class="ky ir"> </strong>函数，可用于自动创建对象。所有的对象都有相同的“类型”,也就是说它们有相同的状态属性和相同的方法，但是使用<code class="fe mx my mz na b">Object.getPrototypeOf</code>会返回<code class="fe mx my mz na b">Object.prototype/{}</code>,所以你不能确定你用了什么函数来构造实例对象。</p><p id="bf81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种模式有一些缺点，包括内存效率低，因为每个新实例都有所有方法的完整副本，并且无法检出用于创建对象的匹配原型对象(原型是通用对象)。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="323a" class="nf ma iq na b gy ng nh l ni nj">&gt; let cello = createInstrument("cello","squeak",500) <br/>&gt; Object.getPrototypeOf(cello) // {}</span></pre><p id="2c61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要编写一个对象工厂函数，需要声明一个函数，该函数接受构成对象状态的参数。在函数体中，<code class="fe mx my mz na b">return</code>一个对象字面量。应该使用下面的<code class="fe mx my mz na b">instrument</code>、<code class="fe mx my mz na b">noise</code>和<code class="fe mx my mz na b">value</code>的参数来设置属性，并且可以添加方法。总的来说，您正在创建使用该函数创建的对象的骨架版本，并且所有属性都将添加到使用该函数创建的每个新对象中，因此内存效率很低。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7105" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能还会看到用箭头函数表达式编写的这种模式。如果您选择这种语法，请记住将对象括在括号中。默认情况下，JavaScript假设您想在使用大括号<code class="fe mx my mz na b">{}</code>时创建一个函数体。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3a67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管关系建模和代码冗余存在缺陷，一些开发人员认为使用工厂函数和<em class="mw">混合插件</em>编码是理想的，因为继承不能对所有场景建模。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="fe3f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">具有混合功能的对象工厂</h1><p id="f98e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">使用具有混合功能的对象工厂有利于对没有明确的<em class="mw">“</em>是-a”<em class="mw"/>关系的对象进行建模。在下面的例子中，我们可以创建三种不同且不相关的对象类型——鸭嘴兽(又名鸭嘴兽或鸭嘴兽)、企鹅和人类——它们有一些共同的行为，但不能以任何方式进行子类化。不是在每个对象工厂的方法中复制代码，而是使用<code class="fe mx my mz na b">Object.assign</code>将<em class="mw">混合到</em>中，将所有可枚举的属性从源对象复制到目标对象中。</p><p id="953d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在代码中，<code class="fe mx my mz na b">details</code>、<code class="fe mx my mz na b">swim</code>和<code class="fe mx my mz na b">layEggs</code>都是具有属性值的对象。创建三种不同类型的对象有三个功能:<code class="fe mx my mz na b">createPlatypus</code>、<code class="fe mx my mz na b">createPenguin</code>和<code class="fe mx my mz na b">createHuman</code>。这三个函数可用于创建这些类型对象的新实例。</p><p id="82e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看一看<code class="fe mx my mz na b">createPlatypus</code>，我们看到该函数带有一个名称参数。在函数体中，<code class="fe mx my mz na b">Object.assign</code>用于将<code class="fe mx my mz na b">details</code>、<code class="fe mx my mz na b">swim</code>和<code class="fe mx my mz na b">layEggs</code>对象的可枚举属性赋给一个空对象。在这三个对象的属性被复制到新对象之后，它使用<code class="fe mx my mz na b">addDetails</code>方法，当我们使用<code class="fe mx my mz na b">Object.assign</code>方法复制可枚举属性时，它被从<code class="fe mx my mz na b">details</code>对象复制到<code class="fe mx my mz na b">createPlatypus</code>。因此，它用name属性和来自<code class="fe mx my mz na b">details</code>、<code class="fe mx my mz na b">swim</code>和<code class="fe mx my mz na b">layEggs</code>对象的方法创建了一个新的platypus对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5bae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您检查从这些函数实例化的对象的属性，您认为您会看到什么？</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="2f64" class="nf ma iq na b gy ng nh l ni nj">&gt; let platypus = createPlatypus("platypus");<br/>&gt; let penguin = createPenguin("penguin");<br/>&gt; let human = createHuman("human");<br/>&gt; human<br/>{ displayDetails: [Function: displayDetails], swim: [Function: swim], name: 'human' }<br/>&gt; penguin<br/>{ displayDetails: [Function: displayDetails], swim: [Function: swim], layEggs: [Function: layEggs], name: 'penguin' }<br/>&gt; platypus<br/>{ displayDetails: [Function: displayDetails], swim: [Function: swim], layEggs: [Function: layEggs], name: 'platypus'}</span></pre><p id="95ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe mx my mz na b">addDetails</code>方法的使用令人困惑，这里有另一个版本，我们在函数本身中设置细节。请注意，在这些函数中，执行上下文将是全局对象，但是我们可以使用一个赋给变量的空对象来局部添加一些属性，如第22–25行所示。</p><p id="2674" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请看下面的第30–32行，这里发生的事情是我们使用<code class="fe mx my mz na b">Object.assign</code>方法将属性从<code class="fe mx my mz na b">details</code>、<code class="fe mx my mz na b">swim</code>和<code class="fe mx my mz na b">layEggs</code>对象复制到目标中，这是一个空对象<code class="fe mx my mz na b">{}</code>。然后我们链接另一个方法调用，使用对象现在拥有的<code class="fe mx my mz na b">addDetails</code>，并添加我们在函数调用中传递的<code class="fe mx my mz na b">name</code>参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1c5c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">构造器模式</h1><p id="5140" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><em class="mw">构造器模式</em>利用<code class="fe mx my mz na b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="noopener ugc nofollow" target="_blank">new</a></code> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="noopener ugc nofollow" target="_blank">操作符</a>和一个函数来创建新对象。当用<code class="fe mx my mz na b">new</code>操作符/关键字调用一个函数时，它变成一个构造函数，一些事情在幕后发生。下面的代码片段描述了这些步骤:</p><ul class=""><li id="57bf" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated"><code class="fe mx my mz na b">clarinet</code>变量被分配给一个新对象，该对象是通过使用<code class="fe mx my mz na b">new</code>操作符调用<code class="fe mx my mz na b">Instrument</code>构造函数创建的。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/b37134c0f73b35fab4f51ee1d67a29a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/0*o0EddqRVLJJR9abM.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><ul class=""><li id="f430" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated"><code class="fe mx my mz na b">clarinet</code>对象的<code class="fe mx my mz na b">[[Prototype]]</code> / <code class="fe mx my mz na b">__proto__</code>属性被设置为构造函数的原型。</li><li id="6221" class="nm nn iq ky b kz nw lc nx lf ny lj nz ln oa lr nr ns nt nu bi translated">函数执行<code class="fe mx my mz na b">(this)</code>的执行上下文指向新对象。</li><li id="fa34" class="nm nn iq ky b kz nw lc nx lf ny lj nz ln oa lr nr ns nt nu bi translated">构造函数执行。</li><li id="3f7e" class="nm nn iq ky b kz nw lc nx lf ny lj nz ln oa lr nr ns nt nu bi translated">新对象被返回。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8690" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">具有原型的构造函数(伪经典模式)</h1><p id="d30f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在JavaScript中，函数有一个<code class="fe mx my mz na b">prototype</code>属性，该属性有一个<code class="fe mx my mz na b">constructor</code>属性指向函数。对于对象实例，由<code class="fe mx my mz na b">new functionName()</code>实例化的对象的实际原型(<code class="fe mx my mz na b">__proto__</code>属性)指向用于构造该对象的函数<code class="fe mx my mz na b">functionName.prototype</code>的<code class="fe mx my mz na b">prototype</code>属性。</p><p id="cd34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避免在每个新构造的对象上定义函数，可以将函数添加到<code class="fe mx my mz na b">Instrument.prototype</code>中，这样实例调用的方法可以委托给<code class="fe mx my mz na b">Instrument</code>的<code class="fe mx my mz na b">prototype</code>属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="512f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该图表+视频概述有助于展示这一切意味着什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/55f9a6a747f65ec4d3d0a613907eaea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zeNVX5WIMRKENooaa0o2pg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc nl l"/></div></figure><p id="c3b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要区分的主要内容是我们的<code class="fe mx my mz na b">Instrument</code>函数上的<code class="fe mx my mz na b">prototype</code>属性/对象与实例对象的原型之间的区别，后者通过内部的<code class="fe mx my mz na b">[[Prototype]]</code> / <code class="fe mx my mz na b">__proto__</code>属性链接。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/459eb24688cb68a68bc6a971bcaed25b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XcLV2Ml0QKtiSd1D.png"/></div></div></figure><p id="52df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用伪经典模式代替对象工厂函数有几个主要优点。</p><ol class=""><li id="7a57" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr oe ns nt nu bi translated">现在，您可以对对象之间的关系进行建模。</li><li id="b7f8" class="nm nn iq ky b kz nw lc nx lf ny lj nz ln oa lr oe ns nt nu bi translated">共享行为存在于原型中，并被委托而不是被复制到每个新对象中。</li><li id="ddd3" class="nm nn iq ky b kz nw lc nx lf ny lj nz ln oa lr oe ns nt nu bi translated">如果您需要修改原型中的行为/方法，它会自然地反映出来，您不需要编辑您的对象。</li></ol></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="985c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">伪经典模式的继承</h1><p id="49c6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">伪经典是指构造函数继承如何模仿其他OOP语言中的类。</p><p id="054c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在伪经典继承中，一个构造函数的原型继承自另一个构造函数的原型，即子类型继承自超类型。</p><p id="d66a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在代码中，<code class="fe mx my mz na b">StringInstrument</code>构造函数创建的所有对象都继承自<code class="fe mx my mz na b">StringInstrument.prototype</code>，而T5又继承自<code class="fe mx my mz na b">Instrument.prototype</code>。因此，所有的弦乐器对象都可以访问来自<code class="fe mx my mz na b">Instrument.prototype</code>的方法。</p><p id="8dfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果来自<code class="fe mx my mz na b">Instrument.prototype</code>的方法需要被修改以与<code class="fe mx my mz na b">StringInstrument.prototype</code>一起工作，我们可以在<code class="fe mx my mz na b">StringInstrument.prototype</code>对象上用相同的方法属性名称定义它，这样它共享一个接口，即该方法可以在任一对象上被调用并返回预期的输出。</p><p id="d4ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的代码中，我们创建了两个函数，<code class="fe mx my mz na b">Instrument</code>和<code class="fe mx my mz na b">StringInstrument</code>。为了设置<code class="fe mx my mz na b">prototype</code>属性，我们在第16行使用<code class="fe mx my mz na b">Object.create()</code>。为什么我们要创建一个新的对象？如果我们将<code class="fe mx my mz na b">Instrument</code>函数的现有原型分配给<code class="fe mx my mz na b">StringInstrument</code>函数的<code class="fe mx my mz na b">prototype</code>属性，我们将不再有继承结构，因为原型对象在内存中是相同的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1899" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要做什么:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="c5cc" class="nf ma iq na b gy ng nh l ni nj">. // code omitted for brevity<br/>.<br/>.<br/>StringInstrument.prototype = Instrument.prototype; // <strong class="na ir">DON'T DO THIS</strong></span><span id="e6ae" class="nf ma iq na b gy of nh l ni nj">StringInstrument.prototype.tuneStrings = function() {             <br/>    console.log("I have strings.")<br/>}</span><span id="f18c" class="nf ma iq na b gy of nh l ni nj">let oboe = new Instrument("oboe","squeaky squeak");<em class="mw">// Oboe will think it is both a string instrument + an instrument</em></span><span id="3f1f" class="nf ma iq na b gy of nh l ni nj">oboe.tuneStrings(); // I have strings. =&gt; should be a TypeError<br/>console.log(oboe instanceof StringInstrument); // true =&gt; should be false</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ea74" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">设置继承链的另一种方式</h1><p id="f87a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果你看看你在<code class="fe mx my mz na b">Instrument</code>和<code class="fe mx my mz na b">StringInstrument</code>函数中设置的属性，你会发现它们是相似的。这表明您可以在<code class="fe mx my mz na b">StringInstrument</code>中使用<code class="fe mx my mz na b">Instrument</code>构造函数。为此，调用<code class="fe mx my mz na b">Instrument</code>，将其执行上下文显式设置为<code class="fe mx my mz na b">StringInstrument</code>的执行上下文，如下面的函数方法<code class="fe mx my mz na b">call</code>所示。第一个参数是<code class="fe mx my mz na b">this</code>，然后传递任意数量的参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="ac4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是相同的内容，但使用了ES6类语法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5e62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance#ECMAScript_2015_Classes" rel="noopener ugc nofollow" target="_blank"> MDN docs </a>有一个很好的概述，所以在这里它被改编成上面的代码:</p><ul class=""><li id="6445" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated"><code class="fe mx my mz na b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor" rel="noopener ugc nofollow" target="_blank">constructor()</a></code>方法定义了表示我们的<code class="fe mx my mz na b">Instrument</code>类的构造函数。</li><li id="3c70" class="nm nn iq ky b kz nw lc nx lf ny lj nz ln oa lr nr ns nt nu bi translated"><code class="fe mx my mz na b">play()</code>是类方法。任何你想与类关联的方法都在构造函数后面的类中定义。</li><li id="80af" class="nm nn iq ky b kz nw lc nx lf ny lj nz ln oa lr nr ns nt nu bi translated">对于子类，新分配的对象的<code class="fe mx my mz na b">this</code>初始化总是依赖于父类构造函数，也就是你正在扩展的类的构造函数。</li><li id="34bd" class="nm nn iq ky b kz nw lc nx lf ny lj nz ln oa lr nr ns nt nu bi translated">这里我们扩展了<code class="fe mx my mz na b">Instrument</code>类——<code class="fe mx my mz na b">StringInstrument</code>子类是<code class="fe mx my mz na b">Instrument</code>类的扩展。所以对于<code class="fe mx my mz na b">StringInstrument</code>，<code class="fe mx my mz na b">this</code>的初始化是由<code class="fe mx my mz na b">Instrument</code>构造函数完成的。</li><li id="b051" class="nm nn iq ky b kz nw lc nx lf ny lj nz ln oa lr nr ns nt nu bi translated">要调用父构造函数，我们必须使用<code class="fe mx my mz na b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super" rel="noopener ugc nofollow" target="_blank">super()</a></code> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super" rel="noopener ugc nofollow" target="_blank">运算符</a>。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a751" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">链接到其他对象的对象(OLOO)</h1><p id="3ead" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">OLOO只关心与其他对象相关联的对象。OLOO是一种委托模式，而不是继承模式。我们看什么对象想要委托给其他对象。OLOO对象不使用构造函数或<code class="fe mx my mz na b">.prototype</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8541" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你用变量名称<code class="fe mx my mz na b">cello</code>赋值为<code class="fe mx my mz na b">let cello = Object.create(instrumentPrototype)</code>用<code class="fe mx my mz na b">Object.create()</code>实例化一个新对象，这个对象当前没有属性。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="5e0b" class="nf ma iq na b gy ng nh l ni nj">&gt; cello // {}</span></pre><p id="4feb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用OLOO模式完成对象的初始化，请使用prototype对象的初始化方法。通常使用<code class="fe mx my mz na b">init</code>作为初始化方法的名称，但这不是必需的。当您使用<code class="fe mx my mz na b">object.create</code>创建一个新对象时，您作为参数传递的对象是新对象的预期原型，所以现在来自<code class="fe mx my mz na b">instrumentPrototype</code>对象的所有方法都可以通过属性委托提供给<code class="fe mx my mz na b">cello</code>对象。</p><p id="ece8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用<code class="fe mx my mz na b">Object.getOwnPropertyNames(obj)</code>来验证这些方法没有被复制到新对象中。</p><p id="051e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这种模式非常类似于对象工厂，我们可以把它比作对象工厂。与对象工厂相比，OLOO的主要优势是内存效率。用OLOO模式创建的所有对象都从原型对象继承方法，而工厂函数将方法复制到用工厂函数创建的每个新对象中。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="03ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我知道如果你有任何进一步的问题，我可以写回信或添加更多的文章！</p></div></div>    
</body>
</html>