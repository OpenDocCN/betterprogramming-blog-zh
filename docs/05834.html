<html>
<head>
<title>What You Need to Know to Get Your Apps Ready for Android 11</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让你的应用为Android 11做好准备你需要知道什么</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-you-need-to-know-to-get-your-apps-ready-for-android-11-de54f1578ee4?source=collection_archive---------12-----------------------#2020-08-10">https://betterprogramming.pub/what-you-need-to-know-to-get-your-apps-ready-for-android-11-de54f1578ee4?source=collection_archive---------12-----------------------#2020-08-10</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="7b36" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">面向开发者的Android 11清单</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/d807bb36ee5e04f2a65437fa9e4939d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TlpNhDR4J3MeaAPv"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@christianw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯蒂安·威迪格</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b8ba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Android 11目前处于测试阶段，计划于2020年第三季度公开发布。</p><p id="e529" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">从能够支持设备录音的原生屏幕记录器，到预定的黑暗模式和以气泡形式查看消息通知，Android R今年将推出许多令人兴奋的新变化。</p><p id="7150" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">隐私一直是下一次Android更新的主要焦点，这意味着开发者的工作已经被削减了。</p><p id="efce" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在接下来的几节中，我将带你浏览一份清单，供你在为Android 11发布下一款应用时参考。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="fb2f" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">权限现在有了'<strong class="ak">只有这一次'选项</strong></h1><p id="54ab" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Android 11提升了其权限模型，包括一次性权限，让用户可以更精细地控制他们的位置、摄像头、麦克风和其他系统权限访问。</p><p id="785e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这意味着如果用户关闭应用程序并重新打开它，权限对话框将在访问相关系统控件之前再次提示。</p><p id="1923" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">值得注意的是，如果用户将你的应用程序放在后台，在活动或服务运行时，权限仍然会保持不变。</p><p id="9517" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这使得处理系统资源访问变得更加重要，因为它可以随时被终止。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj na"><img src="../Images/0436b56930f756606b20552a9e20c7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*1fn09rs_0omJI6Fo9rdD_A.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://developer.android.com/preview/privacy/location" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="746a" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">系统现在将自动撤销未使用应用程序的权限，并在重复“拒绝”时隐藏对话框</h1><p id="c348" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Android 11系统现在更加强调数据和隐私。几个月没有使用某个应用程序的用户可能不知道它过去被授予的权限。</p><p id="9aed" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，为了让用户更有意识地控制他们的资源，系统会自动重置所有未使用的应用程序的权限。</p><p id="6973" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这样做的时候，开发者可能会遇到后台服务的障碍，这些后台服务需要这些权限来执行同步数据或获取位置等任务。</p><p id="fbd7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">幸运的是，您可以从设置中通知用户禁用权限的自动撤销。你需要做的就是使用<code class="fe nb nc nd ne b"><a class="ae kz" href="https://developer.android.com/reference/android/content/Intent#ACTION_AUTO_REVOKE_PERMISSIONS" rel="noopener ugc nofollow" target="_blank">Intent.ACTION_AUTO_REVOKE_PERMISSIONS</a></code>启动一个意向到应用的设置页面。</p><p id="b394" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，调用<code class="fe nb nc nd ne b">isAutoRevokeWhitelisted()</code>方法来确定应用程序权限的状态。</p><p id="718a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Android 11运行时权限流的另一个重要变化是引入了隐式的“不要再问”。直到Android 10，开发者可以在每次用户按下拒绝键时提示许可请求。现在，如果用户连续多次点击拒绝<strong class="lc iv"> </strong>来获得特定的权限，这个动作意味着“不要再问了”</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="0745" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">单独的后台位置权限</h1><p id="a4c9" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Android 11中你需要解决的第三个大变化是后台位置权限的处理。</p><p id="3d86" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们知道Android 10需要在清单中定义一个新的权限<code class="fe nb nc nd ne b">ACCESS_BACKGROUND_LOCATION</code>来请求后台位置。</p><p id="a4ba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Android 11现在带来了一个新的流程，其中要求开发人员对后台位置的使用进行更多的描述。这意味着使用<code class="fe nb nc nd ne b">ACCESS_FINE_LOCATION</code> <strong class="lc iv"> </strong>或<strong class="lc iv"> </strong> <code class="fe nb nc nd ne b">ACCESS_COARSE_LOCATION</code>调用的权限请求对话框将只允许在使用应用程序时访问位置。</p><p id="c139" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于后台定位请求，您必须使用<code class="fe nb nc nd ne b">ACCESS_BACKGROUND_LOCATION</code>单独调用<code class="fe nb nc nd ne b">requestPermission</code>方法。这将把用户带到应用程序的设置页面，在那里他们可以允许它。“设置”页面现在显示了一个新选项，“允许所有时间”，如果用户选择授予完整位置访问权限。</p><p id="0b18" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">需要注意的是，同时调用前台和后台位置请求或者在前台请求之前调用<code class="fe nb nc nd ne b">ACCESS_BACKGROUND_LOCATION</code>将被系统忽略。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="6c4b" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">包可见性限制</h1><p id="f81c" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Android 11通过强迫开发者指定他们希望明确交互的应用程序来提升隐私。</p><p id="5b40" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为此，您需要在清单文件中的新的<code class="fe nb nc nd ne b">&lt;queries&gt;</code>元素内指定这些应用程序的<code class="fe nb nc nd ne b">&lt;package&gt;</code>名称。但是您也可以指定<code class="fe nb nc nd ne b">&lt;intent&gt;</code>类别来允许访问一组应用程序。</p><p id="e998" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，为了访问设备上的所有应用程序，您需要在清单文件中指定以下内容。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nf"><img src="../Images/2a4661f4a09d00290e02a03ef29f86ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Ahq8U0rPYkH4BMYTKOV5Q.png"/></div></div></figure><p id="68ab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在Android 11中调用<code class="fe nb nc nd ne b">queryIntentActivities()</code>只会返回那些在<code class="fe nb nc nd ne b">queries</code>中定义的应用。</p><p id="d476" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您的应用程序属于浏览器、启动器或安全应用程序，您可能希望访问已安装设备上的所有应用程序，而不是每次都手动添加查询和更新您的应用程序。在这种情况下，需要指定一个新的权限<code class="fe nb nc nd ne b">android.permission.QUERY_ALL_PACKAGES</code>。</p><p id="ffc0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意，如果你使用隐式意图与其他应用程序交互，Android 11中的上述包可见性限制不会影响你的应用程序。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="7a1a" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">改进的范围存储实现</h1><p id="6e83" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在Android 10引入作用域存储之前，开发人员可以读取系统存储中的敏感数据，也可以在任何地方写入文件，这导致了存储混乱，因为即使在应用程序卸载后，文件也会保留。</p><p id="3e8f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">引入作用域存储是为了防止开发人员滥用完全存储访问。它确保每个应用程序都有自己指定的目录。</p><p id="17ff" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是在发布的时候，作用域存储要求你使用<a class="ae kz" href="https://developer.android.com/guide/topics/providers/document-provider" rel="noopener ugc nofollow" target="_blank">存储访问框架</a>来访问你的应用目录之外的文件。从本质上讲，<strong class="lc iv"> </strong> <code class="fe nb nc nd ne b">java.io.File</code> API不再工作了。这导致了开发者社区的强烈反对。像批量删除文件这样的事情变得很麻烦—用户必须手动确认对系统中每个文件的访问。</p><p id="d9c5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但令人高兴的是，在Android 10中，作用域存储实现成为可选的。您可以在清单中指定<code class="fe nb nc nd ne b">android:requestLegacyExternalStorage=true</code>来退出它。</p><p id="1692" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是从Android 11开始，使用作用域存储现在是强制性的。</p><p id="6bfe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，Android通过重新引入<code class="fe nb nc nd ne b">java.io.File</code> API使得直接访问文件路径变得更加方便。</p><p id="4d9e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">还有，Android 11带来了新的媒体商店API进行批处理:<code class="fe nb nc nd ne b">createWriteRequest()</code>、<code class="fe nb nc nd ne b">createTrashRequest()</code>、<code class="fe nb nc nd ne b">createFavoriteRequest()</code>。要了解更多信息，请参考“<a class="ae kz" href="https://developer.android.com/preview/privacy/storage" rel="noopener ugc nofollow" target="_blank">Android 11中的存储更新</a>”</p><p id="834a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">回收站请求引入了一种新的隐藏回收站机制，在完全删除文件之前，将已删除的文件在系统中保留一段定义的时间。</p><p id="b9a2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">需要完全填充权限的应用程序(如第三方安装程序)需要在<code class="fe nb nc nd ne b">AndroidManifest.xml</code>文件中指定新的<code class="fe nb nc nd ne b"><a class="ae kz" href="https://developer.android.com/reference/android/Manifest.permission#MANAGE_EXTERNAL_STORAGE" rel="noopener ugc nofollow" target="_blank">MANAGE_EXTERNAL_STORAGE</a></code>权限。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="ae48" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">新对话通知</h1><p id="ed97" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">通知是当今每个应用程序不可或缺的一部分。Android 11现在带来了聊天消息通知的专用部分。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ng"><img src="../Images/46dad2a14639c41bfcf2d924bf1e26b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*PPql5bqqCvWhUdsmwtNPtw.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://developer.android.com/preview/features/conversations" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="298e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您的应用程序包含聊天功能，您需要确保将相应的通知设置为<code class="fe nb nc nd ne b"><a class="ae kz" href="https://developer.android.com/reference/android/app/Notification.MessagingStyle" rel="noopener ugc nofollow" target="_blank">MessagingStyle</a></code>，以便在对话空间中显示它。</p><p id="678e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，为了确保对话通知可以显示为气泡，您需要为该通知设置一个关联的<code class="fe nb nc nd ne b">shortcutId</code>。</p><p id="2402" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对话通知还提供了一些快捷功能，如暂停、自动回复和优先处理特定聊天。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="9636" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">主屏幕上的拜拜祝酒词和API变化</h1><p id="636e" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">敬酒已经存在很长时间了。尽管出现了小吃，但祝酒词仍被大量使用和滥用。例如，由于祝酒词不需要绑定到某个活动，开发人员甚至可以在应用程序处于后台时显示它们。</p><p id="290e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Android 11已经完全屏蔽了从后台发送时显示自定义祝酒词的功能。</p><p id="497f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，文本祝酒不再支持<code class="fe nb nc nd ne b">setView</code>。对它们执行<code class="fe nb nc nd ne b">getView()</code>将返回null。</p><p id="6d89" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们不能再为祝酒词文本设置边距和重力。</p><p id="3be6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Android 11中Toasts API的一个重要新增功能是新的<code class="fe nb nc nd ne b">addCallback()</code>方法来监听toast的出现和消失。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="86e6" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="26c7" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Android 11注重隐私，尽管包可见性限制不会真正防止应用程序不交互，但其余大部分功能都是为了提高Android应用程序的安全性。</p><p id="62a4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">希望你顺利迁移到Android 11。</p><p id="e81a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一次到此为止。感谢阅读。</p></div></div>    
</body>
</html>