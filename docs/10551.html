<html>
<head>
<title>Preventing Smart Contract Attacks on Ethereum — Reentrancy attack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">防止以太坊上的智能合约攻击——重入攻击</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/preventing-smart-contract-attacks-on-ethereum-a-code-analysis-bf95519b403a?source=collection_archive---------6-----------------------#2022-01-14">https://betterprogramming.pub/preventing-smart-contract-attacks-on-ethereum-a-code-analysis-bf95519b403a?source=collection_archive---------6-----------------------#2022-01-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="37de" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们编写一个易受攻击的智能合约代码，看看攻击是如何工作的，并了解修复它的预防技术</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cb4d481c7659914f51d0eb6d1dae219a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*adLy0yMz2hdhZKFokpQ2bw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://undraw.co/" rel="noopener ugc nofollow" target="_blank"> Undraw </a></p></figure><p id="6d14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以太坊智能合约的一个特性是它们能够调用和利用来自其他外部合约的代码。</p><p id="7554" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">契约通常也处理以太网，因此经常将以太网发送到各种外部用户地址。这些操作要求合同提交外部调用。这些外部调用可能会被攻击者劫持，攻击者可以强制契约执行进一步的代码(通过回退功能)，包括对自身的调用。</p><p id="9d64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种攻击在臭名昭著的<a class="ae kv" href="http://bit.ly/2DamSZT" rel="noopener ugc nofollow" target="_blank">道黑</a>中使用过。</p><h1 id="eb7d" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">了解漏洞</h1><p id="dfda" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">当合同向未知地址发送以太网时，可能会发生这种类型的攻击。攻击者可以在回退函数中包含恶意代码的外部地址处精心构造一个协定。</p><p id="2b74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，当一个契约向这个地址发送以太网时，它将调用恶意代码。通常，恶意代码对易受攻击的协定执行功能，执行开发人员不期望的操作。</p><p id="3d59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">术语“可重入性”来源于这样一个事实，即外部恶意契约调用易受攻击契约上的函数，代码执行的路径“重入”它。</p><p id="ebb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了澄清这一点，考虑一下<code class="fe mr ms mt mu b">EtherStore.sol</code>中的简单易受攻击合同，它充当了一个以太坊金库，允许储户每周只提取1个以太:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">以太商店. sol</p></figure><p id="dcc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个契约有两个公共函数，<code class="fe mr ms mt mu b">depositFunds</code>和<code class="fe mr ms mt mu b">withdrawFunds</code>。</p><p id="a52d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">depositFunds</code>功能只是增加发送者的余额。</p><p id="7d19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">withdrawFunds</code>功能允许汇款人指定提取的<code class="fe mr ms mt mu b">wei</code>金额。</p><p id="33ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只有当要求提取的金额小于1乙醚且上周未发生提取时，此功能才会成功。</p><p id="de7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">漏洞在第17行，合同在这里向用户发送他们请求的乙醚量。</p><p id="6671" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑在<code class="fe mr ms mt mu b">Attack.sol</code>中创建了合同的攻击者:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Attack.sol</p></figure><p id="d7b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该漏洞是如何发生的？</p><p id="e667" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，攻击者将使用<code class="fe mr ms mt mu b">EtherStore</code>的契约地址作为唯一的构造函数参数来创建恶意契约(假设在地址<code class="fe mr ms mt mu b">0x0… 123</code>)。</p><p id="b656" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将初始化并将公共变量<code class="fe mr ms mt mu b">etherStore</code>指向要攻击的契约。</p><p id="09f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">攻击者随后会调用<code class="fe mr ms mt mu b">attackEtherStore</code>函数，其中一些以太量大于或等于1——我们暂时假设1个以太。</p><p id="5188" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，我们还将假设许多其他用户已将乙醚存入此合同，因此其当前余额为10乙醚。然后会发生以下情况:</p><ol class=""><li id="dcaf" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated"><code class="fe mr ms mt mu b">Attack.sol</code>的第15行:<code class="fe mr ms mt mu b">EtherStore</code>合约的<code class="fe mr ms mt mu b">depositFunds</code>函数会用1乙醚(和大量气体)的<code class="fe mr ms mt mu b">msg.value</code>调用。发送方(<code class="fe mr ms mt mu b">msg.sender</code>)将是恶意契约(<code class="fe mr ms mt mu b">0x0… 123</code>)。由此，<code class="fe mr ms mt mu b">balances[0x0..123] = 1 ether</code>。</li><li id="5554" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><code class="fe mr ms mt mu b">Attack.sol</code>的第17行:恶意契约然后会调用<code class="fe mr ms mt mu b">EtherStore</code>契约的<code class="fe mr ms mt mu b">withdrawFunds</code>函数，参数为1 ether。这将通过所有要求(<code class="fe mr ms mt mu b">EtherStore</code>合同的第12-16行),因为之前没有提款。</li><li id="5490" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><code class="fe mr ms mt mu b">EtherStore.sol</code>的第17行:契约将1以太送回恶意契约。</li><li id="aaae" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><code class="fe mr ms mt mu b">Attack.sol</code>的第25行:对恶意契约的支付随后会执行回退功能。</li><li id="7829" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><code class="fe mr ms mt mu b">Attack.sol</code>的第26行:<code class="fe mr ms mt mu b">EtherStore</code>合约的总余额是10以太，现在是9以太，所以这个if语句通过。</li><li id="25bf" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><code class="fe mr ms mt mu b">Attack.sol</code>的第27行:fallback函数再次调用<code class="fe mr ms mt mu b">EtherStore</code> <code class="fe mr ms mt mu b">withdrawFunds</code>函数，并‘重新输入’契约<code class="fe mr ms mt mu b">EtherStore</code>。</li><li id="14c8" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><code class="fe mr ms mt mu b">EtherStore.sol</code>的第11行:在对<code class="fe mr ms mt mu b">withdrawFunds</code>的第二次调用中，攻击合同的余额仍为1以太，因为第18行尚未执行。因此，我们还有<code class="fe mr ms mt mu b">balances[0x0..123] = 1 ether</code>。对于<code class="fe mr ms mt mu b">lastWithdrawTime</code>变量也是如此。同样，我们通过了所有的要求。</li><li id="667c" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><code class="fe mr ms mt mu b">EtherStore.sol</code>的第17行:攻击契约再撤回1以太。</li><li id="43c1" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">重复步骤4-8，直到<code class="fe mr ms mt mu b">EtherStore.balance &gt; 1</code>不再出现，如<code class="fe mr ms mt mu b">Attack.sol</code>中第26行所示。</li><li id="e382" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><code class="fe mr ms mt mu b">Attack.sol</code>的第26行:一旦<code class="fe mr ms mt mu b">EtherStore</code>契约还剩1(或更少)个以太，这个if语句就失效了。这将允许执行<code class="fe mr ms mt mu b">EtherStore</code>契约的第18行和第19行(对于每个对<code class="fe mr ms mt mu b">withdrawFunds</code>函数的调用)。</li><li id="3f15" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><code class="fe mr ms mt mu b">EtherStore.sol</code>，第18和19行:余额和<code class="fe mr ms mt mu b">lastWithdrawTime</code>映射将被设置，执行将结束。</li></ol><p id="2add" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终结果是攻击者在一次交易中从<code class="fe mr ms mt mu b">EtherStore</code>合同中提取了除1个以太网之外的所有以太网。</p><h1 id="efbf" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">预防技术</h1><p id="11e1" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">有许多常见的技术有助于避免智能契约中潜在的可重入性漏洞。</p><p id="7663" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个是(只要有可能)在向外部契约发送ether时使用内置的<a class="ae kv" href="http://bit.ly/2Ogvnng" rel="noopener ugc nofollow" target="_blank"> transfer </a>函数。传递函数只随外部调用发送2300 gas，不足以让目的地址/契约调用另一个契约(即重新输入发送契约)。</p><p id="7a40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二种技术是确保所有改变状态变量的逻辑在以太被送出契约(或任何外部调用)之前发生。在<code class="fe mr ms mt mu b">EtherStore</code>示例中，<code class="fe mr ms mt mu b">EtherStore.sol</code>的第18行和第19行应放在第17行之前。</p><p id="9b9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于任何执行对未知地址的外部调用的代码来说，最好将它作为本地化函数或代码执行中的最后一个操作。这就是所谓的<a class="ae kv" href="http://bit.ly/2EVo70v" rel="noopener ugc nofollow" target="_blank">检查-效果-交互模式</a>。</p><p id="8e12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第三种技术是引入互斥体——即添加一个状态变量，在代码执行期间锁定契约，防止可重入调用。</p><p id="a372" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对<code class="fe mr ms mt mu b">EtherStore.sol</code>应用所有这些技术(使用所有这三种技术是不必要的，但是我们这样做是为了演示的目的),给出了可重入自由契约:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">以太商店. sol</p></figure></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="a280" class="lu lv iq bd lw lx ns lz ma mb nt md me jw nu jx mg jz nv ka mi kc nw kd mk ml bi translated">故事时间</h1><p id="10e6" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">DAO(去中心化自治组织)攻击是以太坊早期发展中发生的主要黑客攻击之一。</p><p id="f450" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当时，该合同价值超过1.5亿美元。重入性在攻击中发挥了主要作用，最终导致了创造以太坊经典(ETC)的硬分叉。为了更好地分析DAO漏洞，请查看这个博客。</p><p id="3410" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多关于以太坊的分叉历史，DAO hack时间线，以及ETC在硬分叉中的诞生的信息可以在(<code class="fe mr ms mt mu b"><a class="ae kv" href="https://github.com/ethereumbook/ethereumbook/blob/develop/09smart-contracts-security.asciidoc#ethereum_standards" rel="noopener ugc nofollow" target="_blank">ethereum_standards</a>).</code></p></div></div>    
</body>
</html>