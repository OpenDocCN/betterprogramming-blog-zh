<html>
<head>
<title>How to Design Software in a Clean Architecture Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何以一种干净的架构方式设计软件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-design-in-clean-architecture-way-part-1-36c3e558517b?source=collection_archive---------14-----------------------#2022-01-24">https://betterprogramming.pub/how-to-design-in-clean-architecture-way-part-1-36c3e558517b?source=collection_archive---------14-----------------------#2022-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e191" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看一下面向数据的设计方法</h2></div><ul class=""><li id="d052" class="kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">第一部分，<a class="ae kx" href="https://lazypro.medium.com/how-to-design-in-clean-architecture-way-part-1-36c3e558517b" rel="noopener">面向数据的设计</a></li><li id="2149" class="kf kg iq kh b ki ky kk kz km la ko lb kq lc ks kt ku kv kw bi translated">第二部分，<a class="ae kx" href="https://lazypro.medium.com/how-to-design-in-clean-architecture-way-part-2-8524e76f2720" rel="noopener">领域驱动设计</a></li></ul><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/1e48520d34c85fd733748527d792ab6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/0*fdnh2MllxpiW0mcK.jpg"/></div><p class="ll lm gj gh gi ln lo bd b be z dk translated">洋葱建筑</p></figure><p id="b353" class="pw-post-body-paragraph lp lq iq kh b ki kj jr lr kk kl ju ls km lt lu lv ko lw lx ly kq lz ma mb ks ij bi translated">关于<em class="mc">清洁架构</em>的文章和书籍很多，但重点是为什么和什么，比如为什么要用一个洋葱架构，每一层代表什么，<code class="fe md me mf mg b">SOLID</code>原理是什么。</p><p id="3c29" class="pw-post-body-paragraph lp lq iq kh b ki kj jr lr kk kl ju ls km lt lu lv ko lw lx ly kq lz ma mb ks ij bi translated">但是开发者其实更想关注的是如何，也就是如何根据那些设计原则写出一个好的程序架构。</p><p id="05ce" class="pw-post-body-paragraph lp lq iq kh b ki kj jr lr kk kl ju ls km lt lu lv ko lw lx ly kq lz ma mb ks ij bi translated">在本文中，我们试图用一种干净的架构方式来解决一个常见的架构问题。</p><p id="d337" class="pw-post-body-paragraph lp lq iq kh b ki kj jr lr kk kl ju ls km lt lu lv ko lw lx ly kq lz ma mb ks ij bi translated">很多手游或者商业网站，为了提高用户留存，都设计了签到任务。如果你签到，你会得到一些奖励。连续签到一定天数，会有额外的<strong class="kh ir">礼盒</strong>可以打开，打开后会有奖金。让我们一起努力实现这个要求。</p><h1 id="e0a2" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">问题域</h1><p id="e0ac" class="pw-post-body-paragraph lp lq iq kh b ki mz jr lr kk na ju ls km nb lu lv ko nc lx ly kq nd ma mb ks ij bi translated">连续登录的用户会得到钻石，如下表所示:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/98473a12ba3ca9761eb679ab0f0fd5b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_AmFxl_4bLq0Vi1m4eTf9w.png"/></div></div></figure><p id="9729" class="pw-post-body-paragraph lp lq iq kh b ki kj jr lr kk kl ju ls km lt lu lv ko lw lx ly kq lz ma mb ks ij bi translated">为了简化问题，让我们得到一个固定数量的100颗钻石，每次打开礼盒。比如用户连续四天签到，用户在签到的第五天就可以获得30和一个礼盒。</p><p id="ab87" class="pw-post-body-paragraph lp lq iq kh b ki kj jr lr kk kl ju ls km lt lu lv ko lw lx ly kq lz ma mb ks ij bi translated">用户每次进入首页，都会看到一个签到图，告诉用户在这个周期内已经连续完成了多少次签到，获得了多少奖励。</p><h1 id="7f43" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">设计阶段</h1><p id="0840" class="pw-post-body-paragraph lp lq iq kh b ki mz jr lr kk na ju ls km nb lu lv ko nc lx ly kq nd ma mb ks ij bi translated">有两种不同的设计方法，面向数据的设计和领域驱动的设计。我们将开始讨论面向数据的设计，并告诉你为什么它不是主流设计解决方案。</p><h1 id="e42d" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">面向数据的设计(不能说是好方法)</h1><p id="ed9c" class="pw-post-body-paragraph lp lq iq kh b ki mz jr lr kk na ju ls km nb lu lv ko nc lx ly kq nd ma mb ks ij bi translated">面向数据的设计是指当我们看到一个问题时，我们首先考虑如何存储数据，然后操纵定义的数据格式来试图解决原始问题。</p><p id="d3b3" class="pw-post-body-paragraph lp lq iq kh b ki kj jr lr kk kl ju ls km lt lu lv ko lw lx ly kq lz ma mb ks ij bi translated">所以得到问题后，第一步就是要想好用什么数据库，会有什么模式，数据会以什么格式存在。</p><p id="f004" class="pw-post-body-paragraph lp lq iq kh b ki kj jr lr kk kl ju ls km lt lu lv ko lw lx ly kq lz ma mb ks ij bi translated">我们以签到任务为例。假设我们在一个小的整体上进行设计，通常带有一个关系数据库，所以我们首先定义一个表来实现我们的问题。定义一个签到表，存储每次签到的时间，这样你就可以根据之前的签到记录知道自己可以获得多少奖励。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/57a10ead500caf084ba50ad546615b15.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*bVsEN_OV0l2mHsfLfSia3w.png"/></div></figure><p id="a54d" class="pw-post-body-paragraph lp lq iq kh b ki kj jr lr kk kl ju ls km lt lu lv ko lw lx ly kq lz ma mb ks ij bi translated">从上表来看，如果今天是<code class="fe md me mf mg b">2022-01-04</code>，那么约翰签到的时候可以获得15颗钻石，而玛丽因为没有连续签到，只能获得10颗钻石，所以会开始新的循环。</p><p id="2401" class="pw-post-body-paragraph lp lq iq kh b ki kj jr lr kk kl ju ls km lt lu lv ko lw lx ly kq lz ma mb ks ij bi translated">该任务的逻辑是过滤特定用户的登录日期，并按日期排序，然后检索最新的<code class="fe md me mf mg b">N</code>记录。通过计算连续签到的总天数，然后就可以知道这次要获得什么奖励了。</p><p id="d81b" class="pw-post-body-paragraph lp lq iq kh b ki kj jr lr kk kl ju ls km lt lu lv ko lw lx ly kq lz ma mb ks ij bi translated">这样的设计有一个问题。当用户的签到完全没有中断，即连续签到天数大于<code class="fe md me mf mg b">N</code>时，那么数据量不足以决定当前的奖励。尽管如此，我们不希望扩展<code class="fe md me mf mg b">N</code>,以避免拉太多数据使数据库成为瓶颈。因此，我们应该尝试对原始模式进行一些更改，比如添加一个新字段diamond。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/872f9a04701ecef927c43f1911818b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*aECKyWRW9iLDbj54SnbvYw.png"/></div></figure><p id="419d" class="pw-post-body-paragraph lp lq iq kh b ki kj jr lr kk kl ju ls km lt lu lv ko lw lx ly kq lz ma mb ks ij bi translated">对于约翰来说，在<code class="fe md me mf mg b">2022-01-09</code>上登录将获得10颗钻石，因为我们知道前一个周期的终点是<code class="fe md me mf mg b">2022-01-07</code>。</p><p id="f541" class="pw-post-body-paragraph lp lq iq kh b ki kj jr lr kk kl ju ls km lt lu lv ko lw lx ly kq lz ma mb ks ij bi translated">故事还没有结束。当用户数量增加时，RDBMS的性能将变得很差。每次进入首页都要从数据库中拉数据，运行复杂的计算，最后看到结果。这个过程效率很低。</p><p id="940f" class="pw-post-body-paragraph lp lq iq kh b ki kj jr lr kk kl ju ls km lt lu lv ko lw lx ly kq lz ma mb ks ij bi translated">为了提高主页的效率，大多数项目都会引入缓存来记录整个签到的状态。但是，如何知道缓存是否无效呢？或者说缓存其实不是无效的，而是扭曲的。我在以前的文章<a class="ae kx" href="https://towardsdev.com/resilient-caching-in-redis-a5b3c1a49f14" rel="noopener ugc nofollow" target="_blank">弹性缓存</a>中已经提到了这个问题。通过添加完整性，可以区分数据是否可靠。一旦数据损坏，我们将从RDBMS重建数据。</p><h1 id="879a" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">摘要</h1><p id="d606" class="pw-post-body-paragraph lp lq iq kh b ki mz jr lr kk na ju ls km nb lu lv ko nc lx ly kq nd ma mb ks ij bi translated">从上面的介绍中我们发现，即使是缓存也有很多方面需要考虑，整个面向数据的设计非常复杂，过程非常纠结。</p><p id="9da5" class="pw-post-body-paragraph lp lq iq kh b ki kj jr lr kk kl ju ls km lt lu lv ko lw lx ly kq lz ma mb ks ij bi translated">因此，领域驱动设计诞生了。</p><p id="b84a" class="pw-post-body-paragraph lp lq iq kh b ki kj jr lr kk kl ju ls km lt lu lv ko lw lx ly kq lz ma mb ks ij bi translated">在第2部分中，我们将从实体开始设计，涵盖用例，然后实现像TDD这样的单元测试，最后完成我们的使命。我会提供一个更好的设计过程，你可以按照步骤来简化你将遇到的每一个用户故事。今天到此为止吧。直到下次</p></div></div>    
</body>
</html>