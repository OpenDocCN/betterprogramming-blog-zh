<html>
<head>
<title>JavaScript Promise: Know When To Use It and How It Works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript承诺:知道何时使用它以及它是如何工作的</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-promise-know-when-to-use-it-and-how-it-works-b8671e585e53?source=collection_archive---------6-----------------------#2021-02-15">https://betterprogramming.pub/javascript-promise-know-when-to-use-it-and-how-it-works-b8671e585e53?source=collection_archive---------6-----------------------#2021-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b1ba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">promise不是async/await的旧版本</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/be187aef2c94decb6d711bd0ede924ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4khm6d13VTxslu3c"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@womanizer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">好色之徒WOW Tech </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ccbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多日常使用JavaScript的开发人员喜欢使用<code class="fe lv lw lx ly b">async/await</code>语法。它不仅易于学习和使用，而且还可以使您的代码更具可读性和可理解性。然而，你知道有时候你需要使用<code class="fe lv lw lx ly b">Promise</code>语法而不是<code class="fe lv lw lx ly b">async/await</code>语法吗？</p><p id="bb0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将解释<code class="fe lv lw lx ly b">Promise</code>是如何工作的，以及何时应该使用它。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a06b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">先决条件</h1><p id="710c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">你应该已经知道<code class="fe lv lw lx ly b">Promise</code>的基本用法了。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3950" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">承诺是如何在幕后运作的</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/11574299cf4b7fee73f9a8397a04f233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-DwWPe1HNf3A_3iq.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">《无极》工作流程(作者)。</p></figure><p id="53da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想你们很多人已经知道<code class="fe lv lw lx ly b">Promise</code>的阶段是什么了。一旦你完成了在一个<code class="fe lv lw lx ly b">Promise</code>构造函数中所做的任何事情，它就会返回另一个<code class="fe lv lw lx ly b">Promise</code>并等待你在构造函数中所写的事情被完成。这将是<code class="fe lv lw lx ly b">fulfilled</code>或<code class="fe lv lw lx ly b">rejected</code>。</p><p id="223a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1bb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能猜出结果吗？</p><p id="e7de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然<code class="fe lv lw lx ly b">1</code>首先会被打印出来。由于<code class="fe lv lw lx ly b">setTimeout</code>是一个异步函数，您会想，“它将在以后的某个时候被执行。”然后，你遇到了<code class="fe lv lw lx ly b">Promise</code>。“嗯，一个<code class="fe lv lw lx ly b">Promise</code>也是一个异步的东西，所以我猜这个会在<code class="fe lv lw lx ly b">setTimeout</code>之后执行，因为我先遇到了<code class="fe lv lw lx ly b">setTimeout</code>。”</p><p id="4d2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以你很确定答案是<code class="fe lv lw lx ly b">1-2-3-4</code>或<code class="fe lv lw lx ly b">1-3-2-4</code> …哪个是错的。</p><p id="1460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我遇到的许多开发人员都知道<code class="fe lv lw lx ly b">Promise</code>被认为是异步的，但是他们并不真正知道<em class="ng">为什么</em>被认为是异步的。</p><p id="f21c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将提出几项声明。看看你认为有多少是正确的:</p><ul class=""><li id="4b81" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">JavaScript是一种单线程语言。(O/X)</li><li id="f552" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">JavaScript有多个任务队列。(O/X)</li><li id="b768" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">JavaScript一次只运行一个任务。(O/X)</li><li id="8a1d" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">JavaScript可以在内部区分不同任务的优先级。(O/X)</li></ul><p id="7676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案都是o。都是正确的。众所周知，JavaScript是一种单线程编程语言，在这种语言中，一次只能运行一个任务。不过，它可以决定你处理不同任务的顺序，从而有效地管理几个任务。JavaScript有几个任务队列，我会进一步解释。</p><h2 id="45c6" class="nv mh it bd mi nw nx dn mm ny nz dp mq li oa ob ms lm oc od mu lq oe of mw og bi translated">任务队列看起来像什么？</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/69b104e537fe92f4a71004e47491f1d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oBobM1V9AFpBf-ds3dhxNg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">队列的工作流程…但是JavaScript不是这样工作的(太简单了)。</p></figure><p id="6d05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是它们的样子。</p><p id="418e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript有几个任务队列——可能有三个或更多——当您逐行阅读代码时，每个相关的任务都进入一个队列。例如，如果您阅读:</p><pre class="kj kk kl km gt oi ly oj ok aw ol bi"><span id="7204" class="nv mh it ly b gy om on l oo op">console.log(1);</span></pre><p id="7456" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不会立即执行。内容为“在控制台上打印1”的新任务进入其任务队列(上面工作流中的黄色、绿色或红色队列)。而一旦到了执行这个任务的时候，你终于可以看到印在控制台上的数字了。我不会深入研究这个问题，因为它对你来说太基础了。</p><p id="0e82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但问题是“我怎么知道当前任务去哪个任务队列？”</p><h2 id="b19a" class="nv mh it bd mi nw nx dn mm ny nz dp mq li oa ob ms lm oc od mu lq oe of mw og bi translated">你如何知道每个代码何时被执行？</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/ac3452f9aa36921d29dde7ecae7d6912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6CnDJw4o2YP6lLKbnSA6g.png"/></div></div></figure><p id="4ba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这个帖子是关于<code class="fe lv lw lx ly b">Promise</code>的，所以我主要试着用<code class="fe lv lw lx ly b">Promise</code>来解释一下。</p><p id="4385" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑一个交通信号和想要左转或直行的司机。</p><ul class=""><li id="ff11" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">红色汽车:想左转的司机。</li><li id="fabb" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">绿色汽车:想直行的司机。</li></ul><p id="7a51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">红色的车正在左转，因为左转的标志亮了。但是所有红色车后面的绿色车呢？他们想直行并穿过十字路口，然而他们不得不等待所有的红色汽车离开。</p><p id="5af8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个简短的演示类似于<code class="fe lv lw lx ly b">Promise</code>任务的工作方式。</p><p id="8a77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript在内部将命令分成几部分。本文中您应该记住的一点是，<code class="fe lv lw lx ly b">Promise</code>与其他任务的分类不同，例如<code class="fe lv lw lx ly b">console.log</code>、<code class="fe lv lw lx ly b">new Date()</code>或其他不被认为是异步的任务。</p><p id="d3cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的演示中，<code class="fe lv lw lx ly b">Promise</code>任务是等待轮到他们直行穿过十字路口的绿色汽车。而其他的同步任务就是左转的红车。<code class="fe lv lw lx ly b">Promises</code>必须等到同步任务的队列空了，就像绿色的车必须等到所有要走左边的车都走了。由于这非常重要，我将重复我自己的话:<code class="fe lv lw lx ly b">Promises</code>必须等到所有同步任务执行完毕。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="43f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe lv lw lx ly b">Promise</code>的构造函数内部的区域不是异步的，所以<code class="fe lv lw lx ly b">“resolve”</code>将首先被记录。它向<code class="fe lv lw lx ly b">Promise.then</code>发送另一个<code class="fe lv lw lx ly b">Promise</code>和消息<code class="fe lv lw lx ly b">“resolve”</code>。这是一个异步区域，所以它必须等到所有其他同步任务都执行完。下面有一个无限循环，所以程序会永远卡在那里。你将永远没有机会看到<code class="fe lv lw lx ly b">Promise.then</code>的日志。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/98d0201e8668e362f475ff568a49c6ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gWgl6XVGV3gDURIO1fCw6g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">承诺(异步)和同步任务之间的关系。</p></figure><p id="b9b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图解释了<code class="fe lv lw lx ly b">Promises</code>和同步任务的关系。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c028" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么时候应该使用承诺？</h1><h2 id="9f27" class="nv mh it bd mi nw nx dn mm ny nz dp mq li oa ob ms lm oc od mu lq oe of mw og bi translated">当按您想要的顺序排列任务时</h2><p id="4eac" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Promise</code>任务只有在同步任务队列为空后才执行，所以用<code class="fe lv lw lx ly b">Promise</code>代替<code class="fe lv lw lx ly b">async/await</code>是非常有益的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您使用<code class="fe lv lw lx ly b">async/await</code>语法来获取一些API。</p><p id="aa43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">changeUIComponents</code>应在获取<code class="fe lv lw lx ly b">login</code> API后运行，<code class="fe lv lw lx ly b">reloadPage</code>应在获取<code class="fe lv lw lx ly b">updateProfile</code> API后运行。在这段代码中，您的程序必须等到<code class="fe lv lw lx ly b">login</code>和<code class="fe lv lw lx ly b">updateProfile</code>每行都返回一个结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="facc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有了<code class="fe lv lw lx ly b">Promise</code>，你可以通过推迟任务的执行，在你想按特定顺序排列的任务中建立更安全的序列。</p><p id="ffd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前两行<code class="fe lv lw lx ly b">changeUIComponents</code>和<code class="fe lv lw lx ly b">updateProfile</code>将在<code class="fe lv lw lx ly b">goto</code>完成运行后执行，这是在同步队列为空之后。一旦<code class="fe lv lw lx ly b">updateProfile</code>返回结果，就会执行<code class="fe lv lw lx ly b">reloadPage</code>。</p><h2 id="c877" class="nv mh it bd mi nw nx dn mm ny nz dp mq li oa ob ms lm oc od mu lq oe of mw og bi translated">当增强性能时</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="33ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这个例子。</p><p id="4acc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">my-page</code>页面上，用户等待获取和加载三条信息(用户信息、账单历史和朋友列表)。</p><p id="3cc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">页面上最重要的数据是关于我的信息。所以让用户等待获取相关数据似乎更好，但是其他数据呢？不需要预先获取用户的账单历史或者用户有多少朋友。因此，我会稍微重构一下这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="aa90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当第一次呈现页面时，只获取用户信息。之后，账单历史和朋友列表将被提取。</p><p id="131a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户不必在第一次呈现时等待不太重要的数据。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5a9f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="9437" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在执行之前，A <code class="fe lv lw lx ly b">promise</code>必须一直等待所有同步任务完成。事实上，JavaScript规范在普通任务队列中调用同步任务所在的队列，在微任务队列中调用<code class="fe lv lw lx ly b">Promises</code>所在的队列。</p><p id="664d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还提到，通过将<code class="fe lv lw lx ly b">Promise</code>放在适当的位置，您可以使用<code class="fe lv lw lx ly b">Promise</code>来获得更好的性能。</p></div></div>    
</body>
</html>