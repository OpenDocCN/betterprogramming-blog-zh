<html>
<head>
<title>Implement a WebSocket Server in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js中实现WebSocket服务器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-a-websocket-server-from-scratch-in-node-js-a1360e00a95f?source=collection_archive---------0-----------------------#2022-11-21">https://betterprogramming.pub/implementing-a-websocket-server-from-scratch-in-node-js-a1360e00a95f?source=collection_archive---------0-----------------------#2022-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7cfa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过这个快速指南探索和学习WebSockets的内部原理</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b04b7bcb7bb061e4ef260ce16ad275ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zjIdD5mg_gRDvLfYwVWf9g.png"/></div></div></figure><p id="604b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我们将通过从头实现一个简单的WebSocket服务器来探索WebSockets如何在协议层内部工作。它旨在涵盖客户机-服务器开放握手和数据组帧的基础知识。</p><p id="7d69" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为我们的主要事实来源，我们将参考官方的WebSocket协议规范— <a class="ae ln" href="https://www.rfc-editor.org/rfc/rfc6455" rel="noopener ugc nofollow" target="_blank"> RFC 6455 </a>，尤其是第1节和第4–7节🤓</p><p id="81c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于我们的代码示例，我将使用Node.js v18.12.1。</p><h1 id="63e1" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><strong class="ak"> 1。背景</strong></h1><p id="2fc9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">WebSocket是一种通信协议，它在单个TCP/IP连接上运行，并在客户端和服务器之间提供双向全双工通道。</p><p id="0881" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与HTTP请求-响应范例相反，它有助于通过持久连接进行实时的客户端-服务器消息交换，对于需要实时数据更新的web应用程序尤其有用。</p><p id="4b85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如RFC 6455 的摘要所说，</p><blockquote class="ml mm mn"><p id="e509" class="kr ks mo kt b ku kv jr kw kx ky ju kz mp lb lc ld mq lf lg lh mr lj lk ll lm ij bi translated">该技术的目标是为基于浏览器的应用程序提供一种机制，这种机制需要与服务器进行双向通信，而不依赖于打开多个HTTP连接(例如，使用XMLHttpRequest或<iframe> s和长轮询)。</iframe></p></blockquote><p id="d5e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本质上，WebSockets是TCP/IP栈之上的一个薄的低开销传输层。</p><p id="d348" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文接下来的部分中，我们将讨论该协议的一些细节，还将逐步构建我们的WebSocket服务器。</p><h1 id="7892" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">2.协议概述</h1><p id="719f" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">WebSockets运行在一个持久的TCP连接上，但是它是由一个特殊的HTTP升级请求建立的。在您的项目中使用WebSockets时，您可能经常会在浏览器的Network选项卡中看到这样一个请求的结果。</p><p id="a392" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据RFC第1.7节中的<a class="ae ln" href="https://www.rfc-editor.org/rfc/rfc6455#section-1.7" rel="noopener ugc nofollow" target="_blank">:</a></p><blockquote class="ml mm mn"><p id="bb0b" class="kr ks mo kt b ku kv jr kw kx ky ju kz mp lb lc ld mq lf lg lh mr lj lk ll lm ij bi translated">WebSocket协议是一个独立的基于TCP的协议。它与HTTP的唯一关系是它的握手被HTTP服务器解释为升级请求。</p></blockquote><p id="0bbc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基本上，要启动WebSocket服务器，我们需要首先创建一个HTTP服务器，然后根据来自客户端的升级请求执行一个开放式握手，这将导致协议从HTTP切换到WebSockets。</p><p id="76b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们首先通过创建一个文件<code class="fe ms mt mu mv b">ws.js</code>并声明一个类<code class="fe ms mt mu mv b">WebSocketServer</code>来实现我们的服务器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3c56" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们正在扩展<code class="fe ms mt mu mv b">EventEmitter</code>，因为将来我们的服务器将需要能够发出和订阅像<code class="fe ms mt mu mv b">open</code>、<code class="fe ms mt mu mv b">upgrade</code>、<code class="fe ms mt mu mv b">data</code>等事件。</p><p id="a785" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">服务器本身将在该类的<code class="fe ms mt mu mv b">_init</code>方法中创建:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ca2e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了升级之外，我们真的不想处理任何HTTP请求，所以对于所有传入的HTTP请求，我们用<code class="fe ms mt mu mv b">426 Upgrade Required</code>错误进行响应🚫。这表明我们的服务器拒绝使用HTTP协议处理请求，但是愿意使用来自<code class="fe ms mt mu mv b">Upgrade</code>头的协议来处理请求。</p><p id="d52f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下一节中，我们将讨论并实现一个实际的协议升级(一个开放的WebSocket握手)。</p><h1 id="92e6" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">3.开场握手</h1><p id="6a2b" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">WebSocket连接是由发起“开始握手”的客户端创建的。然后，服务器必须通过用特定的头进行响应来完成握手。之后，初始的HTTP连接被使用相同TCP套接字的WebSocket连接所取代。</p><p id="eec5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">RFC的第4 部分<a class="ae ln" href="https://www.rfc-editor.org/rfc/rfc6455#section-4" rel="noopener ugc nofollow" target="_blank">描述了开场握手，非常简单明了。</a></p><p id="c335" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">客户端通过发送带有以下报头的HTTP GET请求来发起握手:</p><pre class="kg kh ki kj gt my mv mz bn na nb bi"><span id="b3d3" class="nc lp iq mv b be nd ne l nf ng">GET / HTTP/1.1<br/>Connection: Upgrade<br/>Upgrade: websocket<br/>Sec-WebSocket-Key: kB2x1cO5zjL1ynwrLTSXUQ==<br/>Sec-WebSocket-Version: 13</span></pre><p id="41df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ms mt mu mv b">Connection</code>和<code class="fe ms mt mu mv b">Upgrade</code>头的组合向服务器发出客户机请求建立WebSocket连接的信号。</p><p id="ca78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ms mt mu mv b">Sec-WebSocket-Version</code>代表规范的版本。根据规范，这个头字段的值必须是13。</p><p id="e863" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ms mt mu mv b">Sec-WebSocket-Key</code>是一个随机生成的对客户端唯一的字符串。根据RFC，这个头的值是一个随机数，由随机选择的16字节值组成，该值已经过base64编码。必须为每个连接随机选择随机数(<a class="ae ln" href="https://www.rfc-editor.org/rfc/rfc6455#section-4.1" rel="noopener ugc nofollow" target="_blank">第4.1节</a>)。</p><p id="7bbe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ms mt mu mv b">Sec-WebSocket-Key</code>的值用于创建服务器的握手，以表示接受连接。</p><p id="bde8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要接受传入的连接，服务器必须用状态为<code class="fe ms mt mu mv b">101 Switching Protocols</code>的HTTP响应进行响应。</p><p id="d1fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">响应必须包含一个<code class="fe ms mt mu mv b">Sec-WebSocket-Accept</code>头，其值通过以下方式生成:</p><ul class=""><li id="e992" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated">服务器必须获取<code class="fe ms mt mu mv b">Sec-WebSocket-Key</code>的值，并将其与GUID值<code class="fe ms mt mu mv b">258EDFA5-E914–47DA-95CA-C5AB0DC85B11</code>连接起来(这是一个<a class="ae ln" href="https://en.wikipedia.org/wiki/Magic_string" rel="noopener ugc nofollow" target="_blank">神奇字符串</a>)</li><li id="7ae0" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">那么接收到的值必须被<code class="fe ms mt mu mv b">SHA-1</code>散列</li><li id="2b8d" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">那么接收到的散列必须在<code class="fe ms mt mu mv b">base64</code>中编码。</li></ul><p id="194e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">选择神奇字符串值是因为:</p><blockquote class="ml mm mn"><p id="e95b" class="kr ks mo kt b ku kv jr kw kx ky ju kz mp lb lc ld mq lf lg lh mr lj lk ll lm ij bi translated">不理解WebSocket协议的网络端点不太可能使用它(<a class="ae ln" href="https://www.rfc-editor.org/rfc/rfc6455#section-1.3" rel="noopener ugc nofollow" target="_blank">第1.3节</a>)。</p></blockquote><p id="1e51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基本上，为了确保客户机和服务器都支持WebSocket协议，这是必需的。这一步很重要，因为如果服务器接受WebSocket连接，但将数据解释为HTTP请求，可能会出现潜在的安全问题。</p><p id="72cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">握手响应还必须包含报头<code class="fe ms mt mu mv b">Connection: Upgrade</code>和<code class="fe ms mt mu mv b">Upgrade: websocket</code>。</p><p id="794e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在客户端接收到带有所描述的头的服务器响应之后，WebSocket连接被建立并打开以开始传输数据。</p><p id="815b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们看看如何用代码实现握手。</p><p id="5ae1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将继续构建我们的<code class="fe ms mt mu mv b">WebSocketServer</code>示例，并以如下方式更新我们的<code class="fe ms mt mu mv b">_init</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="753f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果<code class="fe ms mt mu mv b">Upgrade</code>报头的值不等于<code class="fe ms mt mu mv b">websocket</code>，我们用400响应，并中止握手。</p><p id="de16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了方便起见，我们发出了<code class="fe ms mt mu mv b">headers</code>事件，这样我们就能够订阅这个事件，并查看在连接请求时收到了什么消息头。</p><p id="3a91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们也将“神奇字符串”声明添加到我们的类的构造函数中:</p><pre class="kg kh ki kj gt my mv mz bn na nb bi"><span id="c6bd" class="nc lp iq mv b be nd ne l nv ng">this.GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';</span></pre><p id="6654" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">方法<code class="fe ms mt mu mv b">_generateAcceptValue</code>是为<code class="fe ms mt mu mv b">Sec-WebSocket-Accept</code>头生成值的方法，非常简单(注意，我们需要来自节点的<code class="fe ms mt mu mv b">crypto</code>模块):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="be11" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，我们的服务器就可以建立⚡️的WebSocket连接了</p><p id="f20c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们只需要在我们的类中添加一个<code class="fe ms mt mu mv b">listen</code>方法，实例化它，然后检查是否一切都像我们预期的那样工作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="caa8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，要启动我们的服务器，我们必须执行以下操作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3eef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了检查一切是否正常，使用<code class="fe ms mt mu mv b">node ws.js</code>命令运行<code class="fe ms mt mu mv b">ws.js</code>文件，打开浏览器控制台并创建一个新的WebSocket:</p><pre class="kg kh ki kj gt my mv mz bn na nb bi"><span id="4d86" class="nc lp iq mv b be nd ne l nv ng">const ws = new WebSocket('ws://localhost:4000');</span></pre><p id="46ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回到您的终端，您应该会看到类似这样的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/a2d91bf2dfd632c066cce8286054db8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rDijYlm4GeoQGE_4liS_vA.png"/></div></div></figure><p id="cb98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">瞧，我们握手了！</p><p id="9a18" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尼斯（法国城市名）💥</p><p id="df46" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下一节中，我们将使我们的服务器能够接收和解析来自客户端的数据。</p><h1 id="52cb" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">4.接收数据</h1><blockquote class="ml mm mn"><p id="bffe" class="kr ks mo kt b ku kv jr kw kx ky ju kz mp lb lc ld mq lf lg lh mr lj lk ll lm ij bi translated">在WebSocket协议中，使用一系列帧来传输数据。(<a class="ae ln" href="https://www.rfc-editor.org/rfc/rfc6455#section-5.1" rel="noopener ugc nofollow" target="_blank">第5.1节</a>)</p></blockquote><p id="8820" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这一节中，我们将着重于实现一个解析WebSocket帧的方法。但首先，让我们讨论一下框架实际上是如何构造的。</p><p id="3936" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下图显示了WebSocket帧的构建块及其大小(以位为单位)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/19d8af15e93e0e93d974cb4a65095b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*03kdZPX_CHQJDRe21NCpRw.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">来源:<a class="ae ln" href="https://rafalgolarz.com/blog/2016/12/07/websocket_servers_101/" rel="noopener ugc nofollow" target="_blank">https://rafalgolarz . com/blog/2016/12/07/web socket _ servers _ 101/</a></p></figure><p id="8106" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">规范的第5.2节中描述了每个块的含义。</p><ul class=""><li id="7e9b" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated"><code class="fe ms mt mu mv b">FIN</code> — 1位。这是WebSocket帧的第一位。如果该位被置位，则表明这是报文的最后一段。</li><li id="9e19" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated"><code class="fe ms mt mu mv b">RSV1</code>、<code class="fe ms mt mu mv b">RSV2</code>、<code class="fe ms mt mu mv b">RSV3</code> —各1位。这些是保留给WebSocket扩展使用的。在撰写本文时，只有两个<a class="ae ln" href="https://www.iana.org/assignments/websocket/websocket.xhtml#extension-name" rel="noopener ugc nofollow" target="_blank">注册扩展</a>:<a class="ae ln" href="https://www.rfc-editor.org/rfc/rfc7692" rel="noopener ugc nofollow" target="_blank">web socket Per-Message Deflate</a>和<a class="ae ln" href="https://usp.technology/" rel="noopener ugc nofollow" target="_blank"> BBF USP协议</a>。这些超出了本文的范围。</li><li id="c1fb" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated"><code class="fe ms mt mu mv b">Opcode</code> — 4位。该块用于解释<code class="fe ms mt mu mv b">Payload Data</code>块。有代码表示文本或二进制帧，连接关闭事件，继续帧等。以下是<code class="fe ms mt mu mv b">opcode</code>的可能值及其含义:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="988f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的例子中，我们将只使用<code class="fe ms mt mu mv b">0x01</code>和<code class="fe ms mt mu mv b">0x08</code>操作码。</p><ul class=""><li id="af31" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated"><code class="fe ms mt mu mv b">mask</code> —定义<code class="fe ms mt mu mv b">Payload Data</code>块是否被屏蔽。如果设置为1，则必须存在一个4字节的<code class="fe ms mt mu mv b">masking-key</code>块，并用于解除<code class="fe ms mt mu mv b">Payload Data</code>块的屏蔽。根据<a class="ae ln" href="https://www.rfc-editor.org/rfc/rfc6455#section-5.1" rel="noopener ugc nofollow" target="_blank">规格</a>:</li></ul><blockquote class="ml mm mn"><p id="4806" class="kr ks mo kt b ku kv jr kw kx ky ju kz mp lb lc ld mq lf lg lh mr lj lk ll lm ij bi translated">客户端必须屏蔽它发送给服务器的所有帧。服务器不得屏蔽它发送给客户端的任何帧。</p></blockquote><p id="fda7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基本上，这意味着当从浏览器测试我们的服务器时，我们总是会收到屏蔽帧。同时，在发送响应时，我们不能屏蔽我们的有效载荷，否则浏览器将拒绝处理我们的帧并抛出错误。</p><ul class=""><li id="00ce" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated"><code class="fe ms mt mu mv b">Payload Len</code> + <code class="fe ms mt mu mv b">Extended payload length</code> — 7位、7+16位或7+64位。</li></ul><p id="d905" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果<code class="fe ms mt mu mv b">Payload Data</code>块的长度小于等于125字节，则<code class="fe ms mt mu mv b">payload len</code>值就是<code class="fe ms mt mu mv b">Payload Data</code>的长度。如果有效载荷的长度大于125字节，<code class="fe ms mt mu mv b">Payload len</code>块的值可以是126或127:</p><ul class=""><li id="c916" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated">如果实际有效载荷长度在126到65，535字节之间，那么<code class="fe ms mt mu mv b">Payload len</code>就是<code class="fe ms mt mu mv b">126</code>，后面的16位将被视为实际有效载荷长度值。</li><li id="9bd9" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">如果实际有效载荷长度在65，536字节和~9223372036.85千兆字节之间，那么<code class="fe ms mt mu mv b">Payload len</code>就是<code class="fe ms mt mu mv b">127</code>，后面的64位将被视为实际有效载荷长度值。</li></ul><p id="1cbb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，如果你必须将<code class="fe ms mt mu mv b">Payload len</code>设置为127，你的帧太大了，你肯定做错了。你能想象单个数据帧9000吗，lol？</p><ul class=""><li id="4e49" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated"><code class="fe ms mt mu mv b">masking-key</code> — 0或4个字节。如果设置了<code class="fe ms mt mu mv b">mask</code>位，则必须提供32位屏蔽密钥。屏蔽密钥用于解除从客户端接收的有效载荷数据的屏蔽。</li><li id="65f0" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated"><code class="fe ms mt mu mv b">Payload Data </code> —发送或接收的实际有效载荷。大多数时候，它包含应用程序数据(我们——应用程序开发人员——发送或接收的任意数据)。但是，如果在开始握手期间已经协商了扩展，它也可以包含扩展数据。</li></ul><p id="7f68" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们试着自己实现一个帧解析函数。</p><p id="09dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，让我们用将要使用的代码在<code class="fe ms mt mu mv b">WebSocketServer</code>构造函数中定义操作码映射:</p><pre class="kg kh ki kj gt my mv mz bn na nb bi"><span id="4b65" class="nc lp iq mv b be nd ne l nv ng">this.OPCODES = { text: 0x01, close: 0x08 };</span></pre><p id="cd21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们定义一个名为<code class="fe ms mt mu mv b">parseFrame</code>的方法，它接收一个缓冲区，从中提取有效载荷并返回一个<code class="fe ms mt mu mv b">utf-8</code>字符串。</p><p id="4254" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于我们不打算使用<code class="fe ms mt mu mv b">0x00</code>操作码(延续帧)，我们将假设<code class="fe ms mt mu mv b">FIN</code>位总是被置位。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0d3d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们读取缓冲区的第一个字节，并提取第一个字节的最后4位值<code class="fe ms mt mu mv b">opcode</code>。如果<code class="fe ms mt mu mv b">opcode</code>是<code class="fe ms mt mu mv b">0x08</code>，那么我们发出一个<code class="fe ms mt mu mv b">close</code>事件并返回null。我们也拒绝处理除纯文本(<code class="fe ms mt mu mv b">opcode</code> 0x01)之外的任何内容。</p><p id="febd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了处理连接关闭事件，让我们添加一个<code class="fe ms mt mu mv b">close</code>事件监听器并销毁其回调☠️中的套接字</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7b2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们尝试提取有效载荷长度。</p><p id="24b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此，我们将读取缓冲区的第二个字节，并从中提取最后7位。这将是框架的<code class="fe ms mt mu mv b">payload len</code>模块。如果该值等于126或127，则实际有效载荷长度将分别在缓冲区的后续2或8个字节中定义。</p><p id="a07b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们不打算使用有效载荷长度值，所以我们将只设置一个偏移计数器来知道实际的有效载荷数据何时在缓冲区中开始。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7694" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">初始的<code class="fe ms mt mu mv b">offset</code>值是<code class="fe ms mt mu mv b">2</code>，因为我们已经读取了缓冲区的第一个和第二个字节。如果<code class="fe ms mt mu mv b">payload len</code>块值是126或127，我们知道接下来的2或8个字节将被实际有效载荷长度占用，所以我们将各自的值加到偏移量上。</p><p id="0edf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还需要注意的是检查<code class="fe ms mt mu mv b">mask</code>位(第二个字节的第一位)并提取<code class="fe ms mt mu mv b">masking-key</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7962" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果<code class="fe ms mt mu mv b">mask</code>位被置位，那么我们知道我们的实际有效载荷从4个字节开始(在屏蔽键之后写入)，所以我们将4加到我们的<code class="fe ms mt mu mv b">offset</code>中。如果<code class="fe ms mt mu mv b">mask</code>位未置位，那么我们的<code class="fe ms mt mu mv b">offset</code>值已经指示了缓存中<code class="fe ms mt mu mv b">payload data</code>的开始，所以我们可以读取它直到结束并返回。</p><p id="5c75" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了得到一个屏蔽键，我们使用<code class="fe ms mt mu mv b">readUInt32BE</code>函数，从<code class="fe ms mt mu mv b">offset</code>字节开始从我们的缓冲区提取32位数据。</p><p id="95d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，有了屏蔽键，我们需要解除有效载荷的屏蔽。</p><p id="3c11" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">屏蔽和取消屏蔽的算法是相同的，并在规范的第5.3节中定义。本质上可以归结为:</p><blockquote class="ml mm mn"><p id="d1b3" class="kr ks mo kt b ku kv jr kw kx ky ju kz mp lb lc ld mq lf lg lh mr lj lk ll lm ij bi translated">转换数据的八位字节I是原始数据的八位字节I与屏蔽密钥的索引I处的八位字节模4的异或</p></blockquote><p id="dc56" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在字节级别上操作，所以我们需要一些二进制算法来转换有效载荷的每一位。我们将遍历有效载荷的每个字节，并将其与屏蔽密钥的适当字节进行异或运算:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f477" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们更新<code class="fe ms mt mu mv b">_init</code>方法中的请求升级回调，以添加<code class="fe ms mt mu mv b">data</code>事件监听器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8030" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，我们只是重新发出了<code class="fe ms mt mu mv b">data</code>事件，但是也向外传递了解析后的数据(使用<code class="fe ms mt mu mv b">parseFrame(buffer)</code>)。</p><p id="95ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以这样使用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="59dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要测试它是否工作，您可以转到浏览器控制台，运行如下内容:</p><pre class="kg kh ki kj gt my mv mz bn na nb bi"><span id="bb9d" class="nc lp iq mv b be nd ne l nv ng">const ws = new WebSocket('ws://localhost:4000');<br/><br/>ws.send(JSON.stringify({ message: 'Hello World' }));</span></pre><p id="a5a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在您的终端中，您应该能够看到来自浏览器的消息:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/6f422a38e43c200cc504c0d1bded4d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t3w_Tm5SgnThZVrd7W2ULA.png"/></div></div></figure><p id="1d1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">万岁！🤘</p><p id="45c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是如果我们只能接收数据而不能发回数据，我们的服务器就没有多大用处了。在下一节中，我们将处理这个问题。</p><h1 id="7381" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">5.发送数据</h1><p id="2448" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们已经知道了WebSocket框架的结构，所以现在创建一个框架会容易得多。另外，我们不需要做掩蔽！</p><p id="553b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要创建一个帧，我们需要回答这个问题:我们应该为一个帧分配多大的缓冲区？</p><p id="3e28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是我们已经知道的:</p><ul class=""><li id="fbba" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated">我们需要第一个字节用于<code class="fe ms mt mu mv b">FIN</code>、<code class="fe ms mt mu mv b">RSV</code>位和<code class="fe ms mt mu mv b">opcode</code>；</li><li id="4021" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">我们需要第二个字节来存储<code class="fe ms mt mu mv b">mask</code>位和<code class="fe ms mt mu mv b">payload len</code>；</li><li id="b917" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">我们需要决定我们是否需要额外的2或8字节用于大的有效载荷；</li><li id="95b7" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">还有我们实际有效载荷的字节长度。</li></ul><p id="3b2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，我们稍微简化了一下，没有为屏蔽键分配4个字节。</p><p id="d6fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了进一步简化，让我们假设<code class="fe ms mt mu mv b">FIN</code>位总是被设置，并且<code class="fe ms mt mu mv b">opcode</code>值总是<code class="fe ms mt mu mv b">0x01</code>(文本框)。</p><p id="0422" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们可以硬编码第一个帧字节— <code class="fe ms mt mu mv b">0b10000001</code>:</p><blockquote class="ml mm mn"><p id="d839" class="kr ks mo kt b ku kv jr kw kx ky ju kz mp lb lc ld mq lf lg lh mr lj lk ll lm ij bi translated">鳍(1)，RSV1 (0)，RSV2 (0)，RSV3 (0)，Opсode (0001)</p></blockquote><p id="b99b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们创建一个方法<code class="fe ms mt mu mv b">createFrame(data)</code>并填充前2个字节和可选的随后的2或8个字节作为一个<code class="fe ms mt mu mv b">extra payload length</code>值。之后，我们只需将有效载荷数据添加到结果缓冲区的末尾:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2d38" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码中，我们逐渐增加<code class="fe ms mt mu mv b">payloadBytesOffset</code>变量，使其与缓冲区中实际有效载荷的起始偏移量相匹配。</p><p id="efc5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦我们知道了<code class="fe ms mt mu mv b">payloadBytesOffset</code>，我们可以很容易地通过将有效载荷的字节长度和偏移量相加来计算得到的缓冲区的总长度。</p><p id="f53f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们将<code class="fe ms mt mu mv b">payload len</code>和可选的<code class="fe ms mt mu mv b">extra payload length</code>写入结果缓冲区。感谢<a class="ae ln" href="https://nodejs.org/api/buffer.html" rel="noopener ugc nofollow" target="_blank"> Buffer </a>的助手函数——<code class="fe ms mt mu mv b">writeUInt16BE</code>和<code class="fe ms mt mu mv b">writeBigUInt64BE</code>——这只是一个函数调用的问题。</p><p id="2af1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们的有效载荷。</p><p id="73d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就这样，很简单。😎</p><p id="5446" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们在下一节把所有的东西放在一起，看看我们的服务器是如何使用的。</p><h1 id="9c35" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">6.把所有的放在一起</h1><p id="28c1" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们有解析和创建WebSocket帧的方法，我们还实现了开始握手过程💪</p><p id="18be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了将所有这些投入使用，让我们首先修改我们的<code class="fe ms mt mu mv b">data</code>回调，将一个<code class="fe ms mt mu mv b">reply</code>函数传递给最终用户:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="bdc4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，我们不仅能够接收数据，还能够将数据发送回客户端:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e4a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">继续并在浏览器控制台中键入</p><pre class="kg kh ki kj gt my mv mz bn na nb bi"><span id="48eb" class="nc lp iq mv b be nd ne l nv ng">const ws = new WebSocket('ws://localhost:4000');<br/><br/>ws.addEventListener('message', ({ data }) =&gt; { console.log(JSON.parse(data)) });<br/>ws.send(JSON.stringify({ ping: 'Hello World' }));</span></pre><p id="9b61" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您将看到我们的服务器用一个<code class="fe ms mt mu mv b">pong</code>响应:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/22fdbf12a31e2f9bca1cd05ef0785459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-nFk81rYe3tq3kM64M9eQ.png"/></div></div></figure><p id="1592" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好吧。现在让我们建立一些更实际的东西。</p><p id="f92a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们定义一些我们的服务器将为客户机提供的API方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8017" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ms mt mu mv b">sleep</code>函数只是<code class="fe ms mt mu mv b">setTimeout</code>函数的重命名导入:</p><pre class="kg kh ki kj gt my mv mz bn na nb bi"><span id="cf4c" class="nc lp iq mv b be nd ne l nv ng">const { setTimeout: sleep } = require('node:timers/promises');</span></pre><p id="97b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们的服务器向客户端提供这个API:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ff42" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在就用吧！</p><p id="a4c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在浏览器控制台中，我们可以连接到我们的服务器并发送一些请求:</p><pre class="kg kh ki kj gt my mv mz bn na nb bi"><span id="9924" class="nc lp iq mv b be nd ne l nv ng">const ws = new WebSocket('ws://localhost:4000');<br/><br/>ws.addEventListener('message', ({ data }) =&gt; { console.log(JSON.parse(data)) });<br/><br/>ws.send(JSON.stringify({ method: 'auth', args: ['admin', 'wrong'] }));<br/>ws.send(JSON.stringify({ method: 'auth', args: ['admin', 'secret'] }));<br/>ws.send(JSON.stringify({ method: 'getUsers' }));</span></pre><p id="d3f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在您的浏览器控制台中，您应该会看到类似这样的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/46b57a77a79a40c0acea089a11760d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zkqOu5Mo6g1HvKbfRvbqAw.png"/></div></div></figure><p id="cedd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">哇，那个RPC用的是WebSockets吗？</p><p id="e8d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是的，看起来是这样😏</p><p id="c57e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">恭喜你。您已到达这篇文章的结尾。到目前为止，您应该知道WebSocket协议在内部是如何工作的，包括客户机-服务器握手和数据组帧。正如你所看到的，WebSockets不是一个太复杂的协议，甚至是RFC也很容易理解。</p><p id="3d18" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">出于学习的目的，你可以试着用我们的<code class="fe ms mt mu mv b">WebSocketServer</code>(利用连续帧)实现流式传输，这应该不会太难，或者给我们的服务器添加真正的JWT认证🤖</p><p id="eeb3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是本文的完整代码(我还在该类的一个<code class="fe ms mt mu mv b">clients</code>属性中添加了连接跟踪):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="c216" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">7.要阅读的其他资源</h1><ol class=""><li id="ca05" class="nh ni iq kt b ku mg kx mh la of le og li oh lm oi nn no np bi translated"><a class="ae ln" href="https://www.rfc-editor.org/rfc/rfc6455" rel="noopener ugc nofollow" target="_blank">RFC 6455—web socket协议</a></li><li id="2f99" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm oi nn no np bi translated"><a class="ae ln" href="https://ably.com/topic/websockets" rel="noopener ugc nofollow" target="_blank">web sockets——概念性的深度研究(Ably) </a></li><li id="c813" class="nh ni iq kt b ku nq kx nr la ns le nt li nu lm oi nn no np bi translated"><a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers" rel="noopener ugc nofollow" target="_blank">编写WebSocket服务器(MDN) </a></li></ol><p id="a753" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>