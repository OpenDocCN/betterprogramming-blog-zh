# 如何以及何时在 Go 中使用上下文

> 原文：<https://betterprogramming.pub/how-and-when-to-use-context-in-go-b365ddf42ae2>

## 侧重于并发性

![](img/20b60bb3c3af85df2630a63b47732759.png)

作者图片

在为并发或客户机/服务器环境开发代码时，我们通常可以从拥有上下文中获益——执行业务逻辑不一定需要的关于系统的信息。Go 的标准库提供了一个优秀的[上下文包](https://pkg.go.dev/context)，其中包含了许多实用程序，可以将这些信息传递给接收它们的函数。这些能力包括:

*   知道手术取消了
*   如果某项操作在特定时间内没有完成，则取消
*   如果操作运行时间过长，则超时
*   以键/值存储的形式传递通用数据

我们将在下面深入探讨每一种方法及其常见用例。

# 空上下文

上下文允许应用程序收集关于其环境的附加信息，它们可以将这些信息传递给它们调用的函数。有时需要从头开始创建一个上下文，或者应用程序开发人员知道将会需要它，但是还不知道该上下文将来自哪里或者如何生成它。

## 背景上下文

在第一种情况下，可以使用以下内容创建空上下文:

`ctx := context.Background()`

这将生成一个空的上下文，可以用取消函数、超时/截止时间或值来传递和扩展(见下一节)。这个上下文永远不会被取消，也没有截止日期或相关的值。这通常用于顶级上下文或测试。

## 待办事项上下文

类似地，我们可以使用以下内容来导出 TODO 上下文:

`ctx := context.TODO()`

这将返回一个永远不会取消的空上下文，并且没有截止日期或相关值。当不清楚要使用哪个上下文，或者函数希望传入一个尚不可用的上下文时，可以使用这个上下文。它本质上提供了一种编译和传递信息的方法，但是将上下文标记为不完整(类似于`// TODO`评论)。

您可以在下面的示例(有点没用)中看到这两者是如何生成和使用的:

# 可取消上下文

取消是结束依赖于上下文的计算路径的最直接的方式——它允许调用代码向下游的任何东西发出不再需要计算的信号。是时候清理资源，退出了。这在处理长时间运行的请求时很有用(例如，如果客户端与服务器断开连接，则停止处理)，并且这是干净地关闭应用程序的常见方式——当应用程序接收到停止信号(例如`SIGTERM`)时，它可以取消顶级上下文，并且从该上下文派生的任何内容都将知道清理和停止活动。

我们用 cancel 生成上下文，如下所示:

`ctx, cancelFunc := WithCancel(parent Context)`

这将返回一个带有新的`Done`通道的`parent`副本，以及一个取消功能。当`cancelFunc`被召唤时，`ctx`上的`Done`频道关闭，向下游发出清理和停止所有活动的信号。如果`parent`可以取消并且已经取消，则`Done`也关闭。

在下面的例子中，我们生成一个可取消的上下文，并通过`Done()`检查 done 通道来检查它是否已被取消:

当我们运行上面的代码时，我们可以看到如下输出:

```
background long running task launched
background long running task still going
going to cancel background task
long running task bailed because context cancelled
some time has elapsed after cancellingProgram exited.
```

如果你想自己尝试一下，你可以将这个例子(或它之后的任何东西)复制/粘贴到 [Go playground](https://go.dev/play/) 中。

# 有截止日期的上下文

当向调用方可能不知道或控制其状态的外部资源(如数据库或 API)发出请求时，通常会使用有截止日期的上下文。他们说，“我希望某件事在某个时间或之前发生，否则就放弃。”当截止日期到期时，上下文的`Done`通道将关闭，向任何下游代码表明它们应该停止正在做的事情。

这些采取的形式是

`ctx, cancelFunc := WithDeadline(parent Context, deadline time.Time)`

其中`parent`是基于的上下文，而`deadline`是你希望事情发生的时间。请注意，如果`parent`的截止日期早于`deadline`。该上下文将具有与`parent`相同的截止日期。

以下示例显示了如何使用它来结束长时间运行的任务:

这里，我们编写了一个函数，它接受一个上下文和一个等待时间的值。在这两种情况下，它都将返回，但会打印出它是由于上下文截止时间已过还是等待时间已过而退出。我们可以看到，我们将返回，因为在第一种情况下上下文过期了，在第二种情况下，我们将在上下文过期之前返回。我们得到以下输出:

```
bailed because context deadline passed
completed before context deadline passedProgram exited.
```

`longRunningTask()`还演示了一个简单的例子，说明接受上下文的代码如何在不同的通道上使用`select`来处理被取消的上下文。

# 超时的上下文

具有超时的上下文是一个方便的特性，类似于具有截止日期的上下文。它们被这样称呼:

`ctx, cancelFunc := WithTimeout(parent Context, dur time.Duration)`

在引擎盖下，他们在呼唤:

`WithDeadline(parent, time.Now().Add(timeout))`

但是，嘿，我们会采取任何我们能得到的简化！

本质上，当我们传递一个超时的上下文时，我们说我们愿意等到`timeout`的时间过去，如果调用没有完成，它应该结束并退出。这降低了我们的代码无限期(对于“infinite”的某个值)挂起以等待某个调用完成而不是出错并继续工作的可能性。

以下示例显示了如何使用它来结束长时间运行的任务:

我们得到以下输出:

```
bailed because context timed out
completed before context timed outProgram exited.
```

我们可以看到这和上面的 deadline 例子是多么的相似。当在`WithDeadline`和`WithTimeout`之间进行选择时，只需选择更符合调用代码的那个即可。如果你想让它在某个时间发生，选择最后期限！如果您希望它在一定的持续时间内发生，请选择超时！

# 具有值的上下文

上下文还允许传递请求范围的值。要将键/值对附加到上下文，请调用:

`ctx := WithValue(parent Context, key, val any)`

这将返回`parent`的副本，其中与`key`关联的值为`val`。

提供的`key`必须是可比较的，并且不应该是内置类型(如 string 或 int ),以避免使用上下文的不同包之间的冲突。如果多个包使用具有相同值的同一个`key`类型，它们在试图设置/获取`val`时会发生冲突。相反，`key`应该被定义为它自己的适当作用域类型，用于设置和获取`val`。这样，即使多个范围用相同的基础值定义了一个键，它们也不会在上下文中发生冲突。下面的例子说明了这一点:

这里我们定义了一个键类型(`keyType1`)，它的作用域是`main()`。它由值`"foo"`构成。我们现在在一个上下文中分配键/值对`"foo"="bar"`。如果我们试图检索一个类型为`keyType1`(值为`"foo"`)的键，我们会得到`"bar"`，这是意料之中的。

现在，我们可以用自己的键类型定义一个新函数。如果我们为新的键类型(`"foo"`)分配相同的键值，我们可以尝试从上下文中获取值:

```
found a value for key type 1: bar
no value for key type 2Program exited.
```

正如我们所看到的，由于我们无法访问正确的键*类型*，所以我们无法访问值，即使键的底层值是相同的。注意，我们也可以在`tryAnotherKeyType()`中分配一个新值，由于我们到目前为止讨论过的相同的键类型不匹配，它在`main()` 中是不可访问的。这就是我们如何避免包(或任何范围单元)之间的键/值冲突。

这个工具应该用于在进程和 API 之间传递请求范围的数据，而不仅仅是可选的函数参数，因为这会混淆代码。还要注意，上下文中的值必须是线程安全的——也就是说，它们可能被多个 goroutines 同时使用。

# 派生上下文

我们在本文前面提到过，但是派生的上下文非常有用。概括来说，子上下文是由它们的父上下文控制的——它们不能有比它们的父上下文更长的超时/截止时间，并且它们不能取消它们的父上下文。它们也继承存储在它们父母中的任何值。然而，父母可以取消他们的孩子。

我们经常使用派生的上下文作为代码分割成具有不同生命周期和功能的分支。例如，我们可能有一个主上下文来管理整个应用程序的生命周期，但是有一个派生的上下文来管理一个 API 请求，可能还有另一个派生的上下文来管理处理请求所需的存储调用。

这样，我们可以选择结束整个应用程序(通过取消主上下文)、请求处理(通过取消第一个派生上下文)或存储调用(通过取消第二个派生上下文)。

# 包扎

注意，对于上述所有内容，当不再需要释放资源时(如果上下文包含取消功能)，调用上下文的`CancelFunc`是最佳实践。在上面的例子中，为了简单起见，我通常忽略了 cancel 函数，但是对于长时间运行的应用程序，有效地利用资源是很重要的。上下文通常作为第一个函数参数传递，所以在开发自己的使用上下文的代码时要记住这一点！

希望这可以作为一个跳板，学习更多关于 Go 中上下文的知识，并提高您的应用程序开发技能。现在，当您看到接受上下文的函数(例如调用数据库或 API)时，它应该开始变得更有意义，并且您可以开始了解作为一个客户端，如何使用上下文来使您自己的代码更可预测和更具性能。

我们已经介绍了 Go 中各种上下文实用程序的主要机制，并讨论了何时以及如何使用它们。您可以在许多方面利用这个工具，所以把它看作是一个开始，而不是终点线。

*感谢阅读！敬请关注更多内容。*