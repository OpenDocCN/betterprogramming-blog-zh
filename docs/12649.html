<html>
<head>
<title>A Poor Man’s Web Worker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个穷人的网络工作者</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/2022-052-a-poor-mans-web-worker-279d17a13018?source=collection_archive---------5-----------------------#2022-06-20">https://betterprogramming.pub/2022-052-a-poor-mans-web-worker-279d17a13018?source=collection_archive---------5-----------------------#2022-06-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e271" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一项实验技术如何拯救世界</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/02c0b02414a0dc4c3ebf959950000358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cNh2KZeEf52O19lQuKAExA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是探索网络工作者替代品的催化剂。在这个例子中，新罕布什尔州的康科德需要更好的碰撞检测和标签放置的自动调整。来源:<a class="ae ky" href="https://full.earth/?utm_term=poor-mans-web-worker" rel="noopener ugc nofollow" target="_blank"> https://full.earth </a>。</p></figure><p id="46d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一段时间以来，我一直在使用JavaScript和HTML canvas开发一个基于浏览器的地球地图系统。这项工作的主要挑战之一是在将3D纬度/经度投影到2D画布上时保持用户界面的响应。地图上每个要素的每个点都必须使用三角法进行转换:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d632" class="ma mb it lw b gy mc md l me mf">x = R cosΦ sin(λ - λ₀)<br/>y = R (cosΦ₀ sinΦ - sinΦ₀ cosΦ cos(λ - λ₀))</span></pre><p id="3a7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解这个问题的规模，一个典型的地图可能包含几十个图层，每个图层包含数百个要素，每个要素包含数千个点。</p><p id="25b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当用户平移或缩放时，所有这些点都必须通过该投影公式运行。此外，因为用户可以自由地重新定位观察点，所以不能使用有意义的缓存方案。</p><p id="cf83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我一直认为，总有一天将数学转移到一个单独的线程是必要的，所以我一直关注着网络工作者的前景。</p><p id="1231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我一直在实现一个碰撞检测系统来识别和纠正重叠的地图标签。这样做所需的计算远远超出了用户的接受范围。这是该项目的转折点——是时候认真考虑实现一个web worker了。</p><p id="77c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可悲的是，这一努力的结果令人失望。</p><p id="b035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网络工作者的机制非常简单。任何在线教程都足以让我们开始。回顾一下，web worker的承诺是浏览器的主线程可以自由地响应鼠标和键盘事件，而web worker线程可以完全专注于计算。</p><p id="f8f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，这种工作方式有一个很大的缺点:必须使用<code class="fe mg mh mi lw b">postMessage</code>函数来来回回地传递输入和输出。教程中演示的玩具例子经常把它当作简单的实现细节，而实际上它变成了一个主要的瓶颈。</p><p id="df24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://engineering.salesforce.com/optimizing-performance-with-web-workers-612b48621d8d/" rel="noopener ugc nofollow" target="_blank">用Web Workers </a>优化性能中，陈熠记录了这个问题，指出“4000个对象的序列化/反序列化需要大约20 ~ 30毫秒，抵消了将大约100毫秒的过程移植到Workers的好处。”</p><p id="21ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">James Milner在<a class="ae ky" href="https://www.jameslmilner.com/post/web-worker-performance/" rel="noopener ugc nofollow" target="_blank">检查Web Worker性能</a>中对此进行了更详细的研究，他总结道“Web Worker的真正成本来自于将数据从主线程传输到Web Worker以及将数据返回到主线程。”</p><p id="54b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的例子中，在主线程和web worker之间传输100K对<code class="fe mg mh mi lw b">{Φ, λ}</code>和<code class="fe mg mh mi lw b">{x, y}</code>是一个站不住脚的设计。</p><p id="70bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决这个问题的方法是使用可转移数组。这些是由主线程填充数字的大型缓冲区，由工作线程处理，然后由调用者返回并展开。</p><p id="b524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的一个扩展是<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas" rel="noopener ugc nofollow" target="_blank"> OffscreenCanvas </a>函数，它已经被承诺了很长时间。Chrome和Opera在2018年提供了这方面的实现，但Firefox和Safari仍然不支持它(<a class="ae ky" href="https://caniuse.com/offscreencanvas" rel="noopener ugc nofollow" target="_blank">can use</a>)。</p><p id="10c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在研究该做什么的时候，我偶然发现了另一项实验性技术，我称之为穷人的网络工作者，但更恰当的称呼是<code class="fe mg mh mi lw b">requestIdleCallback</code>。Safari已经正式将其纳入考虑范围，而其他所有浏览器都已经提供了实现。与此同时，62线<a class="ae ky" href="https://github.com/behnammodi/polyfill/blob/master/window.polyfill.js" rel="noopener ugc nofollow" target="_blank"> polyfill </a>可以暂时满足我们的需求。</p><p id="aa8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">requestIdleCallback</code>的概念很简单。浏览器知道它的队列何时为空，以及离下一个“事件循环”开始还有多长时间我们可以要求浏览器在发生这种情况时通知我们。浏览器通过我们在请求中注册的回调函数来实现这一点。它还告诉我们有多少空闲时间可供我们使用。</p><p id="53aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mg mh mi lw b">requestIdleCallback</code>时，我们的责任是在处理数据的同时关注时钟，当时钟用完时，将控制权交还给浏览器。如果我们在完成之前放弃了，我们需要获取足够的状态信息，从我们停止的地方继续我们的工作，并要求浏览器在另一段时间可用时通知我们。</p><p id="a0da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我用过的脚手架，可以适用于类似的问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="a3cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是穷人的网络工作者:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="9cf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了以60赫兹的刷新率实现清晰的屏幕渲染和鼠标的平滑移动，浏览器需要每隔16.67毫秒处理一次新业务(1000毫秒/60 = 16.67毫秒)。在它处理完未决的DOM事件和内存管理开销之后，剩余的时间将被计算到注册的<code class="fe mg mh mi lw b">requestIdleCallback</code>中。</p><p id="3ed6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用1毫秒―15毫秒范围内的时间片可以取得真正进展的想法一点也不明显。然而在实践中，这种做法取得了令人满意的效果。</p><p id="5bbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一点。细心的读者会注意到对<code class="fe mg mh mi lw b">requestIdleCallback</code>的调用嵌入在<code class="fe mg mh mi lw b">computeLayout</code>回调函数本身中。这看起来像一个递归调用，事实上，当用Chrome的inspector调试代码时，你会注意到堆栈似乎随着每个新请求而增长。</p><p id="c3fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要被误导——这不是真正的递归。就像它的表亲<code class="fe mg mh mi lw b">requestAnimationFrame</code>，浏览器正在做一些幕后的蠢事。(顺便说一下，关于堆栈溢出问题的答案本身就在<a class="ae ky" href="https://stackoverflow.com/questions/29181253/is-requestanimationframe-implementations-recursive" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>上！)</p><h1 id="81a6" class="ml mb it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="4b3e" class="nc nd it lb b lc ne lf nf li ng lm nh lq ni lu nj nk nl nm bi translated">网络工作者被大肆宣传为银弹，但往往达不到他们的承诺。</li><li id="2c3f" class="nc nd it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">使用<code class="fe mg mh mi lw b">postMessage</code>在主线程和工作线程之间穿梭数据是一个主要的瓶颈。</li><li id="6297" class="nc nd it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><code class="fe mg mh mi lw b">requestIdleCallback</code>功能可以成功地作为网络工作者的替代。</li></ul></div></div>    
</body>
</html>