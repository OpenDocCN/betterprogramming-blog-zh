<html>
<head>
<title>How to Build Docker Base Images for Rails</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为Rails构建Docker基础映像</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-docker-base-images-for-rails-2258ea2f11dc?source=collection_archive---------6-----------------------#2019-10-20">https://betterprogramming.pub/build-docker-base-images-for-rails-2258ea2f11dc?source=collection_archive---------6-----------------------#2019-10-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0af4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过使用自定义基础映像，简化Docker文件并减少Docker构建时间</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5510218f1f5f4f54e5ed6a3556283a12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TBgJ8TRd4_qm9RU0bPlY5A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Docker标志</p></figure><p id="7c40" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Docker为在隔离环境中运行应用程序提供了一种简单的方法，它也有助于将应用程序与它们的依赖项打包在一起。</p><p id="dfa7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为您的应用程序构建docker映像并管理这些Docker映像可能是一项具有挑战性的任务(取决于您想要实现的目标)。</p><p id="43b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我将解释如何创建Docker映像来作为Rails应用程序的基础映像。该职位将涵盖以下几点。</p><ul class=""><li id="4694" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">为基础图像创建<code class="fe md me mf mg b">Dockerfiles</code>。</li><li id="7226" class="lu lv it la b lb mh le mi lh mj ll mk lp ml lt lz ma mb mc bi translated">自动创建Docker文件。</li><li id="ac11" class="lu lv it la b lb mh le mi lh mj ll mk lp ml lt lz ma mb mc bi translated">使用GitHub和<a class="ae mm" href="https://travis-ci.org/" rel="noopener ugc nofollow" target="_blank"> Travis </a>自动化构建过程。</li><li id="3c20" class="lu lv it la b lb mh le mi lh mj ll mk lp ml lt lz ma mb mc bi translated">为Rails应用程序使用Docker基本映像。</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5934" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated"><strong class="ak">问题</strong></h1><p id="71df" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">如上所述，Docker映像是一种将应用程序与它应该运行的主机环境隔离的方法。这个特性允许我们将应用程序部署到任何Docker主机上，而不需要关心在主机上安装和管理软件依赖。</p><p id="f01d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了实现这个目标，每个创建的Docker映像都必须包含运行相应应用程序所需的所有依赖项。</p><p id="e3e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，对于使用<code class="fe md me mf mg b">wkhtmltopdf</code>二进制文件生成PDF文档的Rails应用程序，该应用程序的Docker映像必须包含<code class="fe md me mf mg b">wkhtmltopdf</code>二进制文件才能生成PDF文件。</p><p id="f3ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于Rails应用程序，应用程序依赖项可能是以下项目之一(这也可能适用于非Rails应用程序)。在构建期间，需要考虑这些项目并将其包含在Docker映像中。</p><ol class=""><li id="9b4c" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt nr ma mb mc bi translated">对应的Ruby编程语言版本。</li><li id="7223" class="lu lv it la b lb mh le mi lh mj ll mk lp ml lt nr ma mb mc bi translated">像<code class="fe md me mf mg b">mysql2</code>这样的系统包。</li><li id="06e4" class="lu lv it la b lb mh le mi lh mj ll mk lp ml lt nr ma mb mc bi translated">配置和环境变量。</li><li id="2542" class="lu lv it la b lb mh le mi lh mj ll mk lp ml lt nr ma mb mc bi translated">Rails应用程序使用的Ruby/Rails gems。</li></ol><p id="8ff2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为具有上述所有依赖关系的多个应用程序(微服务架构软件)构建Docker映像可能会花费大量时间，因为对于每个服务，我们需要下载并安装所有提到的依赖关系。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="8e17" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated"><strong class="ak">提议的解决方案</strong></h1><p id="af65" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">因为多个Rails应用程序可能有相同的Ruby版本、系统包和配置，所以我们可以构建包含这些项目的Docker映像，然后使用这些Docker映像作为Rails应用程序的基本映像。</p><p id="ce2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个想法将帮助我们减少为我们的服务/应用程序构建Docker映像所需的时间。</p><h2 id="bbe2" class="ns mv it bd mw nt nu dn na nv nw dp ne lh nx ny ng ll nz oa ni lp ob oc nk od bi translated"><strong class="ak"> Docker文件内容</strong></h2><p id="8848" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">我们可以构建Docker基本映像，包括上面列表中的前三项，Ruby和Rails gems是特定于应用程序的，不应该属于基本映像。</p><p id="1cb2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，我们可以使用<a class="ae mm" href="https://hub.docker.com/_/ruby/" rel="noopener ugc nofollow" target="_blank"> Ruby官方图片</a>来覆盖我们列表中的第一项。</p><p id="6681" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了实现这一点，我们需要将下面一行作为第一行包含在基本图像Dockerfile文件中。这一行将告诉Docker，我们希望构建一个基于<a class="ae mm" href="https://alpinelinux.org/about/" rel="noopener ugc nofollow" target="_blank"> Alpine </a>作为操作系统的Docker映像，并且安装了Ruby“2 . 6 . 4”。</p><pre class="kj kk kl km gt oe mg of og aw oh bi"><span id="2e92" class="ns mv it mg b gy oi oj l ok ol">FROM ruby:2.6.4-alpine</span></pre><p id="e2ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一步是定义一些被多个Rails应用程序使用的共享环境变量。</p><p id="c2f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，为了确保我们所有的服务都在Docker的生产模式下运行，我们可以在基本映像中设置<code class="fe md me mf mg b">RAILS_ENV</code>。此外，我们可以为所有应用程序公开相同的端口，这将有助于我们维护服务之间的一致性。</p><p id="cdcf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是可设置项目的建议列表，该列表不限于这些变量或配置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="91d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一步是准备Docker映像操作系统，以便能够托管我们的应用程序。在这一步中，我们将创建一个服务用户来使用它运行我们的应用程序，并安装运行我们的应用程序所需的必要系统包。</p><p id="216c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一步中包含的系统包列表取决于您正在构建的Rails应用程序。例如，如果不止一个应用程序在使用<code class="fe md me mf mg b">wkhtmltopdf</code>，您可以将库包含在其中一个基本映像中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="f0e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一步是切换到创建的用户，并确保安装了<code class="fe md me mf mg b">bundler</code>,以便以后能够安装gems。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="2958" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一步是定义在子Docker映像(Rails应用程序映像)构建期间需要执行的步骤。</p><p id="de51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我们需要确保将应用程序的源代码复制到前面定义的相应文件夹中，并确保我们的用户是该文件夹的所有者。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="99ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是建议的Docker文件的全部内容。注意，这个文件只能用于支持ruby 2.6.4的Rails应用程序。</p><p id="2f85" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了能够支持多个Ruby版本，我们需要为我们想要支持的每个版本创建多个Docker文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Docker基本图像</p></figure><h2 id="4582" class="ns mv it bd mw nt nu dn na nv nw dp ne lh nx ny ng ll nz oa ni lp ob oc nk od bi translated"><strong class="ak">管理Docker图像的创建</strong></h2><p id="7328" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">除了为每个受支持的Ruby版本手动复制基本Docker文件之外，我们还可以尝试通过将建议的Docker文件转换为模板来自动创建这些文件，并使用Ruby从模板中自动创建Docker文件。</p><p id="d41c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要将我们的Docker文件转换为模板，我们需要在建议的Docker文件中添加两个占位符。第一行与我们的Docker映像中使用的Ruby版本相关。</p><pre class="kj kk kl km gt oe mg of og aw oh bi"><span id="fbae" class="ns mv it mg b gy oi oj l ok ol">FROM ruby:&lt;%= ruby_version %&gt;-alpine</span></pre><p id="8417" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二行与需要包含在Docker基本映像中的系统包列表相关</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="4bde" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了这些改变，我们有能力用不同的Ruby版本和不同的系统包创建多个Docker文件。这些更改的完整结果如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="cf5d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一步是自动创建受支持的Docker文件，为此我们可以编写一个简单的Ruby代码，读取受支持的Docker映像及其依赖关系的列表，并为每个映像创建一个Docker文件。</p><p id="0fd9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">YAML文件结构可能类似于下面的文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="db50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的文件包含了两个基于Ruby的Docker图像的定义<code class="fe md me mf mg b">2.6.3</code>，其中一个包含了<code class="fe md me mf mg b">mariadb-dev</code>。借助下面的Ruby代码，我们可以创建构建Docker映像所需的Docker文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="db94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行下面的Ruby代码将为在<code class="fe md me mf mg b">YAML</code>文件中定义的图像创建Docker文件，并将它们存储在本地文件夹<code class="fe md me mf mg b">rails-base-image-ruby</code>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="b859" class="ns mv it bd mw nt nu dn na nv nw dp ne lh nx ny ng ll nz oa ni lp ob oc nk od bi translated"><strong class="ak">自动构建Docker图像</strong></h2><p id="d946" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">既然我们已经为基础映像自动创建了Docker文件，下一步就是找到一种方法来为生成的文件自动构建Docker映像。</p><p id="b36a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">构建Docker映像可以使用Docker命令行<code class="fe md me mf mg b">docker build</code>来完成。所有生成的Docker文件都存储在文件夹<code class="fe md me mf mg b">rails-base-image-ruby</code>下。</p><p id="09a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，为了自动化构建过程，我们可以遍历<code class="fe md me mf mg b">rails-base-image-ruby</code>下的所有文件夹并执行<code class="fe md me mf mg b">docker build</code>命令。同样，我们可以使用命令<code class="fe md me mf mg b">docker push</code>将Docker映像推送到Docker注册表。</p><p id="384d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这可以通过下面的<a class="ae mm" href="https://www.gnu.org/software/bash/" rel="noopener ugc nofollow" target="_blank"> Bash </a>脚本来实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="16b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了提高创建基本映像的自动化程度，我们可以配置Travis，以便在每次创建针对主分支的pull请求时构建Docker基本映像。</p><p id="0a1b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个任务可以通过简单地将下面的文件添加到我们在GitHub上的repo中并在Travis上启用repo来完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="4915" class="ns mv it bd mw nt nu dn na nv nw dp ne lh nx ny ng ll nz oa ni lp ob oc nk od bi translated"><strong class="ak">使用基础Docker图像</strong></h2><p id="06a8" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">为了在Rails应用程序中使用我们的基本图像，我们只需要在Docker文件顶部的<code class="fe md me mf mg b">FROM</code>关键字后设置我们的图像名称。</p><p id="9d92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，我们需要安装应用程序重新获取的Ruby/Rails gems。下面是为Rails应用推荐的<code class="fe md me mf mg b">dockerfile</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="16b4" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated"><strong class="ak">结论</strong></h1><p id="ef0c" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">总之，为Rails应用程序使用Docker基本映像可以提高部署的性能，并减少为应用程序构建Docker映像所需的时间。</p><p id="7190" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个想法的完整实现在下面的GitHub <a class="ae mm" href="https://github.com/wshihadeh/rails-base-images" rel="noopener ugc nofollow" target="_blank"> repo </a>中，生成的Docker图片可以在<a class="ae mm" href="https://cloud.docker.com/u/wshihadeh/repository/docker/wshihadeh/rails-base-image-ruby" rel="noopener ugc nofollow" target="_blank">这个网址</a>找到。</p></div></div>    
</body>
</html>