<html>
<head>
<title>How To Use TypeScript to Avoid Bugs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用TypeScript避免bug</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-typescript-to-avoid-bugs-3d760435e243?source=collection_archive---------18-----------------------#2019-11-11">https://betterprogramming.pub/how-to-use-typescript-to-avoid-bugs-3d760435e243?source=collection_archive---------18-----------------------#2019-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="256c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用TypeScript来避免未定义和类型错误等常见错误</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b61ed9862fb7bfc5207c8bf72351bbef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M5HWJrGmMMbkmiNJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@glenncarstenspeters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格伦·卡斯滕斯-彼得斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0983" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript是JavaScript的超集，创建它是为了解决JavaScript的常见问题。</p><p id="3232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript的一个问题是所有对象都有动态类型。这意味着，如果不将对象记录到调试器中，就无法知道它具有哪些属性。</p><p id="fd1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这造成了很多挫折，因为您必须亲自检查每个对象，从而减慢了开发速度。没有静态类型，你也不能在你的编辑器中自动完成，因为没有办法100%确定地知道那些对象中有什么。</p><p id="4d5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态类型是可选的，所以您仍然可以使用对象作为散列。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="392a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">类型检查</h1><p id="3756" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">此外，您可以将任何参数放入JavaScript函数中，这带来了与动态类型相同的困难，因为没有强制执行传入的内容。</p><p id="d411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就产生了问题，因为你应该传入但没有传入的参数将是未定义的，然后你会得到未定义的错误。也没有什么可以阻止你传入太多的参数。</p><p id="123a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这两种检查，TypeScript使代码更容易理解和遵循。当你改变代码的时候，你不必担心破坏东西，因为编译器会告诉你，你得到了那些基本的错误。</p><p id="09f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，依赖注入是TypeScript的一部分，这意味着您不必自己解析依赖。这也使得模仿依赖关系易于测试。</p><p id="fe75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript在即将发布的JavaScript版本(尚未最终确定)中提供了一些特性，这些特性可能对一些开发人员来说很方便。</p><p id="4a92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript通过为对象定义类型文件来向对象添加类型。它的工作原理是建立一个模块，然后包含一个<code class="fe mz na nb nc b">module.d.ts</code>文件。</p><p id="95f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这方面的一个例子是在<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html" rel="noopener ugc nofollow" target="_blank">类型脚本文档</a>中。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9b7e" class="nh md it nc b gy ni nj l nk nl">// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]<br/>// Project: [~THE PROJECT NAME~]<br/>// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span><span id="224e" class="nh md it nc b gy nm nj l nk nl">/*~ This is the module template file. You should rename it to index.d.ts<br/> *~ and place it in a folder with the same name as the module.<br/> *~ For example, if you were writing a file for "super-greeter", this<br/> *~ file should be 'super-greeter/index.d.ts'<br/> */</span><span id="9406" class="nh md it nc b gy nm nj l nk nl">/*~ If this module is a UMD module that exposes a global variable 'myLib' when<br/> *~ loaded outside a module loader environment, declare that global here.<br/> *~ Otherwise, delete this declaration.<br/> */<br/>export as namespace myLib;</span><span id="8c10" class="nh md it nc b gy nm nj l nk nl">/*~ If this module has methods, declare them as functions like so.<br/> */<br/>export function myMethod(a: string): string;<br/>export function myOtherMethod(a: number): number;</span><span id="d54d" class="nh md it nc b gy nm nj l nk nl">/*~ You can declare types that are available via importing the module */<br/>export interface someType {<br/>    name: string;<br/>    length: number;<br/>    extras?: string[];<br/>}</span><span id="6838" class="nh md it nc b gy nm nj l nk nl">/*~ You can declare properties of the module using const, let, or var */<br/>export const myField: number;</span><span id="c7e4" class="nh md it nc b gy nm nj l nk nl">/*~ If there are types, properties, or methods inside dotted names<br/> *~ of the module, declare them inside a 'namespace'.<br/> */<br/>export namespace subProp {<br/>    /*~ For example, given this definition, someone could write:<br/>     *~   import { subProp } from 'yourModule';<br/>     *~   subProp.foo();<br/>     *~ or<br/>     *~   import * as yourMod from 'yourModule';<br/>     *~   yourMod.subProp.foo();<br/>     */<br/>    export function foo(): void;<br/>}</span></pre><p id="5ede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据网站上的示例，您可以将顶级属性定义为一行代码。并且，嵌套属性可以通过使用关键字<code class="fe mz na nb nc b">namespace</code>来定义。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8c1e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">组合类型</h1><p id="b322" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您不必在TypeScript中使用单一类型。多个类型可以合并成一个。交集类型是将多种数据类型组合成一种的数据类型。</p><p id="9e62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f3f4" class="nh md it nc b gy ni nj l nk nl">function(foo: Foo, bar: Bar): Foo &amp; Bar {<br/>    const result: Partial&lt;Foo &amp; Bar&gt; = {};<br/>    for (const prop in foo) {<br/>        if (foo.hasOwnProperty(prop)) {<br/>            (result as Foo)[prop] = foo[prop];<br/>        }<br/>    }<br/>    for (const prop in bar) {<br/>        if (bar.hasOwnProperty(prop)) {<br/>            (result as Bar)[prop] = bar[prop];<br/>        }<br/>    }<br/>    return result as Foo&amp; Bar;<br/>}</span></pre><p id="2eb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具有组合类型的对象从两种类型获取属性。</p><p id="fdc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">联合类型是一种数据类型，其中对象可以是一种类型，也可以是另一种类型。例如:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a134" class="nh md it nc b gy ni nj l nk nl">let foo: number|string;</span></pre><p id="664d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在该声明之后，您可以将一个数字或一个字符串赋给变量，TypeScript编译器不会抛出错误。</p><p id="e9a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript允许静态类型，同时还允许灵活性。</p><p id="bfbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在TypeScript、ES6或更高版本中，这些功能都可用。<code class="fe mz na nb nc b">let</code>和<code class="fe mz na nb nc b">const</code>应该用来避免与<code class="fe mz na nb nc b">var</code>发生范围冲突。</p><p id="d6d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以获得新类型的元组和枚举。您可以通过执行以下操作来定义元组，即具有固定数量的元素和类型的数组:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a576" class="nh md it nc b gy ni nj l nk nl">let x: [string, number] = ["hello", 1]; <br/></span></pre><p id="421c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果将<code class="fe mz na nb nc b">x</code>设置为<code class="fe mz na nb nc b">[1, “hello”]</code>，TypeScript编译器将会失败。</p><p id="35fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以为常量列表定义一个<code class="fe mz na nb nc b">enum</code>类型。例如:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d35a" class="nh md it nc b gy ni nj l nk nl">enum Color {Red, Green, Blue} <br/>let green: Color = Color.Green;</span></pre><p id="0866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数组在TypeScript中可以有固定的类型。例如，为了定义一个数字数组，我们把:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="02f0" class="nh md it nc b gy ni nj l nk nl">let x: number[] = [1,2,3];</span></pre><p id="1102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，您可以像这样分配数组:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="e729" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">let </strong>x: Array&lt;number&gt; = [1, 2, 3];</span></pre><p id="d756" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果将<code class="fe mz na nb nc b">x</code>设置为<code class="fe mz na nb nc b">['1','2','3']</code>，编译将会失败。</p><p id="85af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript还向属性和方法添加了访问修饰符。您可以选择将属性和方法设置为<code class="fe mz na nb nc b">public</code>、<code class="fe mz na nb nc b">private</code>或<code class="fe mz na nb nc b">protected</code>。</p><p id="b6bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">public</code>属性和方法对所有外部类都可用。<code class="fe mz na nb nc b">protected</code>属性和方法对子类和当前类可用。<code class="fe mz na nb nc b">private</code>属性和方法仅在类中可用。</p><p id="8098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6292" class="nh md it nc b gy ni nj l nk nl">class classA {<br/>  public publicProp: number;<br/>  private privateProp: number;<br/>}</span><span id="a29d" class="nh md it nc b gy nm nj l nk nl">class classB{<br/>  public a: classA;<br/>}</span><span id="039e" class="nh md it nc b gy nm nj l nk nl">let b: classB = new classB();<br/>b.a: classA = new classA();<br/>b.a.publicProp = 1; // OK<br/>b.a.privateProp = 1; // error</span></pre><p id="bae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一行将给出一个错误，因为<code class="fe mz na nb nc b">privateProp</code>对外部类不可用。</p><p id="043e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在项目中包含TypeScript，可以在JavaScript项目文件夹中运行以下内容:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="43f0" class="nh md it nc b gy ni nj l nk nl">$ npm install typescript --save-dev           </span></pre><p id="1df3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是TypeScript提供的一些基本而重要的优势。有了这些特性，它将节省您开发JavaScript应用程序的大量时间！</p></div></div>    
</body>
</html>