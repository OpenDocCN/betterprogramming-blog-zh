<html>
<head>
<title>How an iOS App Launches</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS应用程序如何启动</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-an-ios-app-launches-ae62bbd4ae8e?source=collection_archive---------11-----------------------#2020-03-23">https://betterprogramming.pub/how-an-ios-app-launches-ae62bbd4ae8e?source=collection_archive---------11-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d0cd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解iOS生命周期的最初时刻</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e1a8d36cbc00db5d7d3946435be6a501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AIgSjY_CeMINi-joTZWzmg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@dsmacinnes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丹尼尔·麦金尼斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/begin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9921" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有没有想过在点击应用图标和<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622921-application?language=objc" rel="noopener ugc nofollow" target="_blank">application:didFinishLaunchingWithOptions</a>:</code>之间会发生什么？</p><p id="ad76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我真的很喜欢深入探讨这样的主题，这些主题起初看起来微不足道，但可以极大地增进你对iPhone操作系统的理解。</p><p id="836f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天存在的每一个iPhone应用程序在技术上都可以被描述为对<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/1622933-uiapplicationmain" rel="noopener ugc nofollow" target="_blank">UIApplicationMain(_:_:_:_:)</a></code>函数的一次调用。</p><p id="bfb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等，什么？是的，你没看错。请继续阅读，找出原因。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="fc0a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">UIApplication</h1><p id="9eea" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果您检查<code class="fe lv lw lx ly b">UIApplicationMain(_:_:_:_:)</code>函数，您可以看到它有一个返回类型<code class="fe lv lw lx ly b">Int32</code>。然而，这个函数实际上从不返回。只要你的应用存在，它就存在。</p><p id="94fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法做的第一件事是创建一个名为<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uiapplication" rel="noopener ugc nofollow" target="_blank">UIApplication</a></code>的类。这门课很重要。<code class="fe lv lw lx ly b">UIApplication</code>是在iOS中运行的应用程序的集中控制和协调点。</p><p id="3dcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个iOS应用程序都有这个对象的一个实例。由此，您可以正确地推断出<code class="fe lv lw lx ly b">UIApplication</code>确实是作为<a class="ae ky" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/Singleton.html#//apple_ref/doc/uid/TP40008195-CH49" rel="noopener ugc nofollow" target="_blank">单例</a>实现的。singleton设计模式背后的基本原理是确保在任何给定的时间，一个类只有一个实例是活动的，所以它是这里的完美选择。</p><p id="a31f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你写<code class="fe lv lw lx ly b">UIApplication.shared</code>的时候，你正在访问这个单例对象。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="eced" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">UIApplicationDelegate</h1><p id="7352" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">该函数做的下一件事是创建<code class="fe lv lw lx ly b">AppDelegate</code>，它基本上是一个符合<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate" rel="noopener ugc nofollow" target="_blank">UIApplicationDelegate</a></code>协议的类。你可能已经熟悉了应用代理。它实际上是你可以与之交互的应用程序的根对象。</p><p id="68b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">UIApplicationDelegate</code>是一套用于管理应用共享行为的方法。</p><p id="3c63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意到类声明上面的<code class="fe lv lw lx ly b">@UIApplicationMain</code>标记了吗？它的存在是为了让<code class="fe lv lw lx ly b">UIApplicationMain(_:_:_:_:)</code>函数知道哪个类是应用程序的委托。这个类也会被保留，并在应用程序的生命周期中持续存在。然后被指定为<code class="fe lv lw lx ly b">UIApplication</code>的代表。</p><p id="1fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">application对象通知委托重要的运行时事件，例如，应用程序启动、内存不足警告和应用程序终止，使其有机会做出适当的响应。</p><p id="4c04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在iOS 13中，<code class="fe lv lw lx ly b">AppDelegate</code>的部分职责交给了<code class="fe lv lw lx ly b">SceneDelegate</code>。<code class="fe lv lw lx ly b">AppDelegate</code>仍然负责应用的生命周期，但是<code class="fe lv lw lx ly b">SceenDelegate</code>现在负责屏幕上显示的内容。它处理像屏幕和窗口这样的东西。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="77b6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">故事板？</h1><p id="ff83" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">此时，我们的应用程序的基础已经就绪。<code class="fe lv lw lx ly b">UIApplicationMain(_:_:_:_:)</code>现在可以开始构造用户界面了。</p><p id="c13e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个过程的第一步是找出我们的应用程序是否使用主要的故事板。这是通过检查<code class="fe lv lw lx ly b">Info.plist</code> <em class="nd"> </em>文件来完成的，看看它是否包含一个名为“主要故事板文件基本名称”的键</p><p id="bad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果应用程序使用故事板，<code class="fe lv lw lx ly b">UIApplicationMain(_:_:_:_:)</code>将为我们处理实例化<a class="ae ky" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623056-window" rel="noopener ugc nofollow" target="_blank">应用程序的窗口</a>。窗口是<code class="fe lv lw lx ly b">UIWindow</code>的实例，它是<code class="fe lv lw lx ly b">UIView</code>的子类。窗口基本上就是包含用户界面的东西。</p><p id="cf7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦被实例化，窗口就被赋给了<code class="fe lv lw lx ly b">SceneDelegate</code>的window属性(iOS 13之前的<code class="fe lv lw lx ly b">AppDelegate</code>用来包含这个属性)。</p><p id="8156" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您查看一下您的<code class="fe lv lw lx ly b">SceneDelegate</code>的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uiscenedelegate/3197914-scene" rel="noopener ugc nofollow" target="_blank">scene(_:willConnectTo:options:)</a></code>方法，您会看到下面的注释:</p><p id="afd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">"如果使用故事板，<code class="fe lv lw lx ly b">window</code>属性会自动初始化并附加到场景中."</p><p id="74ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">window</code>属性将被保留，并在应用程序的生命周期内持续存在。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f99c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">初始视图控制器</h1><p id="c860" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">用户不会看到应用程序的窗口，你也不经常需要直接操作它。用户将看到的是窗口的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uiwindow/1621581-rootviewcontroller" rel="noopener ugc nofollow" target="_blank">rootViewController</a></code>属性。</p><p id="089b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rootViewController</code>包含应用的初始视图控制器。您可以设置初始视图控制器，方法是在故事板中选择一个视图控制器，打开属性检查器，并勾选“是初始视图控制器”复选框。</p><p id="b426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦找到，它就被分配给并保留在<code class="fe lv lw lx ly b">rootViewController</code>属性中。它被称为根视图，因为它是窗口中唯一的直接子视图。所有其他视图都将是根视图的子视图。</p><p id="e59e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这时<code class="fe lv lw lx ly b">UIApplicationMain(_:_:_:_:)</code>决定是时候调用我们以前的<code class="fe lv lw lx ly b">application:didFinishLaunchingWithOptions:</code>函数了。</p><p id="7720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">窗口还不可见。要做到这一点，最后一步是调用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uiwindow/1621601-makekeyandvisible" rel="noopener ugc nofollow" target="_blank">makeKeyAndVisible()</a></code>实例方法。</p><p id="59ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，您的iOS应用程序已经准备好，乐趣可以开始了。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="12f3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">没有故事板？</h1><p id="50e2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">然而，你可能知道，使用故事板并不是强制性的。在这种情况下，您必须在代码中做<code class="fe lv lw lx ly b">UIApplicationMain</code>为您做的事情。</p><p id="7b17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在iOS 13之前，这样做的地方应该是<code class="fe lv lw lx ly b">didFinishLaunchingWithOptions</code>。然而，现在您有了<code class="fe lv lw lx ly b">SceneDelegate</code>的<code class="fe lv lw lx ly b">(_willConnectTo:options:)</code>方法来处理这个问题。</p><p id="19f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你要做的是:</p><ul class=""><li id="7a36" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">实例化<code class="fe lv lw lx ly b">UIWindow</code>并将其分配给<code class="fe lv lw lx ly b">SceneDelegate</code>的<code class="fe lv lw lx ly b">window</code>属性。</li><li id="d292" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">实例化您的初始视图控制器，并将其分配给<code class="fe lv lw lx ly b">window</code>的<code class="fe lv lw lx ly b">rootViewController</code>属性。</li><li id="2e58" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">调用<code class="fe lv lw lx ly b">makeKeyAndVisible()</code>将界面呈现给用户。</li></ul><p id="4e12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述内容的基本实现可能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f258" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="73ea" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我上面描述的过程发生在眨眼之间，我们大多数人在开发应用程序时并没有真正考虑这一点。然而，它仍然是应用程序生命周期的精华部分。</p><p id="cfbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您花时间阅读这篇文章。如果你有任何想法、建议或问题，请在下面的评论中留下。</p><p id="fe53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢阅读这篇文章，那么你可能会从我的两篇关于iOS开发和Swift的文章中获得一些价值:</p><div class="nu nv gp gr nw nx"><a href="https://medium.com/better-programming/understand-copy-on-write-in-swift-5-52a4716165a3" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">了解Swift 5中的写入时复制</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">结构、值类型和黑魔法</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a href="https://medium.com/better-programming/befriend-objective-c-as-a-swift-developer-7d529c685299" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">作为Swift开发人员与Objective-C友好相处</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">学会驯服野兽</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="om l oi oj ok og ol ks nx"/></div></div></a></div></div></div>    
</body>
</html>