<html>
<head>
<title>Build a React Redux App With JavaScript Web Tokens</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript Web令牌构建React Redux应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-react-redux-app-with-javascript-web-tokens-9f2b73768e18?source=collection_archive---------1-----------------------#2020-04-06">https://betterprogramming.pub/build-a-react-redux-app-with-javascript-web-tokens-9f2b73768e18?source=collection_archive---------1-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0aef" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">设置应用程序来管理JWT</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4b2926a9985259d9a21a319a983440b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q4DH34WPy9SZ4LnRAYtPcw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Redux、React和JWT徽标</p></figure><p id="f568" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是从头开始创建React Redux应用程序的指南。重点是处理用户注册和登录，然后用JSON Web令牌(JWT)对他们进行认证和授权。请记住，这里介绍的文件结构和方法只是其中之一。</p><p id="d373" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于本指南，我们将向已经创建的Ruby on Rails API发出请求。作为参考，这里指的是<a class="ae lu" href="https://medium.com/better-programming/build-a-rails-api-with-jwt-61fb8a52d833" rel="noopener">产生的Rails API</a>和<a class="ae lu" href="https://github.com/reireynoso/jwt-rails-api-template" rel="noopener ugc nofollow" target="_blank"> repo </a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ea55" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置</h1><p id="c741" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">让我们用Create React App生成一个React应用程序。在终端中，运行:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7965" class="ne md it na b gy nf ng l nh ni">npx create-react-app jwt-react-redux</span></pre><p id="208b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将目录更改为<code class="fe nj nk nl na b">jwt-react-redux</code>，并打开它。从目录中，运行以下命令来安装Redux、React Redux和Redux Thunk。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="daa8" class="ne md it na b gy nf ng l nh ni">npm install redux react-redux redux-thunk</span></pre><p id="b020" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在包方面，我们已经安装了将Redux集成到React应用程序中所需的所有东西。</p><p id="8581" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">提前考虑React应用程序扩展和需要更多数据的时候，最好将我们的actions和reducers组织到两个独立的文件夹中。在<code class="fe nj nk nl na b">src</code>下，我们创建两个文件夹，一个叫做<code class="fe nj nk nl na b">action</code>，一个叫做<code class="fe nj nk nl na b">reducers</code>。我们可能还想考虑为应用程序可能拥有的多个组件创建一个<code class="fe nj nk nl na b">components</code>文件夹。现在，我们将把这些文件夹放在一边，专注于集成Redux。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7f9c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">集成冗余</h1><p id="743b" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">导航至<code class="fe nj nk nl na b">src/index.js</code>。在文件的顶部，我们要添加:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6d74" class="ne md it na b gy nf ng l nh ni">import {Provider} from 'react-redux'</span></pre><p id="87dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nj nk nl na b">Provider</code>将允许我们向组成我们应用程序的所有组件提供Redux <code class="fe nj nk nl na b">Store</code>(它将包含状态)，这意味着<code class="fe nj nk nl na b">Store</code>不必手动传递。相反，想要访问<code class="fe nj nk nl na b">Store</code>的单个组件可以直接访问它。</p><p id="1fcd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将<code class="fe nj nk nl na b">Provider</code>视为一个组件，在<code class="fe nj nk nl na b">Provider</code>标签中，我们提供了应用程序的其余部分，在本例中是<code class="fe nj nk nl na b">App</code>组件。需要将单个道具传递给<code class="fe nj nk nl na b">Provider</code>—<code class="fe nj nk nl na b">Store</code>以便与应用程序的其余部分共享。</p><p id="7e06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在需要使用来自<code class="fe nj nk nl na b">redux</code>的方法创建<code class="fe nj nk nl na b">Store</code>。在顶部，让我们添加:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c962" class="ne md it na b gy nf ng l nh ni">import {createStore} from 'redux'</span></pre><p id="6fbb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nj nk nl na b">createStore</code>是在应用程序开始时调用一次以创建Redux <code class="fe nj nk nl na b">Store</code>的函数。它接受一个参数，一个返回对象的函数。这个功能就是所谓的<code class="fe nj nk nl na b">reducer</code>。</p><h2 id="f707" class="ne md it bd me nm nn dn mi no np dp mm lh nq nr mo ll ns nt mq lp nu nv ms nw bi translated">还原剂</h2><p id="6104" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们可以有多个reducer函数，每个函数负责状态中的一条信息。在本指南中，我们想要一个登录用户的信息和一个额外的例子，一个评论列表(只是一个空数组)。最好为每种类型的信息创建一个reducer函数。</p><p id="8ff8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe nj nk nl na b">src/reducers</code>下，我们创建两个文件:<code class="fe nj nk nl na b">userReducer.js</code>和<code class="fe nj nk nl na b">commentReducer.js</code>。先说<code class="fe nj nk nl na b">userReducer.js</code>。我们想定义一个变量<code class="fe nj nk nl na b">userReducer</code>，并将其设置为一个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/reducers/userReducer.js</p></figure><p id="5b8a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个函数将默认状态作为第一个参数，并将一个动作对象作为第二个参数。在代码块中，action对象将有一个属性:type。基于该类型，状态将发生某些变化。通常使用switch语句来处理不同的情况。</p><p id="3852" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个缩减器必须在另一个文件中使用，所以我们必须导出它。因为我们只想导出一个函数，所以我们使用<code class="fe nj nk nl na b">export default</code>。</p><p id="cac1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们导航到<code class="fe nj nk nl na b">commentReducer.js</code>。这个函数只是一个例子，所以不包含任何信息。同样，让我们创建一个变量<code class="fe nj nk nl na b">commentReducer</code>，并将其设置为一个函数。默认状态是一个空数组作为第一个参数，一个动作对象作为第二个参数。我们还将默认导出这个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/reducers/commentReducer.js</p></figure><p id="d0d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经设置了两个reducers，我们可以将它们都包含在我们的Redux <code class="fe nj nk nl na b">Store</code>中。但是，<code class="fe nj nk nl na b">createStore</code>只能带一个减速器。为了避免这种困境，我们使用Redux的另一个函数，它允许我们组合多个reducers。</p><p id="6a8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe nj nk nl na b">src/reducers</code>下再创建一个文件，命名为<code class="fe nj nk nl na b">index.js</code>。在这个文件中，我们从Redux和reducers导入<code class="fe nj nk nl na b">combineReducers</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/reducers/index.js</p></figure><p id="013c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nj nk nl na b">combineReducers</code>接受一个参数，一个提供键值对的对象。键将代表根状态名，值将是管理它的缩减器。当我们<code class="fe nj nk nl na b">export default</code>这个<code class="fe nj nk nl na b">rootReducer</code>的时候，这将代表我们传入<code class="fe nj nk nl na b">createStore</code>的对象。</p><p id="82ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们导航回<code class="fe nj nk nl na b">src/index.js</code>，导入<code class="fe nj nk nl na b">rootReducer</code>，从Redux导入<code class="fe nj nk nl na b">applyMiddleware</code>，从<code class="fe nj nk nl na b">redux-thunk</code>导入Thunk。简单来说，<code class="fe nj nk nl na b">applyMiddleware</code>和Thunk将用于处理调度中的异步获取。<code class="fe nj nk nl na b">rootReducer</code>将是<code class="fe nj nk nl na b">createStore</code>的第一个参数，<code class="fe nj nk nl na b">applyMiddleware(thunk)</code>将是第二个参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/index.js</p></figure><p id="8cab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在已经创建了Redux <code class="fe nj nk nl na b">Store</code>。下一步是生成更新reducers的动作。</p><h2 id="d387" class="ne md it bd me nm nn dn mi no np dp mm lh nq nr mo ll ns nt mq lp nu nv ms nw bi translated">行动</h2><p id="fd2f" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">由于<code class="fe nj nk nl na b">commentsReducer</code>作为一个例子，它的状态不会改变。我们将关注于为<code class="fe nj nk nl na b">userReducer</code>创建动作。在<code class="fe nj nk nl na b">src/actions</code>下，我们创建一个名为<code class="fe nj nk nl na b">userActions.js</code>的文件。在这个文件中，我们将创建所谓的<em class="nz">动作创建器，以及返回动作对象的</em>函数。它们将包含一个<code class="fe nj nk nl na b">type</code>属性，我们将使用该属性对状态进行适当的更改。更多信息，请参考<a class="ae lu" href="https://redux.js.org/basics/actions/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="c54f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们也有处理异步请求的方法。在这些方法中，我们进行fetch调用，并从发送回来的数据中调用dispatch，使用适当的action对象和返回的数据(如果需要的话)作为参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/actions/用户操作/js</p></figure><p id="bc5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nj nk nl na b">fetchUser</code>、<code class="fe nj nk nl na b">signUserUp</code>和<code class="fe nj nk nl na b">autoLogin</code>是处理对服务器的获取请求的例子。提醒一下，本指南的服务器是从另一个指南生成的Rails API，目前运行在<code class="fe nj nk nl na b">http://localhost:4000</code>上。</p><p id="26d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意:</strong>请求成功后，服务器会返回一个带有<code class="fe nj nk nl na b">user</code>和<code class="fe nj nk nl na b">token</code>属性的对象。<code class="fe nj nk nl na b">token</code>代表服务器生成的JWT，这个会通过<code class="fe nj nk nl na b">localStorage.setItem("token", data.token)</code>存储在浏览器中。当向服务器发出另一个要求认证/授权的请求时，可以通过<code class="fe nj nk nl na b">localStorage.getItem("token")</code>拉出令牌。</p><p id="76e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">提醒:</strong>动作创建者是一个返回对象的函数。简单的称之为不会改变我们的状态。Redux中的一个函数<code class="fe nj nk nl na b">dispatch</code>必须使用一个对象作为参数来调用，以便与<code class="fe nj nk nl na b">Store</code>进行通信。<code class="fe nj nk nl na b">dispatch</code>既可以从组件调用，也可以从动作文件调用。</p><p id="f5bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于在创建<code class="fe nj nk nl na b">Store</code>时集成了<code class="fe nj nk nl na b">applyMiddleware(thunk)</code>，所以<code class="fe nj nk nl na b">fetchUser</code>、<code class="fe nj nk nl na b">signUserUp</code>和<code class="fe nj nk nl na b">autoLogin</code>的方法结构是可能的。还没有展示出来，但是这两个方法会从一个<code class="fe nj nk nl na b">dispatch</code>内部的组件中调用。但是，如前所述，<code class="fe nj nk nl na b">dispatch</code>只能接受一个对象。使用<code class="fe nj nk nl na b">applyMiddleware(thunk)</code>，我们能够传递一个函数定义。</p><p id="01e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有关<code class="fe nj nk nl na b">applyMiddleware</code>功能的更多信息，请参考Thunk的<a class="ae lu" href="https://github.com/reduxjs/redux-thunk/blob/master/src/index.js" rel="noopener ugc nofollow" target="_blank"> GitHub页面。</a></p><p id="1497" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们有多个函数，所以除了<code class="fe nj nk nl na b">setUser</code>之外，我们想对每个函数都使用<code class="fe nj nk nl na b">export</code>。该功能仅在<code class="fe nj nk nl na b">fetchUser</code>、<code class="fe nj nk nl na b">signUserUp</code>和<code class="fe nj nk nl na b">autoLogin</code>的上下文中使用，它们在同一个文件中。现在我们已经设置好了<code class="fe nj nk nl na b">Store</code>、减速器和动作。下一个重点是如何将React组件连接到<code class="fe nj nk nl na b">Store</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d863" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用“连接”将组件连接到商店</h1><p id="274d" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">对于本指南，我们将只关注三个组件:生成的<code class="fe nj nk nl na b">App</code>、<code class="fe nj nk nl na b">LoginComponent</code>和我们将创建的<code class="fe nj nk nl na b">SignUpComponent</code>。让我们对<code class="fe nj nk nl na b">App</code>组件进行一些调整，并设置到商店的连接。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/App.js</p></figure><p id="6674" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在<code class="fe nj nk nl na b">src/components</code>下创建<code class="fe nj nk nl na b">LoginComponent</code>和<code class="fe nj nk nl na b">SignUpComponent</code>，但是现在，我们可以导入它们。但是我们将导入的另一个关键资源是来自React Redux库的一个命名导出<code class="fe nj nk nl na b">connect</code>。</p><h2 id="4e28" class="ne md it bd me nm nn dn mi no np dp mm lh nq nr mo ll ns nt mq lp nu nv ms nw bi translated">探索“connect()”</h2><p id="9592" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">让我们花几分钟观察一下<code class="fe nj nk nl na b">connect()</code>是如何工作的。调用<code class="fe nj nk nl na b">connect()</code>实际上是返回一个函数。我们希望调用返回的函数，传入我们希望将<code class="fe nj nk nl na b">Store</code>连接到的组件——在本例中，它将是<code class="fe nj nk nl na b">App</code>。一旦建立起来，<code class="fe nj nk nl na b">App</code>组件就被连接到<code class="fe nj nk nl na b">Store</code>。</p><p id="dbea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe nj nk nl na b">connect()</code>中，传入的第一个参数是一个函数，通常称为<code class="fe nj nk nl na b">mapStateToProps</code>。<code class="fe nj nk nl na b">mapStateToProps</code>接受一个参数，它代表状态。该函数需要返回一个对象，其中包含状态所需的信息。在这种情况下，我们只需要<code class="fe nj nk nl na b">userReducer</code>信息。为了访问那个对象，我们引用<code class="fe nj nk nl na b">this.props.userReducer</code>。</p><p id="0e48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nj nk nl na b">connect()</code>还接受第二个参数，通常称为<code class="fe nj nk nl na b">mapDispatchToProps</code>。类似于<code class="fe nj nk nl na b">mapStateToProps</code>，它接受一个参数，这个参数代表<code class="fe nj nk nl na b">dispatch</code>。目标是返回一个定义各种道具的对象，这些道具要调用<code class="fe nj nk nl na b">dispatch</code>。道具通常用箭头函数来定义。在这些<code class="fe nj nk nl na b">dispatch</code>调用中，我们可以调用我们在<code class="fe nj nk nl na b">actions</code>中定义的函数，比如<code class="fe nj nk nl na b">fetchUser</code>和<code class="fe nj nk nl na b">signUserUp </code>——但是这些必须首先被导入。</p><p id="99ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意:</strong>并非所有组件都需要来自<code class="fe nj nk nl na b">Store</code>的信息或向<code class="fe nj nk nl na b">Store</code>发送一个<code class="fe nj nk nl na b">dispatch</code>。如果我们只需要信息，我们只需在<code class="fe nj nk nl na b">connect(mapStateToProps)</code>中传入<code class="fe nj nk nl na b">mapStateToProps</code>。否则，如果我们只需要组件发送一个<code class="fe nj nk nl na b">dispatch</code>，我们将第一个参数<code class="fe nj nk nl na b">null</code>留下，并将<code class="fe nj nk nl na b">mapDispatchToProps</code>作为第二个参数传入<code class="fe nj nk nl na b">connect(null, mapDispatchToProps)</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="70c7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用户登录/注册</h1><p id="8459" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">既然我们能够用<code class="fe nj nk nl na b">connect()</code>访问<code class="fe nj nk nl na b">Store</code>，让我们开始从服务器获取用户信息，并将其存储在我们的状态中。除了有一个额外的字段外，<code class="fe nj nk nl na b">LoginComponent</code>和<code class="fe nj nk nl na b">SignUpComponent</code>将非常相似，并且它们将向两个不同的方法发送一个<code class="fe nj nk nl na b">dispatch</code>。先说<code class="fe nj nk nl na b">LoginComponent</code>。</p><h2 id="ee91" class="ne md it bd me nm nn dn mi no np dp mm lh nq nr mo ll ns nt mq lp nu nv ms nw bi translated">注册</h2><p id="6582" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在我们的Ruby on Rails API中，当用户登录时，我们需要传递用户名和密码。我们将在这个组件中实现一个表单，并希望它是可控的。我们将包含一个本地组件状态来跟踪输入。对于这个组件，我们只需要从React Redux导入<code class="fe nj nk nl na b">fetchUser</code>动作和<code class="fe nj nk nl na b">connect</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/components/log in component . js</p></figure><p id="7841" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该组件将只需要向<code class="fe nj nk nl na b">Store</code>发送一个<code class="fe nj nk nl na b">dispatch</code>。它不需要从中获取信息。所以我们用<code class="fe nj nk nl na b">(null, mapDispatchToProps)</code>设置<code class="fe nj nk nl na b">connect</code>。当表单被提交时，一个<code class="fe nj nk nl na b">dispatch</code>被发送到<code class="fe nj nk nl na b">fetchUser</code>方法。<code class="fe nj nk nl na b">fetchUser</code>将把存储在本地状态的凭证作为一个参数。</p><p id="5046" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">提醒一下，在<code class="fe nj nk nl na b">fetchUser</code>函数中，我们向服务器发出一个获取请求，让用户登录。如果凭据匹配，将返回一个包含用户属性和令牌(JWT)的对象。令牌将通过<code class="fe nj nk nl na b">localStorage</code>存储，并将代表我们被认证/授权的方式。</p><p id="ea9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个<code class="fe nj nk nl na b">dispatch</code>在函数中被调用，接受从<code class="fe nj nk nl na b">setUser</code>动作创建器返回的对象。该对象被发送到<code class="fe nj nk nl na b">Store</code>并与<code class="fe nj nk nl na b">reducers</code>通信，转换用户状态信息。</p><h2 id="5642" class="ne md it bd me nm nn dn mi no np dp mm lh nq nr mo ll ns nt mq lp nu nv ms nw bi translated">签名操作</h2><p id="646a" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在我们的Ruby on Rails API中，当用户注册时，我们需要传递用户名、密码和年龄。<code class="fe nj nk nl na b">SignUpComponent</code>与<code class="fe nj nk nl na b">LoginComponent</code>相同，带有一个年龄输入字段。此外，我们从<code class="fe nj nk nl na b">actions</code>导入命名的导出<code class="fe nj nk nl na b">signUserUp</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/components/sign up component . js</p></figure><p id="a27f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和<code class="fe nj nk nl na b">LoginComponent</code>类似，这个组件只关注<code class="fe nj nk nl na b">dispatch</code>。然而，当提交表单时，一个<code class="fe nj nk nl na b">dispatch</code>被发送给<code class="fe nj nk nl na b">signUserUp</code>方法，但是也接受存储在本地状态中的凭证作为参数。同样的过程发生在<code class="fe nj nk nl na b">signUserUp</code>函数内部——将JWT存储到<code class="fe nj nk nl na b">localStorage</code>中，并将包含<code class="fe nj nk nl na b">action</code>类型和用户信息的<code class="fe nj nk nl na b">dispatch</code>发送到<code class="fe nj nk nl na b">reducers</code>。</p><h2 id="cc3f" class="ne md it bd me nm nn dn mi no np dp mm lh nq nr mo ll ns nt mq lp nu nv ms nw bi translated">自动登录</h2><p id="b1b3" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">回到<code class="fe nj nk nl na b">App</code>组件，我们包括了生命周期方法<code class="fe nj nk nl na b">componentDidMount</code>。这个想法是当应用程序加载时，我们希望自动验证/授权一个已经登录的用户。为了实现这一点，我们利用存储在<code class="fe nj nk nl na b">localStorage</code>中的JWT，并将它发送给为我们提供相关用户的服务器。</p><p id="67c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们从actions导入命名的export，<code class="fe nj nk nl na b">autoLogin</code>。我们在<code class="fe nj nk nl na b">connect</code>中设置了<code class="fe nj nk nl na b">mapDispatchToProps</code>，并将道具命名为<code class="fe nj nk nl na b">autoLogin</code>。在<code class="fe nj nk nl na b">componentDidMount</code>内部，我们想要调用这个道具。我们不需要传递任何参数。</p><p id="4a72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe nj nk nl na b">actions</code>的<code class="fe nj nk nl na b">autoLogin</code>函数中，我们向服务器发出一个GET <code class="fe nj nk nl na b">fetch</code>请求。在消息头中，我们将一个授权密钥集传递给<code class="fe nj nk nl na b">Bearer &lt;token&gt;</code>。载体和令牌之间的间隔很重要，因为我们的服务器希望它是这种格式。</p><p id="116a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">服务器接收请求，并根据JWT对用户进行身份验证/授权。一旦响应被发送回来，一个类似的过程将JWT存储到<code class="fe nj nk nl na b">localStorage</code>中，一个包含<code class="fe nj nk nl na b">action</code>类型和用户信息的<code class="fe nj nk nl na b">dispatch</code>被发送到<code class="fe nj nk nl na b">reducers</code>。</p><h2 id="fc4a" class="ne md it bd me nm nn dn mi no np dp mm lh nq nr mo ll ns nt mq lp nu nv ms nw bi translated">注销用户</h2><p id="2da9" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated"><code class="fe nj nk nl na b">logOut</code>的功能不会在应用程序中实现，但它的动作是在<code class="fe nj nk nl na b">actions</code>中创建的。根据我们希望哪个组件具有该功能，我们将从<code class="fe nj nk nl na b">actions</code>导入名为<code class="fe nj nk nl na b">logUserOut</code>的导出。然后可以将一个<code class="fe nj nk nl na b">dispatch</code>发送给<code class="fe nj nk nl na b">Store</code>，将<code class="fe nj nk nl na b">logUserOut</code>作为参数，因为它是object。在<code class="fe nj nk nl na b">userReducer</code>中，用户对象的属性以及被调用的<code class="fe nj nk nl na b">localStorage.clear()</code>将被清除，从而移除JWT。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0699" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">额外奖励:React Redux挂钩替代方案</h1><p id="67d2" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">React Redux提供了一组钩子作为现有<code class="fe nj nk nl na b">connect()</code> <strong class="la iu"> </strong>函数的替代。这些钩子允许您连接到Redux <code class="fe nj nk nl na b">Store</code>并分派动作，而不必将组件包装在<code class="fe nj nk nl na b">connect()</code>中。</p><p id="343c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将把现有的<code class="fe nj nk nl na b">App</code>类组件重新格式化成一个功能组件。由于这将是一个功能组件，我们无法使用生命周期方法。</p><p id="39ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们必须从React、<code class="fe nj nk nl na b">useEffect</code>导入一个命名的导出，以及从React Redux而不是<code class="fe nj nk nl na b">connect</code>导入<code class="fe nj nk nl na b">useSelector</code>和<code class="fe nj nk nl na b">useDispatch</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/App.js(钩子替代)</p></figure><p id="fbde" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代替<code class="fe nj nk nl na b">componentDidMount</code>，我们将实现<code class="fe nj nk nl na b">useEffect</code>函数。它接受两个参数，一个函数和一个空数组。该函数在组件每次呈现时运行。该数组包含依赖项列表。如果其中一个依赖关系的值改变，<code class="fe nj nk nl na b">useEffect</code>将再次执行。我们将它作为一个空数组，以避免可能出现的渲染无限循环。</p><p id="a743" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有关React挂钩的更多信息，请参考本文。</p><p id="9881" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nj nk nl na b">useSelector</code>相当于<code class="fe nj nk nl na b">mapStateToProps</code>。接受一个函数，其中状态是参数，我们隐式返回state中的一个特定值。<code class="fe nj nk nl na b">useDispatch</code>相当于<code class="fe nj nk nl na b">mapDispatchToProps</code>。调用它将返回一个<code class="fe nj nk nl na b">dispatch</code>，它将接收<code class="fe nj nk nl na b">autoLogin</code>。</p><p id="295d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于React Redux挂钩的更多信息，请参见<a class="ae lu" href="https://levelup.gitconnected.com/react-redux-hooks-useselector-and-usedispatch-f7d8c7f75cdd" rel="noopener ugc nofollow" target="_blank">本文</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f870" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结束语</h1><p id="358e" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">现在你知道了！我们已经创建了一个React Redux应用程序，它管理用户验证/授权的JWT。这涵盖了一个非常基本的设置，没有考虑到边缘情况，比如如果请求没有返回用户怎么办？如果您准备好了，请扩展基本构建模块，包括注销功能和解决边缘情况。感谢您的阅读！</p><p id="03f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有关详细信息，请参考我的存储库:</p><ul class=""><li id="2ce5" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated"><a class="ae lu" href="https://github.com/reireynoso/jwt-react-redux-template" rel="noopener ugc nofollow" target="_blank"> GitHub回购</a></li></ul></div></div>    
</body>
</html>