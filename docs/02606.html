<html>
<head>
<title>How To Count Occurrences in a Python List</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何计算Python列表中的出现次数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-count-occurrences-in-a-python-list-f799072538b3?source=collection_archive---------1-----------------------#2019-12-12">https://betterprogramming.pub/how-to-count-occurrences-in-a-python-list-f799072538b3?source=collection_archive---------1-----------------------#2019-12-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a67d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">哪一个最快:filter()、list comprehension或。count()？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/55250e1a349d25bf12bedd13e420237c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*68fPZL6QCXC19wgqi32-MA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@loic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Djim Loic </a>在<a class="ae ky" href="https://unsplash.com/s/photos/count?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="aae8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算一个值在一个列表中出现的次数是一项常见的任务，无论你是计算失败的清单项目的数量，通过测试的学生的数量，甚至是一颗红色糖果的数量。</p><p id="b593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与编程中的大多数事情一样，有许多方法可以解决同一个问题。我们将看看三种不同的选择:列表理解、<code class="fe lv lw lx ly b">filter()</code>和<code class="fe lv lw lx ly b">count()</code>方法。</p><p id="4b75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有两句话概述每一个以及为什么包括它们。</p><ul class=""><li id="e190" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><strong class="lb iu">列表理解</strong>:数据理解是Python的一个标志性特征，它支持使用函数、<code class="fe lv lw lx ly b">if</code>逻辑，甚至嵌套迭代来定义列表。当你试图思考Pythonic时，你的大脑倾向于问这样一个问题，“我能用理解来做这个吗？”</li><li id="4614" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><strong class="lb iu"/><code class="fe lv lw lx ly b"><strong class="lb iu">filter()</strong></code><strong class="lb iu">函数</strong>:<code class="fe lv lw lx ly b">filter()</code>函数——<a class="ae ky" href="https://medium.com/better-programming/how-to-start-using-map-filter-and-reduce-e01edba0d81?" rel="noopener">许多其他流行语言</a>中的一个方法——是一个通用的实现，它用一个表达式查询每一项，并且只保留那些评估为<code class="fe lv lw lx ly b">true</code>的项。如果您来自另一种语言，您可能对这种方法很熟悉，因此，它作为一种选择出现。</li><li id="2fd6" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><strong class="lb iu"/><code class="fe lv lw lx ly b"><strong class="lb iu">.count()</strong></code><strong class="lb iu">方法</strong>:由于filter是其他语言的内置方法，Python列表内置了<code class="fe lv lw lx ly b">.count()</code>方法。很多时候，解决问题是我们的天性；然而，看看有什么现成的是值得的。</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="854d" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">如何计算Python列表中的出现次数</h1><h2 id="3a09" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">使用列表理解</h2><p id="81db" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">列表理解是一种创建新列表的速记技术。在Python中，我们能够在方括号中嵌入一个<code class="fe lv lw lx ly b">for</code>循环和一个条件<code class="fe lv lw lx ly b">if</code>表达式来形成我们的新数组。</p><p id="89b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要做的是，在遍历原始列表时，将表达式设置为只包含我们要查找的项。一旦我们有了过滤后的列表，我们就使用<code class="fe lv lw lx ly b">len()</code>函数来获得我们的计数。</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="0623" class="nm mv it ly b gy oh oi l oj ok">numbers = [1,1,2,4,5,3,2,1,6,3,1,6]</span><span id="50e2" class="nm mv it ly b gy ol oi l oj ok">sixes = [<br/>   number<br/>   for number in numbers<br/>   if number == 6<br/>]</span><span id="7e6b" class="nm mv it ly b gy ol oi l oj ok">count_sixes = len(sixes)</span></pre><p id="0635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，为了清楚起见，我将列表理解分成了多行。第一行是我们的临时变量名。因为我们没有修改这个值，所以这里没有什么特别的事情发生。第二行是<code class="fe lv lw lx ly b">for</code>循环，它将把<code class="fe lv lw lx ly b">numbers</code>中的每一项分配给临时变量<code class="fe lv lw lx ly b">number</code>。第三行是我们的条件，它将决定列表中包含哪些项目。</p><h2 id="6efc" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">使用filter()函数</h2><p id="224f" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated"><code class="fe lv lw lx ly b">filter()</code>函数将接受两个参数:一个函数和一个序列。序列将是我们的列表，函数将是一个<a class="ae ky" href="https://medium.com/better-programming/how-to-use-lambda-expressions-in-python-a96330b513d4?" rel="noopener"> lambda表达式</a>，这是一个单行匿名表达式——类似于匿名函数。</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="53e3" class="nm mv it ly b gy oh oi l oj ok">numbers = [1,1,2,4,5,3,2,1,6,3,1,6]</span><span id="71d7" class="nm mv it ly b gy ol oi l oj ok">sixes = list(filter(lambda number: number == 6, numbers))</span><span id="e4cb" class="nm mv it ly b gy ol oi l oj ok">count_sixes = len(sixes)</span></pre><p id="9f8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">lambda表达式与list comprehension示例有许多相似之处。为了明确语法，临时变量被定义在关键字<code class="fe lv lw lx ly b">lambda</code>之后，冒号之前。表达式如下，只有评估为<code class="fe lv lw lx ly b">True</code>的值将被包含在我们的过滤器中。</p><p id="1e3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">认识到<code class="fe lv lw lx ly b">filter()</code>函数返回一个过滤器对象也很重要。因此，我们需要将其返回强制到一个列表中，然后确定长度。</p><h2 id="1ecb" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">使用。count()列表方法</h2><p id="ad16" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated"><code class="fe lv lw lx ly b">.count()</code>方法内置于list类中，与list表达式和<code class="fe lv lw lx ly b">filter()</code>不同，我们在这里不会使用表达式。要使用<code class="fe lv lw lx ly b">.count()</code>，您需要做的就是传递圆括号内匹配的值。</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="740e" class="nm mv it ly b gy oh oi l oj ok">numbers = [1,1,2,4,5,3,2,1,6,3,1,6]</span><span id="7612" class="nm mv it ly b gy ol oi l oj ok">count_sixes = numbers.count(6)</span></pre><p id="d7e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">超级简单。正是这些类型的本地方法，让许多在阅读手册之前就开始钻研的人错过了。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="6f29" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">确定最快的技术</h1><h2 id="664f" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">测试场景</h2><p id="c04b" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">为了测试哪种技术最快，我编写了一个简单的测试脚本，创建了1，000，000个从1到100，000的随机整数的列表，以及1到100，000之间的搜索值。</p><p id="6745" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个方法的时间将被记录下来，这个场景将运行10次。最后，每项技术的平均时间将用于比较。</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="f181" class="nm mv it ly b gy oh oi l oj ok">from random import randint<br/>import time</span><span id="e12d" class="nm mv it ly b gy ol oi l oj ok">count_time = []<br/>list_time = []<br/>filter_time = []</span><span id="28b8" class="nm mv it ly b gy ol oi l oj ok">for _ in range(0,10):<br/>    numbers = [randint(1,100000) for _ in range(0,1000000)]<br/>    search = randint(1,1000000)</span><span id="2971" class="nm mv it ly b gy ol oi l oj ok">    count_start = time.time()<br/>    count_matches = numbers.count(search)<br/>    count_time.append(time.time() - count_start)</span><span id="2516" class="nm mv it ly b gy ol oi l oj ok">    list_start = time.time()<br/>    list_matches = len([x for x in numbers if x == search])<br/>    list_time.append(time.time() - list_start)</span><span id="d3c9" class="nm mv it ly b gy ol oi l oj ok">    filter_start = time.time()<br/>    filter_matches = len(list(<br/>        filter(lambda x: x == search, numbers)<br/>    ))<br/>    filter_time.append(time.time() - filter_start)</span><span id="23bf" class="nm mv it ly b gy ol oi l oj ok">print(sum(count_time)/len(count_time))<br/>print(sum(list_time)/len(list_time))<br/>print(sum(filter_time)/len(filter_time))</span></pre><h2 id="377b" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">结果</h2><p id="d4e3" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">速度测试的结果如下:</p><ul class=""><li id="f2b7" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><strong class="lb iu">计数方法</strong>:0。46860 . 68686868661</li><li id="7ff9" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><strong class="lb iu">过滤功能</strong>:0 . 46860 . 46866868661</li><li id="5859" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">列表理解:0 . 46860 . 36868686861</li></ul><p id="1490" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这三种技术都不是特别慢，但是<code class="fe lv lw lx ly b">.count()</code>方法无疑是最好的。此外，排在第二位的<code class="fe lv lw lx ly b">filter()</code>函数更接近于计数的速度，而不是列表理解的速度。</p><p id="71c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于<code class="fe lv lw lx ly b">.count()</code>不仅速度最快，而且最容易阅读和编写，我相信它在客观上优于其他两个类似用例的选项。</p></div></div>    
</body>
</html>