<html>
<head>
<title>3 Mistakes Junior Developers Make With a React Component’s State</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初级开发人员对React组件状态犯的3个错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-mistakes-junior-developers-make-with-a-react-components-state-997043291b54?source=collection_archive---------3-----------------------#2020-06-26">https://betterprogramming.pub/3-mistakes-junior-developers-make-with-a-react-components-state-997043291b54?source=collection_archive---------3-----------------------#2020-06-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7d69" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及如何停止制造它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/42ded0db0b1f549cfde2de503008c846.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lIYGOdkZoD9RVFH4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jamie452?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰米街</a>上<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">的Unsplash </a>拍摄。</p></figure><p id="e36e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于web开发，我最喜欢的一点是总有新的东西要学。你可能花了一生的时间来掌握各种编程语言、库和框架，但仍然不知道所有的东西。</p><p id="dfec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们都在学习，这也意味着我们都容易犯错误。这是可以的。目标是变得更好，变得更好。如果你犯了错误并从中吸取教训，你就做得很好！但是如果你没有学到任何新的东西，并且不断重复犯同样的错误，那么听起来你的职业生涯可能会停滞不前。</p><p id="f76a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本着这种精神，下面是我在代码评审中经常看到的三个初级开发人员在处理React组件状态时会犯的常见错误。我们将看看每个错误，然后讨论如何修复它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="053f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.直接修改状态</h1><p id="f520" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当改变一个组件的状态时，重要的是返回一个修改过的状态的新副本，而不是直接修改当前状态。如果您错误地修改了组件的状态，React的区分算法将不会捕捉到更改，并且您的组件将不会正确更新。</p><p id="baf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子。假设你有这样一个状态:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1fc4" class="ne md it na b gy nf ng l nh ni">this.state = {<br/>  colors: ['red', 'green', 'blue']<br/>}</span></pre><p id="5266" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你想给这个数组添加颜色<code class="fe nj nk nl na b">yellow</code>。这样做可能很诱人:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c3fa" class="ne md it na b gy nf ng l nh ni">this.state.colors.push('yellow')</span></pre><p id="043c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">甚至是这个:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bb0d" class="ne md it na b gy nf ng l nh ni">this.state.colors = [...this.state.colors, 'yellow']</span></pre><p id="38c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这两种方法都是不正确的！当更新类组件中的状态时，您总是需要使用<code class="fe nj nk nl na b">setState</code>方法，并且您应该总是小心不要改变对象。</p><p id="a6ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将元素添加到数组的正确方法如下:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e496" class="ne md it na b gy nf ng l nh ni">this.setState(prevState =&gt; ({ colors: [...prevState.colors, 'yellow'] }))</span></pre><p id="16bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我们犯了第二个错误。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="19fe" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.设置依赖于前一状态而不使用函数的状态</h1><p id="9488" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有两种方法可以使用<code class="fe nj nk nl na b">setState</code>方法。第一种方法是提供一个对象作为参数。第二种方法是提供一个函数作为参数。那么，你什么时候想用一个而不是另一个呢？</p><p id="ad77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您有一个可以启用或禁用的按钮，您可能会有一个名为<code class="fe nj nk nl na b">isDisabled</code>的状态，其中包含一个布尔值。如果您想将按钮从启用状态切换到禁用状态，那么编写类似这样的代码，使用一个对象作为参数是很有诱惑力的:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5cd3" class="ne md it na b gy nf ng l nh ni">this.setState({ <!-- -->isDisabled<!-- -->: !this.state.<!-- -->isDisabled<!-- --> })</span></pre><p id="182f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，这有什么错呢？问题在于React状态更新可以是批处理的，这意味着多个状态更新可以在一个更新周期中发生。如果您的更新是批处理的，并且您有多个更新处于启用/禁用状态，那么最终结果可能不是您所期望的。</p><p id="6130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新此处状态的更好方法是提供前一状态的函数作为参数:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f187" class="ne md it na b gy nf ng l nh ni">this.setState(prevState =&gt; ({ <!-- -->isDisabled<!-- -->: !prevState.<!-- -->isDisabled<!-- --> }))</span></pre><p id="752e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，即使您的状态更新是批处理的，并且对启用/禁用状态的多次更新是一起进行的，每次更新都将依赖于正确的先前状态，以便您总是以您期望的结果结束。</p><p id="3966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于像递增计数器这样的事情也是如此。</p><p id="17f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要这样做:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="230d" class="ne md it na b gy nf ng l nh ni">this.setState({ counterValue: this.state.counterValue + 1 })</span></pre><p id="9e63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行以下操作:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="dfa1" class="ne md it na b gy nf ng l nh ni">this.setState(prevState =&gt; ({ counterValue: prevState.counterValue + 1 }))</span></pre><p id="2792" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的关键是，如果你的新状态依赖于旧状态的值，你应该总是使用一个函数作为参数。如果设置的值不依赖于旧状态的值，则可以使用对象作为参数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d07b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.忘记了setState是异步的</h1><p id="895c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后，重要的是要记住<code class="fe nj nk nl na b">setState</code>是一个异步方法。例如，假设我们有一个状态如下的组件:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2357" class="ne md it na b gy nf ng l nh ni">this.state = { name: 'John' }</span></pre><p id="b65b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们有一个方法来更新状态，然后将状态记录到控制台:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e81e" class="ne md it na b gy nf ng l nh ni">this.setState({ name: 'Matt' })<br/>console.log(this.state.name)</span></pre><p id="4da0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能认为这会将<code class="fe nj nk nl na b">'Matt'</code>记录到控制台，但事实并非如此！它记录了<code class="fe nj nk nl na b">'John'</code>！</p><p id="1b0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因是，<code class="fe nj nk nl na b">setState</code>是异步的。这意味着当它到达调用<code class="fe nj nk nl na b">setState</code>的代码行时，它将开始状态更新，但是它下面的代码将继续执行，因为异步代码是非阻塞的。</p><p id="f425" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有需要在状态更新后运行<em class="nm">的代码，React允许您提供一个回调函数，在更新完成后运行。</em></p><p id="6f8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新后记录当前状态的正确方法是:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4c38" class="ne md it na b gy nf ng l nh ni">this.setState({ name: 'Matt' }, () =&gt; console.log(this.state.name))</span></pre><p id="5174" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好多了！现在，它可以像预期的那样正确记录<code class="fe nj nk nl na b">'Matt'</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6e92" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="0679" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你有它！三个常见错误以及如何改正。记住，犯错是可以的。你在学习。我正在学习。我们都在学习。让我们继续学习，一起变得更好。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="b027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">更新:想学习这些同样的概念，但是用函数组件和钩子？在这里看我的后续文章！</em></p><div class="nn no gp gr np nq"><a href="https://medium.com/better-programming/3-mistakes-junior-developers-make-with-react-function-component-state-8a744ab99a0d" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">初级开发人员在使用React函数组件状态时犯的3个错误</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">“初级开发人员对React组件状态犯的3个错误”的后续</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">medium.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ks nq"/></div></div></a></div></div></div>    
</body>
</html>