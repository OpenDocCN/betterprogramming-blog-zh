# 用函数式编程治愈冒名顶替综合症

> 原文：<https://betterprogramming.pub/cure-impostor-syndrome-with-functional-programming-f9c489986c76>

## 一个高级开发人员转向函数式编程的旅程

![](img/88a6baaf33ed5485fdaf51c4ef949cb1.png)

阿里安·达尔维什在 [Unsplash](https://unsplash.com/search/photos/programming?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

十年的网络开发让我觉得自己像尼欧，在他遇见墨菲斯之前。这个世界有些不对劲。我有一些线索，但是我不能确切地解释它是什么。

我的日常语言是 JavaScript。我最终决定成为一名教师，向初学者和大三学生解释如何制作真实世界的 webapps。

我转行并不是因为觉得自己已经站稳了脚跟，事实上恰恰相反。我想成为一名教师，这样我就可以提升我的技能，质疑它们，并治愈我自己的冒名顶替综合症。

在获得学位并在某一领域实践十年后，谁会觉得自己是个骗子；永远的新人？当然是程序员。

但是为什么呢？我会试着解释我的发现。

我过去常常这样开始我的编程课:“要成为一名优秀的程序员，你根本不需要数学。我们需要解决问题的人。”

当然还有:“凡事皆有工具。如果你知道在哪里找到并使用合适的资源，你甚至不需要成为一名优秀的程序员。”

甚至:“由于行业变化如此之快，你必须每年学习一个框架来跟上潮流。”

当我们谈论质量时，我总是提倡明智选择的 camelCase 变量名。有人问我为什么 web 这么乱，我描述了 JavaScript 的弱点和疲劳(JS，一种没人学的语言)，编码员的懒惰，缺乏测试/devo PS/设计模式/质量工具等等。

当谈到冒名顶替综合症时，即使我深受其害，我也只是试图让人们放心:“继续发布应用，它就在你的脑海里，它会随着你的成就而消失。”

然而，我的冒名顶替综合症没有及时消失——我的成就消失了。

我的所有网站和应用都消失了。我的第一个 PHP &[ASP.NET](https://www.asp.net/)定制 CMS，我的 [Java](https://www.java.com/) &早期[节点](https://nodejs.org/)后端，我的 [jQuery](https://jquery.com/) 插件，我的 [Dojo](https://dojo.io/) 应用，我的 [Ruby on Rails](https://rubyonrails.org/) 项目，我的 [AngularJS](https://angularjs.org/) 登陆页面和 [Ionic](https://ionicframework.com/) 移动应用，甚至我最近用 [Vue 1](https://v1.vuejs.org/) 、 [Angular](http://blog.angularjs.org/2015/12/angular-2-beta.html)

我知道为什么。那些项目太大而不能改变，而且问题太多——技术容易腐烂，投资流不一致，新的编码员太缺乏经验而不能扩展现有的代码库。

甚至用最佳实践完成的工作也丢失了，死了，在地狱里燃烧。DDD，设计模式，API，微服务，TDD，linters + prettiers，评论， [GitFlow](https://datasift.github.io/gitflow/IntroducingGitFlow.html) ，最佳框架和库， [Docker](https://www.docker.com/) ，CI/CD 和 DevOps，KISS， [Redux](https://redux.js.org/introduction/getting-started) ，[react vex](http://reactivex.io/)，[敏捷](https://www.agilealliance.org/agile101/)管理，任务运行者和传输者，结对编程和评审等。

我们什么都试过了。但在所有这些之后，项目中的某些东西仍然是不好的。代码库将不断更新，直到它变得太大；然后我们想从头开始重新编码。这显然是个恶性循环。

如果我一直都错了呢？十年的错误？

如果对于我们在网络开发和计算机科学中造成的混乱有一个不同的解释会怎么样？

如果我们错过的东西实际上与我所教的正好相反呢？

如果是这样，让我们颠倒一下说明。

*   不要再像热心的猴子修补者一样试图解决问题。
*   在不了解基础知识的情况下，停止组合不可靠的工具。
*   不要把每一个代码都关在笼子里，让我们知道我们会创造出恐怖的怪物。
*   停止用更多的代码填充无尽的空白。
*   停止选择名字或开发静态 API 绑定到多用途的问题，与易腐的目的。
*   停止开发新的数据结构，而不表达现有数据结构的潜力。
*   停止每月改变技术、框架和代码库——以一种在 10 年后更加可靠和可用的方式修改它们。
*   别再冒充了。

# 函数式编程

你听说过函数式编程吗？

是的，当然，因为每一个大的语言、公司和思想领袖已经在这个方向上采取了几年的措施。

但是函数式编程是关于什么的呢？

两年前，我去了离我最近的大学图书馆，试图找到关于单子、Lambda 微积分、半群、组合子、线性代数、高阶函数和其他当我们发现 FP 时出现的主题的书。

我天真地搜索计算机科学书籍，一无所获。

几周前，我去同一个地方找了一本关于布尔代数的书，准备上课。

图书馆助理带我去了数学书架，在那里我发现了圣杯——50 本旧书，涵盖了你能在函数式编程的幻想世界中找到的一切。

在我翻开的第一本布满灰尘的书里，我清楚地解释了 Monoï ds，以及你可以用它们做的操作。

这是一个启蒙的时刻，安眠药就在这个架子上。十年来我一直在寻找的答案非常简单:“数学很重要”。我仍然不明白 Monoï ds 的一切，但我现在可以清楚地看到路径，矩阵的绿色字符落在我周围。

为什么程序不起作用？

为什么我们需要每两年彻底重写一次？

因为他们缺乏数学。当然了。

我们想整天操纵“0”和“1”，但我们甚至不知道简单的(布尔)代数，如恒等式、交换性、可结合性、幂等性等。

解决问题不是*的*技能——花时间重新发明和修补(即使聪明地)仍然会增加代码库，创造一种没人愿意支付的“技术债务”。

那么我们需要什么？

我们需要的是更少的代码。

我们需要的是证明它有效。不是昂贵的“TDD 证明”,而是一种肯定能解决所有问题的方法。

我们需要的是除了 a、b 或 c 之外不需要任何其他变量名称的可伸缩性级别。我们的函数将如此简单、通用、稳定、可组合、经得起未来考验，以至于现在和 30 年后都可以以同样的方式阅读和使用。

我们需要的不是随处可见的人为限制和工具来避免糟糕的代码或糟糕的实践，而是随处可见的代数。

我们需要的是停止冒充，最终开始为计算机思考，像它一样思考。我们正在编程的这台机器，这个能够巧妙计算一切的概念。这将是困难的。至少对我来说很艰难。

电脑开机后会做什么？

它将来自 DD 的数据作为输入，并将其计算为我们的设备需要的输出。然后，它等待新的输入，允许我们开发程序或应用程序来再次映射某些输出。

只有两种情况:

*   如果已经计算过了，我们只需要内存。
*   如果要计算，我们需要一个函数。

为什么我们把如此简单的事情复杂化了？我们没有学习数学，而是选择发明一个由流行文化语言和工具组成的神秘世界，这些语言和工具或多或少可以解决任何类型的问题。

每次我们试图见机行事时，我们都会制造更多的问题。

这是面向 bug 的编程。

在信息学的早期，执行计算的方法仍然需要被发现。那时候，为了组织一切，创造新的词汇和语言来重复使用基本计算，找到变通办法是可以的。

现在不知道和利用我们所拥有的是一种耻辱。计算机和语言如此可靠，以至于它们可以从一个设计良好的函数中无误地计算出数万亿的数据。除了对纳米级晶体管的影响之外，它仍然是可靠的，并且我们可以说该功能是“纯”的。

谁擅长函数，知道它们所有肮脏的小秘密？当然是数学家。

用那种力量吧！CPU 工程师已经完成了他们的工作。现在，让他们看看我们这边能做些什么。更不用说信息学领域的新问题是关于异步性、多线程和并发性——FP 的主要目的，它存在的原因。

那我现在要教什么呢？

不要改变语言或框架，而是改变你的想法。

继续使用 docker，linters，DDD，TDD，任何可以帮助你提供可靠应用的东西。

但是，在你的日常工作中:

*   停止写更多的代码，更多的数据结构，API 和类。少写点，直到得到一个核心的一行一个参数的可重用纯函数。去最小的地方。
*   尝试像专业人士一样使用这些函数，并在您编写的美丽过程之前和之后保留真实世界的“效果”。
*   开始循序渐进地学习函数式编程。将其视为成为一名自信的高级程序员的数学前提。
*   开始使用 FP 世界的函数，只是为了看看它们把你引向哪里(映射、过滤、归约、管道等。).
*   开始写自己的高阶函数。然后从它们有用的数学特性中获益。

你想从设计模式开始吗？

以下是一个适用于任何规模项目的“洋葱”模式:

*   你的编程语言是一个隐含层，你必须彻底学习。
*   为你的语言中缺少的核心函数编写一个代码层，比如“log”、“not”、“even”、“odd”、“concat”、“map”、“reduce”、“filter”、“compose”、“pipe”等等。或者你可以用一个现有的，像[拉姆达](https://ramdajs.com/)或者[洛达什](https://github.com/lodash/lodash/wiki/FP-Guide)，但是如果是这样，那就好好学。让我们称他们为 *utils* 。
*   您的“领域”功能和数据模型的层，您可以在您的领域、公司或业务的每个项目中重用该层。姑且称他们为*帮手*。
*   当前程序功能和数据模型层。让我们称它们为*服务*。
*   顶层，是你的程序，在这里你可以控制数据、函数和效果。理想情况下，这是唯一一个可以用前端框架来完善代码库的地方。因此，如果你改变你的框架，你可以保留其余的。

每一层都是前几层的简单组合。如果你尊重这个顺序，那么你可以在任何时候放下上层，使用上一层。

对于一个小项目或 POC，只需使用两到三层即可。

新一代编码员来了。目前全世界有数百万人在学习和训练；由于高薪和有趣工作的“吸引效应”而放大。

大多数人认为成为一个问题解决者或者“学习什么是公共静态 void 方法”或者“开始一个流行的框架”，就足以创建工作应用程序。如果您只需要一次性程序，就是这种情况。

你可以带着这些幻想度过整个职业生涯，在和我有相同信仰体系的人周围寻找安慰。因此，未完成和无法完成的产品的日常生产更新问题将会增加，就像 JavaScript 疲劳本身一样。

但是也有希望。许多年轻的程序员没有被 OO 经典之旅或命令式方法格式化。他们不想仅仅用意大利面条式的代码来解决问题。有些人已经迷上了函数式编程。

所以，趁早跳上 FP 列车吧。互联网处于原始的混乱状态，但我们将一起重塑它。这将对未来产生影响，你将成为我们迫切需要的同事、导师或老师。

但是，请善待那些还不知道好消息的人，我们不想把他们抛在身后。揭露真相需要时间。

我想做一个假设，来更好地解释我自己的旅程。

JavaScript 为什么这么快就变得这么流行？为什么有些编码员会爱上它，尽管它有明显的缺陷？我认为这仅仅是因为它的*作为值*的功能，它诱惑了每一个使用它的编码者。

他们不知道为什么感觉这么好，但他们留在那里，自然变得雄辩，要求更多。也许这种直觉会引导你走向 FP，就像我一样。不要等到多年以后才睁开眼睛，从今天开始。

但是要小心，如果 JavaScript 因为这个原因诱惑了你，而你从未学会如何管理它，最终你会得到一个有缺陷的代码。

那我呢？自从我开始使用这个范例，我的程序不仅更好，而且更真实，在控制之下，最终真正可靠。我的代码库每天都在减少。在我的程序员/教师生涯中，我从未感到如此快乐，因为我终于知道我在做什么了。

重构现在是一种乐趣。感觉就像一个游戏，我说:“哦！我可以用这种方式分解它，它只是我已经知道的简单事物的组合！”

我仍然可以从数学中学到很多东西，因为这些年来我一直在回避它。

但是现在，我的冒名顶替综合症开始消失了。我永远不会完全摆脱它，因为我仍然相信正信(*初学者心态——禅宗*)，但它不再吓我了。

感谢您的阅读，祝您一切顺利。

loc Truchot

PS:如果你想一头扎进前端 FP，而不是从你的语言开始，你可以试着学习 [PureScript](http://www.purescript.org/) 、 [ClojureScript](https://clojurescript.org/) 、[react](https://reasonml.github.io/reason-react/)、fp-ts 或者 [Elm](https://elm-lang.org/) (我个人的最爱)。他们的目标是 JavaScript，但是强迫你作为一个函数式程序员来思考。