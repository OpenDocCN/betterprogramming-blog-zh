<html>
<head>
<title>Introducing SwiftUI List Bindings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI列表绑定简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introducing-swiftui-list-bindings-a150410b836b?source=collection_archive---------8-----------------------#2021-06-10">https://betterprogramming.pub/introducing-swiftui-list-bindings-a150410b836b?source=collection_archive---------8-----------------------#2021-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4a7c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">SwiftUI现在允许在列表中使用项目绑定。看看它是如何在幕后实现的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4c7d8cf02dbfe4942fae39173e419ed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PA1M326CjpRx7DyV.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="8dc9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">列表可能是iOS应用中最受欢迎的UI元素之一，自<code class="fe lu lv lw lx b">UITableViewController</code>首次推出以来，我们已经走过了漫长的道路。在UIKit中创建列表并不完全是火箭科学，但它确实需要一些仪式。</p><p id="1141" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SwiftUI让创建列表变得非常简单。看看这个显示待办事项列表的片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="ebb2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只用三行代码，我们就能创建一个简单的列表视图。</p><p id="b8e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们试图使列表行中的项目可编辑，事情就会变得稍微复杂一些。例如，<code class="fe lu lv lw lx b">TextField</code>需要绑定到我们想要编辑的元素:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="6918" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，直到现在，SwiftUI还没有提供一种简单的方法来访问集合项的可变绑定。这就是为什么我们最终构建了这样的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="d2ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码不仅看起来比实际需要复杂得多，而且它还迫使SwiftUI重新呈现整个列表，即使我们只更改了列表中的一个元素。这可能会导致缓慢的用户界面更新和闪烁。</p><p id="632f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从WWDC 2021开始，SwiftUI支持列表元素的绑定。要使用这个特性，我们需要做的就是将集合的绑定传递到列表中，SwiftUI会将当前元素的绑定传递到闭包中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="87d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码更容易阅读，看起来与我们开始时的原始代码相似。最棒的是:您可以将这段代码回部署到任何支持SwiftUI的iOS版本中。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="143c" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">在幕后</h1><p id="f781" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">我相信你会欣赏这给你的代码带来的更多的简单性。更简单的代码意味着更少的错误，这也使得它更容易读写。</p><p id="c7f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是它是如何工作的呢？</p><p id="938f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，有几件事凑在一起，使这成为可能。让我们首先看看是什么使得在<code class="fe lu lv lw lx b">List</code>(顺便说一下，还有<code class="fe lu lv lw lx b">ForEach</code>)中使用绑定成为可能。</p><p id="b2ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们跳到<code class="fe lu lv lw lx b">List</code>初始化器的定义(使用<code class="fe lu lv lw lx b">⌃ + ⌘ + J</code>或<code class="fe lu lv lw lx b">⌃ + ⌘ + Click</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="104d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">快速浏览一下<a class="ae ne" href="https://developer.apple.com/documentation/swiftui/list?changes=latest_minor" rel="noopener ugc nofollow" target="_blank">文档</a>(打开API差异)可以发现这是12.5到13.0b1的一个新增内容。</p><p id="558b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们解开这个新的初始化签名告诉我们什么:</p><ul class=""><li id="7db4" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">第一个参数(<code class="fe lu lv lw lx b">data: Binding&lt;Data&gt;</code>)定义了初始化器期望一个在<code class="fe lu lv lw lx b">Data</code>上通用的绑定(例如，一个数组，就像我们的例子)。</li><li id="8ebc" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">第二个参数(<code class="fe lu lv lw lx b">@ViewBuilder rowContent: @escaping (Binding&lt;Data.Element&gt;) -&gt; RowContent</code>)定义了结尾闭包，我们在其中定义了列表的主体。这个签名向我们展示了闭包将接收一个绑定，这个绑定是数据集合的元素类型的泛型。</li></ul><p id="2685" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这使得我们可以传入一组绑定，并在<code class="fe lu lv lw lx b">List</code>的主体中一个接一个地接收它们。</p><p id="862b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但这只是等式的一部分！为什么我们可以使用<code class="fe lu lv lw lx b">$</code>符号语法？</p><p id="2067" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了理解这一点，我们需要做更多的API考古——或者从从事这方面工作的人那里得到一点提示。谢谢，<a class="ae ne" href="https://twitter.com/hollyborla" rel="noopener ugc nofollow" target="_blank">荷莉</a>。</p><p id="cb54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae ne" href="https://github.com/apple/swift-evolution/blob/main/proposals/0293-extend-property-wrappers-to-function-and-closure-parameters.md" rel="noopener ugc nofollow" target="_blank"> SE-0293 </a>(将属性包装器扩展到函数和闭包参数)讨论了将属性包装器扩展到函数和闭包参数。这就是为什么我们能够首先在尾随闭包上使用<code class="fe lu lv lw lx b">Binding</code>。提案的<a class="ae ne" href="https://github.com/apple/swift-evolution/blob/main/proposals/0293-extend-property-wrappers-to-function-and-closure-parameters.md#closures" rel="noopener ugc nofollow" target="_blank">关闭部分</a>讨论了是什么使<code class="fe lu lv lw lx b">$</code>标志成为可能:</p><blockquote class="nt nu nv"><p id="116f" class="ky kz nw la b lb lc ju ld le lf jx lg nx li lj lk ny lm ln lo nz lq lr ls lt im bi translated">对于接受投影值的闭包，如果支持属性包装器和投影值具有相同的类型，如SwiftUI的属性包装器，则属性包装器属性不是必需的。如果<code class="fe lu lv lw lx b">Binding</code>实现了<code class="fe lu lv lw lx b">init(projectedValue:)</code>，它可以用作闭包参数上的属性包装器属性，而无需显式编写该属性:</p><p id="cb2c" class="ky kz nw la b lb lc ju ld le lf jx lg nx li lj lk ny lm ln lo nz lq lr ls lt im bi translated">让我们使用Binding:(Binding<int>)-&gt; Void = { $ value in</int></p><p id="40ba" class="ky kz nw la b lb lc ju ld le lf jx lg nx li lj lk ny lm ln lo nz lq lr ls lt im bi">...</p><p id="ba7f" class="ky kz nw la b lb lc ju ld le lf jx lg nx li lj lk ny lm ln lo nz lq lr ls lt im bi">}”</p></blockquote><p id="205f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">果不其然，如果我们看看<code class="fe lu lv lw lx b">Binding</code>的API差异，它就在那里:<code class="fe lu lv lw lx b">init(projectedValue: Binding&lt;Value&gt;)</code>是Xcode 12.5到Xcode 13.0b1 的一个<a class="ae ne" href="https://developer.apple.com/documentation/swiftui/binding/?changes=latest_minor" rel="noopener ugc nofollow" target="_blank">增加。</a></p><p id="ceca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在你知道了:由于在SE-0293中所做的工作，我们可以使用<code class="fe lu lv lw lx b">List</code>和<code class="fe lu lv lw lx b">ForEach</code>内部的绑定，并向<code class="fe lu lv lw lx b">List</code>(参见<a class="ae ne" href="https://developer.apple.com/documentation/swiftui/list/init(_:rowcontent:)-25c5f?changes=latest_minor" rel="noopener ugc nofollow" target="_blank">文档</a>)、<code class="fe lu lv lw lx b">ForEach</code>(参见<a class="ae ne" href="https://developer.apple.com/documentation/swiftui/foreach/init(_:content:)-96gx9?changes=latest_minor" rel="noopener ugc nofollow" target="_blank">文档</a>)和<code class="fe lu lv lw lx b">Binding</code>(参见<a class="ae ne" href="https://developer.apple.com/documentation/swiftui/binding/init(projectedvalue:)?changes=latest_minor" rel="noopener ugc nofollow" target="_blank">文档</a>)添加各自的初始化器。</p><p id="dd1e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如<a class="ae ne" href="https://twitter.com/hollyborla/status/1402386082633633794" rel="noopener ugc nofollow" target="_blank"> Holly提到的</a>，闭包参数的新<code class="fe lu lv lw lx b">$</code>语法是该语言的一个编译时方面，只要你在用Swift 5.5编译，它就能工作。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="3ff7" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">反向展开</h1><p id="dfde" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">这就给我们带来了以下问题:为什么这个可以<a class="ae ne" href="https://twitter.com/luka_bernardi/status/1402363202923491332" rel="noopener ugc nofollow" target="_blank">回部署</a>到更早的iOS版本？闭包参数的新<code class="fe lu lv lw lx b">$</code>语法只是拼图的一部分，但是我们也有新的API(额外的初始化器),需要在以前版本的操作系统上提供。</p><p id="ed0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们如何使新的API对早期版本的运行时可用？</p><p id="96b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Swift repo上有一整篇文档讨论了<a class="ae ne" href="https://github.com/apple/swift/blob/main/docs/LibraryEvolution.rst#always-emit-into-client" rel="noopener ugc nofollow" target="_blank">库进化</a>的主题，即“在不破坏源代码或二进制兼容性的情况下更改库的能力”</p><p id="bd5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该文档对<code class="fe lu lv lw lx b">@_alwaysEmitIntoClient</code>有些含糊，但似乎用该属性注释函数、计算属性或下标将导致代码被发送到客户端二进制文件(即我们的应用程序)，从而使得在Swift运行时的先前ABI稳定版本上使用新的API成为可能。似乎这就是团队为这个特定功能所做的。</p><p id="4a2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想更深入地了解这个话题，<a class="ae ne" href="https://swift.org/blog/library-evolution/" rel="noopener ugc nofollow" target="_blank"> Library Evolution博客文章</a>提供了更多关于底层概念的细节，以及什么时候启用Library Evolution支持是个好主意(什么时候不是)。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="1ead" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">关闭</h1><p id="8ff0" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">我总是觉得很有趣的是，我们经常认为理所当然的语言和框架的看似很小的特性中融入了多少工程学。感谢所有为此付出努力的人！</p><p id="5c2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如<a class="ae ne" href="https://twitter.com/ricketson_" rel="noopener ugc nofollow" target="_blank">马特</a>在<a class="ae ne" href="https://developer.apple.com/videos/play/wwdc2021/10018/" rel="noopener ugc nofollow" target="_blank">swift ui</a>的新功能中提到的(在7:37的标记处)，这个特性将帮助我们构建更无错误(和高性能！)应用程序，所以现在是检查您的代码并更新您的所有列表以使用新功能的好时机。</p><p id="34e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p><p id="2144" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nw">原发布于</em><a class="ae ne" href="https://peterfriese.dev/swiftui-list-item-bindings-behind-the-scenes/" rel="noopener ugc nofollow" target="_blank"><em class="nw">https://peterfriese . dev</em></a><em class="nw">。</em></p></div></div>    
</body>
</html>