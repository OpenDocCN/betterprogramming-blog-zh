<html>
<head>
<title>Parsing and Generating YAML in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中YAML的解析与生成</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/parsing-and-creating-yaml-in-go-crash-course-2ec10b7db850?source=collection_archive---------0-----------------------#2022-06-05">https://betterprogramming.pub/parsing-and-creating-yaml-in-go-crash-course-2ec10b7db850?source=collection_archive---------0-----------------------#2022-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6899" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">速成班</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5e7f0a4254afebcb2ddd6a7cf5ea2349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_JOLOwXOBd5SB-fr2iCo_Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">让我们去惹YAML吧！</p></figure><p id="78e1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文以一个非常基础的程序为例，提供了一个在Go中解析和创建YAML的速成课程。</p><p id="b23f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我不知道你怎么想，但是当我听到“封送”和“解封送”这样的术语时，我想到的最后一件事就是将YAML转换成一个结构。这就是我们生活的世界；命名很难，只要有机会，我们总会让事情听起来比实际情况更不寻常。</p><p id="414c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好消息是，需要一组(相对)小的工具来帮助您解析现有的YAML文件(解组)或将现有的Go结构(或任何类型)转换为YAML(封送)。另一个好消息是，当向<em class="lr">解释让它变得简单</em>时，它很简单。</p><h1 id="1179" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">从Go struct到YAML </strong></h1><p id="bfc2" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">本文假设您的机器上已经安装并设置了Go。如果你在这方面需要帮助，去<a class="ae mp" href="https://go.dev/doc/install" rel="noopener ugc nofollow" target="_blank">看看这个</a>指南，然后回来。</p><p id="0a89" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们创建一个基本项目:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1210" class="mv lt iq mr b gy mw mx l my mz">mkdir converttoyaml<br/>cd converttoyaml<br/>go mod init converttoyaml/v1</span></pre><p id="ab59" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，让我们创建一个名为<em class="lr"> main.go </em>的新文件，并添加以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="fbfe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一段简单的代码；创建一个结构，添加一些数据，并打印出来。一切都好，对吧？</p><p id="d44b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，让我们假设这是一条我们希望以YAML格式保存的关键信息。为此，我们将使用<a class="ae mp" href="https://github.com/go-yaml/yaml" rel="noopener ugc nofollow" target="_blank"> go-yaml </a>包。</p><p id="7d6b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们需要安装它:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="cde5" class="mv lt iq mr b gy mw mx l my mz">go get gopkg.in/yaml.v3</span></pre><p id="1701" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们需要更新我们的代码来导入包，然后让它工作。我们将从以下位置更新我们的导入行:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="b045" class="mv lt iq mr b gy mw mx l my mz">import “fmt”</span></pre><p id="085a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">To(如果有错误，我们将使用log.fatal):</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="ec95" class="mv lt iq mr b gy mw mx l my mz">import (<br/>  "fmt"<br/>  "log"<br/>  "gopkg.in/yaml.v3"<br/>)</span></pre><p id="f2f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将更新我们的主要功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3625" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里我们对<em class="lr"> go-yaml </em>包的要求是获取我们的结构并将其转换成yaml输出。注意这里的<em class="lr"> out </em>返回为<em class="lr">[]字节</em>；在<em class="lr"> fmt </em>可以打印结果之前，我们需要将它转换成一个字符串。</p><p id="25f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，更新您的文件，重新运行该代码，您将看到如下输出:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="dc75" class="mv lt iq mr b gy mw mx l my mz">topspeed: 60<br/>name: Mirthmobile<br/>cool: true<br/>passengers:<br/>- garth<br/>- wayne</span></pre><p id="10e1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不错的YAML！</p><h1 id="b38b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">从YAML到Go struct </strong></h1><p id="e042" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">既然微型移动电话的秘密已经在YAML被记录下来，我们需要将这些数据作为一个结构加载回Go。首先，让我们将程序的输出写入一个文件:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1042" class="mv lt iq mr b gy mw mx l my mz">go run ./main.go &gt; themirth.yaml</span></pre><p id="908c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了将YAML文件的内容转换回我们的<em class="lr"> Car </em> struct，我们需要用一些针对<em class="lr"> go-yaml </em>包的指令来注释我们的struct定义。为此，我们需要为每个结构字段指定输入键名:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2ad3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些标记使我们能够定义YAML中的键名和结构中相应的字段名的映射。当YAML文件被“解组”(即，被转换成结构)时，这些标签被用来适当地填充该结构。解组文件的代码如下所示(再次更新我们的主函数):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="eb59" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">继续，复制并粘贴它！然后重新运行程序，您将得到如下输出:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="9644" class="mv lt iq mr b gy mw mx l my mz">{TopSpeed:60 Name:Mirthmobile Cool:true Passengers:[garth wayne]}</span></pre><p id="b18d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不错的结构！</p><h1 id="5af0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">处理YAML Go结构中的多种数据格式</strong></h1><p id="4c6a" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在理想的情况下，只有一种特定格式的输入数据，从struct字段到YAML键的静态映射也能很好地工作。但是因为这是真实的世界，这种事情不会总是发生。幸运的是，<code class="fe nc nd ne mr b">go-yaml</code>包允许我们“自带”<code class="fe nc nd ne mr b">UnmarshalYAML</code>功能。</p><p id="c42a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我将使用的场景是<code class="fe nc nd ne mr b">passengers</code>字段。有时加思和韦恩坐在一起，但当两人在为是否允许“吮吸切割”的创作者回到节目中而争吵时，他们可能不想花任何时间在一起。在这种情况下，Garth不想提供一个名称数组；他想用一根绳子。</p><p id="9c2e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">也就是这个</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="ad5e" class="mv lt iq mr b gy mw mx l my mz">topspeed: 60<br/>name: Mirthmobile<br/>cool: true<br/><strong class="mr ir">passengers: garth</strong></span></pre><p id="be12" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不是这个</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="d566" class="mv lt iq mr b gy mw mx l my mz">topspeed: 60<br/>name: Mirthmobile<br/>cool: true<br/><strong class="mr ir">passengers:<br/>- garth</strong></span></pre><p id="f65e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">继续用代码原样尝试；你会得到很好的回应:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="debf" class="mv lt iq mr b gy mw mx l my mz">unmarshal errors:<br/>line 4: cannot unmarshal !!str `garth` into []string</span></pre><p id="d00d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">是啊。有道理；数据类型现在已经完全改变了。然而，我们希望支持这一点，一个自定义的<code class="fe nc nd ne mr b">UnmarshalYAML</code>函数是一个答案。</p><p id="6765" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将在导入中添加一个新项目(错误):</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="d64e" class="mv lt iq mr b gy mw mx l my mz">import (<br/> "errors"<br/> "fmt"<br/> "log"<br/> "os"</span><span id="92a8" class="mv lt iq mr b gy nf mx l my mz"> "gopkg.in/yaml.v3"<br/>)</span></pre><p id="964c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们将添加自定义的<code class="fe nc nd ne mr b">UnmarshalYAML</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="35ee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好吧，这是怎么回事。首先，当添加一个<em class="lr">unmarshal AML</em>方法到我们的结构中时，我们告诉<code class="fe nc nd ne mr b">go-yaml</code>包跳过它的内部魔法，调用我们的函数来解析数据——所以我们必须比以前更加努力。</p><p id="7b6f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">函数中第一个有趣的地方是<em class="lr">解组</em>函数本身。这个函数将我们的YAML转换成一个<code class="fe nc nd ne mr b">map[string]interface{}</code>。然后，我们可以解包这个新值的内容(存储在<em class="lr"> carDetails </em>变量中)。</p><p id="3ddf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于我们要设置的每个字段，我们需要测试该字段是否实际存在，如果存在，我们就要获取值。现在，每个值都属于类型<em class="lr"> interface{} </em>，所以我们必须将它转换为结构中所需的数据类型。</p><p id="2428" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">一个快速的警告，你绝对需要在Go中做任何事情的时候做错误处理。任何转换为正确数据类型的失败都将导致死机。为了简洁起见，我在这里省略了它。</em></p><p id="a502" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们检查了我们的特殊乘客的领域，并验证我们有数据；下一步是使用一个开关来确定我们被提供了什么类型的数据。我们在这里的目标是获取一个字符串列表或单个字符串，并填充结构上的<code class="fe nc nd ne mr b">Passengers</code>字段——这是一个字符串片段。</p><p id="a089" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在示例代码中，如果提供的数据是任何类型的切片，我们迭代该数据，将其转换为字符串，并将其指定为乘客字段的成员。如果我们只被传递了一个字符串，我们将用我们的单个值给乘客字段分配一个新的字符串片段。在这样做的时候，不管Garth只传入单个字符串值还是一个字符串列表(你知道，当Wayne在的时候)，我们的代码都可以解析它并给出正确的值。</p><p id="2692" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">继续并重新运行该程序；事情看起来好多了，嗯？</p><h1 id="bff9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">处理YAML Go struct中的多种数据格式(更简单的方法)</strong></h1><p id="a196" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">所以，在最后一个例子中，你对自己说，“这太多了”——这是你的权利。幸运的是，在另一个软件包的帮助下，我们可以更容易地做到这一点；<a class="ae mp" href="https://github.com/mitchellh/mapstructure" rel="noopener ugc nofollow" target="_blank">地图结构</a>。除了给我们带来像Terraform这样的美好事物之外，<a class="ae mp" href="https://github.com/mitchellh" rel="noopener ugc nofollow" target="_blank">米切尔</a>也给我们带来了<code class="fe nc nd ne mr b">mapstructure</code>。mapstructure包是一个更加灵活的解析器，可以处理我们以前处理的强制，而不需要太多额外的代码。</p><p id="7765" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们来安装<code class="fe nc nd ne mr b">mapstructure</code>:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="6721" class="mv lt iq mr b gy mw mx l my mz">go get github.com/mitchellh/mapstructure</span></pre><p id="3007" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，在main.go文件中，我们可以删除整个<code class="fe nc nd ne mr b">UnmarshalYAML</code>函数；我们不再需要它了。我们确实需要稍微更新一下我们的汽车定义(将标签从<code class="fe nc nd ne mr b">yaml</code>改为<code class="fe nc nd ne mr b">mapstructure</code>):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e85c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们还有最后一个版本的<code class="fe nc nd ne mr b">main</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="26b1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们回顾一下这里发生的事情:</p><ul class=""><li id="b737" class="ng nh iq kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated">我们不是直接将输入数据解组到<code class="fe nc nd ne mr b">Car</code>，而是解组到<code class="fe nc nd ne mr b">interface{} (variable raw)</code>。这意味着我们还没有尝试转换所有的数据类型，这样做的结果只是“幕后”变量<code class="fe nc nd ne mr b">raw</code>是一个<code class="fe nc nd ne mr b">map[string]interface{}</code></li><li id="1ca0" class="ng nh iq kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">我们正在创建一个新的<code class="fe nc nd ne mr b">mapstructure</code>解码器，将它的配置设置为将结果发送到我们的<em class="lr"> c </em>变量(类型为<code class="fe nc nd ne mr b">Car</code>)，并且我们还通知<code class="fe nc nd ne mr b">mapstructure</code>使用“<code class="fe nc nd ne mr b">WeaklyTypedInput</code>”。这是关键；启用此选项将自动完成从单个字符串到字符串片段的转换，这是我们在自定义解组函数中必须完成的！</li><li id="719b" class="ng nh iq kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">我们在新的解码器上调用<code class="fe nc nd ne mr b">Decode</code>方法，它将我们的原始输入转换成具有正确数据类型的<code class="fe nc nd ne mr b">Car</code>结构！</li></ul><p id="06e5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">继续重新运行您的代码！</p><p id="2bbf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个<code class="fe nc nd ne mr b">mapstructure</code>包能够完成比这里所介绍的更多的工作，但是即使在这个简单的例子中，它也可以使处理输入YAML(或者任何格式)变得更加简单！</p><h1 id="da3c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">结论</strong></h1><p id="8593" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们已经讨论了很多内容，希望您对如何在YAML和围棋之间来回切换有一个基本的了解。值得回顾一下<code class="fe nc nd ne mr b">go-yaml</code>和<code class="fe nc nd ne mr b">mapstructure</code>文档；这两个包都有不同的方法或接口，可以使特定的用例变得更加容易，本文中的代码将是“困难的方式”</p><p id="6105" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">希望您发现这很有用！</p></div></div>    
</body>
</html>