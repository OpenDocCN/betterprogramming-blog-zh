<html>
<head>
<title>Should You Be Using Python’s Walrus Operator? (Yes. And Here’s Why)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该使用Python的Walrus操作符吗？(是的。原因如下)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/should-you-be-using-pythons-walrus-operator-yes-and-here-s-why-36297be16907?source=collection_archive---------1-----------------------#2022-08-15">https://betterprogramming.pub/should-you-be-using-pythons-walrus-operator-yes-and-here-s-why-36297be16907?source=collection_archive---------1-----------------------#2022-08-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e464" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python有争议的赋值表达式——被称为walrus运算符——可以改进您的代码，现在是您开始使用它的时候了！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aca76b3f9b100ae7ead6e240be3a0988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ZYi8cWvhqY3SocFh4cV5A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔纳森·库珀在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4c71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">赋值操作符——或者我们都知道的walrus操作符——是Python中的一个特性(从3.8开始),但它仍然有一些争议，许多人对它有毫无根据的厌恶。</p><p id="f7d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将试图说服您，walrus操作符确实是语言的一个很好的补充，如果您正确使用它，那么它可以帮助您使您的代码更加简洁和可读。</p><h1 id="a830" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基础/必需品</h1><p id="fde9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果您还不熟悉<code class="fe ms mt mu mv b">:=</code>，让我们首先回顾一些基本的用例，这些用例可能会说服您尝试一下这个Python特性。</p><p id="84b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想展示的第一个例子是如何使用walrus操作符来减少函数调用的次数。让我们想象一个名为<code class="fe ms mt mu mv b">func()</code>的函数，它执行一些非常昂贵的计算。计算结果需要很长时间，所以我们不想多次调用它。你可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4331" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面声明的第一个列表中，<code class="fe ms mt mu mv b">func(x)</code>被调用了三次，每次都返回相同的结果，这浪费了时间和计算资源。当使用walrus操作符重写时，<code class="fe ms mt mu mv b">func()</code>只被调用一次，将其结果赋给<code class="fe ms mt mu mv b">y</code>，并在剩余的两个列表值中重用它。</p><p id="3303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会说，<em class="my">“我在列表声明前加</em> <code class="fe ms mt mu mv b"><em class="my">y = func(x)</em></code> <em class="my">就可以了，不需要海象！”</em>是的，你可以，但是那是一个额外的、不必要的代码行，乍一看——不知道<code class="fe ms mt mu mv b">func(x)</code>超级慢——可能不清楚为什么额外的<code class="fe ms mt mu mv b">y</code>变量需要存在。</p><p id="bfe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不相信上面的话，我还有一个。用同样昂贵的<code class="fe ms mt mu mv b">func()</code>考虑下面的列表理解:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="05ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一行中，<code class="fe ms mt mu mv b">func(x)</code>在每个循环中被调用两次。相反——使用walrus操作符——我们在<code class="fe ms mt mu mv b">if</code>语句中计算一次，然后重用它。代码长度是一样的，两行的可读性都是一样的，但是第二行的效率是第一行的两倍。您可以避免使用walrus操作符，同时通过将它改为一个完整的<code class="fe ms mt mu mv b">for</code>循环来保持性能，但这需要五行代码。</p><p id="b2cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">walrus操作符最常见的用例之一是减少嵌套条件，比如在使用正则表达式匹配时。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8c7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用walrus，我们将匹配代码从七行减少到四行，同时通过移除嵌套的<code class="fe ms mt mu mv b">if</code>使其更具可读性。</p><p id="cadc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">名单上的下一个是所谓的“一圈半”习语。它看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="13e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常的解决方案是使用一个虚拟的无限<code class="fe ms mt mu mv b">while</code>循环，将控制流委托给<code class="fe ms mt mu mv b">break</code>语句。相反，我们可以使用walrus操作符来重新分配<code class="fe ms mt mu mv b">command</code>的值，然后在同一行的<code class="fe ms mt mu mv b">while</code>循环的条件中使用它，这将使代码更加简洁。</p><p id="b4df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似的简化也可以应用于其他<code class="fe ms mt mu mv b">while</code>循环，例如，当逐行读取文件或从套接字接收数据时。</p><h1 id="04ae" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">就地积累数据</h1><p id="cc4e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">继续讨论一些更高级的walrus操作符的用例。这使得就地积累数据成为可能。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b582" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前两行展示了如何利用walrus操作符来计算运行总数。对于这样一个简单的例子，来自<code class="fe ms mt mu mv b">itertools</code>的函数，比如<code class="fe ms mt mu mv b">accumulate</code>是一个更好的选择，如下面两行所示。然而，对于更复杂的场景，使用<code class="fe ms mt mu mv b">itertools</code>会很快变得不可读。而且，在我看来，有<code class="fe ms mt mu mv b">:=</code>的版本比有<code class="fe ms mt mu mv b">lambda</code>的版本好看多了。</p><p id="bc92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你仍然不相信，检查一下文档中的<code class="fe ms mt mu mv b">accumulate</code> <a class="ae ky" href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="noopener ugc nofollow" target="_blank">示例(例如，累计利息或逻辑图示例)，这些示例不可读。尝试重写它们以使用赋值表达式。它们看起来会更好。</a></p><h1 id="9daf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">命名f字符串中的值</h1><p id="219a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个例子展示了<code class="fe ms mt mu mv b">:=</code>的可能性和局限性，而不是最佳实践。</p><p id="9a45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你愿意，你可以在f弦中使用海象操作符。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4240" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的第一个打印语句中，我们使用<code class="fe ms mt mu mv b">:=</code>来定义变量<code class="fe ms mt mu mv b">today</code>，然后在同一行中重用该变量，这样我们就不用重复调用<code class="fe ms mt mu mv b">datetime.today()</code>。</p><p id="6c2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，在第二个例子中，我们声明了<code class="fe ms mt mu mv b">theta</code>变量，然后重用它来计算<code class="fe ms mt mu mv b">sin(theta)</code>和<code class="fe ms mt mu mv b">cos(theta)</code>。在这种情况下，我们还将它与看起来像“reverse walrus”的操作符结合使用。这只是<code class="fe ms mt mu mv b">=</code>，它强制表达式沿着它的值打印，加上用于格式化表达式的<code class="fe ms mt mu mv b">:</code>。</p><p id="69d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还要注意，walrus表达式必须用括号括起来，这样f字符串才能正确解释它。</p><h1 id="9ebb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">任何和所有</h1><p id="1d89" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您可以使用Python的<code class="fe ms mt mu mv b">any()</code>和<code class="fe ms mt mu mv b">all()</code>函数来验证某个iterable中的任意或所有值是否满足某些条件。但是，如果您还想捕获导致<code class="fe ms mt mu mv b">any()</code>返回<code class="fe ms mt mu mv b">True</code>的值(所谓的“见证”)或导致<code class="fe ms mt mu mv b">all()</code>失败的值(所谓的“反例”)，该怎么办呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5a14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">any()</code>和<code class="fe ms mt mu mv b">all()</code>都使用短路来计算表达式。这意味着他们一找到第一个“见证”或“反例”，就停止评估。所以，用这一招，walrus操作符创建的变量总会给我们第一个“见证”/“反例”。</p><h1 id="0583" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">陷阱和限制</h1><p id="5d5c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">虽然我在前面几节中试图鼓励您使用walrus操作符，但我认为提醒您它的一些缺点和局限性也很重要。以下是您在使用walrus运算符时可能遇到的问题:</p><p id="0713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前面的例子中，您看到了短路对于捕获<code class="fe ms mt mu mv b">any()</code> / <code class="fe ms mt mu mv b">all()</code>中的值可能是有用的，但是在某些情况下，它可能会产生意想不到的结果。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9fa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们创建了一个条件，其中两个赋值由<code class="fe ms mt mu mv b">and</code>连接。它们根据是否满足第一个、第二个或两个条件来检查一个数是否能被2、3或6整除。乍一看，这似乎是一个不错的技巧，但是由于短路，如果表达式<code class="fe ms mt mu mv b">(two := i % 2 == 0)</code>失败，第二部分将被跳过，因此<code class="fe ms mt mu mv b">three</code>将是未定义的或者将具有来自前一个循环的旧值。</p><p id="ce88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，短路也可能是有益的/有意的。我们可以将它与正则表达式一起使用，在一个字符串中搜索多个模式，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经在第一部分中看到了这个片段的一个版本，其中我们将<code class="fe ms mt mu mv b">if</code> / <code class="fe ms mt mu mv b">elif</code>与walrus operator结合使用。在这里，我们通过将条件简化为单个<code class="fe ms mt mu mv b">if</code>来进一步简化它。</p><p id="c36c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您熟悉walrus操作符，您可能会注意到它会导致变量作用域在理解中表现不同。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用正常的list/dict/set理解，循环变量不会泄漏到周围的范围内，因此，任何同名的现有变量都不会被修改。</p><p id="57fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，使用walrus操作符，在comprehension返回之后，来自comprehension的变量(上面代码中的<code class="fe ms mt mu mv b">total</code>)仍然是可访问的，从comprehension内部取值。</p><p id="2239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您对在代码中使用walrus变得更加熟悉时，您可以尝试在更多的情况下使用它。有一个地方你绝对不应该使用它，那就是带有<code class="fe ms mt mu mv b">with</code>语句的地方。下面是这个陷阱的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f3d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用普通语法<code class="fe ms mt mu mv b">with ContextManager() as context: ...</code>时，<code class="fe ms mt mu mv b">context</code>被绑定到<code class="fe ms mt mu mv b">context.__enter__()</code>的返回值，而如果使用带有<code class="fe ms mt mu mv b">:=</code>的版本，那么它被绑定到<code class="fe ms mt mu mv b">ContextManager()</code>本身的结果。这通常无关紧要，因为<code class="fe ms mt mu mv b">context.__enter__()</code>通常会返回<code class="fe ms mt mu mv b">self</code>，但如果不返回，就会产生难以调试的问题。</p><p id="6881" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一个更实际的例子，看看当您将walrus操作符与下面的<code class="fe ms mt mu mv b">closing</code>上下文管理器一起使用时会发生什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d7d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能遇到的另一个问题是<code class="fe ms mt mu mv b">:=</code>的相对优先级，它低于逻辑运算符的优先级。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="cea5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们看到我们需要用圆括号将赋值括起来，以确保将<code class="fe ms mt mu mv b">re.match(...)</code>的结果赋值给变量。如果我们不这样做，那么将首先计算<code class="fe ms mt mu mv b">and</code>表达式，然后分配一个布尔结果。</p><p id="4c0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这真的不是一个陷阱，而是一个轻微的限制。您目前不能对walrus运算符使用内联类型提示。因此，如果你想指定变量的类型，那么你需要把它分成两行，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="8211" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结束语</h1><p id="5350" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">像其他语法特性一样，walrus操作符可能会被滥用，降低清晰度和可读性。你不需要尽可能把它塞进你的代码里。把它当作一种工具——意识到它的优点和缺点，并在适当的时候使用它。</p><p id="3e69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想看更多关于walrus操作符的实用的、好的用法，看看它是如何被引入到CPython的标准库中的——所有这些变化都可以在<a class="ae ky" href="https://github.com/python/cpython/pull/8122/files" rel="noopener ugc nofollow" target="_blank"> this PR </a>中找到。</p><p id="7f50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，我还推荐通读<a class="ae ky" href="https://peps.python.org/pep-0572/" rel="noopener ugc nofollow" target="_blank"> PEP 572 </a>，其中有更多的例子和介绍操作者的基本原理。</p><div class="mz na gp gr nb nc"><a href="https://towardsdatascience.com/python-f-strings-are-more-powerful-than-you-might-think-8271d3efbd7d" rel="noopener follow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">Python f-strings比您想象的更强大</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">了解Python的f字符串的未知特性——格式化的字符串文字——以及您的文本格式化…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">towardsdatascience.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq ks nc"/></div></div></a></div><div class="mz na gp gr nb nc"><a rel="noopener  ugc nofollow" target="_blank" href="/automate-all-the-boring-kubernetes-operations-with-python-7a31bbf7a387"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">用Python自动化所有枯燥的Kubernetes操作</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">了解如何使用Python的Kubernetes客户端库来自动化所有枯燥的Kubernetes任务和操作</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">better编程. pub</p></div></div><div class="nl l"><div class="nr l nn no np nl nq ks nc"/></div></div></a></div><pre class="kj kk kl km gt ns mv nt nu aw nv bi"><span id="e167" class="nw lw it mv b gy nx ny l nz oa"><strong class="mv iu">Want to Connect?</strong></span><span id="3a24" class="nw lw it mv b gy ob ny l nz oa">This article was originally posted at <a class="ae ky" href="http://martinheinz.dev/blog/79" rel="noopener ugc nofollow" target="_blank">martinheinz.dev</a></span></pre></div></div>    
</body>
</html>