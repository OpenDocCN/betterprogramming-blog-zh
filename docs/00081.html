<html>
<head>
<title>Building a Spring Boot REST API — Part 3: Integrating MySQL Database and JPA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建Spring Boot REST API —第3部分:集成MySQL数据库和JPA</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-spring-boot-rest-api-part-iii-integrating-mysql-database-and-jpa-81391404046a?source=collection_archive---------0-----------------------#2017-12-17">https://betterprogramming.pub/building-a-spring-boot-rest-api-part-iii-integrating-mysql-database-and-jpa-81391404046a?source=collection_archive---------0-----------------------#2017-12-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fafa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">最后一部分:MySQL数据库集成和查询数据库的Java持久性API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f77e5931a078e8486607b5434ca04a7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fo570K-1Kf74fvhHQhwJ8g.png"/></div></div></figure><p id="f4ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<a class="ae lq" href="https://medium.com/@salisuwy/building-a-spring-boot-rest-api-part-ii-7ff1e4384b0b" rel="noopener">之前的教程</a>中，我们已经看到了如何使用硬编码的模拟数据发送请求并从控制器获得响应。</p><p id="f22e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本节中，将集成MySQL数据库和用于查询数据库的<a class="ae lq" href="https://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html" rel="noopener ugc nofollow" target="_blank"> Java持久性API </a> (JPA)。把JPA想象成一个对象关系映射(ORM)库，类似于<a class="ae lq" href="https://laravel.com/docs/5.8/eloquent" rel="noopener ugc nofollow" target="_blank">雄辩</a>、<a class="ae lq" href="https://www.doctrine-project.org/" rel="noopener ugc nofollow" target="_blank">教条</a>、<a class="ae lq" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/" rel="noopener ugc nofollow" target="_blank"> E </a>实体框架等。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="35fc" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">设置MySQL数据库</h1><p id="2ab2" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">首先，我们需要安装MySQL并创建一个表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/a68fa9ca61d6790c5a2044882ac83a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*adBetjil8fozP49ouWVbBQ.png"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">表结构</p></figure><p id="8bfa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">打开MySQL终端并运行以下命令来创建数据库和blogs表:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4b75" class="nf lz it nb b gy ng nh l ni nj"><strong class="nb iu">CREATE </strong>DATABASE restapi;</span><span id="8985" class="nf lz it nb b gy nk nh l ni nj"><strong class="nb iu">USE</strong> restapi;</span><span id="6e6e" class="nf lz it nb b gy nk nh l ni nj"><strong class="nb iu">CREATE TABLE </strong>blog (<br/>  id <strong class="nb iu">INT</strong>(6) UNSIGNED AUTO_INCREMENT <strong class="nb iu">PRIMARY KEY</strong>,<br/>  title <strong class="nb iu">VARCHAR</strong>(500) <strong class="nb iu">NOT NULL</strong>,<br/>  content <strong class="nb iu">VARCHAR</strong>(5000) <strong class="nb iu">NOT NULL<br/></strong>);</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="6cb4" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">应用程序配置</h1><p id="69d2" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">将<a class="ae lq" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>应用程序连接到MySQL数据库:</p><ul class=""><li id="18e0" class="nl nm it kw b kx ky la lb ld nn lh no ll np lp nq nr ns nt bi translated">将所需的依赖项(如MySQL库)添加到<code class="fe nu nv nw nb b">pom.xml</code>文件中。这些依赖项是连接到数据库所需的Java库。</li><li id="cd0f" class="nl nm it kw b kx nx la ny ld nz lh oa ll ob lp nq nr ns nt bi translated">向应用程序提供数据库连接属性。这些属性包括数据库连接字符串、端口、用户名、密码等。</li><li id="b2b2" class="nl nm it kw b kx nx la ny ld nz lh oa ll ob lp nq nr ns nt bi translated">创建一个与数据库对话的类。这个类通常被称为“存储库类”。</li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="2835" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">添加MySQL依赖项</h1><p id="9b69" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">要将Spring Boot应用程序连接到MySQL数据库，需要使用<code class="fe nu nv nw nb b">mysql-connector-java</code>库。</p><p id="6d9f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类似地，Spring JPA需要<code class="fe nu nv nw nb b">spring-boot-starter-data-jpa</code>库。稍后我们将更多地讨论JPA。</p><p id="a973" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将下面的代码复制并粘贴到<code class="fe nu nv nw nb b">pom.xml</code>文件中的dependencies标记内。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9ef8" class="nf lz it nb b gy ng nh l ni nj">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;mysql&lt;/groupId&gt;<br/>    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="95b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nu nv nw nb b">pom.xml</code>文件现在应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="9d1f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">设置连接属性</h1><p id="9590" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">要将Spring Boot应用程序连接到数据库，我们需要向应用程序提供数据库URL、用户名和密码。</p><p id="55b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，只需在<code class="fe nu nv nw nb b">resources</code>文件夹中创建一个文件<code class="fe nu nv nw nb b">application.properties</code>，并将下面的代码粘贴到其中:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="bd9d" class="nf lz it nb b gy ng nh l ni nj">spring.datasource.url=jdbc:mysql://localhost:3306/restapi<br/>spring.datasource.username=root<br/>spring.datasource.password=</span></pre><ul class=""><li id="194f" class="nl nm it kw b kx ky la lb ld nn lh no ll np lp nq nr ns nt bi translated"><code class="fe nu nv nw nb b">spring.datasource.url</code>:包含MySQL连接字符串。</li><li id="0067" class="nl nm it kw b kx nx la ny ld nz lh oa ll ob lp nq nr ns nt bi translated"><code class="fe nu nv nw nb b">spring.datasource.username</code>:是MySQL用户名。</li><li id="cf82" class="nl nm it kw b kx nx la ny ld nz lh oa ll ob lp nq nr ns nt bi translated"><code class="fe nu nv nw nb b">spring.datasource.password</code>:是MySQL密码。</li></ul><p id="0f0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">确保更改以上属性以反映您的MySQL设置。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="2d09" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">与数据库对话:创建存储库类</h1><p id="b2b3" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">既然我们已经准备好了数据库，安装了依赖项，并提供了连接属性，接下来要做的就是创建一个与数据库对话的类。这个类通常被称为<em class="oe">库</em>。</p><ul class=""><li id="dd52" class="nl nm it kw b kx ky la lb ld nn lh no ll np lp nq nr ns nt bi translated">首先，我们创建一个扩展<code class="fe nu nv nw nb b">JpaRepository</code>的接口。<code class="fe nu nv nw nb b">JpaRepository</code>为我们提供了一些现成的功能，比如获取所有记录、单个记录、保存、更新、删除等。</li><li id="fceb" class="nl nm it kw b kx nx la ny ld nz lh oa ll ob lp nq nr ns nt bi translated">向接口添加注释<code class="fe nu nv nw nb b">@Repository</code>,告诉Spring这是一个存储库。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/bf68702b86a3205f46901ba904fb2362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I8wMIvOpD2C3y-RVhN3GvA.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">创建存储库的公式</p></figure><p id="9d4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上图显示了存储库的一般结构。所以，来看看我们的<code class="fe nu nv nw nb b">BlogRepository</code>是什么样子的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="e716" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是什么？</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="fe5b" class="nf lz it nb b gy ng nh l ni nj">List&lt;Blog&gt; findByTitleContainingOrContentContaining(String text, String textAgain);</span></pre><p id="ac87" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我知道这一开始可能会让人困惑，但我们以后会谈到它。现在，忘记<code class="fe nu nv nw nb b">findByTitleContainingOrContentContaining</code>方法</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c72a" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">将博客转换为实体(@Entity)</h1><p id="4592" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在上一个教程中，我们用表中的字段创建了一个博客类<code class="fe nu nv nw nb b">Blog.java</code>。如您所知，<code class="fe nu nv nw nb b">Blog.java</code>的每个实例都应该是我们表中的一个条目(即一行)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="10bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了告诉spring<code class="fe nu nv nw nb b">Blog.java</code>是一个条目，我们需要向该类添加一个<code class="fe nu nv nw nb b">@Entity </code>注释。</p><p id="e890" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从上面的表结构来看，<code class="fe nu nv nw nb b">id</code>列是主键和自动生成的字段。为了告诉Spring<code class="fe nu nv nw nb b">id</code>是主键，我们将注释<code class="fe nu nv nw nb b">@Id</code>放入该字段。</p><p id="f36b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nu nv nw nb b">@GeneratedValue(strategy = GenerationType.AUTO)</code> <strong class="kw iu"> </strong>告诉Spring该字段是自动生成的，不会由用户提供，而是由数据库生成。</p><p id="7afa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还在类中添加了另一个构造函数，只有“标题”和“内容”。当我们向控制器提供表单数据时，将使用这个构造函数。</p><p id="e358" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于id是自动生成的，我们不需要提供它。因此，从构造函数中排除。</p><p id="6310" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以添加到类中的另一个注释是:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="790d" class="nf lz it nb b gy ng nh l ni nj">@Table(name = “Blog”)</span></pre><p id="d5df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您的表名不同于类名，这是必需的。</p><p id="45cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果字段的名称不同于表列的名称，我们还可以向字段添加列注释。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c093" class="nf lz it nb b gy ng nh l ni nj">@Column(name="title")<br/>private String title;</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4197" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">自动布线，单一选择</h1><p id="b89a" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在之前的教程中，我们创建了<code class="fe nu nv nw nb b">BlogMockedClass.java</code>并使其成为单例。如果你不明白什么是独生子女，可以查一下我的<a class="ae lq" href="https://medium.com/@salisuwy/building-a-spring-boot-rest-api-part-ii-7ff1e4384b0b" rel="noopener">以前的tutoria </a> l。</p><p id="6d85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Spring提供的一个解决方案是<code class="fe nu nv nw nb b">@Autowired</code>注释。如果我们用<code class="fe nu nv nw nb b">@Autowired</code>注释一个类，Spring会自动解析实例，并将其注入声明它的类中。因此，我们不需要自己获得singleton实例。</p><p id="7df7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，我们需要在<code class="fe nu nv nw nb b">BlogController</code>类中有一个<code class="fe nu nv nw nb b">BlogRepository</code>的实例。因此，我们需要做的就是:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="89f5" class="nf lz it nb b gy ng nh l ni nj">@Autowired<br/>BlogRespository blogRespository;</span></pre><p id="5c26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过这样做，我们可以在控制器中的任何地方使用<code class="fe nu nv nw nb b">blogRepository</code>，而不必实例化它。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="7485" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">控制器</h1><p id="4585" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">现在来看看我们的控制器是什么样子的。我们将从之前的教程中删除<code class="fe nu nv nw nb b">BlogMockedData</code>,并使用我们在上面创建的存储库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="f023" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能注意到的第一个变化是我们现在使用了<code class="fe nu nv nw nb b">BlogRepository</code>和<code class="fe nu nv nw nb b">@Autowired</code>注释。</p><p id="ae3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">方法的定义保持不变，但是实现发生了变化。</p><p id="593e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能会注意到<code class="fe nu nv nw nb b">blogRepository</code>有方法，比如<code class="fe nu nv nw nb b">findAll</code>、<code class="fe nu nv nw nb b">findOne</code>、<code class="fe nu nv nw nb b">save</code>、<code class="fe nu nv nw nb b">delete</code>，这些我们在<code class="fe nu nv nw nb b">BlogRepository.java</code>中没有定义。</p><p id="9b49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些方法是由我们扩展的<code class="fe nu nv nw nb b">JpaRepository</code>提供的。</p><p id="b982" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nu nv nw nb b">findAll()</code>返回表格中的所有行。这相当于:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="b151" class="nf lz it nb b gy ng nh l ni nj">SELECT * FROM blog</span></pre><p id="8d01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nu nv nw nb b">findOne(<strong class="kw iu">param</strong>)</code>返回一个与<code class="fe nu nv nw nb b">param</code>主键字段匹配的项目。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="3fc9" class="nf lz it nb b gy ng nh l ni nj">SELECT * FROM blog WHERE id=<strong class="nb iu">param</strong> LIMIT 1</span></pre><p id="1dac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nu nv nw nb b">save(<strong class="kw iu">blog</strong>)</code>将条目保存到数据库中。如果提供了新的博客条目，该函数将创建新的记录，如果提供了现有的博客条目，该函数将更新现有的记录。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5316" class="nf lz it nb b gy ng nh l ni nj">INSERT INTO blog(title, content) VALUES (<strong class="nb iu">blog.title</strong>, <strong class="nb iu">blog.content</strong>)</span></pre><p id="9e58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="871c" class="nf lz it nb b gy ng nh l ni nj">UPDATE blog SET title=<strong class="nb iu">blog.title</strong>, content=<strong class="nb iu">blog.content</strong> WHERE id=<strong class="nb iu">blog.id</strong></span></pre><p id="1d9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nu nv nw nb b">delete(<strong class="kw iu">param</strong>)</code>根据提供的<code class="fe nu nv nw nb b">id</code>删除表格中的条目。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="41d2" class="nf lz it nb b gy ng nh l ni nj">DELETE FROM blog WHERE id=<strong class="nb iu">param</strong></span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="e701" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">自定义JPA查询</h1><p id="2e05" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">虽然JPA为我们提供了开箱即用的默认CRUD操作(即<code class="fe nu nv nw nb b">findAll</code>、<code class="fe nu nv nw nb b">findOne</code>、<code class="fe nu nv nw nb b">save</code>、<code class="fe nu nv nw nb b">delete</code>)，但它留给我们来定义我们的定制查询。</p><p id="0d9f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在JPA中定义定制查询非常容易。让我们来看一些示例查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/02cb187d5b92ac34662083ef3b2860a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I4jrFZ6keOHlyujfQVa7fg.png"/></div></div></figure><ul class=""><li id="bcd5" class="nl nm it kw b kx ky la lb ld nn lh no ll np lp nq nr ns nt bi translated"><code class="fe nu nv nw nb b">findBy</code>子句是主要的查询关键字。接下来是“栏目名称”，然后是查询<code class="fe nu nv nw nb b">Constrain</code>，如<code class="fe nu nv nw nb b">Contains</code>、<code class="fe nu nv nw nb b">Containing</code>、<code class="fe nu nv nw nb b">GreatherThan</code>、<code class="fe nu nv nw nb b">LessThan</code>等。</li><li id="5e7b" class="nl nm it kw b kx nx la ny ld nz lh oa ll ob lp nq nr ns nt bi translated"><code class="fe nu nv nw nb b">And</code>和<code class="fe nu nv nw nb b">Or</code>作为连接词连接两个或多个查询条件，类似于MySQL的<code class="fe nu nv nw nb b">AND</code>和<code class="fe nu nv nw nb b">OR</code>。</li></ul><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="30be" class="nf lz it nb b gy ng nh l ni nj">MORE EXAMPLES:<br/>-----------------------------------------------------------------</span><span id="ca75" class="nf lz it nb b gy nk nh l ni nj">JPA:       findByIdGreatherThan(20)   <br/>SQL:       WHERE id &gt; 20<br/>-----------------------------------------------------------------</span><span id="fa78" class="nf lz it nb b gy nk nh l ni nj">JPA:       findByIdGreatherThanAndTitleContaining(20, "google")<br/>SQL:       WHERE id &gt; 20 AND title LIKE "%google%"<br/>-----------------------------------------------------------------<br/>JPA:       findByIdGreaterThanEqualOrTitle(5, "google api")<br/>SQL:       WHERE id &gt;= 5 OR title = "google api"</span></pre><p id="70a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/" rel="noopener ugc nofollow" target="_blank">你可以在这里阅读更多关于JPA查询的内容</a>。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f000" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结果:REST控制器输出</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/fe5581d72418d0bf36980758cf1301ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5QFf2AA714DtAL-q-i4Hg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/0e6ddbfd6e697ee4ed35979dd4feeb02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cyqjZ0rK4EjmFY7wgUOGAA.png"/></div></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="e91c" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">最后一个音符</h1><p id="9d31" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们已经看到了如何集成MySQL数据库和Java持久API。希望你喜欢这个教程。如果你有任何问题，请在评论区告诉我。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="09d0" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">源代码</h1><p id="6ec9" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated"><a class="ae lq" href="https://github.com/salisuwy/building-spring-boot-resp-api-v3" rel="noopener ugc nofollow" target="_blank">GitHub上的完整源代码</a>。</p></div></div>    
</body>
</html>