<html>
<head>
<title>Using async/await in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中使用async/await</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-async-await-in-swiftui-dfc5e08b03f7?source=collection_archive---------6-----------------------#2021-02-10">https://betterprogramming.pub/using-async-await-in-swiftui-dfc5e08b03f7?source=collection_archive---------6-----------------------#2021-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ab74" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">快速进化</h2><div class=""/><div class=""><h2 id="bc5b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">并发变得简单多了</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/fb396dd69a4c58165a4b34addde992de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ymd5kUAbzPd3wllKzjvgpw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="ce3d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们编写的许多代码都必须处理异步行为。从磁盘获取数据、向远程API发送请求或下载图像——所有这些操作都需要时间，即使在超高速、低延迟的在家工作网络上也是如此。</p><p id="2b78" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">处理这种情况的一个简单方法是等待，直到一个呼叫结束，我们请求的数据到达。这种方法的问题是你的应用程序的用户界面在等待的时候会冻结。我们都使用过在某些任务上似乎完全冻结的应用程序——这是一种糟糕的用户体验。</p><p id="67f3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">那么如何才能做得更好呢？</p><p id="2089" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一种方法是在后台线程上执行长时间运行的任务，并在结果到达后回调主应用程序。有许多方法可以实现这一点。作为iOS开发人员，我们对委托很熟悉:您调用一个方法，过一会儿您将收到一个委托方法的结果。这样做效果很好，但是产生的代码分散在各处，很难阅读。</p><p id="d865" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">闭包提供了一种稍微更优雅的方式来编写异步代码。让我们看一些真实例子的伪代码:在餐馆点餐。</p><pre class="ks kt ku kv gt md me mf mg aw mh bi"><span id="1c0f" class="mi mj it me b gy mk ml l mm mn">chatWithFriends()<br/>placeOrder(theOrder) { meal in<br/>  eat(meal)<br/>}</span></pre><p id="64c1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里重要的是，你可以在等待你的订单到达的同时继续和你的朋友聊天。调用<code class="fe mo mp mq me b">placeOrder</code>后花括号中的代码被称为<em class="mr">尾随闭包</em>，只有当饭菜准备好并送到您的住处时，才会调用它。</p><p id="4060" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这与同步代码非常不同，在同步代码中，计算机按顺序执行一个又一个语句。下面的伪代码更类似于我们对这种情况的理解:</p><pre class="ks kt ku kv gt md me mf mg aw mh bi"><span id="e7d5" class="mi mj it me b gy mk ml l mm mn">placeOrder(theOrder)<br/>chatWithFriends()<br/>meal = receiveMeal()<br/>eat(meal)</span></pre><ol class=""><li id="8623" class="ms mt it lj b lk ll ln lo lq mu lu mv ly mw mc mx my mz na bi translated">我们下订单。</li><li id="a1e1" class="ms mt it lj b lk nb ln nc lq nd lu ne ly nf mc mx my mz na bi translated">然后，当我们等待饭菜端上来的时候，我们和朋友聊天。</li><li id="5226" class="ms mt it lj b lk nb ln nc lq nd lu ne ly nf mc mx my mz na bi translated">过了一会儿，饭菜来了，我们可以享用了。</li></ol><p id="07f5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">使用闭包和回调来处理异步代码现在很常见，许多iOS SDKs，如Alamofire、AWS Amplify、Firebase，甚至苹果自己的<code class="fe mo mp mq me b">URLSession</code>都使用了它。</p><p id="3d85" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然而，一旦您试图协调几个异步调用，这种代码很快就会变得难以阅读，更糟糕的是，很难正确处理。如果我们能够以类似于第二段代码的方式编写异步代码，那不是很好吗？</p><p id="6282" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">好消息是，我们可以做到:Swift团队已经提议在Swift语言中增加一项功能，让我们可以做到这一点。该提案被命名为<a class="ae ng" href="https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md" rel="noopener ugc nofollow" target="_blank"> SE-0296 </a>，可在Swift编译器工具链的开发快照中获得。它为Swift添加了对async/await的支持，这将允许我们在不使用回调的情况下进行异步调用。</p><p id="c4ab" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本文中，我将向您展示如何安装编译器工具链，激活这个新特性，并重写基于回调的代码片段以利用async/await。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">观看此视频，了解这一点</p></figure></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="f570" class="nq mj it bd nr ns nt nu nv nw nx ny nz ki oa kj ob kl oc km od ko oe kp of og bi translated">安装实验编译器工具链</h1><p id="f66f" class="pw-post-body-paragraph lh li it lj b lk oh kd lm ln oi kg lp lq oj ls lt lu ok lw lx ly ol ma mb mc im bi translated">为了试验这一特性，我们首先需要从Swift网站上的<a class="ae ng" href="https://swift.org/download/" rel="noopener ugc nofollow" target="_blank">下载页面</a>下载Swift编译器工具链。向下滚动到“主干开发(主)”部分，并点击Xcode链接。链接标题有点误导——该下载实际上并不包含Xcode的副本。它实际上只是编译器工具链。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/c9ebcb25ab03081ebd02aec5fa29baef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*EwKBWXu5BhraiUz8.png"/></div></figure><p id="9150" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下载完成后，我们可以通过双击软件包来安装它。</p><p id="704d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">要激活编译器工具链，我们需要启动Xcode并选择工具链。进入首选项&gt;组件&gt;工具链并选择Swift开发快照。在这个对话框中，你还会看到官方的工具链——它的标签是Xcode 12.5。当你回到你的工作项目时，不要忘记切换回这个原始的工具链。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/d5bec22009375a3fb2c1643b3bc5b541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*G6OXoY1llJElP57m.png"/></div></figure><p id="92d9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一旦工具链被激活，Xcode将在状态区域显示一个蓝色的链图标:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/bec5f996fd20fe2a90190618bfb39afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*wViNV26ngwS4oqpy.png"/></div></figure><p id="7235" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">注意:值得记住的是，这是一个实验性的特性，从现在到发布时，情况可能会有所变化。最重要的是，不可能使用实验工具链将构建版本发布到App Store。你也不能在真实设备上运行，只能在模拟器上运行。所以不要在你的产品代码中使用它。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="cd7c" class="nq mj it bd nr ns nt nu nv nw nx ny nz ki oa kj ob kl oc km od ko oe kp of og bi translated">启用对并发的实验性支持</h1><p id="4faa" class="pw-post-body-paragraph lh li it lj b lk oh kd lm ln oi kg lp lq oj ls lt lu ok lw lx ly ol ma mb mc im bi translated">在使用async/await之前，我们需要在项目的构建设置中启用实验性并发。</p><p id="344a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为此，我们需要打开构建设置，找到其他Swift标志，并添加<code class="fe mo mp mq me b">-Xfrontend -enable-experimental-concurrency</code>。</p><p id="2ab0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">注意:<a class="ae ng" href="https://github.com/apple/swift/pull/35784" rel="noopener ugc nofollow" target="_blank"> PR 35784 </a>默认情况下启用async/await，所以一旦它推出，您就可以使用这个特性，而不必启用实验支持——安装工具链就足够了。</p><p id="dc42" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">尝试启动应用程序时，您可能会看到一条错误消息，提示“无法启动(应用程序名称)— LLDB未提供错误字符串”。如果发生这种情况，请关闭应用程序目标的调试:选择您的目标，然后选择编辑方案…&gt;运行并取消选择“调试可执行文件”复选框。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/6a64d48b50e6a9b7d967118762c875b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*JdcYOErtYy8bh9Bh.png"/></div></figure></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="c01e" class="nq mj it bd nr ns nt nu nv nw nx ny nz ki oa kj ob kl oc km od ko oe kp of og bi translated">查看示例项目</h1><p id="39e3" class="pw-post-body-paragraph lh li it lj b lk oh kd lm ln oi kg lp lq oj ls lt lu ok lw lx ly ol ma mb mc im bi translated">如果您想继续学习，可以从<a class="ae ng" href="https://github.com/peterfriese/Swift-Async-Await-Experiments" rel="noopener ugc nofollow" target="_blank">GitHub repo</a>下载本文的示例项目，切换到<a class="ae ng" href="https://github.com/peterfriese/Swift-Async-Await-Experiments/tree/blog/article_analyser/starter" rel="noopener ugc nofollow" target="_blank"> starter </a>分支，然后打开ArticleAnalyser项目。</p><p id="852f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">该示例项目包含一些我从目前正在进行的另一个项目中获得的功能:用户可以添加他们希望稍后阅读的文章的链接，应用程序将分析网页并提取信息，如标题、英雄图像和其他元信息。此外，它将使用一些自然语言API来为文本计算有意义的标签。例如，如果你粘贴一个链接到这篇文章，它应该建议标签<em class="mr">并发</em>和<em class="mr">迅捷</em>。</p><p id="2160" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">获取网页文本是一项异步任务，执行分析也可能需要一点时间——尤其是如果我们要使用任何基于云的API。目前，代码使用苹果的<code class="fe mo mp mq me b">NLTagger</code>API，但在未来，我们可能会决定使用<a class="ae ng" href="https://cloud.google.com/natural-language" rel="noopener ugc nofollow" target="_blank">谷歌的云自然语言API</a>。</p><p id="562f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">由于这是一个多步骤的过程，我定义了一个界面来帮助我们保持事物整洁有序:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on ni l"/></div></figure><p id="d3bb" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">该协议中的所有方法都使用尾随闭包，其中一些被标记为<code class="fe mo mp mq me b">@escaping</code>，这意味着在执行从方法返回后，将有代码保留闭包。这是异步代码的一个迹象。</p><p id="cf49" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">到目前为止，一切顺利。现在让我们看看控制整个过程的代码。请记住，我们首先需要下载组成网页的文本，然后提取所有信息，运行我们的自然语言处理等。</p><p id="e51c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你准备好了吗？看起来不太好。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on ni l"/></div></figure><p id="2a68" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我想我们都同意这真的很难读懂。事实上，当我把这个给我的一个同事看的时候，他说“我不知道在整个星系中有那么多闭合花括号！”</p><p id="6870" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最重要的是，错误处理甚至不是很好。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="89d1" class="nq mj it bd nr ns nt nu nv nw nx ny nz ki oa kj ob kl oc km od ko oe kp of og bi translated">异步/等待</h1><p id="ec35" class="pw-post-body-paragraph lh li it lj b lk oh kd lm ln oi kg lp lq oj ls lt lu ok lw lx ly ol ma mb mc im bi translated">让我们看看如何通过使用async/await来改进这段代码。</p><p id="1e47" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">第一步是摆脱所有的回调。相反，我们将告诉编译器，这些函数的结果将异步交付，它们可能会抛出错误。最后，我们指定返回类型。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on ni l"/></div></figure><p id="9da1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这看起来已经简单多了。当我们对其中一种方法进行之前/之后比较时，对比更加明显:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on ni l"/></div></figure><p id="b4a4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">新的方法签名看起来更干净，更容易看出输入参数和返回类型是什么。</p><p id="b9ee" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下一步，让我们更新驱动下载和分析网站的整个过程的代码。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on ni l"/></div></figure><p id="478c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">去掉回调处理程序允许我们以更简洁的方式编写代码。首先，我们可以将<code class="fe mo mp mq me b">process</code>方法标记为异步。然后我们会告诉编译器这个方法可能会抛出一个错误，返回类型是一个<code class="fe mo mp mq me b">Article</code>。</p><p id="b88d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">要调用标记为<code class="fe mo mp mq me b">async</code>的方法，我们需要在调用前加上<code class="fe mo mp mq me b">await</code>关键字。这告诉编译器它需要等待调用返回。好消息是Xcode会告诉我们<code class="fe mo mp mq me b">await</code>关键字是否丢失，甚至会主动为我们修复代码。</p><p id="1fed" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">就这样，我们消除了以前回调驱动实现中必须使用的深度嵌套回调结构。代码变得更加简洁明了，看起来像线性程序。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="bb5b" class="nq mj it bd nr ns nt nu nv nw nx ny nz ki oa kj ob kl oc km od ko oe kp of og bi translated">重构基于回调的代码</h1><p id="a986" class="pw-post-body-paragraph lh li it lj b lk oh kd lm ln oi kg lp lq oj ls lt lu ok lw lx ly ol ma mb mc im bi translated">当然，我们需要转换现有的代码来获取网页并提取所有的元数据。</p><p id="d8d7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们从采用我们之前定义的协议开始。</p><p id="ea8b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了了解将现有的基于回调的代码转换为async/await所需的工作量有多大，让我们粘贴现有的代码，然后对其进行适当的修改。</p><p id="41c5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是获取网页的代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on ni l"/></div></figure><p id="dbfd" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当我们将它粘贴到我们的新方法中时，您会注意到的第一件事是，我们不再有一个可以用来与调用者通信的<code class="fe mo mp mq me b">completion</code>处理程序。有多种方法可以处理这个问题，对于初始的<code class="fe mo mp mq me b">guard</code>语句，如果URL无效，我们可以抛出一个错误:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on ni l"/></div></figure><p id="6d70" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了包装现有代码，async/await建议为我们提供了一些助手函数，比如<code class="fe mo mp mq me b">withUnsafeThrowingContinuation</code>。这些助手函数使用一个带有<code class="fe mo mp mq me b">continuation</code>参数的闭包，当代码完成时可以调用这个闭包。</p><p id="2332" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它是这样工作的:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on ni l"/></div></figure><ul class=""><li id="bff1" class="ms mt it lj b lk ll ln lo lq mu lu mv ly mw mc oo my mz na bi translated">首先，我们将现有代码包装在对<code class="fe mo mp mq me b">withUnsafeThrowingContinuation</code>的调用中。</li><li id="bcfe" class="ms mt it lj b lk nb ln nc lq nd lu ne ly nf mc oo my mz na bi translated">然后，无论何时您想要与呼叫者通信，您都可以调用<code class="fe mo mp mq me b">continuation</code>来代替。</li><li id="1c07" class="ms mt it lj b lk nb ln nc lq nd lu ne ly nf mc oo my mz na bi translated"><code class="fe mo mp mq me b">UnsafeThrowingContinuation</code>有几个重载的<code class="fe mo mp mq me b">resume</code>方法，允许你返回一个<code class="fe mo mp mq me b">Result</code>类型和一个正常的返回值，或者甚至抛出一个错误。</li></ul><p id="9ebb" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这允许我们在下载失败时抛出一个错误。如果下载成功，我们可以返回网页的文本。</p><p id="a3de" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这些是将代码从使用回调转为使用async/await所需要做的唯一更改。</p><p id="eb67" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，您已经掌握了转换剩余函数的所有技术。我将把这作为一个练习留给你，但是如果你卡住了，检查一下项目回购中的<a class="ae ng" href="https://github.com/peterfriese/Swift-Async-Await-Experiments/tree/blog/article_analyser/final" rel="noopener ugc nofollow" target="_blank"> final </a>分支。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="5ad9" class="nq mj it bd nr ns nt nu nv nw nx ny nz ki oa kj ob kl oc km od ko oe kp of og bi translated">连接用户界面</h1><p id="6d42" class="pw-post-body-paragraph lh li it lj b lk oh kd lm ln oi kg lp lq oj ls lt lu ok lw lx ly ol ma mb mc im bi translated">最后，让我们将UI连接到我们的新代码。在这个示例应用程序中，我们使用<code class="fe mo mp mq me b">ArticlesViewModel</code>作为事实的来源——它有一个名为<code class="fe mo mp mq me b">articles</code>的已发布属性，包含主列表视图将显示的所有文章的列表。</p><p id="e7e4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">目前，当用户添加一个要分析的新URL时，UI将调用<code class="fe mo mp mq me b">addNewArticle</code>，提供<code class="fe mo mp mq me b">url</code>作为输入参数。这个方法将调用<code class="fe mo mp mq me b">performAddNewArticle</code>，后者使用基于回调的<code class="fe mo mp mq me b">AnalyserService</code>来下载和分析文章，并将其添加到<code class="fe mo mp mq me b">articles</code>数组中。</p><p id="1539" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">相反，我们想使用我们的新<code class="fe mo mp mq me b">AsyncArticleAnalyserService</code>。我们可以从制作一个<code class="fe mo mp mq me b">performAddNewArticle</code>的副本开始，并做一些调整，以便它能与我们新的异步代码一起工作。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on ni l"/></div></figure><p id="2fa0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们已经知道，我们需要给异步函数的调用加上前缀<code class="fe mo mp mq me b">async</code>，由于方法可以抛出，我们还需要将调用封装在一个<code class="fe mo mp mq me b">do / try / catch</code>块中。我们还可以去掉结尾的闭包，并将结果赋给一个名为<code class="fe mo mp mq me b">article</code>的局部变量。</p><p id="0f92" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但是Xcode似乎并不高兴，显示了一个错误:<code class="fe mo mp mq me b">'async' in a function that does not support concurrency</code>。这是因为我们试图从一个不包含在异步上下文中的地方调用。我们可以遵循Xcode的建议，使用<code class="fe mo mp mq me b">@asyncHandler</code>标记<code class="fe mo mp mq me b">performAddNewArticleAsync</code>，而不是自己建立一个异步上下文:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on ni l"/></div></figure><p id="83d5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这样，我们现在可以再次运行该应用程序，并查看我们全新的async/await实现的运行情况！</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="6ddb" class="nq mj it bd nr ns nt nu nv nw nx ny nz ki oa kj ob kl oc km od ko oe kp of og bi translated">关闭；-)</h1><p id="5c17" class="pw-post-body-paragraph lh li it lj b lk oh kd lm ln oi kg lp lq oj ls lt lu ok lw lx ly ol ma mb mc im bi translated">我认为async/await是对Swift语言的一个很好的补充。许多其他语言，如C#、JavaScript或TypeScript，都有类似的语言功能，在Swift中添加async/await将使来自这些语言的人更容易使用。</p><p id="6485" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">使用async/await将使您的代码更具可读性，并且正如我们刚刚看到的，重构现有代码相对简单。</p><p id="f767" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在您自己的代码中使用async/await的最强有力的论据之一是，这允许您显式地表示代码的某些部分异步运行。这对用户来说是一个强烈的信号，有助于他们更好地理解API的哪些部分是异步的，可能只是在短暂的停顿后才返回。更好的是，如果开发人员试图以非异步方式调用您的API，Swift编译器现在会发出警告和错误。这对于回调和尾随闭包来说是不可能的。</p><p id="7ce2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我还认为这对任何构建API的人来说都是一个好消息，有望减少他们花在支持上的时间。有趣的事实:“Firebase APIs是异步的…”是我在回答堆栈溢出问题时最常用的句子之一。</p><p id="b82a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我迫不及待地想在Swift的下一个版本中加入这一特性。你呢？在本文资源库的<a class="ae ng" href="https://github.com/peterfriese/Swift-Async-Await-Experiments/discussions" rel="noopener ugc nofollow" target="_blank">讨论论坛</a>上联系我。</p></div></div>    
</body>
</html>