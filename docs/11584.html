<html>
<head>
<title>A Guide to Loose Coupling and Writing Better Python Code With Dependency Inversion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">松散耦合和使用依赖反转编写更好的Python代码指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-guide-to-loose-coupling-and-writing-better-python-code-with-dependency-inversion-bec5f7460f7?source=collection_archive---------5-----------------------#2022-04-01">https://betterprogramming.pub/a-guide-to-loose-coupling-and-writing-better-python-code-with-dependency-inversion-bec5f7460f7?source=collection_archive---------5-----------------------#2022-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dbbe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入流行的设计模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a495ec3433d599d129403a0bc7082321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OQJ7xzVI1leNaCKS"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由瑞秋·尼克森 / <a class="ae ky" href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="593d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是关于<a class="ae ky" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">坚实</a>原则系列文章的第5部分。<br/>你可以在这里找到4号岗位<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/the-interface-segregation-principle-isp-explained-in-python-46e173241642">，在这里</a>找到3号岗位<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/the-liskov-substitution-principle-lsp-explained-in-python-6ab92b29d0b8">，在这里</a>找到2号岗位<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/the-open-closed-principle-explained-in-python-f5517488f990">，在这里</a>找到1号岗位<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/the-single-responsibility-principle-explained-in-python-622e2d996d86">。</a></p><p id="fb9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们终于达到了最后的坚实的原则。像往常一样，我们从一个定义开始:</p><p id="f64e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原则5被称为依赖性反转原则。该定义有两个部分:</p><blockquote class="lv lw lx"><p id="b972" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">A.高级模块不应该从低级模块导入任何东西。两者都应该依赖于抽象(例如接口)。</p><p id="d6af" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">B.抽象不应该依赖于细节。细节(具体的实现)应该依赖于抽象。</p><p id="216d" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">来源:<a class="ae ky" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank">依存倒置原则——维基百科</a></p></blockquote><p id="f0b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在传统的软件架构中，我们设计较低级别的组件供较高级别的组件使用/消费。换句话说，较高级别的组件依赖于较低级别的组件。这种依赖性导致了软件中的紧密耦合。正如原则<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/the-single-responsibility-principle-explained-in-python-622e2d996d86"> one </a>中所解释的，我们努力实现松耦合，以便将来更容易开发、维护和更改代码。</p><p id="7d55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖性反转原则<em class="ly">在某种意义上反转了</em>这种依赖性，而不是更高级别的组件依赖于更低级别的组件，两者都应该依赖于抽象。这个抽象层将是一个位于高层和低层组件之间的中间组件。然后，这两个组件将使用这个组件相互通信和交互。抽象组件通常会被实现为一个<em class="ly">接口</em>。</p><p id="201b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候给出一些代码和具体的例子了！</p><h1 id="c1de" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">密码</h1><p id="2c5c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">考虑下面的例子，其中我们模拟了一个机器人:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f167" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">Robot</code>类只有一个函数<code class="fe nb nc nd ne b">get_energy</code>。我们制作了一个机器人可以从中获取能量的<code class="fe nb nc nd ne b">Apple</code>模型。</p><p id="d06b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在某个时候机器人会厌倦吃苹果。所以我们增加了一个<code class="fe nb nc nd ne b">Chocolate</code>类来给机器人提供更多的饮食选择。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，请注意<code class="fe nb nc nd ne b">get_energy</code>方法发生了什么。我们必须传递一个字符串作为参数，指示机器人应该吃什么食物。此外，我们必须在两种不同的食物上使用if-else分支。现在你可以想象如果增加更多的食物，我们将需要更多的树枝。这不是好的设计。</p><p id="e06a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，因为<code class="fe nb nc nd ne b">Robot</code>依赖于每一个单独的食物，如果其中一个食物的实现发生变化，我们就会遇到问题。例如，如果我们向<code class="fe nb nc nd ne b">Chocolate</code>中的<code class="fe nb nc nd ne b">eat</code>方法引入一个额外的参数，那么<code class="fe nb nc nd ne b">get_energy</code>中的代码将会中断，我们将不得不重构它以反映<code class="fe nb nc nd ne b">Chocolate</code>中的变化。这些问题是由于<em class="ly">紧耦合</em>和<em class="ly">强依赖</em>造成的，违反了依赖反转原则。</p><p id="44f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，我们的架构如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/aeb3ca8882bf46b18ead6c852732b141.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*o4pgVfbTlXGINW50EuO_sQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">依赖苹果和巧克力的机器人</p></figure><h1 id="a573" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">解决办法</h1><p id="e5ad" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了解决这个问题，我们需要引入一个抽象层。<br/>我们将架构修改如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/556bd1a9364616c6304c36d17d3edea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*e4_E7ZHCvnBGffjiZYJyRg.png"/></div></figure><p id="6307" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b754" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建一个由<code class="fe nb nc nd ne b">Apple</code>和<code class="fe nb nc nd ne b">Chocolate</code>实现的<code class="fe nb nc nd ne b">Eatable</code>接口。<br/>我们改变了<code class="fe nb nc nd ne b">get_energy</code>的方法签名，因此它需要一个类型为<code class="fe nb nc nd ne b">Eatable</code>的参数，而不是<code class="fe nb nc nd ne b">str</code>。这意味着我们可以去掉if-else分支。此外，由于所有的食物都实现了<code class="fe nb nc nd ne b">Eatable</code>接口，我们确信如果<code class="fe nb nc nd ne b">Chocolate</code>或<code class="fe nb nc nd ne b">Apple</code>发生变化，将不会出现代码破坏。</p><h1 id="28b3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="7352" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这篇文章中，我们看了依赖倒置原则。该原则本质上是说，较高级别的模块不应该依赖于较低级别的模块。相反，两者都应该依赖于抽象。我们使高级模块独立于低级模块中的实现细节。</p><p id="3452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原则是:</p><ul class=""><li id="dc98" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">加强松散耦合，从而有助于使代码在面对变化时更加健壮。</li><li id="b746" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">允许重用较高级别的组件，因为抽象层可以防止在较低级别的组件需要更改时出现代码中断。</li></ul><p id="d7cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们终于到达终点了！</p><p id="e83c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章和之前所有关于坚实原则的文章。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="7967" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ly">最初发表于</em>【https://haseebkamal.com】<em class="ly"/></p></div></div>    
</body>
</html>