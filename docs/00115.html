<html>
<head>
<title>Demystifying Server-Side Rendering in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开React中服务器端渲染的神秘面纱</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/demystifying-reacts-server-side-render-de335d408fe4?source=collection_archive---------0-----------------------#2018-03-26">https://betterprogramming.pub/demystifying-reacts-server-side-render-de335d408fe4?source=collection_archive---------0-----------------------#2018-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="13d5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">仔细看看这个特性，它允许你用<strong class="ak"> React </strong>构建<strong class="ak">通用</strong> <strong class="ak">应用</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eff58c54966b7196e3012117a1552c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vV47LI67-6Cn4DHKUzxzRQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lukasneasi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Lukas Neasi </a>在<a class="ae ky" href="https://unsplash.com/search/photos/mist?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="570e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务器端呈现——从这里开始称为SSR是一个<strong class="lb iu">前端框架</strong>在一个<strong class="lb iu">后端系统</strong>上运行时呈现标记的能力。</p><p id="c41a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">能够在服务器和客户端上渲染的应用程序被称为<strong class="lb iu">通用应用程序</strong>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0604" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">何必呢？</h1><p id="7d4a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了理解为什么需要SSR，我们需要理解web应用程序在过去十年中的演变。</p><p id="3f91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与<a class="ae ky" href="https://medium.com/@NeotericEU/single-page-application-vs-multiple-page-application-2591588efe58" rel="noopener"> <em class="mz">单页应用</em></a><em class="mz">——</em>SPA的兴起紧密相关。与传统的服务器端应用相比，spa在速度和UX方面有很大优势。</p><p id="80ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是有一个问题。最初的服务器请求通常是返回一个<strong class="lb iu">空的</strong> <strong class="lb iu"> HTML </strong>文件，其中包含一堆CSS和JavaScript (JS)链接。然后需要获取外部文件以呈现相关的标记。</p><p id="9ab8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着用户将不得不等待更长时间的<strong class="lb iu">初始渲染</strong>。这也意味着爬虫程序可能会将您的页面解释为空的。</p><p id="27be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们的想法是首先在服务器上呈现您的应用程序，然后在客户端利用SPAs的功能。</p><p id="5e96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> SSR + SPA =通用应用* </strong></p><p id="a289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">*你会在一些文章中发现术语<em class="mz">同构app</em>——是一回事。</p><p id="fcad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在用户不必等待你的JS加载，只要初始请求返回一个响应，用户就会得到一个完全呈现的HTML。</p><p id="b4b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下用户在慢速3G网络上导航的巨大改善。他们不用等20多秒来加载网站，而是几乎立刻就能在屏幕上看到内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/bc60a53b92e54ce013c7adc80749c030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v0wyppYBPaeqoeKRplinvQ.png"/></div></div></figure><p id="18e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，对服务器的所有请求都返回完全呈现的HTML。对你的SEO部门来说是个好消息！</p><p id="cb1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Web_crawler" rel="noopener ugc nofollow" target="_blank">爬虫</a>现在会将你的网站视为网络上的任何其他静态网站，并将<strong class="lb iu">索引</strong>你在服务器上呈现的所有内容。</p><p id="1c5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">概括来说，我们从SSR中获得的两个主要好处是:</p><ul class=""><li id="54bc" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">初始页面渲染速度更快</li><li id="4c57" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">完全可索引的HTML页面</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ca1d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">了解SSR —一步一个脚印</h1><p id="bbad" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们采用迭代方法来构建完整的SSR示例。我们从React的服务器渲染API开始，我们将在每一步添加一些东西。</p><p id="1cd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以遵循<a class="ae ky" href="https://github.com/alexnm/react-ssr" rel="noopener ugc nofollow" target="_blank">这个存储库</a>和在那里为每个步骤定义的标签。</p><h2 id="b4b7" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">基本设置</h2><p id="43d3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">重要的事情先来。为了使用SSR，我们需要一个服务器！我们将使用一个简单的<em class="mz"> Express </em>应用来呈现我们的React应用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="67ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要告诉Express从我们的输出文件夹提供静态文件——第10行。</p><p id="3a6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建一个处理所有非静态传入请求的路由。该路由将使用呈现的HTML进行响应。</p><p id="c479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe od oe of og b">renderToString</code>——第13–14行——将我们的起始JSX转换成一个<code class="fe od oe of og b">string</code>,然后插入到HTML模板中。</p><p id="0e94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们对客户端代码和服务器代码使用了相同的Babel插件。所以<em class="mz"> JSX </em>和<em class="mz"> ES模块</em>在<code class="fe od oe of og b">server.js</code>内部工作。</p><p id="9fd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端上对应的方法现在是<code class="fe od oe of og b">ReactDOM.hydrate</code>。该函数将使用服务器呈现的React应用程序，并将附加事件处理程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="b036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要查看完整的示例，请查看<a class="ae ky" href="https://github.com/alexnm/react-ssr/tree/basic" rel="noopener ugc nofollow" target="_blank">存储库</a>中的<code class="fe od oe of og b">basic</code>标签。</p><p id="e722" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！您刚刚创建了您的第一个<strong class="lb iu">服务器渲染的</strong> React应用程序！</p><h2 id="c461" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">反应路由器</h2><p id="7dbd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们必须诚实地说，这个应用程序并没有做太多的事情。所以让我们添加一些路由，看看我们如何处理服务器部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="36c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe od oe of og b">Layout</code>组件现在在客户机上呈现多条路线。</p><p id="a6cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要在服务器上模拟路由器设置。下面你可以看到应该做的主要改变。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d0a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在服务器上，我们需要将React应用程序包装在<code class="fe od oe of og b">StaticRouter</code>组件中，并提供<code class="fe od oe of og b">location</code>。</p><p id="f120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便提一下，<code class="fe od oe of og b">context</code>用于在呈现React DOM时跟踪潜在的重定向。这需要用来自服务器的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Redirection_messages" rel="noopener ugc nofollow" target="_blank"> 3XX响应</a>来处理。</p><p id="7cb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的示例可以在<a class="ae ky" href="https://github.com/alexnm/react-ssr/releases/tag/router" rel="noopener ugc nofollow" target="_blank">相同存储库</a>中的<code class="fe od oe of og b">router</code>标签上看到。</p><h2 id="6ae0" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">Redux</h2><p id="392c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们有了路由功能，让我们集成<a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>。</p><p id="bd53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在简单的场景中，我们需要Redux来处理客户端的状态管理。但是如果我们需要根据那个状态来呈现DOM的一部分呢？在服务器上初始化Redux是有意义的。</p><p id="01d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你的应用程序正在<strong class="lb iu">服务器</strong>上<strong class="lb iu">分派</strong> <strong class="lb iu">动作</strong>，它需要<strong class="lb iu">捕获</strong>状态，并通过网络与HTML一起发送。在客户端，我们将初始状态输入Redux。</p><p id="68fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先来看看服务器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="a148" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它看起来很难看，但是我们需要将完整的JSON状态和我们的HTML一起发送。</p><p id="f051" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们看看客户:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="1406" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们调用了两次<code class="fe od oe of og b">createStore</code>,第一次在服务器上，然后在客户机上。然而，在客户机上，我们用保存在服务器上的任何状态来初始化状态。这个过程类似于DOM水合。</p><p id="0718" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的示例可以在<a class="ae ky" href="https://github.com/alexnm/react-ssr/releases/tag/redux" rel="noopener ugc nofollow" target="_blank">同一个存储库</a>中的<code class="fe od oe of og b">redux</code>标签上看到。</p><h2 id="1bff" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">取数据</h2><p id="7654" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">拼图的最后一块是加载数据。这就是事情变得有点棘手的地方。假设我们有一个服务于JSON数据的API。</p><p id="bb04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的代码库中，我从一个公共API 获取2018年一级方程式赛季<a class="ae ky" href="https://ergast.com/mrd/" rel="noopener ugc nofollow" target="_blank">的所有事件。假设我们想在<strong class="lb iu">主页</strong>上显示所有事件。</a></p><p id="a1fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在安装了React应用程序并呈现了所有内容之后，我们只能从客户端调用API。但是这将对UX产生不好的影响，可能会在用户看到相关内容之前显示一个旋转器或加载器。</p><p id="3fe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经有了Redux作为在服务器上存储数据并将其发送到客户端的方法。</p><p id="495d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在服务器上进行API调用，将结果存储在Redux中，然后为客户端呈现包含相关数据的完整HTML，会怎么样？</p><p id="436d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们怎么知道哪些电话需要打呢？</p><p id="b013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要一种不同的方式来声明路由。所以我们切换到所谓的路由配置文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="f7fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们静态地声明每个组件的数据需求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="98e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住<code class="fe od oe of og b">serverFetch</code>是虚构的——你可以用任何听起来对你更好的。</p><p id="0cee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意的是，<code class="fe od oe of og b">fetchData</code>是一个<a class="ae ky" href="https://github.com/gaearon/redux-thunk" rel="noopener ugc nofollow" target="_blank"> Redux thunk动作</a>，在调度时返回一个承诺。</p><p id="623d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在服务器上，我们可以使用来自<code class="fe od oe of og b">react-router</code>的一个叫做<code class="fe od oe of og b">matchRoute</code>的特殊函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="5ab6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们得到了一个组件列表，当React被渲染为当前URL上的字符串时，这些组件将被挂载。</p><p id="4eeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们收集<em class="mz">数据需求</em>，并等待所有API调用返回。最后，我们继续服务器渲染，但是数据已经在Redux中可用。</p><p id="c138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的例子可以在<a class="ae ky" href="https://github.com/alexnm/react-ssr/tree/fetch-data" rel="noopener ugc nofollow" target="_blank">同一个库</a>中的<code class="fe od oe of og b">fetch-data</code>标签上看到。</p><p id="12e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能会注意到这带来了性能损失，因为我们将渲染延迟到获取数据之后。</p><p id="e98a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是您开始比较指标并尽最大努力理解哪些呼叫是必要的，哪些不是必要的。例如，获取电子商务应用程序的产品可能是至关重要的，但价格和侧边栏过滤器可能会被延迟加载。</p><h2 id="2f1c" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">头盔</h2><p id="8ccc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">作为奖励，我们来看看SEO。在使用React时，您可能希望在您的<code class="fe od oe of og b">&lt;head&gt;</code>标签中设置不同的值。例如，您可能想要设置<em class="mz">标题</em>、<em class="mz">元标签</em>、<em class="mz">关键字、</em>等等。</p><p id="6d24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，<code class="fe od oe of og b">&lt;head&gt;</code>标签通常不是React应用程序的一部分！</p><p id="5b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/nfl/react-helmet" rel="noopener ugc nofollow" target="_blank">react-头盔</a>你在这个场景中覆盖了。并且对SSR有很大的支持。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="50dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您只需将您的<code class="fe od oe of og b">head</code>数据添加到组件树中的任意位置。这为您在客户端上安装的React应用程序之外更改值提供了支持。</p><p id="8e73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们增加了对SSR的支持:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="9198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了一个全功能的React SSR示例！</p><p id="07d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从一个简单的HTML渲染开始，在一个<em class="mz"> Express </em>应用的上下文中。我们逐渐增加了路由、状态管理和数据获取。最后，我们处理了React应用程序范围之外的更改。</p><p id="7135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的代码库在之前提到的同一个库的<code class="fe od oe of og b">master</code>上。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d539" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="fa09" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如您所看到的，SSR不是什么大事，但它可能会变得复杂。如果你一步一步地建立你的需求，它会更容易掌握。</p><p id="fd15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在你的应用中加入SSR值得吗？一如既往，视情况而定。如果你的网站是公开的，成千上万的用户可以访问，这是必须的。但是，如果您正在构建一个类似工具/仪表板的应用程序，这可能不值得。</p><p id="c44b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，利用通用应用程序的力量对于前端社区来说是向前迈进了一步。</p><p id="277c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您对SSR使用类似的方法吗？或者你认为我错过了什么？在下面给我留言。</p><p id="50d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你觉得这篇文章有用，帮我分享给社区吧！</p></div></div>    
</body>
</html>