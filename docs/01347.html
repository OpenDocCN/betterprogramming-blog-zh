<html>
<head>
<title>Why You Should Be Using Controlled Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该使用受控组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/controlled-components-are-awesome-and-we-dont-talk-about-it-enough-6bb21ce8256a?source=collection_archive---------19-----------------------#2019-09-02">https://betterprogramming.pub/controlled-components-are-awesome-and-we-dont-talk-about-it-enough-6bb21ce8256a?source=collection_archive---------19-----------------------#2019-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7cee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">他们很棒——而我们对此谈论得不够</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e64e7dc91566fdd4e3c6166ae29d691d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2P5ewH2dCiMRvDFjnOrfrQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚历克斯·约马尔(<a class="ae ky" href="https://pixabay.com/fr/users/yomare-539547/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/fr/users/yomare-539547/</a>)</p></figure><p id="dbbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">受控组件</em>，一个由<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>推广的术语，是简单的组件，它们从赋予它们的属性中获得它们的整个状态，而不是通过保存内部数据。我认为它们是制作一个可维护的UI的最重要的成分之一，在React社区之外还没有被充分讨论(也许在it界也是如此)。受控组件使测试变得更容易，只需很少的额外努力就能提供可定制性，并且本质上是可组合的。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9924" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">什么是受控组件？</h1><p id="2af9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">受控组件只是其状态由其父组件管理而非内部管理的组件。这是一个简单的想法，但是它确实改变了你创建组件的方式。</p><p id="b1b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使本文尽可能与框架无关，我们将尝试用纯JavaScript制作我们自己的简单输入组件——它采用一个选择器(显示在DOM中的何处插入组件)、一个标签、一个值和一个回调(当输入发生变化时通知它)。</p><p id="6659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是React、<a class="ae ky" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue </a>、<a class="ae ky" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>和任何其他SPA框架中的组件最终简化成的样子。</p><p id="ae90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑一个简单的非受控组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="40ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似的受控组件可以写成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组件根本不更新模型，而不是更新组件内部的模型并在事后通知父组件。相反，组件把对其状态的控制让给了它的父组件，父组件可以随心所欲地处理值。</p><p id="3a0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个琐碎的例子看起来像是做了很多额外的工作，却没有任何好处——我们只是添加了额外的步骤来做同样的事情。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="809a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">为什么要使用受控元件？</h1><p id="c4c5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">使用受控组件使我们能够以我们想要的任何方式改变组件的内部状态。</p><p id="c71a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，考虑如果我们想防止用户在添加无效字符时更改输入会发生什么。</p><p id="c196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在不受控制的组件示例中，我们需要在内部处理每一种不同类型的验证——因此，如果我们需要模式验证，我们需要将它与最大长度分开添加。</p><p id="69c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们天真地这样做，它会看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于受控组件，组件的实现不需要改变，因为父组件决定哪些值可以通过，哪些不可以。</p><p id="edf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，大多数没有受控组件的框架不会这样做，而是提供一个您可以自己编写的验证器函数的通用实现——接受值并返回true或false的函数。</p><p id="9427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这是由受控组件解决的单一症状的单一解决方案。</p><p id="d863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个不同的例子—如果您想在有人输入值时格式化输入，该怎么办？假设我们想为数字添加一个千位分隔符。</p><p id="6182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的不受控制的组件示例，我们将这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们的非受控组件示例变得越来越复杂，但我们最初的受控组件示例可以处理一切，而无需更改。</p><p id="1f55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">受控组件不费吹灰之力就给了我们很多功能。通过这种方式，对高层关注点有更好理解的调用者可以处理业务逻辑，而我们的组件可以保持精简并处理与DOM交互的低层方面。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6872" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">组件使测试变得容易</h1><p id="3515" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">测试UI(在本例中是DOM)既复杂又耗时。为了说明这一点，考虑一个针对我们之前的未受控组件的简单测试——我们想要测试对<code class="fe nc nd ne nf b">1</code>的<code class="fe nc nd ne nf b">maxLength</code>验证。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="bd41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你不仅需要启动整个浏览器(或者至少是一个模拟的dom环境，比如<a class="ae ky" href="https://github.com/jsdom/jsdom" rel="noopener ugc nofollow" target="_blank"> jsdom </a>)，你还需要不断地进行复杂、容易出错且耗时的DOM调用，比如<code class="fe nc nd ne nf b">querySelector</code>和<code class="fe nc nd ne nf b">triggerEvent</code>，你还需要知道组件如何工作的内部机制——在这种情况下，它只有一个输入。(即使您使用了为您包装这些操作的测试工具，也需要完成这些操作。)</p><p id="dbe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要对输入的每个变化都这样做(模式可能有几十个需要您验证有效性的例子)。</p><p id="b197" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，对于受控组件，您可以很容易地将测试分成两部分——测试组件是否根据提供给它的更改正确地更新，一旦您相信您的组件在输入时表现正常，您就可以测试<code class="fe nc nd ne nf b">onChange</code>功能了。不需要启动浏览器会话或进入DOM内部。</p><p id="ef9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">受控组件在组件的责任和调用者的责任之间定义了一个严格的屏障。反过来，它们消除了测试组件特性的所有排列的需要，让您可以分别测试组件和业务逻辑。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9e27" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">权衡</h1><p id="7e16" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当然，编程中没有免费的午餐，受控组件是有成本的——它们有更多的样板文件。因为不受控制的组件处理它们自己的状态，所以你不需要代码来处理你的父组件的状态。对于简单的用例，这通常是每个应用程序中的大多数，这变得乏味和低效。</p><p id="92f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们还会阻止组件最大限度地利用本地APIs考虑我们最初验证非法输入<code class="fe nc nd ne nf b">length</code>和<code class="fe nc nd ne nf b">pattern</code> <em class="lv">的例子。</em></p><p id="1ef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">HTMLInput</code>元素已经为这些类型的验证提供了内置的API，它们甚至可能提供额外的优势(例如，在移动设备上，如果你为输入验证提供某种模式，你可以得到不同的键盘)。</p><p id="0ab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该示例应该写成这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="203b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得吗？我的经验告诉我，是的。总有那么一点点特性或用例，不适合组件的可用定制。通常，为这种用例同步状态的努力掩盖了重复使用受控组件的样板文件。你的里程可能会有所不同。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="49f9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">受控组件不限于表单</h1><p id="9c8c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">大多数关于受控/非受控组件的文章(包括本文)都围绕表单输入展开，但是任何对变化做出反应的东西都可以成为受控组件。</p><p id="c56c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例子包括<em class="lv">可折叠/可折叠</em>、<em class="lv">列表</em>、<em class="lv">桌子</em>，任何真正互动的东西。</p></div></div>    
</body>
</html>