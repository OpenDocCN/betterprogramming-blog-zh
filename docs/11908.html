<html>
<head>
<title>How to Write JavaScript Code to Create and Update a Changelog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写JavaScript代码来创建和更新Changelog</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-javascript-code-to-create-and-update-a-changelog-4f57f2bca914?source=collection_archive---------6-----------------------#2022-04-26">https://betterprogramming.pub/how-to-write-javascript-code-to-create-and-update-a-changelog-4f57f2bca914?source=collection_archive---------6-----------------------#2022-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fa19" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不再有生成器、日志或依赖——现在是JavaScript！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7e64ee6fbe5cd32d567555746d5a263d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k4B3Tz2azGgrd4DEklvmUg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@grakozy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">格雷格·拉科齐</a>在<a class="ae ky" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="11e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你读了我的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-write-a-bash-script-to-create-and-update-a-changelog-de4df98985ab">上一篇关于如何编写python脚本来创建和更新changelog的文章</a>，或者<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-write-a-bash-script-to-create-and-update-a-changelog-de4df98985ab">上一篇关于在bash中编写changelog脚本的文章</a> <em class="lv">在</em>之前，你可能也会对这篇文章感兴趣。目标是增加对多种语言的支持，这样开发人员就不必只选择一种语言，而可以选择最符合他们当前使用的堆栈的语言。</p><p id="2805" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我添加了<a class="ae ky" href="https://github.com/macro6461/changelog-python" rel="noopener ugc nofollow" target="_blank"> JavaScript支持</a>来扩展我的<a class="ae ky" href="https://github.com/macro6461/changelog-bash" rel="noopener ugc nofollow" target="_blank">原始changelog脚本</a>给偏爱JavaScript的工程师。现在，您可以对JavaScript使用相同的脚本逻辑。如果您是一名JS开发人员，并且想要为您的changelog创建/生成添加更多的定制，那么现在有了这个新增的支持，您可以更容易地做到这一点。</p><p id="3f73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为它与我上两篇关于Bash和Python的文章的逻辑相同，所以我不会在功能方面做太深入的讨论。与Python上的文章一样，这篇文章将强调语法差异。</p><p id="3b55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，创建一个<code class="fe lw lx ly lz b">changelog.js</code>文件来运行脚本的逻辑。您可以通过运行<code class="fe lw lx ly lz b">chmod +x changelog.js</code>使该文件可执行。这样你就可以从命令行运行<code class="fe lw lx ly lz b">./changelog.js</code>,或者在另一个脚本中添加<code class="fe lw lx ly lz b">./changelog.js</code>来包含它。</p><p id="0db3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要我们的项目版本与我们的changelog同步。这可能是JavaScript代码中最复杂的部分。您可以做两件事之一:</p><ol class=""><li id="b270" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">找到一个可以用来在JavaScript文件中执行<code class="fe lw lx ly lz b">git describe --long</code>的包(可能类似于<a class="ae ky" href="https://www.npmjs.com/package/git-describe/v/2.0.0" rel="noopener ugc nofollow" target="_blank">这个</a>)。</li><li id="2d3e" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">做一个纯粹主义者，用你自己的代码来做所有的事情！如果这是你要去的路线，我们有几个步骤。</li></ol><p id="019d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们必须<code class="fe lw lx ly lz b">require</code>所谓的<code class="fe lw lx ly lz b">child_process</code>，然后在那个子进程上运行<code class="fe lw lx ly lz b">exec</code>。<a class="ae ky" href="https://www.javatpoint.com/nodejs-child-process" rel="noopener ugc nofollow" target="_blank">这个方法</a>允许我们在控制台中运行命令并缓冲输出。这是我们的第一行代码。</p><pre class="kj kk kl km gt mo lz mp mq aw mr bi"><span id="9640" class="ms mt it lz b gy mu mv l mw mx">const exec = require('child_process').exec;</span></pre><p id="598c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要编写一个函数，运行一个接受<code class="fe lw lx ly lz b">"git describe --long"</code>作为参数的子执行，以及一个回调函数。下面是我们的函数。</p><pre class="kj kk kl km gt mo lz mp mq aw mr bi"><span id="64bd" class="ms mt it lz b gy mu mv l mw mx">const result = (command, cb) =&gt; {<br/>  var child = exec(command, (err, stdout, stderr) =&gt; {<br/>    if(err != null){<br/>      return cb(new Error(err), null);<br/>    }else if(typeof(stderr) != "string"){<br/>      return cb(new Error(stderr), null);<br/>    }else{<br/>      return cb(null, stdout);<br/>   }<br/>  });<br/>  return child<br/>}</span></pre><p id="7ed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这基本上是一个包装器，它将执行传递的命令和回调函数。这个包装器还提供了初步的错误处理。我们剩下要做的就是编写一个实际执行这个序列并处理结果的函数。我们称这个函数为<code class="fe lw lx ly lz b">getTaggedVersion</code>。</p><p id="1fff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是代码。</p><pre class="kj kk kl km gt mo lz mp mq aw mr bi"><span id="3a4d" class="ms mt it lz b gy mu mv l mw mx">const getTaggedVersion = () =&gt; {<br/>  result("git describe --long", (err, response) =&gt; {<br/>    if(!err){ <br/>      console.log(response);<br/>    }else {<br/>      console.log(err);<br/>    }<br/>  });<br/>}</span></pre><p id="7afa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有点复杂，但是它可以让您不必安装和配置依赖项！现在，到我们的脚本的其余部分。</p><p id="91c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lw lx ly lz b">changelog.js</code>中有我们使用字符串插值的地方。这在JavaScript中的实现方式与在Bash或Python中略有不同。Bash字符串插值见下文。</p><pre class="kj kk kl km gt mo lz mp mq aw mr bi"><span id="349b" class="ms mt it lz b gy mu mv l mw mx">name="Matthew Croak"<br/>introduction="My name is $name"<br/>echo $introduction<br/>&gt; "My name is Matthew"</span></pre><p id="974b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这里是JavaScript的字符串插值。</p><pre class="kj kk kl km gt mo lz mp mq aw mr bi"><span id="ba8a" class="ms mt it lz b gy mu mv l mw mx">name="Matthew Croak"<br/>introduction=`My name is ${name}`<br/>console.log(introduction)<br/>&gt; "My name is Matthew"</span></pre><p id="1622" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字符串插值对脚本很重要，因为我们将从提供的字符串写入和重写changelog文件。这些字符串将包含更新的信息，例如今天的日期和包的版本。</p><p id="9862" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们写我们的<code class="fe lw lx ly lz b">init</code>函数。这个函数将被用来决定我们是否想要创建一个新的changelog或者简单地更新一个现有的。在JavaScript中，<code class="fe lw lx ly lz b"><a class="ae ky" href="https://nodejs.dev/learn/the-nodejs-fs-module" rel="noopener ugc nofollow" target="_blank">fs</a></code> <a class="ae ky" href="https://nodejs.dev/learn/the-nodejs-fs-module" rel="noopener ugc nofollow" target="_blank">模块</a>使得文件处理相对简单。我们可以从<code class="fe lw lx ly lz b">fs</code>模块导入<code class="fe lw lx ly lz b">existsSync</code>并检查提供的路径是否存在。见下文。</p><pre class="kj kk kl km gt mo lz mp mq aw mr bi"><span id="4efc" class="ms mt it lz b gy mu mv l mw mx">const {existsSync} = require('fs');<br/>const path = './CHANGELOG.md'</span><span id="b511" class="ms mt it lz b gy my mv l mw mx">const init = () =&gt;{<br/>  try {<br/>    if (existsSync(path)) {<br/>      newChangelogItem()<br/>    } else {<br/>      newChangelog()<br/>    }<br/>  } catch (err){<br/>    console.log(err)<br/>  }<br/>}</span></pre><p id="5959" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们回顾一下如何读写我们的changelog文件。在Bash中，您可以这样读取文件:</p><pre class="kj kk kl km gt mo lz mp mq aw mr bi"><span id="962c" class="ms mt it lz b gy mu mv l mw mx">while read line; do           <br/>  # code performed for each line<br/>done &lt; CHANGELOG.md</span></pre><p id="0b8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，我们使用<code class="fe lw lx ly lz b">readFileSync</code>到<em class="lv">读取</em>提供的文件，使用<code class="fe lw lx ly lz b">writeFileSync</code>到<em class="lv">将</em>写入提供的文件。这两种功能都由<code class="fe lw lx ly lz b">fs</code>模块提供。<code class="fe lw lx ly lz b">readFileSync</code>将获取一个提供的文件，并将其转换为字符串。然后，我们可以获取这个字符串，并在每一个新行中使用<code class="fe lw lx ly lz b">split</code>(<code class="fe lw lx ly lz b">/n</code>)。</p><p id="683a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们可以创建一个要迭代的行数组。见下文。</p><pre class="kj kk kl km gt mo lz mp mq aw mr bi"><span id="f95e" class="ms mt it lz b gy mu mv l mw mx">const fileData = readFileSync("CHANGELOG.md", { encoding: "utf8" });<br/>const fileDataArray = fileData.split("\n");</span></pre><p id="9ecf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">writeFileSync</code>看起来很相似，但是它需要一个额外的参数(在文件名和编码数据之间)。第三个参数是提供的将被写入文件的字符串。见下文。</p><pre class="kj kk kl km gt mo lz mp mq aw mr bi"><span id="8265" class="ms mt it lz b gy mu mv l mw mx">writeFileSync("CHANGELOG.md", newFileData, { encoding: "utf8" });</span></pre><p id="fae2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续讨论<code class="fe lw lx ly lz b">readAsync</code>和<code class="fe lw lx ly lz b">writeAsync</code>之前，让我们再看一遍<code class="fe lw lx ly lz b">fs</code>模块提供的功能:<code class="fe lw lx ly lz b">appendFile</code>。</p><p id="5947" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顾名思义，我们可以使用<code class="fe lw lx ly lz b">appendFile</code>将文件数据追加到文件中。通过提供文件名、文件数据(字符串形式)和回调函数，我们可以轻松地创建changelog文件。见下文。</p><pre class="kj kk kl km gt mo lz mp mq aw mr bi"><span id="d5b8" class="ms mt it lz b gy mu mv l mw mx">const newChangelog = () =&gt; {<br/>  appendFile("CHANGELOG.md", changelogStart, (err) =&gt; {<br/>    if (err) throw err;<br/>    console.log('Changelog is created successfully.');<br/>  })<br/>}</span></pre><p id="6f0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数将创建一个新文件(<code class="fe lw lx ly lz b">CHANGELOG.md</code>)，用<code class="fe lw lx ly lz b">changelogStart</code>(在<a class="ae ky" href="https://github.com/macro6461/changelog-js/blob/main/changelog.js" rel="noopener ugc nofollow" target="_blank"> Github </a>上的changelog.js文件中可用的字符串)填充它。现在我们已经创建了将为我们创建一个changelog的函数，如果它不存在，我们可以继续使用我们的函数向现有的changelog添加一个新的changelog项目！</p><p id="77dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在我们进入行插入代码之前，让我们看看我们需要什么代码来确定我们<em class="lv">是否应该</em>添加一个项目。记住，我们的变更日志条目对应于一个项目版本<em class="lv">和</em>日期。如果我们已经有一个当前版本和日期的changelog项目，我们不需要创建一个新的。</p><p id="f867" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们将用来检查我们是否需要一个新项目的代码。</p><pre class="kj kk kl km gt mo lz mp mq aw mr bi"><span id="47ac" class="ms mt it lz b gy mu mv l mw mx">const newChangelogItem = () =&gt; {<br/>  if (checkIfItemExists(item)){<br/>    console.log(`Changelog item already exists for \n   ${item}`)<br/>  } else {<br/>    writeChangelog()<br/>  }<br/>}</span></pre><p id="be65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们一会儿会讲到<code class="fe lw lx ly lz b">writeChangelog</code>，但首先，这里是<code class="fe lw lx ly lz b">checkIfItemExists</code>。</p><pre class="kj kk kl km gt mo lz mp mq aw mr bi"><span id="0326" class="ms mt it lz b gy mu mv l mw mx">const checkIfItemExists = (str) =&gt; {<br/>  const contents = readFileSync('CHANGELOG.md', 'utf-8');<br/>  return contents.indexOf(str) &gt; -1;<br/>}</span></pre><p id="ec68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该功能利用了<code class="fe lw lx ly lz b">readFileAsync</code>。这将生成一个字符串版本的changelog。一旦它是一个字符串，我们可以使用检查我们的changelog项目的索引。如果它大于-1，那么它存在，我们不需要添加一个新的。否则，添加一个新的。简单，不是吗？</p><p id="819a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们正在处理是否可以/应该添加一个新的changelog条目，那么让我们来看看如何实际添加一个。为此，我们将利用<code class="fe lw lx ly lz b">readFileAsync</code>和<code class="fe lw lx ly lz b">writeFileAsync</code>。我们将把我们的文件转换成一个行的数组(如前所述)，然后迭代这个数组。在迭代我们的代码行时，我们寻找将要插入新项目的代码行。这条线用<code class="fe lw lx ly lz b">"## [Unreleased]"</code>表示。</p><p id="ab37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以再次使用<code class="fe lw lx ly lz b">indexOf</code>来检查这一点。如果<code class="fe lw lx ly lz b">fileDataArray[i].indexOf(“## [Unreleased]”) &gt; -1</code>那么我们知道<em class="lv">那</em>就是我们插入项目的那一行。如何在JavaScript中插入我们的项目？利用<code class="fe lw lx ly lz b">splice</code>。</p><p id="d50c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">允许我们在数组中添加新的元素来代替现有的元素。我们可以简单地在我们的第<code class="fe lw lx ly lz b">“## [Unreleased]”</code>行之后<code class="fe lw lx ly lz b">splice</code>我们的新项目到我们的数组中。见下文。</p><pre class="kj kk kl km gt mo lz mp mq aw mr bi"><span id="58c6" class="ms mt it lz b gy mu mv l mw mx">iterateArr = [...fileDataArray)<br/>for (var i = 0; i &lt; iterateArr.length; i++){<br/>  if (fileDataArray[i].indexOf("## [Unreleased]") &gt; -1){<br/>    fileDataArray.splice(i + 1, 0, `\n${item}\n### Added\n- ADD CHANGE HERE!`)<br/>     const newFileData = fileDataArray.join("\n");<br/>     writeFileSync("CHANGELOG.md", newFileData, { encoding: "utf8" })<br/>     break<br/>  }<br/>}</span></pre><p id="1f6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用扩展运算符从<code class="fe lw lx ly lz b">fileDataArray</code>创建<code class="fe lw lx ly lz b">iterateArr</code>。我们这样做是因为我们不想迭代我们正在操作的数组。一旦我们把新的条目放到了行的数组中，我们就可以把它们放到一个字符串中。然后我们可以将这个字符串提供给<code class="fe lw lx ly lz b">writeFileAsync</code>并将其写入我们的<code class="fe lw lx ly lz b">CHANGELOG.md</code>文件。</p><h2 id="8f6f" class="ms mt it bd mz na nb dn nc nd ne dp nf li ng nh ni lm nj nk nl lq nm nn no np bi translated">你应该用哪一个？</h2><p id="876e" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">假设这一代changelog现在支持Bash、Python和JavaScript，你应该使用哪一个？我个人觉得Python是首选。我觉得Bash的学习曲线比Python宽一点(至少对我来说)，虽然Bash的代码行更少，但我在调试方面更加努力。</p><p id="2a1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript是我的首选语言(我有偏见，因为我多年来一直专业地使用JavaScript)，但是对于这个用例，我发现我必须编写更多的配置代码。虽然<code class="fe lw lx ly lz b">fs</code>模块为文件管理和操作提供了大量内置逻辑，但我不得不编写单独的函数来支持git命令的执行<em class="lv">和</em>，我发现为了开始遍历文件并添加文本，还需要更多的步骤。</p><p id="9a4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你是一个JavaScripter爱好者(？)现在，您已经有了一个<em class="lv">纯</em>脚本，可以整合到您的应用程序中来生成一个变更日志<em class="lv">和</em>添加变更日志项目。它还在格式和变更日志内容方面为您提供了灵活性<em class="lv">而不需要</em>生成器、日志或其他依赖项。</p><p id="6140" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整代码在<a class="ae ky" href="https://github.com/macro6461/changelog-js" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="4f68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://matt-croak.medium.com/membership" rel="noopener"> <strong class="lb iu"> <em class="lv">升级您的免费Medium会员资格</em> </strong> </a> <em class="lv">并接收各种出版物上数千名作家的无限量、无广告的故事。这是一个附属链接，你的会员资格的一部分帮助我为我创造的内容获得奖励。</em></p><p id="69a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">您也可以通过电子邮件</em>   <em class="lv">订阅，每当我发布新内容时，您都会收到通知！</em></p><p id="2525" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢你！</p><h1 id="d309" class="oc mt it bd mz od oe of nc og oh oi nf jz oj ka ni kc ok kd nl kf ol kg no om bi translated">参考</h1><p id="18d9" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-write-a-bash-script-to-create-and-update-a-changelog-de4df98985ab">如何编写Bash脚本来创建和更新变更日志</a></p><p id="7354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/macro6461/changelog-python" rel="noopener ugc nofollow" target="_blank">GitHub—macro 6461/changelog-python:生成并更新变更日志的Python脚本</a></p><p id="e4bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/macro6461/changelog-bash" rel="noopener ugc nofollow" target="_blank">GitHub—macro 6461/changelog-bash:生成和添加changelog项目的纯bash脚本</a></p><p id="ae32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.npmjs.com/package/git-describe/v/2.0.0" rel="noopener ugc nofollow" target="_blank">git-描述</a></p><p id="d475" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.javatpoint.com/nodejs-child-process" rel="noopener ugc nofollow" target="_blank"> Node.js子进程—Java point</a></p><p id="19fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/macro6461/changelog-js/blob/main/changelog.js" rel="noopener ugc nofollow" target="_blank">主宏6461/changelog-js处的changelog-js/changelog . js</a></p><p id="6994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" rel="noopener ugc nofollow" target="_blank">array . prototype . splice()—JavaScript | MDN</a></p><p id="0298" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/macro6461/changelog-js" rel="noopener ugc nofollow" target="_blank">GitHub—macro 6461/changelog-js:用于生成和更新变更日志的JavaScript代码</a></p></div></div>    
</body>
</html>