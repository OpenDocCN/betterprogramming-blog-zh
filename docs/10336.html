<html>
<head>
<title>Visualizing Big O Notation in 12 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在12分钟内可视化大O符号</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/visualizing-big-o-notation-in-12-minutes-e221fc4cd2e3?source=collection_archive---------3-----------------------#2021-12-29">https://betterprogramming.pub/visualizing-big-o-notation-in-12-minutes-e221fc4cd2e3?source=collection_archive---------3-----------------------#2021-12-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="15c8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们从不同的角度来看一下BigO符号</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/10cd7da36c7fe203167f5a768d21ac20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8Kb5gbwaXWKP77uY"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@julienk53?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历山大·巴甫洛夫·赫罗夫卡</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9d17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我真的相信，如果你从最基本的开始，没有什么是你学不到的。</p><p id="a74a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你把正确的资源和学习的意愿结合起来，没有什么能阻挡你和你的梦想。</p><p id="c592" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我想通过解释BigO符号这样一个非常重要的概念来为社区做出一点小小的贡献，使用一些可视化的功能和我的数学背景来帮助大家更好地理解这个主题。</p><p id="d8e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从定义开始:</p><blockquote class="ls lt lu"><p id="8f1f" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">大O符号是一种<strong class="ky ir">数学符号</strong>，它描述了当自变量趋向某个特定值或无穷大时函数的极限行为。</p></blockquote><p id="ad4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们如何理解呢？</p><p id="ac50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在计算机科学中，解决一个问题几乎总是有几种方法。作为软件工程师，我们的工作是找到最有效的解决方案并实现它。但是它到底是什么意思呢？这是最快的方法吗？是那个比其他的占空间小的吗？其实看情况。这纯粹与你的特殊问题有关。如果您在内存有限的嵌入式系统中工作，例如，如果问题是计算在微波炉中解冻200克肉所需的功率(瓦特),您可以将一种内存效率更高、需要1秒来进行计算的算法转换为另一种以毫秒为单位进行计算但需要更多内存的算法。毕竟，即使启动需要几毫秒，除霜过程本身也需要10到15分钟。</p><p id="7437" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们讨论将导弹锁定在目标飞机上的算法，很明显我们在这里处理的是毫秒级的，可以牺牲内存消耗。这架飞机足够大，可以为更多的内存插槽留出空间。</p><blockquote class="ls lt lu"><p id="f138" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">一般来说，软件工程是关于权衡的。一个好的软件工程师必须意识到需求并提出解决方案来满足它们。</p></blockquote><p id="1f03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">说了这么多，现在可以理解的是，我们需要以某种方式量化和测量任何算法的性能和内存含义。一种方法是看看一个算法需要多少秒来完成。这可以提供一些价值，但问题是，如果我的搜索算法在有1000个项目的笔记本电脑上需要2到3秒，那么在另一台更强大的笔记本电脑上可能需要更少的时间，对吗？即使我们同意以我的笔记本电脑的性能为基础，我们也不知道当阵列的规模翻倍时会发生什么？当数组的大小趋于无穷大时会发生什么？</p><p id="243b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了回答这些问题，我们需要一个独立于机器的测量，它可以告诉我们当输入的大小越来越大时，我们的算法会发生什么。这里是BigO符号。</p><p id="5359" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">BigO旨在找出在给定任意大小输入的最坏情况下需要执行多少操作。它旨在发现当规模越来越大时，算法的运算次数的极限是多少。BigO分为时间和空间复杂度分析。对于每一个算法，你可以通过简单地计算你在给定的数据结构上执行的辅助操作的数量来计算它的时间复杂度。</p><p id="f2f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你将一个包含10个元素的数组复制到另一个数组中，那么你需要遍历整个数组，这意味着10次操作。在BigO符号中表示为O(N ),其中N是输入数组的大小。这个例子的空间复杂度也是O(N ),因为您将为复制的数组分配更多的内存。</p><p id="930e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">BigO所做的是给你一个数学函数，当输入变大时，它纯粹专注于寻找你需要执行的操作数量的极限。例如，如果您使用线性搜索在给定列表中搜索数字5。然后在最坏的情况下，这个数字将在列表的末尾，但是因为你将从头开始迭代，你将需要执行和输入数字一样多的查找操作。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="fd6e" class="me mf iq ma b gy mg mh l mi mj">[1, 2, 3, 4, <strong class="ma ir"><em class="lv">5</em></strong>]  # you will perform 5 operations here to find it</span></pre><p id="3ce2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我想在术语<strong class="ky ir"> <em class="lv">最坏情况</em> </strong>上停留片刻。如果你想一想，所需的数字有可能在列表的开头，在这种情况下，你将只执行1次操作。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="9a94" class="me mf iq ma b gy mg mh l mi mj">[<strong class="ma ir"><em class="lv">5</em></strong>, 1, 2, 3, 4]  # you will perform only one operation in this case</span></pre><p id="bd56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题是，我们不能考虑最好的情况，并希望它在大多数情况下都会发生，因为这样我们就无法比较不同的算法。在BigO符号的上下文中，我们总是对最坏的情况感兴趣(有一些例外，比如哈希映射，稍后会详细介绍)。</p><p id="d8f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我之前说过，BigO给了你一个数学函数，重点是求运算次数的极限。当我们谈论数学中的极限时，我们不能只谈论它们而没有任何形象化。这非常有助于理解函数在输入大小趋于无穷大时的趋势。让我们通过一个例子来逐一分析一些非常常见的BigO符号。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="5a31" class="mr mf iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">O(1)常数时间</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/d876bd8df1a7b39849441c676cfa63e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*nvyprGekNX-FMivfSVCrRw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">O(1)</p></figure><p id="5a81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以理解，这是一个算法可以拥有的最好的BigO符号。当您想要执行某个操作，并且只需一次操作即可完成时。让我们看一个使用python的例子:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="6ce5" class="me mf iq ma b gy mg mh l mi mj">country_phone_code_map = {<br/>    'Albania': '+355',<br/>    'Algeria': '+213',<br/>    'American Samoa': '+684',<br/>}<br/>country = 'Albania'<br/><strong class="ma ir">print(country_phone_code_map[country])  # 1 operation</strong><br/>&gt;&gt;&gt; '+355'</span></pre><p id="3124" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在python中，如果你想在字典中查找一个条目，那么这个操作的时间复杂度是O(1)。python中的Dict类似于其他语言中的HashMap。</p><p id="c44b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">确切地说，最坏的情况是O(N ),这与数据结构实现的好坏有关。哈希函数在这里起着关键作用，但是一般来说，字典查找的BigO是O(1)。如果你在一次编码面试中，你可以假设它是O(1)。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="3223" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在计算BigO时，我想在另一个非常重要的话题上停下来。<strong class="ky ir">常数</strong>。您可能熟悉也可能不熟悉在计算BigO时忽略常数。我不希望你只是把这当成一个规律去接受，而不去思考背后的原因。</p><p id="0cf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这正是我将BigO符号可视化的原因。因此，让我们假设在上面的例子中，我们还需要通过获得国家名称来获得3个和2个字母的国家代码。这意味着我们有一些其他的2和3个字母的国家代码的映射，我们只需要在同一个函数中再执行2次操作。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="0440" class="me mf iq ma b gy mg mh l mi mj">country_phone_code_map = {<br/>    'Albania': '+355',<br/>    'Algeria': '+213',<br/>}<br/>country_2_letter_code_map = {<br/>    'Albania': 'AL',<br/>    'Algeria': 'DZ',<br/>}<br/>country_3_letter_code_map = {<br/>    'Albania': 'ALB',<br/>    'Algeria': 'DZA',<br/>}<br/>country = 'Albania'<br/><br/><strong class="ma ir">phone_code = country_phone_code_map[country]  # 1 operation<br/>two_letter_code = country_2_letter_code_map[country]  # 1 operation<br/>three_letter_code = country_3_letter_code_map[country]  # 1 operation</strong></span></pre><p id="3b1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们继续像之前说好的那样计算手术次数。在这里，我们将有3个运算使BigO = O(3)正确？</p><p id="2c33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们想象一下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/e58427137e7608f83aa91aadd647bcc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*-28HgvQH9BJu4f2Wp3J96w.png"/></div></figure><p id="29dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，操作数量增加了3。这意味着我们实际上执行了不止一个操作来完成这个任务。但是，BigO说，如果有常量，就忽略它们。所以O(3)或O(2n)或O(2n + 1)将分别为O(1)，O(n)，O(n)。</p><p id="893b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为我们感兴趣的是当N趋于无穷大时函数的极限，而不是它将执行多少次运算。我们并不计算运算的次数，相反，我们感兴趣的是，当N趋于无穷大时，运算的次数将如何增长。你可能会想，是的，但是使用<code class="fe nk nl nm ma b">O(1000n)</code>的算法比使用O(n)的算法要慢，所以我们需要考虑1000，我们不能忽略它。这是真的，但这个数字1000是一个常数，它不会随着N的增大而增大。即使N是10，它仍然是1000，即使N是1B，它仍然是1000。所以它没有给我们提供任何关于函数极限的有价值的信息。唯一重要的部分是O(n ),它告诉我们，你增加的越多，你就要执行越多的操作来完成任务。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="e47d" class="mr mf iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">O(logn)对数时间</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/f6f139a7ba2d9078171ad785a96d856a.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*i2kIz49tpzcyLeAG2l1BOQ.png"/></div></figure><p id="4a5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种符号通常与分而治之的搜索算法结合在一起。如果我们在一个有序的数组中寻找一个数字，我们可以使用最基本的算法，二分搜索法。该算法将在每次运算时将数组一分为二，并且需要log(n)次运算才能找到该数。<a class="ae kv" href="https://www.cs.usfca.edu/~galles/visualization/Search.html" rel="noopener ugc nofollow" target="_blank">这里的</a>是一个很好的可视化这个算法的工具。</p><blockquote class="ls lt lu"><p id="e083" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">这里很重要的一点是，当我们在计算机科学中谈论对数而不指定底数时，我们总是谈论底数为2的T2对数。在数学中，我们习惯于以10为底的对数，但在计算机科学中却不同。在处理复杂性分析时，请记住这一点。</p></blockquote><p id="c320" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上图可以看出，这其实是一个非常好的时间复杂度。用简单的英语来说，复杂度为O(logn)意味着每次输入的大小加倍时，我们只需要再进行一次迭代就可以完成任务。当N大约为100万时，我们只需要执行20次运算，而当它达到10亿左右时，我们只需要执行30次运算。可以看到时间复杂度为O(logn)的算法的强大之处。对于N的如此巨大的增加，我们只需要再进行10次运算。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="8f1b" class="mr mf iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">O(N)线性时间</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/29da308d5e79395323efe9287b5e09de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*jK0wJjUqlIWTohCk0atGtA.png"/></div></figure><p id="878d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，当N趋于无穷大时，运算次数也趋于无穷大，速率与N相同。一个例子是我们之前讨论过的线性搜索。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="3c2b" class="me mf iq ma b gy mg mh l mi mj">array = [1, 2, 3, 4, 5]<br/>number = 5<br/>for index, item in enumerate(array):  <strong class="ma ir"># loop n times</strong><br/>    if item == number:  <strong class="ma ir"># check for equality</strong><br/>        print(f'Found item at {index=}')<br/>        break<br/>        <br/>&gt;&gt;&gt; Found item at index=4</span></pre></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="6d02" class="mr mf iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">O(NlogN)对数线性时间</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/1c88927952a89bf36dbf875a864a4f00.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*mFf0hHKYyYR92TmXk2VyiA.png"/></div></figure><p id="c40e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种符号通常与排序算法结合在一起。看看这个用于合并排序的<a class="ae kv" href="https://www.hackerearth.com/practice/algorithms/sorting/merge-sort/visualize/" rel="noopener ugc nofollow" target="_blank">可视化</a>。Merge sort将数组分成O(logn)的两半，用O(n)的线性时间来合并分开的数组。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="dedb" class="mr mf iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">O(N)次时间</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/9ddd2b4cf8af0d22095e392e419bef8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*khFRdR-2CBC0h5X5FAc0SQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">注意1e6在操作轴的数量</p></figure><p id="7a25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常是带有嵌套循环的算法。例如一个强力排序算法，在两个嵌套的<strong class="ky ir">for循环中遍历整个数组。冒泡排序就是一个例子:</strong></p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="f7be" class="me mf iq ma b gy mg mh l mi mj">def <strong class="ma ir">bubble_sort</strong>(data):<br/>    for _ in range(len(data)):  <strong class="ma ir"># O(n)</strong><br/>        for i in range(len(data) - 1):  <strong class="ma ir"># nested O(n)</strong><br/><br/>            if data[i] &gt; data[i + 1]:<br/>                data[i], data[i + 1] = data[i + 1], data[i]<br/>    return data</span></pre><p id="3493" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于第二个循环是嵌套的，我们将把它的复杂性乘以第一个循环的复杂性。即O(n) * O(n) = O(n)</p><blockquote class="ls lt lu"><p id="2dac" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">如果第二个循环在第一个循环之外，我们将对它们求和而不是相乘，因为在这种情况下，第二个循环不会像第一个循环那样重复很多次。</p></blockquote></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="87d2" class="mr mf iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">立方时间</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/bb8623032cf3af7a7066cfd5df878a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*yFUgI2_x0jnMiG5JgfvgWQ.png"/></div></figure><p id="764b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最简单的例子是一个有3个嵌套for循环的算法。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="1c7a" class="me mf iq ma b gy mg mh l mi mj">for i in range(len(array)):  <strong class="ma ir"># O(n)</strong><br/>    for j in range(len(array)):  <strong class="ma ir"># O(n)</strong><br/>        for p in range(len(array)):  <strong class="ma ir"># O(n)</strong><br/>            print(i, j, p)</span></pre><p id="b8b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你直接应用矩阵乘法的数学定义，那么你将得到一个时间为立方的算法。这个任务有一些改进的算法，看看<a class="ae kv" href="https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="cdc6" class="mr mf iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">O(2^N)指数时间</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/db05962f0bfc9b307b1258cf77b770e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*_oJu4bAnsNbln5FJ_Z4w4Q.png"/></div></figure><p id="cd1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种表示法最著名的例子是用递归方法找到第n个斐波那契数。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="d298" class="me mf iq ma b gy mg mh l mi mj">def nth_fibonacci(n: int) -&gt; int:<br/>    if n in [1, 2]:<br/>        return 1<br/><br/>    return nth_fibonacci(n - 1) + nth_fibonacci(n - 2)</span></pre></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="23ab" class="mr mf iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">O(N！)阶乘时间</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/9d15955fa3370a34dd6ac6bf9c277771.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*X00B6j_wIccv_u4TXxsw4w.png"/></div></figure><p id="ce96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这方面的一个例子是生成一个列表的所有排列。看一看<a class="ae kv" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" rel="noopener ugc nofollow" target="_blank">旅行推销员问题。</a></p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="c20a" class="mr mf iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">取最重要的因素</h1><p id="f4e9" class="pw-post-body-paragraph kw kx iq ky b kz nu jr lb lc nv ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">我们已经讨论过在计算一个算法的复杂度时去掉常数，因为它们不能给我们提供任何值。关于这条规则还有更多东西。当执行复杂性分析时，我们可以得到一个对给定的输入执行不止一种操作的算法。例如，我们可能需要一些函数来对一个数组进行初始排序，然后对其进行搜索。让我们假设这将是一个复杂度为O(NlogN)的排序操作加上另一个复杂度为O(logN)的搜索操作。</p><p id="9fa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种函数的时间复杂度将是O(NlogN) + O(logN)。让我们想象一下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/33ac0917ca824917713e5a35ae247f3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*G46XmMUtJM5_J4_LDJYChg.png"/></div></figure><p id="f49f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你看一下这个图，你会注意到O(NlogN)的影响大于O(logN)的影响，因为这个图更类似于O(NlogN)而不是O(logN)。我们甚至可以用数学方法证明这一点。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="a885" class="me mf iq ma b gy mg mh l mi mj">O(NlogN) + O(logN) = O((N+1)logN)  # factorize<br/>O((N+1)logN) = O(NlogN)  # drop constant 1</span></pre><p id="7223" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，它们彼此相对接近，差异不明显但如果我们再举一个像O(N！+ N + N + N)我们会注意到N以外的符号的影响！和N比起来实在是太小了！当N变得过大时！</p><p id="e5c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以很容易地计算出1 000 000的^ 3，但尝试同样的1 000 000阶乘。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/6563777d9b5df0cc193abf1b63ef83e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*bu3VSXUeWEDoPteIU8-vLA.png"/></div></figure><blockquote class="ls lt lu"><p id="9bc1" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">10的阶乘是3 628 800，而10只是1000。如你所见，与N相比，N的影响是如此之小！我们可以忽略它。这就是为什么当我们有多个符号时，我们选择最重要的因素。</p></blockquote><p id="7495" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在选择最重要的因素时，有一点非常重要，那就是我们根据输入对因素进行分组。这意味着，如果我们有一个算法在两个不同的数组上操作，一个大小为N，一个大小为M，算法的复杂度是O(N + N + M + M ),那么我们不能说最高因子是M，所以复杂度是O(M)。这是不正确的，因为它们在我们的函数中是完全独立的变量。我们的算法依赖于这两个变量，所以正确的做法是取出这两个变量的最高因子。我们消去N是因为N更高，消去M是因为M更高，结果是O(N + M)。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="fcae" class="mr mf iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">结论</h1><p id="f0e2" class="pw-post-body-paragraph kw kx iq ky b kz nu jr lb lc nv ju le lf nw lh li lj nx ll lm ln ny lp lq lr ij bi translated">如果你想深入学习算法和数据结构，那么你需要质疑一切。不要认为任何规则都是理所当然的。向他们提问，并试图找到答案。可视化对于理解复杂算法有着巨大的影响。不要忘记，你学习这些主题不是为了通过一些编码面试，而是为了让自己成为一名更好的工程师。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="369a" class="mr mf iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">参考</h1><ul class=""><li id="b51e" class="ob oc iq ky b kz nu lc nv lf od lj oe ln of lr og oh oi oj bi translated">我的Jupyter笔记本用于可视化</li><li id="de9e" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr og oh oi oj bi translated"><a class="ae kv" href="https://github.com/klement97/algorithms" rel="noopener ugc nofollow" target="_blank">我的Github repo on算法</a></li><li id="0805" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr og oh oi oj bi translated"><a class="ae kv" href="https://www.cs.usfca.edu/~galles/visualization/Search.html" rel="noopener ugc nofollow" target="_blank">二分搜索法可视化</a></li><li id="9557" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr og oh oi oj bi translated"><a class="ae kv" href="https://www.hackerearth.com/practice/algorithms/sorting/merge-sort/visualize/" rel="noopener ugc nofollow" target="_blank">合并排序可视化</a></li><li id="84d9" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr og oh oi oj bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm" rel="noopener ugc nofollow" target="_blank">矩阵乘法</a></li><li id="0035" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr og oh oi oj bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" rel="noopener ugc nofollow" target="_blank">旅行推销员问题</a></li></ul></div></div>    
</body>
</html>