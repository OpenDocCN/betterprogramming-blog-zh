<html>
<head>
<title>Unity Production Patterns: Consistent Association With Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">统一生产模式:与仿制药的一致关联</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unity-production-patterns-consistent-association-with-templates-e90af258e503?source=collection_archive---------25-----------------------#2022-04-12">https://betterprogramming.pub/unity-production-patterns-consistent-association-with-templates-e90af258e503?source=collection_archive---------25-----------------------#2022-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6b67" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看看有缺陷的方法和更好的解决方案</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8e1bb1926e598dc6bc997e51f92372ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1S_s-7dhAbIBrxeYUVfRSA.png"/></div></div></figure><p id="6fa3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在使用Unity开发时，经常会遇到这样的情况，您希望在两个或更多类型的孩子之间建立一对一的关系。如果有什么不同的话，这是很多应用程序中非常常见的情况。</p><p id="a54d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，在一个每张牌都召唤一个怪物的纸牌游戏中，每种类型的牌都可以与特定类型的怪物相关联。每次我们玩一个<code class="fe ln lo lp lq b">DragonCard</code>，它就会召唤一条龙。</p><p id="55e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我们将为第一个(例如<code class="fe ln lo lp lq b">Card</code>)的每种类型实现一个子类，并为第二个(例如<code class="fe ln lo lp lq b">Monster</code>)的每种类型实现一个子类，我们将学习如何使它们显式关联，以及这如何有助于创建健壮的设置和干净的、可调试的、可扩展的产品代码。</p><p id="6552" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从一个更简单的方法的变体开始，看看为什么这个模式可以帮助我们清理我们的实现。<br/>假设每个<code class="fe ln lo lp lq b">Enemy</code>类型都与一个<code class="fe ln lo lp lq b">EnemyAnimator</code>引用相关联。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><h1 id="0872" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">糟糕的生产方法#1</h1><p id="ff9c" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">我经常看到的一种常见方法是为敌人职业的每个孩子设置一个序列化的字段，该字段对应于所需的敌人类型。(有时根本没有基类，每个孩子都将完全独立地工作)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><h2 id="9bcc" class="mq lu iq bd lv mr ms dn lz mt mu dp md la mv mw mf le mx my mh li mz na mj nb bi translated">为什么这样不好？</h2><p id="2d37" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">这种结构在短期内可能看起来不错，但从长期来看，实际上可能会降低产量，原因有很多。</p><p id="338d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，你没有建立任何规则。所以当和别人一起工作时(包括来自未来的你)..他们可能想要添加一个新的敌人类型，但是不知道(或者完全忘记)任何想要的架构。所以他们可能会创建一个新的不继承EnemyAnimator的动画类。当你没有建立结构的时候，这个<em class="nc">确实会发生很多次</em>。</p><p id="cdaa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将导致更多的非通用错误，使您的代码更难调试和跟踪，更难理解或扩展。</p><p id="e36c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你也没有很好地利用继承。如果你能访问任何敌方引用的动画，那么你就能有更多的通用基类逻辑，这将节省你在子类中的重复代码。</p><p id="e4b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，如果我们突然决定，当我们做某个动作时，需要立即停止并重置每一个灌肠剂，该怎么办？</p><h1 id="03bd" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">糟糕的(但不是非常糟糕的)生产方法#2</h1><p id="1674" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">我看到的另一种方法是在基类上有一个受保护的EnemyAnimator。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="51d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，任何一个<code class="fe ln lo lp lq b">Enemy</code>类的子类，比如说<code class="fe ln lo lp lq b">EnemyGoomba</code>，都有一个<code class="fe ln lo lp lq b">EnemyAnimator</code>引用，你可以通过检查器来设置它，并且你可以将它转换为<code class="fe ln lo lp lq b">EnemyAnimatorGoomba</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="00e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这实际上要好得多。但是，我们不应该在每个孩子身上都引用这个词。</p><p id="7b50" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是从我的经验来看，最大的问题可能是你现在可以将<code class="fe ln lo lp lq b">EnemyAnimatorGoomba</code>分配给<code class="fe ln lo lp lq b">EnemyKoopa</code>。如果你的游戏中会有很多敌人，特别是如果你和其他人一起创建预设的设置，你需要尽可能的清楚这些设置。而且拿任何<code class="fe ln lo lp lq b">EnemyAnimator</code>做参照物都太宽松了。当其他人看到<code class="fe ln lo lp lq b">EnemyAnimator</code>时，并不会告诉他们在设置过程中应该使用哪个脚本。减少设置中的混乱和事故总是值得的。</p><h1 id="1498" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">泛型方法</h1><p id="43cb" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">确保显式关联非常简单。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="fa88" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简单来说，我们可以使用泛型。这意味着每当我们实现一个新的<code class="fe ln lo lp lq b">enemy</code>类型时，我们必须给它一个继承自<code class="fe ln lo lp lq b">EnemyAnimator</code>的类，另一个继承自<code class="fe ln lo lp lq b">EnemyConfig</code>(这只是一个在三个类型之间创建关联的例子)。</p><p id="5b46" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从一个非普通的敌人基类中继承<code class="fe ln lo lp lq b">Enemy&lt;AT,CT&gt;</code>看起来没什么用，但是当我们想在某个地方有一个敌人数组时，这将变得很有用。</p><p id="09ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">仅此而已。我们的<code class="fe ln lo lp lq b">EnemyGoomba</code>类现在可以这样了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="018d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更少的代码，更高的设置一致性，以及编写通用逻辑的能力。这就是优秀建筑的回报。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><h1 id="cd82" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">传递公共参考</h1><p id="f815" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">这是我发现的另一个有用的模式，可以与前面提到的模式结合使用，以获得更高的一致性。</p><p id="ac8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用Unity时需要解决的一个非常常见的架构问题是:如何传递公共引用？例如，在播放过场动画时，你希望过场动画可以访问你的摄像机、视觉处理类、音频管理器，甚至你的播放器。</p><p id="7f49" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有两种常见的方法可以分配这些引用。</p><ol class=""><li id="e70c" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm ni nj nk nl bi translated"><strong class="kt ir">检查器分配</strong> — <strong class="kt ir"> </strong>最简单的方法是将检查器中的公共引用分配给每个需要它们的脚本。这有时是一种有效的方法，但在生产或更大的项目中通常是一个坏主意。很简单，因为在很多情况下，你会多次分配相同的引用。例如，这会增加设置场景的时间，并增加出错的几率。但也很没必要。</li><li id="eaf1" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated"><strong class="kt ir">参考抓取</strong> — <strong class="kt ir"> </strong>这包括有时使用<code class="fe ln lo lp lq b">GetComponent&lt;T&gt;</code>或<code class="fe ln lo lp lq b">GameObject.Find&lt;T&gt;()</code>。这会增加很多性能开销，尤其是在移动设备上。但是这样做的一个常见方法是将您的公共控制器类作为单件。这在很多情况下是非常可靠和现实的。</li></ol><p id="90f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第三种方式在某些情况下非常合适，那就是利用参数和泛型传递这些引用，提供脚本需要的精确引用。这只能在一个入口点初始化某种顶级游戏系统的层级中起作用，然后这个层级会使用参数来初始化其他功能。</p><p id="67c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意:这并不是在所有情况下都是最好的主意</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><h1 id="85ab" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="9a8a" class="nd ne iq kt b ku ml kx mm la nr le ns li nt lm nu nj nk nl bi translated">建立规则创造一致性</li><li id="859f" class="nd ne iq kt b ku nm kx nn la no le np li nq lm nu nj nk nl bi translated">将相关的类关联在一起明显减少了实现、调试或设置相关特性的痛苦</li><li id="7688" class="nd ne iq kt b ku nm kx nn la no le np li nq lm nu nj nk nl bi translated">诸如此类的模式只是帮助您更好地规划工作流的可用工具</li></ul></div></div>    
</body>
</html>