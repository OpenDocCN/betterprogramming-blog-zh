<html>
<head>
<title>Building a Sharded Application Using Akka Cluster Sharding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Akka集群分片构建分片应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-sharded-application-using-akka-cluster-sharding-ce2f34e54115?source=collection_archive---------8-----------------------#2022-10-27">https://betterprogramming.pub/building-sharded-application-using-akka-cluster-sharding-ce2f34e54115?source=collection_archive---------8-----------------------#2022-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6e2b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">OpenAPI工具+Spring+Bazel+Akka+Cassandra+Kubernetes</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0ebf7e8d94c2fff730dea9fcef34a858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FhK1aSxMTD8tAql1CFlN_g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@dianamia" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kw"> C达斯汀</strong> </a> <strong class="bd kw"> </strong>在<a class="ae kv" href="https://unsplash.com/photos/91AQt9p4Mo8" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="5313" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">到目前为止，分片作为一个概念主要用于数据库环境中。但是在本文中，我想让我们探讨用这种范式设计应用层的含义。</p><p id="c390" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">今天，我将尝试捕捉构建一个分片应用程序所需要的一些本质，所以不会讨论理论或基本的设计细节。因此，要了解应用层的分片是什么样子，请浏览这篇文章<a class="ae kv" href="http://thinkmicroservices.com/blog/2019/sharding.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="f265" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我将从API优先设计开始，并通过使用一些基础设施服务提供商部署应用程序的最后阶段来讲述我的方法。对于当今使用的任何技术，我既不是老手，也不自称是专家，所以对我说的一切要持保留态度。本文旨在从创建到运行时维护的各种技术的角度，为编写分片微服务提供一个起点或基本框架。</p><p id="3551" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">作为一个例子，我们将构建一个键值缓存服务，它使用Akka集群分片对应用程序级存储进行分片。</p><p id="859a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是我们正在构建的图形表示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/dd3bc59f5904a3ee1e8eac3dfee9f8dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-H03B1IbGEBrcbVZJSEAbw.jpeg"/></div></div></figure><p id="945a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们来看看各个阶段的时间顺序，以及开发这样一个微服务并在以后部署它需要做些什么:</p><ol class=""><li id="3a79" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated">API层设计，通过消费OAS 3.0，使用OpenAPI代码生成器生成Spring控制器代码</li><li id="ea54" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">通过Bazel构建和执行我们的应用程序。</li><li id="ceca" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">应用层设计:我们将使用Akka集群分片合并我们的业务逻辑(即KV缓存逻辑)，其中我们将利用Cassandra作为后备存储。</li><li id="77cb" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">使用Docker实现应用程序的容器化。</li><li id="fc04" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">通过数字海洋在K8s集群上部署所述容器。</li></ol><p id="d9fa" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">通过Git片段的使用，我将介绍我设计架构和开发应用程序代码的思维过程。为了避免这成为一个多部分的系列，我将在本文中链接许多参考资料。他们会解释技术堆栈的必要部分，而不需要我去浏览它们。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="0d81" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">作为这篇文章和代码的作者，由于我自己狭隘的观点，我可能会跳过一些必要的解释或步骤。因此，如果有些东西没有意义或感觉不完整，请在评论区伸出手，这样文章可以迭代改进。如果我能提供至少一个有价值的见解，我将认为这是一个成功。我希望你找到你正在寻找的东西。尽情享受吧！</p><h1 id="2178" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">先决条件</h1><p id="26f6" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">在我们进入问题的关键之前，非常需要熟悉上面提到的堆栈:</p><p id="aab5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">1.OpenAPI规范，即OAS 3.0，是一个语言不可知的API定义文档，它可以描述由服务公开的HTTP APIs的风格。代码生成器可以使用该规范来生成黄金标准的客户端绑定和服务器存根，从而将开发人员的生产力提高到更高的水平。下面的博客提供了对OAS及其相关工具的深刻见解。</p><div class="nm nn gp gr no np"><a href="https://blog.apideck.com/introduction-to-openapi-specification" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">什么是OpenAPI？OpenAPI规范(OAS)简介</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">OpenAPI继续发展并维持着一个充满活力、相互联系的API经济。在这里，我们定义OpenAPI到底是什么…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">blog.apideck.com</p></div></div></div></a></div><p id="0c42" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在所有围绕OpenAPI规范构建的工具中，对我们来说最重要的是OpenAPI生成器。该工具使用OpenAPI规范文件来生成SDK、服务器存根或支持20多种编程语言的文档。OpenAPI generator会帮助我们为自己设计的API生成spring服务器存根，我们要做的就是用OpenAPI定义来描述它们。</p><div class="nm nn gp gr no np"><a href="https://github.com/OpenAPITools/openapi-generator" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">GitHub—open api tools/open API-Generator:open API Generator允许生成API客户端…</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">OpenAPI生成器允许生成API客户端库(SDK生成)、服务器存根、文档和…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od kp np"/></div></div></a></div><p id="3313" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">2.Akka是一个帮助创建高性能分布式应用程序的工具包，其核心是受Actor系统的影响并遵循Actor系统的范式。对于不熟悉演员概念的读者，我建议他们看看下面的博客:</p><div class="nm nn gp gr no np"><a href="https://www.brianstorti.com/the-actor-model/" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">10分钟后的演员模特</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">我们的CPU并没有变得更快。现在的情况是，我们已经拥有了多个内核。如果我们想拿…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">www.brianstorti.com</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od kp np"/></div></div></a></div><p id="3da0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要理解为什么Akka框架如此适合设计可伸缩的、有弹性的并发系统，请参考以下内容:</p><div class="nm nn gp gr no np"><a href="https://doc.akka.io/docs/akka/current/typed/guide/actors-intro.html" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">参与者模型如何满足现代分布式系统的需求</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">如前一主题所述，常见的编程实践并不能很好地满足要求苛刻的现代…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">doc.akka.io</p></div></div><div class="ny l"><div class="of l oa ob oc ny od kp np"/></div></div></a></div><p id="9574" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Akka提供了内置的库来支持集群中多个实例上的分片角色机制。所以我们只需要担心使用actor系统范式设计我们的业务逻辑。查看Akka文档时，请注意以下几点:</p><ol class=""><li id="c067" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated"><a class="ae kv" href="https://doc.akka.io/docs/akka/current/typed/actors.html" rel="noopener ugc nofollow" target="_blank">演员介绍</a></li><li id="6bfc" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated"><a class="ae kv" href="https://doc.akka.io/docs/akka/current/typed/persistence.html" rel="noopener ugc nofollow" target="_blank">使用事件源的参与者状态的持久性</a></li><li id="9411" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated"><a class="ae kv" href="https://doc.akka.io/docs/akka/current/typed/cluster.html" rel="noopener ugc nofollow" target="_blank">聚集在阿卡</a></li></ol><p id="64b4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">3.阿帕奇卡桑德拉。选择Cassandra的最好理由是通过Akka分片库提供的插件，通过Cassandra使事件源成为一个持久的范例。</p><p id="0ec6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这也是一个明智的选择，因为Cassandra可以水平扩展，同时保持效率和速度高于一切，这使它成为为分片服务编写持久化层的绝佳选择，我们可以在事件发生时不断编写状态变化事件。</p><div class="nm nn gp gr no np"><a href="https://www.freecodecamp.org/news/the-apache-cassandra-beginner-tutorial/" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">Apache Cassandra初学者教程</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">如今有很多数据存储选择。您必须在托管或非托管、关系型或…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">www.freecodecamp.org</p></div></div><div class="ny l"><div class="og l oa ob oc ny od kp np"/></div></div></a></div><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="b0a7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是我为我们正在构建的键值缓存服务创建的git存储库:</p><div class="nm nn gp gr no np"><a href="https://github.com/VamshikShetty/akka-cluster-sharding-kv-service" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">GitHub-VamshikShetty/akka-集群-分片-kv-服务</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="oj l oa ob oc ny od kp np"/></div></div></a></div><h1 id="9911" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">1.使用OpenAPI生成器和OAS 3.0生成Spring代码</h1><p id="3682" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">我们的应用程序的目标是存储键-值对，这至少需要两组操作，即存储键-值对和根据提供的键获取值。</p><p id="bd89" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">以下要点展示了kv缓存服务所需的完整OAS。有两个操作是不言自明的，即POST方法带有一个存储数据的请求体，该请求体通过确认数据是否被存储来响应。GET方法使用反映键的查询参数，如果键-值对不存在，则返回值或null。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok oi l"/></div></figure><p id="3467" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">随着OAS文件的消耗，OpenAPI生成器也需要生成器配置来生成spring服务器存根。我们的生成器配置只利用了最少的必需属性来生成合适的spring代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok oi l"/></div></figure><p id="1506" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要更好地理解OpenAPI生成器配置，请参考以下内容:</p><div class="nm nn gp gr no np"><a href="https://openapi-generator.tech/docs/generators" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">OpenAPI生成器从OpenAPI 2.0/3.x文档生成客户端、服务器和文档</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">以下发电机可用:</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">openapi-generator.tech</p></div></div></div></a></div><p id="d35f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">接下来，我们将使用OpenAPI规范和生成器配置文件来生成我们的spring代码。下面是shell脚本，它使用OpenAPI代码生成器的docker映像来生成所需的spring服务器存根(<a class="ae kv" href="https://github.com/OpenAPITools/openapi-generator#16---docker" rel="noopener ugc nofollow" target="_blank">使用参考</a>)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok oi l"/></div></figure><blockquote class="ol om on"><p id="6cde" class="kx ky oo kz b la lb jr lc ld le ju lf op lh li lj oq ll lm ln or lp lq lr ls ij bi translated"><strong class="kz ir">注意</strong>:上面提到的脚本从一个名为spec的文件夹中选择我们的OAS和代码生成器配置文件。</p></blockquote><p id="fa7b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在我们执行了上面的shell文件之后，我们当前的工作目录应该看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/a6e4c5e5f7e7498287d9989e559ec6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*_8oBSKuOzD0nNgsfA0N1Zw.png"/></div></figure><p id="dec7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">目前，我们在<code class="fe ot ou ov ow b">akka-sharded-kv</code>文件夹中看到的一切都是生成的代码。在我们使用Akka在生成的代码旁边添加业务逻辑之前，让我们开始使用Bazel作为构建工具。</p><h1 id="210e" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">2.我们项目的市场化</h1><p id="8bc5" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">使用Bazel构建这个项目并执行产生的java二进制文件是个人的选择。我建议读者阅读Bazel，但是他们可以很容易地使用其他构建自动化工具，比如gradle、maven等。</p><p id="0598" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">注意:</strong>眼尖的读者可能已经注意到<code class="fe ot ou ov ow b">pom.xml</code>是和spring代码一起生成的。我们可以构建和部署应用程序，但我们不会使用它，而是用Bazel需要的东西来替换它。</p><p id="b12f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于不熟悉使用Bazel进行Java项目的读者，可以参考以下内容:</p><div class="nm nn gp gr no np"><a href="https://bazel.build/start/java" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">Bazel教程:构建一个Java项目</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">本教程涵盖了用Bazel构建Java应用程序的基础知识。您将设置您的工作区并构建一个…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">巴泽尔. build</p></div></div></div></a></div><p id="e163" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">正如上面的教程所解释的，我们必须创建<a class="ae kv" href="https://github.com/VamshikShetty/akka-cluster-sharding-kv-service/blob/main/akka-sharded-kv/BUILD" rel="noopener ugc nofollow" target="_blank"> BUILD </a>和<a class="ae kv" href="https://github.com/VamshikShetty/akka-cluster-sharding-kv-service/blob/main/akka-sharded-kv/WORKSPACE" rel="noopener ugc nofollow" target="_blank"> WORKSPACE </a> Bazel文件。这些文件将驻留在<code class="fe ot ou ov ow b">akka-sharded-kv</code>目录中。另外，记得删除通过OpenAPI代码生成器生成的<code class="fe ot ou ov ow b">pom.xml</code>,因为不再需要它了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok oi l"/></div></figure><p id="522b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一旦我们引入了构建和工作空间文件，我们就可以运行以下Bazel命令了:</p><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="e4af" class="pb mq iq ow b gy pc pd l pe pf"># Run cmds from root of service directory<br/>cd akka-sharded-kv</span><span id="cbeb" class="pb mq iq ow b gy pg pd l pe pf"># Bazel cmd to build our application<br/>bazel build //:kv-akka-sharded</span><span id="19a6" class="pb mq iq ow b gy pg pd l pe pf"># Bazel cmd to execute and start spring boot application<br/>bazel run //:kv-akka-sharded</span></pre><p id="ba79" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里有一些材料试图为Bazel提供一个案例，因为本文并不打算这样做。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h1 id="b234" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">3.使用Akka构建分片的键值缓存逻辑</h1><p id="eb86" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">我们只写了四样东西，即OpenAPI规范、生成器配置、Bazel构建和工作空间文件。而spring代码是通过OpenAPI代码生成器自动生成的。这或多或少涵盖了在我们的服务中设计和创建我们的API层。现在是时候添加以分片方式缓存键值对的业务逻辑了。</p><p id="74fe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我希望你已经熟悉了一个演员的生命周期，以及在Akka演员系统中创建一个演员并与之互动的过程。如果没有，请浏览以下材料:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="6fe3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">参与者还应该能够将消息或它们的状态或者两者都保存到通用存储系统中。Akka通过两种方法提供持久性，即<a class="ae kv" href="https://doc.akka.io/docs/akka/current/typed/persistence.html" rel="noopener ugc nofollow" target="_blank">事件源</a>和<a class="ae kv" href="https://doc.akka.io/docs/akka/current/typed/durable-state/persistence.html" rel="noopener ugc nofollow" target="_blank">持久状态</a>。对于我们的键值缓存服务，我们将使用事件源范式来存储参与者的状态。</p><p id="1a16" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">向前看，我们必须理解分片的含义，并将其与演员在演员系统中的行为相结合。幸运的是，Akka集群提供了一种跨多个角色系统实例共享角色的机制。以下参考文献总结了Akka如何为我们实现这一机制，因此我们可以专注于业务逻辑:</p><ol class=""><li id="6d9a" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated"><a class="ae kv" href="https://doc.akka.io/docs/akka/current/typed/cluster-sharding-concepts.html" rel="noopener ugc nofollow" target="_blank">Akka中演员系统的集群分片概念</a></li><li id="d13e" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated"><a class="ae kv" href="https://doc.akka.io/docs/akka/current/typed/cluster-sharding.html" rel="noopener ugc nofollow" target="_blank">如何使用Akka实现集群分片</a></li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h2 id="2e13" class="pb mq iq bd mr ph pi dn mv pj pk dp mz lg pl pm nb lk pn po nd lo pp pq nf pr bi translated">设计键值管理器实体</h2><p id="ff66" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">现在我们已经熟悉了Akka集群分片，让我们利用它来编写我们的业务逻辑。现在问问你自己:如果你有一些键值对，你想在应用程序层使用Actors来存储和缓存，你会怎么做？</p><p id="3800" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">也许，每个键-值对可以由单个参与者持有，对单个参与者的切分是对跨实例切分单个键-值对的反映。但是为每个新的键-值对创建一个单独的actor感觉有点过头了。此外，删除一个键值对需要我们从系统中删除持久化的actor。</p><p id="5a82" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">好了，转到下一个设计，我们可以创建一个键值管理器角色/实体，它基于一些内在的标识符来存储键值对组。为了创建键值管理器实体，我们可以利用键的前缀作为基于预定义长度提取的实体id。这可能是这样的:</p><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="84f5" class="pb mq iq ow b gy pc pd l pe pf">Predefined prefix length is 5</span><span id="5034" class="pb mq iq ow b gy pg pd l pe pf">kv pair 1 : { "hello-word" : "some-value-1" }<br/>kv pair 2 : { "hello-you"  : "some-value-2" }<br/>kv pair 3 : { "alerts-sys" : "some-value-3" }</span><span id="572e" class="pb mq iq ow b gy pg pd l pe pf">Here, key-value manager entity ID is prefix of key of defined length i.e. Using prefix length of 5 entity Id for pair 1 &amp; 2 is “hello” and for 3rd pair its “alert”</span></pre><p id="7c57" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里有一个小问题，如果键比我们的前缀长度短怎么办。因此，为了解决这个问题，我们要么添加填充，要么从键的哈希前缀中派生实体id。后一种方法看起来像这样:</p><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="42ca" class="pb mq iq ow b gy pc pd l pe pf">Predefined prefix length is 5</span><span id="88aa" class="pb mq iq ow b gy pg pd l pe pf">kv pair 1 : { "key-458997"  : "value-1" }<br/>kv pair 2 : { "key-100"     : "value-2" }<br/>kv pair 3 : { "key-1548533" : "value-3" }</span><span id="c86a" class="pb mq iq ow b gy pg pd l pe pf">sha256 hash of "key-458997" :<br/>ac100d31fa61174af78a25216ab2f70db52f3ef0473913561de20a6e6755c597<br/>Entity Id to store this key-value in : ac100</span><span id="06bf" class="pb mq iq ow b gy pg pd l pe pf">sha256 hash of "key-100" :<br/>47bae8fa70a586fc7d275abc2e480472b7a052518931839d3e5e05c499476563<br/>Entity Id to store this key-value in : 47bae</span><span id="68b5" class="pb mq iq ow b gy pg pd l pe pf">sha256 hash of "key-1548533" :<br/>ac100894689f09fa054b3e92f4d09514c89a8add7d5c30969bd57abb3645a815<br/>Entity Id to store this key-value in : ac100</span><span id="1731" class="pb mq iq ow b gy pg pd l pe pf">So now Kv manager entity with Id ac100 will store pair 1 &amp; 3, whereas entity with Id 47bae will store 2nd pair</span></pre><blockquote class="ol om on"><p id="3b2c" class="kx ky oo kz b la lb jr lc ld le ju lf op lh li lj oq ll lm ln or lp lq lr ls ij bi translated"><strong class="kz ir">重要</strong>:记住一个actor/entity的Id是用来计算这个actor会坐在哪个shard里面的。默认情况下，碎片标识符是实体标识符的<code class="fe ot ou ov ow b"><em class="iq">hashCode</em></code>的绝对值，以碎片总数为模。<br/>参考:s <a class="ae kv" href="https://doc.akka.io/docs/akka/current/typed/cluster-sharding.html#shard-allocation" rel="noopener ugc nofollow" target="_blank">硬分配</a></p></blockquote><p id="adb2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">假设读者已经熟悉了在Akka集群中编写actor/entity的基础知识，我们将定义一个键值管理器实体，它维护一个持久化多个键值对的状态。该实体接受两个命令:</p><p id="1829" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe ot ou ov ow b">StoreValueCmd</code>:这个命令包含一个键值对，需要持久化到<code class="fe ot ou ov ow b">KvManagerEntity</code>状态的hashmap中，这个hashmap是在<code class="fe ot ou ov ow b">KVState</code> Java类中定义的。</p><p id="ea5a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在接收到这个命令时，实体首先持久化<code class="fe ot ou ov ow b">StoreValueEvent</code>，然后通过向hashmap添加键值对来改变内部状态。</p><p id="5f4e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe ot ou ov ow b">FetchValueCmd</code>:该命令从<code class="fe ot ou ov ow b">KvManagerEntity</code>的<code class="fe ot ou ov ow b">KVState</code>中取出所提供密钥的值。如果键不存在，那么它返回null。</p><p id="0944" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">注意</strong>:我们正在扩展event sourced with enforced replies类来设计我们的actor/entity。因此，kv管理器实体必须总是响应接收到的命令。</p><p id="7848" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">参考:<a class="ae kv" href="https://doc.akka.io/docs/akka/current/typed/persistence.html#replies" rel="noopener ugc nofollow" target="_blank">Akka演员的强制回复</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok oi l"/></div></figure><p id="48ca" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们定义一个spring服务，它将代表REST层与驻留在actor系统中的键值管理器实体进行交互，以存储和获取键值对。请注意这三个重要的函数定义:</p><ol class=""><li id="6226" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated"><code class="fe ot ou ov ow b">kvManagerEntityId</code>:从键的散列中生成实体ID的函数。</li><li id="61d9" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated"><code class="fe ot ou ov ow b">putKeyValue</code>和<code class="fe ot ou ov ow b">getValue</code>:通过发送命令与Akka集群中的键值管理实体进行交互的功能，即<code class="fe ot ou ov ow b">StoreValueCmd</code>和<code class="fe ot ou ov ow b">FetchValueCmd</code>。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok oi l"/></div></figure><p id="619f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">只需要几个实用程序类，创建一个actor系统并为我们的actor系统初始化分片区域。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok oi l"/></div></figure><p id="35e7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们将所有的Akka逻辑捆绑在我们生成的spring代码旁边的<code class="fe ot ou ov ow b">com.example.akka.sharding.kv.actor</code>包中。这将产生类似于以下内容的目录结构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/f8b6ba42490a521d29011c18f3407135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*UYObQRurcT5e5Vm7q8bNnA.png"/></div></figure><p id="3453" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们需要更新我们生成的spring代码，也就是我们的REST层，开始通过spring键值服务与我们的actor系统进行交互。</p><p id="f2ef" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">生成的API控制器继承了定义REST路由的API类。首先，我们必须定义一些这些路由可以调用的抽象函数。而利用<code class="fe ot ou ov ow b">KvService</code>的逻辑需要放在生成的控制器内部:</p><ol class=""><li id="5cf3" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated">更新spring生成的API类以包含抽象逻辑函数，当检测到有效的API请求时需要调用这些函数:</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok oi l"/></div></figure><p id="9040" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">2.更新spring生成的控制器类，以提供与键值服务层交互的能力。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok oi l"/></div></figure><h2 id="d1fb" class="pb mq iq bd mr ph pi dn mv pj pk dp mz lg pl pm nb lk pn po nd lo pp pq nf pr bi translated">3.1.启动Akka集群的配置</h2><p id="c221" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">3.1.1.Akka中的序列化配置<br/> Akka actors需要通过JVM或实例互相发送消息来实现这种能力。这些信息需要序列化。下面的配置定义了要使用的序列化程序，并在我们的实现中将它绑定到一个公共的基本接口。</p><p id="bb87" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">参考:<a class="ae kv" href="https://doc.akka.io/docs/akka/current/serialization.html" rel="noopener ugc nofollow" target="_blank"> Akka序列化文档</a></p><p id="54e4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">将以下配置作为<code class="fe ot ou ov ow b">serialization.conf</code>存储在资源中。稍后，这将与其他几个Akka配置文件拼接在一起。</p><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="99f1" class="pb mq iq ow b gy pc pd l pe pf">akka.actor {<br/>  serializers {<br/>      jackson-cbor = "akka.serialization.jackson.JacksonCborSerializer"<br/>  }<br/>  serialization-bindings {<br/>    "com.example.akka.sharding.kv.actor.common.CborSerializable" = jackson-cbor<br/>  }<br/>}</span></pre><p id="57d2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">3.1.2。用于分片的集群配置</p><p id="73d4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">集群中的Akka应用程序需要一个最低配置，我们必须通过设置<code class="fe ot ou ov ow b">akka.actor.provider</code>属性来表明它的实例属于集群。有关更详细的理解，请参考<a class="ae kv" href="https://doc.akka.io/docs/akka/current/typed/cluster.html#cluster-api-extension" rel="noopener ugc nofollow" target="_blank">集群配置</a>。</p><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="f31d" class="pb mq iq ow b gy pc pd l pe pf">akka {<br/>  actor {<br/>    provider = "cluster"<br/>  }</span><span id="62e6" class="pb mq iq ow b gy pg pd l pe pf">remote.artery {<br/>    canonical {<br/>      port = 2551<br/>    }<br/>  }</span><span id="2fdd" class="pb mq iq ow b gy pg pd l pe pf">cluster {<br/>    app-version = 0.0.1</span><span id="fae6" class="pb mq iq ow b gy pg pd l pe pf">    # Seed nodes are NOT needed for K8s deployment.<br/>    # seed-nodes = ["akka://kv-inmem-actor-system@127.0.0.1:2551"]<br/>    .<br/>    .</span></pre><p id="8ceb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当我们开始利用分片时，可能需要在集群配置中添加一些配置参数，以便分片能够像<a class="ae kv" href="https://doc.akka.io/docs/akka/current/typed/cluster-sharding.html#shard-allocation" rel="noopener ugc nofollow" target="_blank">集群分片配置</a>中提到的那样工作。看起来是这样的:</p><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="6b21" class="pb mq iq ow b gy pc pd l pe pf">    .<br/>    .<br/>    sharding {<br/>      number-of-shards = 1000</span><span id="af6e" class="pb mq iq ow b gy pg pd l pe pf">remember-entities = off<br/>      remember-entities-store = eventsourced</span><span id="1159" class="pb mq iq ow b gy pg pd l pe pf">passivation {<br/>        default-idle-strategy {<br/>          idle-entity.timeout = 10 minutes<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="725f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">注意</strong>:将该配置保存为<code class="fe ot ou ov ow b">cluster.conf</code>。</p><p id="66ce" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 3.1.3。K8s的Akka管理和集群引导发现配置</strong></p><p id="4148" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">以下一组配置从K8s的角度来看是相当重要的。在这里，我们执行以下操作:</p><ol class=""><li id="a07c" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated"><a class="ae kv" href="https://doc.akka.io/docs/akka-management/current/healthchecks.html" rel="noopener ugc nofollow" target="_blank">使用默认实现设置路径以提供健康检查</a></li><li id="c3c2" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">Set discovery method查找K8s副本集中的其他节点，<code class="fe ot ou ov ow b">kubernetes-api</code>机制查询Kubernetes API服务器，查找带有给定标签的pod。请参考<a class="ae kv" href="https://doc.akka.io/docs/akka-management/current/bootstrap/index.html" rel="noopener ugc nofollow" target="_blank"> Akka集群引导</a>以更好地理解发现应用实例而不是设置种子节点的替代方法，因为该机制在K8s部署中无效。</li><li id="fc09" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">定义Akka管理的联系端口<br/>参考:<a class="ae kv" href="https://doc.akka.io/docs/akka-management/current/akka-management.html#basic-configuration" rel="noopener ugc nofollow" target="_blank"> Akka管理基本配置</a></li></ol><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="cf5b" class="pb mq iq ow b gy pc pd l pe pf">akka.management {<br/>  http {<br/>    port = 8552<br/>  }<br/>  <br/>  health-checks {<br/>    readiness-path = "akka-management/health-checks/ready"<br/>    liveness-path = "akka-management/health-checks/alive"<br/>  }</span><span id="cf06" class="pb mq iq ow b gy pg pd l pe pf">cluster.bootstrap {<br/>    contact-point-discovery {<br/>      discovery-method = kubernetes-api<br/>    }<br/>  }<br/>}</span></pre><p id="8027" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们需要定义<code class="fe ot ou ov ow b">pod-label-selector</code>和一个服务发现机制，集群代码需要使用该机制来检测其他实例。以下配置仅用于K8s部署。关于如何创建k8s资源以及如何在配置中引用它们的高级概述，请参考<a class="ae kv" href="https://doc.akka.io/docs/akka-management/current/bootstrap/kubernetes-api.html" rel="noopener ugc nofollow" target="_blank">使用Kubernetes API机制的引导程序</a>。</p><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="2a72" class="pb mq iq ow b gy pc pd l pe pf">akka.discovery {<br/>   kubernetes-api {<br/>     pod-label-selector = "app.kv.akka=%s"<br/>     class = akka.discovery.kubernetes.KubernetesApiServiceDiscovery<br/>   }<br/>}</span></pre><p id="0a2b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">注意:</strong>将此配置存储为<code class="fe ot ou ov ow b">discovery.conf</code>。</p><h2 id="683b" class="pb mq iq bd mr ph pi dn mv pj pk dp mz lg pl pm nb lk pn po nd lo pp pq nf pr bi translated">3.2.配置以便Akka集群可以与Cassandra交互</h2><p id="55fd" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">如前所述，我们将使用事件源范式来持久化我们的键值管理器实体。这种形式的持久性需要Akka来维护日志和快照。当收到的消息导致某个参与者的状态发生变化时，Akka不会更新或存储该参与者的状态，而是存储导致所述变化的事件。</p><p id="75eb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Akka中的持久性配置<br/>几个存储插件作为Akka生态系统的库提供。<a class="ae kv" href="https://doc.akka.io/docs/akka/current/persistence-plugins.html" rel="noopener ugc nofollow" target="_blank">持久性插件</a>文档提供了所有可用插件的概述以及它们在Akka应用程序中的使用说明。</p><p id="f245" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">关于Cassandra与Akka的集成，请参考以下文档:</p><ol class=""><li id="3d31" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated"><a class="ae kv" href="https://doc.akka.io/docs/akka-persistence-cassandra/current/overview.html" rel="noopener ugc nofollow" target="_blank">概述和项目依赖性</a></li><li id="ca42" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">为<a class="ae kv" href="https://doc.akka.io/docs/akka-persistence-cassandra/current/journal.html" rel="noopener ugc nofollow" target="_blank">日志</a>和<a class="ae kv" href="https://doc.akka.io/docs/akka-persistence-cassandra/current/snapshots.html" rel="noopener ugc nofollow" target="_blank">快照</a>设置存储事件所需的键空间和表</li><li id="5983" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated"><a class="ae kv" href="https://doc.akka.io/docs/akka-persistence-cassandra/current/configuration.html" rel="noopener ugc nofollow" target="_blank">配置</a>包含Akka w.r.t Cassandra使用的默认设置，并描述如何设置存储接触点和data tax-Java驱动程序，以与Cassandra的实例通信。</li></ol><p id="ef36" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">以下是我们服务的<code class="fe ot ou ov ow b">Persistence.conf</code>设置:</p><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="acfb" class="pb mq iq ow b gy pc pd l pe pf">clustering {<br/>  cassandra {<br/>    contactpoint = ${?CASSANDRA_CONTACT_POINT}<br/>  }<br/>}</span><span id="cc88" class="pb mq iq ow b gy pg pd l pe pf">datastax-java-driver {<br/>  advanced.reconnect-on-init = true<br/>  basic.contact-points = [${clustering.cassandra.contactpoint}]<br/>  basic.load-balancing-policy.local-datacenter = "datacenter1"<br/>}</span><span id="e1f3" class="pb mq iq ow b gy pg pd l pe pf">akka {<br/>  persistence {<br/>    journal {<br/>      plugin = "akka.persistence.cassandra.journal"<br/>      auto-start-journals = ["akka.persistence.cassandra.journal"]<br/>    }</span><span id="45c1" class="pb mq iq ow b gy pg pd l pe pf">snapshot-store {<br/>      plugin = "akka.persistence.cassandra.snapshot"<br/>    }</span><span id="a740" class="pb mq iq ow b gy pg pd l pe pf">cassandra  {<br/>      journal {<br/>        class = "akka.persistence.cassandra.journal.CassandraJournal"<br/>        keyspace = "akka"<br/>      }<br/>  <br/>      snapshot {<br/>        keyspace = "akka_snapshot"<br/>      }<br/>    }<br/>  }<br/>}</span></pre><h2 id="b99f" class="pb mq iq bd mr ph pi dn mv pj pk dp mz lg pl pm nb lk pn po nd lo pp pq nf pr bi translated">3.3.将所有配置拼接成一个</h2><p id="5b7c" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">一旦我们创建了<code class="fe ot ou ov ow b">cluster.conf</code>、<code class="fe ot ou ov ow b">serialization.conf</code>、<code class="fe ot ou ov ow b">persistence.conf</code>和<code class="fe ot ou ov ow b">discovery.conf</code>，我们将把所有这些配置放在一个名为<code class="fe ot ou ov ow b">application.conf</code>的文件中，这个文件是Akka应用程序在启动时使用的默认配置文件。请注意，我们还将包括其他配置，例如与登录到此文件相关的配置:</p><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="37b3" class="pb mq iq ow b gy pc pd l pe pf">include "cluster"<br/>include "serialization"<br/>include "persistence"<br/>include "discovery"</span><span id="9bee" class="pb mq iq ow b gy pg pd l pe pf">akka {<br/>  loglevel = "DEBUG"</span><span id="6dc9" class="pb mq iq ow b gy pg pd l pe pf"># This is useful when you are uncertain of what configuration is used.<br/>  log-config-on-start = off</span><span id="c969" class="pb mq iq ow b gy pg pd l pe pf">stdout-loglevel = "DEBUG"</span><span id="075d" class="pb mq iq ow b gy pg pd l pe pf">loggers = ["akka.event.slf4j.Slf4jLogger"]<br/>  logging-filter = "akka.event.slf4j.Slf4jLoggingFilter"</span><span id="192c" class="pb mq iq ow b gy pg pd l pe pf">log-dead-letters = on<br/>  log-dead-letters-during-shutdown = on<br/>}</span></pre><h1 id="d865" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">4.我们项目的集装箱化</h1><p id="b679" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">我需要在我们的容器中安装Bazel，并构建我们的Akka应用程序作为映像创建的一部分，这样当我们部署容器时，入口点或cmd可以直接启动应用程序。</p><p id="b4c0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我使用下面的<a class="ae kv" href="https://hub.docker.com/r/insready/bazel/dockerfile" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>作为如何获取和安装Bazel的参考:</p><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="104b" class="pb mq iq ow b gy pc pd l pe pf">FROM openjdk:8</span><span id="e2e7" class="pb mq iq ow b gy pg pd l pe pf">RUN echo "deb [arch=amd64] <a class="ae kv" href="http://storage.googleapis.com/bazel-apt" rel="noopener ugc nofollow" target="_blank">http://storage.googleapis.com/bazel-apt</a> stable jdk1.8" | tee /etc/apt/sources.list.d/bazel.list \ &amp;&amp; curl <a class="ae kv" href="https://bazel.build/bazel-release.pub.gpg" rel="noopener ugc nofollow" target="_blank">https://bazel.build/bazel-release.pub.gpg</a> | apt-key add -</span><span id="4187" class="pb mq iq ow b gy pg pd l pe pf">RUN apt-get update \<br/>  &amp;&amp; apt-get install -y bazel \<br/>  &amp;&amp; rm -rf /var/lib/apt/lists/*</span></pre><p id="7c9e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一旦Bazel安装完毕，复制Bazel构建文件和应用程序源代码来构建我们的Akka分片服务。构建我们的应用程序是我们创建映像的重要一步，因为它需要初始化Bazel缓存服务器，解决依赖性并存储所有需要的jar。如果现在不这样做，我们将在容器启动运行应用程序时结束执行。这将增加我们的应用程序在实际K8s部署期间的启动时间。</p><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="0f77" class="pb mq iq ow b gy pc pd l pe pf">WORKDIR /akka-sharded-kv</span><span id="49f0" class="pb mq iq ow b gy pg pd l pe pf">COPY BUILD BUILD<br/>COPY WORKSPACE WORKSPACE<br/>COPY src ./src</span><span id="0840" class="pb mq iq ow b gy pg pd l pe pf"># Build now to avoid time penalty later<br/>RUN bazel build //:kv-akka-sharded</span><span id="b3b5" class="pb mq iq ow b gy pg pd l pe pf">CMD bazel run //:kv-akka-sharded</span></pre><p id="697a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这些都是构建我们的docker文件和生成所需的容器映像所需要的。</p><h1 id="cdf8" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">5.让它在数字海洋上与K8s一起工作</h1><p id="6445" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">我们将选择DigitalOcean作为我们的基础设施提供商来部署我们的Akka缓存服务。在部署我们的应用程序之前，我们需要有一个Cassandra集群或一个实例，以便我们的键值管理器实体可以被持久化。</p><p id="da7f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">运行生产级Cassandra集群本身是一个由多个部分组成的博客系列，但是为了让我们的应用程序正常工作，我们将在K8s集群中部署一个临时Cassandra实例。</p><p id="2f50" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在Kubernetes上部署/运行Cassandra集群的参考:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="18c5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">请注意，存在一个名为K8ssandra的东西，它是运行在Kubernetes上的Cassandra的云原生发行版。许多优秀的教程可以帮助您部署生产级Cassandra集群。</p><p id="4ddb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">点击此处了解更多信息:</p><div class="nm nn gp gr no np"><a href="https://k8ssandra.io/" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">K8ssandra</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">“New Relic非常支持标准化社区支持的工具来操作和管理Cassandra…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">k8ssandra.io</p></div></div><div class="ny l"><div class="pt l oa ob oc ny od kp np"/></div></div></a></div><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="6cdf" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">关于在K8s上运行Cassandra时遇到的挑战的精彩阅读:</p><div class="nm nn gp gr no np"><a href="https://blog.palark.com/running-cassandra-in-kubernetes-challenges-and-solutions/" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">在Kubernetes中运行Cassandra:挑战与解决方案</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">我们经常与Apache Cassandra打交道，并且需要将它作为基于Kubernetes的基础设施的一部分来操作…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">blog.palark.com</p></div></div><div class="ny l"><div class="pu l oa ob oc ny od kp np"/></div></div></a></div><p id="c672" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">无论如何，让我们完成Cassandra部署，这样我们就可以回到我们的应用程序了。</p><h2 id="2ca1" class="pb mq iq bd mr ph pi dn mv pj pk dp mz lg pl pm nb lk pn po nd lo pp pq nf pr bi translated">5.1.设置K8s集群和容器存储库</h2><p id="b55c" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">首先，我们需要在DigitalOcean中拥有一个K8s集群来部署我们的Cassandra实例和Akka集群实例。这里有一个快速入门指南:</p><div class="nm nn gp gr no np"><a href="https://docs.digitalocean.com/products/kubernetes/quickstart/" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">Kubernetes快速入门|数字海洋文档</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">DigitalOcean Kubernetes (DOKS)是一个托管的Kubernetes服务，让您部署Kubernetes集群，而无需…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">docs.digitalocean.com</p></div></div><div class="ny l"><div class="pv l oa ob oc ny od kp np"/></div></div></a></div><p id="cb2e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 5.1.1。通过本地终端</strong>连接到K8s集群</p><p id="d4b4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们将在配置集群后下载<code class="fe ot ou ov ow b">kubeconfig</code>,并通过参考我们的集群配置来执行kubectl命令。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pw"><img src="../Images/504593200828be0d74b11bb464a1c9e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsYze71vztq-u6U4toE6og.png"/></div></div></figure><p id="4a0d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们试着去取几个K8s资源吧。看起来是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi px"><img src="../Images/a19d6a087f708ae5eae0bfa05585bc76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ghPXKyMk0rvdJW9QZj0pDg.png"/></div></div></figure><p id="b5cd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在我们已经准备好使用K8s资源配置文件部署实例了。</p><p id="4642" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> 5.1.2。创建一个容器库来上传我们的容器映像</strong></p><div class="nm nn gp gr no np"><a href="https://docs.digitalocean.com/products/container-registry/quickstart/" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">集装箱注册快速入门|数字海洋文档</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">数字海洋集装箱注册(DOCR)是一个私人码头图像注册，具有额外的工具支持…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">docs.digitalocean.com</p></div></div><div class="ny l"><div class="py l oa ob oc ny od kp np"/></div></div></a></div><p id="6147" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一旦创建了容器注册表。现在，我们需要创建一个API令牌，然后登录到注册表，这样我们就可以将本地映像上传到我们的私有存储库中。下面是如何做到这一点:</p><div class="nm nn gp gr no np"><a href="https://docs.digitalocean.com/products/container-registry/how-to/use-registry-docker-kubernetes/" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">如何通过Docker和Kubernetes | DigitalOcean使用您的私人DigitalOcean容器注册表…</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">数字海洋集装箱注册(DOCR)是一个私人码头图像注册，具有额外的工具支持…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">docs.digitalocean.com</p></div></div><div class="ny l"><div class="pz l oa ob oc ny od kp np"/></div></div></a></div><p id="c796" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">上述步骤应该会产生类似于以下内容的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qa"><img src="../Images/98ff25e8073c6184b47287e3264ce416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iw2GS9XlNZFIgoeA-BVTSw.png"/></div></div></figure><h2 id="b558" class="pb mq iq bd mr ph pi dn mv pj pk dp mz lg pl pm nb lk pn po nd lo pp pq nf pr bi translated">5.2.K8s deploy Cassandra部署和服务</h2><p id="4c3a" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">我们将部署一个Cassandra 3.11映像，并用所需的表来配置它，以便于我们的应用程序工作。在这种情况下，有两个文件非常重要:</p><ol class=""><li id="4213" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated"><code class="fe ot ou ov ow b">create_keyspace_tables.cql</code>:这个Cassandra查询文件包含一个键空间和表定义的列表，从Akka持久性的角度来看，这是至关重要的。这些表需要在Cassandra实例联机后创建。</li><li id="2cfc" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated"><code class="fe ot ou ov ow b">cassandra-initdb-script.sh</code>:即使容器启动并准备好了，Cassandra实例也需要一些时间才能上线，所以我们有必要在尝试创建存在于<code class="fe ot ou ov ow b">create_keyspace_tables.cql</code>文件中的定义之前等待。这个脚本会等到<code class="fe ot ou ov ow b">cqlsh</code>命令可以执行一个有意义的任务时，才会尝试创建所需的表。</li></ol><p id="c312" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">下面是K8s资源配置文件:</p><ol class=""><li id="81f4" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated"><code class="fe ot ou ov ow b">ConfigMap</code> configuration负责创建初始化器脚本和cql定义的文件，由K8s部署资源配置使用。</li><li id="0378" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated"><code class="fe ot ou ov ow b">Deployment</code>配置拉一个稳定的Cassandra映像，公开容器端口，并执行Cassandra初始化器脚本，作为启动后生命周期钩子的一部分。</li><li id="136b" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated"><code class="fe ot ou ov ow b">Service</code>配置在部署配置中公开的所有端口上公开Cassandra实例，使用元数据标签<code class="fe ot ou ov ow b">cassandr-db-service-backend</code>作为服务名。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok oi l"/></div></figure><blockquote class="ol om on"><p id="8802" class="kx ky oo kz b la lb jr lc ld le ju lf op lh li lj oq ll lm ln or lp lq lr ls ij bi translated"><strong class="kz ir">注意:</strong>初始化cassandra实例的另一种方法是通过对其中的keyspace和表定义进行编码来创建一个定制的容器映像。你可以在这里找到这种方法的例子<a class="ae kv" href="https://gist.github.com/derlin/0d4c98f7787140805793d6268dae8440" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="e1bf" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">使用以下命令一次性部署Cassandra的配置映射、部署和服务:</p><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="c9ba" class="pb mq iq ow b gy pc pd l pe pf"># Go to akka-sharded-kv and execute following <br/>kubectl --kubeconfig=&lt;Path to kube config yaml&gt; apply -f K8s/cassandra</span></pre><p id="8299" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这将导致K8s资源的创建，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qb"><img src="../Images/c8bb2471899bca3d8d4521dbed89252b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bkjqJt-CJXZAkDW8dkE58A.png"/></div></div></figure><h2 id="0f26" class="pb mq iq bd mr ph pi dn mv pj pk dp mz lg pl pm nb lk pn po nd lo pp pq nf pr bi translated">5.3.K8s部署Akka集群分片应用部署和服务</h2><p id="9e0b" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">在部署Akka应用程序之前，我们需要构建我们的Akka容器映像，并将其上传到我们创建的私有存储库中，以便我们的K8s集群可以访问该映像。</p><h1 id="27ae" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">建立我们的形象</h1><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="df9e" class="pb mq iq ow b gy pc pd l pe pf"># Go to akka-sharded-kv directory and execute following cmd :</span><span id="e9c5" class="pb mq iq ow b gy pg pd l pe pf">docker build --tag kv-akka-sharded .</span></pre><p id="58b1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当我们建立我们的图像时，我们会给它贴上<code class="fe ot ou ov ow b">kv-akka-sharded</code>标签，这样就可以更容易地把它推送到我们的私有存储库中，这个存储库利用了上述标签。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qc"><img src="../Images/0fc4b3aa83bd8f99bda31f7ec5f22632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jqbDM-BSmMSDqLdwKlOvvQ.png"/></div></div></figure><p id="40ed" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">将图像推送到我们的容器存储库的步骤</strong></p><p id="3cc0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">使用<code class="fe ot ou ov ow b">docker tag</code>命令用全限定目标路径标记您的映像，然后使用全限定路径推送:</p><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="a921" class="pb mq iq ow b gy pc pd l pe pf">docker tag kv-akka-sharded:latest registry.digitalocean.com/akka-kv-service-repo/kv-akka-sharded</span><span id="deb0" class="pb mq iq ow b gy pg pd l pe pf">docker push registry.digitalocean.com/akka-kv-service-repo/kv-akka-sharded</span></pre><p id="2c6c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最后，图像应该在我们的私有存储库中可见，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qd"><img src="../Images/8fb7fe668b51fc43226eba56b133083c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jb28PhN9mPdza5f4mnQ1Jw.png"/></div></div></figure><p id="3f89" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在来说说Akka集群K8s资源配置文件。</p><p id="3e76" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在<code class="fe ot ou ov ow b">Deployment</code>配置中，可以注意到K8s正在从之前创建的digital ocean的私有repo中提取键值缓存Akka应用程序的容器映像。之后，我们在之前在<code class="fe ot ou ov ow b">discovery.conf</code>文件中提到的路径上设置健康检查探测器。最后，我们声明两个环境参数:</p><ol class=""><li id="26b1" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated"><code class="fe ot ou ov ow b">CASSANDRA_CONTACT_POINT</code>:将指向之前在第5.2节中部署的Cassandra集群服务</li><li id="fa1c" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated"><code class="fe ot ou ov ow b">AKKA_CLUSTER_BOOTSTRAP_SERVICE_NAME</code>:指向传递给pod-label-selector以匹配Akka pods的部署的元数据标签。这在kubernetes-api发现机制中非常有用。</li></ol><p id="5caa" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在<code class="fe ot ou ov ow b">Service</code>配置中，我们的应用程序被定义为负载平衡器，因此导致公共IP的可用性，并将我们的应用程序暴露给外部流量。</p><p id="230b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">使用<code class="fe ot ou ov ow b">Role</code>和<code class="fe ot ou ov ow b">RoleBinding</code>配置，我们让默认名称空间中的pod能够与K8s API服务器对话，并获取集群中运行的pod列表。这是Akka实例在K8s集群等动态设置中如何发现彼此的核心方式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok oi l"/></div></figure><p id="7765" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">类似于我们如何部署Cassandra实例，我们可以为我们的Akka应用程序部署K8s资源:</p><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="3518" class="pb mq iq ow b gy pc pd l pe pf"># Go to akka-sharded-kv and execute following <br/>kubectl --kubeconfig=&lt;Path to kube config yaml&gt; apply -f K8s/kv-akka-sharded</span></pre><p id="ca4b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这将导致为我们的应用程序创建K8s对象:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qe"><img src="../Images/9a63bd43da407e4b1326d5983b108b07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Izs9eP9bhJmi7ToaU7pDHQ.png"/></div></div></figure><p id="6f49" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">等到<code class="fe ot ou ov ow b">kv-akka-sharded-service-backend</code>服务获得分配的外部IP:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qf"><img src="../Images/6b889c862fcf8cf0c9b23d67ee61c262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*blxSxLcLz7de4I4Mbgiunw.png"/></div></div></figure><h1 id="7abb" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">与我们的Akka应用程序交互</h1><p id="b6a9" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">下面是与我们的应用程序交互所需的curl命令:</p><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="26e5" class="pb mq iq ow b gy pc pd l pe pf"># To store key-value pair :</span><span id="ad6f" class="pb mq iq ow b gy pg pd l pe pf">Request :</span><span id="ba12" class="pb mq iq ow b gy pg pd l pe pf">curl --location --request POST '<a class="ae kv" href="http://139.59.54.202:8089/db/kv/put'" rel="noopener ugc nofollow" target="_blank">http://139.59.54.202:8089/db/kv/put'</a> \<br/>--header 'Content-Type: application/json' \<br/>--data-raw '{<br/> "key" : "key-3",<br/> "value" : "value-4"<br/>}'</span><span id="6afb" class="pb mq iq ow b gy pg pd l pe pf">Response :</span><span id="d97d" class="pb mq iq ow b gy pg pd l pe pf">{"stored":true}</span><span id="e892" class="pb mq iq ow b gy pg pd l pe pf">--------------------------------------------</span><span id="0d03" class="pb mq iq ow b gy pg pd l pe pf"># To fetch value using provide key :</span><span id="a8a4" class="pb mq iq ow b gy pg pd l pe pf">Request :</span><span id="ee55" class="pb mq iq ow b gy pg pd l pe pf">curl --location --request GET '<a class="ae kv" href="http://139.59.54.202:8089/db/kv/get?key=key-3'" rel="noopener ugc nofollow" target="_blank">http://139.59.54.202:8089/db/kv/get?key=key-3'</a></span><span id="cd10" class="pb mq iq ow b gy pg pd l pe pf">Response :</span><span id="8ccd" class="pb mq iq ow b gy pg pd l pe pf">{"value":"value-4"}</span></pre><p id="a822" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了验证托管碎片的键值管理器实体是在我们应用程序的不同实例中创建的，我们可以在发送多个请求后检查pod日志:</p><p id="1dea" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">获取窗格列表:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qg"><img src="../Images/ba8dcac6ee9cc07cfec83a5a928b9557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GdVQBQbis0DRzrFnFMQByw.png"/></div></div></figure><p id="f4b5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在使用带有force选项的kubectl logs命令来跟踪创建碎片的位置:</p><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="5e02" class="pb mq iq ow b gy pc pd l pe pf">kubectl --kubeconfig=&lt;Path to kube config yaml&gt; logs &lt;POD NAME&gt; -f</span></pre><p id="ad66" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为我们的应用程序、部署的每个pod打开终端，并执行上面的命令。您应该会看到类似于以下内容的日志:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qh"><img src="../Images/5cb0d2d26ef3b02c2030e38f04d79574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m4A4gEUl1EJADiIxHU1LSA.png"/></div></div></figure><p id="123b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">差不多就是这样。我希望你喜欢它。感谢您阅读本文！</p><pre class="kg kh ki kj gt ox ow oy oz aw pa bi"><span id="4c24" class="pb mq iq ow b gy pc pd l pe pf"><strong class="ow ir">Want to Connect?</strong></span><span id="ed80" class="pb mq iq ow b gy pg pd l pe pf">You can find me on <a class="ae kv" href="https://www.linkedin.com/in/vamshik-shetty/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>.</span></pre></div></div>    
</body>
</html>