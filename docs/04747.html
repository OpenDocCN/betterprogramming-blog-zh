<html>
<head>
<title>Server-Sent Events on React and Spring WebFlux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React和Spring WebFlux上服务器发送的事件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/server-sent-events-on-react-and-spring-webflux-5f532b04633?source=collection_archive---------1-----------------------#2020-05-06">https://betterprogramming.pub/server-sent-events-on-react-and-spring-webflux-5f532b04633?source=collection_archive---------1-----------------------#2020-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c6f0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用React客户端应用程序监听服务器发送的实时事件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/116b464fb33700c96bc40fb4874ce9ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F2DN2h7aYoysnIpjb-Kkvg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="12cb" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">什么是服务器发送的事件？</h1><p id="c493" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">服务器发送的事件是一种标准，它允许客户端(浏览器)在长期标准HTTP连接上侦听事件流，而不是轮询服务器或建立WebSocket。</p><p id="8425" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">SSE允许浏览器在连接建立后接收实时更新。这是一种服务器推送技术，客户端启动连接以接收更新，并保持连接活动，直到事件源关闭。</p><p id="70d2" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">服务器发送的事件对事件的推送方式有一个特定的标准。SSE流的内容类型应该是文本/事件流，事件本身由两个表示事件结束的换行符(<code class="fe my mz na nb b">\n\n</code>)分隔。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="f181" class="ng lg it nb b gy nh ni l nj nk">data:{"cpuUsage":57,"memoryUsage":73,"date":"05-01-2020"}</span><span id="0c77" class="ng lg it nb b gy nl ni l nj nk">data:{"cpuUsage":9,"memoryUsage":81,"date":"05-01-2020"}</span></pre></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="6552" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">SSE与WebSocket</h1><p id="2a48" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">您可能想知道WebSocket和SSE之间的区别，因为它们听起来非常相似。嗯，WebSocket和SSE有很多不同的特征。</p><p id="c07e" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">WS和SSE的主要区别在于服务器发送的事件是单向的，这意味着它是从服务器到浏览器的单向连接(例如监控系统)。但是WebSockets是双向的，这意味着客户端和服务器都可以推送更新。(例如聊天应用程序)。</p><p id="dcee" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">SSE可以通过简单的HTTP传输，不像WebSocket在TCP握手之后使用WebSocket协议。使用SSE时，您不必担心连接会被一些防火墙阻止，并且受现有基础设施的支持，而一些防火墙可能会在数据包检查期间阻止WebSocket连接。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="204a" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">弹簧网流量</h1><p id="b04a" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">Spring Framework 5引入了一个新的模块，<a class="ae nm" href="https://docs.spring.io/spring-framework/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/web-reactive.html" rel="noopener ugc nofollow" target="_blank"> spring-webflux </a>，它支持反应式编程来编写类似Node.js的异步、非阻塞、事件驱动的应用程序</p><p id="ecec" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">该模块支持两种编程模型:</p><ul class=""><li id="ba4a" class="nn no it lz b ma mt md mu mg np mk nq mo nr ms ns nt nu nv bi translated">传统的基于注释的控制器类似于spring-webmvc。</li><li id="fbd3" class="nn no it lz b ma nw md nx mg ny mk nz mo oa ms ns nt nu nv bi translated">用Java 8 lambda函数进行函数式编程。</li></ul><p id="e2a2" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">在spring-webflux中，与spring-webmvc相比，你不用简单的POJO来响应。相反，我们使用单声道和通量:</p><ul class=""><li id="d607" class="nn no it lz b ma mt md mu mg np mk nq mo nr ms ns nt nu nv bi translated"><code class="fe my mz na nb b">Mono&lt;T&gt;</code>:可以返回零个或一个结果。</li><li id="1125" class="nn no it lz b ma nw md nx mg ny mk nz mo oa ms ns nt nu nv bi translated"><code class="fe my mz na nb b">Flux&lt;T&gt;</code>:可以返回零个或多个结果。</li></ul><p id="a06b" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">关于spring-webflux模块，我就不赘述了。相反，本指南侧重于在React中编写实时事件监听器。你可以在他们的官方文档上阅读更多<a class="ae nm" href="https://docs.spring.io/spring-framework/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/web-reactive.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="668d" class="ng lg it bd lh ob oc dn ll od oe dp lp mg of og lr mk oh oi lt mo oj ok lv ol bi translated">计算机网络服务器</h2><p id="a30f" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">让我们首先使用<a class="ae nm" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring Initializ </a> r创建一个spring-boot应用程序，并添加下面的依赖项:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="6d06" class="ng lg it nb b gy nh ni l nj nk">&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="599c" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">现在我们将创建一个控制器，它将每秒发出包含资源使用数据的事件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="d00c" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">上面的控制器方法(<code class="fe my mz na nb b">getResourceUsage()</code>)将每秒发出事件，包含一个新的<code class="fe my mz na nb b">Usage</code>类对象，分别填充了<code class="fe my mz na nb b">cpuUsage</code>和<code class="fe my mz na nb b">memoryUsage</code> <strong class="lz iu">、</strong>的随机值，以模拟连续的事件流。</p><p id="a49e" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">由于服务器发送的事件应该有一个文本/事件流的内容类型，我们必须在<code class="fe my mz na nb b">GetMapping</code>注释内的路径值后添加<strong class="lz iu"> </strong> <code class="fe my mz na nb b">produces = MediaType.TEXT_EVENT_STREAM_VALUE</code> <strong class="lz iu"> </strong>。</p><p id="8141" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">记下注释<code class="fe my mz na nb b">@CrossOrigin(allowedHeaders = “*”)</code>。我已经允许来自所有主机的所有跨源头，因为我们将从React应用程序调用这个端点。如果我们不允许，浏览器会阻止这个请求。</p><p id="8a29" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">这就是在spring-webflux中生成事件流所要做的全部工作。</p><p id="d8ea" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">现在让我们启动应用程序，并在浏览器中转到<a class="ae nm" href="http://localhost:8080/event/resources/usage" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/event/resources/usage</a>。您应该能够看到发出的一系列事件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/1448a5d3f7364b957656e896ef69ed05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3_yDV_ufkWNX2wUjzctPRw.gif"/></div></div></figure><h2 id="edc5" class="ng lg it bd lh ob oc dn ll od oe dp lp mg of og lr mk oh oi lt mo oj ok lv ol bi translated">客户应用程序</h2><p id="293a" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">我们将创建一个带有两个计量器的简单仪表板来演示服务器发送的实时事件。因此，让我们使用<a class="ae nm" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>创建一个React应用程序:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="5558" class="ng lg it nb b gy nh ni l nj nk">npm create-react-app react-sse-demo</span></pre><p id="6f41" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">为了显示流数据，我们将使用<a class="ae nm" href="https://www.npmjs.com/package/react-d3-speedometer" rel="noopener ugc nofollow" target="_blank">react-D3-速度计。</a> <strong class="lz iu"> </strong>让我们使用下面的命令安装软件包:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="c4f5" class="ng lg it nb b gy nh ni l nj nk">npm i react-d3-speedometer</span></pre><p id="ab36" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">我们可以使用JavaScript event source API<strong class="lz iu"/>来订阅事件流。现在在名为<code class="fe my mz na nb b">/src/components</code>的新目录中创建一个名为<code class="fe my mz na nb b">Dashboard.js</code>的文件，并添加下面的代码。不要忘记在<code class="fe my mz na nb b">App.js</code>中渲染这个组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="21e6" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">这里，我们创建了一个功能组件，并使用React钩子<code class="fe my mz na nb b"><a class="ae nm" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">useState</a></code> <a class="ae nm" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank"> <strong class="lz iu"> </strong> </a>和<code class="fe my mz na nb b"><a class="ae nm" href="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank">useEffect</a></code> <a class="ae nm" href="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank"> <strong class="lz iu"> </strong> </a>来管理状态和生命周期方法。</p><p id="3793" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">在<code class="fe my mz na nb b">useEffect</code> <strong class="lz iu">、</strong>中，我们通过传递端点的URL创建了一个新的<code class="fe my mz na nb b">EventSource</code> <strong class="lz iu"> </strong>对象。这将启动到我们端点的连接并开始监听。注意空数组<code class="fe my mz na nb b">[]</code> <strong class="lz iu"> </strong>作为<code class="fe my mz na nb b">useEffect</code> <strong class="lz iu"> </strong>的最后一个参数，它只会在组件被挂载和卸载时调用该函数。</p><p id="be8a" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">客户端每次接收到事件时，都会调用<code class="fe my mz na nb b">EventSource.onmessage</code> <strong class="lz iu"> </strong>。在函数内部，我们将<code class="fe my mz na nb b">event.data</code> <strong class="lz iu"> </strong>解析为一个JSON对象，并分别改变<code class="fe my mz na nb b">cpuUsage</code>和<code class="fe my mz na nb b">memoryUsage</code> <strong class="lz iu">、</strong>的状态，使其重新渲染组件。注意，状态变量<code class="fe my mz na nb b">cpuUsage</code>和<code class="fe my mz na nb b">memoryUsage</code>被设置为ReactSpeedometer的<code class="fe my mz na nb b">value</code>属性。</p><p id="0e2e" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">最后，我们必须关闭事件监听器。否则，它将保持连接并一直监听，直到我们停止。在<code class="fe my mz na nb b">useEffect</code> <strong class="lz iu"> </strong>中返回函数的行为类似于基于类的组件中的<code class="fe my mz na nb b">componentWillUnmount()</code>生命周期方法。所以当组件被卸载时，<code class="fe my mz na nb b">EventSource.close()</code> <strong class="lz iu"> </strong>被调用，强制它停止并关闭连接。</p><p id="18be" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">好了，现在让我们通过执行<code class="fe my mz na nb b">npm start</code>来启动应用程序。</p><p id="ad5e" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">当服务器推送事件时，您应该能够看到仪表板实时更新。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/992d32e95c55cdd4f4c3a8cd85d4ba82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3jmR16jN_zWZ218QhEKQJQ.gif"/></div></div></figure><p id="e810" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">太好了！SSE的使用取决于应用程序的类型(例如，点击流、物联网数据、综合服务器监控工具、汇率等)。).本指南中的事件源只是发出随机事件，实际的实现可能会有所不同，但仍然使用相同的概念。</p><p id="2592" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">你可以在GitHub 上获得完整的代码<a class="ae nm" href="https://github.com/oshanfernando/sse-react-spring-webflux" rel="noopener ugc nofollow" target="_blank">,以防你的系统无法正常运行。</a></p><p id="8a2b" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">感谢您的阅读和快乐编码！</p></div></div>    
</body>
</html>