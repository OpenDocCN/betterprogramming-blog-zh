<html>
<head>
<title>Clean Code: 5 Essential Takeaways</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">干净的代码:5个基本要点</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/clean-code-5-essential-takeaways-2a0b17ccd05c?source=collection_archive---------0-----------------------#2020-01-24">https://betterprogramming.pub/clean-code-5-essential-takeaways-2a0b17ccd05c?source=collection_archive---------0-----------------------#2020-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bafb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">程序员必读书籍的要点</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/06688b67b7b3ff6b8f32e6cbf5dee9dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYE3DMdtifTC_C2yb635cA.png"/></div></div></figure><p id="7ee7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我最近写了关于“<a class="ae lq" href="https://medium.com/better-programming/5-books-that-changed-the-way-i-code-73caffec6f0b" rel="noopener"> 5本改变了我编码方式</a>的书。”在评论中，几位读者推荐了罗伯特·c·马丁的《干净的代码》。因此，我现在读了这本书，发现它值得深入研究。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="7289" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">关于这本书</h1><p id="ede4" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">《干净的代码》于2008年出版，最近几年，它一直是T2最畅销的五本书之一。这位被亲切地称为“鲍勃叔叔”的作者是<a class="ae lq" href="https://agilemanifesto.org" rel="noopener ugc nofollow" target="_blank">敏捷宣言</a>的原始作者之一，并且有一些严肃的资历。这本书在Goodreads上的平均评分为4.4分，超过13，000分。可以说，这是每个程序员都应该读的书之一。</p><p id="db8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇评论中，我将把这本书浓缩成五个要点。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="73df" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">1.编程是一门手艺</h1><p id="e637" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我经常认为架构和构造不是编程的好比喻。我们不会创建一个完整的设计，然后从头开始构建基础，稳步推进到完成的建筑。</p><p id="cf7e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，我们从草图开始，反复添加细节。我们修改、提炼和扩展——在不同的抽象层次上工作，直到软件达到我们的要求。软件永远不会真正完成。</p><p id="18da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是“干净代码”的精髓在整本书中，作者传达了软件是一门艺术并且“很像绘画”的思想本质上，他认为编程是一门<em class="mv">手艺。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/9cc4efba0c347683cab886a31bfcbc0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*ldXJND38N7PUecQ-n6_qWQ.png"/></div><p class="mx my gj gh gi mz na bd b be z dk translated"><a class="ae lq" href="https://xkcd.com/844/" rel="noopener ugc nofollow" target="_blank"> xkcd </a>的“好代码”</p></figure><p id="fd18" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我们如何从简单地写代码发展到制作代码呢？</p><p id="0c4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据Martin的说法，我们拥有的主要工具是持续重构和测试驱动开发(TDD)。这些就像一枚硬币的两面一样一起工作。以下是一些定义:</p><p id="64c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mv">重构</em> <strong class="kw iu"> </strong>是在不改变现有计算机代码外部行为的情况下，对其进行重构的过程。</p><p id="8627" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mv">测试驱动开发</em>是将需求转化为具体测试用例，然后添加代码以通过测试的过程。</p><p id="a0b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，制作软件的过程可能看起来像这样:</p><ol class=""><li id="f558" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">编写失败的测试，验证所需但未实现的行为。</li><li id="f8f6" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">写一些(可能是坏的)代码，使这些测试通过。</li><li id="7df3" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">增量地重构代码，随着测试的继续通过，每一次开发迭代都变得更加清晰。</li></ol><blockquote class="np nq nr"><p id="8d18" class="ku kv mv kw b kx ky ju kz la lb jx lc ns le lf lg nt li lj lk nu lm ln lo lp im bi translated">“我们可以一次就把系统做好，这是一个神话。”相反，我们应该只实现今天的故事，然后重构和扩展系统以实现明天的新故事。这是迭代和增量敏捷的本质。"</p><p id="f5c1" class="ku kv mv kw b kx ky ju kz la lb jx lc ns le lf lg nt li lj lk nu lm ln lo lp im bi translated">罗伯特·马丁</p></blockquote><p id="b3fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，Martin提出的一个中心思想是，干净的代码是通过开发的过程和实践出现的，而不是简单地在一遍中创建的。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5ce4" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">2.保持简短！</h1><blockquote class="np nq nr"><p id="9fc2" class="ku kv mv kw b kx ky ju kz la lb jx lc ns le lf lg nt li lj lk nu lm ln lo lp im bi translated">“函数的第一条规则是它们应该很小。函数的第二个规则是它们应该比那个小。”罗伯特·马丁</p></blockquote><p id="cf20" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据马丁的说法，这意味着两件事:</p><ul class=""><li id="80a2" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp nv nh ni nj bi translated">函数体应该很短——很少超过20行，大多数少于10行</li><li id="8ce3" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp nv nh ni nj bi translated">函数应该采用尽可能少的参数，最好是没有参数</li></ul><p id="c906" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数简洁使得代码更容易阅读。它还将我们引向一种情况，即函数只做一件事，而且做得很好。</p><p id="2ebc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于阶级，他提出了类似的观点。对于类，他建议用职责而不是代码行来衡量大小。这个想法是一个类应该只负责一件事。这就是所谓的<a class="ae lq" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a> (SRP)。</p><p id="bd9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">保持实体简短是使代码更干净的分治策略。如果我们有一个包含大量冗长复杂代码的大文件，我们可以将文件分成模块，将模块分成功能，将功能分成子功能，直到逻辑和意图清晰为止。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="82ce" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">3.使代码自文档化</h1><blockquote class="np nq nr"><p id="13f5" class="ku kv mv kw b kx ky ju kz la lb jx lc ns le lf lg nt li lj lk nu lm ln lo lp im bi translated">“注释很少的清晰而富有表现力的代码远远优于注释很多的混乱而复杂的代码。”罗伯特·马丁</p></blockquote><p id="d724" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在关于注释、有意义的名称和格式的章节中，Martin为代码自文档化提供了一个强有力的例子。这方面的一个例子如下:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="8dc9" class="ob lz it nx b gy oc od l oe of">// Check to see if the employee is eligible for full benefits<br/>if ((employee.flags &amp; HOURLY_FLAG) &amp;&amp;<br/>    (employee.age &gt; 65))</span></pre><p id="b5f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这被重构为:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="6100" class="ob lz it nx b gy oc od l oe of">if (employee.isEligibleForFullBenefits())</span></pre><p id="75f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注:</strong></p><ul class=""><li id="6222" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp nv nh ni nj bi translated">该注释被删除</li><li id="3e07" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp nv nh ni nj bi translated">条件逻辑被封装到一个方法中</li><li id="a7b4" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp nv nh ni nj bi translated">因为使用的是方法而不是独立的函数，所以可以使用实例变量，从而创建一个零参数的方法调用</li><li id="e6f2" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp nv nh ni nj bi translated">该方法被赋予了一个描述性的名称，使得它的职责非常清楚</li></ul><p id="6ae5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">“干净代码”包括一整章关于命名的内容，本质上是对Tim Ottinger的规则的阐述。其中包括:</p><ul class=""><li id="82d5" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp nv nh ni nj bi translated">使用透露意图的名字——例如<code class="fe og oh oi nx b">int elapsedTimeInDays</code>，而不是<code class="fe og oh oi nx b">int days</code></li><li id="35b1" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp nv nh ni nj bi translated">使用容易发音的名字，例如<code class="fe og oh oi nx b">Customer</code>，而不是<code class="fe og oh oi nx b">DtaRcrd102</code></li><li id="79de" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp nv nh ni nj bi translated">避免编码——不要对成员使用前缀<code class="fe og oh oi nx b">m_</code>,不要使用匈牙利符号<a class="ae lq" href="https://en.wikipedia.org/wiki/Hungarian_notation" rel="noopener ugc nofollow" target="_blank"/></li><li id="3633" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp nv nh ni nj bi translated">为每个概念选择一个词——不要用<code class="fe og oh oi nx b">fetch</code>、<code class="fe og oh oi nx b">retrieve</code>、<code class="fe og oh oi nx b">get</code>来描述同一个概念</li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8fa2" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">4.尊重抽象</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/986cfe851a094c046a1fada5f88ec03d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LtAYpu13VHCtrMsjBtV1pQ.png"/></div></div><p class="mx my gj gh gi mz na bd b be z dk translated">抽象。来源:<a class="ae lq" href="https://abstrusegoose.com/98" rel="noopener ugc nofollow" target="_blank">奥鹅</a></p></figure><p id="af63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据“干净代码”，如果我们想确保我们的函数只做一件事，我们需要确保每个函数中的语句都在同一抽象级别。</p><p id="0046" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Martin用下面来自<a class="ae lq" href="https://github.com/unclebob/fitnesse" rel="noopener ugc nofollow" target="_blank"> FitNesse </a>的例子说明了这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="c58f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这至少混合了两个层次的抽象。第一个是呈现给定大小的<code class="fe og oh oi nx b">hr</code>标签的高级概念，第二个是处理实际构造标签的低级语法细节。为了说明这一点，对代码进行了更清晰的重构，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="ab38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">备注:</strong></p><ul class=""><li id="3120" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp nv nh ni nj bi translated"><code class="fe og oh oi nx b">render()</code>函数现在只负责构造一个<code class="fe og oh oi nx b">hr</code>标签</li><li id="0577" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp nv nh ni nj bi translated">构建标签的底层细节现在委托给了<code class="fe og oh oi nx b">HtmlTag</code>模块</li><li id="52d9" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp nv nh ni nj bi translated">大小格式化被抽象成一个独立的函数</li></ul><p id="a1b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据马丁的说法:</p><blockquote class="np nq nr"><p id="8fba" class="ku kv mv kw b kx ky ju kz la lb jx lc ns le lf lg nt li lj lk nu lm ln lo lp im bi translated">“分离抽象层次是重构最重要的功能之一，也是最难做好的功能之一。”</p></blockquote><p id="295c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这肯定是我在以后的代码中会更多考虑的事情。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="ca90" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">5.干净的代码是关于原则和努力的</h1><p id="1401" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我不希望这篇评论仅仅是一系列要点和格言，形成我们可以用来获得干净代码的规则。这样做将是对这本书的一种伤害——因为它与这种教条式的方法本身相去甚远。</p><p id="3a19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，我得到的印象是，Martin在哄骗我们培养强烈的个人原则意识，并不断说明将代码从脏变干净所需的努力和责任心。这本书称之为<em class="mv">代码感，</em>需要“通过辛苦获得的清洁感，有纪律地使用无数小技巧。”</p><blockquote class="np nq nr"><p id="dd79" class="ku kv mv kw b kx ky ju kz la lb jx lc ns le lf lg nt li lj lk nu lm ln lo lp im bi translated">“干净的代码不是按照一套规则编写的。通过学习一系列启发法，你不会成为一名软件工匠。专业精神和工匠精神来自推动学科发展的价值观。”罗伯特·马丁</p></blockquote><p id="3496" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就我个人而言，作为一个缺乏自信的人，我非常欢迎这种强调。很高兴知道即使鲍勃叔叔也坚信编码很难，需要认真的工作和纪律。要真正擅长编写干净的代码，我们需要迭代我们作为程序员的个人发展，以及我们代码的发展。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="3aa8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="c1c8" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">并非“干净代码”中的每个想法都是由Bob叔叔提出的，他在书中的不同地方公开承认了这一点。如果有什么不同的话，这是使这本书如此成功的原因之一——它是来自编程社区各个部分的智慧的升华，用实际的例子来充实。</p><p id="6c46" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我有一个小小的批评，那就是关于细节的章节之间的平衡与关于更高层次的概念的章节相比稍微有点偏离。系统章节只有13页，几乎是评论空间的一半。然而，我怀疑不那么强调系统的原因是为了把这个讨论留到他后来的书“<a class="ae lq" href="https://www.amazon.co.uk/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164" rel="noopener ugc nofollow" target="_blank"> Clean Architecture </a>”中，这本书将在我2021年的阅读清单上。除此之外，这是最好的编程书籍之一。</p></div></div>    
</body>
</html>