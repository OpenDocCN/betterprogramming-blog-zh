<html>
<head>
<title>Demystifying JavaScript’s Prototype Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开JavaScript原型继承的神秘面纱</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/demystifying-javascripts-prototype-inheritance-6d91d4ee6256?source=collection_archive---------3-----------------------#2019-06-18">https://betterprogramming.pub/demystifying-javascripts-prototype-inheritance-6d91d4ee6256?source=collection_archive---------3-----------------------#2019-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7dbdd86c7cadf6767c6c234d48424eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*juZZe0SbI8E_QPd74Ax9uA.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@maxcodes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Max Nelson </a>在<a class="ae kf" href="https://unsplash.com/search/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e64c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在某种程度上，每个学习JavaScript的学生都听说过JavaScript没有类。或者他们可能听说JavaScript没有“真正的”类。</p><p id="f3fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，如果你看看下面的代码，或者打开你的浏览器控制台，键入“class ”,你会清楚地看到一些语法高亮显示。JavaScript显然有一个类，那么到底什么是“真正的”类呢？</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="6c3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript有类吗？是的，从某种意义上说，这个关键词确实存在，而且确实做了一些事情。然而，它与Java等语言中的class关键字意义不同。它唯一的目的是成为创建构造函数和设置其原型的语法糖。</p><p id="6cac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有很多花哨的词语，所以让我们把它分解一下。当我们说某事是句法糖时，我们的意思是它作为一种更好、更干净、可能更容易阅读的方式来做某事。</p><p id="8a9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">语法糖不是一个功能！它没有给这种语言添加任何以前不存在的额外功能。如果JavaScript类是语法糖，这意味着已经存在一种方法来编写上面的代码。事实上，有，虽然它看起来不太好。</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="f8f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，在第一行，我们有JavaScript的普通旧函数关键字。我们接受两个参数，并使用<code class="fe lk ll lm ln b">this</code>关键字动态设置<code class="fe lk ll lm ln b">name</code>和<code class="fe lk ll lm ln b">age</code>的值。</p><p id="51f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为第十行的代码，我们实际上告诉JavaScript创建一个<code class="fe lk ll lm ln b">PersonOldWay</code>函数的实例。</p><p id="9713" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第六行是我们给这个<code class="fe lk ll lm ln b">PersonOldWay</code>构造函数<code class="fe lk ll lm ln b">sayHello</code>函数的地方。注意，为了这样做，我们访问了<code class="fe lk ll lm ln b">PersonOldWay</code> prototype属性。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lo"><img src="../Images/4b90dd3f6f7c1f1d21b6f7a3010385fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s_CdKQ4QzcL5sYTIttrbAA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">注意Person.prototype计算出一个包含我们函数的对象。</p></figure><p id="0ae8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实际上，我们在第一段代码中做了完全相同的事情。请记住，第一段代码只是第二段代码的一个更漂亮的版本。它实际上并没有实现任何以前做不到的事情。</p><p id="13ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的<code class="fe lk ll lm ln b">Person.prototype</code>中，我们看到了我们定义的<code class="fe lk ll lm ln b">constructor</code>函数和<code class="fe lk ll lm ln b">sayHello</code>函数。随着我们向类中添加越来越多的方法，prototype属性将继续扩展，但是您可能也注意到了<code class="fe lk ll lm ln b">__proto__</code>指向了<code class="fe lk ll lm ln b">Object</code>。那到底是什么？</p><p id="9a4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lk ll lm ln b">__proto__</code>告诉我们<code class="fe lk ll lm ln b">Person</code>继承了<code class="fe lk ll lm ln b">Object.prototype</code>。如果我们看一下<code class="fe lk ll lm ln b">Object.prototype</code>，我们可以看到那里定义了各种方法——例如<code class="fe lk ll lm ln b">toString</code>方法。我们可以在<code class="fe lk ll lm ln b">Person</code>类上调用<code class="fe lk ll lm ln b">toString</code>方法，因为<code class="fe lk ll lm ln b">Person</code>从原型链的更高层继承了这些方法。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lp"><img src="../Images/6dd530fcfcd90949c4c641e004836394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQtyfhJz3DTNtVtbxd5bXw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">注意:我使用__proto__是为了说明，通常你会使用Object.getPrototypeOf。</p></figure><p id="efc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一件好事，因为它允许我们通过简单地编写一次方法来提高内存效率，然后让需要它的对象继承它。</p><p id="a9d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当运行一段代码时，JavaScript将首先检查有问题的对象是否具有该属性。如果有，它会询问是否会使用它。否则，它将查看该对象的<code class="fe lk ll lm ln b"> __proto__</code>，在我们的例子中是<code class="fe lk ll lm ln b">Person.prototype</code>，以查看该属性是否存在。</p><p id="f5f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它将重复这个过程，直到找到它，或者到达链的末端并返回null。</p><p id="876a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你熟悉一种使用经典继承的语言(比如Java或Ruby)，有些可能听起来很熟悉。使用经典继承的语言也有一种重用代码的方式，那么到底有什么区别呢？</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lp"><img src="../Images/a2f7cc7739f07df778510c63ef75adb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uF_RDjOzv0qB_1PI1YwtDA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">注意:b仍然有toString方法，即使它返回[object Object]</p></figure><p id="b6f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavasScript中，一切都只是一个从另一个对象继承的对象。没有蓝图，只有原型。原型本身就是一段工作代码。我可以直接给<code class="fe lk ll lm ln b">Person</code>函数赋予功能。在定义函数之后，我可以随时这样做。我所说的工作代码到底是什么意思？</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lp"><img src="../Images/7ef16d0f54208d29272161127e4c3ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wrllegs-XUAqOoLPiZ35ig.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">人员刚刚接收了自己的人员功能。我们的adam实例不能直接访问它，但是我们可以通过自己的方式访问它。</p></figure><p id="3790" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，在<code class="fe lk ll lm ln b">Person</code>上直接进行了一个新的函数调用<code class="fe lk ll lm ln b">personFunction</code>。它没有做任何特别的事情；它只是返回一个字符串。对象<code class="fe lk ll lm ln b">adam</code>继承自<code class="fe lk ll lm ln b">Person</code>，也就是说<code class="fe lk ll lm ln b">adam.__proto</code> <em class="lq"> = </em> <code class="fe lk ll lm ln b">Person.prototype</code> <em class="lq">。</em></p><p id="ef78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是请注意，我们不能简单地调用<code class="fe lk ll lm ln b">adam.personFunction()</code>，因为这个函数不存在于<code class="fe lk ll lm ln b">adam</code>继承链中。相反，它直接存在于构造函数中。<code class="fe lk ll lm ln b">Person</code>可以做的不仅仅是定义<code class="fe lk ll lm ln b">adam</code>将如何表现，这意味着它可以<em class="lq">做工作</em>。</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">一个简单的Java类，带有3个参数的构造函数。</p></figure><p id="fff3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面，我们定义了一个名为<code class="fe lk ll lm ln b">Dog</code>的简单Java类，并给了它一个三参数构造函数。这个类将定义每个<code class="fe lk ll lm ln b">Dog</code>实例的外观。<code class="fe lk ll lm ln b">Dog</code>的每个实例都会有两个字符串对应名字和品种，一个整数对应年龄。类本身不做任何工作。</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">这里我们制作一个Dog的实例并打印出它的属性。</p></figure><p id="03c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在传统的继承语言中，类作为创建对象(类的实例)的蓝图。除了定义其实例将继承的方法和属性之外，类本身没有任何用途。</p><p id="402c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">换句话说，除了定义其实例的行为方式，您不能对Java类做任何实际的事情。Java中的类将继承其他类，只要子类有一个潜在的更大、更健壮的蓝图。</p><p id="8727" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，不管继承链有多长，类本身永远不会仅仅是一个蓝图。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="ad06" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">来源</h1><div class="mw mx gp gr my mz"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd iu gy z fp ne fr fs nf fu fw is bi translated">功能</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">函数构造器创建一个新的函数对象。直接调用构造函数可以创建函数…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">developer.mozilla.org</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn jz mz"/></div></div></a></div><div class="mw mx gp gr my mz"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd iu gy z fp ne fr fs nf fu fw is bi translated">继承和原型链</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">对于熟悉基于类的语言(如Java或C++)的开发人员来说，JavaScript有点令人困惑，因为它是动态的…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">developer.mozilla.org</p></div></div><div class="ni l"><div class="no l nk nl nm ni nn jz mz"/></div></div></a></div></div></div>    
</body>
</html>