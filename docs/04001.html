<html>
<head>
<title>Leverage the Coordinator Design Pattern in Swift 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Swift 5中的协调器设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/leverage-the-coordinator-design-pattern-in-swift-5-cd5bb9e78e12?source=collection_archive---------1-----------------------#2020-03-18">https://betterprogramming.pub/leverage-the-coordinator-design-pattern-in-swift-5-cd5bb9e78e12?source=collection_archive---------1-----------------------#2020-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d207" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">隔离您的视图控制器，使它们更易于测试和重用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f7871c2de6a4b6957ac0a50a4ef843de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mZMuA35iRSE4kwkW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿尔瓦罗·雷耶斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="84a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们将通过一个示例项目探索Swift中的协调器设计模式。</p><p id="1e56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协调模式允许我们控制应用程序的流程，避免将导航逻辑直接放入控制器中。它还帮助我们将视图控制器相互隔离，当我们想要在我们的项目中重用它们时，这很方便。</p><p id="987b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将讨论以下部分:</p><ul class=""><li id="1f0b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">创建个人协调员</li><li id="ab17" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">利用协调员流程</li><li id="6ee3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用协调器在视图控制器之间传递数据</li></ul><p id="72f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该项目的源代码可以在文章的底部找到。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2299" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">我们开始吧</h1><p id="c0f7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">首先，让我们创建所有协调员都要遵守的<code class="fe nn no np nq b">Coordinator</code>协议:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="43fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要创建负责启动我们的应用程序的<code class="fe nn no np nq b">AppCoordinator</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完成初始设置，我们需要启动<code class="fe nn no np nq b">AppDelegate</code>中<code class="fe nn no np nq b">AppCoordinator</code>的<code class="fe nn no np nq b">start</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="72b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们进入应用程序的第一个屏幕。</p><h2 id="8522" class="nt mr it bd ms nu nv dn mw nw nx dp na li ny nz nc lm oa ob ne lq oc od ng oe bi translated">StartCoordinator</h2><p id="f29b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">类似于我们在<code class="fe nn no np nq b">AppCoordinator</code>中所做的，我们创建了<code class="fe nn no np nq b">StartCoordinator</code>类并使其符合<code class="fe nn no np nq b">Coordinator</code>协议。我们还定义了包含方法<code class="fe nn no np nq b">coordinateToTabBar()</code>的<code class="fe nn no np nq b">StartFlow</code>协议，我们将在<code class="fe nn no np nq b">StartViewController</code>中触发它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="71b7" class="nt mr it bd ms nu nv dn mw nw nx dp na li ny nz nc lm oa ob ne lq oc od ng oe bi translated">开始视图控制器</h2><p id="4990" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这里，我们简单地在屏幕中央布置了一个按钮，并创建了<code class="fe nn no np nq b">startTapped</code>处理程序(其中我们调用了<code class="fe nn no np nq b">coordinateToTabBar()</code>方法):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="aa39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看我们如何协调到<code class="fe nn no np nq b">TabBarCoordinator</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9a15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们所要做的就是实例化协调器并调用<code class="fe nn no np nq b">coordinate(to:)</code>方法。</p><p id="41d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们探索一下如何使用带有<code class="fe nn no np nq b">UITabBarController</code>的协调器。</p><h2 id="eb5f" class="nt mr it bd ms nu nv dn mw nw nx dp na li ny nz nc lm oa ob ne lq oc od ng oe bi translated">TabBarCoordinator</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4b6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在<code class="fe nn no np nq b">start()</code>方法中看到的，我们创建了单独的<code class="fe nn no np nq b">UINavigationController</code>和协调器，然后触发每个协调器的<code class="fe nn no np nq b">coordinate(to:)</code>方法。</p><p id="a313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们有了不知道其他控制器的<code class="fe nn no np nq b">TabBarController</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="22ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看标签栏的各个屏幕:<code class="fe nn no np nq b">TopRated</code>、<code class="fe nn no np nq b">Search</code>和<code class="fe nn no np nq b">History</code>。</p><h2 id="8873" class="nt mr it bd ms nu nv dn mw nw nx dp na li ny nz nc lm oa ob ne lq oc od ng oe bi translated">顶级协调员</h2><p id="5263" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们为<code class="fe nn no np nq b">TopRatedViewController</code>构造协调器如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3203" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而<code class="fe nn no np nq b">TopRatedViewController</code>本身:</p><h2 id="8608" class="nt mr it bd ms nu nv dn mw nw nx dp na li ny nz nc lm oa ob ne lq oc od ng oe bi translated">TopRatedViewController</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e0b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们有以下布局:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/ac2245829f8c6e1a6ba60e2332fc081d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nlceBqeF09ksoe_8O2S-Mw.png"/></div></div></figure><p id="3b24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们实现当用户点击<code class="fe nn no np nq b">showDetailButton</code>时我们将呈现的细节屏幕。</p><h2 id="dee9" class="nt mr it bd ms nu nv dn mw nw nx dp na li ny nz nc lm oa ob ne lq oc od ng oe bi translated">TopRatedDetailCoordinator</h2><p id="9225" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这里，一切几乎都是一样的——不同之处在于我们执行的是<code class="fe nn no np nq b">present</code>方法，而不是<code class="fe nn no np nq b">pushViewController</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="c921" class="nt mr it bd ms nu nv dn mw nw nx dp na li ny nz nc lm oa ob ne lq oc od ng oe bi translated">TopRatedDetailViewController</h2><p id="81ce" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">和前面的视图控制器一样，我们有一个<code class="fe nn no np nq b">coordinator</code>属性，在<code class="fe nn no np nq b">dismissDetailTapped</code>按钮处理程序中使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="31c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们有以下工作流程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/5bb7682d219b5e0cea239f7348cd81a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/1*Ky9EsbOAbZf0Qy4QMW0XQg.gif"/></div></figure><p id="2e51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">Search</code>工作流是相同的——让我们转而关注如何在<code class="fe nn no np nq b">History</code>屏幕中的协调员之间传递数据。</p><h2 id="b0e9" class="nt mr it bd ms nu nv dn mw nw nx dp na li ny nz nc lm oa ob ne lq oc od ng oe bi translated">历史项目</h2><p id="9d6f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们定义了一个非常简单的类来表示<code class="fe nn no np nq b">Model</code>，我们将把它从一个协调器传递给另一个协调器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="a240" class="nt mr it bd ms nu nv dn mw nw nx dp na li ny nz nc lm oa ob ne lq oc od ng oe bi translated">历史协调员</h2><p id="a41c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">就像之前一样，我们在<code class="fe nn no np nq b">start()</code>方法中实例化并推送一个全新的视图控制器到导航堆栈上:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="8221" class="nt mr it bd ms nu nv dn mw nw nx dp na li ny nz nc lm oa ob ne lq oc od ng oe bi translated">历史视图控制器</h2><p id="76a0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们创建一个视图控制器，显示包含我们的<code class="fe nn no np nq b">HistoryItem</code>对象的<code class="fe nn no np nq b">UITableView</code>。当我们选择一个特定的<code class="fe nn no np nq b">UITableViewCell</code>时，<code class="fe nn no np nq b">didSelectRow</code>方法被触发(其中我们捕获相应的<code class="fe nn no np nq b">HistoryItem</code>并将其传递给<code class="fe nn no np nq b">HistoryCoordinator</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="253a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们有以下布局:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/703ae48c8db0cf491ebc403f409cc12c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MIFGODLLrR0c-VKaQOVufA.png"/></div></div></figure><p id="f305" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们转到详细信息屏幕。</p><h2 id="f823" class="nt mr it bd ms nu nv dn mw nw nx dp na li ny nz nc lm oa ob ne lq oc od ng oe bi translated">历史详细协调员</h2><p id="c6e9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们可以看到除了标准的<code class="fe nn no np nq b">navigationController</code>，我们还有<code class="fe nn no np nq b">historyItemTitle</code>属性。</p><p id="15b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在<code class="fe nn no np nq b">start()</code>方法中将它赋给<code class="fe nn no np nq b">HistoryDetailViewController</code>自己的<code class="fe nn no np nq b">historyItemTitle</code>属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="9e36" class="nt mr it bd ms nu nv dn mw nw nx dp na li ny nz nc lm oa ob ne lq oc od ng oe bi translated">HistoryDetailViewController</h2><p id="74ef" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">该控制器仅在屏幕顶部显示一个标签，并在中间显示一个解散按钮:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9cb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们建立了以下工作流程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/da8964db747c47843264b17479fd923c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/1*DYtHum1YPhMOeQMPecmvUg.gif"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9b73" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">泄漏仪器</h1><p id="4486" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">内存管理呢？我们可以看到每个被解除的视图控制器和一个相应的协调器被使用Leaks工具解除分配:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/6526bf6231c431089f33cf4abb41185e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*be7N2CqE3L9Nn0EDI3ikAw.png"/></div></div></figure><p id="d9ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不熟悉泄漏仪器，我建议你看看我的文章，我在文章中详细解释了如何使用它:</p><div class="oi oj gp gr ok ol"><a href="https://medium.com/better-programming/diagnose-memory-leaks-using-xcode-instruments-5692a6458020" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">使用Xcode工具诊断内存泄漏</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">面临记忆问题时，leaks仪器可能会成为你最好的朋友</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9fba" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">资源</h1><p id="89f4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">该项目的源代码可以在GitHub上找到:</p><div class="oi oj gp gr ok ol"><a href="https://github.com/zafarivaev/CoordinatorDesignPattern" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">zafarivaev/CoordinatorDesignPattern</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">显示协调器设计模式实现的应用程序。为一篇中等文章写的…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">github.com</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz ks ol"/></div></div></a></div></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="895d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">包扎</h1><p id="fe0c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">对其他设计模式感兴趣？请随意查看我的其他相关作品:</p><div class="oi oj gp gr ok ol"><a href="https://medium.com/better-programming/implement-the-adapter-design-pattern-in-swift-165ac22bc868" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">在Swift中实施适配器设计模式</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">让不兼容的接口协同工作</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pb l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://medium.com/better-programming/implement-the-builder-design-pattern-in-swift-5-ff5bc6f2fc3d" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">在Swift 5中实施构建器设计模式</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">创建和使用自定义URLRequests和URLSessionDataTasks</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pc l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://medium.com/better-programming/implement-the-strategy-design-pattern-in-swift-5d9c3f221277" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">在Swift中实施战略设计模式</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">只需一行代码就可以在领域和核心数据之间切换</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pd l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://medium.com/better-programming/this-is-how-you-implement-mvc-architecture-in-2020-b39d65b4212f" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">新MVC:单一责任原则和委托</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">苹果的模型视图控制器，终于做对了</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pe l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://medium.com/better-programming/implement-a-model-view-presenter-architecture-in-swift-5-dfa21bbb8e0b" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">在Swift 5中实施模型-视图-演示者架构</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">使用领域数据库作为业务逻辑层</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pf l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://medium.com/better-programming/reactive-mvvm-and-the-coordinator-pattern-done-right-88248baf8ca5" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">反应式MVVM和协调模式做对了</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">使用Swift 5、RxSwift和RxDataSources</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pg l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://medium.com/better-programming/how-to-implement-viper-architecture-in-your-ios-app-rest-api-and-kingfisher-f494a0891c43" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">如何使用Swift 5在您的iOS应用中实现VIPER架构</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">使用方便的Xcode模板和参考报告</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="ph l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://medium.com/better-programming/implement-a-service-oriented-architecture-in-swift-5-fc70b8117616" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">在Swift 5中实施面向服务的架构</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">为什么只用MVC/MVVM/蝰蛇还不够</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pi l ow ox oy ou oz ks ol"/></div></div></a></div><p id="753f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>