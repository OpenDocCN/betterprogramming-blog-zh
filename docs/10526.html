<html>
<head>
<title>Thoughts On Event-Driven Architectures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于事件驱动架构的思考</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/thoughts-about-event-driven-architectures-6ce12d8d525e?source=collection_archive---------13-----------------------#2022-01-12">https://betterprogramming.pub/thoughts-about-event-driven-architectures-6ce12d8d525e?source=collection_archive---------13-----------------------#2022-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dcd3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解EDA的基础知识及其缺点</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b7a422a7448663a125d3e89609929906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4K-h9QRi6gSidOXO"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Marc-Olivier Jodoin 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6f0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近在思考事件驱动架构，它们的优点、缺点和最常见的用例。</p><p id="624b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们都熟悉微服务之间不同的通信风格，其中两个值得注意的是:基于消息传递和事件驱动通信的同步请求-响应调用和异步交互。</p><p id="b34b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，我们可以问自己的最明显的问题是，在什么情况下应用什么样的沟通方式？</p><p id="d064" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了回答这个问题，让我们简单回顾一下什么是事件驱动架构。</p><h1 id="b49b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">事件驱动架构基础</h1><p id="3fc3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当跨多个微服务传播变更时，通常使用异步消息传递和事件驱动的通信。</p><p id="9026" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最简单地说，当微服务“A”执行微服务“B”可能感兴趣的动作时，它向消息代理发布一个事件。遵循众所周知的发布-订阅设计模式，微服务“A”是发布者，微服务“B”是订阅者，它处理从代理收到的事件。</p><p id="218e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更明确地说，大多数消息代理支持两种消息传递模式:队列和发布/订阅。不同之处在于，对于队列，事件由一个消费者处理，而对于pub/subs，多个消费者可以订阅特定类型的事件，并在必要时消费它们。</p><p id="1164" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来自AMQ/JMS <a class="ae kv" href="https://www.tomitribe.com/blog/author/rmonson/" rel="noopener ugc nofollow" target="_blank">教程</a>的下图描述了这些差异:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/c0acd62ecb7dd6df65788b0dd3609581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*QSk7PWMeqQz-eQRVtD0oEg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">除非另有说明，所有插图均由作者创作</p></figure><p id="13db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们开始讨论事件驱动架构的优点和缺点之前，让我们定义一下“事件”是什么，以及它与“命令”有什么不同。</p><p id="6918" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在他精彩的关于事件驱动架构的意义的<a class="ae kv" href="https://www.youtube.com/watch?v=STKCRSUsyP0" rel="noopener ugc nofollow" target="_blank">演讲</a>中，Martin Fowler给出了一个“客户管理”服务的例子，该服务与下游的“保险报价”服务交互，通过直接调用它或发出“地址已更改”事件来触发重新报价流程，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/f43adec73f7384b6abb7067edb37855d.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*SUbvWLLa7K3kYS_vjrQMBw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">直接服务呼叫</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/e5d2cdfce7d91682809f5de9d2dcfafb.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*x2BA9mREBYa4YrbL5tIsaw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">事件通知</p></figure><p id="c3d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">马丁提出了一个有趣的问题:我们什么时候有<em class="ms">事件</em>或<em class="ms">命令</em>？</p><p id="eebf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在“<em class="ms">命令</em>语言的情况下，意图可能是“客户管理”服务指示“保险报价”服务重新报价保险。这意味着“客户管理”系统知道应该做什么，并且明确地告诉“报价”系统该做什么。</p><p id="dc7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们把它框定为一个“<em class="ms">事件”</em>时，语义发生了变化:“客户管理”系统通知了“地址变更”,并且不一定期望任何响应。</p><p id="34dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，归根结底，我们需要通过正确命名来准确描述系统的工作方式，然后将其转换为正确的交流方式。</p><p id="b222" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所看到的，基于事件的通信有许多潜在的好处:</p><ul class=""><li id="747f" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated"><strong class="ky ir">可扩展性— </strong>我们可以在“客户管理”服务不知道的情况下，通过监听<code class="fe nc nd ne nf b">addressChanged</code>事件来轻松连接其他服务。这是一种非常有吸引力的能力，尤其是如果我们想要集成的服务是由另一个团队、部门甚至公司开发的。</li><li id="c60c" class="mt mu iq ky b kz ng lc nh lf ni lj nj ln nk lr my mz na nb bi translated"><strong class="ky ir">弹性— </strong>我们可以通过添加或删除生产者和消费者来调整系统吞吐量，以处理所需的负载。这种能力对于可伸缩性和成本效益至关重要。</li><li id="87ef" class="mt mu iq ky b kz ng lc nh lf ni lj nj ln nk lr my mz na nb bi translated"><strong class="ky ir">弹性:</strong>如果一个事件消费者暂时停止工作，那么当消费者恢复工作时，事件可以被保留并重新消费。在同步请求-应答的情况下，我们需要开发全面的“重试”机制来实现这一点，而在事件驱动的情况下，大多数事件代理都提供现成的这种功能。</li><li id="ff6b" class="mt mu iq ky b kz ng lc nh lf ni lj nj ln nk lr my mz na nb bi translated"><strong class="ky ir">分析:</strong>由于服务之间的交互被生成并记录为“事件”，我们可以在感兴趣的地方添加日志记录，并从中提取有用的见解。我记得有一个案例，我和我的团队为每个事件添加了一个简单的日志消息，稍后由<a class="ae kv" href="https://logz.io/" rel="noopener ugc nofollow" target="_blank"> Logz.io </a>系统提交和处理，为我们提供系统使用统计和商业智能。</li><li id="ec1e" class="mt mu iq ky b kz ng lc nh lf ni lj nj ln nk lr my mz na nb bi translated"><strong class="ky ir">一致性:</strong>我们可以持久化事件流，并通过“重放”过去的事件来重建最新的系统状态。在此查看“事件采购”模式<a class="ae kv" href="https://martinfowler.com/eaaDev/EventSourcing.html" rel="noopener ugc nofollow" target="_blank">。</a></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/ece6b8130e8e6590d762784a0847c806.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*MFoVjUwmkzX1CZidyw0J0w.png"/></div></figure><p id="fd3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们都非常熟悉基于事件源的系统——版本控制:)</p><p id="7f55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里找到一个非常有趣的讨论。</p><h1 id="fbd9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">事件驱动架构(EDA)的缺点</h1><p id="d6a7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">好了，现在我们对EDA有了一些了解，让我们来谈谈在选择使用EDA时应该记住的权衡和缺点。</p><ul class=""><li id="6915" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">首先，根据我过去设计的相对较大的事件驱动系统的经验，很难理解系统中发生了什么。这是使用事件通知的服务之间的松散依赖的副作用:您实际上需要监视事件和系统行为，深入研究作为事件消费及其处理的结果而触发的流。这使得仅仅通过阅读代码来理解系统变得非常困难。</li><li id="4eff" class="mt mu iq ky b kz ng lc nh lf ni lj nj ln nk lr my mz na nb bi translated">EDA可能使之更加困难的另一件事是管理整个系统状态。有些情况下，我们可以选择在每个事件通知中将服务“A”的状态传递给服务“B ”,这样服务“B”就可以复制它，从而避免它们之间额外的通信。这种复制有许多好处，例如提高了性能、系统吞吐量及其可用性。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/d702fdd274f60b53e8a1f171c913a3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*6YX5szT4tPhPqr1E_CiVTw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">事件携带状态转移</p></figure><p id="d238" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这当然会迫使我们处理数据一致性问题、冲突解决和其他与数据相关的复杂性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/0e7291b603a6193d0665ff8b33cf6717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*ecC0bXkS8ty3OFhtTwewrQ.png"/></div></figure><ul class=""><li id="6180" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">接下来，我想让大家思考的是，我们实际上是如何组织我们的活动的。一方面，我们有一种足够普通的紧张感，另一方面，我们希望它们传达尽可能多的信息和背景。在“事件源”的情况下，我们需要能够通过重放我们持久保存的事件来重建应用程序状态，这反过来要求它们包含信息，这是这种“重放”所必需的。</li><li id="f433" class="mt mu iq ky b kz ng lc nh lf ni lj nj ln nk lr my mz na nb bi translated">你会问还会有什么问题？事件修改和版本控制。当我们改变一个方法名或者通过改变它的签名来重构它时，我们被迫遍历所有引用同一个方法的地方并改变它。事件不是这样的。对于事件，我们需要开始寻找相关队列和主题的所有订阅者，并逐个了解他们是否受到相同变更的影响。这在基于“事件源”的系统中尤其具有挑战性，因为用不同版本重放事件可能会使事情变得非常棘手。</li><li id="a514" class="mt mu iq ky b kz ng lc nh lf ni lj nj ln nk lr my mz na nb bi translated">最后，我想谈谈同步流。我从在实时应用程序(命令和控制系统)中使用事件驱动架构得出的结论是，当您有一个方法调用流，分布在不同的服务中，并且您真的希望确保该流以“全有或全无”的方式运行时，促进这种同步行为将非常困难。在这些情况下，我们可以转向常规的REST或gRPC调用，并将它们与系统的事件驱动部分结合起来。</li></ul><p id="02e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我要说的是，与任何其他模式一样，我们应该小心谨慎，只有当事件驱动架构适合手头问题的性质和需求时，才使用它。</p><p id="fbf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">否则，我们可能会以“工具法则”<a class="ae kv" href="https://en.wikipedia.org/wiki/Law_of_the_instrument#:~:text=From%20Wikipedia%2C%20the%20free%20encyclopedia,reliance%20on%20a%20familiar%20tool." rel="noopener ugc nofollow" target="_blank">陷阱</a>告终，该陷阱指出:</p><blockquote class="no np nq"><p id="5f1b" class="kw kx ms ky b kz la jr lb lc ld ju le nr lg lh li ns lk ll lm nt lo lp lq lr ij bi translated"><em class="iq">如果你只有一把锤子，你会把每个问题都看成钉子</em></p><p id="1c60" class="kw kx ms ky b kz la jr lb lc ld ju le nr lg lh li ns lk ll lm nt lo lp lq lr ij bi translated"><em class="iq">——亚伯拉罕·马斯洛</em></p></blockquote></div></div>    
</body>
</html>