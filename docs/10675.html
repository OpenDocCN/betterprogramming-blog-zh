<html>
<head>
<title>SwiftUI Tutorial: Basic Animations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI教程:基本动画</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-tutorial-basic-animations-edb78c97eb01?source=collection_archive---------5-----------------------#2022-01-21">https://betterprogramming.pub/swiftui-tutorial-basic-animations-edb78c97eb01?source=collection_archive---------5-----------------------#2022-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dc69" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解隐式和显式动画</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/521e943b4d10df59e38b9c7d475439bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xOV-13Qx7KhOH6CkZH-LJQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。</p></figure><p id="9ad5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SwiftUI通过自动制作任何将要发生的过渡动画来处理制作效果的所有复杂性。编写复杂代码来制作简单的动画过渡的日子已经过去了。框架自带足够的内置效果，可以执行不同的动画。</p><p id="c3ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本教程中，我们将通过理解如何使用隐式和显式来涵盖SwiftUI动画的基础。但是在做任何事情之前，请确保您有一个用于本教程的打开项目。</p><h1 id="d5d0" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">隐式动画</h1><p id="6f49" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">使用名为<code class="fe mr ms mt mu b">animation()</code> <em class="mv">的修改器。</em>通过将修改器附加到所需的视图，SwiftUI将根据指定的动画类型自动渲染动画。</p><p id="e90f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个在社交媒体上广泛使用的心型动画。这里发生的情况是，当点击心脏时，心脏会变红，并且变大。首先从系统图像创建一个心脏。</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="993b" class="na lv it mu b gy nb nc l nd ne">struct ContentView: View {<br/>    <br/>    @State private var heartChange = false<br/>    <br/>    var body: some View {<br/>        <br/>        ZStack {<br/>            <br/>            Image(systemName: heartChange ? "heart.fill" : "heart")<br/>                .font(.system(size: 100))<br/>                .foregroundColor(heartChange ? .red : .black)<br/>                .scaleEffect(heartChange ? 1.5 : 1.0)<br/>            <br/>        } //ZStack<br/>        .onTapGesture {<br/>            self.heartChange.toggle()<br/>        }<br/>        <br/>    } //body<br/>    <br/>} //ContentView</span></pre><p id="1434" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码中有两个部分需要讨论。首先是状态变量，它应该从false变为true，反之亦然。然后<code class="fe mr ms mt mu b">.onTapGesture</code>(这就是为什么我们有ZStack)将负责使用<em class="mv"> </em> <code class="fe mr ms mt mu b">toggle()</code>改变状态。</p><p id="324c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您运行该应用程序，点击心脏将改变对象的颜色和大小。但是对象到另一种形式的转换是没有动画的。因为有一件重要的事情我们还没有包含在这段代码中。这就是处理效果的动画修改器。在<code class="fe mr ms mt mu b">scaleEffect</code>下面添加这个修饰符:</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="e622" class="na lv it mu b gy nb nc l nd ne">.animation(.default, value: heartChange)</span></pre><p id="d064" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">再次运行应用程序，反复点击心脏。你会注意到过渡现在有效果了，这意味着动画开始工作了。</p><p id="4be6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在<a class="ae nf" href="https://github.com/athurion/SwiftUI-Tutorial-Basic-Animations/blob/main/ContentViewImplicitAnimation.swift" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上传了完整的源代码。</p><h1 id="86e1" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">明确的动画</h1><p id="90f7" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">工作方式不同，使用<code class="fe mr ms mt mu b">withAnimation()</code>函数代替修改器。它的作用是根据状态变化控制动画。</p><p id="045b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们为之前的例子创建一个明确的动画版本。像这样修改现有代码:</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="8313" class="na lv it mu b gy nb nc l nd ne">struct ContentView: View {<br/>    <br/>    @State private var heartChange = false<br/>    <br/>    var body: some View {<br/>        <br/>        ZStack {<br/>            <br/>            Image(systemName: heartChange ? "heart.fill" : "heart")<br/>                .font(.system(size: 100))<br/>                .foregroundColor(heartChange ? .red : .black)<br/>                .scaleEffect(heartChange ? 1.5 : 1.0)<br/>            <br/>        } //ZStack<br/>        .onTapGesture {<br/>            withAnimation(.default) {<br/>                self.heartChange.toggle()<br/>            }<br/>        }<br/>        <br/>    } //body<br/>    <br/>} //ContentView</span></pre><p id="1cf6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mr ms mt mu b">withAnimation()</code>是在<code class="fe mr ms mt mu b">.onTapGesture</code> <em class="mv">内部触发的功能。</em>运行应用程序将提供完全相同的结果。</p><h1 id="cd10" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">改变速度</h1><p id="f0a1" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">虽然SwiftUI中的动画渲染是自动的，但这并不意味着您不能定义动画的持续时间和延迟。在我们的隐式和显式示例中，我们只使用这样设置的<code class="fe mr ms mt mu b">.default</code>:慢速开始(<code class="fe mr ms mt mu b">easeIn</code>)、加速、慢速结束(<code class="fe mr ms mt mu b">easeOut</code>)。</p><p id="77a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以用下面的修饰符来指定持续时间。更换即可。默认为以下之一:</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="5364" class="na lv it mu b gy nb nc l nd ne">.easeIn(duration: //seconds) //Setup the duration of start slow<br/>.easeOut(duration: //seconds) //Setup the duration of ends slow<br/>.easeInOut(duration: //seconds) //Setup the duration of both </span></pre><p id="959b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，我们想将<code class="fe mr ms mt mu b">easeInOut</code>调整为1秒(默认为0.35秒左右)。</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="f759" class="na lv it mu b gy nb nc l nd ne">struct ContentView: View {<br/>    <br/>    @State private var heartChange = false<br/>    <br/>    var body: some View {<br/>        <br/>        ZStack {<br/>            <br/>            Image(systemName: heartChange ? "heart.fill" : "heart")<br/>                .font(.system(size: 100))<br/>                .foregroundColor(heartChange ? .red : .black)<br/>                .scaleEffect(heartChange ? 1.5 : 1.0)<br/>                .animation(.easeInOut(duration: 1), value: heartChange)<br/>            <br/>        } //ZStack<br/>        .onTapGesture {<br/>            self.heartChange.toggle()<br/>        }<br/>        <br/>    } //body<br/>    <br/>} //ContentView</span></pre><p id="4f3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理解这个例子也可以应用于显式动画是很重要的。当您运行应用程序时，您会注意到动画花费了更长的时间。</p><h1 id="8503" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">常用效果</h1><p id="7e77" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">为了方便起见，我将在显式动画中执行所有示例。明确地说，这也适用于隐式动画。</p><p id="029e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从快速放大然后反弹的动画开始。它叫做<code class="fe mr ms mt mu b">spring</code>。</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="744f" class="na lv it mu b gy nb nc l nd ne">withAnimation(.spring(response: 0.2, dampingFraction: 0.2, blendDuration: 0.2)) {<br/>    self.heartChange.toggle()<br/>}</span></pre><ul class=""><li id="cb28" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated"><code class="fe mr ms mt mu b">response</code> —弹簧刚度的持续时间。</li><li id="1d80" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><code class="fe mr ms mt mu b">dampingFraction</code> —拖动量。</li><li id="2c1f" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><code class="fe mr ms mt mu b">blendDuration</code> —以秒为单位的变化持续时间。</li></ul><p id="e58a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有另一个版本叫做<code class="fe mr ms mt mu b">interpolatingSpring</code>。这个有更明显的弹跳效果。</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="3256" class="na lv it mu b gy nb nc l nd ne">withAnimation(.interpolatingSpring(mass: 1, stiffness: 40, damping: 1, initialVelocity: 1)) {<br/>    self.heartChange.toggle()<br/>}</span></pre><ul class=""><li id="3783" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated"><code class="fe mr ms mt mu b">mass</code> —字面意思是附在弹簧上的质量。</li><li id="70f0" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><code class="fe mr ms mt mu b">stiffness</code> —字面意思是刚度。</li><li id="53db" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><code class="fe mr ms mt mu b">damping</code> —它将如何克服阻力。</li><li id="4814" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><code class="fe mr ms mt mu b">initialVelocity</code> —动画开始时的起始速度。</li></ul><p id="88bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mr ms mt mu b">linear</code>动画的工作原理类似于<code class="fe mr ms mt mu b">.default</code>。但是你可以调整动画的持续时间。</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="7966" class="na lv it mu b gy nb nc l nd ne">withAnimation(.linear(duration: 1)) {<br/>    self.heartChange.toggle()<br/>}</span></pre><p id="01cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过添加<code class="fe mr ms mt mu b">repeatCount</code> <strong class="la iu"> </strong>修改器并指定动画将重复的次数，可以使动画重复多次。</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="624d" class="na lv it mu b gy nb nc l nd ne">withAnimation(.linear(duration: 1).repeatCount(5)) {<br/>    self.heartChange.toggle()<br/>}}</span></pre><p id="e73f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者您可以使用<code class="fe mr ms mt mu b">repeatForever</code>让它无限循环:</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="dc72" class="na lv it mu b gy nb nc l nd ne">withAnimation(.linear(duration: 1).repeatForever()) {<br/>    self.heartChange.toggle()<br/>}}</span></pre><h1 id="f07f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">转换用户界面</h1><p id="da37" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我不想在没有做出能为你下一个app所用的东西的情况下结束这个教程。</p><p id="dc31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将创建一个按钮和背景，它将从以下内容进行转换:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/f4e0c4a0486baf5dd4b2d74fba038d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*TOPD0Zssc_QAaI7P69Zr9w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图二。默认按钮设计</p></figure><p id="bd3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">变成这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/dd53a80262f14beb9e7e14590f2f1041.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/format:webp/1*X1QT1AmHJJOpsjhKf3V5kg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3。按压后的按钮设计</p></figure><p id="1095" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当再次按下时，反之亦然。不仅如此。但是按钮按下后也会有闪烁的背景。事不宜迟，我们开始吧。</p><p id="24c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要两个变量。第一个处理按钮的状态，第二个处理闪烁的背景状态。将这些变量写入<code class="fe mr ms mt mu b">ContentView</code>:</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="86d7" class="na lv it mu b gy nb nc l nd ne">@State private var isRecording = false<br/>@State private var darkBackground = false</span></pre><p id="b63d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在主体内部，我们将创建一个嵌入ZStack的按钮。将这段代码写在body变量中。</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="40da" class="na lv it mu b gy nb nc l nd ne">ZStack {<br/>    <br/>    Color(darkBackground ? UIColor.black : UIColor.white)<br/>        .ignoresSafeArea(.all)<br/>    <br/>    Button(action: {<br/><br/>    }) {<br/>        Image(systemName: "video.and.waveform.fill")<br/>            .frame(<br/>                width: isRecording ? 100 : 300,<br/>                height: 100<br/>            )<br/>            .padding()<br/>            .font(.system(size: 50))<br/>            .foregroundColor(.white)<br/>            .background(isRecording ? .red : .blue)<br/>            .cornerRadius(isRecording ? .infinity : 40)<br/>    } //Button<br/>    <br/>} //ZStack</span></pre><p id="cc7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是按下按钮时会改变的修饰符:</p><ul class=""><li id="9023" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated"><code class="fe mr ms mt mu b">ZStack</code>颜色——默认为白色，将变为黑色。<code class="fe mr ms mt mu b">darkBackground</code>将会处理好这个状态。</li><li id="3fff" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><code class="fe mr ms mt mu b">frame</code>宽度——默认情况下按钮很长，按下后会变小。</li><li id="d7d9" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><code class="fe mr ms mt mu b">background</code> —按钮的背景色为蓝色，按下后变为红色。</li><li id="49f4" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><code class="fe mr ms mt mu b">cornerRadius</code> —默认为40，按下会变成圆形。我使用了<code class="fe mr ms mt mu b">.infinity</code> <em class="mv"> </em>来制作按钮圆形，不管框架大小如何。</li></ul><p id="5076" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了<code class="fe mr ms mt mu b">ZStack</code>颜色，其余修改器都是用<code class="fe mr ms mt mu b">isRecording</code>状态处理的。</p><p id="bf07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是时候附上动画了。在按钮操作下编写以下代码:</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="539d" class="na lv it mu b gy nb nc l nd ne">withAnimation(.spring()) {<br/>    self.isRecording.toggle()<br/>}<br/>withAnimation(.linear.repeatCount(6)) {<br/>    self.darkBackground.toggle()<br/>}</span></pre><p id="092b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，这里有两个独立的<code class="fe mr ms mt mu b">withAnimation</code>。这是因为我们需要执行两种不同的动画:变换按钮(<code class="fe mr ms mt mu b">isRecording</code>)和闪烁背景(<code class="fe mr ms mt mu b">darkBackground</code>)。这就是我们为此创建两个独立变量的原因。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="9472" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行应用程序并尝试按下按钮。现在，每次按下按钮时，按钮都会变形，同时背景会闪烁几秒钟。对自己出色完成的工作给予鼓励。</p><p id="1c0e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该实践的源代码可在<a class="ae nf" href="https://github.com/athurion/SwiftUI-Tutorial-Basic-Animations/blob/main/ContentViewTransformingUI.swift" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中获得。</p><p id="cea4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">愿法典与你同在。</p></div></div>    
</body>
</html>