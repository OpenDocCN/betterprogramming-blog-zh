<html>
<head>
<title>Handling SwiftUI Views Using Protocol-Oriented Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用面向协议的编程处理SwiftUI视图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/handle-swiftui-views-using-protocol-oriented-programming-d07741f58f4b?source=collection_archive---------7-----------------------#2022-05-31">https://betterprogramming.pub/handle-swiftui-views-using-protocol-oriented-programming-d07741f58f4b?source=collection_archive---------7-----------------------#2022-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b227" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编写可伸缩和可测试的代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cdbb0be5e7fff60fa4b920d2050c9746.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vG03Lq545uwsEn5Z"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@dmosipenko?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">德米特里·奥西彭科</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="76a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SwiftUI展示了一种更新、更快、更有效的构建视图的方式。声明式编程是一项令人惊叹的技术，SwiftUI以及Android上的Jetpack Compose和Flutter的Widget使视图构建比以往任何时候都更令人愉快。</p><p id="d6c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，构建视图并不是移动开发人员生活的唯一部分。在一个高度变化的环境中，设计一个好的、可伸缩的、有效的、能与任何类型的模型一起工作的UI是一个相当大的挑战。</p><h1 id="d0ce" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">一般是怎么处理的？</h1><p id="a722" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在大多数常见场景和简单案例中，有两个层:</p><ul class=""><li id="ac3c" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><strong class="ky ir"> Model </strong>:这是从存储库中获取的，可以是来自API的数据、来自数据库的记录或者来自多个服务的其他类型的数据。模型通常公开公开字段，很少公开方法。</li><li id="a2f5" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">视图:实现视图协议的结构——在最好的情况下，只有一个依赖关系。</li></ul><p id="852f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">依赖关系图如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/38bf7bab58099100d0866952b0421f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*plMbMPYKdYkh7_Tmzq6_-w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">视图-模型从属关系</p></figure><p id="397e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3d1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将模型直接注入视图是一个……有效的想法。不要误会我！我并不是说这是不正确的方法。当模型是原始类型时，这些解决方案工作得很好，例如:</p><ul class=""><li id="debb" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">线</li><li id="05f8" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">布尔代数学体系的</li><li id="321d" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">数字</li></ul><p id="c314" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将上述类型注入到视图中可以让我们避免多余的样板代码——比如额外的抽象层或者仅仅为了满足多余需求而创建的<code class="fe ng nh ni nj b">ViewModel</code>类。</p><p id="6e42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，当一个大视图被分成多个小视图时，改变一个特定的视图很容易，尤其是当它们不依赖于模型，而是依赖于原始类型时。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="5454" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二种方法是MVVM架构——在这里<a class="ae kv" href="https://www.hackingwithswift.com/books/ios-swiftui/introducing-mvvm-into-your-swiftui-project" rel="noopener ugc nofollow" target="_blank">有很好的描述。在这个架构中，大多数视图都有自己的<code class="fe ng nh ni nj b">ViewModel</code>。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/cb608b4c04903df81264da89e6aa3274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*lSqf7jzm1BqLOtURNXE4QQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">MVVM属地</p></figure><p id="b741" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">MVVM在模型和视图之间增加了一层T2。模型和视图对象与前一个例子没有什么不同，重要的区别在于要显示的数据是如何传递给视图的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7d31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这通常是解决视图层和模型层之间依赖问题的一个非常好的方法——并且被广泛使用。这种方法的最大优点是:</p><ul class=""><li id="9aeb" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><strong class="ky ir">层分离</strong>:清晰可见抽象负责什么，领域模型和UI之间没有依赖关系</li><li id="a629" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><strong class="ky ir">可测试性</strong>:视图模型通常容易测试</li><li id="85f6" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><strong class="ky ir">视图模型通信</strong>:发布者或代理可以从父视图模型传递到子视图模型，并在上层进行处理</li></ul><p id="ab92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但我也看到了一些缺点:</p><ul class=""><li id="faec" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><strong class="ky ir">不同种类的来源:</strong>只有一个模型被<code class="fe ng nh ni nj b">ViewModel</code>接受。这意味着一个类不是可扩展的，如果一个新的商业案例出现，它必须被重写。例如，一个额外的需求出现了，现在<code class="fe ng nh ni nj b">user</code>列表填充了用户模型和<code class="fe ng nh ni nj b">group</code>模型——这是一个完全不同的模型。</li><li id="64a0" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">样板代码和ViewModel实际上只不过是模型的包装——只是暴露了更多的字段供查看。</li><li id="8f03" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">在大多数情况下，为每个视图创建新的视图模型似乎是一个过度工程</li></ul><p id="37ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">知道了这些问题，我们就可以顺利地继续:</p><h1 id="3e9e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">面向协议的方法</h1><p id="1ccf" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我推荐介于MVVM和原始模型之间的东西——视图依赖性，以避免:</p><ul class=""><li id="fcba" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">许多视图模型文件——这些文件只描述了如何将模型转换成视图。</li></ul><p id="a0aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并确保:</p><ul class=""><li id="2010" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">良好的可测试性</li><li id="03eb" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">轻松采用不同种类的资源</li><li id="58cd" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">需要时从协议到视图模型的轻松转换</li></ul><p id="30a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">POP方法的主要目标是创建一个适应各种业务需求的适应性强且灵活的环境。它的关键部分是一个协议(通常称为<code class="fe ng nh ni nj b">DisplayableModel</code>，它描述了视图中需要显示的内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/07b5cab20de2cee646cd0ec1407d70bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*IbtoxxtLecA23VFl9Nbo3Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">面向协议的模型</p></figure><p id="07d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它可能看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a73b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ng nh ni nj b">Displayable</code>协议定义了视图所需的所有数据。这里，它是一个<code class="fe ng nh ni nj b">name</code>变量，描述每个用户行视图都有一个name文本元素，以及一个用于在屏幕上显示用户头像的<code class="fe ng nh ni nj b">ImageSource</code>。</p><p id="3b6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可显示模型不包含任何类型的业务逻辑。其中的属性对于正确显示视图至关重要。所以，<code class="fe ng nh ni nj b">DisplayableModel</code>的目标是尽可能的清晰和小巧。</p><p id="8389" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">视图将接受<code class="fe ng nh ni nj b">DisplayableModel</code>协议作为入口点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0d69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由<code class="fe ng nh ni nj b">UserRow</code>处理的每个模型都必须实现<code class="fe ng nh ni nj b">DisplayableModel</code>协议。</p><p id="17a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，必须在<code class="fe ng nh ni nj b">UserView</code>上显示的每个模型都必须实现一个<code class="fe ng nh ni nj b">DisplayableModel</code>协议。示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="cb24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">剩下的就看你的了。可显示的模型可能来自<code class="fe ng nh ni nj b">ViewModel</code>，或来自可观察的商店，或来自任何种类的来源。</p><p id="b555" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，使用这种技术，我们可以构建快速、可伸缩和适应性强的视图。</p><h1 id="bdc1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">视图模型示例</h1><p id="de1e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，我将展示上述方法是如何结合MVVM的。记住，你不仅要在同一个列表视图中显示<code class="fe ng nh ni nj b">user</code>，还要显示组。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><ol class=""><li id="19c4" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr nt mv mw mx bi translated">可显示的模型存储在一个数组中，并标记为<code class="fe ng nh ni nj b">Published</code></li><li id="2f70" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nt mv mw mx bi translated">当视图出现时，或者需要时，方法<code class="fe ng nh ni nj b">fetch</code>被调用</li><li id="3e57" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nt mv mw mx bi translated">在其中，<code class="fe ng nh ni nj b">ViewModel</code>异步获取两个不同的模型:<code class="fe ng nh ni nj b">Group</code>和<code class="fe ng nh ni nj b">User</code></li><li id="04a5" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nt mv mw mx bi translated">因为两者都实现了一个<code class="fe ng nh ni nj b">UserRowDisplayableModel</code>，所以它可以很容易地传递给published元素。</li></ol></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="f78d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">协议是Swift迄今为止最好的功能之一。它允许编写一个简单的，描述良好的，清晰的代码，有且只有一个容易理解的目的。</p><p id="1532" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我强烈建议将相关代码封装到一个协议中，以获得更好的可读性和更容易的测试。</p></div></div>    
</body>
</html>