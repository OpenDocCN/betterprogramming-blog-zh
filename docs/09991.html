<html>
<head>
<title>How To Design Pipelines and Sort by Dependencies in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中设计管道并按依赖关系排序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-design-pipelines-and-sort-by-dependencies-in-python-ed876495a826?source=collection_archive---------10-----------------------#2021-11-10">https://betterprogramming.pub/how-to-design-pipelines-and-sort-by-dependencies-in-python-ed876495a826?source=collection_archive---------10-----------------------#2021-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9a0a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用并行步骤对有向无环图(DAG)进行排序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/68a7b96e775a053818dffc0b3d70de8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*29cUKUe-3TTKCP2B"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ec14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我不得不研究如何从配置文件构建管道。</p><p id="7ffc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">棘手的部分总是如何简化如何编写配置文件，尤其是如何管理管道步骤的顺序并使其可读。我的目标是找到一种方法来对步骤进行排序，并优化可以并行完成的工作。</p><p id="20c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我看了看其他人在做什么，我喜欢用<code class="fe lv lw lx ly b">needs</code>关键字在<a class="ae ky" href="https://docs.github.com/en/actions/learn-github-actions/managing-complex-workflows#creating-dependent-jobs" rel="noopener ugc nofollow" target="_blank"> GitHub actions </a>中是如何做的。</p><p id="076d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的作用是每当你创建一个步骤时，你定义哪个(些)步骤应该在这个步骤之前发生。</p><p id="537d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以下面的例子为例:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="65e3" class="md me it ly b gy mf mg l mh mi">jobs:<br/>  <strong class="ly iu">Lint</strong>:<br/>    <em class="mj"># ...</em></span><span id="cfdb" class="md me it ly b gy mk mg l mh mi">  <strong class="ly iu">Coverage</strong>:<br/>    needs: <strong class="ly iu">Test</strong><br/>    <em class="mj"># ...</em></span><span id="3c7c" class="md me it ly b gy mk mg l mh mi"><strong class="ly iu">  Docs:<br/></strong>    needs: [ <strong class="ly iu">Coverage, Lint</strong> ]<strong class="ly iu"><br/></strong>    <em class="mj"># ...</em></span><span id="0cf9" class="md me it ly b gy mk mg l mh mi"><strong class="ly iu">  Benchmark:<br/>    </strong>needs: <strong class="ly iu">Coverage</strong><br/>    <em class="mj"># ...</em></span><span id="0728" class="md me it ly b gy mk mg l mh mi"><strong class="ly iu">  Test</strong>:<br/>    <em class="mj"># ...</em></span></pre><p id="82ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们直观地表示它，它看起来会像下面的管道。<br/>如你所见，我们有一些任务可以并行运行，而其他任务应该等待另一个任务的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/11428000f843f33e93098bdbeac18b6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UIAFeQS5Id1ODHJvfPzq-w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">管道的可视化版本</p></figure><h1 id="115e" class="mm me it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">有向无环图</h1><p id="8bd7" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">像这样的流水线可以用一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank">有向无环图(DAG) </a>来表示，这是一个没有有向循环的有向图。这意味着如果一个步骤完成了，你就不能回到这个步骤。</p><p id="5d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">知道您的管道是一个DAG，您就可以开始根据您拥有的依赖关系树对您的图进行排序。</p><h2 id="ab7e" class="md me it bd mn ni nj dn mr nk nl dp mv li nm nn mx lm no np mz lq nq nr nb ns bi translated">如何对DAG进行排序？</h2><p id="9209" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">对DAG进行排序的自然方式是使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Topological_sorting" rel="noopener ugc nofollow" target="_blank">拓扑排序</a>，但这不适用于并行步骤，因此我不得不放弃这个解决方案，转而使用自定义解决方案。</p><p id="a4f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们从在<code class="fe lv lw lx ly b">Dict</code>中创建依赖结构开始:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5fe0" class="md me it ly b gy mf mg l mh mi">dependencies = {<br/>    "<strong class="ly iu">Lint</strong>": [],<br/>    "<strong class="ly iu">Test</strong>": [],<br/>    "<strong class="ly iu">Coverage</strong>": ["<strong class="ly iu">Test</strong>"],<br/>    "<strong class="ly iu">Docs</strong>": ["<strong class="ly iu">Coverage</strong>", "<strong class="ly iu">Lint</strong>"],<br/>    "<strong class="ly iu">Benchmark</strong>": ["<strong class="ly iu">Coverage</strong>"],<br/>}</span></pre><p id="ec40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个<code class="fe lv lw lx ly b">job</code>，我们都有一个<code class="fe lv lw lx ly b">List</code>依赖项。<br/>在我们的例子中，这意味着<code class="fe lv lw lx ly b">Test</code>应该在运行<code class="fe lv lw lx ly b">Coverage</code>之前完成。</p><p id="2f2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个<code class="fe lv lw lx ly b">Dict</code>，我们现在可以使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://networkx.org/" rel="noopener ugc nofollow" target="_blank">networkx</a></code>将其转换为<code class="fe lv lw lx ly b">DiGraph</code>。</p><blockquote class="nt nu nv"><p id="56a6" class="kz la mj lb b lc ld ju le lf lg jx lh nw lj lk ll nx ln lo lp ny lr ls lt lu im bi translated">NetworkX是一个Python包，用于创建、操作和研究复杂网络的结构、动态和功能。—neuro.debian.net</p></blockquote><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e117" class="md me it ly b gy mf mg l mh mi">g = <strong class="ly iu">nx.DiGraph</strong>(dependencies)</span></pre><p id="3ff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你有了<code class="fe lv lw lx ly b">DiGraph</code>，我们可以排序了。为此，我们选取0度的节点，并对其进行迭代以找到下一步，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="d5c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在下面看到排序的完整代码。👇</p><p id="3e30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是排序的结果将如下所示:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="60ef" class="md me it ly b gy mf mg l mh mi"><em class="mj"># output result</em><br/>[<strong class="ly iu">['Lint', 'Test']</strong>, <strong class="ly iu">['Coverage']</strong>, <strong class="ly iu">['Docs', 'Benchmark']</strong>]</span></pre><h1 id="a117" class="mm me it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">♺检测周期</h1><p id="bf71" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">如前所述，为了能够对DAG进行排序，我们应该没有循环依赖。因为我们已经创建了一个<code class="fe lv lw lx ly b">networkx.DiGraph</code>，我们可以使用<code class="fe lv lw lx ly b">simple_cycles</code>函数来检测在你的<code class="fe lv lw lx ly b">dependencies</code>中是否有任何循环返回你的图的循环依赖列表。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="339b" class="md me it ly b gy mf mg l mh mi"><em class="mj"># detect cycling workflows</em><br/>cycles = list(<strong class="ly iu">nx.simple_cycles</strong>(g))<br/>if <strong class="ly iu">len(cycles) &gt; 0</strong>:<br/>    raise CyclingPipeline(cycles=cycles)</span></pre><p id="c284" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在知道我们没有循环依赖之后，是时候根据图对依赖进行排序了。</p><h1 id="85f9" class="mm me it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">👨‍💻完整源代码</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="e3e0" class="mm me it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">结论</h1><p id="73bf" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">有了这样的设计，配置对于编写它的人来说是超级容易的，因为你不必考虑所有事情的完整顺序；你只需要把你的注意力集中在你的舞步上。</p><p id="26d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由<code class="fe lv lw lx ly b">_sort_jobs</code>函数提供的输出顺序也被优化为并行运行任务，这使得你的输出更有性能。</p><p id="e7f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用它来安排您自己的管道，这对于CI工具来说是完美的，但是如果您必须编排多个服务，也是如此。</p><p id="443d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样的算法有很多用途。</p></div></div>    
</body>
</html>