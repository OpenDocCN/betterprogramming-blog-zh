<html>
<head>
<title>How JavaScript Works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript如何工作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-javascript-works-1706b9b66c4d?source=collection_archive---------0-----------------------#2019-09-02">https://betterprogramming.pub/how-javascript-works-1706b9b66c4d?source=collection_archive---------0-----------------------#2019-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="def5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么理解基本面是无价的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/458b2f2272ea33313af1fc096c34072c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K26vJpKbNvZds4vwL9l4VA.jpeg"/></div></div></figure><p id="6637" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能想知道为什么有人会在2019年写一篇关于核心JavaScript的长文。</p><p id="4ba3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是因为我相信，如果没有对基础知识的扎实理解，现在很容易迷失在JS生态系统中，并且几乎不可能探索更高级的主题。</p><p id="91e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理解JavaScript的工作原理会使阅读和编写代码变得更容易，更容易，并且让您专注于应用程序的逻辑，而不是与语言的语法斗争。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="6293" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">它是如何工作的？</h1><p id="beea" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">计算机不理解JavaScript，但浏览器理解。</p><p id="aba5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了处理网络请求、监听鼠标点击、解释HTML和CSS以在屏幕上绘制像素，浏览器还内置了JavaScript引擎。</p><p id="9f58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript引擎是一个程序，用比如说C++编写，它遍历所有的JavaScript代码，一个字符一个字符地，把它“转换”成计算机的CPU可以理解和执行的东西——<a class="ae mu" href="https://en.wikipedia.org/wiki/Machine_code" rel="noopener ugc nofollow" target="_blank">机器码</a>。</p><p id="18b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是同步发生的，意味着一次一行，按顺序进行。</p><p id="e885" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">他们这样做是因为机器码很难，也因为机器码指令在CPU制造商之间是不同的。</p><p id="c987" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，他们将所有这些麻烦从JavaScript开发人员那里抽象出来，否则，web开发将会更加困难，更加不受欢迎，我们也不会有像Medium这样的东西来编写像这样的文章(我现在可能正在睡觉)。</p><p id="88ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript引擎可以盲目地一遍又一遍地遍历JavaScript的每一行(参见<a class="ae mu" href="https://en.wikipedia.org/wiki/Interpreter_(computing)" rel="noopener ugc nofollow" target="_blank">解释器</a>)，或者它可以变得更聪明，检测经常被调用并总是产生相同结果的函数。</p><p id="77ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，它可以将这些编译成机器码一次，这样下次遇到它时，它就会运行已经编译好的代码，这样会快得多(参见<a class="ae mu" href="https://en.wikipedia.org/wiki/Just-in-time_compilation" rel="noopener ugc nofollow" target="_blank">即时编译</a>)。</p><p id="9896" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者，它可以提前将整个东西编译成机器码并执行它(参见<a class="ae mu" href="https://en.wikipedia.org/wiki/Compiler" rel="noopener ugc nofollow" target="_blank">编译器</a>)。</p><p id="5987" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">V8 就是这样一个JavaScript引擎，谷歌在2008年开源了这个引擎。2009年，一个叫Ryan Dahl的人有了用V8创建<a class="ae mu" href="https://en.wikipedia.org/wiki/Node.js" rel="noopener ugc nofollow" target="_blank"> Node.js </a>的想法，这是一个浏览器外的JavaScript运行时环境，这意味着该语言也可以用于服务器端应用。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="060b" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">函数执行上下文</h1><p id="bee8" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">像任何其他语言一样，JavaScript对于函数、变量、数据类型以及这些数据类型可以存储的确切值、它们在代码中的可访问位置和不可访问位置等都有自己的规则。</p><p id="e91c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些规则由一个名为<a class="ae mu" href="https://www.ecma-international.org/" rel="noopener ugc nofollow" target="_blank"> Ecma International </a>的标准组织定义，它们共同构成了语言规范文档(你可以在这里找到最新版本<a class="ae mu" href="https://www.ecma-international.org/publications/standards/Ecma-262.htm" rel="noopener ugc nofollow" target="_blank">)。</a></p><p id="eb05" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，当引擎将JavaScript代码转换为机器代码时，它需要考虑规范。</p><p id="f28a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果代码包含非法赋值，或者试图访问一个变量，而根据语言规范，该变量不应该从代码的特定部分访问，该怎么办？</p><p id="d330" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每次调用一个函数时，它都需要解决所有这些问题。它通过创建一个名为<em class="mv">执行上下文</em>的包装器来实现这一点。</p><p id="637e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了更具体并避免将来混淆，我将把这个<em class="mv">函数执行上下文称为</em>，因为每次调用一个函数都会创建一个。不要被这个术语吓倒，现在也不要想太多，稍后会详细说明。</p><p id="23e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只要记住它决定了一些事情，比如:“在那个特定的函数中哪些变量是可访问的，在它里面<code class="fe mw mx my mz b">this</code>的值是什么，在它里面声明了哪些变量和函数？”</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="cbd6" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">全局执行上下文</h1><p id="9a70" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">但是，并不是所有的JavaScript代码都在函数内部(尽管大部分都在函数内部)。</p><p id="f685" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">任何函数之外也可以有全局级别的代码，因此JavaScript引擎首先要做的事情之一就是创建一个<em class="mv">全局执行上下文。</em></p><p id="1cb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就像一个函数执行上下文，在全局级别上服务于相同的目的，但是它有一些特殊性。</p><p id="382f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，只有一个全局执行上下文，在执行开始时创建，所有JavaScript代码都在其中运行。</p><p id="6119" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">即使没有要执行的代码，全局执行上下文也会创建两个特定于它的东西:</p><ul class=""><li id="94c1" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">一个全局对象。当JavaScript在浏览器中运行时，这个对象就是<code class="fe mw mx my mz b">window</code>对象。当它在它之外运行时，就像Node.js的情况一样，它将类似于<code class="fe mw mx my mz b">global</code>。不过为了简单起见，我将在本文中使用<code class="fe mw mx my mz b">window</code>。</li><li id="59af" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">一个叫做<code class="fe mw mx my mz b">this</code>的特殊变量。</li></ul><p id="84e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在全局执行上下文中，并且只有在那里，<code class="fe mw mx my mz b">this</code>实际上等于全局对象<code class="fe mw mx my mz b">window</code>。基本上是参考了<code class="fe mw mx my mz b">window</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="bb95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">全局执行上下文和函数执行上下文之间的另一个微妙区别是，在全局级别声明的任何变量或函数(在任何函数之外)，都作为属性自动附加到<code class="fe mw mx my mz b">window</code>对象，并隐式附加到特殊变量<code class="fe mw mx my mz b">this</code>。</p><p id="473d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管函数也有特殊变量<code class="fe mw mx my mz b">this</code>，但这不会发生在函数执行上下文中。</p><p id="0a73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，如果我们有一个在全局级别声明的全局变量<code class="fe mw mx my mz b">foo</code>，下面的三个语句实际上都指向它。这同样适用于函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b80c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有的JavaScript内置变量和函数都附加在全局的<code class="fe mw mx my mz b">window</code>对象上:<code class="fe mw mx my mz b">setTimeout()</code>、<code class="fe mw mx my mz b">localStorage</code>、<code class="fe mw mx my mz b">scrollTo()</code>、<code class="fe mw mx my mz b">Math</code>、<code class="fe mw mx my mz b">fetch()</code>等。这就是为什么在代码中的任何地方都可以访问它们。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="8469" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">执行堆栈</h1><p id="da8c" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">我们知道，每次调用函数时，都会创建一个函数执行上下文。</p><p id="a2ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为即使是最简单的JavaScript程序也有相当多的函数调用，所以所有这些函数执行上下文都需要以某种方式进行管理。</p><p id="37cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1697" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当遇到函数<code class="fe mw mx my mz b">a()</code>的调用时，如上所述创建函数执行上下文，并执行函数内的代码。</p><p id="3c0b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当代码执行完成时(到达函数的<code class="fe mw mx my mz b">return</code>语句或封装<code class="fe mw mx my mz b">}</code>，函数<code class="fe mw mx my mz b">a()</code>的函数执行上下文被销毁。</p><p id="28fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，遇到对<code class="fe mw mx my mz b">b()</code>的调用，并对函数<code class="fe mw mx my mz b">b()</code>重复相同的过程。</p><p id="ec93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是这种情况很少发生，即使在非常简单的JavaScript程序中也是如此。大多数情况下，会有一些函数在其他函数中被调用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b3d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，为<code class="fe mw mx my mz b">a()</code>创建了一个函数执行上下文，但是在<code class="fe mw mx my mz b">a()</code>执行的中途，遇到了<code class="fe mw mx my mz b">b()</code>的调用。</p><p id="b5e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为<code class="fe mw mx my mz b">b()</code>创建了一个全新的函数执行上下文，但是没有破坏<code class="fe mw mx my mz b">a()</code>的执行上下文，因为它的代码没有被完全执行。</p><p id="d52c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着同时存在许多函数执行上下文。然而，在任何给定的时间，它们中只有一个真正在运行。</p><p id="5d10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了跟踪哪一个当前正在运行，使用了一个堆栈，其中当前运行的函数执行上下文位于堆栈的顶部。</p><p id="da84" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦它完成执行，它将从堆栈中弹出，下一个执行上下文的执行将继续，等等，直到执行堆栈为空。</p><p id="549e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个堆栈被称为<em class="mv">执行堆栈</em>，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/32fff2beeb4c6966e2527677f10aa288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VBlFoXDlOXi5JBs_9ocjow.png"/></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">JavaScript执行堆栈</p></figure><p id="bcf1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当执行堆栈为空时，我们之前讨论过的并且永远不会被销毁的全局执行上下文就变成了当前正在运行的执行上下文。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="5f36" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">事件队列</h1><p id="cd67" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">还记得我说过JavaScript引擎只是浏览器的一个组件，与渲染引擎或网络层并列吗？</p><p id="873b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些组件有内置的钩子，引擎用它来发起网络请求，在屏幕上画像素，或者监听鼠标点击。</p><p id="6c78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您在JavaScript中使用类似于<code class="fe mw mx my mz b">fetch</code>的东西来执行HTTP请求时，引擎实际上会将它传递给网络层。每当请求的响应到来时，网络层都会将其传递回JavaScript引擎。</p><p id="c15c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是这可能需要几秒钟的时间，那么在请求过程中JavaScript引擎会做什么呢？</p><p id="1456" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简单地停止执行任何代码，直到响应到来？继续执行剩下的代码，每当响应到来时，停止一切并执行回调？当回调结束时，从它停止的地方继续执行？</p><p id="f869" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以上都不是，尽管第一个可以通过使用<a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="noopener ugc nofollow" target="_blank"> await </a>来实现。</p><p id="c01d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在多线程语言中，这可以通过让一个线程在当前运行的执行上下文中执行代码，另一个线程执行事件的回调来处理。但是这对于JavaScript是不可能的，因为它是单线程的。</p><p id="40b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了理解这实际上是如何工作的，让我们考虑一下我们之前看到的<code class="fe mw mx my mz b">a()</code>和<code class="fe mw mx my mz b">b()</code>函数，但是添加了一个点击处理程序和一个HTTP请求处理程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e187" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript引擎从浏览器的其他组件接收到的任何事件，比如鼠标点击或网络响应，都不会被立即处理。</p><p id="f7e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript引擎此时可能正忙于执行代码，所以它会将事件放入一个队列中，称为<em class="mv">事件队列</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/43e5635fd03ac926da66a927d26475f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nk_77fgBqv8FL485rWvzHg.png"/></div></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">JavaScript事件队列</p></figure><p id="3cd0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经讨论了执行堆栈，以及一旦相应函数中的代码执行完毕，当前运行的函数执行上下文是如何从堆栈中弹出的。</p><p id="d558" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，下一个执行上下文继续执行，直到它结束，以此类推，直到堆栈为空，全局执行上下文成为当前运行的执行上下文。</p><p id="a91b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当有代码要在执行堆栈上执行时，事件队列中的事件会被忽略，因为引擎正忙于执行堆栈上的代码。</p><p id="a919" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只有当它完成，并且执行堆栈为空时，JavaScript引擎才会处理事件队列中的下一个事件(当然，如果有事件队列的话)，并调用它的处理程序。</p><p id="e89e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于这个处理程序是一个JavaScript函数，它将像处理<code class="fe mw mx my mz b">a()</code>和<code class="fe mw mx my mz b">b()</code>一样被处理，这意味着一个函数执行上下文被创建并被推送到执行堆栈上。</p><p id="8f9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果该处理程序依次调用另一个函数，则另一个函数执行上下文被创建并被推到堆栈顶部，依此类推。</p><p id="6d47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只有当执行堆栈再次为空时，JavaScript引擎才会再次检查事件队列中的新事件。</p><p id="73fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这同样适用于键盘和鼠标事件。当鼠标被单击时，JavaScript引擎将获得一个click事件，将其放入事件队列，并且仅在执行堆栈为空时执行其处理程序。</p><p id="2e1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过将以下代码复制粘贴到浏览器控制台中，您可以很容易地看到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9791" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mw mx my mz b">while</code>循环只是让引擎忙碌五秒钟，不用太担心。在这五秒钟内开始单击文档上的任何地方，您将看到控制台上没有记录任何内容。</p><p id="5134" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当五秒钟过后，执行堆栈为空，第一次单击的处理程序被调用。</p><p id="e80a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为这是一个函数，所以函数执行上下文被创建、推送到堆栈、执行并从堆栈中弹出。然后，调用第二次单击的处理程序，依此类推。</p><p id="f47e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实际上，<code class="fe mw mx my mz b">setTimeout()</code>(和<code class="fe mw mx my mz b">setInterval()</code>)也是如此。您提供给<code class="fe mw mx my mz b">setTimeout()</code>的处理程序实际上被放在事件队列中。</p><p id="25ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着，如果您将超时设置为<code class="fe mw mx my mz b">0</code>，但是在执行堆栈上有代码要执行，那么<code class="fe mw mx my mz b">setTimeout()</code>的处理程序将仅在堆栈为空时被调用，这可能是许多毫秒之后。</p><p id="b4a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这也是<code class="fe mw mx my mz b">setTimeout()</code>和<code class="fe mw mx my mz b">setInterval()</code>不是真正精确的原因之一。如果你不相信我的话，把下一个要点复制粘贴到你的浏览器控制台上。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7228" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:放入事件队列的代码被称为<em class="mv">异步</em>。这是不是一个好的术语是一个不同的话题，但人们就是这么称呼它的，所以我想你必须习惯它。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="058c" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">函数执行上下文步骤</h1><p id="9aca" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">现在我们已经熟悉了JavaScript程序的执行生命周期，让我们更深入地了解一下函数执行上下文是如何创建的。</p><p id="8dc7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它分两步进行:创建步骤和执行步骤。</p><p id="654c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建步骤“设置东西”以便代码可以被执行，而执行步骤实际上执行它。</p><p id="763f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在创作阶段，有两件事非常重要:</p><ul class=""><li id="de7f" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">范围确定了。</li><li id="5e8c" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">确定了<code class="fe mw mx my mz b">this</code>的值(我假设您已经熟悉JavaScript中的<code class="fe mw mx my mz b">this</code>关键字)。</li></ul><p id="4a3c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在接下来的两个相应部分中，将详细介绍其中的每一项。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="e2f5" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">范围和范围链</h1><p id="9407" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">作用域由给定函数中可访问的变量和函数组成，即使它们没有在函数本身中声明。</p><p id="9d8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript有<em class="mv">词法作用域</em>，这意味着作用域是根据代码中声明函数的位置来确定的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b501" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当到达上面的<code class="fe mw mx my mz b">console.log(foo)</code>时，JavaScript引擎将首先检查在<code class="fe mw mx my mz b">b()</code>的执行上下文的范围内是否有变量<code class="fe mw mx my mz b">foo</code>。</p><p id="0d64" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于没有声明，它将转到“父”执行上下文，也就是<code class="fe mw mx my mz b">a()</code>的执行上下文，因为<code class="fe mw mx my mz b">b()</code>是在<code class="fe mw mx my mz b">a()</code>中声明的。在这个执行上下文的作用域上，它找到<code class="fe mw mx my mz b">foo</code>，并打印它的值。</p><p id="0426" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们在<code class="fe mw mx my mz b">a()</code>外提取<code class="fe mw mx my mz b">b()</code>，像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="fe12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">会抛出一个<code class="fe mw mx my mz b">ReferenceError</code>，即使两者唯一的区别是声明<code class="fe mw mx my mz b">b()</code>的地方。</p><p id="3e8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mw mx my mz b">b()</code>的“父”作用域现在是全局执行上下文的作用域，因为它是在全局级别声明的，在任何函数之外，并且那里没有变量<code class="fe mw mx my mz b">foo</code>。</p><p id="9174" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我明白为什么这可能会令人困惑，因为如果你看看执行堆栈，它看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/32fff2beeb4c6966e2527677f10aa288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VBlFoXDlOXi5JBs_9ocjow.png"/></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">JavaScript执行堆栈</p></figure><p id="9fac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，很容易假设“父”执行上下文是堆栈中的下一个，在当前上下文之下。然而，事实并非如此。</p><p id="a73e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第一个例子中，<code class="fe mw mx my mz b">a()</code>的执行上下文实际上是<code class="fe mw mx my mz b">b()</code>的“父”执行上下文。不是因为<code class="fe mw mx my mz b">a()</code>恰好是执行堆栈中的下一项，就在<code class="fe mw mx my mz b">b()</code>的下面，而是因为<code class="fe mw mx my mz b">b()</code>是在<code class="fe mw mx my mz b">a()</code>内部声明的。</p><p id="cdc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第二个例子中，执行堆栈看起来是一样的，但是这次<code class="fe mw mx my mz b">b()</code>的“父”执行上下文是全局执行上下文，因为<code class="fe mw mx my mz b">b()</code>是在全局级别声明的。</p><p id="558a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只要记住:在哪里调用函数并不重要，重要的是在哪里声明它。</p><p id="5cbf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，如果在“父”执行上下文的范围内也找不到变量，会发生什么呢？</p><p id="edbb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，它将尝试在下一个“父”执行上下文的范围内找到它，这是以完全相同的方式确定的。</p><p id="e377" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果它也不在那里，它将尝试下一个，以此类推，直到最终到达全局执行上下文的范围。如果它在那里也找不到，就会抛出一个<code class="fe mw mx my mz b">ReferenceError</code>。</p><p id="49e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这被称为<em class="mv">范围链</em>，这正是下面的例子中发生的情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1bbe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它首先试图在<code class="fe mw mx my mz b">c()</code>的执行上下文的范围内找到<code class="fe mw mx my mz b">foo</code>，然后是<code class="fe mw mx my mz b">b()</code>，最后是<code class="fe mw mx my mz b">a()</code>，在那里找到它。</p><p id="ac06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:记住，它只是从<code class="fe mw mx my mz b">c()</code>到<code class="fe mw mx my mz b">b()</code>再到<code class="fe mw mx my mz b">a()</code>，因为它们是在对方内部声明的，而不是因为它们对应的执行上下文在执行堆栈中位于对方之上。</p><p id="12d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果它们不在另一个中声明，那么“父”执行上下文就会不同，如上所述。</p><p id="add4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，如果在<code class="fe mw mx my mz b">c()</code>或<code class="fe mw mx my mz b">b()</code>中有另一个变量<code class="fe mw mx my mz b">foo</code>，它的值将被记录到控制台，因为引擎一找到该变量就停止“寻找”“父”执行上下文。</p><p id="6d02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这同样适用于函数，不仅仅是变量，同样适用于全局变量，就像上面的<code class="fe mw mx my mz b">console</code>本身。</p><p id="0dc7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它将沿着作用域链向下(或者向上，这取决于你如何看待它)，寻找一个名为<code class="fe mw mx my mz b">console</code>的变量，并最终在全局执行上下文中找到它，附加到<code class="fe mw mx my mz b">window</code>对象。</p><p id="b23d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:尽管我在上面的例子中只使用了函数声明语法，但是作用域和作用域链对于在ES2015(也称为ES6)中引入的<a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">箭头函数</a>完全相同。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="272b" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">关闭</h1><p id="b6eb" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">闭包提供了从内部函数到外部函数范围的访问。</p><p id="3a54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，这并不是什么新东西，我只是在上面描述了它是如何通过作用域链实现的。</p><p id="59f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">闭包的特别之处在于，即使外部函数的代码被执行，它的执行上下文从执行堆栈中弹出，并被销毁，内部函数仍然有对外部函数范围的引用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">JavaScript闭包</p></figure><p id="3c37" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这正是上例中发生的情况。<code class="fe mw mx my mz b">b()</code>是在<code class="fe mw mx my mz b">a()</code>内部声明的，所以它可以通过作用域链从<code class="fe mw mx my mz b">a()</code>的作用域中访问<code class="fe mw mx my mz b">name</code>变量。</p><p id="ad84" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是它不仅可以访问它，还创建了一个闭包，这意味着它甚至可以在父函数<code class="fe mw mx my mz b">a()</code>返回后访问它。</p><p id="eb21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">变量<code class="fe mw mx my mz b">c</code>只是对内部函数<code class="fe mw mx my mz b">b()</code>的引用，所以最后一行代码实际上调用了内部函数<code class="fe mw mx my mz b">b()</code>。</p><p id="659b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">即使这发生在<code class="fe mw mx my mz b">b()</code>的外部函数<code class="fe mw mx my mz b">a()</code>返回很久之后，内部函数<code class="fe mw mx my mz b">b()</code>仍然可以访问父函数的范围。</p><p id="aee6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在这篇由Eric Elliott撰写的关于Medium的文章中阅读更多关于如何使用闭包的内容。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="8f35" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">这个的价值</h1><p id="b2d3" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">在执行上下文的创建步骤中确定的下一件事是<code class="fe mw mx my mz b">this</code>的值。</p><p id="51f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">恐怕这没有作用域那么简单，因为函数内部的<code class="fe mw mx my mz b">this</code>的值取决于函数是如何被调用的。更复杂的是，您可以“覆盖”默认行为。</p><p id="23b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我会尽量让解释简单明了，你可以在<a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank"> MDN </a>上找到关于这个话题的更详细的文章。</p><p id="ef82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，要看函数是不是用函数声明来声明的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2d2b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或箭头功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7332" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如上所述，两者确定的范围完全相同，但<code class="fe mw mx my mz b">this</code>的值不同。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="90cd" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">箭头功能</h1><p id="3564" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">我从简单的开始。在箭头函数的情况下，<code class="fe mw mx my mz b">this</code>的值是词法的，所以它的确定类似于范围的确定。</p><p id="8be5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">“父”执行上下文完全按照<em class="mv">作用域和作用域链</em>一节中的解释来确定，这取决于arrow函数的声明位置。</p><p id="c8c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mw mx my mz b">this</code>的值将与父执行上下文中的<code class="fe mw mx my mz b">this</code>的值相同，而父执行上下文中的值又是如本节所述确定的。</p><p id="b4c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以在下面的两个例子中看到这一点。</p><p id="583f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一个将记录<code class="fe mw mx my mz b">true</code>，而第二个记录<code class="fe mw mx my mz b">false</code>，即使在两种情况下<code class="fe mw mx my mz b">myArrowFunction</code>都在同一个地方被调用。两者之间唯一的区别是声明箭头函数<code class="fe mw mx my mz b">myArrowFunction</code>的地方。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">日志<code class="fe mw mx my mz b">true</code></p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">日志错误</p></figure><p id="739b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于<code class="fe mw mx my mz b">myArrowFunction</code>中<code class="fe mw mx my mz b">this</code>的值是词法的，所以在第一个例子中它将是<code class="fe mw mx my mz b">window</code>，因为它是在全局级别声明的，在任何函数或类之外。</p><p id="ff7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第二个例子中，<code class="fe mw mx my mz b">myArrowFunction</code>中<code class="fe mw mx my mz b">this</code>的值将是包装它的函数中<code class="fe mw mx my mz b">this</code>的值。</p><p id="3251" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将在本节的后面详细讨论这个值的具体值，但是现在，注意到它不是第一个例子中的<code class="fe mw mx my mz b">window</code>就足够了。</p><p id="3826" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记住:对于箭头函数，<code class="fe mw mx my mz b">this</code>的值是基于箭头函数在哪里被声明，而不是在哪里或者如何被调用。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="2e1a" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">函数声明</h1><p id="35a1" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">在这种情况下，事情并不那么简单，这正是为什么在ES2015中引入箭头功能的原因(或至少是其中之一)，但请相信我，几段时间后一切都会变得有意义。</p><p id="06f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了箭头函数(<code class="fe mw mx my mz b">const a = () =&gt; { … }</code>)和函数声明(<code class="fe mw mx my mz b">function a() { … }</code>)在语法上的区别之外，两者之间的主要区别是各自内部的<code class="fe mw mx my mz b">this</code>的值。</p><p id="5cb5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与arrow函数不同，函数声明中的<code class="fe mw mx my mz b">this</code>的值不是基于函数声明的位置按词法确定的。</p><p id="afab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是根据调用函数的方式来确定的。有几种方法可以调用函数:</p><ul class=""><li id="f3e5" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">简单调用:<code class="fe mw mx my mz b">myFunction()</code></li><li id="42cd" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">对象方法调用:<code class="fe mw mx my mz b">myObject.myFunction()</code></li><li id="a4cc" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">构造函数调用:<code class="fe mw mx my mz b">new myFunction()</code></li><li id="1412" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">DOM事件处理程序调用:<code class="fe mw mx my mz b">document.addEventListener(‘click’, myFunction)</code></li></ul><p id="796c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于每种类型的调用，<code class="fe mw mx my mz b">myFunction()</code>中的<code class="fe mw mx my mz b">this</code>的值是不同的，与<code class="fe mw mx my mz b">myFunction()</code>的声明位置无关，所以让我们一个一个地来看看它是如何工作的。</p><h2 id="0e37" class="nx ly it bd lz ny nz dn md oa ob dp mh ld oc od mj lh oe of ml ll og oh mn oi bi translated"><strong class="ak">简单调用</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f642" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简单调用就是简单地调用一个函数，就像上面的例子一样:只有函数名，前面没有任何字符，后面跟有<code class="fe mw mx my mz b">()</code>(当然，里面有任何可选的参数)。</p><p id="40b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在简单调用的情况下，函数中<code class="fe mw mx my mz b">this</code>的值总是全局的<code class="fe mw mx my mz b">this</code>，它又指向全局的<code class="fe mw mx my mz b">window</code>对象，如上面某一节所述。</p><p id="07f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样！但是请记住，这只适用于简单的调用；函数名后跟<code class="fe mw mx my mz b">()</code>。没有前置字符。</p><p id="4cdc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:因为简单函数调用中的值<code class="fe mw mx my mz b">this</code>实际上是对全局<code class="fe mw mx my mz b">window</code>对象的引用，所以在简单调用要调用的函数中使用<code class="fe mw mx my mz b">this</code>被认为是不好的做法。</p><p id="9559" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是因为函数内部任何附加到<code class="fe mw mx my mz b">this</code>的属性实际上都附加到了<code class="fe mw mx my mz b">window</code>对象上，变成了全局变量，这是很糟糕的做法。</p><p id="1215" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是为什么在<a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" rel="noopener ugc nofollow" target="_blank">严格模式</a>下，简单调用所调用的任何函数中<code class="fe mw mx my mz b">this</code>的值都是<code class="fe mw mx my mz b">undefined</code>，上面的例子会输出<code class="fe mw mx my mz b">false</code>。</p><h2 id="5da3" class="nx ly it bd lz ny nz dn md oa ob dp mh ld oc od mj lh oe of ml ll og oh mn oi bi translated"><strong class="ak">对象方法调用</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d8cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当一个对象的属性有一个函数作为它的值时，它被认为是该对象的一个方法，因此有术语<em class="mv">方法调用</em>。</p><p id="da50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当使用这种类型的调用时，函数中的值<code class="fe mw mx my mz b">this</code>将简单地指向调用方法的对象，在上面的例子中是<code class="fe mw mx my mz b">myObject</code>。</p><p id="2c76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:如果使用了arrow函数语法，而不是上面例子中的函数声明，那么arrow函数中的值<code class="fe mw mx my mz b">this</code>应该是全局<code class="fe mw mx my mz b">window</code>对象。</p><p id="76c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是因为它的父执行上下文应该是全局执行上下文。它是在对象内部声明的这一事实不会改变任何事情。</p><h2 id="083a" class="nx ly it bd lz ny nz dn md oa ob dp mh ld oc od mj lh oe of ml ll og oh mn oi bi translated"><strong class="ak">构造函数调用</strong></h2><p id="59b0" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">调用函数的另一种方式是在调用之前加上关键字<code class="fe mw mx my mz b">new</code>，如下例所示。</p><p id="d0ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当以这种方式调用时，函数将返回一个新的对象(即使它没有return语句)，函数内部的值<code class="fe mw mx my mz b">this</code>将指向那个新创建的对象。</p><p id="0d94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解释有点简单(更多关于<a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="noopener ugc nofollow" target="_blank"> MDN </a>，但重点是它会创建(或<em class="mv">构造</em>，因此<em class="mv">构造</em>)并返回一个<code class="fe mw mx my mz b">this</code>将在函数内部指向的对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e83c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:当在<code class="fe mw mx my mz b">class</code>上使用<code class="fe mw mx my mz b">new</code>关键字时也是如此，因为类实际上是特殊的函数，只有很小的区别。</p><p id="2b20" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:箭头函数不能用作构造函数。</p><h2 id="95c6" class="nx ly it bd lz ny nz dn md oa ob dp mh ld oc od mj lh oe of ml ll og oh mn oi bi translated"><strong class="ak"> DOM事件处理程序调用</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e570" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当作为DOM事件处理程序调用时，函数中的<code class="fe mw mx my mz b">this</code>的值将是事件所在的DOM元素。</p><p id="1a2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:在所有其他类型的调用中，我们自己调用函数。</p><p id="d228" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，在事件处理程序的情况下，我们不这样做，我们只传递一个对处理函数的引用。JavaScript引擎调用该函数，我们无法控制它如何执行。</p><h2 id="43cf" class="nx ly it bd lz ny nz dn md oa ob dp mh ld oc od mj lh oe of ml ll og oh mn oi bi translated"><strong class="ak">用自定义</strong> <code class="fe mw mx my mz b"><strong class="ak">this</strong></code> <strong class="ak">值</strong>调用</h2><p id="f3c1" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">通过使用<code class="fe mw mx my mz b">Function.prototype</code>中的<code class="fe mw mx my mz b">bind()</code>、<code class="fe mw mx my mz b">call()</code>或<code class="fe mw mx my mz b">apply()</code>调用函数，可以将函数中<code class="fe mw mx my mz b">this</code>的值显式设置为自定义值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4f9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的例子显示了这些是如何工作的。</p><p id="440a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mw mx my mz b">call()</code>和<code class="fe mw mx my mz b">apply()</code>非常相似，唯一的区别是<code class="fe mw mx my mz b">apply()</code>的函数参数是以数组的形式传递的。</p><p id="ac30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当<code class="fe mw mx my mz b">call()</code>和<code class="fe mw mx my mz b">apply()</code>实际调用函数时，将<code class="fe mw mx my mz b">this</code>的值设置为您作为第一个参数传入的值，<code class="fe mw mx my mz b">bind()</code>不会调用该函数。</p><p id="f662" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，它返回一个新函数，这个函数与使用了<code class="fe mw mx my mz b">bind()</code>的函数完全一样，但是<code class="fe mw mx my mz b">this</code>的值被设置为您作为参数传递给<code class="fe mw mx my mz b">bind()</code>的值。</p><p id="7763" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是为什么你在<code class="fe mw mx my mz b">a.bind(obj)</code>后看到<code class="fe mw mx my mz b">(5, 6)</code>，实际上是为了调用<code class="fe mw mx my mz b">bind()</code>返回的函数。</p><p id="b5bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe mw mx my mz b">bind()</code>的情况下，返回函数中<code class="fe mw mx my mz b">this</code>的值被永久绑定到作为<code class="fe mw mx my mz b">this</code>值传递的任何值(因此得名<code class="fe mw mx my mz b">bind()</code>)。</p><p id="1517" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无论使用哪种类型的调用，返回函数中的<code class="fe mw mx my mz b">this</code>值总是作为参数提供的值。只能用<code class="fe mw mx my mz b">call()</code>、<code class="fe mw mx my mz b">bind()</code>或<code class="fe mw mx my mz b">apply()</code>再次修改。</p><p id="7f5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面这段话几乎完全正确。当然，这个规则也有例外，这个例外就是构造函数调用。</p><p id="9ca2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当以这种方式调用一个函数时，通过将<code class="fe mw mx my mz b">new</code>关键字放在它的调用之前，函数内部的<code class="fe mw mx my mz b">this</code>的值将总是由调用返回的对象，即使<code class="fe mw mx my mz b">new</code>函数被赋予另一个带有<code class="fe mw mx my mz b">bind()</code>的<code class="fe mw mx my mz b">this</code>。</p><p id="45c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在下面的示例中检查这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6ebb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个例子，说明如何使用<code class="fe mw mx my mz b">bind()</code>来控制我们前面讨论的点击事件处理程序的<code class="fe mw mx my mz b">this</code>的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="efdd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:<code class="fe mw mx my mz b">bind()</code>、<code class="fe mw mx my mz b">call()</code>和<code class="fe mw mx my mz b">apply()</code>不能用于向箭头函数传递自定义<code class="fe mw mx my mz b">this</code>值。</p><h2 id="a943" class="nx ly it bd lz ny nz dn md oa ob dp mh ld oc od mj lh oe of ml ll og oh mn oi bi translated"><strong class="ak">箭头功能注释</strong></h2><p id="d7c6" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">您现在可以看到，这些函数声明的规则，即使相当简单，也会因为所有的特殊情况而导致混乱，并成为错误的来源。</p><p id="3b50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对函数调用方式的一个小小的改变将会改变函数中<code class="fe mw mx my mz b">this</code>的值。这可能导致整个连锁反应，这就是为什么了解这些规则以及它们如何影响你的代码是很重要的。</p><p id="a156" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是为什么编写JavaScript规范的人想出了箭头函数，其中<code class="fe mw mx my mz b">this</code>的值总是词法的，并且每次都是完全相同的，不管它们是如何被调用的。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="06a3" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">提升</h1><p id="fcf3" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">我之前提到过，当一个函数被调用时，JavaScript引擎会首先遍历代码，找出<code class="fe mw mx my mz b">this</code>的作用域和值，并识别函数体中声明的变量和函数。</p><p id="3b15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第一步(创建步骤)中，这些变量获得一个特殊值<code class="fe mw mx my mz b">undefined</code>，不管代码中给它们分配了什么实际值。</p><p id="bea9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只有在第二个步骤(执行步骤)中，它们才被赋予实际值，并且这仅在到达赋值行时发生。</p><p id="fe6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是为什么下面的JavaScript代码会记录<code class="fe mw mx my mz b">undefined</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2292" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在创建步骤中，变量<code class="fe mw mx my mz b">a</code>被识别，并被赋予特殊值<code class="fe mw mx my mz b">undefined</code>。</p><p id="a559" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，在执行步骤中，到达将<code class="fe mw mx my mz b">a</code>登录到控制台的那一行。<code class="fe mw mx my mz b">undefined</code>被记录，因为这是上一步中设置为<code class="fe mw mx my mz b">a</code>的值。</p><p id="8dcf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当到达给<code class="fe mw mx my mz b">a</code>赋值<code class="fe mw mx my mz b">1</code>的行时，<code class="fe mw mx my mz b">a</code>的值将变为<code class="fe mw mx my mz b">1</code>，但是<code class="fe mw mx my mz b">undefined</code>已经被记录到控制台。</p><p id="e008" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种效果叫做<em class="mv">提升</em>，就好像所有的变量声明都被提升到了代码的顶部。如你所见，这不是真的发生了什么，但这是用来描述它的术语。</p><p id="8543" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:这也会发生在箭头函数上，但不会发生在函数声明上。</p><p id="51e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在创建步骤中，函数没有被赋予特殊值<code class="fe mw mx my mz b">undefined</code>，而是将整个函数体放入内存中。这就是为什么一个函数甚至可以在声明之前就被调用，就像下面的例子，而且它会工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="dddd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:当试图访问一个根本没有定义的变量时，会抛出一个<code class="fe mw mx my mz b">ReferenceError: x is not defined</code>。所以，在“未定义”和“未定义”之间是有区别的，这可能有点令人困惑。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="2c67" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">结论</h1><p id="d155" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">我记得读过关于提升、范围、闭包等的文章。，当我阅读它们的时候，它们都是有意义的，但我总是会遇到一些奇怪的JavaScript行为，我无法解释。</p><p id="8d4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">问题是我总是一个一个地阅读每个概念。</p><p id="b86f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我试着理解更大的图景，比如JavaScript引擎本身。如何创建执行上下文并将其推送到执行堆栈上，事件队列如何工作，如何确定<code class="fe mw mx my mz b">this</code>和范围等。</p><p id="c7e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在那之后，一切都变得有意义了。我开始更早地发现潜在的问题，更快地识别错误的来源，并且对我的总体编码更加自信。</p><p id="7992" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望这篇文章对你也一样！</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="1ced" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">参考</h1><ul class=""><li id="6e81" class="na nb it kw b kx mp la mq ld oj lh ok ll ol lp nf ng nh ni bi translated"><a class="ae mu" href="https://www.amazon.com/Programming-JavaScript-Applications-Architecture-Libraries/dp/1491950293" rel="noopener ugc nofollow" target="_blank">编写JavaScript应用程序</a></li><li id="8ce9" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated"><a class="ae mu" href="https://www.udemy.com/understand-javascript/" rel="noopener ugc nofollow" target="_blank"> JavaScript:理解奇怪的部分</a>(前三个半小时免费<a class="ae mu" href="https://www.youtube.com/watch?v=Bv_5Zv5c-Ts" rel="noopener ugc nofollow" target="_blank">这里</a>)</li><li id="69bf" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated"><a class="ae mu" href="https://github.com/getify/You-Dont-Know-JS" rel="noopener ugc nofollow" target="_blank">你不知道JS </a></li></ul></div></div>    
</body>
</html>