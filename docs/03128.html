<html>
<head>
<title>How to Implement Docker Health Checks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何实施Docker健康检查</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/docker-healthchecks-eb744bfe3f3b?source=collection_archive---------1-----------------------#2020-01-22">https://betterprogramming.pub/docker-healthchecks-eb744bfe3f3b?source=collection_archive---------1-----------------------#2020-01-22</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="8b42" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">如何判断你的应用程序运行是否正常</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/6ce7e49805d56389c70aa88340d365da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Vi-7dLR4X-4iwSzkTb12A.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@edulauton?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">edu·劳顿</a>在<a class="ae kz" href="https://unsplash.com/s/photos/happy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c6b3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您的docker文件已创建，您的映像已构建，您已准备好投入生产。在一个快速的<code class="fe lw lx ly lz b">docker run</code>之后，你的容器启动了，你急切地等待你的应用程序开始服务请求。</p><p id="d5ce" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您等待几秒钟… <code class="fe lw lx ly lz b">docker ps</code>报告您的容器正在运行，但是没有得到任何服务。发生了什么事？</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="58cf" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">集装箱朝上的半真半假</h1><p id="15cb" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">让我们从使用以下Docker文件创建最简单的Docker容器开始:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="b910" class="ni mi iu lz b gz nj nk l nl nm">FROM nginx:1.17.7</span></pre><p id="589f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">构建映像，并启动一个容器:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="cf27" class="ni mi iu lz b gz nj nk l nl nm">docker build -t docker-health .<br/>docker run --rm --name docker-health -p 8080:80 docker-health</span></pre><p id="9389" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">NGINX容器现在正在本地端口8080上运行和侦听。继续前进，通过发出<code class="fe lw lx ly lz b">curl localhost:8080</code>来测试它，或者只是在你的浏览器中打开<code class="fe lw lx ly lz b"><a class="ae kz" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a></code>:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nn"><img src="../Images/7c842f478800826e7bce4324fa6ad79e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*43PgNfYGYt-PSGCkCVtOGw.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">NGINX在Docker中运行(图片由作者提供)</p></figure><p id="1a89" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该容器被报告为<code class="fe lw lx ly lz b">Up</code>，运行几秒钟:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj no"><img src="../Images/0d449a2371244acb4dba24a3ca3ef915.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eAEpK8RhBwnAc85vrZkffA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Docker进程正在运行(图片由作者提供)</p></figure><p id="6276" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是Docker检查什么来报告你的容器正在运行呢？让我们来看看容器内部运行的流程:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj np"><img src="../Images/d8051adda1719084063f2fb40ef249d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vHQ19O5tVxDset9Uq7IW7g.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">容器内运行的进程(图片由作者提供)</p></figure><p id="c171" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由Dockerfile的<code class="fe lw lx ly lz b">ENTRYPOINT</code>或<code class="fe lw lx ly lz b">CMD</code>启动的过程作为<br/> PID 1运行。PID是进程标识号的首字母缩写，在创建时自动分配给每个进程。在任何类似Unix的系统上，每个进程都有一个唯一的PID。在容器中作为PID 1运行的进程被特殊对待，因为它忽略任何信号，如<code class="fe lw lx ly lz b">SIGINT</code>或<code class="fe lw lx ly lz b">SIGTERM</code>，并且不会终止，除非它被编码为这样做。</p><p id="58ab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">只要PID 1启动并运行，Docker引擎将继续报告容器也启动并运行。即使您通过<code class="fe lw lx ly lz b">docker pause</code>暂停容器，容器仍然被报告为<code class="fe lw lx ly lz b">Up</code>，但是带有<code class="fe lw lx ly lz b">(Paused)</code>标志:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nq"><img src="../Images/77d7f9c2cefcae4a32157ce63f267fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7z1XjRv1Pnyr9k8HISCWQA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">暂停的容器(作者图片)</p></figure><p id="d2c8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Docker引擎并不真正知道，也不关心一个容器化的应用程序在做什么。但是我们有。</p><p id="27fa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们想象一下，我们基于NGINX的容器被创建来服务(除了别的以外)一些包含系统健康信息的静态<code class="fe lw lx ly lz b">system-status.txt</code>文件。当容器最初启动时，这个文件可能不会立即可用，因为我们可能会以其他方式创建它。让我们尝试在创建容器后不久获取这个文件:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nr"><img src="../Images/cfeb9ba52291831dec86277efda5c5ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*uYsd-M7gvslT9T_wlYNOMg.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">系统状态健康检查文件还不可用(图片由作者提供)</p></figure><p id="0139" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该文件不存在，我们得到了一个404错误。这是说集装箱好还是不好？毕竟，我们确实得到了NGINX的回复。</p><p id="f61c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然这里使用了一个简单的静态文件示例，但是您的检查很可能是关于应用程序API的可用性。考虑到您的容器化应用程序可能需要几秒钟才能启动并使其API可用，您的容器将被报告为<code class="fe lw lx ly lz b">Up</code>,尽管现在还不能提供任何服务。</p><p id="80f5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">类似地，如果应用程序遇到了导致其API端点不可访问的问题，PID可能仍在运行，但没有客户端能够与之交互。事实上，你最终得到了一个<code class="fe lw lx ly lz b">docker ps</code>报告运行良好的僵尸容器。</p><p id="5611" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果Docker提供一种方法来执行定制检查而不是它已经在做的过程检查，那不是更好吗？我们，应用程序开发人员，可以用定制的方式定义一个检查，本质上适合于在容器内运行的应用程序？</p><p id="79f9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看看如何做到这一点，并定义一个自定义的健康检查。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="0259" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">集装箱健康检查</h1><p id="5857" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">从1.12版本开始，Docker引擎提供了一种将自定义命令定义为健康检查的方法。虽然这项功能从2016年年中开始提供，但仍然看到许多Docker图像没有使用它，这令人非常惊讶。</p><p id="f76b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用<code class="fe lw lx ly lz b">HEALTHCHECK</code>指令在Dockerfile文件中指定自定义健康检查。check命令是在容器内部执行的，所以要确保它可用。至于它执行的检查类型，只要它返回适当的退出状态代码，它可以是您能想到的任何类型。根据Docker官方文档，这些退出代码可以是:</p><blockquote class="ns nt nu"><p id="9dc4" class="la lb nv lc b ld le jv lf lg lh jy li nw lk ll lm nx lo lp lq ny ls lt lu lv in bi translated">“0:成功-容器运行正常，可以使用了<br/> 1:不正常-容器工作不正常<br/> 2:保留-不使用此退出代码”</p></blockquote><p id="0bd8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在实践中，任何大于<code class="fe lw lx ly lz b">0</code>的状态代码似乎都工作正常，表明一个失败的容器。</p><p id="9c01" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们尝试重写上例中使用的Dockerfile，这次实现健康检查:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="07f3" class="ni mi iu lz b gz nj nk l nl nm">FROM nginx:1.17.7</span><span id="d3de" class="ni mi iu lz b gz nz nk l nl nm">RUN apt-get update &amp;&amp; apt-get install -y wget</span><span id="cda5" class="ni mi iu lz b gz nz nk l nl nm">HEALTHCHECK CMD wget -q --method=HEAD localhost/system-status.txt</span></pre><p id="cd85" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，Dockerfile补充了一个<code class="fe lw lx ly lz b">RUN</code>命令来安装用于定义健康检查的<code class="fe lw lx ly lz b">Wget</code>客户端。</p><p id="ab83" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">其次，定义了<code class="fe lw lx ly lz b">HEALTHCHECK</code>。健康检查包括一个调用，使用<code class="fe lw lx ly lz b">wget</code>获取定制<code class="fe lw lx ly lz b">system-status.txt</code>文件的特定URL。如果找到该文件，该命令的退出代码将是<code class="fe lw lx ly lz b">0</code>，如果没有找到，它将是<code class="fe lw lx ly lz b">8</code>(根据Wget的官方<a class="ae kz" href="https://www.gnu.org/software/wget/manual/html_node/Exit-Status.html" rel="noopener ugc nofollow" target="_blank">退出代码页</a>，表示“服务器发出错误响应”)。</p><h2 id="87a8" class="ni mi iu bd mj oa ob dn mn oc od dp mr lj oe of mt ln og oh mv lr oi oj mx ok bi translated">测试运行状况检查</h2><p id="1fd6" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">使用上面的扩展Dockerfile文件，让我们构建一个新的映像并重新运行容器:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ol"><img src="../Images/af6e004a401e2eb58ca0879321aaacf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQI76OoTYeruE8yIaRVvbw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在启用健康检查的情况下构建和运行容器(图片由作者提供)</p></figure><p id="0cbd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">发出<code class="fe lw lx ly lz b">docker ps</code>现在，我们可以看到Docker引擎除了报告其<code class="fe lw lx ly lz b">UP</code>状态之外，还报告了容器的健康状态:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj om"><img src="../Images/318011ffda78a9165e397300e6c8d656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n26snznVIbRKb5jdOlNlPw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">尚未执行健康检查的起始容器(图片由作者提供)</p></figure><p id="32fa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于健康检查的默认配置，健康检查命令不会立即执行，所以您看到的初始状态是<code class="fe lw lx ly lz b">(health: starting)</code>。这表明您的容器已经启动，但尚未执行任何健康检查。30秒后，运行状况检查命令被执行，由于<code class="fe lw lx ly lz b">system-status.txt</code>不存在，容器现在被报告为<code class="fe lw lx ly lz b">unhealthy</code>:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj on"><img src="../Images/d5f13c399ec10f70b046528acb4f5021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1WAwc2Uw-VLB3w1b-5_O0w.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">不健康的容器(图片由作者提供)</p></figure><p id="890a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们通过创建一个样本<code class="fe lw lx ly lz b">system-status.txt</code>来修复容器:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="9c1e" class="ni mi iu lz b gz nj nk l nl nm">docker exec docker-health sh -c \<br/>'echo OK &gt; /usr/share/nginx/html/system-status.txt'</span></pre><p id="c907" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在接下来的30秒内，集装箱应报告为<code class="fe lw lx ly lz b">healthy</code>:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oo"><img src="../Images/d8a0e85382ccd851b94398f0985fe516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QV5C01CRvkasQBx4yBm2Yg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">健康的容器(图片由作者提供)</p></figure><h2 id="a703" class="ni mi iu bd mj oa ob dn mn oc od dp mr lj oe of mt ln og oh mv lr oi oj mx ok bi translated">健康检查参数</h2><p id="0506" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated"><code class="fe lw lx ly lz b">HEALTHCHECK</code>命令也可用于四个不同的选项:</p><blockquote class="ns nt nu"><p id="7211" class="la lb nv lc b ld le jv lf lg lh jy li nw lk ll lm nx lo lp lq ny ls lt lu lv in bi translated">-间隔=持续时间(默认值:30秒)<br/> -超时=持续时间(默认值:30秒)<br/> -开始-周期=持续时间(默认值:0秒)<br/> -重试次数=N(默认值:3)</p></blockquote><p id="5bc7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">interval</code>选项指定执行健康检查前最初等待的秒数，以及后续健康检查的执行频率。</p><p id="2eb0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">timeout</code>选项指定了Docker等待您的健康检查命令返回退出代码的秒数，然后将它声明为失败(并将您的容器声明为<code class="fe lw lx ly lz b">unhealthy</code>)。</p><p id="f3d0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">start-period</code>选项指定容器需要引导的秒数。在此期间，退出代码大于零的健康检查不会将容器标记为<code class="fe lw lx ly lz b">unhealthy</code>；然而，<code class="fe lw lx ly lz b">0</code>的状态码会将集装箱标记为<code class="fe lw lx ly lz b">healthy</code>。</p><p id="c1a1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">retries</code>选项指定将容器声明为<code class="fe lw lx ly lz b">unhealthy</code>所需的连续健康检查失败次数。</p><h2 id="f018" class="ni mi iu bd mj oa ob dn mn oc od dp mr lj oe of mt ln og oh mv lr oi oj mx ok bi translated">码头工人群体行为</h2><p id="05b6" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">在Docker Swarm中运行容器时，健康检查的一个有用特性是，只要容器处于<code class="fe lw lx ly lz b">unhealthy</code>或<code class="fe lw lx ly lz b">(health: starting)</code>状态，路由就被禁用，根本没有请求到达容器。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="ddc2" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">结论</h1><p id="2952" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">启动容器并不一定意味着应用程序已经启动或者其行为符合设计。Docker健康检查可以非常容易地实施，并可以帮助您在不正常的行为成为真正的问题之前快速识别它。</p><p id="88eb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下次创建Dockerfile文件时，考虑添加健康检查。</p></div></div>    
</body>
</html>