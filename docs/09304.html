<html>
<head>
<title>How To Find and Fix Timing Attacks in Your Java Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何找到并修复Java代码中的计时攻击</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-find-and-fix-timing-attacks-in-your-java-code-11291a4f7cd?source=collection_archive---------9-----------------------#2021-08-09">https://betterprogramming.pub/how-to-find-and-fix-timing-attacks-in-your-java-code-11291a4f7cd?source=collection_archive---------9-----------------------#2021-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="abbf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用CodeQL防止计时攻击</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9aefc1d8993ea730cecec6cbde839c12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*00iw7xR6DjMYLeWY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jaelynnalexis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jaelynn Castillo </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2756" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">消息认证码(MAC)或数字签名可用于认证消息并保护其完整性。</p><p id="04b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查签名时，最好使用常数时间算法。否则，攻击者可以通过运行定时攻击来伪造任意消息的有效签名。</p><p id="5bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这是一种相当复杂的攻击，但有时它可能是一种真正的威胁。让我们看看如何在Java应用程序中使用CodeQL来检测这些问题。</p><h1 id="495c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">签署消息</h1><p id="8339" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下面是一个展示如何使用签名的示例场景。</p><p id="5c43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发送方和接收方共享密钥。发送者使用密钥计算消息上的签名。接下来，发送者发送消息和签名。然后，接收者计算接收到的消息的签名，并将计算出的签名与接收到的签名进行比较。如果签名匹配，接收者知道消息是由知道密钥的发送者创建的，因此接受消息。如果签名不匹配，接收者拒绝该消息。</p><p id="b81a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果攻击者不知道密钥，他们就不能为任意消息创建签名。因此，假设重放攻击超出范围，攻击者的消息将被拒绝。</p><h1 id="3b3e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">对签名的计时攻击</h1><p id="e046" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当应用程序不使用常数时间算法来验证签名时，就会出现问题。下面是一个易受攻击的代码示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f175" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当方法<code class="fe mu mv mw mx b">Arrays.equals()</code>发现输入的一个字节不同时，它立即返回<code class="fe mu mv mw mx b">false</code>。这意味着比较时间取决于数组的内容。这个小东西可能允许攻击者一个字节一个字节地伪造任意消息的有效签名。如果你想了解更多，请查看丹·博纳的视频。对了，如果你对密码学了解不多，但是有兴趣了解更多，我推荐他在Coursera 上的<a class="ae ky" href="https://www.coursera.org/learn/crypto" rel="noopener ugc nofollow" target="_blank">免费课程。</a></p><h1 id="80d9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">防止计时攻击</h1><p id="33b8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">它通常是一行代码:只需使用<code class="fe mu mv mw mx b">MessageDigest.isEqual()</code>来验证签名。将<code class="fe mu mv mw mx b">Arrays.equals()</code>替换为<code class="fe mu mv mw mx b">MessageDigest.isEqual()</code>即可修复上述代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="2625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管计时攻击很难运行，但为了安全起见，最好还是应用这样的单行修复程序来确保计时攻击是不可能的。看起来这样的修复不太可能引入严重的问题。也许您会注意到一些性能下降，因为<code class="fe mu mv mw mx b">MessageDigest.isEqual()</code>实际上检查了所有的字节，但是影响应该很小。</p><p id="38f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe mu mv mw mx b">Arrays.equals()</code>之外，还有许多其他方法不使用常数时间算法。例如，<code class="fe mu mv mw mx b">String.equals()</code>。这里CodeQL开始发挥作用。</p><h1 id="4d1c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">用CodeQL检测计时攻击</h1><p id="9f16" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你不知道，<a class="ae ky" href="https://securitylab.github.com/tools/codeql" rel="noopener ugc nofollow" target="_blank"> CodeQL </a>是一个代码分析引擎。它允许您为代码编写查询来检测各种问题，包括安全问题。</p><p id="a6d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我写了几个<a class="ae ky" href="https://github.com/github/codeql/pull/6006" rel="noopener ugc nofollow" target="_blank"> CodeQL查询，</a>可以检测Java应用程序中的计时攻击。</p><p id="97af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个查询<code class="fe mu mv mw mx b">PossibleTimingAttackAgainstSignature.ql</code>非常简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它查找以下数据流:</p><ol class=""><li id="455c" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">数据流的来源是可以产生签名的<code class="fe mu mv mw mx b">MAC</code>、<code class="fe mu mv mw mx b">Signature</code>和<code class="fe mu mv mw mx b">Cipher</code>类的方法。严格地说，<code class="fe mu mv mw mx b">Cipher</code>用于加密/解密，但是它也可以用于实现定制的MAC。所以这里也考虑了。此类源在<code class="fe mu mv mw mx b">CryptoOperationSource</code>类及其子类中定义。</li><li id="065f" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">接收器是不使用常数时间算法来比较输入的方法之一。它不仅包括<code class="fe mu mv mw mx b">Array.equals()</code>，还包括许多其他方法。<code class="fe mu mv mw mx b">NonConstantTimeComparisonSink</code>定义了这样的水槽。</li></ol><p id="b678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上在<code class="fe mu mv mw mx b">NonConstantTimeCryptoComparisonConfig</code>中实现，用于使用CodeQL跟踪数据流:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="3a21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格地说，对于一个成功的计时攻击来说，仅仅使用一个非常数时间算法来验证签名是不够的。此外，攻击者必须能够向接收者发送消息和签名。查询<code class="fe mu mv mw mx b">PossibleTimingAttackAgainstSignature.ql</code>没有检查这一点。但是第二个查询<code class="fe mu mv mw mx b">TimingAttackAgainstSignature.ql</code>会:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="cffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不同之处在于，它在源和接收器上都调用了<code class="fe mu mv mw mx b">includesUserInput()</code>谓词:</p><ol class=""><li id="e614" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated"><code class="fe mu mv mw mx b">CryptoOperationSource.includesUserInput()</code>检查不可信数据是否用于计算具有<code class="fe mu mv mw mx b">MAC</code>、<code class="fe mu mv mw mx b">Signature</code>或<code class="fe mu mv mw mx b">Cipher</code>类的签名。</li><li id="ffd5" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe mu mv mw mx b">NonConstantTimeComparisonSink.includesUserInput()</code>检查在比较过程中是否使用了不可信的数据。</li></ol><p id="9a58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得查询比第一个查询更严格，因此它应该产生更少的误报。但当然，它更有可能跳过一些真正的积极因素。</p><h1 id="9788" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><ul class=""><li id="d517" class="my mz it lb b lc mn lf mo li nm lm nn lq no lu np ne nf ng bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Message_authentication_code" rel="noopener ugc nofollow" target="_blank"> MAC </a></li><li id="b387" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu np ne nf ng bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Digital_signature" rel="noopener ugc nofollow" target="_blank">数字签名</a></li><li id="e73d" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu np ne nf ng bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Timing_attack" rel="noopener ugc nofollow" target="_blank">定时攻击</a></li></ul></div></div>    
</body>
</html>