<html>
<head>
<title>Bring Your Mathematics Up to Speed With vDSP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用vDSP加快您的数学运算速度</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/bring-your-mathematics-up-to-speed-with-vdsp-2a814d82c786?source=collection_archive---------11-----------------------#2020-03-12">https://betterprogramming.pub/bring-your-mathematics-up-to-speed-with-vdsp-2a814d82c786?source=collection_archive---------11-----------------------#2020-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="14ae" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Swift中更快的数学运算</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1a585e47671d96fcf946e6ec9bd964f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dSn_XyNrz671jZzy"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">阿什拉夫·阿里在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="bbe1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="4436" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">应用程序速度超快，响应速度真的很快……除非它们不是这样。每当你在代码中处理大规模计算时，总会有一个点让你的函数变慢，你会发现自己盯着代码想知道为什么这个简单的加法、乘法或除法会让一切都停止。我们的口袋里不是应该有超级计算机吗？</p><p id="f137" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">幸运的是，现代CPU实际上相当快。但是你，编码者，也需要知道如何以一种可以非常有效地执行的方式来呈现你的数学代码。为此，我们将利用(部分)自2003年就存在的<a class="ae kv" href="https://developer.apple.com/documentation/accelerate" rel="noopener ugc nofollow" target="_blank">加速</a>框架。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="0b70" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">一点历史</h1><p id="7624" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当然，早在2003年Swift还不存在，但存在的是Power Mac G4和G5。OG奶酪磨碎机和古老的风洞G4带来的东西之一是<a class="ae kv" href="https://en.wikipedia.org/wiki/AltiVec" rel="noopener ugc nofollow" target="_blank"> AltiVec </a>(也被苹果称为<em class="nb">速度引擎</em>)。开发人员对此的支持包含在Mac OS X 10.3 (Panther)中，因此每个人都可以通过使用Accelerate框架来利用它。每个人都在玩数学游戏，一片欢腾！</p><p id="e935" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后在2005年，苹果宣布他们将从IBM (PowerPC)转向英特尔(x86)。幸运的是，英特尔也有一些这些<a class="ae kv" href="https://en.wikipedia.org/wiki/SIMD" rel="noopener ugc nofollow" target="_blank"> SIMD </a>扩展，被称为<a class="ae kv" href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions" rel="noopener ugc nofollow" target="_blank"> SSE </a> (2、3和后来的4)，所以已经有一个支持库(Accelerate)来处理这些繁重的工作是一件好事。使用这个库的开发人员可以在新的体系结构上相当容易地运行他们的代码，而不必担心必须重写他们的代码来匹配新的指令集或体系结构。</p><p id="d663" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">几年后，在2007年，苹果推出了iPhone，同样采用了不同的CPU架构(ARM)。直到iOS 4才为这个平台提供了Accelerate，但是，在那个时候有一个抽象框架是很好的，我们作为开发人员，不必针对CPU细节。</p><p id="71a2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">所有这些导致了一个跨多个CPU架构使用的单一框架，并提供了一个可靠而快速的抽象层，因此我们不必为特定的架构编写特定的代码。耶！</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="4151" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">加速前进</h1><p id="9888" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">所以你的代码运行缓慢，但是我们想修复它，让它更快。许多开发人员立即开始将东西转移到后台队列，因为这就是我们所学的，对吗？永远不要阻塞主队列，在后台队列中执行开销很大的操作。这是明智的建议，但是后台队列中的慢速代码仍然会很慢。</p><p id="db76" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">大多数时候，计算速度慢的代码启动速度并不快(至少不明显)。有人会说，“嗯，对于这个50个数的数组，我们要执行这个和那个运算。”你要给它编程序。它似乎在合理的时间内运行。你非常自豪，因为你使用了像<code class="fe nc nd ne nf b">map</code>或<code class="fe nc nd ne nf b">zip</code>或<code class="fe nc nd ne nf b">reduce</code>这样花哨快捷的东西，所有东西都适合一个简洁(功能性)的一行程序或超级紧凑的<code class="fe nc nd ne nf b">for</code>循环。</p><p id="376d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，有人决定不应该是50个数字，而实际上是50，000个数字。你更新了号码，但是现在，哎呀，应用程序完全没有反应。不用担心——您只需将计算转移到后台队列中。问题解决了！但是在结果出来之前不得不等待五秒钟，感觉不是很令人满意。</p><p id="374f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">公平地说，算法的复杂性并不总是罪魁祸首。在Swift中，即使是对大量数字进行最基本的运算，似乎也要花费很长时间。Swift一定很慢吧？嗯，没有。但是Swift做了非常彻底的工作来保护您免受与无效内存访问相关的运行时错误。不幸的是，Swift中对整个数据结构的<code class="fe nc nd ne nf b">map</code>的下标访问和函数方法很慢。安全(有点)…但是很慢。</p><p id="9e1c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">输入vDSP。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="db7b" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">为什么选择vDSP？</h1><blockquote class="ng nh ni"><p id="7c9a" class="lo lp nb lq b lr mk jr lt lu ml ju lw nj mm lz ma nk mn md me nl mo mh mi mj ij bi translated">“vDSP框架包含一组高度优化的函数，用于大型阵列上的数字信号处理和通用运算。”</p><p id="4873" class="lo lp nb lq b lr mk jr lt lu ml ju lw nj mm lz ma nk mn md me nl mo mh mi mj ij bi translated">— <a class="ae kv" href="https://developer.apple.com/documentation/accelerate/vdsp" rel="noopener ugc nofollow" target="_blank">苹果文档</a></p></blockquote><p id="f4ac" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">vDSP是构成整个Accelerate框架的组件之一。这也是对该领域的一个相对温和的介绍，因为有许多方便的功能可以从Swift直接访问，而不必求助于手动内存管理和不安全的访问。</p><p id="a4f0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们来看一个例子。假设我们有一个包含50，000个类型为<code class="fe nc nd ne nf b">Double</code>的项目的数组，我们想要计算平均值。一个简单直接的解决方案是对数组求和，然后除以项目数:</p><pre class="kg kh ki kj gt nm nf nn no aw np bi"><span id="07a4" class="nq kx iq nf b gy nr ns l nt nu">let array = Array(stride(from: 0.0, to: 50000.0, by: 1))<br/>let mean = array.reduce(0.0, +) / Double(array.count)</span></pre><p id="cea0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">很公平，如果你在操场上测量，你会得到大约0.014秒(14毫秒)的平均计算时间，这取决于你的机器。不错——绝对不慢。但是，如果我们将其与vDSP替代方案进行对比，我们会得到不同的结果:</p><pre class="kg kh ki kj gt nm nf nn no aw np bi"><span id="314a" class="nq kx iq nf b gy nr ns l nt nu">import Accelerate</span><span id="b4e3" class="nq kx iq nf b gy nv ns l nt nu">let array = Array(stride(from: 0.0, to: 50000.0, by: 1))<br/>let mean = vDSP.mean(array)</span></pre><p id="7ab6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这一过程的平均计算时间比T2少一毫秒。您可能会认为这不公平，因为vDSP有一个专用的<code class="fe nc nd ne nf b">mean</code>函数，所以我们将改用两个数组的简单乘法:</p><pre class="kg kh ki kj gt nm nf nn no aw np bi"><span id="0ef6" class="nq kx iq nf b gy nr ns l nt nu">let array = Array(stride(from: 0.0, to: 50000.0, by: 1))<br/>let result = array.map { $0 * $0 }</span></pre><p id="69c9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对抗</p><pre class="kg kh ki kj gt nm nf nn no aw np bi"><span id="753f" class="nq kx iq nf b gy nr ns l nt nu">let array = Array(stride(from: 0.0, to: 50000.0, by: 1))<br/>let result = vDSP.multiply(array, array)</span></pre><p id="71a0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里的速度差异变得更加明显，Swifty代码需要大约350毫秒，vDSP代码需要<em class="nb">不到一毫秒</em>。供参考:所有基准测试都是在我的MacBook Pro (2018)上使用Xcode Playground运行的。</p><p id="a16d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">你可能会插话说，这些都是非常基本的功能，没有人会在他们的应用程序中使用那种计算。但是，如果您从事信号处理(例如，音频处理)或在大型数据集上执行数据分析，那么您很可能会在非常大的数字数组上执行非常基本的重复操作。尤其是如果你在一个(接近)实时的领域工作，比如音频处理，每一毫秒都会有很大的不同。</p><p id="13f9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><a class="ae kv" href="https://developer.apple.com/documentation/accelerate/using_vdsp_for_vector-based_arithmetic" rel="noopener ugc nofollow" target="_blank">苹果文档</a>有一个非常好的最简单的函数列表，处理加法/减法/乘法/除法，甚至包括经常使用的组合，例如，<a class="ae kv" href="https://developer.apple.com/documentation/accelerate/vdsp/3241049-multiply" rel="noopener ugc nofollow" target="_blank">将两个向量相加，然后乘以第三个</a>。这又导致了速度的提高，Swifty实施需要390毫秒，而vDSP代码平均需要不到一毫秒。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="2cc4" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">包扎</h1><p id="0997" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一旦你对vDSP可以执行的操作有了感觉，你就会更好地理解如何重写你的算法，并将其分解成可以在所有苹果平台上快速运行的组件。</p><p id="df36" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><a class="ae kv" href="https://developer.apple.com/documentation/accelerate/vdsp/arithmetic_operations" rel="noopener ugc nofollow" target="_blank">这个列表</a>提供了vDSP为您提供的所有方便的类函数的详尽概述，这些类函数使您可以非常轻松地抛出一个或多个(大型)数字数组并获得一个(快速！)结果回来了。</p><p id="7d8a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里需要注意的是，引用的静态函数仅在最新的iOS/macOS版本中可用(iOS 13+和macOS 10.15+)。如果你需要支持旧版本，仍然可以使用vDSP，但是你必须自己解决内存管理问题。例如，我们的乘法示例如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0f22" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这肯定没有新的静态函数好，但是同样快。此外，这些较旧的函数为您提供了更多的参数来调整，例如，实际处理的步距或项目数(如果您希望只对数据集的一部分执行计算，或者只对奇数/偶数元素执行计算)。</p><p id="db6a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了方便起见，我还添加了基准测试的操场代码。您可以简单地将它复制/粘贴到一个新的空操场上，并运行它来查看结果(平均运行时间将记录在控制台输出中)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="5ef8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">感谢您的阅读，希望这将鼓励您开始以不同的方式思考Swift中的计算，这样您就可以将它们分解为面向向量的操作，并帮助您极大地加快速度。</p></div></div>    
</body>
</html>