# 你可能想知道的 7 个高级 Python 概念

> 原文：<https://betterprogramming.pub/advanced-python-concepts-257076fa8e35>

## 多重继承、元类等等

![](img/4ceffc6ae0e6637a13395fdd2630e07c.png)

Chris Ried 在 [Unsplash](https://unsplash.com/s/photos/code?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍照。

Python 是世界上最流行的编程语言。大多数应用程序只需要 Python 多样化武库中的一小部分。但是，如果您想成为真正的 Python 专家，您也应该学习和掌握这些概念。

# 多重遗传

类可以从不止一个主类继承。它们可以从多个。这允许您结合多个基类的优势来创建一个非常多样化和强大的类。

多重遗传

虽然真正的多重继承(即从两个或更多充实的类继承)是不被认可的，但是从一个基类继承然后继承一些其他非常特殊的类是经常使用的。这些专门的类被称为 *mixins* ，通常只有在与某些基类结合时才起作用。

一个很好的使用 mixins 的框架是 [Django Rest 框架](https://www.django-rest-framework.org/)。您可以选择一个基本的`View`类，然后您可以轻松地添加 GET、POST 或 PUT mixins。

Django Rest 框架中的多重继承。来源: [Django Rest 框架](https://www.django-rest-framework.org/tutorial/3-class-based-views/)

`ListModelMixin` 和`CreateModelMixin` 将具有基于 Django 模型获取和更新数据库中正确数据的逻辑——并且只使用这两个单词进行继承。

需要记住的一点是，任何解析都是从左到右进行的。所以如果一个方法同时在`BaseClassA` 和`BaseClassB`中定义，那么它将从`BaseClassB` *、*中取最先定义的方法。这对于类中的任何`super()`调用都是一样的。这种方法解析是不鼓励继承多个扩展类的原因，因为它会造成很多混乱。保持一个基类和几个专门的混合。

# 邓德方法

Dunder 方法是以双下划线开始和结束的 Python 方法。这些有时也被称为魔术方法。你可以在文档中找到完整的列表[。](https://docs.python.org/3/reference/datamodel.html)

一些 dunder 方法是众所周知的，比如`__init__`或`__str__`。但是还有很多其他的值得一看。

## 打电话

`__call__`允许你执行一个对象作为一个函数。如果您有一些默认功能要在类中使用，或者当您想要互换使用方法和对象时，这将非常有用。

__call__ 提供舍入金额的函数元素示例

使用 call 方法，您可以将对对象属性的轻松访问与函数的简单使用结合起来。

## 经营者

您也可以覆盖任何您喜欢的运算符，如加、减、乘、除。还有幂、floored division、矩阵乘法、模(`*@*`)。也可以实现比较语句，如大于、小于或等于。最后，您有像`and`、`invert`和`or`这样的逻辑操作符。请记住，`__and__`、`__invert__`、*、*、`__or__`、*、*方法指的是按位`ands` ( `a & b`)、`inverts` ( `~a`)、`ors` ( `a | b`)。`and`、`not`和`or`语句会将对象转换为布尔值，然后对表达式求值。

操作员魔术方法

许多这些方法都有相应的`__r(method)__`实现。这在没有实现从左到右实现时使用。当我们做`5 + a`的时候，这个会被调用。这就是为什么重要的不是出错而是返回`NotImplemented`。类似的事情也存在于`__i(method)__`中，例如`a += 5`中的计算将在适当的位置完成。

重写这些神奇的方法在图书馆中非常流行。在 NumPy 中，矩阵覆盖了标准实现，提供了矩阵运算的强大而简洁的用法。在 Django 中，or 和 ands 可以用来组合`QuerySets` or 过滤器。

NumPy 和 Django——魔法方法的使用

# 发电机

生成器是可以迭代的对象。最常见的例子是 range 函数。使用生成器的好处是，您不需要将整个数据结构保存在内存中。生成器只是跟踪需要什么来提供下一个值。

发电机有两种类型。第一类是包含`yield` 语句的函数。第二种类型是已经实现了`__iter__` 和`__next__`方法的对象。

任何包含`yield` 语句的函数都将成为生成器。迭代函数将执行函数，直到执行完`yield` 语句，并返回第一个值。对于第二个值，它将从关键字继续，直到下一个`yield`。这种情况会一直发生，直到函数结束或出现`StopIteration`错误。

函数生成器

基于对象的迭代器需要两种方法才能工作:`__iter__` 和`__next__`。`__iter__`会初始化迭代，需要返回生成器(一般是自身)。`__next__`将被调用以获取下一个值。

对象生成器

对于发电机，你必须记住两件事。一旦迭代，它们必须再次初始化。您不能使用它们来迭代两次。其次，您也可以使用内置的`next` 函数手动迭代它们。

# 上下文管理器

每个有自尊心的 Python 开发者都知道他们需要如何处理文件。要么在打开文件后确保将其关闭，要么使用`with` 语句。`with` 语句称为上下文管理器。它可以在任何时候使用，当您需要在启动时进行初始化，或者在停止使用后进行清理——特别是当发生错误时也需要进行清理。

创建自己的上下文管理器很容易。您需要实现`__enter__` 和`__exit__` dunder 方法。然后你可以使用`with`声明来确保你安全地清理干净。enter 方法返回的值被赋予`as` 语句。

上下文管理器

这对于 I/O 操作非常有用，因为您希望确保在之后关闭已使用的资源。这将避免悬空连接和打开文件。

最后，exit 方法还可以处理引发的错误。类型、值和引用都是错误信息。您可以使用这些来处理异常。如果从 exit 方法返回一个`True`值，Python 将不会再次引发异常，并照常继续。

如果使用`contextlib.contextmanager`装饰器，生成器函数也可以用作带有`yield`关键字的上下文管理器。但我会让你自己去想。

# 阿辛西奥

Python 库允许你的代码异步运行吗？在开始之前，请确保了解线程、异步和多处理器之间的区别。我建议阅读[这篇文章](/which-should-you-use-asynchronous-programming-or-multi-threading-7435ec9adc8e)。简而言之，`asyncio`允许您在等待慢速操作时处理其他东西(通常是 IO、数据库或网络)。如果没有这些操作，`asyncio`不会提高代码性能。

实现`asyncio`非常容易。通过将`async`放在定义前面，您可以使任何函数异步。当您调用该函数时，它将返回一个`Future`对象。为了得到未来的结果，你需要`await`它。Python 将通过在等待时执行其他代码来调度`Future`对象的正确执行。

阿辛西奥

这里，我们从数据库中得到一些记录。只要我们有一个兼容`asyncio`的数据库，它就能够并行获取记录。我们先初始化所有的请求，然后再处理它们。当代码等待一行时，它已经请求下一行，依此类推。

作为对比，我们也有一个用`await`做列表理解的烂例子。这不会提高性能，因为事件循环会等到获取上一条记录后再请求下一条记录。所以一定要使用`gather`或者类似的方法来提高性能。

随着`asyncio`而来的是一些额外的 under 方法。您可以实现`await`魔法方法来使一个对象变得可唤醒。对于异步上下文管理器，可以使用`__aenter__` 和`__aexit__` ，对于异步迭代器，可以实现`__aiter__`和`__anext__`。

# __new__ 和对象初始化

在`__init__`之前，每当您创建一个类的新实例时，就会调用`__new__` dunder 类方法。它是一个类方法，应该返回该类的一个实例。您可以控制创建类中的对象时返回的实例。你甚至可以返回另一个类对象！`__init__` 将在你返回的实例上被调用。

新邓德方法

虽然经常是非传统的，甚至有争议，这种方法确实有它的用途。最常见的例子是单例实现。使用类作为基类将确保一次只初始化其中一个。单例也可以用其他方式强制执行，但是我觉得`__new__` 方法提供了一个非常方便的实现。

第二个例子类似于其他语言中的工厂模式。基于输入，新方法可以返回适当的类。和前面的例子一样，工厂对象或静态函数也可以产生相同的结果。但是我发现新方法对于同样的问题是一个非常干净简洁的解决方案。

# 元类

元类将类向前推进了一步。它们允许你动态地调整你的类的属性或方法。文本不能公平对待元类，所以这里有一个例子:

环境的元类

`Environment`类将在一个有用的类中加载环境变量。它可以很好地处理输入提示，并避免使用相同的代码一次又一次地加载环境变量。您甚至可以设置默认值或使用它将值转换为正确的类型！

要定义一个元类，需要用命名继承来设置它。新函数的输出必须是一个类(它是一个元类实例)。它将定义类是什么以及它的行为方式。

输入参数是:

*   元类(因为默认情况下`__new__`是一个类方法)
*   (非元)类的名称
*   (非元)类的子类/基
*   非元类的命名空间

名称空间是这里有趣的部分。它将包含在(非元)类上定义的所有字段，如果它们有值的话。它还提供一些其他信息，如注释。这里，我们使用注释将环境变量设置为类属性。通过一些额外的逻辑，您还可以将它们转换为正确的类型或引发适当的错误。

再举一个例子，Django 在它的模型上使用它来将模型属性转换成数据库中的相关值。Pydantic 使用类似的方法来检索其模型的注释。

不过，非常重要的一点是:元类的 new 方法会在类定义后立即执行，而不是在每次对象初始化时执行。所以要确保你的类是完整的，并且元类不需要额外的信息。

# 结论

并非所有这些都同样有用。尤其是元类并不常见，这是有充分理由的。你可以成为一个严肃的程序员，而不需要深入了解所有这些概念。

但是我认为这篇文章为你提供了一些选择，有时可以做得更好。更深层次地理解 Python 可以让你理解正在发生的事情，你也将能够更好地理解一些大量使用这些高级方法的高级库(例如 Django、SQLAlchemy 和 Pydantic)。