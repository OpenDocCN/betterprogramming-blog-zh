<html>
<head>
<title>Getting Started With Docker in 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2021年Docker入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-docker-in-2021-8df187f5979d?source=collection_archive---------7-----------------------#2021-04-14">https://betterprogramming.pub/getting-started-with-docker-in-2021-8df187f5979d?source=collection_archive---------7-----------------------#2021-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="146d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于Docker你需要知道的一切</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4db90ccb875894c80c0e48d47594dd66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R-b79MxbTL-CU2JZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">托德·克雷文在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="1d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的几年里，Docker一直在扰乱开发和DevOps领域。很多人认为Docker是一种编程语言或框架。它不是。Docker是一个用于构建、运输和运行容器的开源平台。</p><p id="33e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个允许你管理图像和容器的工具。因此，在介绍Docker之前，我们最好先了解一下容器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1f50" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">容器</h1><p id="c553" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://www.docker.com/why-docker" rel="noopener ugc nofollow" target="_blank">根据Docker </a>的说法，“容器是一种标准化的软件单元，允许开发者将他们的应用程序与环境隔离开来。”通过使用容器，你不再需要担心你的应用程序之间的相互依赖。一个应用程序需要的每一个依赖项都可以安装并隔离在一个容器中。此外，我们可以保证在一个容器中运行的应用程序也可以在其他容器中运行。</p><h2 id="d7d1" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">使用容器的优点</h2><p id="5cab" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">那么，我们为什么还要使用容器呢？有什么好处？好吧，简单回答这个问题，隔离和限制。</p><p id="a8eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用容器，我们可以将特定的应用程序与主机(我们使用Docker的机器)中的其他组件隔离开来。默认情况下，容器不能访问主机的任何存储，反之亦然。隔离和限制行为解决了很多事情，但是让我们关注两件主要的事情:依赖性冲突和限制恶意软件的损害。</p><h2 id="cebd" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">避免依赖冲突</h2><p id="d8b8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我很确定每个人都经历过个人电脑上的依赖冲突。当你在你的电脑上安装了大量的软件时，这些软件之间的依赖关系就有可能发生冲突。</p><p id="f236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您希望安装软件A和软件B。软件A要求您在PC中安装Python 2.1，而软件B要求Python 2.3。当你安装软件A时，它可以完美地工作。但是在你安装了软件B之后，你的电脑用2.3版本替换了Python 2.1。因为Python 2.3和2.1的一些特性不同，所以软件A可能不再工作了。这种事情也经常发生在生产服务器中。</p><p id="c88a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让一切都完美地工作，您需要解决依赖性冲突。</p><p id="dc11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过在应用系统中使用容器来避免依赖冲突。容器是相互隔离的，甚至与它们的主机也是隔离的，所以依赖冲突是不可能的。</p><h2 id="c58d" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">限制病毒的危害</h2><p id="bfd1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">不管是不是意外，你使用的一些软件可能含有病毒。如果带有病毒的软件在没有使用任何资源隔离的情况下运行，它将能够访问整个主机。但是，如果它在容器中运行，它将不能访问任何超出允许范围的内容。正因为如此，你可以把一个容器想象成一个里面正在运行的进程的监狱。在容器内，病毒将无法访问容器外的文件。它也不容易访问硬件资源(CPU和内存),因为容器也会限制它们使用的硬件资源。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5eba" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">容器与虚拟机</h1><p id="7bcb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你已经做了一段时间的开发人员，你可能听说过甚至使用过虚拟机。容器和虚拟机非常相似。它们既隔离又限制了其中的一个过程。那么，为什么使用容器而不是虚拟机呢？</p><p id="8a7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虚拟机是一种软件，它在其上托管整个操作系统，并在称为虚拟机管理程序的物理机器上运行。同时，容器提供了一个运行在其主机操作系统之上的隔离空间。</p><p id="b4f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容器最重要的优势是初始化新实例的速度。创建一个虚拟机需要几分钟，因为您需要创建一个虚拟磁盘、安装操作系统、分配资源等。容器使用主机的操作系统、磁盘、内存、CPU等。这使得创建容器非常快速(通常几秒钟)。</p><p id="5ec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个优势是便携性。在Docker中，我们可以使用图像来打包容器的数据(我们将在本文后面了解这一点)。然而，对于一个虚拟机，如果你想打包它，你需要用它的系统数据包装整个操作系统，产生一个巨大的包。</p><p id="fe18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的一点是，在VM中包含容器没有任何问题。其实很多人都是这样用的。你可以在像GCP、AWS或DigitalOcean这样的云服务器中租用一个虚拟机，并在其中运行许多容器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/c04f92abb09b10ff98a1bd3ed323a9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*_qx4HZhjeyapBCMn3rQvag.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">容器与虚拟机结构</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="026f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Docker简介</h1><p id="e0a4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如我们在上一节中了解到的，Docker是一个用于构建、运输和运行容器的开源平台。默认情况下，Docker运行在Linux操作系统之上。如果你在Windows或macOS上安装Docker，它会要求你安装一个Linux VM，这样它就可以在其上运行。</p><p id="cd6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">注意:苹果新的M1 CPU架构目前不支持Docker。有一个开发者预览版，但是还不稳定。</em></p><h2 id="6ced" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">Docker的“你好世界”</h2><p id="f3e8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于这一部分，你需要首先安装<a class="ae ky" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank"> Docker桌面</a>。安装完成后，您可以使用命令<code class="fe nn no np nq b">docker -v</code>来验证您的安装。在我的例子中，我使用的是Windows，我安装的docker版本是<code class="fe nn no np nq b">19.03.12</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/5f713d5f7c8b5eb4fb3734987dbb11d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tWXks8lMqKKKN9Ew.png"/></div></div></figure><p id="7af8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功安装Docker后，您可以尝试使用<code class="fe nn no np nq b">docker run hello-world</code>运行“hello world”Docker映像。您应该会得到这样的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/8562d59a9438b5b212c802a0e457667f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Kh4-m6LFHS8WtN2P.png"/></div></div></figure><p id="60e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，你觉得结果怎么样？你注意到那行<code class="fe nn no np nq b">Unable to find image ‘hello-world:latest’ locally</code>了吗？当我们运行前面的命令时，实际上发生了什么？</p><p id="f02b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你首先要知道的是Docker形象。Docker映像基本上是之前配置的容器的快照。在我们的“hello world”图像中，它被配置为在容器启动时立即显示消息。</p><p id="16da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，当我们运行这个命令时发生了什么呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/0e71d077c9e3879082b73a62ab928320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*yYD4_N79RkjObA7hxfvtEw.png"/></div></figure><ol class=""><li id="89d1" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">码头工人得到了<code class="fe nn no np nq b">docker run hello-world</code>号的命令。</li><li id="16e4" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">Docker检查了<code class="fe nn no np nq b">hello-world</code>图像是否在图像缓存中。</li><li id="edb2" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">图像缓存没有返回任何内容，表明<code class="fe nn no np nq b">hello-world</code>图像不在图像缓存中。</li><li id="b640" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">Docker检查了Docker Hub (Docker的公共存储库)中的<code class="fe nn no np nq b">hello-world</code>图像。</li><li id="f6e1" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">Docker Hub发现了一个标记为<code class="fe nn no np nq b">hello-world:latest</code>的图像，并将其返回到您机器上的Docker。注意，如果不指定标签版本，默认情况下您将获得<code class="fe nn no np nq b">latest</code>标签。</li><li id="0048" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">Docker然后从它得到的图像创建一个容器，在终端屏幕上显示输出。</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="499b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">基本命令</h1><p id="2f48" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">既然我们已经了解了如何使用<code class="fe nn no np nq b">docker run</code>运行映像，那么让我们学习一些基本的命令。</p><h2 id="96db" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">码头运行</h2><p id="2d2d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们在“hello world”示例中使用了<code class="fe nn no np nq b">docker run</code>。<code class="fe nn no np nq b">docker run</code>基本上就是<code class="fe nn no np nq b">docker pull</code>、<code class="fe nn no np nq b">docker create</code>、<code class="fe nn no np nq b">docker start</code>的组合。简单来说，<code class="fe nn no np nq b">docker pull</code>用来从Docker注册表中拉一张图片到你的图片缓存中，<code class="fe nn no np nq b">docker create</code>用来根据图片创建一个容器，<code class="fe nn no np nq b">docker start</code>用来启动一个容器。</p><p id="ac0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">docker run</code>有很多参数可以发送给它。一些最常用的是<code class="fe nn no np nq b">--rm</code>、<code class="fe nn no np nq b">--name</code>和<code class="fe nn no np nq b">-it</code>。</p><p id="d58c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你用<code class="fe nn no np nq b">--rm</code>启动一个容器时，Docker会在停止时移除你的容器。如果你想保持你的机器干净，没有未使用的容器，这是很有用的。</p><p id="b793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">--name</code>会给容器一个名字。如果您为容器设置了一个名称，那么您可以通过它的名称而不仅仅是它的ID来与容器进行交互。</p><p id="9b7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">-it</code>参数公开了容器的输入和输出，因此您可以与之交互。</p><h2 id="1223" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">使用自定义命令运行</h2><p id="e3af" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在创建Docker映像时，您可以指定一个默认命令，该命令将在您从映像运行容器时执行。对于我们的<code class="fe nn no np nq b">hello-world</code>图像，它的默认命令将打开一个脚本，在容器中显示一些输出。但是如果图像没有任何默认命令呢？或者，如果我们想使用自定义命令而不是默认命令，该怎么办？</p><p id="fbc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于本节中的例子，我们将使用一个<code class="fe nn no np nq b">busybox</code>映像，它提供了几个Unix实用程序。<code class="fe nn no np nq b">busybox</code>没有默认命令，这对于我们的例子来说非常完美。</p><p id="09bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着用<code class="fe nn no np nq b">docker run busybox</code>运行<code class="fe nn no np nq b">busybox</code>图像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/2d669d9b8390346673b108e65f9fcfa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*O-O_oKMLJzKCFrwl.png"/></div></div></figure><p id="2dc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">注意:如果您之前没有运行过</em> <code class="fe nn no np nq b"><em class="nm">busybox</em></code> <em class="nm">图像，将会有一个图像提取过程。我以前运行过</em> <code class="fe nn no np nq b"><em class="nm">busybox</em></code> <em class="nm">图像，所以没有图像提取过程。</em></p><p id="c250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么都没发生，对吗？在您键入命令后，会有一点延迟，但之后它不会显示任何内容。<code class="fe nn no np nq b">busybox</code>没有默认命令，所以在我们运行它之后，它会自动停止。</p><p id="fc58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们试试<code class="fe nn no np nq b">docker run -it busybox /bin/sh</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/a4517384e8b09b616bcea11dd396b6ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kmKXWmH1U1CztMT2.png"/></div></div></figure><p id="9a5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出事了！我们现在实际上正在进入集装箱！正如我们在上一节中了解到的，<code class="fe nn no np nq b">-it</code>参数公开了容器的输入和输出，因此您可以与容器进行交互。</p><p id="ccc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">/bin/sh</code>是容器启动时要运行的命令。如果你对Linux有一些基本的了解，你就会知道它是做什么的。它基本上会启动一个外壳。</p><p id="2eb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们打开这个终端，打开一个新的。</p><h2 id="5a7a" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">docker ps</h2><p id="8057" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nn no np nq b">docker ps</code>是一个将显示每个正在运行的容器的命令。如果你想显示一个没有运行的容器，你可以添加一个<code class="fe nn no np nq b">-a</code>参数。</p><p id="7c19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们仍然在运行<code class="fe nn no np nq b">busybox</code>容器，所以让我们使用<code class="fe nn no np nq b">docker ps</code>来查看它的信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/c16a8d9393f9ed14238fc2541e69e216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rZWN7cMQb-jlgv_i.png"/></div></div></figure><h2 id="9cd4" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">码头经理</h2><p id="bc7e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你想在一个正在运行的容器中运行一个命令，可以使用<code class="fe nn no np nq b">docker exec</code>。让我们试试<code class="fe nn no np nq b">docker exec -it fcd /bin/sh</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/81d6799d8e6b5c07c94609035a917701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PLY69eRUtzsushJq.png"/></div></div></figure><p id="e576" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令中的<code class="fe nn no np nq b">fcd</code>是什么意思？<code class="fe nn no np nq b">fcd</code>实际上是我们之前运行的<code class="fe nn no np nq b">busybox</code>容器ID的起始字母。当我们尝试<code class="fe nn no np nq b">docker ps</code>时，我们可以看到集装箱ID打印为<code class="fe nn no np nq b">fcd21cffad6e</code>。Docker是一款真正智能的软件。即使你没有输入完整的ID，它也能识别你所指向的容器。只要它足够独特，Docker就能识别容器。</p><p id="303e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以通过创建一个文件夹并查看另一个终端中是否也创建了该文件夹来测试您的两个终端是否正在访问同一个容器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/4d211a48e9cbe354567beb7821253b76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*O1PBy7CEDrvSYElQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/65a563d5ec7badc9869f8caf8952e99e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CTkZEm_u0z5fhb0X.png"/></div></div></figure><p id="dd8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一张图片中，我在第一个终端中创建了一个名为<code class="fe nn no np nq b">testing</code>的目录。之后，当我在第二个终端中运行一个<code class="fe nn no np nq b">ls</code>命令时，您可以看到目录也在那里。</p><h2 id="9afd" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">码头日志</h2><p id="ffce" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了更好地形象化<code class="fe nn no np nq b">docker logs</code>命令的作用，让我们通过运行<code class="fe nn no np nq b">docker run -d redis</code>来使用<code class="fe nn no np nq b">redis</code>图像。</p><p id="fce2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">docker logs {containerId}</code>可以用来查看过去控制台输出的一个容器。如果您想跟踪日志，还可以添加<code class="fe nn no np nq b">--follow</code>参数。让我们通过使用<code class="fe nn no np nq b">docker logs 82</code>来看看我们刚刚运行的<code class="fe nn no np nq b">redis</code>容器输出了什么。请注意，我的机器和你的机器上的容器ID是不同的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/3023d8246f620f3d03a03e7f43bdfb21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uCGc0GswoOFbR3ms.png"/></div></div></figure><p id="b7aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker的基本命令就是这样。如果你对其他命令感兴趣，你可以在<a class="ae ky" href="https://dockerlabs.collabnix.com/docker/cheatsheet/" rel="noopener ugc nofollow" target="_blank">Docker备忘单</a>中查看它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2ceb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用体积</h1><p id="cbb7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们开始处理音量。在这一节中，我认为只有一件事是你刚开始学习Docker时应该知道的:卷安装。</p><p id="499f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">卷挂载基本上是一种将主机操作系统的卷与容器的卷连接起来的方法。如果您打算使用Docker托管一个具有持久数据存储的容器，这是一件非常重要的事情。如果不将容器的卷装载到主机操作系统，每次更新映像或创建新容器时，您的数据都会被擦除。</p><p id="4795" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了展示这是如何工作的，让我们再次使用<code class="fe nn no np nq b">busybox</code>图像。但是在我们启动容器之前，在您的机器上创建一个文件夹。在我的例子中，我将在<code class="fe nn no np nq b">D:/docker/test-busybox-volume</code>中创建一个文件夹。让我们在刚刚创建的文件夹中创建一个简单的文本文件，并随意命名。我将命名我的<code class="fe nn no np nq b"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/mounted.txt">mounted.txt</a></code>。</p><p id="fa3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候启动<code class="fe nn no np nq b">busybox</code>并将其安装到我们之前创建的文件夹中了！要使用挂载卷特性，我们可以使用<code class="fe nn no np nq b">docker run {image} --volume={src}:{dst}</code>。我们试试<code class="fe nn no np nq b">docker run --volume D:/docker/test-busybox-volume:/test-busybox -it busybox /bin/sh</code>。转到<code class="fe nn no np nq b">/test-busybox</code>目录，使用<code class="fe nn no np nq b">ls</code>列出里面的文件。您应该会看到刚刚创建的文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/d324ccc86e3e1f468f75f4ae35aefb1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lBQS94DtpL_35rDv.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bdd4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用网络</h1><p id="4ae1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">关于Docker中的网络，你需要知道两件重要的事情:</p><ul class=""><li id="a429" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu oq oa ob oc bi translated">如何从容器中公开一个端口来托管操作系统。</li><li id="b5ab" class="nu nv it lb b lc od lf oe li of lm og lq oh lu oq oa ob oc bi translated">容器如何相互通信。</li></ul><p id="1a95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于本节中的示例，我们需要一个具有公开端点的图像。我已经创建了一个简单的名为<code class="fe nn no np nq b">brilianfird/node-mock-endpoint:1.0.0</code>的图像，我们可以使用它作为我们的案例。该图像包含一个监听端口8080的应用程序，当它被点击时将返回一个简单的<code class="fe nn no np nq b">{"success": true}</code>响应。</p><h2 id="8c70" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">暴露端口</h2><p id="8de6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">将端口暴露给主机操作系统很容易。您可以在启动容器时添加<code class="fe nn no np nq b">--port {to}:{from}</code>参数。让我们用<code class="fe nn no np nq b">brilianfird/node-mock-endpoint</code>图像来试试:</p><pre class="kj kk kl km gt or nq os ot aw ou bi"><span id="abdf" class="mz md it nq b gy ov ow l ox oy">docker run -p 8081:8080 brilianfird/node-mock-endpoint:<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/1.0.0">1.0.0</a></span></pre><p id="bd89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，尝试在浏览器中打开localhost:8081，您将看到响应。</p><h2 id="e8c2" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">集装箱之间的通信</h2><p id="3729" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">由于微服务的流行，服务相互连接是非常正常的。大多数应用程序还需要连接到数据库才能正常运行。如果容器是孤立的，那么它们如何相互连接呢？</p><p id="82c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于要相互连接的容器，它们需要在同一个Docker网络中。在本文中，我们将使用一个非常简单的桥接网络来连接容器。如果你对其他类型的网络感兴趣，你可以在文档中阅读。</p><p id="1439" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用<code class="fe nn no np nq b">docker network create my-network</code>创建一个基本网络，并用<code class="fe nn no np nq b">docker network inspect my-network</code>检查它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/c6419050632648baf0ca3ac510fb02bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_dtagn9mCtG6IHAw.png"/></div></div></figure><p id="fcd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网络中有许多配置，但在我们的例子中，Docker默认分配所有配置，因为我们没有指定它们。我们不会深入探究每个配置的功能。您唯一需要知道的是,<code class="fe nn no np nq b">“bridge”</code>驱动程序将使其中的容器能够相互通信。</p><p id="84f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一步我们将使用两个容器:<code class="fe nn no np nq b">node-mock-endpoint</code>和<code class="fe nn no np nq b">alpine</code>。让我们通过运行<code class="fe nn no np nq b">docker run --rm --network my-network --name my-endpoint -d node-mock-endpoint:<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/1.0.0">1.0.0</a></code>来启动附加到我们新创建的网络的<code class="fe nn no np nq b">node-mock-endpoint</code>映像。请注意，我们将容器命名为。为了让其他容器更容易地调用这个容器，这是一件非常重要的事情。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/57bbeff766d6f8bfc690c60940556db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*w51QvlBz1qX9ii8K.png"/></div></div></figure><p id="07ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是运行一个<code class="fe nn no np nq b">alpine</code>图像。然后，我们将在alpine映像中安装<code class="fe nn no np nq b">curl</code>,并尝试从中访问我们的<code class="fe nn no np nq b">node-mock-endpoint</code>映像。让我们运行<code class="fe nn no np nq b">docker run --network my-network --rm -it alpine /bin/sh</code>来创建一个新的容器。进入容器后，运行<code class="fe nn no np nq b">apk add curl --no-cache</code>在容器中安装<code class="fe nn no np nq b">curl</code>命令:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/ab0f8a373724ca24393187d3b6f164d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Lih4SUsgp1al5lAh.png"/></div></div></figure><p id="aa42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们如何调用<code class="fe nn no np nq b">node-mock-endpoint</code>容器？嗯，当你在网络中创建一个容器时，Docker网络会自动为你的容器分配一个私有IP。Docker还会根据容器的名称给IP添加一个别名。所以，如果你想调用一个特定的容器，你可以直接调用它的名字。</p><p id="79e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之前，我们将我们的<code class="fe nn no np nq b">node-mock-endpoint</code>容器命名为<code class="fe nn no np nq b">my-endpoint</code>。因为我们可以使用容器的名称来访问它，所以我们可以只从<code class="fe nn no np nq b">curl</code>到<code class="fe nn no np nq b">my-endpoint</code>看看它是否返回响应。让我们运行<code class="fe nn no np nq b">curl -XGET my-endpoint:8080</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/09fb517f22eafbf7450f0178ee9dfac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ps7_f4LdZanmdLhD.png"/></div></div></figure><p id="e94e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切顺利，您应该会看到来自<code class="fe nn no np nq b">my-endpoint</code>容器的响应<code class="fe nn no np nq b">{"message":true}</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d447" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在Docker中创建我们自己的形象</h1><p id="6307" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止，我们只使用了Docker Hub中已经存在的图像。但是我们实际上是如何塑造自己的形象的呢？在本节中，我们将学习如何做到这一点！我们将创建一个简单的<code class="fe nn no np nq b">alpine</code>映像，其中预装了一个<code class="fe nn no np nq b">curl</code>，并将运行<code class="fe nn no np nq b">curl --help</code>作为默认命令。</p><p id="6a05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通常只使用自定义命令来进入容器的外壳。但是请记住，我们可以运行任何与映像兼容的命令(比如安装<code class="fe nn no np nq b">curl</code>)。</p><p id="9d10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们运行一个<code class="fe nn no np nq b">alpine</code>容器。这一次，我们将安装<code class="fe nn no np nq b">curl</code>而不进入容器。我们也把容器命名为<code class="fe nn no np nq b">alpine-curl</code>。为此，我们可以运行<code class="fe nn no np nq b">docker run --name alpine-curl alpine apk add --no-cache curl</code>。</p><p id="b9bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们有了一个安装了<code class="fe nn no np nq b">curl</code>的<code class="fe nn no np nq b">alpine</code>容器。为了从它创建一个图像，我们可以使用<code class="fe nn no np nq b">docker commit</code>命令。首先，让我们看看如何通过运行<code class="fe nn no np nq b">docker commit --help</code>来使用<code class="fe nn no np nq b">docker commit</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/7f63edff7b0f56f70accaa1a36ac1ebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vRP94LV2OMNQGrbN.png"/></div></div></figure><p id="b3b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从帮助响应中，我们知道要使用<code class="fe nn no np nq b">docker commit</code>，我们至少需要指定容器、存储库和标签。容器就是您想要从中创建图像的容器的ID或名称。存储库是您的映像的名称。它通常有这样的格式:<code class="fe nn no np nq b">{company-name}/{image-name}</code>。标签基本上是你的图像的一个版本。默认情况下，Docker会使用<code class="fe nn no np nq b">latest</code>标签。</p><p id="41da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，回到我们的形象。剩下要做的就是将默认命令添加到我们的<code class="fe nn no np nq b">alpine-curl</code>容器中。为此，我们可以在提交时使用带有CMD值的<code class="fe nn no np nq b">--change</code>参数。让我们运行<code class="fe nn no np nq b">docker commit --change='CMD ["curl", "--help"]' alpine-curl brilianfird/alpine-curl:latest</code>。注意，我使用我的Docker的句柄名称作为<code class="fe nn no np nq b">{company-name}</code>。您可以使用相同的名称或将其更改为您的Docker的句柄名称。然后我们可以尝试使用<code class="fe nn no np nq b">docker run brilianfird/alpine-curl</code>运行<code class="fe nn no np nq b">brilianfird/alpine-curl</code>图像，我们应该会看到curl帮助信息。</p><p id="e256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">注意:如果您使用的是windows，并且在运行映像时得到了</em> <code class="fe nn no np nq b"><em class="nm">/bin/sh: [“curl”,: not found</em></code> <em class="nm">，请尝试在WSL终端中提交映像。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/dd81fbbea8895009c4e3515d4b1124c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2TNPr-j23NyAPclM.png"/></div></div></figure><p id="7a65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不错！现在我们的图像完成了！我们基于<code class="fe nn no np nq b">alpine</code>图像创建了一个图像<code class="fe nn no np nq b">alpine-curl</code>，并在其中安装了<code class="fe nn no np nq b">curl</code>命令。然后，我们还添加了一个默认命令<code class="fe nn no np nq b">curl --help</code>，如果我们运行这个映像，这个命令就会被执行！</p><p id="4bc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你是否觉得创建一个图像非常复杂，需要记住所有的命令？你并不孤单。我也有这种感觉！幸运的是，Docker用Dockerfile提供了一个更简单的图像创建过程。</p><h2 id="2bcb" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">使用Dockerfile创建图像</h2><p id="4120" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用<code class="fe nn no np nq b">Dockerfile</code>，您可以用更简单的语法将所有的<code class="fe nn no np nq b">docker commit</code>命令包含在一个文件中。让我们为之前创建的<code class="fe nn no np nq b">alpine-curl</code>图像创建一个。</p><p id="17d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们创建一个文件夹，命名为<code class="fe nn no np nq b">alpine-curl</code>。然后在我们刚刚创建的文件夹中创建一个名为<code class="fe nn no np nq b">Dockerfile</code>(没有任何扩展名)的文件，并在其中插入以下文本:</p><pre class="kj kk kl km gt or nq os ot aw ou bi"><span id="56f4" class="mz md it nq b gy ov ow l ox oy">FROM alpine<br/><br/>RUN apk add --no-cache curl<br/>CMD ["curl", "--help"]</span></pre><p id="fcc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，运行<code class="fe nn no np nq b">alpine-curl</code>文件夹内的<code class="fe nn no np nq b">docker build .</code>命令。您将获得一个图像ID，如果您尝试运行它，您将看到<code class="fe nn no np nq b">curl</code>帮助信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/4545503a7451c0f46c8b7c74e21527db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UB5WKd007lpiw-WQ.png"/></div></div></figure><p id="78e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的另一件事是更改图像的名称。为此我们可以使用<code class="fe nn no np nq b"><a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/tag/" rel="noopener ugc nofollow" target="_blank">docker tag</a></code>。尝试运行<code class="fe nn no np nq b">docker tag 63 brilianfird/alpine-curl-dockerfile:latest</code>(记得更改图像ID)。</p><p id="5c34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标记图像后，您可以使用<code class="fe nn no np nq b">docker images</code>来检查它是否被正确标记。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/97f13f351f80228d8d522afe94ddc5ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sIOO_Xlp3KFz483j.png"/></div></div></figure><p id="c2f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在创建一个图像非常容易，对吗？<code class="fe nn no np nq b">Dockerfile</code>也是你通常用来创建一个开发项目的图像。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0729" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Docker撰写</h1><p id="cbef" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止，我们只讨论了如何创建单容器应用程序。如果我们想创建一个多容器的怎么办？多克还是支持你的。您可以使用Docker Compose创建一个多容器Docker应用程序。</p><p id="3abe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker Compose通常用于应用程序的开发和测试阶段。通过使用Docker Compose，如果您的应用程序依赖于一个MongoDB存储库，您就不必在您的机器上安装Mongo。您只需将它添加到Docker Compose文件中，每次运行它时，您的应用程序都会以Mongo服务启动。</p><p id="e43e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker Compose还会让您的测试工作变得更加轻松——尤其是集成测试。有了它，您可以确保您的应用程序在本地环境中的依赖关系与在生产环境中是一样的。</p><p id="3d21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在前面的例子中使用了<code class="fe nn no np nq b">node-mock-endpoint</code>和<code class="fe nn no np nq b">alpine-curl</code>。对于本节，我们将使用相同的。我们将创建一个Docker Compose，用一个命令运行<code class="fe nn no np nq b">node-mock-endpoint</code>和<code class="fe nn no np nq b">alpine-curl</code>，看看它们是否如我们预期的那样工作。</p><p id="694e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于本节中的示例，让我们首先创建一个<code class="fe nn no np nq b">Dockerfile</code>:</p><pre class="kj kk kl km gt or nq os ot aw ou bi"><span id="2186" class="mz md it nq b gy ov ow l ox oy">FROM alpine<br/><br/>RUN apk add --no-cache curl<br/>CMD ["ping", "google.com"]</span></pre><p id="0f7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们pinging Google的原因是，当我们运行它时，容器不会立即退出。</p><p id="f70a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，创建一个Docker合成文件。转到之前创建的<code class="fe nn no np nq b">alpine-curl</code>文件夹，创建一个名为<code class="fe nn no np nq b">docker-compose.yml</code>的yml文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div></figure><p id="6b82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一行一行地讨论<code class="fe nn no np nq b"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/docker-compose.yml">docker-compose.yml</a></code>。</p><ol class=""><li id="5b9d" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">第一行是<code class="fe nn no np nq b">version</code>。这决定了您正在使用哪个版本的docker-compose。</li><li id="ae7f" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><code class="fe nn no np nq b">services</code>确定您想要运行的服务/图像。</li><li id="ca6c" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><code class="fe nn no np nq b">alpine-curl</code>和<code class="fe nn no np nq b">mock-endpoint</code>是服务名。你可以随便给它们起什么名字。</li><li id="b99f" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><code class="fe nn no np nq b">build</code>要求Docker为指定的服务建立Docker文件。您需要指定将在上下文中构建哪个Dockerfile。因为我们使用默认的docker文件名(<code class="fe nn no np nq b">Dockerfile</code>)，所以我们可以在那里放一个点。</li><li id="c234" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><code class="fe nn no np nq b">image</code>表示您将在服务中运行图像。您可以在那里指定存储库、图像名称和标记。</li></ol><p id="213f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们没有指定任何网络。当你使用Docker Compose时，默认情况下每个容器都可以互相通信。因此，即使我们没有指定任何网络，<code class="fe nn no np nq b">alpine-curl</code>仍然能够与<code class="fe nn no np nq b">mock-endpoint</code>通信。</p><p id="9098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们通过在终端中运行<code class="fe nn no np nq b">docker-compose up --build</code>来启动Docker Compose。<code class="fe nn no np nq b">--build</code>参数在这里是可选的，但是如果您更改Dockerfile/Docker Compose文件中的某些内容，最好添加该参数来强制Docker Compose构建您的Dockerfile。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/d2903dc91d57a04f53eb5ff90c34e641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TKEaJYzVN-uAqhvK.png"/></div></div></figure><p id="7dd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nn no np nq b">docker-compose up</code>命令，Docker将解析<code class="fe nn no np nq b">docker-compose.yml</code>并在文件中创建已定义图像的容器。</p><p id="15a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了证明两个容器可以相互通信，我们可以打开一个新的终端，并通过运行命令<code class="fe nn no np nq b">docker exec -it alpine-curl_alpine-curl_1 /bin/sh</code>进入<code class="fe nn no np nq b">alpine-curl</code>容器。在容器内部，尝试使用curl命令(<code class="fe nn no np nq b">curl -XGET mock_endpoint:8080</code>，您应该会得到一个<code class="fe nn no np nq b">{"message": true}</code>响应。您可以调用<code class="fe nn no np nq b">mock_endpoint</code>的原因是Docker自动将服务名称解析为它的私有IP。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/41a89781f27c7e72e2cac37683984f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uVY0Q5TuIwM2hGpF.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a701" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="68ed" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Docker对于软件开发人员和开发者来说都是一个非常重要的组件。这是使用容器时事实上的标准，与不使用容器相比，它有很多优点。</p><p id="c6e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们了解了Docker，但是接下来呢？我们可以学习如何在实际的开发项目中使用它，还可以学习Kubernetes，一个Docker/容器管理系统。</p><p id="5704" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我想说谢谢你一直看完这篇文章！我希望你喜欢它，并从中有所收获！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0374" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ul class=""><li id="fcec" class="nu nv it lb b lc mu lf mv li pk lm pl lq pm lu oq oa ob oc bi translated"><a class="ae ky" href="https://docker.com" rel="noopener ugc nofollow" target="_blank">码头工人</a></li><li id="572a" class="nu nv it lb b lc od lf oe li of lm og lq oh lu oq oa ob oc bi translated">Docker和Kubernetes:Udemy的完整指南</li><li id="f330" class="nu nv it lb b lc od lf oe li of lm og lq oh lu oq oa ob oc bi translated"><a class="ae ky" href="https://dockerlabs.collabnix.com/docker/cheatsheet/" rel="noopener ugc nofollow" target="_blank">终极Docker备忘单</a></li><li id="8bcd" class="nu nv it lb b lc od lf oe li of lm og lq oh lu oq oa ob oc bi translated"><a class="ae ky" href="https://learning.oreilly.com/library/view/docker-in-action/9781617294761/" rel="noopener ugc nofollow" target="_blank"> Docker in Action，第二版</a></li><li id="c942" class="nu nv it lb b lc od lf oe li of lm og lq oh lu oq oa ob oc bi translated"><a class="ae ky" href="https://www.burwood.com/blog-archive/containerization-vs-virtualization#:~:text=Virtualization%20enables%20you%20to%20run,single%20virtual%20machine%20or%20server." rel="noopener ugc nofollow" target="_blank">容器化与虚拟化:有何区别？</a></li></ul><p id="5738" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">先前发表于</em><a class="ae ky" href="https://codecurated.com/blog/get-started-with-docker/" rel="noopener ugc nofollow" target="_blank"><em class="nm">codecurated.com</em></a><em class="nm">。</em></p></div></div>    
</body>
</html>