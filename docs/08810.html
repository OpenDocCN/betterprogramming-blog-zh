<html>
<head>
<title>What’s Coming in React 18?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 18中有什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-coming-in-react-18-d56832fc0ef3?source=collection_archive---------1-----------------------#2021-06-15">https://betterprogramming.pub/whats-coming-in-react-18-d56832fc0ef3?source=collection_archive---------1-----------------------#2021-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="62c5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这可能是迄今为止用户体验的最大改进</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c6f1fa08efa56809845944116de6b874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-IhsY9ky4eH8j5mU6Td10w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Joshua Woroniecki 在<a class="ae ky" href="https://unsplash.com/@joshua_j_woroniecki?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="f690" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React 18带来了一些新的开箱即用的改进，更专注于用户体验和内部架构的变化。新功能如下。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3cc3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.新的根API</h1><p id="8967" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们知道<code class="fe mz na nb nc b">&lt;App /&gt;</code>组件通常是如何在<code class="fe mz na nb nc b">index.js</code>文件中呈现到<code class="fe mz na nb nc b">index.htm</code> l文件中的根元素上的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在React 18之前，组件是如何在根目录中呈现的</p></figure><p id="aac8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在React 18中，我们需要使用<code class="fe mz na nb nc b">createRoot()</code>方法来创建一个根元素，然后呈现所需的组件，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">React 18</strong>中组件如何在根中渲染</p></figure><p id="7c34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用于渲染的旧方法也将得到支持，它将被称为遗留根API。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d3e7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.较少渲染的自动批处理</h1><h2 id="a6ad" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">什么是批处理？</h2><p id="a010" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://github.com/reactwg/react-18/discussions/21" rel="noopener ugc nofollow" target="_blank"> <em class="nr">批处理</em> </a>是React将多个状态更新分组到单个重新渲染中以获得更好的性能。当我们有大量没有批处理的应用程序时，由于多种状态变化，我们可能会遇到很多页面的重新呈现。这可能会导致一些不必要的错误，导致糟糕的用户体验。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在React 17中没有配料</p></figure><p id="2ea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下示例展示了React 18中引入自动批处理后重新渲染的变化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">React 18中的自动配料</p></figure><p id="a55c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nr">自动批处理</em>本质上是指在超时内状态更新的情况下，任何承诺、本地事件处理程序和任何其他事件都将被自动批处理。需要使用前面提到的新的根API来启用这个特性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">批处理自动发生的例子。</strong></p></figure><p id="700e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码片段<code class="fe mz na nb nc b">examples.js</code>中提到的所有例子中，批处理将自动发生，因此React将只为批处理重新渲染一次，而不是两次。</p><h2 id="8560" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">既然是自动的，那如果我们不想用这个功能呢？</h2><p id="afab" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以通过使用react-dom的<code class="fe mz na nb nc b">flushSync()</code>函数退出批处理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">当我们不想要批处理的时候。</strong></p></figure><p id="f630" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是React的一个很好的新增功能，因为这可以通过避免不必要的重新渲染来提高应用程序的性能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bd97" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.悬念的服务器端渲染支持</h1><h2 id="b76d" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">什么是服务器端渲染？</h2><p id="e92f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通常，当我们打开一个网站时，网络浏览器请求一个页面，然后JavaScript包被加载，然后网页就可见了。初始加载时请求的HTML文档是稀疏的，只包含脚本标记，然后请求JavaScript包。加载包，然后发出JSON请求，使网站可访问。</p><p id="aa14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在向用户显示任何内容之前，我们发出三个请求。</p><p id="50d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在服务器端渲染中，当我们打开网站时，HTML文件被加载，用户在初始加载时得到一个可用的可视屏幕。(服务器进行渲染)。因此，我们在用户屏幕上显示HTML框架，同时在后台加载JavaScript包。</p><p id="5b2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当所有这些都完成后，JavaScript和HTML就连在一起了。这个过程被称为<a class="ae ky" href="https://github.com/reactwg/react-18/discussions/37" rel="noopener ugc nofollow" target="_blank"> <em class="nr">水合</em> </a>。</p><p id="c006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的缺点如下:</p><ul class=""><li id="fe32" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">在我们水合任何东西之前，我们需要取回所有的东西。</li><li id="7df1" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">在我们与任何东西互动之前，我们必须水合所有东西。即使框架HTML加载并可见，组件也不是交互式的。</li></ul><p id="c523" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在React 18中用<code class="fe mz na nb nc b">&lt;Suspense /&gt;</code>组件解决。</p><p id="5f24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在获取所有数据之前流式传输HTML。这种流式传输没有特定的顺序。</p><p id="02e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一些组件(例如，<code class="fe mz na nb nc b">&lt;Comments/&gt;</code>)需要很长时间来加载。这个组件可以用<code class="fe mz na nb nc b">&lt;Suspense&gt;</code>包裹。服务器在服务器中合成这个组件，然后将它发送给客户端。因此，其他组件(在本例中为<code class="fe mz na nb nc b">&lt;NavBar /&gt;</code>、<code class="fe mz na nb nc b">&lt;SideBar /&gt;</code>和<code class="fe mz na nb nc b">&lt;Post /&gt; </code>)可以独立流式传输，而不依赖于<code class="fe mz na nb nc b">&lt;Comments/&gt;</code>组件。当服务器正在水合<code class="fe mz na nb nc b">&lt;Comments/&gt;</code>组件时，显示回退，在本例中为<code class="fe mz na nb nc b">&lt;Spinner /&gt;</code> <strong class="lb iu">，</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这被称为<em class="nr">选择性水合</em>。其他组件渲染，React不需要等待<strong class="lb iu"> </strong> <code class="fe mz na nb nc b">&lt;Comments/&gt;</code>组件加载补水。使用<code class="fe mz na nb nc b">&lt;Suspense&gt;</code>，我们还可以在装载<code class="fe mz na nb nc b">&lt;Comments/&gt;</code>组件之前水合其他组件。</p><p id="bc2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果需要，它还允许通过排除<code class="fe mz na nb nc b">&lt;Comments /&gt;</code>组件来捆绑HTML。当评论的数据在服务器上准备好了，React将发送额外的HTML到同一个流中，以及一个最小的inline <code class="fe mz na nb nc b">&lt;script&gt;</code>标签来把HTML放在“正确的地方”</p><p id="6cb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在服务器中的<code class="fe mz na nb nc b">&lt;Comments /&gt;</code>水合作用不再阻碍浏览器做其他工作。因此，其他组分(<code class="fe mz na nb nc b">&lt;NavBar /</code>、&gt;、<code class="fe mz na nb nc b">&lt;SideBar /&gt;</code>和<code class="fe mz na nb nc b">&lt;Post /&gt;</code>)将完全水合，并且这些组分将是可相互作用的。</p><p id="8ea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，有了这个新特性，用户也可以与呈现的组件进行交互，而不是等待加载整个包。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fe0e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.新过渡API</h1><p id="26c9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个新特性允许我们告诉React哪些更新是紧急的，哪些不是，这实质上有助于区分更新的优先级。在React 18之前，所有的更新都被认为是紧急的。</p><p id="0fcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个带有验证的表单。我们有两种状态，一种存储用户的表单输入，另一种存储错误状态。当我们进行大屏幕更新时，状态更新之间可能会有一些延迟。有了这个新特性，我们可以使输入的变化变得紧急，而错误状态验证变得不紧急。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4e69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">围绕<code class="fe mz na nb nc b">startTransition()</code> <strong class="lb iu"> </strong>方法的所有更新都被视为非紧急更新，如果出现更紧急的更新，如点击或按键，就会被中断。</p><p id="9d38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在React 18之前，上述两种状态将同时呈现，并将阻止用户看到来自他们交互的反馈，直到所有内容都呈现出来。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6713" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="81bd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">React 18带来了一些有前途的新功能。由于它仍处于alpha版本，脸书已经建立了一个<a class="ae ky" href="https://github.com/reactwg/react-18" rel="noopener ugc nofollow" target="_blank"> React 18工作组</a>来为新版本的顺利和逐步采用准备生态系统。总之，我们有:</p><ol class=""><li id="2b04" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu og ny nz oa bi translated">新的根API</li><li id="cb5f" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">自动配料</li><li id="4c72" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">SSR的悬念</li><li id="55c0" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">新的转换API</li></ol><h2 id="9875" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">如何尝试React 18</h2><p id="a127" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可以通过运行以下命令来安装React 18:</p><pre class="kj kk kl km gt oh nc oi oj aw ok bi"><span id="27e5" class="nf md it nc b gy ol om l on oo">npm install react@alpha<br/>npm install react-dom@alpha</span></pre><p id="3908" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">公众测试版预计将在几个月后推出。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="bc4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">你觉得最刺激的特点是什么？</strong></p><p id="edb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="83d6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><p id="854b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">React 18的计划:<a class="ae ky" href="https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html" rel="noopener ugc nofollow" target="_blank">https://React js . org/blog/2021/06/08/the-Plan-for-React-18 . html</a></p><p id="f7a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自动配料:<a class="ae ky" href="https://github.com/reactwg/react-18/discussions/21" rel="noopener ugc nofollow" target="_blank">https://github.com/reactwg/react-18/discussions/21</a></p><p id="4812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转场:<a class="ae ky" href="https://github.com/reactwg/react-18/discussions/41" rel="noopener ugc nofollow" target="_blank">https://github.com/reactwg/react-18/discussions/41</a></p><p id="2ab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SSR的新悬念:【https://github.com/reactwg/react-18/discussions/37】T2</p></div></div>    
</body>
</html>