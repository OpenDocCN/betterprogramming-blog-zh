<html>
<head>
<title>Create a Multi-service Development Environment With VS Code and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用VS代码和Docker创建多服务开发环境</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-multi-service-development-environment-with-vs-code-and-docker-e58b2b611278?source=collection_archive---------4-----------------------#2022-02-01">https://betterprogramming.pub/create-a-multi-service-development-environment-with-vs-code-and-docker-e58b2b611278?source=collection_archive---------4-----------------------#2022-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="056d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Visual Studio代码中设置多容器环境</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b89e640c0ce7cc5b7737bdcb7c836fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*40ESIUWUC1IwlbVz"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@guibolduc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Guillaume Bolduc </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3829" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您想要开发一个由前端、API和DB组成的应用程序。您可以在同一个Docker容器中实现这一点，但这会限制您将来扩展的可能性，也就是说，如果您的负载增加，您需要添加额外的API或多个数据库服务器。</p><p id="2aff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对此的解决方案是在各自的容器中开发这些服务。Visual Studio Code(VS Code)让我们不仅可以启动我们的多个服务，还可以轻松连接到每个服务，并在不同的容器中使用VS Code作为我们的开发工具。</p><p id="1b22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看这是如何实现的。以<a class="ae kv" href="https://medium.com/@bernd.bornhausen/setting-up-visual-studio-code-with-docker-as-a-development-environment-for-python-da640978cae3" rel="noopener">这篇文章为基础</a>，我们可以扩展相同的概念并构建我们的多容器环境。</p><p id="3ee9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们的架构由以下三个服务组成:</p><ol class=""><li id="313b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">前端，基于PyWebIO</li><li id="d65d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">中间层，一个基于fastApi的API</li><li id="b099" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">后端，一个Redis实例</li></ol><p id="4e34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的开发文件夹中的文件夹结构，在本例中命名为<code class="fe mg mh mi mj b">multicontainersetup </code>，如下所示:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="0fb4" class="mo mp iq mj b gy mq mr l ms mt">C:\DEV\MULTICONTAINERSETUP<br/>├───api<br/>├───frontend<br/>└───redis</span></pre><p id="d6af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让VS代码将不同的文件夹识别为“Remote-Folder ”,即应该在Docker容器中打开的文件夹，我们需要在每个子文件夹中创建一个<code class="fe mg mh mi mj b">.devcontainer</code>文件夹。以前面提到的文章中描述的文件为基础，我们可以根据需要定制每个文件夹的配置。<br/>由于前端和API将使用Python开发，我们可以为它们使用相同的<code class="fe mg mh mi mj b">Dockerfile </code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">前端和api服务的Dockerfile</p></figure><p id="0ff7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该docker文件必须复制到<code class="fe mg mh mi mj b">Frontend</code>的<code class="fe mg mh mi mj b">.devcontainer</code>文件夹和<code class="fe mg mh mi mj b">API </code>文件夹中。</p><p id="c6ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">必须修改<code class="fe mg mh mi mj b">devcontainer.json</code>文件来使用Docker合成文件，以便VS代码可以同时启动多个Docker容器。在我描述<code class="fe mg mh mi mj b">devcontainer.json</code>文件之前，让我们快速浏览一下<code class="fe mg mh mi mj b">docker-compose.yml</code>文件。<br/><code class="fe mg mh mi mj b">docker-compose.yml</code>文件必须放在我们项目的根文件夹中，在这里是<code class="fe mg mh mi mj b">multicontainersetup</code>。</p><p id="f763" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了我稍后将解释的<code class="fe mg mh mi mj b">redis </code>服务之外，每个服务都将遵循相同的模式，对于<code class="fe mg mh mi mj b">docker-compose.yml</code>文件中服务部分的<code class="fe mg mh mi mj b">frontend</code>,配置将如下所示:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="9c5d" class="mo mp iq mj b gy mq mr l ms mt">frontend:</span><span id="1296" class="mo mp iq mj b gy mw mr l ms mt">image: frontend</span><span id="b3d3" class="mo mp iq mj b gy mw mr l ms mt">tty: true</span><span id="0c78" class="mo mp iq mj b gy mw mr l ms mt">build:</span><span id="cd62" class="mo mp iq mj b gy mw mr l ms mt">context: ./frontend/.devcontainer</span><span id="cd47" class="mo mp iq mj b gy mw mr l ms mt">dockerfile: ./Dockerfile</span><span id="0aba" class="mo mp iq mj b gy mw mr l ms mt">volumes:<br/>- .:/workspace:cached</span><span id="73a8" class="mo mp iq mj b gy mw mr l ms mt">depends_on:</span><span id="5608" class="mo mp iq mj b gy mw mr l ms mt">- api<br/>- redisserver</span><span id="dc0f" class="mo mp iq mj b gy mw mr l ms mt">ports:</span><span id="8ba3" class="mo mp iq mj b gy mw mr l ms mt">- "8000:8000"</span><span id="1f15" class="mo mp iq mj b gy mw mr l ms mt">networks:</span><span id="d17b" class="mo mp iq mj b gy mw mr l ms mt">- myNetwork</span></pre><p id="ee98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仔细观察我们会发现，我们正在描述一个名为<code class="fe mg mh mi mj b">frontend</code>的服务，这是上面代码中的第一行，它是基于我们的<code class="fe mg mh mi mj b">frontend/.devcontainer</code>文件夹中的<code class="fe mg mh mi mj b">Dockerfile</code>构建的:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="3555" class="mo mp iq mj b gy mq mr l ms mt">context: ./frontend/.devcontainer</span><span id="66d8" class="mo mp iq mj b gy mw mr l ms mt">dockerfile: ./Dockerfile</span></pre><p id="4ef0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还使这个容器依赖于我们的<code class="fe mg mh mi mj b">api </code>服务和<code class="fe mg mh mi mj b">redisserver</code>服务，这样一旦我们启动了<code class="fe mg mh mi mj b">frontend</code>容器，两个容器都将被启动。我还公开了端口‘8000 ’,这样一旦我开发了它，我就可以从我的主机上访问<code class="fe mg mh mi mj b">frontend</code>。</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="598d" class="mo mp iq mj b gy mq mr l ms mt">ports:</span><span id="75f4" class="mo mp iq mj b gy mw mr l ms mt">- "8000:8000"</span></pre><p id="ae93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用相同的格式，<code class="fe mg mh mi mj b">api </code>服务将如下所示:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="ebb9" class="mo mp iq mj b gy mq mr l ms mt">api:</span><span id="b3f7" class="mo mp iq mj b gy mw mr l ms mt">image: api</span><span id="a523" class="mo mp iq mj b gy mw mr l ms mt">tty: true</span><span id="e0e7" class="mo mp iq mj b gy mw mr l ms mt">build:</span><span id="74df" class="mo mp iq mj b gy mw mr l ms mt">context: ./api/.devcontainer</span><span id="d305" class="mo mp iq mj b gy mw mr l ms mt">dockerfile: ./Dockerfile</span><span id="6a1c" class="mo mp iq mj b gy mw mr l ms mt">volumes:<br/>- .:/workspace:cached</span><span id="19de" class="mo mp iq mj b gy mw mr l ms mt">networks:</span><span id="8ff4" class="mo mp iq mj b gy mw mr l ms mt">- myNetwork</span></pre><p id="1dce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我将这两个服务都连接到了一个名为<code class="fe mg mh mi mj b">myNetwork</code>的网络。</p><p id="e565" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我计划只在这个Docker网络中使用API，所以我没有向主机暴露任何端口。</p><p id="be9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi mj b">docker-compose.yml</code>文件中的网络配置部分如下所示，将位于配置的最末端。</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="5069" class="mo mp iq mj b gy mq mr l ms mt">networks:</span><span id="8870" class="mo mp iq mj b gy mw mr l ms mt">myNetwork:</span><span id="aece" class="mo mp iq mj b gy mw mr l ms mt">driver: bridge</span></pre><p id="0f2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在来看将成为我们后端的<code class="fe mg mh mi mj b">redisserver </code>服务。因为我们不打算在这个容器中开发，所以我们可以设置这个容器，没有<code class="fe mg mh mi mj b">.devcontainer</code>文件夹和<code class="fe mg mh mi mj b">Dockerfile</code>和<code class="fe mg mh mi mj b">devcontainer.json</code>文件。</p><p id="f11f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不会详细介绍redis容器的配置，下面的配置对我来说很有用:)</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="c421" class="mo mp iq mj b gy mq mr l ms mt">redissever:</span><span id="7148" class="mo mp iq mj b gy mw mr l ms mt">image: redisserver</span><span id="d57d" class="mo mp iq mj b gy mw mr l ms mt">tty: true</span><span id="9412" class="mo mp iq mj b gy mw mr l ms mt">build:</span><span id="0b43" class="mo mp iq mj b gy mw mr l ms mt">context: ./redis/</span><span id="251d" class="mo mp iq mj b gy mw mr l ms mt">dockerfile: ./Dockerfile</span><span id="262c" class="mo mp iq mj b gy mw mr l ms mt">volumes:</span><span id="9a6e" class="mo mp iq mj b gy mw mr l ms mt">- .:/workspace:cached</span><span id="fc4d" class="mo mp iq mj b gy mw mr l ms mt">- ./redis/redis-data:/data</span><span id="aadf" class="mo mp iq mj b gy mw mr l ms mt">ports:</span><span id="885c" class="mo mp iq mj b gy mw mr l ms mt">- "6379:6379"</span><span id="a3bc" class="mo mp iq mj b gy mw mr l ms mt">command:</span><span id="8276" class="mo mp iq mj b gy mw mr l ms mt"># Save if 100 keys are added in every 10 seconds</span><span id="df9a" class="mo mp iq mj b gy mw mr l ms mt">- "--save 10 100"</span><span id="7cc8" class="mo mp iq mj b gy mw mr l ms mt">networks:</span><span id="5725" class="mo mp iq mj b gy mw mr l ms mt">- myNetwork</span></pre><p id="1c98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我正在使用的完整的docker-compose.yml文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Docker合成文件</p></figure><p id="708f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个服务的<code class="fe mg mh mi mj b">devcontainer.json</code>文件非常相似，但是在<code class="fe mg mh mi mj b">docker-compose.ym</code> l文件中引用它们各自的映像。<br/>必须为每个集装箱定制以下零件；这是<code class="fe mg mh mi mj b">frontend </code>服务的具体部分:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="a076" class="mo mp iq mj b gy mq mr l ms mt">"name": "frontend",</span><span id="f1b6" class="mo mp iq mj b gy mw mr l ms mt">"dockerComposeFile": "../../docker-compose.yml",</span><span id="428a" class="mo mp iq mj b gy mw mr l ms mt">"workspaceFolder": "/workspace/frontend",</span><span id="11db" class="mo mp iq mj b gy mw mr l ms mt">"service": "frontend",</span></pre><p id="ffba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要定义名称，VS代码将用来构建我们的环境的<code class="fe mg mh mi mj b">docker-compose.yml</code>文件，我们的代码将存储在<code class="fe mg mh mi mj b">workspaceFolder </code>中的文件夹，以及我们在Docker Compose文件中引用的服务的名称。</p><p id="cd12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">包含Python linter配置的两个完整文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">前端devcontainer.json</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">API devcontainer.json</p></figure><p id="6a3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了完成我们的设置，我们需要为每个服务创建<code class="fe mg mh mi mj b">requirements.txt</code>文件。前端服务的一个具有以下内容，因为我的前端将基于PyWebIO:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="9cd0" class="mo mp iq mj b gy mq mr l ms mt">pylint<br/>pycodestyle<br/>black<br/>requests<br/>pywebio</span></pre><p id="bf8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">API服务的内容如下:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="e534" class="mo mp iq mj b gy mq mr l ms mt">pylint<br/>pycodestyle<br/>black<br/>fastapi<br/>uvicorn[standard]<br/>redis</span></pre><p id="6200" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">API将使用<code class="fe mg mh mi mj b">fastapi </code>构建，而<code class="fe mg mh mi mj b">uvicorn </code>将用于托管API。我还安装了<code class="fe mg mh mi mj b">redis </code> Python模块来访问redis DB。</p><p id="44b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">包括文件的完整文件夹结构应该是这样的</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="5b71" class="mo mp iq mj b gy mq mr l ms mt">C:\DEV\MULTICONTAINERSETUP<br/>│   docker-compose.yml<br/>│   <br/>├───api<br/>│   └───.devcontainer<br/>│           devcontainer.json<br/>│           Dockerfile<br/>│           requirements.txt<br/>│           <br/>├───frontend<br/>│   └───.devcontainer<br/>│           devcontainer.json<br/>│           Dockerfile<br/>│           requirements.txt<br/>│           <br/>└───redis</span></pre><p id="fc2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用CTRL+SHIFT+P或F1访问VS代码命令面板，我们选择以下命令</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="67ab" class="mo mp iq mj b gy mq mr l ms mt">Remote-containers: Open Folder in Container</span></pre><p id="0863" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的窗口中，我们选择API或前端文件夹，vs代码将启动三个容器。如果一切正常，我们将看到容器中的一个终端，所有三个容器都将运行。</p></div></div>    
</body>
</html>