<html>
<head>
<title>Functional Programming: Using the ‘Semigroup’ Type Class to Merge Things</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式编程:使用“半群”类型的类来合并事物</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-programming-using-the-semigroup-type-class-to-merge-d3dc9815f53a?source=collection_archive---------14-----------------------#2020-05-18">https://betterprogramming.pub/functional-programming-using-the-semigroup-type-class-to-merge-d3dc9815f53a?source=collection_archive---------14-----------------------#2020-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="26e6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索“半群”类型类及其用例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/468c290f2c4c3d9f44b3f97b90ca2801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IzL6kfk468UzxQeqT3OO_g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">西蒙·艾布拉姆斯在<a class="ae kv" href="https://unsplash.com/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6ef3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将是一个包含几篇文章的系列，在其中我试图解释和展示一些函数式编程模式的用例。我们将使用TypeScript并使用函数式编程库<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/gcanti/fp-ts" rel="noopener ugc nofollow" target="_blank">fp-ts</a></code>。这些示例和解释受到了来自<code class="fe ls lt lu lv b">fp-ts</code>作者的<a class="ae kv" href="https://dev.to/gcanti/getting-started-with-fp-ts-ord-5f1e" rel="noopener ugc nofollow" target="_blank">伟大文章系列</a>的启发。</p><p id="e861" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们系列的第3部分，这篇文章是关于<code class="fe ls lt lu lv b">Semigroup</code>类型类的。我们将探索什么是<code class="fe ls lt lu lv b">Semigroup</code>类型类以及我们可以用它来做什么。</p><h2 id="7e3c" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">其他部分</h2><ul class=""><li id="f0eb" class="mp mq iq ky b kz mr lc ms lf mt lj mu ln mv lr mw mx my mz bi translated"><strong class="ky ir">第一部分:</strong><a class="ae kv" href="/better-programming/functional-programming-using-the-eq-type-class-to-check-for-equality-b7e9b989063a" rel="noopener ugc nofollow" target="_blank"/><code class="fe ls lt lu lv b"><a class="ae kv" href="/better-programming/functional-programming-using-the-eq-type-class-to-check-for-equality-b7e9b989063a" rel="noopener ugc nofollow" target="_blank">Eq</a></code><a class="ae kv" href="/better-programming/functional-programming-using-the-eq-type-class-to-check-for-equality-b7e9b989063a" rel="noopener ugc nofollow" target="_blank">类型类</a></li><li id="50be" class="mp mq iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated"><strong class="ky ir">第二部分:</strong><a class="ae kv" href="https://medium.com/@cedricdose/functional-programming-using-the-ord-type-class-to-order-things-17c3bfdc20ce" rel="noopener"/><code class="fe ls lt lu lv b"><a class="ae kv" href="https://medium.com/@cedricdose/functional-programming-using-the-ord-type-class-to-order-things-17c3bfdc20ce" rel="noopener">Ord</a></code><a class="ae kv" href="https://medium.com/@cedricdose/functional-programming-using-the-ord-type-class-to-order-things-17c3bfdc20ce" rel="noopener">类型类</a></li><li id="fa2f" class="mp mq iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated"><strong class="ky ir">第三部分:</strong>本文</li></ul></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="861a" class="nm lx iq bd ly nn no np mb nq nr ns me jw nt jx mh jz nu ka mk kc nv kd mn nw bi translated">“半群”型类</h1><p id="a797" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">首先我们来看看什么是<code class="fe ls lt lu lv b">Semigroup</code>以及它有什么作用。请阅读以下要点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="169a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太多了！但是别担心——我们会无话不谈的。</p><p id="7547" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们做的第一件事是用TypeScript接口定义<code class="fe ls lt lu lv b">Semigroup</code>类型类。正如你所看到的，要成为<code class="fe ls lt lu lv b">Semigroup</code>类型类的实例，需要定义一个<code class="fe ls lt lu lv b">concat</code>方法。</p><p id="845e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个<code class="fe ls lt lu lv b">concat</code>方法接受两个相同类型的参数，并返回该类型的单个值。因此我们可以看到这个<code class="fe ls lt lu lv b">concat</code>方法将两个类型为<code class="fe ls lt lu lv b">A</code>的值组合/合并/连接成一个类型为<code class="fe ls lt lu lv b">A</code>的值——例如，它接受两个字符串并返回另一个字符串。</p><p id="ebc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不知道你怎么想，但我认为这听起来对很多事情都很有用。我们将在本文后面看到一个更有趣的例子。</p><h2 id="5875" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">实现“半群”实例</h2><p id="a897" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">在上面的要点中，接下来发生的是我们为乘法运算下的<code class="fe ls lt lu lv b">number</code>类型实现一个<code class="fe ls lt lu lv b">Semigroup</code>实例，这意味着我们用一个<code class="fe ls lt lu lv b">concat</code>方法创建一个对象，该方法接受两个数并将它们相乘。我们也可以做加法。唯一的区别是，我们将两个数相加，而不是在<code class="fe ls lt lu lv b">concat</code>方法中相乘。</p><p id="7f35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还为类型<code class="fe ls lt lu lv b">string</code>定义了一个<code class="fe ls lt lu lv b">Semigroup</code>实例。这里我们将传递给<code class="fe ls lt lu lv b">concat</code>方法的两个字符串相加(连接)在一起，构建一个新的字符串。</p><p id="5cdc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在<code class="fe ls lt lu lv b">concat</code>方法中执行的前面的操作都是<code class="fe ls lt lu lv b">associative</code>，这意味着我们不必将表达式括起来，只需编写<code class="fe ls lt lu lv b">x * y * z</code>。<code class="fe ls lt lu lv b">Associativity</code>是一个对于<code class="fe ls lt lu lv b">Semigroup</code>实例的<code class="fe ls lt lu lv b">concat</code>方法必须成立的法则。</p><h2 id="47c1" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">实现“半群”实例的其他方式</h2><p id="0527" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Associativity</code>能成问题。有时对于一个类型没有关联操作。令人高兴的是，有两种方法可以为一个类型创建一个<code class="fe ls lt lu lv b">Semigroup</code>实例。</p><p id="6e01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一种方法是用只返回第一个或最后一个输入的<code class="fe ls lt lu lv b">concat</code>方法创建一个<code class="fe ls lt lu lv b">Semigroup</code>实例。看看要点中的<code class="fe ls lt lu lv b">getFirstSemigroup</code>和<code class="fe ls lt lu lv b">getLastSemigroup</code>功能。</p><p id="609c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个<code class="fe ls lt lu lv b">getFirst</code>和<code class="fe ls lt lu lv b">getLast</code>逻辑，我们也可以很容易地从一个已经定义了<code class="fe ls lt lu lv b">Ord</code>实例的类型中创建一个<code class="fe ls lt lu lv b">Semigroup</code>实例。我们可以通过在<code class="fe ls lt lu lv b">concat</code>方法中返回最小值或最大值来实现。</p><p id="058f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二种方法是创建一个所谓的类型为<code class="fe ls lt lu lv b">A</code>的自由<code class="fe ls lt lu lv b">Semigroup </code>。这意味着我们为类型<code class="fe ls lt lu lv b">A</code>创建一个<code class="fe ls lt lu lv b">Semigroup</code>实例，方法是将值包装在一个单例列表<code class="fe ls lt lu lv b">[A]</code>中，然后为类型<code class="fe ls lt lu lv b">Array&lt;A&gt;</code>创建一个<code class="fe ls lt lu lv b">Semigroup</code>实例，其中<code class="fe ls lt lu lv b">concat</code>是<code class="fe ls lt lu lv b">(x, y) =&gt; x.concat(y)</code>。<code class="fe ls lt lu lv b">x.concat</code>指内置的JS数组方法。</p><h2 id="e020" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">实现选项<a>的“半群”实例</a></h2><p id="58de" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">将两个数字或字符串合并在一起非常容易，但是如果我们想要合并像<code class="fe ls lt lu lv b">Option&lt;A&gt;</code>这样的上下文中的值呢？为此我们需要一些特殊的逻辑:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="29a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为类似于<code class="fe ls lt lu lv b">Option&lt;A&gt;</code>的东西实现一个<code class="fe ls lt lu lv b">Semigroup</code>实例也并不难。</p><p id="1be5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只需要在<code class="fe ls lt lu lv b">concat</code>方法中定义一些额外的逻辑。在这里，我们只是检查我们的<code class="fe ls lt lu lv b">concat</code>方法中的两个值是否都是<em class="oc">而不是</em> <code class="fe ls lt lu lv b">none</code>，如果是，我们从我们的<code class="fe ls lt lu lv b">Option&lt;A&gt;</code>中取出值，并将其应用于我们传递到<code class="fe ls lt lu lv b">getApplySemigroup</code>的<code class="fe ls lt lu lv b">Semigroup</code>实例中的<code class="fe ls lt lu lv b">concat</code>方法。</p><h2 id="6245" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">使用“折叠”合并值数组</h2><p id="8467" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">现在我们对什么是“s”有了一种感觉，并且知道我们可以将两个值合并/组合/连接在一起。但是有时我们想要将两个以上的值合并在一起。我们如何才能做到这一点？</p><p id="48db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，有一个函数可以做到这一点。它叫<code class="fe ls lt lu lv b">fold</code>，和内置的JS数组方法<code class="fe ls lt lu lv b">reduce</code>很像。让我们来看看:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="5d94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们可以看到，<code class="fe ls lt lu lv b">fold</code>接受一个<code class="fe ls lt lu lv b">Semigroup&lt;A&gt;</code>并返回一个函数，该函数接受一个初始值<code class="fe ls lt lu lv b">A</code>和一个数组<code class="fe ls lt lu lv b">A</code> ( <code class="fe ls lt lu lv b">Array&lt;A&gt;</code>)并返回一个<code class="fe ls lt lu lv b">A</code>。所以它将一个<code class="fe ls lt lu lv b">Array&lt;A&gt;</code>折叠/缩减成一个单一的值<code class="fe ls lt lu lv b">A</code>。在引擎盖下，<code class="fe ls lt lu lv b">fold</code>也使用<code class="fe ls lt lu lv b">Array.prototype.reduce</code>(<code class="fe ls lt lu lv b">reducer</code>是传入<code class="fe ls lt lu lv b">Semigroup</code>实例的<code class="fe ls lt lu lv b">concat</code>方法)。</p><p id="a71e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太酷了！我们现在可以映射一个数组，并将其合并/简化为一个值。当我们稍后看到一个更有趣的例子时，这就更酷了。</p><h2 id="09b6" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">实现对象的“半群”实例</h2><p id="1185" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">我们已经看到了一些如何为某些类型创建<code class="fe ls lt lu lv b">Semigroup</code>实例的例子，但是我们还没有看到如何为<code class="fe ls lt lu lv b">object</code>实现<code class="fe ls lt lu lv b">Semigroup</code>实例。所以让我们开始吧:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="34ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">semigroupSong</code>的第一个定义是用更手动的方式创建的。<br/>我们通过定义一个<code class="fe ls lt lu lv b">concat</code>方法来为我们的<code class="fe ls lt lu lv b">Song</code>类型创建一个<code class="fe ls lt lu lv b">Semigroup</code>实例，该方法接受两个<code class="fe ls lt lu lv b">Song</code>类型的对象，并将它们与我们为每个键定义的规则/函数组合在一起。</p><p id="6b86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我们通过过滤较大的数字来保留最近的年份，从而合并关键字<code class="fe ls lt lu lv b">releaseYear</code>。</p><p id="f5ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经自己编写了将键合并在一起的规则/函数，但是我们也可以从现有的<code class="fe ls lt lu lv b">Semigroup</code>实例中使用<code class="fe ls lt lu lv b">concat</code>方法。就像我们的<code class="fe ls lt lu lv b">semigroupProduct</code>，它的<code class="fe ls lt lu lv b">concat</code>方法通过相乘将两个值合并在一起。</p><p id="5ba1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">semigroupSong</code>的第二个定义是通过使用<code class="fe ls lt lu lv b">fp-ts</code>中的一些函数创建的。它遵循与之前大致相同的逻辑，但是这一次我们没有定义一个<code class="fe ls lt lu lv b">concat</code>方法，只是为对象的每个键定义/使用完整的<code class="fe ls lt lu lv b">Semigroup</code>实例，而不仅仅是一个函数。</p><p id="da3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在底层，它也只是将输入应用于我们为对象的键定义的<code class="fe ls lt lu lv b">Semigroup</code>实例的<code class="fe ls lt lu lv b">concat</code>方法。</p><p id="b897" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个例子的有趣之处在于，我们现在可以为每个键使用定制的合并逻辑来合并对象。这可能真的很有用——例如，当我们有两个来自不同数据源的<code class="fe ls lt lu lv b">Song</code>并且想要将它们组合/合并成一个，但是对于每个键应该保留什么值有一些规则。</p><p id="25ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类型类对于定义类型的自定义合并逻辑非常有用。</p><p id="0404" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢这个关于<code class="fe ls lt lu lv b">Semigroup</code>类型的简短介绍。下一篇文章将是关于<code class="fe ls lt lu lv b">Monoid</code>类型类的。</p></div></div>    
</body>
</html>