<html>
<head>
<title>Architecting Distributed Systems: The Importance of Idempotence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建分布式系统:幂等性的重要性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/architecting-distributed-systems-the-importance-of-idempotence-138722a6b88e?source=collection_archive---------1-----------------------#2021-12-08">https://betterprogramming.pub/architecting-distributed-systems-the-importance-of-idempotence-138722a6b88e?source=collection_archive---------1-----------------------#2021-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="187d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">幂等系统如何允许更简单和更少浪费的软件集成的图解说明</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/712b628582baeeef7305068d29e85a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dH1GwaW3Si4QYMU9THn7Rw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a3d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幂等性(如果你愿意，也可以称之为<em class="lu">幂等性</em>)是一个操作的特征，比如一个HTTP端点或一个RPC调用，允许多次执行它并观察到相同的结果，就好像操作只应用了一次一样。</p><p id="7636" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换句话说，当与另一个系统(如第三方支付提供商)集成时，您希望能够不止一次地请求相同的支付，但您希望提供商只转移一次资金。</p><p id="0cd1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个显而易见的问题是:为什么有人会不止一次要求相同的付款？在理想的情况下，通常在99%以上的情况下，您的系统、提供商、网络和其他一切都工作正常，并且操作在第一次尝试时成功完成。但是，如果出现问题，并且您不确定操作的结果，您可能需要重试，再次提交相同的付款请求。这种情况在我的关于API失败的文章中有详细的解释，如果你还没有接触过集成，我强烈推荐你阅读这篇文章，因为它有助于理解本文的其余部分。</p><p id="4bd1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了充分理解幂等运算的价值，我们将比较两个假想的支付提供商的集成工作:第一个不是幂等的，第二个是幂等的。我们的要求保持不变:</p><p id="66b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">如果操作过程中系统的任何部分出现故障，并且我们不知道操作是否成功，我们应该能够重试操作，直到操作成功，并且操作必须恰好执行一次</em>。</p><p id="cb23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了模拟这个场景，我们将假设我们的服务器在发送请求之后<em class="lu">崩溃，但是在</em>收到来自第三方系统的响应之前<em class="lu">崩溃。在我们的服务器重新启动后，我们希望确保只有一次支付成功执行。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/18fd6a0391d8646f84b73a2820a39872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yQdehVZf1WAD2vdpG4hFrA.png"/></div></div></figure><p id="eae8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意:如果我们不知道执行是否成功，或者如果我们有理由相信故障是暂时的，我们必须重新启动。如果提供者用一个<code class="fe lx ly lz ma b">400: bad request</code>来响应，重试没有任何帮助，我们必须使操作失败。</p><h1 id="e856" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">与非幂等系统集成</h1><p id="5276" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">让我们集成一个非幂等系统，并尝试使它对故障有弹性，满足我们最初的要求。这里有一个我们必须集成的非幂等API:</p><pre class="kj kk kl km gt my ma mz na aw nb bi"><span id="74f7" class="nc mc it ma b gy nd ne l nf ng">POST /payments<br/>{<br/>  "from": "sender@email.com",<br/>  "to": "recipient@email.com",<br/>  "amount": 120<br/>}</span></pre><p id="66e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每次我们向<code class="fe lx ly lz ma b">/payment</code>端点发出POST请求时，支付提供商都会尝试将指定金额的钱从发送方转移到接收方。</p><p id="8b8e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于我们的服务器在等待响应时崩溃，并且我们不知道第一次尝试的结果是什么(支付可能实际上已经成功)，我们不能再次调用同一个端点，因为这样我们就冒着进行两次支付而不是一次支付的风险。首先，我们需要弄清楚我们之前执行支付的尝试发生了什么。这意味着提供者需要公开至少一个以上的端点，列出已经执行的过去的支付，以便我们检查是否应该继续POST调用:</p><pre class="kj kk kl km gt my ma mz na aw nb bi"><span id="e071" class="nc mc it ma b gy nd ne l nf ng">GET /payments</span></pre><p id="a190" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们这边，现在我们需要在每次尝试调用POST端点之前调用这个端点，而不仅仅是为了重试。这是因为，如果不对我们的系统进行任何额外的修改(例如，在呼叫第三方提供商之前坚持所有的支付尝试)，我们就无法判断我们是第一次尝试还是再次尝试相同的支付。这导致我们执行一次支付所需的API调用增加了2倍，但看起来它解决了双重执行的问题！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/5ae39a3f67eae898188b56573d533c70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_oygyTC0pPyYqJwzWSXsEQ.png"/></div></div></figure><p id="69d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">…或者是吗？</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="7e80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的内容在理论上看起来很好，一次只有一个后端实例试图调用提供者…但是现实总是这样吗？如果用户打开了两个浏览器标签，并试图在几乎相同的时间从这两个标签中查看同一个购物车，会怎么样？很有可能,<code class="fe lx ly lz ma b">GET /payments</code>请求会对我们的两个并行流程产生相同的响应，并且两个流程都会继续尝试并执行<code class="fe lx ly lz ma b">POST /payments</code>调用，这可能会导致两次支付而不是一次。不理想。</p><p id="06cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有多种方法可以解决这个问题，但是所有这些方法都依赖于使自然的异步过程同步，比如一次从几个浏览器窗口进行API调用。我们可以用单线程处理所有请求，使用锁，将所有尝试保存在数据库中，或者使用一些其他的魔法来防止相同支付的并行执行。</p><p id="b771" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然这肯定是可能的，但它增加了复杂性，需要仔细维护和彻底测试。在这个阶段，我们已经满足了我们的需求，但是我们需要使用一个额外的API调用和某种同步机制来防止相同支付的并行执行。此外，我们的整体性能可能会受到这些增加的影响。</p><p id="a063" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看这个开销是否可以避免。</p><h1 id="fb8f" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">与幂等系统的集成</h1><p id="6707" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">下面是我们的等幂支付提供商API的样子:</p><pre class="kj kk kl km gt my ma mz na aw nb bi"><span id="2233" class="nc mc it ma b gy nd ne l nf ng">PUT /payments/{payment_id}<br/>{<br/>  "from": "sender@email.com",<br/>  "to": "recipient@email.com",<br/>  "amount": 120<br/>}</span></pre><p id="68cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，有两个显著的区别:</p><ol class=""><li id="9ffb" class="np nq it la b lb lc le lf lh nr ll ns lp nt lt nu nv nw nx bi translated">用PUT代替POST</li><li id="43c5" class="np nq it la b lb ny le nz lh oa ll ob lp oc lt nu nv nw nx bi translated">附加<code class="fe lx ly lz ma b">payment_id</code>参数</li></ol><p id="ba69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">POST和PUT的主要区别在于，PUT应该是幂等的，而POST应该在每次被调用时创建一个新的资源。更详细的解释可以在<a class="ae lv" href="https://restfulapi.net/rest-put-vs-post/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="b42a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">额外的<code class="fe lx ly lz ma b">payment_id</code>参数充当我们的幂等键，用于唯一地标识支付，允许提供者在我们不止一次调用API的情况下删除重复的请求。这确实使我们有必要<strong class="la iu">生成这个唯一的id </strong>，尽管在某些情况下这可能是有挑战性的，并且这个逻辑将取决于用例。在我们的情况下，我们可以假设用户id和购物车id的组合唯一地标识了一个付款请求。如果您正在与电子邮件提供商集成，作为一个选项，这可以是发件人、收件人列表和主题的散列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/3a4a7697de6879943a0bceb2e011a3bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4yFEXny2Shw_YecpfJAzFg.png"/></div></div></figure><p id="4d8a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样的端点允许我们多次尝试执行相同的操作，直到得到成功的响应，而不必担心并行执行或额外的支付成功检查。因此，我们可以编写更少的生产代码，更少的测试代码来覆盖生产代码，并且睡得更好。</p><p id="4ab4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">额外提示:当重试此类操作时，建议在超时中添加一些随机化。我在我的关于分布式系统中随机数的文章中解释了原因。您可能还想将重试逻辑封装在客户端库中，以简化集成，正如关于<a class="ae lv" rel="noopener ugc nofollow" target="_blank" href="/architecting-distributed-systems-increasing-availability-using-client-libraries-b4763d4d74c9">客户端库如何提高系统可用性的文章</a>中所解释的那样。</p><h1 id="bb41" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="185f" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我希望这个例子显示了与幂等系统集成是多么容易。作为一名开发人员，花一点时间来欣赏这些令人愉快的API，如果您自己正在开发一个API，那么尽可能使它幂等。</p><pre class="kj kk kl km gt my ma mz na aw nb bi"><span id="059c" class="nc mc it ma b gy nd ne l nf ng"><strong class="ma iu">Want to Connect With the Author?</strong></span><span id="c709" class="nc mc it ma b gy oe ne l nf ng">Check out <a class="ae lv" href="https://konarskis.com/" rel="noopener ugc nofollow" target="_blank">konarskis.com</a>.</span></pre></div></div>    
</body>
</html>