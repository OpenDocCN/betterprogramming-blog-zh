<html>
<head>
<title>From Micro to Macro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从微观到宏观</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/from-micro-to-macro-git-branching-model-and-workflow-8dc1b230a28e?source=collection_archive---------0-----------------------#2019-01-12">https://betterprogramming.pub/from-micro-to-macro-git-branching-model-and-workflow-8dc1b230a28e?source=collection_archive---------0-----------------------#2019-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4945" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">自定义git分支模型和工作流</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2b306d6ea820253177c8fb2c68dc050b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2yKpI-DmLmNlSi2SdAZGww.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">阿尔瓦罗·雷耶斯在<a class="ae kv" href="https://unsplash.com/s/photos/workflow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9da5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在过去的一年里，我一直致力于一个简单而干净的GIT工作流和一个分支模型。该流程适合中长期生产项目，尤其是基于web的项目，但是可以扩展到任何项目。</p><p id="986e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该流程分为两部分。首先是<strong class="ky ir">宏</strong>分支模型，它定义了不同的分支以及它们之间的关系。第二个是<strong class="ky ir">微观</strong>模型，它定义了每个分支内部的GIT工作流。</p><blockquote class="ls lt lu"><p id="b21b" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><em class="iq">该模型基于Florent Lebreton撰写的</em>“<a class="ae kv" href="https://fle.github.io/an-efficient-git-workflow-for-midlong-term-projects.html" rel="noopener ugc nofollow" target="_blank">中长期项目的高效GIT工作流</a>”中发表的观点。</p></blockquote></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="c7d0" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">TL；速度三角形定位法(dead reckoning)</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/730dfdfe2866c44b3d0bf60f408e3d02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mrLuEolKE97FsBp4QRDiCA.png"/></div></div></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="1b52" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">定义</h1><p id="82b6" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在进入流程之前，让我们先定义一些我们稍后会用到的术语:</p><ul class=""><li id="a6b9" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><strong class="ky ir">微流程</strong>是指处理特性\bug分支上的提交的工作流，包括提交命名约定和合并分支的指令。</li><li id="3b45" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir">宏流程</strong>描述了所有分支(bug、特性、静态分支)之间的关系以及如何管理它们，包括:分支命名约定、处理bug和热修复、合并特性、创建发布候选、以及标记发布。</li><li id="7e42" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir">静态分支</strong>是那些一直存在的分支(即开发、发布候选和产品\主)</li><li id="9682" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir">特性\Bug分支</strong>是短期分支(新特性和Bug修复)。这些存在直到它们被合并到静态分支(开发，发布候选)。</li><li id="2ae0" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">Git-Master 是一个负责执行宏流程、计划和协调静态分支，以及帮助修复任何其他问题的人。根据我的经验，修复静态分支上的错误可能很耗时，因此最好有一个对流程有深刻理解的维护者来协调和管理存储库。</li><li id="1c52" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir">bug-fix</strong>vs<strong class="ky ir">release candidate fix</strong>vs<strong class="ky ir">hot-fix</strong>都是Bug修复，区别在于发现Bug的时间，更重要的是，它将在何时被修复:</li><li id="a158" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">Hot-fix :一个关键的优先bug修复，通常在计划的产品周期之外进行修复。</li><li id="9113" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir"> Bug-fix </strong>:来自数据库的预定Bug修复。</li><li id="6651" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir">发布候选修复</strong>:在新特性完成后(合并到<code class="fe ns nt nu nv b">dev</code>)和代码发布前(合并到<code class="fe ns nt nu nv b">prod</code>)发现的bug修复。</li><li id="1685" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">我们处理流程中每种类型的bug修复的方式略有不同。</li></ul><p id="e424" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还应该定义一些分支类型:</p><ul class=""><li id="5d21" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><strong class="ky ir"> dev </strong>分支包含最新的特性和bug修复<strong class="ky ir">。这个分支应该总是为发布候选(RC)做好准备。换句话说，我们应该避免合并正在进行的工作。任何新的特性或计划的bug修复分支都是基于<code class="fe ns nt nu nv b">dev</code>的，并在重设基础后合并回<code class="fe ns nt nu nv b">dev</code>(更多关于微流程中的内部管理)</strong></li><li id="5614" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir"> RC </strong> (rc/x.y.z):发布候选(RC)分支是一个“代码冻结”点(在<code class="fe ns nt nu nv b">dev</code>上)。对于每一个准备发布的版本，我们创建一个临时分支来代表发布候选(在宏流程中有更多关于这个分支的信息)。</li><li id="4478" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir"> prod </strong>(或master):这个分支包含所有被标记的官方(非候选)版本。</li></ul></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="60ba" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">规则</h1><p id="6ba7" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">对于整个流程，我们应始终遵循以下规则:</p><ul class=""><li id="8e10" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">一次一个维护者(Git-Master)。</li><li id="c07b" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">永远不要直接提交到任何静态分支。</li><li id="b129" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">永远不要改变静态分支的基础。</li><li id="c739" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">不要脱离计划好的工作流程。</li></ul></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="b74d" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">流程概述</h1><p id="7637" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">目标很简单:以最简单、最干净的方式将代码从<code class="fe ns nt nu nv b">dev</code>带到<code class="fe ns nt nu nv b">prod</code>，允许验证团队在代码进入<code class="fe ns nt nu nv b">prod</code>之前对其进行测试。</p><p id="6474" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于任何<strong class="ky ir">新特性</strong>或<strong class="ky ir"> bug修复</strong>，我们会基于<code class="fe ns nt nu nv b">dev</code>创建一个新的分支。完成后，我们合并回<code class="fe ns nt nu nv b">dev</code>。一旦新特性/缺陷修复准备好发布，我们通过创建一个新的发布候选<code class="fe ns nt nu nv b">rc/x.y.z</code>分支来“冻结代码”，并且我们将该版本标记为发布候选<code class="fe ns nt nu nv b">x.y.z-rc.0</code>。在这一点上，验证团队可以验证这个候选版本。如果没有发现错误，该版本可以合并到<code class="fe ns nt nu nv b">prod</code>并标记为正式版本<code class="fe ns nt nu nv b">x.y.z</code>。否则，我们修复<code class="fe ns nt nu nv b">release candidate bugs</code>并创建另一个发布候选。我们重复这个过程，直到候选人通过验证。最后，我们可以将<code class="fe ns nt nu nv b">RC</code>分支合并到<code class="fe ns nt nu nv b">prod</code>。</p><p id="0fe8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的流程说明了“代码冻结”点的概念。很容易看出，每个<code class="fe ns nt nu nv b">RC</code>分支都是一个保护层，允许验证团队测试版本，并允许开发团队修复发布候选错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/ac2f434f2a9b1ff6c9d6b144eb0c8fe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ellByY2y2TpzLxfKbIuSA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">RC提交颜色代表验证状态(红色=失败，绿色=通过)</p></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="3243" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">第一部分:宏观分支模型</h1><p id="a490" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我认为，在我们进入管理提交的细节(第二部分中的微观工作流)之前，如果我们理解大图(宏观分支模型)会更容易。</p><p id="ed53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用以下分支命名约定。就我个人而言，我发现这些惯例有助于保持历史的整洁和可读性。但是，只要每个人都同意，您可以使用其他约定:</p><ul class=""><li id="4884" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><strong class="ky ir">特征分支名称</strong> — <code class="fe ns nt nu nv b">feat/&lt;ID&gt;/&lt;title&gt;</code>。<br/> <code class="fe ns nt nu nv b">ID</code> —待办事项中的任务\故事ID号。<br/> <code class="fe ns nt nu nv b">title </code> —一个简短的(最多几个字)，小写的特征标题。</li><li id="3642" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir"> Bug分支名称— </strong> <code class="fe ns nt nu nv b">bug/&lt;ID&gt;/&lt;title&gt;</code>(针对任何Bug修复类型— A、B或C)</li><li id="dd4e" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir">发布候选</strong>(分支)— <code class="fe ns nt nu nv b">rc/&lt;version&gt;</code> <br/> <code class="fe ns nt nu nv b">version</code> —对于版本化，我们使用<a class="ae kv" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本化</a>约定。</li><li id="08c7" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir">发布候选标签</strong>——在创建了一个<code class="fe ns nt nu nv b">RC</code>分支之后，我们可能想要将它标记为候选标签<code class="fe ns nt nu nv b">&lt;version&gt;-rc.&lt;index&gt;</code>(例如<code class="fe ns nt nu nv b">1.2.3-rc.0</code>)。</li></ul><h2 id="d8a0" class="nx mh iq bd mi ny nz dn mm oa ob dp mq lf oc od ms lj oe of mu ln og oh mw oi bi translated"><strong class="ak">宏工作流程配方</strong></h2><p id="1cd9" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在这个食谱中，我将描述从完成工作(在<code class="fe ns nt nu nv b">dev</code>上)到发布的步骤。</p><ol class=""><li id="0a24" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr oj nk nl nm bi translated">基于<code class="fe ns nt nu nv b">dev</code>创建一个<code class="fe ns nt nu nv b">RC</code>分支<code class="fe ns nt nu nv b">rc/x.y.z</code>。</li><li id="f44f" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr oj nk nl nm bi translated">使用标准版本标记发布候选。<br/> <code class="fe ns nt nu nv b">standard-version --prerelease rc &amp; git push</code> <br/> —如果<code class="fe ns nt nu nv b">RC</code>有bug，修复它们(遵循微流程的约定)，再次标记，重复直到候选被批准发布。<br/> —在这一点上，我们期望看到下一个版本的带有后缀<code class="fe ns nt nu nv b">-rc.0</code>的新标签。</li><li id="13d2" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr oj nk nl nm bi translated">如果我们需要修复bug:<br/><strong class="ky ir">a .</strong>创建一个新的bugfix分支<code class="fe ns nt nu nv b">git checkout -b fix/&lt;name&gt;</code>(微流中的名称更多)并修复bug。<br/> <strong class="ky ir"> b. </strong>将bug合并到<code class="fe ns nt nu nv b">RC</code>分支(建议:为代码评审创建拉请求。如果使用GitHub，使用“合并拉取请求”选项)<br/> <strong class="ky ir"> c. </strong>标记新的发布候选(回到步骤2)。</li><li id="fbb2" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr oj nk nl nm bi translated">(假设没有bug，版本获得了绿灯)<br/>将<code class="fe ns nt nu nv b">RC</code>分支合并到<code class="fe ns nt nu nv b">prod</code>。</li><li id="a4cf" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr oj nk nl nm bi translated">标记发布提交。<br/> <code class="fe ns nt nu nv b">standard-version &amp; git push</code></li><li id="cc28" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr oj nk nl nm bi translated">合并<code class="fe ns nt nu nv b">prod</code>到<code class="fe ns nt nu nv b">RC</code>和<code class="fe ns nt nu nv b">dev</code> : <br/>执行标准版本工具将更新changelog(在<code class="fe ns nt nu nv b">prod</code>上)。因此，要获得正确的版本，我们需要:<br/> <strong class="ky ir"> a. </strong>将prod合并到<code class="fe ns nt nu nv b">RC</code>(以防我们需要热修复)<br/> <strong class="ky ir"> b. </strong>将<code class="fe ns nt nu nv b">RC</code>合并到<code class="fe ns nt nu nv b">dev<br/></code> <em class="lv">注意:我们可以直接将prod合并到</em> <code class="fe ns nt nu nv b"><em class="lv">dev</em></code> <em class="lv">，但是当使用类似于</em><a class="ae kv" href="https://www.gitkraken.com/" rel="noopener ugc nofollow" target="_blank"><em class="lv">git kraken</em></a><em class="lv">的工具时，上面的流程会产生更好的图形。</em></li></ol><h2 id="7095" class="nx mh iq bd mi ny nz dn mm oa ob dp mq lf oc od ms lj oe of mu ln og oh mw oi bi translated"><strong class="ak">附加步骤</strong></h2><p id="31b4" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">删除最后两个分支之前的<code class="fe ns nt nu nv b">RC</code>分支(我们总是保留最后两个<code class="fe ns nt nu nv b">RC</code>分支)</p><ul class=""><li id="6de0" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">看一下结果图——确保它看起来像你预期的那样。</li><li id="b96c" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">删除所有合并的临时分支(即feat\fix)。</li><li id="b82e" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">将所有现有的分支重新设置为最新的<code class="fe ns nt nu nv b">dev</code>是一个很好的实践。</li></ul></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="ecab" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">第二部分—微GIT工作流</h1><p id="a33d" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">实现简单、干净和可读的分支的方法是维护线性分支。</p><p id="386d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">线性分支</strong>是一个<strong class="ky ir"> <em class="lv"> " </em> </strong> <em class="lv"> Git历史，其中所有的提交都是一个接一个的"</em> ( <a class="ae kv" href="http://www.bitsnbites.eu/a-tidy-linear-git-history/" rel="noopener ugc nofollow" target="_blank">来源</a>)。我们通过在合并前总是重新建立基础来实现它。让我们更深入地了解一下<strong class="ky ir">重定基础</strong>和<strong class="ky ir">合并:</strong></p><p id="d4a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了给<strong class="ky ir">重设基础</strong>，我们使用<code class="fe ns nt nu nv b"><strong class="ky ir">git rebase -i </strong>&lt;branch&gt;</code></p><p id="ba97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ns nt nu nv b">-i</code>允许编辑提交(重命名、压缩、删除等):</p><blockquote class="ls lt lu"><p id="f43e" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">(<code class="fe ns nt nu nv b">-i</code> ) " <em class="iq">最简单的形式是将另一个分支合并到您当前工作的分支中的命令，并且</em> <strong class="ky ir"> <em class="iq">将重定基础分支之前的所有本地提交移动到该分支上的历史</em> </strong> <em class="iq">的顶部。</em>”(<a class="ae kv" href="https://nathanleclaire.com/blog/2014/09/14/dont-be-scared-of-git-rebase/" rel="noopener ugc nofollow" target="_blank">来源</a>)。</p></blockquote><p id="d427" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于合并，我们有两个选项:有或没有<code class="fe ns nt nu nv b">--no-ff</code>(无快进)标志:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/9f31d598d9e27b1829c4e10aa4b1636a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*YzE6ZF7922wBHsdIJ9OHpA.png"/></div></figure><p id="22bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<strong class="ky ir">静态分支，</strong>我们使用无快进合并(在合并期间使用<code class="fe ns nt nu nv b">--no-ff</code>标志)。</p><p id="04e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，<code class="fe ns nt nu nv b">dev</code>分支应该看起来像:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/2856e1ff4d66df88e0e751bebcf83aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*R2RJhY99RwrKP0oOG4Xazg.png"/></div></figure><p id="93df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用<code class="fe ns nt nu nv b">--no-ff</code>,我们将提交分组在一起。这些组使得分支历史更具可读性，更重要的是，通过多次提交可以很容易地恢复特性或修复——我们所需要做的就是恢复单次合并提交。</p><p id="e41b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TK由于使用特性/修复分支，我们不希望对提交进行分组，并且恢复多个提交将是线性快进<code class="fe ns nt nu nv b">— ff</code>合并。</p><h2 id="4d7d" class="nx mh iq bd mi ny nz dn mm oa ob dp mq lf oc od ms lj oe of mu ln og oh mw oi bi translated">履行约定</h2><p id="2488" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">因为我们使用的是标准版本，所以使用<a class="ae kv" href="https://www.conventionalcommits.org/en/v1.0.0-beta.2/" rel="noopener ugc nofollow" target="_blank"> GIT常规提交消息</a>很重要</p><p id="994e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从标准版本文档:</p><blockquote class="ls lt lu"><p id="1c16" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><em class="iq">“只要您的git提交消息是常规的和准确的，您就不再需要指定semver类型——并且您可以免费获得CHANGELOG生成！\o/" </em></p></blockquote><p id="f219" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">典型的提交消息具有以下格式:</p><pre class="kg kh ki kj gt om nv on oo aw op bi"><span id="2e0d" class="nx mh iq nv b gy oq or l os ot">&lt;type&gt;: &lt;ID&gt; &lt;description&gt;</span></pre><p id="cd66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要讨论的另一点是提交什么以及提交多少次。一般来说，当你在一个分支上工作(特性或者bug修复)时，你可以尽可能频繁地提交(保存状态)，并且当你不再需要它们时压缩提交。我的经验是，只有在将来有机会使用(恢复或审查)代码时才提交。</p><p id="10ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，在bug修复分支中，bug修复通常应该在一次提交中完成。如果它是一个特性分支，那么将特性分成更小的有意义的子任务并对每个子任务进行提交是有意义的。</p><h2 id="c758" class="nx mh iq bd mi ny nz dn mm oa ob dp mq lf oc od ms lj oe of mu ln og oh mw oi bi translated"><strong class="ak">微工作流程配方</strong></h2><ol class=""><li id="461d" class="ne nf iq ky b kz mz lc na lf ou lj ov ln ow lr oj nk nl nm bi translated">使用<code class="fe ns nt nu nv b">dev</code>分支作为基础，从<code class="fe ns nt nu nv b">dev</code>创建一个新的工作分支(除非我们和其他人一起工作在相同的特性上——稍后会详细介绍)。</li><li id="35d6" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr oj nk nl nm bi translated">通过使用<code class="fe ns nt nu nv b">rebase </code> — <code class="fe ns nt nu nv b">git rebase dev</code>，让工作分支与<code class="fe ns nt nu nv b">dev</code>保持同步是一个好的做法。在这一点上，与<code class="fe ns nt nu nv b">dev</code>的冲突是可能的，但是保持工作分支总是与最新的<code class="fe ns nt nu nv b">dev</code>保持一致应该使它们容易解决。</li><li id="a559" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr oj nk nl nm bi translated">当开发完成后，返回到<code class="fe ns nt nu nv b">dev</code>并创建一个pull请求(GitHub)用于代码评审。<code class="fe ns nt nu nv b">git rebase dev</code> <strong class="ky ir"> </strong>或者，如果需要分支清理，<code class="fe ns nt nu nv b">git rebase -i dev</code>修改工作分支历史。</li><li id="5090" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr oj nk nl nm bi translated">在代码被批准并准备好被合并之后:<br/> —确保工作分支在<code class="fe ns nt nu nv b">dev</code>被重置为最新提交。<br/>—Git-Admin使用“<a class="ae kv" href="https://help.github.com/articles/about-pull-request-merges/" rel="noopener ugc nofollow" target="_blank">合并拉取请求</a>”选项将分支合并到<code class="fe ns nt nu nv b">dev</code>。另一个选项是命令行:<code class="fe ns nt nu nv b">git merge --no-ff &lt;branch&gt;</code>。</li></ol><h2 id="c5cd" class="nx mh iq bd mi ny nz dn mm oa ob dp mq lf oc od ms lj oe of mu ln og oh mw oi bi translated"><strong class="ak">例子</strong></h2><p id="5027" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在这个例子中，我们有三个开发人员在三个分支上工作:</p><ul class=""><li id="96ed" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">开发者1💙:正在制作一个功能<code class="fe ns nt nu nv b">feat/T-1/A</code></li><li id="25f3" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">开发者2💛:正在修复一个错误<code class="fe ns nt nu nv b">fix/B-1/C</code></li><li id="3e53" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">开发者3💜:正在制作一个功能<code class="fe ns nt nu nv b">feat/T-2/B</code></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/2e216d639a6d25e08948f4cc25c1fb2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*UuOPq6nPE3EROQUMZTfS1g.png"/></div></figure><p id="34fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开发者1💙:完成，他准备合并，因为他与开发是最新的，他可以创建PR，当PR被批准的分支可以由Git-Admin合并。</p><p id="8baf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开发者3💛:遵循最佳实践，并将其代码重置为<code class="fe ns nt nu nv b">dev</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/72e7d30dd1867875827b1383d326a701.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*BzGvfuMhiLJSeYu_63f2GA.png"/></div></figure><p id="9087" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Git-Admin合并了开发人员3💛编码并询问开发人员2💜重定基数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/f465009cd574e3b3105e8be5895de283.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*zVjJal0IwnRxUhTrRh98ug.png"/></div></figure><p id="7221" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在PR被批准后，错误修复💜可以合并到<code class="fe ns nt nu nv b">dev</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/2856e1ff4d66df88e0e751bebcf83aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*R2RJhY99RwrKP0oOG4Xazg.png"/></div></figure><h2 id="7f50" class="nx mh iq bd mi ny nz dn mm oa ob dp mq lf oc od ms lj oe of mu ln og oh mw oi bi translated"><strong class="ak">注意事项和提示</strong></h2><p id="916c" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">你可能已经注意到，神奇的词是rebase。Git-Admin应该在合并分支之前验证它是否被重定了基。即使犯了错误，撤销更改也很容易:</p><ul class=""><li id="8a00" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">只需<strong class="ky ir">将</strong>的<code class="fe ns nt nu nv b">dev</code>分支重置为之前的提交:<br/> <code class="fe ns nt nu nv b">git checkout dev</code> <br/> <code class="fe ns nt nu nv b">git reset — hard HEAD~1</code> <br/> <code class="fe ns nt nu nv b">git push</code></li><li id="9cb4" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">为了确保在这个过程中不会丢失分支，在分支的最后一次提交(分支的<code class="fe ns nt nu nv b">HEAD</code>)中创建一个临时分支(作为分支的指针)。</li><li id="49a9" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">遵循微流程中的步骤3–4(重设基础和合并)。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/3d8176fa62435ee6410571d2eae0a60d.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*ezB1BDN9CzdE5eLuTjVu9A.png"/></div></figure><p id="536d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了保持工作环境的整洁，最好删除本地和远程分支。</p><p id="6efe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我个人使用GitHub分支视图来移除分支。它帮助我避免意外删除未合并的分支。</p><p id="9723" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在pull请求被审查并且分支被合并到dev之后，没有理由保留远程分支——最好是<strong class="ky ir">删除</strong>已完成的分支以保持git环境的整洁。</p><h2 id="cbef" class="nx mh iq bd mi ny nz dn mm oa ob dp mq lf oc od ms lj oe of mu ln og oh mw oi bi translated"><strong class="ak">处理热修复</strong></h2><p id="f099" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">报告了一个严重的错误，您必须提供快速修复？让我们看看如何利用这种优势。还记得我们保留的树枝吗？我们用它来修复关键的错误。</p><ol class=""><li id="94f0" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr oj nk nl nm bi translated">将<code class="fe ns nt nu nv b">prod</code>合并到stage中(因为我们需要将标签版本放入<code class="fe ns nt nu nv b">RC</code>)。</li><li id="0a0b" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr oj nk nl nm bi translated">可能已经有另一个打开的<code class="fe ns nt nu nv b">RC</code>分支(最新版本)，但是如果没有，跳到步骤3。如果是这样，我们必须删除RC分支上的所有标签(并在<code class="fe ns nt nu nv b">rebase</code>之后重新创建它们)。</li><li id="c18a" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr oj nk nl nm bi translated">遵循宏工作流程:提交<code class="fe ns nt nu nv b">hotfix</code>，标记(<code class="fe ns nt nu nv b">pre-release</code>，合并到<code class="fe ns nt nu nv b">prod</code>，释放，然后合并到<code class="fe ns nt nu nv b">dev</code>。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/1d2ba44cadba92e08df7a431b416d5f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LnL0DTuGcwOVKQVC9mKf8Q.png"/></div></div></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="89f6" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">摘要</h1><p id="e716" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我希望到现在为止，您已经很好地了解了这个流程是如何工作的。我喜欢这个流程的一点是它的灵活性。由于每个项目都是不同的，团队结构会发生变化，任务管理方法也是不同的，所以您可以根据自己的需要修改和扩展流程。</p><p id="3051" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我要感谢Dominique Legault的流程设计和评审！</p></div></div>    
</body>
</html>