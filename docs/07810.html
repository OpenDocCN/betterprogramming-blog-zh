<html>
<head>
<title>Sharing Logic Components Between Frontend and Backend Repositories</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在前端和后端存储库之间共享逻辑组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sharing-logic-components-between-frontend-and-backend-repositories-6fdc1f9cb850?source=collection_archive---------8-----------------------#2021-02-22">https://betterprogramming.pub/sharing-logic-components-between-frontend-and-backend-repositories-6fdc1f9cb850?source=collection_archive---------8-----------------------#2021-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8dfb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">前端，后端，谁在乎？如果代码的逻辑有效，那么组件可以在任何地方共享</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/adda6f639ec2a5b76c0a8651430d5ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cVZlWlRrqrYBb92Z"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">凯利·西克玛在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="68d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">公司经常选择为前端和后端代码维护不同的存储库。当技术不同时，这很有意义(例如，在前端使用JS，在后端使用Java)。但是，即使你在前台和后台都使用JS，保持独立的repos允许更简单的分支模型和版本控制工作流(每个团队都可以处理任何更适合他们需求的事情)。</p><p id="cdfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也就是说，当这种情况发生时，某些逻辑组件(即解决一个特定过程的代码片段)将不得不在项目之间共享，以避免代码重复并保持功能和行为的一致性。这方面的一个例子是用户输入验证器，它不一定涉及特定的前端或后端代码，并在两个地方解决相同的问题。</p><p id="1a7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对此肯定有解决方案，但大多数都要求您以包的形式提供这些公共代码，而这些包又需要从您的源代码中提取出来，放入它们自己的独立项目中。这给你的工作流程增加了额外的复杂性。通常，一个团队需要拥有它并负责更新、修改等。</p><p id="ac15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，使用<a class="ae kv" href="https://bit.dev/" rel="noopener ugc nofollow" target="_blank">位</a>，您可以共享公共逻辑，就好像它是直接为您的项目编写的一样。不仅如此，由于Bit与GitHub的集成，您可以让所有存储库与自动PRs保持同步，自动PRs会通知您存储库使用的组件中的新变化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/c8e7bdf584ecb80bf9c3a735efe878b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R2IqUonSEKCw6gpuyVbyjQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">跟踪任何回购的组件，并通过您自己的Bit服务器与其他回购共享它们。照片来自<a class="ae kv" href="https://bit.dev/" rel="noopener ugc nofollow" target="_blank">位</a>。</p></figure><div class="lt lu gp gr lv lw"><a href="https://github.com/teambit/bit" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">团队位/位</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">文档*教程*快速入门指南*工作流* bit.dev组件云*视频演示bit是一个开源…</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">github.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk kp lw"/></div></div></a></div><p id="c01d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一件重要的事情需要注意:每个使用共享组件的存储库也将能够更新它，并将这些更新“推”回一个新的组件发布版本(给定适当的位权限)。这为更有效的协作铺平了道路，这种协作关注于单独的独立组件，而不是大型的整体存储库。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://bit.dev"><div class="gh gi ml"><img src="../Images/15b20628fd97bb00a8becfda7140f9d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OvS1CD2ACZmTQETcMk3PNw.png"/></div></a><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们的共享输入验证器</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://bit.dev"><div class="gh gi mm"><img src="../Images/ecd47be9c0e52ff90ea4390b6bca3f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bcMvXNJ9ZImDa-xndYxCfA.png"/></div></a><p class="kr ks gj gh gi kt ku bd b be z dk translated">共享组件改变后由Bit自动生成的PR</p></figure></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="68cb" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">先说一下比特</h1><p id="652f" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">Bit是一个工具，它使开发者能够在<a class="ae kv" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank">其网站</a>或其他定制的Bit服务器上分享他们的JavaScript组件(我们正在谈论React、Vue、Angular，甚至Node.js模块)。</p><p id="89e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Bit常用于共享UI组件。然而，如果我们扩展我们的组件概念，我们可以看到Bit可以与任何后端组件或通用逻辑一起使用。这就是我今天想向你们展示的。</p><p id="c597" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一步是安装Bit的CLI工具，这就是我们将要使用的工具:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="69d4" class="nw mv iq ns b gy nx ny l nz oa">$ npm install bit-bin --global</span></pre></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="a45a" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">一个简单的用例</h1><p id="e7b7" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">假设我们需要将当前项目中的输入验证代码归纳为一个公司范围的组件，可以用于前端和后端。</p><p id="ad14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码已经在你的项目中了。你所要做的就是导出它，以某种方式使它可用，并将其集成到另一个代码库中。</p><p id="cc58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我已经提到的，我们并不想从我们的解决方案中去掉代码。它已经存在，我们希望保持这种状态。太好了，比特可以处理。</p><p id="df84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们所要做的就是转到项目的根文件夹并键入:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="26a0" class="nw mv iq ns b gy nx ny l nz oa">$ bit init<br/>$ bit import bit.envs/compilers/typescript --compile<!-- --> </span></pre><p id="975f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将在我们的项目中启动一个Bit工作区，并添加TypeScript编译器，这是我将用于我的代码的东西(TS编译器是另一个Bit组件，它确保我的组件不依赖于我的项目的构建设置)。</p><p id="76b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成后，简单地写下:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="9728" class="nw mv iq ns b gy nx ny l nz oa">$ bit add lib/validators.ts<br/>$ bit tag --all 0.0.1 --message "first version"</span></pre><p id="dd1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，第一行将在我们有验证器的地方添加文件。现在，他们只有两个基本的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="6e50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码正在导出两个验证函数:<code class="fe od oe of ns b">validateEmail</code>和<code class="fe od oe of ns b">usPhoneNumberValidator</code>。就是这样。</p><p id="6f7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二行将标记版本。本质上，它会对其进行快照并添加一个版本号，以便您以后可以引用它。这个新的锁定版本将会“输出”到<a class="ae kv" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank"> Bit的网站</a>上。</p><p id="bbd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要做的最后一件事是将我们标记的组件导出到您在Bit网站上创建的任何集合中。请记住，您首先必须访问网站，登录并设置收藏。</p><p id="dc64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个例子，我创建了一个名为“<a class="ae kv" href="https://bit.dev/deletemangroup/common-validators" rel="noopener ugc nofollow" target="_blank"> common-validators </a>”的集合，我打算在其中发布我公司范围内的所有通用验证代码。</p><p id="d7b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到这一点，我需要用一行非常简单的代码将我的公共代码导出到集合中:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="6f3b" class="nw mv iq ns b gy nx ny l nz oa">$ bit export deletemangroup.common-validators</span></pre><p id="2fa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，<code class="fe od oe of ns b">deletemangroup</code>是我在Bit上建立的组织。那部分可以是你想要的任何东西。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/15b20628fd97bb00a8becfda7140f9d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OvS1CD2ACZmTQETcMk3PNw.png"/></div></div></figure><p id="1d24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在上面的图片中看到我导出的组件的最终结果。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="5a70" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">在另一个项目中使用我的通用组件</h1><p id="5fc0" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">在另一个项目中重用我的组件就像使用Bit CLI工具或直接使用NPM(或yarn)添加组件一样简单，如果您已经在捆绑过程中使用了它:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="1a86" class="nw mv iq ns b gy nx ny l nz oa">$ npm i @bit/deletemangroup.common-validators.validators<br/>$ yarn add @bit/deletemangroup.common-validators.validators<br/>$ bit import deletemangroup.common-validators/validators</span></pre><p id="0b97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论您如何操作，都可以使用以下模式引用它:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="411d" class="nw mv iq ns b gy nx ny l nz oa">"<a class="ae kv" href="http://twitter.com/bit/deleteman" rel="noopener ugc nofollow" target="_blank">@bit</a>/ORGNAME.COLLECTION-NAME.NAME"</span></pre><p id="e916" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果我们想导入<code class="fe od oe of ns b">emailValidator</code>函数，我们可以这样做:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="ed55" class="nw mv iq ns b gy nx ny l nz oa">import { emailValidator } from "<a class="ae kv" href="http://twitter.com/bit/deleteman" rel="noopener ugc nofollow" target="_blank">@bit</a>/deletemangroup.common-validators.validators"</span></pre><p id="5967" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您在代码库中使用了一个通用组件。</p><p id="e908" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最好的一点是，我从来没有提到后端或前端的特定术语。这意味着你的泛型逻辑是真正的泛型。这是少数几个在后端和前端都有JavaScript的例子之一，可以实现代码的完全重用。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="8d05" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">额外的奖励</h1><p id="1dc7" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">因为Bit和GitHub可以集成，所以每次更新组件代码时，可以指示Bit集合通知GitHub的bot。</p><p id="382e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没错，通过该通知，机器人将自动创建一个PR，更新使用您的组件的每个存储库的依赖关系。</p><p id="6ef0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，有一个警告:这只适用于库<a class="ae kv" href="https://docs.bit.dev/docs/sourcing-components" rel="noopener ugc nofollow" target="_blank"> <em class="og">导入</em> </a>您的组件(当他们添加整个组件时，因此能够修改它并将其导出回Bit)。如果他们将组件作为NPM软件包直接安装，自动化将不起作用。</p><p id="20de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经在本文中介绍了如何做到这一点<a class="ae kv" href="https://blog.bitsrc.io/keeping-your-documentation-up-to-date-with-bit-and-github-9cc6e62906f8" rel="noopener ugc nofollow" target="_blank">，在本文中，我解释了当组件的代码发生变化时，如何自动更新文档的片段。</a></p><p id="64e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然我不想在这里重复整个示例，但是您必须遵循以下步骤来获得带有更新依赖项的PR:</p><ol class=""><li id="2740" class="oh oi iq ky b kz la lc ld lf oj lj ok ln ol lr om on oo op bi translated">在您的Bit enterprise帐户上设置与GitHub的集成。别担心，是企业账号，但是免费的。</li><li id="663e" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated">确保在您的收藏中为所有<em class="og">回购配置它。</em></li></ol><p id="f6f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应该就是这样了。每次更新代码时，所有使用你的组件的GitHub库都应该收到一个PR。GitHub还会让你直接知道PR合并是否安全，让你的验证工作更加容易。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mm"><img src="../Images/ecd47be9c0e52ff90ea4390b6bca3f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bcMvXNJ9ZImDa-xndYxCfA.png"/></div></div></figure><p id="9b08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意我的<a class="ae kv" href="https://github.com/deleteman/logic-components-example" rel="noopener ugc nofollow" target="_blank">测试存储库</a>上的PR。它是我在<a class="ae kv" href="https://bit.dev/deletemangroup/common-validators" rel="noopener ugc nofollow" target="_blank">我的收藏</a>上更新版本时自动创建的。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="2b52" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">结论</h1><p id="4dbd" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">使用Bit时，在环境甚至项目之间共享逻辑可能非常简单。此外，GitHub集成带来的额外好处是，您的所有项目都可以自动更新，只需与开发人员进行最少的交互。</p><p id="9ec7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你以前尝试过在不同环境之间共享代码吗？有这么容易吗？你用的是什么工具？</p></div></div>    
</body>
</html>