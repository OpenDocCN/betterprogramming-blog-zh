<html>
<head>
<title>The Differences Between Protocol Oriented Programming (POP) and Object-Oriented Programming(OOP) in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中面向协议编程(POP)和面向对象编程(OOP)的区别</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/difference-between-protocol-oriented-programming-pop-and-object-oriented-programming-oop-in-swift-2dc3048b4fd?source=collection_archive---------2-----------------------#2020-02-28">https://betterprogramming.pub/difference-between-protocol-oriented-programming-pop-and-object-oriented-programming-oop-in-swift-2dc3048b4fd?source=collection_archive---------2-----------------------#2020-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b7f1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么我们需要协议，什么时候我们应该使用它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/24e123f63dd7b5a5e3ed4a32a711924c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HA5txJWZViUfPlD2lphLMw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">面向对象与面向协议的编程</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="7dfa" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">介绍</h1><p id="998f" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">我参加过很多面试，有初创公司的，也有大公司的，他们都问我这样的问题:</p><ul class=""><li id="6f48" class="mt mu it lz b ma mv md mw mg mx mk my mo mz ms na nb nc nd bi translated">协议和类有什么区别？</li><li id="7f29" class="mt mu it lz b ma ne md nf mg ng mk nh mo ni ms na nb nc nd bi translated">为什么不用超类代替协议呢？</li></ul><p id="63b3" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">本文将为您提供这类问题的答案，并可能向您介绍Swift编程的一个新方面。</p><p id="5bc2" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">读完这篇文章后，你会明白为什么要制定协议，什么时候我们可以使用它们，为什么我们应该选择它们而不是超类，以及它们的优缺点。</p><p id="23e9" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">让我们停止谈话，开始做吧！</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="976b" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">继承问题</h1><p id="e9ff" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">当来自面向对象的编程语言时，继承通常用于在多个类之间共享代码。但是这种解决方案并不总是最好的，并且存在一些问题。</p><p id="eb4a" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">假设你有一个应用程序，里面有很多具有相同行为的<code class="fe nm nn no np b">UIViewController</code>类——例如，它们都有一张个人资料图片。当然，你不希望在应用程序的每个视图控制器中重新实现配置文件图片逻辑——设置<code class="fe nm nn no np b">leftBarButtonItem</code>，点击按钮时打开和关闭编辑配置文件<code class="fe nm nn no np b">ViewController</code>，等等。</p><p id="6bbf" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">解决方法很简单。只需创建一个<code class="fe nm nn no np b">MainViewController</code>，实现所有这些行为<code class="fe nm nn no np b">UIViewController</code>的子类，然后让所有的<code class="fe nm nn no np b">ViewController</code>从<code class="fe nm nn no np b">MainViewController</code>继承，而不是直接从<code class="fe nm nn no np b">UIViewController</code>继承。这样，它们都继承了那些方法，并以同样的方式运行——没有必要每次都重新实现所有的东西。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2526" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">但是后来在开发过程中，你意识到你需要一个<code class="fe nm nn no np b">UITableViewController</code>或者<code class="fe nm nn no np b">UICollectionViewControlle</code>。不幸的是，您不能使用<code class="fe nm nn no np b">MainViewController</code>，因为它继承了<code class="fe nm nn no np b">UIViewController</code>，而不是<code class="fe nm nn no np b">UICollectionViewController</code>或<code class="fe nm nn no np b">UITableViewController</code>。</p><p id="a60e" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">怎样才能做出一个<code class="fe nm nn no np b">MainTableViewController</code>实现和<code class="fe nm nn no np b">MainViewController</code>一样的东西，但是继承自<code class="fe nm nn no np b">UITableViewController</code>而不是<code class="fe nm nn no np b">UIViewController</code>？那会有很多代码重复，对吗？</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="462a" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">作文来了</h1><p id="3995" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">当然，典型且容易回答的是作文。</p><p id="e8cf" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">这意味着<code class="fe nm nn no np b">UIViewController</code>不是利用继承，而是包含提供行为的内部类，或者由提供行为的内部类组成。</p><p id="458a" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">在我们的例子中，我们可以想象一个<code class="fe nm nn no np b">ProfileManager</code>类，它提供所有需要的方法来设置个人资料图片图像并与之交互。各种<code class="fe nm nn no np b">UIViewControllers</code>将会有一个<em class="ns">属性</em>持有一个<code class="fe nm nn no np b">ProfileManager</code>，并可以用它来与剖面栏按钮交互:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0968" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">你可以看到事情会变得多么复杂。每次都需要显式引用中间对象<code class="fe nm nn no np b">ProfileManager</code>。在某种程度上，这也是一种重复，你可能需要更长的时间来实现。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="5732" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">多重继承</h1><p id="4cc2" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">继承的另一个问题是许多面向对象语言不允许多重继承——这是有充分理由的，尤其是钻石问题。</p><p id="8f05" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">这意味着一个类不能继承多个超类。</p><p id="6ccf" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">假设你是上帝，你想实现代表生物的模型类。你有<code class="fe nm nn no np b">Bird</code>、<code class="fe nm nn no np b">Fly</code>、<code class="fe nm nn no np b">Human</code>、<code class="fe nm nn no np b">Monkey </code>——它们之间是如何联系的？有的能走，有的能飞，有的两者兼而有之；有些会说话有些不会，有些是动物有些不是。</p><p id="823a" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">类<code class="fe nm nn no np b">Mockingbird</code>和类<code class="fe nm nn no np b">Mosquito</code>都可以飞行，所以我们可以想象一个<code class="fe nm nn no np b">Flyer</code>超类，它提供了<code class="fe nm nn no np b">func fly()</code>方法的实现。但是<code class="fe nm nn no np b">Mockingbird</code>和<code class="fe nm nn no np b">Eagle</code>都是鸟，所以我们也可以想象一个<code class="fe nm nn no np b">Birds</code>超类，而<code class="fe nm nn no np b">Mosquito</code>和<code class="fe nm nn no np b">Bees</code>将是<code class="fe nm nn no np b">Flies</code>类的子类。那么<code class="fe nm nn no np b">Mockinbird</code>既继承了<code class="fe nm nn no np b">Flyer</code>又继承了<code class="fe nm nn no np b">birds</code>？这在Swift(以及很多OOP语言)中是不可能的。</p><p id="9f73" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">我们应该选择其中之一吗？但是如果我们创建一个<code class="fe nm nn no np b">Icarus</code>或者说<code class="fe nm nn no np b">Human </code>的子类<code class="fe nm nn no np b">Superman</code>——那么<code class="fe nm nn no np b">func fly()</code>方法的实现呢？我们不能在<code class="fe nm nn no np b">Human</code>实现它，因为不是每个人都能飞，但是<code class="fe nm nn no np b">Superman</code>和<code class="fe nm nn no np b">Icarus</code>也需要那个方法，我们不想复制它。</p><p id="2b99" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">因此，我们可以在那里使用组合，比如让<code class="fe nm nn no np b">class Icarus</code>成为由<code class="fe nm nn no np b">var flyingOption: Flyer</code>属性的组成的<em class="ns">。但是不得不写<code class="fe nm nn no np b">Icarus.flyingOption.fly()</code>而不是仅仅写<code class="fe nm nn no np b">Icarus.fly()</code>并不好看。</em></p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="2528" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">拯救混合和特性</h1><p id="435a" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">这就是混合和特性的概念发挥作用的地方。</p><ul class=""><li id="6651" class="mt mu it lz b ma mv md mw mg mx mk my mo mz ms na nb nc nd bi translated">通过继承，你可以定义你的类是什么。例如，每个<code class="fe nm nn no np b">Dog</code>都是一个<code class="fe nm nn no np b">Animal</code>。</li><li id="5c2c" class="mt mu it lz b ma ne md nf mg ng mk nh mo ni ms na nb nc nd bi translated">有了traits，你就定义了什么类<em class="ns">可以做什么</em>。例如，每个<code class="fe nm nn no np b">Animal</code>都可以<code class="fe nm nn no np b">eat()</code>人类、鸟类和所有其他生物也可以。</li></ul><p id="8367" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">继承让你描述一个对象是什么，特征让你描述一个对象能做什么。</p><p id="11e6" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">继承是你的对象身份，但是特征将定义你的对象能够做什么。</p><p id="fa73" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">最好的是，一个类可以采用多个<code class="fe nm nn no np b">Traits</code>，因为它可以做多件事，而它只能做一件事(只继承一个超类)。这意味着我们有一个身份，人类，但我们有多种能力:走路，说话，吃饭，有时甚至飞行。但是其他一些生物也能做到这些，所以它们不是人类独有的。</p><p id="29ac" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">那么，我们如何在Swift中做到这一点呢？</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="01d4" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">协议是答案</h1><p id="5e6b" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">在Swift 2.0中，协议可以有一个默认实现。当您定义一个<code class="fe nm nn no np b">protocol</code>时，您可以使用该协议的一个<code class="fe nm nn no np b">extension</code>为该协议的一些或所有方法提供默认实现。它看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6811" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">当您创建一个符合那个<code class="fe nm nn no np b">Flyer</code>协议的类或结构时，它会免费获得一个<code class="fe nm nn no np b">fly()</code>方法的实现！</p><p id="6d3b" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">这仍然是一个默认的实现——如果需要的话，你可以自由地重新定义那个方法，但是如果你不这样做，你仍然会有一个默认的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2328" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">默认实施协议的这一特性对很多事情都有好处——包括将“traits”概念引入Swift。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="1085" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">一个身份，多种能力</h1><p id="58cd" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">特性的伟大之处在于，它们不依赖于你应用它们的对象的身份。他们不关心这个类是什么，它继承了什么，他们只是在这个类上定义了一些函数。</p><p id="96ac" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">这就解决了我们的问题，伊卡洛斯既是人又能飞，而嘲鸟是鸟也能飞。</p><p id="fcbb" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">你是什么样的人并不能决定你能做什么。</p><p id="6dc3" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">现在让我们利用特征来实现我们的模型类。首先，让我们定义各种特征:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c797" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">那么让我们给他们一些默认的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5954" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">此时，我们仍将使用继承来定义我们的生物的身份(它们是什么)，所以让我们有一些父类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1c42" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">现在，我们可以通过身份(通过继承)和能力(特征/协议一致性)来定义我们的角色:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="744f" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">现在，<code class="fe nm nn no np b">Icarus</code>、<code class="fe nm nn no np b">IronMan</code>和<code class="fe nm nn no np b">Bee </code>都使用相同的<code class="fe nm nn no np b">fly()</code>实现，即使它们从不同的超类继承而来(一个是<code class="fe nm nn no np b">Insect</code>，另一个是<code class="fe nm nn no np b">Human</code>),即使一个是人类，另一个是昆虫，蜘蛛和伊卡洛斯都知道如何进食:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="0c37" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">时空冒险</h1><p id="17ba" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">现在让我们介绍一个新的太空旅行能力/特性:</p><pre class="kj kk kl km gt nu np nv nw aw nx bi"><span id="2934" class="ny lg it np b gy nz oa l ob oc"><strong class="np iu">protocol</strong> SpaceTraveler {<br/>     <strong class="np iu">func</strong> travelTo(location: String)<br/>}</span></pre><p id="f951" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">并给它一个默认实现:</p><pre class="kj kk kl km gt nu np nv nw aw nx bi"><span id="5a9b" class="ny lg it np b gy nz oa l ob oc"><strong class="np iu">extension</strong> SpaceTraveler {<br/>    <strong class="np iu">func</strong> travelTo(location: String) {<br/>         print("Let's go to \(location)!")<br/>    }<br/>}</span></pre><p id="8bff" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">然后，我们可以使用Swift的<code class="fe nm nn no np b">extensions</code>将协议一致性添加到现有的类中，所以让我们将这些能力添加到我们已经定义的生物中:</p><pre class="kj kk kl km gt nu np nv nw aw nx bi"><span id="0bf8" class="ny lg it np b gy nz oa l ob oc"><strong class="np iu">extension</strong> Superman: SpaceTraveler {}</span></pre><p id="da4f" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">是的，这就是将这个能力/特质添加到现有职业的全部内容！就这样，他们现在可以<code class="fe nm nn no np b">travelTo()</code>任何地方！</p><pre class="kj kk kl km gt nu np nv nw aw nx bi"><span id="22ce" class="ny lg it np b gy nz oa l ob oc">clark.travelTo(location: "Trenzalore") // prints "Let's go to Trenzalore!"</span></pre></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="03d3" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">让我们邀请更多的人来参加聚会吧！</h1><p id="3997" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">现在让我们引入更多的人来混合，这一次我想使用更多的科幻生物来使它更加不现实和不合理，并以更不可能的方式来创建模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="cdff" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">我们这里有个问题。莱卡不是人类，朱伊也不是，斯波克是半人半瓦肯人，所以那些定义都是相当错误的。</p><p id="9b45" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">你看到这里的问题了吗？我们已经理所当然地认为<code class="fe nm nn no np b">Human</code>和<code class="fe nm nn no np b">Alien</code>是相同的——我们又被遗传咬了一口。一些类被迫成为某种类型，或者从一些父类继承，然而事实上，这并不总是现实——尤其是在科幻小说中。</p><p id="401e" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">这也是为什么在Swift和protocols default实现中使用协议有助于消除那些通过继承强加在您的类上的约束。</p><p id="150e" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">如果<code class="fe nm nn no np b">Human</code>和<code class="fe nm nn no np b">Alien</code>是<code class="fe nm nn no np b">protocols</code>而不是<code class="fe nm nn no np b">classes</code>，我们会有很多好处:</p><ul class=""><li id="76c6" class="mt mu it lz b ma mv md mw mg mx mk my mo mz ms na nb nc nd bi translated">我们可以定义一个<code class="fe nm nn no np b">MilleniumFalconPilot</code>类型，而不强迫它成为一个<code class="fe nm nn no np b">Human</code>，从而允许朱伊驾驶它。</li><li id="b9d4" class="mt mu it lz b ma ne md nf mg ng mk nh mo ni ms na nb nc nd bi translated">我们可以把拉卡定义为一个<code class="fe nm nn no np b">Astronaut</code>，即使她不是<code class="fe nm nn no np b">Human</code>。</li><li id="ae37" class="mt mu it lz b ma ne md nf mg ng mk nh mo ni ms na nb nc nd bi translated">我们可以将<code class="fe nm nn no np b">Spock</code>定义为<code class="fe nm nn no np b">Human</code>和<code class="fe nm nn no np b">Alien</code>。</li><li id="5dad" class="mt mu it lz b ma ne md nf mg ng mk nh mo ni ms na nb nc nd bi translated">我们甚至可以完全摆脱继承，将类型定义为<code class="fe nm nn no np b">structs</code>而不是<code class="fe nm nn no np b">classes</code>。A <code class="fe nm nn no np b">struct</code>不支持继承，但是仍然可以符合你想要的任意多的协议。</li></ul></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="ab7e" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">到处都有协议！</h1><p id="11f3" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">因此，解决这个问题的一个办法是让一切都成为协议，摆脱继承。毕竟，我们不在乎<em class="ns">我们的生物是什么</em>，定义英雄和生物的是它们拥有的<em class="ns">能力</em>！</p><p id="3287" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">我已经包含了一个Swift Playground，你可以在这里下载<a class="ae nt" href="https://github.com/EmadBeyrami/OOP-Vs-POP" rel="noopener ugc nofollow" target="_blank"/>，它包含了本文中显示的代码。它还展示了作为解决方案的另一个平台，其中所有东西都由协议和结构组成，完全没有继承。看一看！</p><p id="7e0a" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">当然，这并不意味着你必须不惜一切代价摆脱继承。继承仍然有用，仍然有意义。a <code class="fe nm nn no np b">UILabel</code>是<code class="fe nm nn no np b">UIView</code>的<em class="ns">子类</em>感觉还是符合逻辑的。但是这让您体会到默认实现的mixins和协议可以提供什么。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="2265" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">结论</h1><p id="652f" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">练习Swift时，您会意识到它实际上是一种面向协议的语言，并且在Swift中使用协议比在Objective-C中更常见、更强大。毕竟，Swift标准库中的<code class="fe nm nn no np b">Equatable</code>、<code class="fe nm nn no np b">CustomStringConvertible</code>和<code class="fe nm nn no np b">-able</code>中的任何协议实际上都可以被视为Mixins！</p><p id="309d" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">甚至许多内置Swift APIs都在使用诸如<code class="fe nm nn no np b">UITableViewDelegate</code>、<code class="fe nm nn no np b">UITableViewDataSource</code>等协议。</p><p id="83ee" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">使用Swift协议和协议默认实现，您可以实现mixins和traits，并使您的代码更加灵活。</p><p id="6de4" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">mixins和traits方法允许您通过类型能做什么来描述类型，而不是它们是什么，更重要的是，允许您选择类型的功能。这就像你购物并为你的类型选择你想要的功能，不管它们继承了什么类，如果有的话。</p><p id="27ae" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">回到第一个例子——你可以用默认实现创建一个<code class="fe nm nn no np b">protocol ProfilePictureManager</code>,然后简单地让你的视图控制器(不管它们是<code class="fe nm nn no np b">UIViewController</code>、<code class="fe nm nn no np b">UITableViewController</code>还是什么)符合那个协议。然后它会自动从<code class="fe nm nn no np b">ProfilePictureManager</code>免费获得那些能力和特性，而不用担心<code class="fe nm nn no np b">UIViewController</code>的父类！</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><p id="5aa4" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">感谢您阅读我的文章。我希望你喜欢它。使用协议和协议扩展，我们可以做更多令人惊奇的事情，但是这篇文章已经够长了。</p><h1 id="7a35" class="lf lg it bd lh li od lk ll lm oe lo lp jz of ka lr kc og kd lt kf oh kg lv lw bi translated">给我买杯咖啡☕️:</h1><div class="oi oj gp gr ok ol"><a href="https://www.paypal.com/donate/?hosted_button_id=FRY432D75E4Q2" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">捐给艾玛德·拜拉米</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">通过捐赠或与朋友分享来帮助支持艾玛德·拜拉米。</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">www.paypal.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://nowpayments.io/donation/emad" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">DonateCrypto</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">通过捐赠加密货币或与您的朋友分享来帮助支持艾玛德·贝拉米…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">nowpayments.io</p></div></div></div></a></div><p id="49e9" class="pw-post-body-paragraph lx ly it lz b ma mv ju mc md mw jx mf mg nj mi mj mk nk mm mn mo nl mq mr ms im bi translated">提前感谢大家的支持！</p><h1 id="d805" class="lf lg it bd lh li od lk ll lm oe lo lp jz of ka lr kc og kd lt kf oh kg lv lw bi translated">参考资料和资源</h1><ul class=""><li id="2470" class="mt mu it lz b ma mb md me mg pa mk pb mo pc ms na nb nc nd bi translated"><a class="ae nt" href="https://github.com/EmadBeyrami/OOP-Vs-POP" rel="noopener ugc nofollow" target="_blank">https://github.com/EmadBeyrami/OOP-Vs-POP</a></li><li id="0a07" class="mt mu it lz b ma ne md nf mg ng mk nh mo ni ms na nb nc nd bi translated"><a class="ae nt" href="https://www.appcoda.com/pop-vs-oop/" rel="noopener ugc nofollow" target="_blank">https://www.appcoda.com/pop-vs-oop/</a></li><li id="e669" class="mt mu it lz b ma ne md nf mg ng mk nh mo ni ms na nb nc nd bi translated"><a class="ae nt" href="https://tsh.io/blog/protocol-oriented-programming-swift/" rel="noopener ugc nofollow" target="_blank">https://tsh.io/blog/protocol-oriented-programming-swift/</a></li><li id="ec5e" class="mt mu it lz b ma ne md nf mg ng mk nh mo ni ms na nb nc nd bi translated"><a class="ae nt" href="https://alisoftware.github.io/swift/protocol/2015/11/08/mixins-over-inheritance/#fn:diff" rel="noopener ugc nofollow" target="_blank">https://alisoftware . github . io/swift/protocol/2015/11/08/mixins-over-inheritance/# fn:diff</a></li></ul></div></div>    
</body>
</html>