<html>
<head>
<title>A Note on Upgradable Smart Contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于可升级智能合约的一个注记</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-note-on-upgreadable-smart-contracts-d8fb6fd515da?source=collection_archive---------9-----------------------#2020-10-27">https://betterprogramming.pub/a-note-on-upgreadable-smart-contracts-d8fb6fd515da?source=collection_archive---------9-----------------------#2020-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="14f7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">代理合同的重要性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7115df4fa0b93d2c7691af093fd3feb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tarsy9nPWwxqldvf"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@reinis_birznieks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Reinis Birznieks </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="5b77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管以太坊在为软件开发带来不变逻辑方面做得很好，但在合同中还是会不断发现错误。此外，如果事先没有一个适当的计划，迁移成本会很高。因此，必须在产品设计时考虑这一价值，然后谨慎实施。安全性和发展性至关重要——尤其是当它涉及到人们的资金时。</p><p id="4495" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任何业务模型中的不变性都超出了这个范围。相反，本文强调了它的技术方面。</p><p id="961b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于没有高标准的开发工具来防止犯错误或提前一步识别事件，这个问题限制了智能合约程序员迭代其应用程序的能力。</p><p id="2204" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，有一些启发式的技术和模式用于更安全的开发，比如一个优雅的契约销毁，或者通过一个托管地址在紧急情况发生时提取资金。</p><p id="1bf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，就可升级的不变性而言，存在一个共同的范式:代理契约。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f462" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">代理模式</strong></h1><p id="d022" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">虽然不可能升级已经部署的智能协定的代码，但是可以建立一个代理协定体系结构，它将允许您使用新部署的协定，就像您的主要逻辑已经升级一样。</p><p id="50d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们重点介绍一下与可升级合同相关的最受认可的提案。</p><p id="b6f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mw">注:以下所有实现都依赖于底层</em> <code class="fe mx my mz na b"><em class="mw">delegatecalls</em></code> <em class="mw">。</em></p><blockquote class="nb nc nd"><p id="7efc" class="kw kx mw ky b kz la jr lb lc ld ju le ne lg lh li nf lk ll lm ng lo lp lq lr ij bi translated">solidity <code class="fe mx my mz na b">delegatecall</code>操作码使一个契约能够执行来自另一个契约的函数，但是它被执行，就好像该函数来自调用契约一样。本质上，delegatecall使一个契约能够“借用”另一个契约的功能。用delegatecall执行的函数会影响调用协定的存储变量，而不会影响定义函数的协定。—<a class="ae kv" href="https://github.com/ethereum/EIPs/issues/1538" rel="noopener ugc nofollow" target="_blank">GitHub上的ERC 1538</a></p></blockquote></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="87dc" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">以太坊改进建议</h1><h2 id="f572" class="nh ma iq bd mb ni nj dn mf nk nl dp mj lf nm nn ml lj no np mn ln nq nr mp ns bi translated">EIP 1538</h2><p id="d206" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">它由一个契约版本控制系统组成，该系统通过标准事件公开记录对契约的更改，以实现可追溯性。它还支持无限制的存储大小、原子多重升级和用于外部调用的标准接口。</p><p id="f5e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它代表了不可变的无信任透明契约和可升级的模糊委托契约之间的权衡。</p><p id="9680" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">术语:</p><ul class=""><li id="c214" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated">透明的<em class="mw"> </em>契约包含一个回退，它使用<code class="fe mx my mz na b">delegatecall</code>操作码将函数调用转发给委托<em class="mw"> </em>契约。如果需要，它还支持其他不可变函数。</li><li id="d762" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">可以通过向一个<code class="fe mx my mz na b">updateContract</code>函数提供新地址来改变委托契约。但是，用户只能与固定地址(透明的地址)进行交互。</li><li id="1b68" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">标准应该有一个认证机制来保护透明契约中的委托更新。</li><li id="ab5e" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">每个函数更新都会发出<code class="fe mx my mz na b">CommitMessage</code>和<code class="fe mx my mz na b">FunctionUpdate</code>事件来记录更改。</li><li id="8bcf" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">给定函数签名列表，可以一次执行多次更新。</li><li id="dfff" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">当新部署的委托中省略了<code class="fe mx my mz na b">updateContract</code>函数时，可变性可以在任何给定的时间被关闭。</li></ul><h2 id="3049" class="nh ma iq bd mb ni nj dn mf nk nl dp mj lf nm nn ml lj no np mn ln nq nr mp ns bi translated"><strong class="ak"> EIP 2535 </strong></h2><p id="41c3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">作为EIP-1538(也称为钻石标准)的继任者，它为智能合约的迭代开发提供了模块化设计，支持部分和完全升级，依赖于钻石合约和多个方面。</p><p id="7a88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">钻石是一种契约，将外部功能与刻面绑定在一起。</p><p id="daa7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">方面是公开外部函数的独立契约。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/901f9bb6876c734bfb099c957fe4b000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*7GG8ZO_I1bJM6G8_vEWb_Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://eips.ethereum.org/EIPS/eip-2535" rel="noopener ugc nofollow" target="_blank">以太坊改进建议</a>。</p></figure><p id="dccd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">术语:</p><ul class=""><li id="5929" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated">每当调用外部函数时，菱形都会执行回退。它从<code class="fe mx my mz na b">selectorToFacet</code>映射中获取相关的方面地址，然后执行<code class="fe mx my mz na b">delegatecall</code>。</li><li id="9984" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">给定一个刻面地址及其选择器，加上一个动作(添加、替换、删除)以防止函数冲突，刻面升级通过<code class="fe mx my mz na b">DiamondCut</code>函数调用完成。此外，还会发出一个事件来记录新的更改。</li><li id="d475" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">刻面状态变量应该驻留在静态存储槽中(菱形存储模式)。</li><li id="ee8d" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><a class="ae kv" href="https://dev.to/mudgen/what-is-diamond-storage-3n7c" rel="noopener ugc nofollow" target="_blank">钻石存储</a>是一种通过指向一组固定内存槽的指针来控制多个刻面上的状态变量范围的技术。</li><li id="8224" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">当方面从同一契约或库继承时，它们也可以共享内部函数。</li><li id="26db" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">刻面可重复使用，并可由多个钻石共享。</li><li id="94fd" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">每个钻石都有一个放大镜刻面，其中包含四个标准外部函数来显示所有其他刻面及其功能。</li></ul><h2 id="a774" class="nh ma iq bd mb ni nj dn mf nk nl dp mj lf nm nn ml lj no np mn ln nq nr mp ns bi translated">EIP 1822年</h2><p id="1d1b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这个标准非常简单。它依靠一个可代理的契约来处理升级和执行兼容性检查，以及一个具有唯一存储槽的代理契约，该存储槽引用新的逻辑契约地址。它还支持代理契约字节码的验证。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/5eede2a5643af8ec7bc97b43656b6896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_1-9mmRHr4ahUJDPwD-AHQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://eips.ethereum.org/EIPS/eip-1822" rel="noopener ugc nofollow" target="_blank">以太坊改进建议</a>。</p></figure><p id="020e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">术语:</p><ul class=""><li id="ae00" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated">逻辑契约地址驻留在代理契约内的固定内存槽中:<em class="mw"> keccak256("PROXIABLE ")槽</em>地址。</li><li id="0a95" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">所有后续的逻辑契约都应该继承标准的可代理契约。</li><li id="5791" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">可代理契约包含一个用于执行升级的<code class="fe mx my mz na b">updateCodeAddress</code>函数(更新<em class="mw"> keccak256("可代理")</em>槽地址值)。</li><li id="ad90" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">在升级之前执行兼容性检查，以确保逻辑契约符合通用可升级代理标准。</li><li id="e1f1" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">后续逻辑契约中变量的实例化顺序对于防止覆盖代理中的现有值至关重要。为此，建议使用所有新协定都继承的基础协定。</li><li id="e5cc" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">通常，<code class="fe mx my mz na b">Owner</code>和<code class="fe mx my mz na b">LibraryLock</code>契约与逻辑契约一起部署，以控制访问并限制任何最终的破坏性功能。</li><li id="e7c6" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">代理契约支持逻辑契约中包含的多个构造函数，因为它在自己的构造函数中接受任何任意数据。</li></ul><h2 id="b9c2" class="nh ma iq bd mb ni nj dn mf nk nl dp mj lf nm nn ml lj no np mn ln nq nr mp ns bi translated">EIP 1155</h2><p id="39c7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">多种令牌类型的外观，包括可替换、不可替换和半可替换令牌的任意组合，该标准可配置为在任何给定时间支持新类型。它还支持跨多种类型的原子操作。</p><p id="ef54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">术语:</p><ul class=""><li id="8d48" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated">每个令牌都有一个唯一的ID。</li><li id="d1f4" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">合同应实现ERC-165 <strong class="ky ir"> </strong> <code class="fe mx my mz na b">supportsInterface</code>对目的地址的预先检查。</li><li id="fed1" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">契约中的每个函数都接受一个ID参数，以便将请求转发给相关的令牌。</li><li id="71da" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">允许一次处理多个操作。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="55b3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">最后的想法</h1><p id="a28c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">尽管这些模式已经解决了不变性问题，但它们都依赖于基于操作码的方法，这影响了代码的可读性，从而使开发人员体验痛苦。</p><p id="065e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些涉及高风险的事件，比如DAO hack，需要对规范本身进行低级修改(硬分叉),从而提高协议的可信度。</p><p id="f741" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了代理，还有其他模式关注数据结构的可升级性，而不是逻辑和存储分离方法，即<a class="ae kv" href="https://fravoll.github.io/solidity-patterns/eternal_storage.html" rel="noopener ugc nofollow" target="_blank">永恒存储</a>模式。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="90d0" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">参考</h1><ul class=""><li id="53dc" class="nt nu iq ky b kz mr lc ms lf oj lj ok ln ol lr ny nz oa ob bi translated"><a class="ae kv" href="https://eips.ethereum.org/EIPS/eip-1538" rel="noopener ugc nofollow" target="_blank">https://eips.ethereum.org/EIPS/eip-1538</a></li><li id="2b6f" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">【https://eips.ethereum.org/EIPS/eip-2535 T2】号</li><li id="b40c" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">【https://eips.ethereum.org/EIPS/eip-1822 T4】</li><li id="bbd9" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><a class="ae kv" href="https://eips.ethereum.org/EIPS/eip-1155" rel="noopener ugc nofollow" target="_blank">https://eips.ethereum.org/EIPS/eip-1155</a></li></ul></div></div>    
</body>
</html>