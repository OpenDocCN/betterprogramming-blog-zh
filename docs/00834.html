<html>
<head>
<title>Build Your Pokédex: Part 2 — @ngrx/entity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建您的Pokédex:第2部分— @ngrx/entity</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-your-pok%C3%A9dex-part-2-ngrx-entity-6e9d7256e6a8?source=collection_archive---------10-----------------------#2019-07-18">https://betterprogramming.pub/build-your-pok%C3%A9dex-part-2-ngrx-entity-6e9d7256e6a8?source=collection_archive---------10-----------------------#2019-07-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2646" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">角度教程— NgRx分步指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c1e6d1f27afb705aad46cb2b8a7b0766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8z04ARQ6AeW6vz0OmRZFUw.png"/></div></div></figure><p id="6e5e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章是我描述如何从初学者到忍者使用<a class="ae lq" href="https://ngrx.io/" rel="noopener ugc nofollow" target="_blank"> NgRx </a>构建你的<a class="ae lq" href="https://www.pokemon.com/us/pokedex/" rel="noopener ugc nofollow" target="_blank"> Pokédex </a>的系列文章的一部分。如果您想阅读更多内容，可以在本文底部找到该系列其余部分的链接。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="a886" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">介绍</h1><p id="1df0" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">有必要阅读这篇文章的第一部分，这样你就能理解我们在构建什么。在这篇文章中，我们将使用<code class="fe mv mw mx my b">@ngrx/entity</code>包改进第一篇文章中开发的代码，这将简化创建缩减器和选择器的任务。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="12d2" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">@ngrx/entity</h1><p id="b03f" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated"><code class="fe mv mw mx my b">@ngrx/entity</code>包是一个用于管理记录集合的适配器。这个包提供了一个API来操作和查询实体集合。</p><p id="17ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，它减少了创建管理模型集合的reducer的样板文件。它为管理实体集合提供了高性能的CRUD操作。它是一个可扩展的类型安全适配器，用于选择实体信息。</p><p id="b504" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一步是安装将提供所有这些优势的软件包。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="5597" class="nd lz it my b gy ne nf l ng nh">npm i @ngrx/entity</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c06b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">实体状态</h1><p id="d2ac" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated"><code class="fe mv mw mx my b">EntityState</code>是给定实体集合的预定义通用接口，具有以下接口:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b0dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在上一篇文章中用这两个属性开发<code class="fe mv mw mx my b">PokemonState</code>的原因如下所示。通用属性如下:</p><ul class=""><li id="b49b" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated"><code class="fe mv mw mx my b">ids</code>。集合中所有主要id的数组。</li><li id="2ac3" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><code class="fe mv mw mx my b">entities</code>。集合中由主ID索引的实体的字典。</li></ul><p id="a75e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如下图所示,<code class="fe mv mw mx my b">pokemon.state.ts</code>文件被替换为<code class="fe mv mw mx my b">pokemon.adapter.ts</code>。</p><p id="333d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之前:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1b54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b299" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的新模型中，我们已经使用继承基于<code class="fe mv mw mx my b">EntityState</code>创建了别名<code class="fe mv mw mx my b">PokemonState</code>，尽管我们还没有为状态添加任何新的属性。</p><p id="1c1f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一方面，<code class="fe mv mw mx my b">createEntityAdapter</code>方法负责为我们的<code class="fe mv mw mx my b">Pokemon</code>数据模型创建适配器。这个适配器为我们提供了修改状态和创建选择器的方法集合。</p><p id="c80c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">方法接受具有两个属性的对象进行配置:</p><ul class=""><li id="df91" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated"><code class="fe mv mw mx my b">selectId</code>。为集合选择主ID的方法。当实体的主键为ID时，该选项是可选的。</li><li id="aa1a" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><code class="fe mv mw mx my b">sortComparer</code>。用于对集合排序的比较函数。只有当集合需要在显示之前进行排序时，才需要比较功能。将它设置为false可以使集合不排序，这样在CRUD操作期间性能会更好。</li></ul><p id="0567" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的例子中，我们没有使用任何配置属性，因为这是不必要的。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="9eb6" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">还原剂</h1><p id="0eed" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">返回的适配器对象提供了一组方法，您可以在reducer函数中使用这些方法来根据您提供的操作管理实体集合。</p><ul class=""><li id="0e25" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated"><code class="fe mv mw mx my b">getInitialState</code>。基于提供的类型返回实体状态的<code class="fe mv mw mx my b">initialState</code>。<code class="fe mv mw mx my b">initialState</code>是提供给你的减速器功能。在我们的例子中，这个函数被包装在<code class="fe mv mw mx my b">pokemonInitialState</code>中。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="eb88" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">适配器收集方法</h1><p id="e5fc" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">实体适配器还提供针对实体的操作方法。这些方法可以一次更改一个或多个记录。</p><p id="03f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果进行了更改，每个方法都返回新修改的状态，如果没有进行更改，则返回相同的状态。</p><ul class=""><li id="0d1a" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated"><code class="fe mv mw mx my b">addOne</code>:向集合中添加一个实体。</li><li id="5462" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><code class="fe mv mw mx my b">addMany</code>:向集合中添加多个实体。</li><li id="168a" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><code class="fe mv mw mx my b">addAll</code>:用提供的集合替换当前集合。</li><li id="735c" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><code class="fe mv mw mx my b">removeOne</code>:从集合中删除一个实体。</li><li id="0e9a" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><code class="fe mv mw mx my b">removeMany</code>:通过ID或谓词从集合中删除多个实体。</li><li id="f164" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><code class="fe mv mw mx my b">removeAll</code>:清除实体集合。</li><li id="2021" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><code class="fe mv mw mx my b">updateOne</code>:更新集合中的一个实体。</li><li id="307c" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><code class="fe mv mw mx my b">updateMany</code>:更新集合中的多个实体。</li><li id="587f" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><code class="fe mv mw mx my b">upsertOne</code>:添加或更新集合中的一个实体。</li><li id="3e31" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><code class="fe mv mw mx my b">upsertMany</code>:添加或更新集合中的多个实体。</li><li id="19f0" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><code class="fe mv mw mx my b">map</code>:通过定义一个映射函数来更新集合中的多个实体，类似于<code class="fe mv mw mx my b">Array.map</code>。</li></ul><p id="c64d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这组方法允许我们简化reduce函数，在这个函数中我们有复杂的嵌套对象来修改属性。</p><p id="d093" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样，请注意这个函数的before和after，其中的代码被简化为调用一个方法。</p><p id="ab67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之前:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b629" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c4f4" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">选择器</h1><p id="d514" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">由创建的实体适配器返回的<code class="fe mv mw mx my b">getSelectors</code>方法提供了从实体中选择信息的函数。</p><p id="5661" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，最广泛使用的四种选择器是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d74a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，<code class="fe mv mw mx my b">pokemon.selector.ts</code>文件被稍微修改了一下，因为我们不需要构建<code class="fe mv mw mx my b">selectAll</code>选择器，因为我们将使用适配器提供的选择器。</p><p id="e4f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之前:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b147" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f5c5" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="bf1d" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在这篇文章中，我们使用<code class="fe mv mw mx my b">@ngrx/entity</code>包重构了一个Pokédex的小例子。</p><p id="1d24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">适配器的使用将减少应用程序状态管理中不必要的复杂性。</p><p id="58cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">适配器允许我们根据需要轻松地扩展状态，并且在处理应用程序的状态时具有最常用的操作。</p><p id="98a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，在这篇文章中，我们讨论了以下主题:</p><ul class=""><li id="360e" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated">分离可视组件的状态管理。</li><li id="9786" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">高效、轻松地创建状态管理元素。</li><li id="b1c7" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">创建关注相关性的组件:视图。</li><li id="3b9b" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">使用<code class="fe mv mw mx my b">@ngrx/entity</code>自动创建状态，因为这是非常重复的。</li></ul><p id="83ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本系列中的其他帖子将涵盖有趣的主题，例如:</p><ul class=""><li id="cff2" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated">自动创建效果和动作，并使用<code class="fe mv mw mx my b">@ngrx/entity</code>简化reduce函数。</li><li id="9041" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">通过<code class="fe mv mw mx my b">@ngrx/data</code>包使用外观模式。</li><li id="7760" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">测试应用程序的状态。</li></ul><p id="1aab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">重要的是概念，而不是使用的技术或库。因此，对于那些开始大型<a class="ae lq" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>应用并需要应用架构原则的人来说，这篇文章应该作为一个指南。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="64a0" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">该系列的其他部分</h1><ol class=""><li id="58a0" class="nk nl it kw b kx mq la mr ld ny lh nz ll oa lp ob nq nr ns bi translated">第一部分。构建你的pokédex:NgR简介</li><li id="4ad7" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp ob nq nr ns bi translated"><a class="ae lq" href="https://medium.com/better-programming/build-your-pok%C3%A9dex-part-2-ngrx-entity-da176edffdfb" rel="noopener">第二部分。构建您的Pokédex: @ngrx/entity </a></li><li id="b7cc" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp ob nq nr ns bi translated">第三部分。构建您的Pokédex:使用create*函数改进NgRx(即将推出)</li><li id="b4f1" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp ob nq nr ns bi translated">第四部分。构建您的Pokédex: @ngrx/data(即将推出)</li><li id="2f0e" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp ob nq nr ns bi translated">第五部分。构建您的Pokédex:测试NgRx(即将推出)</li></ol></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c927" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">资源</h1><ul class=""><li id="4ef9" class="nk nl it kw b kx mq la mr ld ny lh nz ll oa lp np nq nr ns bi translated"><a class="ae lq" href="https://github.com/Caballerog/ngrx-pokedex/tree/ngrx-part2" rel="noopener ugc nofollow" target="_blank"> GitHub分支</a>为本岗位。</li><li id="74ca" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><a class="ae lq" href="https://angular-academy.com/angular-architecture-best-practices/" rel="noopener ugc nofollow" target="_blank">角度架构最佳实践</a></li><li id="4801" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><a class="ae lq" href="https://angular.io/guide/architecture" rel="noopener ugc nofollow" target="_blank">棱角分明的建筑(官方文件)</a></li><li id="9111" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><a class="ae lq" href="https://ngrx.io/" rel="noopener ugc nofollow" target="_blank"> NgRx </a></li></ul></div></div>    
</body>
</html>