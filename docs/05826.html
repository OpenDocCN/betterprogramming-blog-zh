<html>
<head>
<title>Test Custom Hooks Using React Hooks Testing Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React钩子测试库测试定制钩子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/test-custom-hooks-using-react-hooks-testing-library-a3a37031a9be?source=collection_archive---------4-----------------------#2020-08-10">https://betterprogramming.pub/test-custom-hooks-using-react-hooks-testing-library-a3a37031a9be?source=collection_archive---------4-----------------------#2020-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fccd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为你的钩子建立一个基本的测试基础设施</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8faaa6e00c34a7baaa22630b68a5b841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F1mqM3rcdfEaIvYY1w2EoQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安娜·洪科在<a class="ae ky" href="https://unsplash.com/s/photos/library?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1928" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">钩子很受欢迎，因为它们带来了可读性和可维护性。定制钩子成为可组合性和可重用性的推动者。在<a class="ae ky" href="https://medium.com/better-programming/headless-ui-components-a-journey-with-high-order-components-render-props-and-custom-hooks-811c9677b4cf" rel="noopener">无头UI组件</a>中，我们探索了定制钩子，以及高阶组件(hoc)。</p><p id="886a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何测试它们？在<a class="ae ky" href="https://medium.com/better-programming/test-cases-and-test-coverage-for-high-order-components-2fb6fbddc33c" rel="noopener">高阶组件的测试用例与测试覆盖</a>中，我们使用<a class="ae ky" href="https://github.com/facebook/jest" rel="noopener ugc nofollow" target="_blank"> Jest </a>和<a class="ae ky" href="https://github.com/testing-library/react-testing-library" rel="noopener ugc nofollow" target="_blank"> React测试库</a>举例说明了如何编写高阶组件的测试用例以及如何测量测试覆盖。在本文中，我们将演示如何使用<a class="ae ky" href="https://github.com/testing-library/react-hooks-testing-library" rel="noopener ugc nofollow" target="_blank"> React钩子测试库</a>来测试定制钩子。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2cd9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">安装React钩子测试库</h1><p id="08c1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">测试定制钩子需要两个包:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ca5a" class="ne md it na b gy nf ng l nh ni">npm install --save-dev @testing-library/react-hooks<br/>npm install --save-dev react-test-renderer</span></pre><p id="c534" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装完成后，这些包就变成了<code class="fe nj nk nl na b">package.json</code>中的<code class="fe nj nk nl na b"><a class="ae ky" href="https://medium.com/better-programming/package-jsons-dependencies-in-depth-a1f0637a3129" rel="noopener">devDependencies</a></code>。</p><p id="2a39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/better-programming/testing-your-components-in-react-967abda02396" rel="noopener">测试渲染器</a> ( <code class="fe nj nk nl na b">react-test-renderer</code>)用于将React组件渲染为纯JavaScript对象，不依赖于DOM或原生移动环境。安装的版本应该与React版本相匹配。</p><p id="c39c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">@testing-library/react-hooks</code>构建于测试渲染器之上。</p><p id="5a18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能还需要其他的<code class="fe nj nk nl na b">@testing-library</code>包。如果您使用<a class="ae ky" href="https://medium.com/better-programming/10-fun-facts-about-create-react-app-eb7124aa3785" rel="noopener">创建React App </a>，它们是<code class="fe nj nk nl na b">package.json</code>中<code class="fe nj nk nl na b">dependencies</code>的一部分:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d555" class="ne md it na b gy nf ng l nh ni">"dependencies": {<br/>  "@testing-library/jest-dom": "^4.2.4",<br/>  "@testing-library/react": "^9.5.0",<br/>  "@testing-library/user-event": "^7.2.1"<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cd45" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">renderHook API</h1><p id="71d5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nj nk nl na b">renderHook</code> API是<code class="fe nj nk nl na b">@testing-library/react-hooks</code>的核心。每次渲染时，它都会渲染一个调用所提供的<code class="fe nj nk nl na b">callback</code>的测试组件，包括它调用的任何钩子。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2c9b" class="ne md it na b gy nf ng l nh ni">function renderHook(<br/>  callback: function(props?: any): any,<br/>  options?: RenderHookOptions<br/>): RenderHookResult</span></pre><p id="5b1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">options</code>的类型为<code class="fe nj nk nl na b">RenderHookOptions</code>，它是一个对象，可以选择包括:</p><ul class=""><li id="29d3" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><code class="fe nj nk nl na b">initialProps</code>:是<code class="fe nj nk nl na b">renderHook</code>的<code class="fe nj nk nl na b">callback</code>功能的初始值。</li><li id="86dd" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe nj nk nl na b">wrapper</code>:它是一个React组件，在使用全局上下文的同时包装测试组件。</li></ul><p id="56d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">RenderHookResult</code>是定义如下的数据结构:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d2a9" class="ne md it na b gy nf ng l nh ni">{<br/>  current: any,<br/>  error: Error<br/>}</span></pre><p id="eae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用例子来说明<code class="fe nj nk nl na b">renderHook</code>在各种情况下是如何使用的。使用Create React App作为工作环境。所有定制钩子都托管在<code class="fe nj nk nl na b">src/hooks</code>中，所有钩子测试都托管在<code class="fe nj nk nl na b">src/hooks.test.js</code>中。</p><p id="0a25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://medium.com/better-programming/everyone-can-build-a-custom-hook-e0f1c6802ffe" rel="noopener">中每个人都可以构建一个定制的钩子</a>，我们构建了一系列钩子。我们将使用它们来构建测试用例。</p><p id="5496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是最简单的挂钩:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="dd17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是测试案例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="503d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第6行，<code class="fe nj nk nl na b">renderHook</code>用于呈现自定义钩子，<code class="fe nj nk nl na b">useMyName</code>。</p><p id="c5cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第7行，<code class="fe nj nk nl na b">result.current</code>是<code class="fe nj nk nl na b">useMyName</code>的返回值。</p><p id="e1ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与第5 - 8行的情况相比，第10-13行显示了初始值设置为<code class="fe nj nk nl na b">“Larry”</code>的不同情况。</p><p id="d8a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在<a class="ae ky" href="https://medium.com/better-programming/test-cases-and-test-coverage-for-high-order-components-2fb6fbddc33c" rel="noopener">另一篇文章</a>中所解释的，下面的命令用于执行测试用例:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a206" class="ne md it na b gy nf ng l nh ni">npm test -- --testMatch="&lt;rootDir&gt;/src/hooks.test.js" --collectCoverage --collectCoverageFrom="src/hooks.js"</span></pre><p id="62bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是测试结果和测试覆盖范围:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/4885e1a3324a34069e31dc43832c7a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b8Kag1aRWcDL6rij2ZiaAw.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f1c9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><code class="fe nj nk nl na b">rerender</code>原料药</h1><p id="9dc0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在之前的测试中，我们用不同的初始值重复了两个测试。这可以通过将初始值传递给<code class="fe nj nk nl na b">renderHook</code>的<code class="fe nj nk nl na b">callback</code>来组合:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="143d" class="ne md it na b gy nf ng l nh ni">renderHook((initialName) =&gt; useMyName(initialName)</span></pre><p id="ab5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当初始值改变时，我们调用<code class="fe nj nk nl na b">rerender</code>来触发钩子重新计算。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8141" class="ne md it na b gy nf ng l nh ni">function rerender(newProps?: any): void</span></pre><p id="8e37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是备选测试套件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="9d6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会产生相同的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/ea4583cfaa2f971f073082117c4f12c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fixp7l5BHnaBSZb9pB0Dvw.png"/></div></div></figure><p id="2922" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们来看一个更复杂的定制钩子，它返回一个方法和一个值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="9857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是测试案例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="f751" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第6行，<code class="fe nj nk nl na b">renderHook</code>用于呈现自定义钩子，<code class="fe nj nk nl na b">useMyName</code>。这一次，<code class="fe nj nk nl na b">current</code>被析构为一个方法和一个值(第12行)。在第13行测试该方法，在第14行和第16行测试该消息。</p><p id="b608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行测试套件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/32edca86b2c11c8c7a23ecff79e64946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_getJiuqyHClS-Rnk9YoA.png"/></div></div></figure><p id="1c54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发生了什么事？测试在第16行失败。</p><p id="d66f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">message</code>的值在第12行被析构。<code class="fe nj nk nl na b">message</code>变得停滞不前，不再获取新值<code class="fe nj nk nl na b">“Larry”</code>。</p><p id="8ab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是需要记住的事情。尽管析构<code class="fe nj nk nl na b">result.current</code>的值使代码变得干净，但是任何后续的更新只能在直接使用<code class="fe nj nk nl na b">result.current</code>时使用，除非它们被再次析构。</p><p id="ba9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在下面的测试代码中修复了这个问题(第16行):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="83f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们仍然得到失败的测试结果。还有什么不对？</p><p id="4e59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nj nk nl na b">useMyName</code>中，<code class="fe nj nk nl na b">initialName</code>被传递到<code class="fe nj nk nl na b">useState</code>作为初始状态。由于<code class="fe nj nk nl na b">useState</code>的性质，rerender不会更新初始状态。为了让状态拾取道具变化，我们需要调用<code class="fe nj nk nl na b">useEffect</code> hook(第6 - 8行)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="74bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在测试用例通过了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/2e146c41ae4fe759ae92abb89a4c809c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dMyVRQHOHJd-wem4iYE7lA.png"/></div></div></figure><p id="33f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们发现功能覆盖率是<code class="fe nj nk nl na b">66.67%</code>。测试用例没有覆盖第11行的函数<code class="fe nj nk nl na b">setName</code>。</p><p id="0ae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在第16行添加了函数的测试用例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="dc72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次运行测试:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/a1fd3547d74444a4bc6c4c08559479a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zpPtH17taEYxR8O6fV3twA.png"/></div></div></figure><p id="0954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试用例通过，语句覆盖率为100%。分支、函数和线条。</p><p id="e257" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是那个红色警告是什么？这意味着我们需要<code class="fe nj nk nl na b">act</code> API。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f5c6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">act API</h1><p id="3154" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">测试时，导致React状态更新的代码应该被包装到<code class="fe nj nk nl na b">act(…)</code>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="5feb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">act</code>由<code class="fe nj nk nl na b">react-test-renderer</code>导出。因此，它可以通过第2行的语句导入。</p><p id="de68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用方便，<code class="fe nj nk nl na b">act</code>被<code class="fe nj nk nl na b">@testing-library/react-hooks</code>重新导出。它通常与<code class="fe nj nk nl na b">renderHook</code>一起导入，类似于第1行的语句。</p><p id="e0d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第18行，调用<code class="fe nj nk nl na b">setName</code>被包装在<code class="fe nj nk nl na b">act</code>中。</p><p id="9acd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行这个命令，我们通过了所有的测试，并且没有任何警告。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/2345e9995cfc494c6f9f7c8b58a45a35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x5FVXkA9MZTrRTNbJri5Fw.png"/></div></div></figure><p id="2563" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个<code class="fe nj nk nl na b">act</code>，从<code class="fe nj nk nl na b">@testing-library/react</code>或者<code class="fe nj nk nl na b">react-dom/test-utils</code>出口。它的功能类似，但它是不同的<code class="fe nj nk nl na b">act</code>。如果你用错了，会有警告提醒你:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3829" class="ne md it na b gy nf ng l nh ni">Warning: It looks like you're using the wrong act() around your test interactions.<br/>    Be sure to use the matching version of act() corresponding to your renderer:<br/>    <br/>    // for react-dom:<br/>    import {act} from 'react-dom/test-utils';<br/>    // ...<br/>    act(() =&gt; ...);<br/>    <br/>    // for react-test-renderer:<br/>    import TestRenderer from 'react-test-renderer';<br/>    const {act} = TestRenderer;<br/>    // ...<br/>    act(() =&gt; ...);<br/>        in TestHook<br/>        in Suspense</span></pre><p id="06c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的测试用例中，我们添加了第二个测试套件(第23 - 56行)，它构建了一个采取行动的用户界面:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="d32a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个点击动作(第45行和第52行)由<code class="fe nj nk nl na b">act</code> API包装。</p><p id="7a6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和往常一样，我们想做一个快照测试(第47行),看看它是如何呈现的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="4784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行测试用例，我们很高兴看到一切看起来都很好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/12a65eecc431951d89e4a8f5bc073293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*33EcM4cvgVd6UW3IRNGeQw.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fdaf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">useContext的包装</h1><p id="f8a1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们如何测试调用全局上下文的定制钩子？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="c6de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，<code class="fe nj nk nl na b">NameContext</code>(第3行)是一个全局上下文，由第12行使用。</p><p id="bd43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">NameContext</code>要求提供者使用全局上下文包装组件。这个提供者在第5行被定义为<code class="fe nj nk nl na b">NameContextProvider</code>。</p><p id="723c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过调用<code class="fe nj nk nl na b">renderHook(() =&gt; useMyName())</code>来测试<code class="fe nj nk nl na b">useMyName</code>。但是，这仅验证第3行的<code class="fe nj nk nl na b">CreateContext</code>的初始值，在本例中为<code class="fe nj nk nl na b">undefined</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="25c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">wrapper</code>是renderHook的选项之一。这有助于我们解决问题。在第8-11行，它创建了一个由<code class="fe nj nk nl na b">NameContextProvider</code>包装的React组件。该组件可自由设置任何<code class="fe nj nk nl na b">initialName</code>(第9行)。</p><p id="1ae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第14行的测试能够读取全局上下文值并通过这个测试套件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/8d60708a4c4a7b318c40e73a9eead274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5TJZAW8_ETGJ6KiCKt4eMg.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0e04" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">waitForNextUpdate API</h1><p id="2a6c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">React Hooks测试库中有一些异步实用程序。<code class="fe nj nk nl na b">waitForNextUpdate</code>返回一个<code class="fe nj nk nl na b">Promise</code>,在钩子下一次渲染时解析，通常是在异步更新导致状态更新时。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f8df" class="ne md it na b gy nf ng l nh ni">function waitForNextUpdate(options?: {<br/>  timeout?: number<br/>}): Promise&lt;void&gt;</span></pre><p id="f9f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码来自<a class="ae ky" href="https://medium.com/better-programming/lodash-create-react-apps-built-in-library-for-debounce-and-throttle-with-hooks-3418087f44d8" rel="noopener"> Lodash:创建React App的内置库，用于去抖和用钩子节流</a>。在<code class="fe nj nk nl na b">wait</code>时间之前，它会去抖一个值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="59d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是测试案例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="e296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第11行和第15行，<code class="fe nj nk nl na b">waitForNextUpdate</code>可以方便地快进到下一个状态更新。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f5e7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">测试减速器</h1><p id="5b35" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">减速器是一个具有<code class="fe nj nk nl na b">(state, action) =&gt; newState</code>类型的功能。它有两个参数——当前状态和用户执行的操作。然后，它根据所调度的动作有条件地返回一个新状态。</p><p id="14dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码来自<a class="ae ky" href="https://medium.com/better-programming/how-to-convert-javascript-classes-to-reacts-usereducer-hook-575769b0c7e9" rel="noopener">如何将JavaScript类转换为React的useReducer钩子</a>。它是一个更新猫的状态对象的reducer。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="a24d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">useReducer</code>是一个内置的钩子，适用于管理包含多个子值的状态对象。我们通过用<code class="fe nj nk nl na b">useReducer</code>钩子包裹一个减速器来生成一个钩子。从技术上讲，<code class="fe nj nk nl na b">useReducer</code>钩子不是自定义钩子，但也可以通过renderHook测试，类似于其他内置钩子。</p><p id="7155" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是<code class="fe nj nk nl na b">catReducer</code>的测试用例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="efc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行tests命令，我们得到了reducer代码的<code class="fe nj nk nl na b">100%</code>覆盖率:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/b5ac88e187a56d8de80584800d36f742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3qI-Cz86bNUfiaTnfyedjA.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6956" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="b504" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">由于自定义钩子在React中流行，我们需要一种方便的方法来测试它们。React Hooks测试库提供了完成它的基础设施。</p><p id="70b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae ky" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p></div></div>    
</body>
</html>