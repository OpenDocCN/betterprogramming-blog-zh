<html>
<head>
<title>Data Structures: Improving Time Complexity on Stacks and Queues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构:改善堆栈和队列的时间复杂度</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/improving-time-complexity-on-stacks-and-queues-7396ab7b5a2b?source=collection_archive---------8-----------------------#2020-02-24">https://betterprogramming.pub/improving-time-complexity-on-stacks-and-queues-7396ab7b5a2b?source=collection_archive---------8-----------------------#2020-02-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b217" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在应用扩展时使用堆栈和队列</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/624fc72f8c494b9765ccf63a455d2ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gkr_OjfkuzVvwduPRdzsDg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@nooryounis?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> noor Younis </a>在<a class="ae kv" href="https://unsplash.com/s/photos/time?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="6267" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">背景</h1><p id="9419" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">在我之前的博客中，我介绍了一种叫做栈和队列的利基数据结构。如果你对它不熟悉，请快速看一下我的博客<a class="ae kv" href="https://medium.com/better-programming/stacks-and-queues-7c322b5f4e35" rel="noopener"> <em class="mr">栈和队列</em> </a>。</p><p id="1033" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">简单来说，栈和队列遵循先入后出(栈)和先入先出(队列)的原则。然而，对于现成的JavaScript数组方法，栈的时间复杂度是O(1)，队列的时间复杂度是O(n)。</p><p id="114c" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">这让我想到，我们能做得更好吗？具体来说，我们是否可以将队列的时间复杂度提高到比O(n)更快？</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="3b6a" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">灵感</h1><p id="0b1c" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">在我们进一步深入之前，我想感谢Rud，他向我介绍了循环数组的概念，以改善堆栈和队列的时间复杂度。我对循环数组的研究启发了我创建自己的堆栈和队列数组类。</p><p id="a8d5" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">虽然在这篇博客中我没有深入研究循环数组，但是我使用了从研究循环数组中学到的相同原理，并将它们用于我的堆栈和队列数组类。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="f2e8" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">堆栈和队列类概述</h1><p id="0767" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">在我们深入研究杂草和代码之前，让我们提供一个如何创建<code class="fe mx my mz na b">StackQueueArray</code>类的概述。</p><p id="8332" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">对于堆栈部分，由于即时可用的Javascript数组方法的时间复杂度为O(1)，所以我决定继续使用相同的方法(即<code class="fe mx my mz na b">.push()</code>和<code class="fe mx my mz na b">.pop()</code>)。当它运行得非常好的时候，重新发明轮子是没有意义的，尤其是当它已经被优化的时候。</p><p id="d73b" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">对于队列部分，这是我必须跳出框框思考的地方。我们仍将利用<code class="fe mx my mz na b">.push()</code>方法，但<code class="fe mx my mz na b">.shift()</code>方法需要改变。毕竟<code class="fe mx my mz na b">.shift()</code>方法是时间复杂度为O(n)的原因。</p><p id="7608" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">这就是利用循环数组原理的地方。根据我的研究，一个关于循环数组的隐含假设是它们有固定的长度。</p><p id="6952" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">通常，循环数组有一个指针指向数组的头部和尾部。通过始终跟踪头部和尾部所在位置的指针，您可以计算出数组中是否有空间来添加额外的元素。</p><p id="12af" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">换句话说，如果头部和尾部是<em class="mr">而不是</em>相邻，那么你可以添加元素。</p><p id="ea99" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">然而，在JavaScript中，由于它是一种动态语言，我们不必担心内存分配。这阻止了我使用循环数组，但是启发了我使用指针来跟踪数组的头部。</p><p id="f12d" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">我们不需要尾部的指针，因为尾部总是数组的最后一个元素。</p><p id="1b0e" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">那么，我们如何结合自定义的<code class="fe mx my mz na b">.shift()</code>方法使用head指针呢？</p><p id="427e" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">让我们用<code class="fe mx my mz na b">StackQueueArray</code>类建立一个新数组，并将一些元素放入其中。</p><p id="008d" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">现在不要担心类方法，因为我们将在后面深入讨论这些方法的细节。回想一下，<code class="fe mx my mz na b">.push()</code>功能将与开箱即用的<code class="fe mx my mz na b">.push()</code>功能相同。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="0011" class="nf le iq na b gy ng nh l ni nj">let array = new StackQueueArray()<br/>array.push(10)<br/>array.push(20)<br/>array.push(30)<br/>console.log(array) // [10, 20, 30]</span></pre><p id="dced" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">在<code class="fe mx my mz na b">StackQueueArray</code>类中，它将有一个名为<code class="fe mx my mz na b">headIndex</code>的属性，这将是我们的头指针。目前，在<code class="fe mx my mz na b">array</code>中，<code class="fe mx my mz na b">headIndex</code>应该是<code class="fe mx my mz na b">0</code>，因为按照先入原则<code class="fe mx my mz na b">10</code>是第一个推入数组的元素。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="0d24" class="nf le iq na b gy ng nh l ni nj">console.log(array.headIndex) // 0</span></pre><p id="d4e4" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">现在，通过我们的自定义<code class="fe mx my mz na b">.shift()</code>方法，我们将利用我从循环数组中学到的另一个原理。</p><p id="8774" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">在一个圆形数组中，只要头指针和尾指针之间有空格，就会用<code class="fe mx my mz na b">null</code>作为占位符来填充。每当我们调用自定义的<code class="fe mx my mz na b">.shift()</code>方法时，我们都要做同样的事情。</p><p id="2722" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">当<code class="fe mx my mz na b">.shift()</code>被调用时，它会将<code class="fe mx my mz na b">headIndex</code>处的值与<code class="fe mx my mz na b">null</code>交换，将<code class="fe mx my mz na b">headIndex</code>增加<code class="fe mx my mz na b">1</code>以将磁头指针分配给新的磁头，并返回该值。</p><p id="9504" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">因此，在伪代码中，它看起来像这样:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="04da" class="nf le iq na b gy ng nh l ni nj">console.log(array) // [10, 20, 30]<br/>console.log(array.headIndex) // 0<br/>array.shift()<br/>console.log(array) // [null, 20, 30]<br/>console.log(array.headIndex) // 1</span></pre><p id="c878" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">让我们真正理解它，并再次调用我们的自定义<code class="fe mx my mz na b">.shift()</code>方法到我们当前的<code class="fe mx my mz na b">array</code>来固化该方法应该做的事情。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="e83b" class="nf le iq na b gy ng nh l ni nj">array.shift() <br/>console.log(array) // [null, null, 30]<br/>console.log(array.headIndex) // 2</span></pre><p id="af81" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">既然我们对方法应该做什么和类的一般概念有了更全面的理解，让我们把它分解成代码。</p><p id="7384" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">注意:出于简洁和解释的目的，下面的<code class="fe mx my mz na b">StackQueueArray</code>类的代码将只考虑正常情况。有许多边缘情况需要考虑，我将在另一个部分进行讨论，我将在本博客的结尾提供该类的完整代码。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="2c6d" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">推送和弹出功能</h1><p id="2027" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">让我们从<code class="fe mx my mz na b">StackQueueArray</code>类需要什么开始。我们将初始化一个空数组和<code class="fe mx my mz na b">headIndex</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2b33" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">到目前为止，一切顺利。我们将<code class="fe mx my mz na b">headIndex</code>初始化为<code class="fe mx my mz na b">null</code>，因为数组是空的，所以还不需要头指针。</p><p id="c5e4" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">接下来，让我们进入<code class="fe mx my mz na b">.push()</code>和<code class="fe mx my mz na b">.pop()</code>功能。回想一下，我们将利用JavaScript已经提供的现成方法。</p><p id="2ebe" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">首先，我们来做一下<code class="fe mx my mz na b">.push()</code>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="92d2" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">在<code class="fe mx my mz na b">if</code>语句中，这仅在数组为空时发生。我们将从<code class="fe mx my mz na b">0</code>开始<code class="fe mx my mz na b">headIndex</code>，因为当你将一个元素推入一个空数组时，它将位于索引<code class="fe mx my mz na b">0</code>。</p><p id="5e5d" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">接下来，我们来做<code class="fe mx my mz na b">.pop()</code>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9f7f" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">我正在使用JavaScript的开箱即用的<code class="fe mx my mz na b">.pop()</code>函数，并将它作为我自己的函数使用。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="58cc" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">移位、头部和尾部功能</h1><p id="1fa2" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">好了，现在是最难的部分，定制<code class="fe mx my mz na b">.shift()</code>函数。对于正常情况，让我们假设我们已经有了<code class="fe mx my mz na b">[10, 20, 30]</code>作为我们的数组。本例中<code class="fe mx my mz na b">headIndex</code>在<code class="fe mx my mz na b">0</code>处。</p><p id="632c" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">根据我在“堆栈和队列类概述”一节中所说的，下面是我们需要完成的三个步骤。</p><ol class=""><li id="c77d" class="nm nn iq lx b ly ms mb mt me no mi np mm nq mq nr ns nt nu bi translated">用<code class="fe mx my mz na b">null</code>交换<code class="fe mx my mz na b">headIndex</code>处的值。</li><li id="eba6" class="nm nn iq lx b ly nv mb nw me nx mi ny mm nz mq nr ns nt nu bi translated">将<code class="fe mx my mz na b">headIndex</code>增加<code class="fe mx my mz na b">1</code>。</li><li id="4a47" class="nm nn iq lx b ly nv mb nw me nx mi ny mm nz mq nr ns nt nu bi translated">返回前一个<code class="fe mx my mz na b">headIndex</code>的值(递增<code class="fe mx my mz na b">headIndex</code>前的值)。</li></ol><p id="6416" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">因为我们需要返回值，所以我们应该将它保存在一个单独的变量中。</p><p id="7e53" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">为了节省空间，我将在。<code class="fe mx my mz na b">shift()</code>单独运行，完成后输入到类中。<code class="fe mx my mz na b">array</code>和<code class="fe mx my mz na b">headIndex</code>仍参考以前的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c7ea" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">目前看来还不错！</p><p id="697e" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">我们还可以包含一些帮助函数来查找头部和尾部，以减轻解析整个数组的痛苦。</p><p id="9fb4" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">因为我们知道尾部总是在数组的末尾，所以我们可以使用数组的长度作为我们的参考点。对于头部，我们已经有了一个头部指针，就是我们的<code class="fe mx my mz na b">headIndex</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0ed7" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">太好了，现在让我们将这些方法添加到<code class="fe mx my mz na b">StackQueueArray</code>类中！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="69c6" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">还有维奥拉。我们已经创建了<code class="fe mx my mz na b">StackQueueArray</code>类的框架。</p><p id="ce05" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">如果你能跟得这么远，你已经成功了一半以上！接下来的步骤将会考虑到边缘情况…而且有很多这样的情况。</p><p id="99bb" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">如果你想挑战自己，试着想想这门课可能发生的所有极端情况。这对于代码挑战和代码面试来说是特别好的实践，因为考虑所有可能的边缘情况是开发人员的责任。</p><p id="37f4" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">我个人甚至不知道所有的边缘案例是不是我自己想到的。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="9009" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">大量边缘案例</h1><p id="a794" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">有六种独特的边缘情况需要考虑。这些边缘情况中的一些以不同的方式重复。</p><p id="82ec" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">下面的要点显示了我制作的<code class="fe mx my mz na b">StackQueueArray</code>类的完整代码。我还做了一个额外的方法，叫做<code class="fe mx my mz na b">cleanUp()</code>，稍后我会解释。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="261e" class="nf le iq bd lf oa ob dn lj oc od dp ln me oe of lp mi og oh lr mm oi oj lt ok bi translated">边缘情况1</h2><p id="0493" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">所有的元素都是<code class="fe mx my mz na b">null</code>。这通常发生在<code class="fe mx my mz na b">.shift()</code>一直被调用到数组末尾的时候。</p><h2 id="dc38" class="nf le iq bd lf oa ob dn lj oc od dp ln me oe of lp mi og oh lr mm oi oj lt ok bi translated">边缘情况2</h2><p id="60f9" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">数组中只有一个非空元素。这只发生在<code class="fe mx my mz na b">.pop()</code>方法上，因为在调用它之后，数组将是空的，这意味着<code class="fe mx my mz na b">headIndex</code>应该是<code class="fe mx my mz na b">null</code>。</p><h2 id="0a56" class="nf le iq bd lf oa ob dn lj oc od dp ln me oe of lp mi og oh lr mm oi oj lt ok bi translated">边缘案例3</h2><p id="7d6c" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">数组的尾部是最后一个非空元素。这只发生在<code class="fe mx my mz na b">.pop()</code>方法中，因为在调用它之后，我们需要通过减少<code class="fe mx my mz na b">1</code>来重新分配<code class="fe mx my mz na b">headIndex</code>。</p><p id="4434" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">如果我们不递减它，<code class="fe mx my mz na b">headIndex</code>将在数组本身的范围之外。</p><h2 id="c947" class="nf le iq bd lf oa ob dn lj oc od dp ln me oe of lp mi og oh lr mm oi oj lt ok bi translated">边缘案例4</h2><p id="a83c" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">数组或者为空，或者数组中的所有元素都是<code class="fe mx my mz na b">null</code>。</p><h2 id="b2a2" class="nf le iq bd lf oa ob dn lj oc od dp ln me oe of lp mi og oh lr mm oi oj lt ok bi translated">边缘情况5</h2><p id="7347" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">没有参数用于<code class="fe mx my mz na b">.push()</code>方法。这是针对用户可能忘记输入值或决定输入值<code class="fe mx my mz na b">null</code>的错误。</p><p id="5b2a" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">如果没有参数，<code class="fe mx my mz na b">.push()</code>会将<code class="fe mx my mz na b">undefined</code>推入数组。将<code class="fe mx my mz na b">undefined</code>或<code class="fe mx my mz na b">null</code>压入数组会破坏类，也违反了堆栈和队列数据结构的基础。</p><p id="3261" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">在我们进入边缘情况6之前，让我解释一下<code class="fe mx my mz na b">.cleanUp()</code>方法的目的。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="e19c" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">cleanUp()方法</h1><p id="4621" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">我设计了<code class="fe mx my mz na b">.cleanUp()</code>,因为我想到了如果只多次调用<code class="fe mx my mz na b">.push()</code>和<code class="fe mx my mz na b">.shift()</code>方法会发生什么。例如，数组可能看起来像是有一堆<code class="fe mx my mz na b">null</code>值，末尾有两个非空值。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="b3e2" class="nf le iq na b gy ng nh l ni nj">console.log(array) <br/>// [null, null, null, null, null, null, null, null, null, 10, 20]</span></pre><p id="659b" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">如前所述，<code class="fe mx my mz na b">null</code>值只是代表先前磁头所在位置的占位符。我们不再关心这些<code class="fe mx my mz na b">null</code>值了。</p><p id="09fb" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">但是，如果您有内存需求或者内存不足以存储这个数组，该怎么办呢？</p><p id="f2ac" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">这就是<code class="fe mx my mz na b">.cleanUp()</code>方法的灵感来源。我们可以调用这个方法，通过删除所有的<code class="fe mx my mz na b">null</code>值来缩短我们的数组以占用更少的内存。</p><p id="be16" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">因此，在伪代码中，它看起来像下面这样:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="8529" class="nf le iq na b gy ng nh l ni nj">array.cleanUp()<br/>console.log(array) // [10, 20]</span></pre><p id="e6be" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">然而，这引入了两种边缘情况:边缘情况1和边缘情况6。我们已经考虑了边缘情况1，其中数组中的所有元素都是<code class="fe mx my mz na b">null</code>。对于这种方法中的边缘情况，我们将返回到类的初始条件。</p><h2 id="34de" class="nf le iq bd lf oa ob dn lj oc od dp ln me oe of lp mi og oh lr mm oi oj lt ok bi translated">边缘情况6</h2><p id="f96d" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">数组为空，或者数组只包含非空元素。</p><p id="b542" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">对于边缘情况6，我们不会以任何方式改变数组，并让用户知道数组中没有更多的<code class="fe mx my mz na b">null</code>值。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="c358" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">StackQueueArray类的时间复杂度</h1><p id="12c8" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">如果你已经走了这么远，给自己一点鼓励。这需要处理大量信息，尤其是如果您阅读了我之前关于栈和队列的博客。</p><p id="c9bb" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">记住，最初的目标是将时间复杂度从O(n)提高到O(1)。让我们看看每个类方法的时间复杂度，看看我们是否达到了。</p><p id="0452" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated"><code class="fe mx my mz na b">.push()</code>:对于这个方法，我们做了五个动作:声明、递增、布尔比较、访问数组中的元素，以及使用现成的<code class="fe mx my mz na b">.push()</code>方法。</p><p id="e115" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">每个动作的时间复杂度都是O(1)，这意味着这个方法的时间复杂度是O(1)。</p><p id="2920" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated"><code class="fe mx my mz na b">.pop()</code>:对于这个方法，我们做了五个动作:声明、递减、布尔比较、访问数组中的元素，以及使用现成的<code class="fe mx my mz na b">.pop()</code>方法。</p><p id="016a" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">每个动作的时间复杂度都是O(1)，这意味着这个方法的时间复杂度是O(1)。</p><p id="c2b7" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated"><code class="fe mx my mz na b">.shift()</code>:对于这个方法，我们做了四个动作:声明、递增、布尔比较和访问数组中的元素。</p><p id="364a" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">每个动作的时间复杂度都是O(1)，这意味着这个方法的时间复杂度是O(1)。</p><p id="a634" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">对于这个方法，我们做了三个动作:声明、布尔比较和访问数组中的元素。</p><p id="3382" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">每个动作的时间复杂度都是O(1)，这意味着这个方法的时间复杂度是O(1)。</p><p id="07f4" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated"><code class="fe mx my mz na b">.tail()</code>:对于这个方法，我们做了三个动作:声明、布尔比较和访问数组中的元素。</p><p id="febb" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">每个动作的时间复杂度都是O(1)，这意味着这个方法的时间复杂度是O(1)。</p><p id="a8cf" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated"><code class="fe mx my mz na b">.cleanUp()</code>:对于这个方法，我们做了四个动作:声明、布尔比较、访问数组中的元素，以及使用现成的<code class="fe mx my mz na b">.slice()</code>方法。</p><p id="bb65" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">除了<code class="fe mx my mz na b">.slice()</code>方法，这些动作的时间复杂度都是O(1)。</p><p id="5554" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated"><code class="fe mx my mz na b">.slice()</code>方法根据参数中提供的输入范围复制子阵列。在最坏的情况下，它可以复制整个数组，这取决于数组的长度。</p><p id="9c6f" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">基于此，<code class="fe mx my mz na b">.slice()</code>方法的时间复杂度为O(n)。这意味着，在最坏的情况下，<code class="fe mx my mz na b">.cleanUp()</code>方法的时间复杂度为O(n)。</p><p id="8679" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">看起来每个方法，除了<code class="fe mx my mz na b">.cleanUp()</code>，时间复杂度都是O(1)。我们会认为这是成功吗？是啊！原因如下。</p><p id="1c72" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">回想一下<code class="fe mx my mz na b">.cleanUp()</code>最初是为了帮助分配，而不是时间复杂度。你可以把这个方法更多地看作是一个有好处的方法，而不是一个必须的方法。</p><p id="caef" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">这种方法不会直接影响堆栈和队列数据结构的症结。如果我们在<code class="fe mx my mz na b">StackQueueArray</code>类中没有<code class="fe mx my mz na b">.cleanUp()</code>方法，这个类仍然可以用于任何实现堆栈和队列的数据结构，假设内存不是问题。</p><p id="885d" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">如果我们现在忽略<code class="fe mx my mz na b">.cleanUp()</code>方法，那么<code class="fe mx my mz na b">StackQueueArray</code>类的总时间复杂度是O(1)！</p><p id="274e" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">我们成功地将栈和队列的时间复杂度从O(n)提高到O(1)！</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="2a1a" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">结论</h1><p id="bc09" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">注意在<code class="fe mx my mz na b">StackQueueArray</code>类中，我们没有使用任何特殊的函数或者不常见的东西。我们在类中编码的一切都是现成的方法、数组的属性和布尔比较。</p><p id="46d8" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">构建一个新的类只需要一些创造力，现在我们有了一个比使用栈和队列的现成方法更快的类。</p></div></div>    
</body>
</html>