<html>
<head>
<title>5 Ways To Implement the Factory Design Pattern in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C#中实现工厂设计模式的5种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-ways-to-implement-factory-design-pattern-in-c-382c0992a3ff?source=collection_archive---------1-----------------------#2021-07-12">https://betterprogramming.pub/5-ways-to-implement-factory-design-pattern-in-c-382c0992a3ff?source=collection_archive---------1-----------------------#2021-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f1fe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">静态、异步、参数化、内部和抽象工厂</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cf0a92e00c38aadebc41d0a92ba1bead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0XlZwxDjNix5Lazf"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上用高清的<a class="ae ky" href="https://unsplash.com/@scienceinhd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">科普拍照。</a></p></figure><p id="4779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对象可以通过调用<code class="fe lv lw lx ly b">new</code>关键字直接实例化其他对象，但是这种方法通常不是最佳选择。</p><p id="df98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实例化对象是一项独立的责任，应该从客户端代码转移到称为工厂的独立类/方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/e9f78c358e560cc70349e6768fd50372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRja5R2pvqaoEhSm-CPv3Q.png"/></div></figure><p id="e33b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用工厂设计模式有以下好处:</p><ul class=""><li id="c24a" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">客户端代码少了一项职责，因为它不需要创建对象。这是工厂的责任。</li><li id="84e4" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">工厂封装了创建可被许多客户机重用的对象的逻辑。</li></ul><p id="2cdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工厂模式有许多变体，每一种都解决不同的问题。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="02b9" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">1.静态工厂方法</h1><p id="2c24" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">构造函数与声明它的类同名。如果类中有多个重载构造函数，它们将具有相同的名称。</p><p id="c05a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要用多个重载构造函数实例化一个类的客户端代码，如果不检查类的实现细节，可能不知道调用哪个构造函数<strong class="lb iu"> </strong>。</p><p id="e52a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，当构造函数需要相同数量的相同类型的参数时，有时它们根本不起作用。</p><p id="981b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码无法编译:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="1ac0" class="nw mw it ly b gy nx ny l nz oa">public struct TimeSpan<br/>{<br/>    public TimeSpan(double seconds)<br/>    {<br/>    }    </span><span id="3606" class="nw mw it ly b gy ob ny l nz oa">    public TimeSpan(double minutes)<br/>    {   <br/>    }<br/>}</span></pre><p id="2ca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态工厂方法是构造函数的一个很好的替代方法，因为它们有一个惟一的名称，可以准确地描述返回实例的用途。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="8331" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端代码可以通过读取工厂方法的名称来判断要调用哪个工厂方法，甚至不需要查看类代码。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="1219" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">2.异步工厂方法</h1><p id="be29" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">构造函数的一个限制是它不能用关键字<code class="fe lv lw lx ly b">async</code>标记。因此，如果需要，无法在构造函数中等待异步调用。</p><p id="d174" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您需要执行一些异步操作来创建对象时，异步工厂方法有助于绕过这个构造函数限制。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="a8d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，这个构造函数是私有的，所以创建对象的唯一方法是调用<code class="fe lv lw lx ly b">CreateNewAsync</code>方法。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="0b6a" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">3.参数化工厂方法</h1><p id="4647" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">参数化工厂方法基于输入参数创建并返回特定类型的对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="4269" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工厂方法可以使用字典(表驱动方法)、<code class="fe lv lw lx ly b">switch</code>表达式或简单的<code class="fe lv lw lx ly b">if-else</code>语句来实现。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="c9c3" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">4.内部工厂</h1><p id="092a" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在决定将工厂方法放在哪里时，开发人员有几种选择。</p><h2 id="9215" class="nw mw it bd mx oe of dn nb og oh dp nf li oi oj nh lm ok ol nj lq om on nl oo bi translated">在原来的班级里</h2><p id="fbfe" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">最直接的方法是将工厂方法直接放入它们创建的类中。</p><p id="cc89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当静态工厂方法简单并且包含几行代码时，通常选择这种方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="99e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将静态工厂方法放在原始类中的缺点是，它违反了单一责任原则，因为该类除了它的主要责任之外，还知道如何创建自己。</p><p id="e30b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优点是凝聚力高。工厂方法尽可能靠近它们实例化的类。</p><h2 id="10e9" class="nw mw it bd mx oe of dn nb og oh dp nf li oi oj nh lm ok ol nj lq om on nl oo bi translated">在单独的班级里</h2><p id="b4a5" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">静态工厂方法的另一个位置是一个单独的类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="027b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法解决了单一责任的问题，但是出现了另一个更严重的问题。<code class="fe lv lw lx ly b">Term</code>类的构造函数现在必须是公共的。否则，工厂方法无法创建<code class="fe lv lw lx ly b">Term</code>实例。</p><p id="e281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时拥有公共构造函数和工厂方法<strong class="lb iu"> </strong>使得需要实例化类的客户很难正确使用代码，因为他们不得不在两个可用选项之间做出选择。</p><h2 id="99f9" class="nw mw it bd mx oe of dn nb og oh dp nf li oi oj nh lm ok ol nj lq om on nl oo bi translated">在内层</h2><p id="cdd9" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">内部工厂有助于减少前两种方法的缺点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="0760" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内部工厂是一个内部静态类，可以访问外部类的私有构造函数，因此不再需要公共构造函数。</p><p id="a4cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内部工厂模式用于。NET内置类型。例如，启动新任务的选项之一如下所示:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="92b9" class="nw mw it ly b gy nx ny l nz oa">await Task.Factory.StartNew(() =&gt;<br/>{<br/>    //Code<br/>});</span></pre></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="fb9c" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">5.抽象工厂</h1><p id="a884" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">抽象工厂提供了创建依赖或相关对象的接口。</p><p id="2146" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">抽象工厂可以使用适当的抽象类或接口来实现。</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="ab6b" class="nw mw it ly b gy nx ny l nz oa"><strong class="ly iu">//Abstract factory</strong><br/>public abstract class DbProviderFactory<br/>{<br/>    public abstract DbConnection CreateConnection();<br/>    public abstract DbCommand CreateCommand();<br/>}</span><span id="d62f" class="nw mw it ly b gy ob ny l nz oa"><strong class="ly iu">//Concrete factory</strong><br/>public class SqlClientFactory : DbProviderFactory<br/>{<br/>    public override DbConnection CreateConnection() <br/>        =&gt; new SqlConnection();<br/>    <br/>    public override DbCommand CreateCommand() <br/>        =&gt; new SqlCommand();<br/>}</span><span id="8e39" class="nw mw it ly b gy ob ny l nz oa"><strong class="ly iu">//Concrete factory</strong><br/>public class PostgreSqlClientFactory : DbProviderFactory<br/>{<br/>    public override DbConnection CreateConnection() <br/>        =&gt; new PostgreSqlConnection();</span><span id="500d" class="nw mw it ly b gy ob ny l nz oa">    public override DbCommand CreateCommand() <br/>        =&gt; new PostgreSqlCommand();<br/>}</span></pre><p id="1cc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端代码应该只依赖于使用以下方法的<code class="fe lv lw lx ly b">DbProviderFactory</code>抽象工厂:<code class="fe lv lw lx ly b">CreateConnection</code>、<code class="fe lv lw lx ly b">CreateCommand</code>等等。</p><p id="eadc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要让客户机代码与不同的数据存储一起工作，您只需要更改DI容器中的特定实现。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="21df" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">结论</h1><p id="7f10" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">实现工厂设计模式的选项列表可能不完整，因为封装了创建对象的逻辑的每个类都可以称为工厂。</p><p id="b183" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过最常用和最有趣的方式来实现这个模式(从我的角度来看)。欢迎对工厂模式的实现提出任何其他想法。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="c4af" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">我的其他文章</h1><div class="op oq gp gr or os"><a href="https://levelup.gitconnected.com/how-to-professionally-to-do-a-code-review-of-a-bug-fix-f17de72d42e0" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">如何专业地对Bug修复进行代码审查</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">审查bug修复时要问的几个重要问题。</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://levelup.gitconnected.com/you-are-simply-injecting-a-dependency-thinking-that-you-are-following-the-dependency-inversion-32632954c208" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">你只是简单地注入一个依赖，认为你在遵循依赖倒置…</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">澄清差异。</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://levelup.gitconnected.com/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">如何在不破坏应用程序的情况下修复Bug</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">更改源代码时更自信的步骤。</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pb l"><div class="pi l pd pe pf pb pg ks os"/></div></div></a></div></div></div>    
</body>
</html>