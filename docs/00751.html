<html>
<head>
<title>Why Would You Use Async Generators?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么要使用异步生成器？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-would-you-use-async-generators-eabbd24c7ae6?source=collection_archive---------9-----------------------#2019-07-09">https://betterprogramming.pub/why-would-you-use-async-generators-eabbd24c7ae6?source=collection_archive---------9-----------------------#2019-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d397" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">讨论与异步生成器相关的概念和策略</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/76845eed1c4065744fd6aa28a93cd6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b6gAV8FckLGDCeeCAnDwcQ.png"/></div></div></figure><p id="e717" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今年6月，我参加了凯尔·辛普森在阿姆斯特丹举办的研讨会“<a class="ae lq" href="https://frontendmasters.com/courses/js-recent-parts/" rel="noopener ugc nofollow" target="_blank"> JavaScript:最近的部分</a>”。材料和表演都很棒，凯尔是表演工作坊的真正大师！</p><p id="7baa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我最兴奋的一个话题是<code class="fe lr ls lt lu b">async generators</code>，它在活动接近尾声时被提及。观众参与进来，并被问了几个关于使用<code class="fe lr ls lt lu b">async generators</code>技术可以实现的不同策略和迭代顺序的问题。为了更好地理解它，我决定写一篇关于这些模式的短文。我将解释一些与<code class="fe lr ls lt lu b">generators</code>话题相关的概念，并详细描述这些策略。</p><p id="bf99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有很多很好的文章和教程详细解释了<a class="ae lq" href="https://codeburst.io/a-simple-guide-to-es6-iterators-in-javascript-with-examples-189d052c3d8e" rel="noopener" target="_blank">迭代器</a>。所以，为了更接近这篇文章的目标，我会简单地说一下。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c0cb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">迭代器</h1><p id="c322" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_generators" rel="noopener ugc nofollow" target="_blank">迭代器</a>简而言之就是任何实现<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol" rel="noopener ugc nofollow" target="_blank">迭代器协议</a>的对象。基本上，<code class="fe lr ls lt lu b">Iterator</code>对象必须包含<code class="fe lr ls lt lu b">next</code>函数，并返回一个具有任意类型<code class="fe lr ls lt lu b">value</code>和布尔<code class="fe lr ls lt lu b">done</code>属性的对象。<code class="fe lr ls lt lu b">next</code>方法定义了迭代的顺序以及每一步产生的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6a24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要迭代这样的对象，可以使用不同的技术:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="fe66" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">许多内置对象，如数组、字符串、映射和集合，已经实现了可迭代接口。通常，为了与<code class="fe lr ls lt lu b">generators</code>兼容，迭代器在<code class="fe lr ls lt lu b">Symbol.iterator</code>属性上声明。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c14a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能会注意到，在到达结束状态后，after done看起来是<code class="fe lr ls lt lu b">true</code>。对迭代器方法的<code class="fe lr ls lt lu b">next()</code>调用返回相同的结果- <code class="fe lr ls lt lu b">{value: undefined, done: true}</code>。</p><p id="f0d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">生成器是一个函数，它简化了迭代器的声明。它可以<strong class="kw iu">停止执行</strong>和<strong class="kw iu">返回多个值</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0e3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个生成器以<code class="fe lr ls lt lu b">function*</code>操作符开始，它的主体就像一个普通的函数，扩展了一些特性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6457" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">异步迭代器</h1><p id="7a76" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">异步迭代器允许延迟包含异步逻辑的迭代过程。异步迭代器<code class="fe lr ls lt lu b">next()</code>方法的每个结果返回一个<code class="fe lr ls lt lu b">Promise</code>，解析成一个对象，包含<code class="fe lr ls lt lu b">value</code>和<code class="fe lr ls lt lu b">done</code>属性。</p><p id="bd81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">异步函数</strong>允许我们使用<code class="fe lr ls lt lu b">await</code>语法并返回<code class="fe lr ls lt lu b">Promise</code>。从逻辑上讲，<strong class="kw iu">异步发电机</strong>允许<code class="fe lr ls lt lu b">await</code>并产生<code class="fe lr ls lt lu b">Promises</code>。</p><blockquote class="nb"><p id="3240" class="nc nd it bd ne nf ng nh ni nj nk lp dk translated">那么，为什么有人会使用异步发电机呢？</p></blockquote><p id="c29b" class="pw-post-body-paragraph ku kv it kw b kx nm ju kz la nn jx lc ld no lf lg lh np lj lk ll nq ln lo lp im bi translated">好问题！<code class="fe lr ls lt lu b">Async iterators</code>自带酷炫<em class="nr">循环构造:</em></p><pre class="kj kk kl km gt ns lu nt nu aw nv bi"><span id="4ba6" class="nw md it lu b gy nx ny l nz oa">for await (const item of asyncIterator) {<br/>  // ...<br/>}</span></pre><p id="2239" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是原因！😉这意味着开发人员可以定义任何他或她喜欢的异步迭代顺序。例如，您可以迭代<a class="ae lq" href="https://nodejs.org/api/stream.html#stream_readable_symbol_asynciterator" rel="noopener ugc nofollow" target="_blank">节点读取流</a>。</p><pre class="kj kk kl km gt ns lu nt nu aw nv bi"><span id="101a" class="nw md it lu b gy nx ny l nz oa">const fs = require('fs')<br/>const readStream = fs.createReadStream('./test.txt', { encoding: 'utf8' })</span><span id="de01" class="nw md it lu b gy ob ny l nz oa">async function print() { <br/>  for await (const chunk of readStream) {<br/>    console.log(chunk)<br/>  }<br/>}<br/>  <br/>print()</span></pre><p id="f7c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不要忘记切换到更新版本的<code class="fe lr ls lt lu b">Node</code>:</p><pre class="kj kk kl km gt ns lu nt nu aw nv bi"><span id="d454" class="nw md it lu b gy nx ny l nz oa">nvm use 12<br/>Now using node v12.4.0 (npm v6.9.0)</span></pre><p id="5025" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，<code class="fe lr ls lt lu b">for-await</code>只能在<code class="fe lr ls lt lu b">async</code>函数内部使用。从实现的角度来看，<code class="fe lr ls lt lu b">async iterators</code>应该用<code class="fe lr ls lt lu b">Symbol.asyncIterator</code>属性来声明。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9f53" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">异步策略</strong></h1><p id="bcdd" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">假设您想要请求多个异步源:</p><pre class="kj kk kl km gt ns lu nt nu aw nv bi"><span id="93a5" class="nw md it lu b gy nx ny l nz oa">async function* inOrderRequests(urls) {<br/>  for (const url of urls) {<br/>    const response = await fetch(url)<br/>    const text = await response.text()<br/>    yield text<br/>  }<br/>}</span></pre><p id="6940" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，可以在异步函数中迭代<code class="fe lr ls lt lu b">urls</code>:</p><pre class="kj kk kl km gt ns lu nt nu aw nv bi"><span id="7121" class="nw md it lu b gy nx ny l nz oa">async function pageText(urls) {<br/>  for await (const responseText of inOrderRequests(urls)) {<br/>    console.log(responseText) <br/>  }<br/>}</span><span id="1c62" class="nw md it lu b gy ob ny l nz oa">pageText([location.href])</span></pre><p id="2d0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">pageText([location.href])</code>函数调用输出当前浏览器页面的初始文本。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="c8b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在研讨会期间，Kyle确定了可用于请求异步资源的三种不同策略:</p><ul class=""><li id="7631" class="oc od it kw b kx ky la lb ld oe lh of ll og lp oh oi oj ok bi translated"><code class="fe lr ls lt lu b">in order - in order</code>当一个请求在另一个请求的响应返回后执行。上面的<code class="fe lr ls lt lu b">pageText</code>就是这种策略的一个例子。</li><li id="0e58" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated"><code class="fe lr ls lt lu b">asap - in order</code>当请求被一起执行并且响应以初始顺序返回时。我们将用一个<code class="fe lr ls lt lu b">asapInOrderRequests</code>函数来修改前面的例子。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7c42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，所有的请求都会立即执行。该函数等待每个请求解决，但是请求所花费的总时间受限于它最大的延迟<code class="fe lr ls lt lu b">Promise</code>。</p><ul class=""><li id="8e91" class="oc od it kw b kx ky la lb ld oe lh of ll og lp oh oi oj ok bi translated">最后，当请求和结果都被执行并尽快返回时，应用<code class="fe lr ls lt lu b">asap - asap</code>策略。</li></ul><p id="e3b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在研讨会上，<a class="ae lq" href="https://me.getify.com/" rel="noopener ugc nofollow" target="_blank">凯尔</a>展示了所有三种可能性，其中<code class="fe lr ls lt lu b">asap - asap</code>是最难的，因为他正在即兴创作。我确实也发现后者最有趣</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9e1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，JavaScript闭包特性被用来表示一个已解决的<code class="fe lr ls lt lu b">Promise</code>。每当它被满足，发电机<code class="fe lr ls lt lu b">yields</code>的结果，所以整个比赛的<code class="fe lr ls lt lu b">Promises</code>正在发生。完成这个练习花了我一些时间和努力。希望你会觉得有用。</p><p id="d618" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我对你的反馈很感兴趣。请让我知道你对那段代码的看法。你会在你的项目中使用类似的结构吗？评论中再见🙂</p><p id="905e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并有一个不错的编码！</p></div></div>    
</body>
</html>