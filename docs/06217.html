<html>
<head>
<title>10 Advanced Python Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10个高级Python面试问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-advanced-python-interview-questions-d36e3429601b?source=collection_archive---------2-----------------------#2020-09-10">https://betterprogramming.pub/10-advanced-python-interview-questions-d36e3429601b?source=collection_archive---------2-----------------------#2020-09-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="723a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">搞定你的下一次面试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/55b510cad7d82dc14c7e966d4da6f24b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fBSRbko6iUMII3HQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="36b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着Python最近变得越来越流行，你们中的许多人可能正在接受与Python相关的技术面试。在本帖中，我将列出十个高级Python面试问答。</p><p id="0183" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些可能会令人困惑，针对的是中级开发人员，他们需要很好地理解Python作为一种语言以及它是如何工作的。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="7da8" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">Nolocal和Global关键字有什么用途？</h1><p id="381c" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">这两个关键字用于改变先前声明的变量的范围。<code class="fe my mz na nb b">nolocal</code>经常在需要访问嵌套函数中的变量时使用:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="0758" class="ng mc it nb b gy nh ni l nj nk">def func1(): <br/>    x = 5<br/>    def func2(): <br/>        nolocal x <br/>        print(x) <br/>    func2()</span></pre><p id="d38d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe my mz na nb b">global</code>是更直接的指令。它使先前声明的变量成为全局变量。例如，考虑以下代码:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="34cc" class="ng mc it nb b gy nh ni l nj nk">x = 5 <br/>def func1(): <br/>    print(x) <br/>func1() <br/>&gt; 5</span></pre><p id="3ab7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于<code class="fe my mz na nb b">x</code>是在函数调用之前声明的，<code class="fe my mz na nb b">func1</code>可以访问它。但是，如果你试图改变它:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="6ff4" class="ng mc it nb b gy nh ni l nj nk">x = 5 <br/>def func2(): <br/>    x += 3 <br/>func2() <br/>&gt; UnboundLocalError: local variable 'c' referenced before assignment</span></pre><p id="aa15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了让它工作，我们需要指出，我们所说的<code class="fe my mz na nb b">x</code>是指全局变量<code class="fe my mz na nb b">x</code>:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="1e6c" class="ng mc it nb b gy nh ni l nj nk">x = 5 <br/>def func2(): <br/>    global x <br/>    x += 3 <br/>func2()</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="3f19" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">Classmethod和Staticmethod有什么区别？</h1><p id="fa3b" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">它们都定义了一个无需实例化类的对象就可以调用的类方法。唯一的区别在于他们的签名:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="03fc" class="ng mc it nb b gy nh ni l nj nk">class A: <br/>    @staticmethod <br/>    def func1(): <br/>        pass <br/>    @classmethod <br/>    def func2(cls): <br/>        pass</span></pre><p id="5890" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，<code class="fe my mz na nb b">classmethod</code>接受一个隐式参数<code class="fe my mz na nb b">cls</code>，该参数将被设置为类<code class="fe my mz na nb b">A</code>本身。<code class="fe my mz na nb b">classmethod</code>的一个常见用例是创建可选的可继承构造函数。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="9e49" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">什么是GIL，有哪些方法可以避开它？</h1><p id="8786" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">GIL代表全局解释器锁，它是Python用于并发的一种机制。它深深地嵌入到Python系统中，目前不可能摆脱它。GIL的主要缺点是它使线程不能真正并发。它会锁定解释器，即使看起来您正在使用线程，它们也不会同时执行，从而导致性能损失。以下是一些解决方法:</p><ul class=""><li id="94fc" class="nl nm it la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated"><code class="fe my mz na nb b">multiprocessing</code>模块。它允许您生成新的Python进程，并像管理线程一样管理它们。</li><li id="1621" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated"><code class="fe my mz na nb b">asyncio</code>模块。它有效地启用了异步编程，并添加了<code class="fe my mz na nb b">async/await</code>语法。虽然它没有解决GIL问题，但它会使代码更易读、更清晰。</li><li id="e488" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated"><a class="ae nz" href="https://en.wikipedia.org/wiki/Stackless_Python" rel="noopener ugc nofollow" target="_blank">无栈Python </a>。这是一条没有GIL的蟒蛇叉。它最显著的用途是作为EVE在线游戏的后端。</li></ul></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="f894" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">什么是元类，什么时候使用？</h1><p id="c5f9" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">元类是类的类。元类可以指定某些行为，这些行为对于许多类来说是常见的，以防继承过于混乱。一个常见的元类是<code class="fe my mz na nb b">ABCMeta</code>，用于创建抽象类。</p><p id="a937" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python中的元类和元编程是一个巨大的话题。如果你对它感兴趣，一定要多读一些。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="f79e" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">什么是类型注释？什么是泛型类型注释？</h1><p id="b600" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">虽然Python是一种动态类型语言，但为了清晰起见，有一种方法可以注释类型。这些是内置类型:</p><ul class=""><li id="b8aa" class="nl nm it la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated"><code class="fe my mz na nb b">int</code></li><li id="dca4" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated"><code class="fe my mz na nb b">float</code></li><li id="2feb" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated"><code class="fe my mz na nb b">bool</code></li><li id="a725" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated"><code class="fe my mz na nb b">str</code></li><li id="8594" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated"><code class="fe my mz na nb b">bytes</code></li></ul><p id="d1c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">复杂类型可从<code class="fe my mz na nb b">typing</code>模块获得:</p><ul class=""><li id="b018" class="nl nm it la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated"><code class="fe my mz na nb b">List</code></li><li id="64e8" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated"><code class="fe my mz na nb b">Set</code></li><li id="502b" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated"><code class="fe my mz na nb b">Dict</code></li><li id="f4e9" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated"><code class="fe my mz na nb b">Tuple</code></li><li id="a870" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated"><code class="fe my mz na nb b">Optional</code></li><li id="a27d" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">等等。</li></ul><p id="b407" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是使用类型注释定义函数的方法:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="d8b6" class="ng mc it nb b gy nh ni l nj nk">def func1(x: int, y: str) -&gt; bool: <br/>    return False</span></pre><p id="0d77" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">泛型类型批注是将另一种类型作为参数的批注，允许您指定复杂的逻辑:</p><ul class=""><li id="2253" class="nl nm it la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated"><code class="fe my mz na nb b">List[int]</code></li><li id="6928" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated"><code class="fe my mz na nb b">Optional[List[int]]</code></li><li id="ac54" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated"><code class="fe my mz na nb b">Tuple[bool]</code></li><li id="d4c0" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">等等。</li></ul><p id="8c0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，这些仅用于警告和静态类型检查。在运行时不能保证这些类型。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="09dd" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">什么是发电机功能？编写您自己的Range版本</h1><p id="f152" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">生成器函数是可以在返回值后暂停执行的函数，以便在稍后的某个时间恢复执行并返回另一个值。这是通过关键字<code class="fe my mz na nb b">yield</code>实现的，您可以用它来代替return。您使用过的最常见的生成器函数是<code class="fe my mz na nb b">range</code>。下面是实现它的一种方法(只适用于积极的步骤，我将把它作为一个练习，让它支持消极的步骤):</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="8f13" class="ng mc it nb b gy nh ni l nj nk">def range(start, end, step): <br/>    cur = start <br/>    while cur &gt; end: <br/>        yield cur <br/>        cur += step</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="9379" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">Python中的Decorators是什么？</h1><p id="183e" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">Python中的装饰器用于修改函数的行为。例如，如果您想记录对一组特定函数的所有调用，缓存它的参数和返回值，执行基准测试等。</p><p id="e8c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">装饰符以符号<code class="fe my mz na nb b">@</code>为前缀，放在函数声明之前:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="0146" class="ng mc it nb b gy nh ni l nj nk">@my_decorator <br/>def func1(): <br/>    pass</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="a553" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">Python中的酸洗和拆洗是什么？</h1><p id="4b76" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">Pickling只是序列化的Python说法。Pickling允许您将一个对象序列化为一个字符串(或您选择的任何其他内容)，以便保存在存储上或通过网络发送。拆包是从已拆包的字符串中恢复原始对象的过程。腌制不安全。仅从可信来源中取消选取对象。</p><p id="a035" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是你如何处理一个基本的数据结构:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="ec57" class="ng mc it nb b gy nh ni l nj nk">import pickle <br/>cars = {"Subaru": "best car", "Toyota": "no i am the best car"} cars_serialized = pickle.dumps(cars) <br/># cars_serialized is a byte string </span><span id="a5db" class="ng mc it nb b gy oa ni l nj nk">new_cars = pickle.loads(cars_serialized)</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="df9b" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">Python函数中的<code class="fe my mz na nb b">*args</code>和<code class="fe my mz na nb b">**kwargs</code>是什么？</h1><p id="8fe5" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">这些与拆包密切相关。如果将<code class="fe my mz na nb b">*args</code>放在函数的参数列表中，所有未命名的参数都将存储在<code class="fe my mz na nb b">args</code>数组中。<code class="fe my mz na nb b">**kwargs</code>工作方式相同，但对于命名参数:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="54c9" class="ng mc it nb b gy nh ni l nj nk">def func1(*args, **kwargs): <br/>    print(args) <br/>    print(kwargs) <br/>func1(1, 'abc', lol='lmao') <br/>&gt; [1, 'abc'] <br/>&gt; {"lol": "lmao"}</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="eb68" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><code class="fe my mz na nb b">.pyc</code>文件是用来做什么的？</h1><p id="6cbd" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated"><code class="fe my mz na nb b">.pyc</code>文件包含Python字节码，与Java中的<code class="fe my mz na nb b">.class</code>文件一样。Python仍然被认为是一种解释语言，因为这个编译阶段发生在你运行程序的时候，而在Java中，这两个阶段是明显分开的。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="2b2b" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">在Python中如何定义抽象类？</h1><p id="217b" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">您通过从<code class="fe my mz na nb b">abc</code>模块继承<code class="fe my mz na nb b">ABC</code>类来定义抽象类:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="a23b" class="ng mc it nb b gy nh ni l nj nk">from abc import ABC <br/>class AbstractCar(ABC): <br/>    @abstractmethod <br/>    def drive(self): <br/>        pass</span></pre><p id="eb22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要实现该类，只需继承它:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="3f45" class="ng mc it nb b gy nh ni l nj nk">class ToyotaSupra(AbstractCar): <br/>    def drive(self): <br/>        print('brrrr sutututu')</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="5e41" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结束语</h1><p id="920d" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">感谢您的阅读，祝您下次面试一切顺利。</p><h2 id="8d37" class="ng mc it bd md ob oc dn mh od oe dp ml lh of og mn ll oh oi mp lp oj ok mr ol bi translated">资源</h2><ul class=""><li id="3cf5" class="nl nm it la b lb mt le mu lh om ll on lp oo lt nq nr ns nt bi translated"><a class="ae nz" href="https://levelup.gitconnected.com/python-context-managers-in-depth-52dd2dd2624b" rel="noopener ugc nofollow" target="_blank">深度Python上下文管理器</a></li></ul></div></div>    
</body>
</html>