# 我在编程的前两年学到的 5 个教训

> 原文：<https://betterprogramming.pub/5-lessons-i-learned-in-my-first-2-years-of-programming-18e43c652367>

## 我在任何教程中都没有找到的东西

![](img/432fedfc0f2976a3f9ef01c8f5553506.png)

照片由[元素 5 数码](https://unsplash.com/@element5digital?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/learn?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

两年多来，我一直靠写代码赚钱。在那段时间里，我对编程的看法发生了很大的变化。

对我来说，最重要的课程不是学习一门特定语言或框架的复杂性。相反，我最大的思想转变是更多地了解编程，与其他人一起工作，并做出一些在你停止工作后仍能保持很长时间的东西。

本文中的例子都是用 JavaScript 编写的，但我希望它们足够简单，无论您的背景如何，都能容易理解。而且，这些想法都是主观的。如果你不同意，我希望在评论中听到更多。

# 你是在为人们写代码，而不是计算机

当我开始的时候，似乎编码就是写指令让计算机去解释。好的代码感觉就像完成工作的代码。但是考虑下面的例子:

```
for(let i=0;i<100;)console.log((++i%3?'':'Fizz')+(i%5?'':'Buzz')||i)
```

你可能会意识到这是经典 FizzBuzz 问题的一个实现。它可以工作，但是代码是如何工作的并不明显。像这样的怎么样？

第一个例子可能更聪明，但是对我来说，第二个例子更容易阅读、理解和维护。在大多数情况下，我们的目标是后者。当然，这个例子是精心设计的，但是随着我们代码的需求变得越来越复杂，清晰的需求变得越来越重要。

因此，好的代码是为其他人编写的代码。我们与传统作家的共同点比我们想象的要多！

# 人们不同意什么使代码可读

不幸的是，什么是可读代码可能会引起分歧。

在我目前的工作中，我们使用类型转换的快捷方式，比如用`+`表示数字，用`!!`表示布尔值。但是在我以前的工作中，我已经学会了避免这些，而支持`Number`和`Boolean`构造函数。我也目睹了关于`async` / `await`和`then` / `catch`的争论(一个我对有强烈意见的问题)！

虽然许多样式问题可以用您最喜欢的代码格式化程序来解决，但重要的是要知道代码可读性实践会根据上下文而变化。总的来说，我们应该渴望根据他们的经验和偏好，写出其他从事这项工作的人可读的代码。

这里有一些关于代码可读性的更具体的想法。

## 1.认知复杂性

我发现一个有用的可读性概念是*认知复杂性*。我在使用代码质量软件 [Sonarcloud](https://sonarcloud.io/) 时遇到了它，它试图测量一个代码单元的理解难度——包括所有可能的路径。

每一层新的嵌套和每一条新的可能路径都会增加认知的复杂性。这包括`for`和`while`循环、`if`语句、三元运算符和可选的链接运算符。

举个简单的例子，这个`isPrime`函数的认知复杂度为 4:

很容易遇到在认知复杂性量表上得分极高的文件，它们有许多嵌套和许多可能的路径。减少这一点是提高可读性的一种方法，你的同事可能会同意这一点，但你的格式化程序不会注意到这一点。

## 2.评论

许多针对初级程序员的教育内容强调好的注释的重要性。但以我的经验来看，过于依赖注释其实对可维护性不好。

这主要有两个原因。首先，注释很容易被它们所解释的代码取代。随着时间的推移，随着项目的变化，代码行将不可避免地四处移动。但是因为注释不是代码运行所必需的，所以很容易把它们放在错误的地方。这可能会导致更多的混乱，因为注释可能会出现在解释错误的代码旁边。

第二个更重要的原因是，注释代码通常可以重写，这样就可以很容易地从代码本身理解代码的作用——主要是通过更好的结构和更好的变量名。

这里有一个简单的例子:

我在一个生产代码库中遇到过类似上面的东西。尽管我们需要在一个数组中存储所有的产品代码，但我们仍然可以将它们分开存储，这样我们就可以删除注释:

这个简单的变化意味着代码可以不用注释就能理解，如果结构发生变化，我们忘记哪些 id 适用于 t 恤，哪些适用于帽衫的风险就会小得多。

# 编程都是关于数据的

对于初学编程的人来说，制作软件的想法可能感觉非常神秘。想象最终结果很容易，但要理解如何实现却困难得多。我最早的啊哈之一！moments 认为编程都是关于数据的:获取数据、修改数据、显示数据，然后将数据发送到其他地方。

当然，把它归结为这些要点并不意味着它总是简单的。从本质上说，让一架飞机飞起来就是升力、阻力、推力和重量。我知道，但是设计一架飞机对我没多大用处！

复杂软件面临的挑战是处理来自许多不同地方的大量数据，这些数据需要高效、大规模地修改，而显示数据也带来了各种挑战。

也就是说，将编程视为数据经历的旅程帮助我分解了更复杂的问题。一旦您能够确定需要什么数据、如何获取数据、如何将数据转换成所需的形式，以及在哪里显示或发送数据，那么您就离解决方案不远了。

# 性能并不重要(除非有必要)

在理想情况下，我们有时间确保所有代码尽可能快地运行。然而，通常花在微调性能上的时间可以更好地用在做其他事情上:在商业中，修复 bug 或创建新功能通常比从特定函数或代码块中减去几百毫秒更有价值。

当然，这条规则也有例外。有些功能需要非常可靠或者非常耗费资源，因此节省下来的每一毫秒都很重要。随着规模的扩大，性能也变得更加重要。如果您可以为一百万用户节省 0.1 秒的加载时间，那么如果每个人都加载一次，那就相当于总共节省了 28 小时的时间。可悲的是，我们中很少有人在处理这样的数字。

性能代码的困境之一是它可能会违背我们更重要的目标:可读性和可维护性。高度优化的代码往往很难看。在我的专业领域——web 开发——有时会涉及到对抗库或框架，比如提供从 React 到使用常规 JavaScript 的退路。

很容易遇到过早优化导致的问题。以 React 为例，当使用`useMemo`或`useCallback`时，事实上[与常规变量和函数](https://kentcdodds.com/blog/usememo-and-usecallback)相比会降低性能。

我也因为过于自由地使用`Promise.all`而陷入尴尬的境地。以下面的函数为例(大致基于我写的一些正版代码):

尽管这比逐个执行异步函数要快，但我引入了一些不可靠的结果，而这些结果是较慢的代码可以避免的。我也许能够重新编写这些函数，使它们能够并发运行，但是让这三个函数并行平稳运行所花费的时间不值得节省。所以在这种情况下，最好这样做:

通常，最高级别的性能需要最高级别的控制。例如，如果我们想从网站中获得最大的理论性能，没有任何库或框架可能会更好。或者也许我们应该使用 Web Assembly 来用 C++编写整个代码？大型、复杂的项目很少选择这种方法有一个很好的原因:实现起来太耗时，维护起来也太耗时。

# 很多用户界面都是虚幻的

最后，关于编程的可视化方面的一个注意事项。作为一个初学者，我没有完全意识到好的 UI 往往是一种欺骗——让事情看起来比平常更快或更有趣。

以进度条为例。根据任务的不同，很难精确估计需要多长时间。这就是为什么我们如此习惯于不把剩余时间的估计看得太重。但是如果我们没有他们呢？如果没有迹象告诉用户有事情发生，人们会感到无聊，他们可能会关闭窗口或重启电脑。因此，我们给他们最好的猜测，以帮助他们保持参与，并阻止他们做任何事情来中断我们的软件。

其他例子是当我们获取数据时使用的占位符图形。或者在状态改变被发送到 API 之前在客户端改变状态。当您在社交媒体网站上关闭通知时，看起来该通知已被标记为立即阅读。但这是客户机在更改实际到达服务器之前向您显示的。一点点的烟火气，让用户的体验感觉又快又滑头。