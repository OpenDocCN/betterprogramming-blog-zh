# JavaScript 中递归的力量

> 原文：<https://betterprogramming.pub/the-power-of-recursion-in-javascript-af57107a1a5a>

## 递归是一种增强

![](img/a657461667a5ffcf253682a8a990cffe.png)

*Joshua Sortino 在 Unsplash 上拍摄的照片*

[递归](https://en.wikipedia.org/wiki/Recursion)是计算机编程中一个强大的概念，函数只需调用自己。在学习了基础知识之后，尽快学习递归是多么重要，这一点我怎么强调都不为过。

理解递归的概念以及如何创建递归将有助于你像程序员一样思考，这将有助于你编写更健壮的代码。

# 递归的好处

一般来说，在某些情况下应用递归时，您几乎总能从中获得以下好处:

1.  你节省了代码行。
2.  您的代码可以看起来更干净(因此应用干净的代码实践，即使这不是您的意图)。
3.  它有助于节省编写和调试代码的时间。
4.  它减少了运行算法的时间量([时间复杂度](https://en.wikipedia.org/wiki/Time_complexity))。
5.  有助于在处理树形结构时轻松解决问题。
6.  有助于*可视化*算法([不信我？](https://algorithm-visualizer.org/))。

# 递归的缺点

1.  它*可以*慢一些——在这种情况下，它会占用更多的堆栈空间(开销)。
2.  如果不使用[尾部调用优化](https://en.wikipedia.org/wiki/Tail_call)，则使用比循环更多的内存。

# 我们需要它吗？

实际上，您可以使用迭代来执行任何算法。问题是，你必须知道*什么时候*最好应用递归——只有这样递归才是更好的选择，而不是使用迭代。

当在最适合递归的情况下应用递归时，你就释放了递归的力量，就像在汉诺塔问题中应用递归一样。

# 例子

理解递归的一个好方法是查看应用递归来解决问题的工作代码。

## 遍历对象

如前所述，递归有助于在处理树形结构时轻松解决问题。一个深度嵌套的对象是一个树形结构，所以我们将使用一个对象。

假设我们有一个表示 HTML DOM 元素的对象，其中每个嵌套对象都可以有元素的子元素。每个子元素都是另一个 HTML DOM 元素，也可以有子元素，所以它可能是一个非常大的对象，这取决于它们的父元素产生了多少子元素。

我们的目标是挖掘每一个对象，不管它的嵌套有多深。

我们将查看它们的`style`属性(表示特定 HTML 元素的属性)，并将`border`、`textColor`和`width`属性固定到它们的样式表示中，以便在使用 JavaScript 时可以正常读取它们。

下面是一个需要更改的样式对象的示例:

在 HTML 中，为了给文本着色，我们需要使用`color`属性，所以我们必须将`textColor`转换为`color`。

对于`width`，我们假设这些小数代表用户设备视口的百分比(应该转换成`45vw`)，需要将`border`对象转换成类似`{ borderColor: 'hotpink', borderWidth: '2px' }`的形状。

让我们使用一个表示类似结构的对象，这样我们就可以遍历它并修复所有的样式对象:

好了，这里我们有一个树形结构，嵌套对象出现在`children`属性中。

我们要创建的第一件事是一个`transformStyleObject`函数，它接受一个 style 对象来修复它，返回一个可以在 JavaScript 和 DOM 中正常使用的新对象:

我们可以使用常规迭代来遍历对象:

但是它开始变得麻烦，原因如下:

1.  它变得更长。
2.  阅读变得更加困难。
3.  调试变得更加困难。
4.  它对变化变得更加敏感。
5.  测试变得更加困难。
6.  这变得很烦人，因为你不得不考虑更多的变量名。

相反，可以使用递归来解决上面列出的所有六个问题:

我们的实现现在看起来更加优雅，也更容易阅读！这种递归是这样工作的:

1.  `transformAll`接受一个代表 HTML DOM 元素的*单个*对象。
2.  转换该元素的样式属性(在我们的例子中，这是每个 HTML DOM 元素的目标)。
3.  通过检查元素的`children`属性来检查是否有嵌套元素。
4.  如果有，这个函数将遍历每个子节点，并在每个子节点上重新调用自己的`transformAll`。
5.  这启动了递归，并将遍历通过`children`找到的每个对象，不管树有多深。

# 使用文件和文件夹

我个人觉得写更多功能性代码是一种很棒的体验。当有功能代码时，就有更多的优雅。递归非常适合这种情况。

让我们构建一个程序，它将查看文件路径下的每个目录，扫描名为`__test__`的文件夹，并通过查找带有`.test.js`的文件名来检测是否有任何单元测试没有实现。

每个文件夹都将是一个“模块”，如果*没有*的`__test__`文件夹*或者*的`__test__` 文件夹中没有任何以`.test.js`结尾的文件，我们将假设*没有为其实现单元测试。*

如果它发现有一个模块的测试，它将向我们返回一个包含整个目录信息的对象，如下所示:

这个操作的最终结果是这些对象的数组，其中每个对象代表一个需要我们注意的文件夹(在我们的例子中是一个模块),因为他们还没有单元测试。

递归可以很容易地用来实现这一点。

我使用了 [JavaScript 算法 repo](https://github.com/trekhleb/javascript-algorithms) ，提取出了`src`目录中的所有内容，并有意删除了一些例子中的几个单元测试，以便我们的代码可以在结果中返回这些位置。

前面的代码片段从 [Node.js](https://nodejs.org/en/) 导入原生模块。

首先，我们将导入`fs`,并声明一个根目录来开始遍历:

接下来，我们稍后将使用来自`fs`模块的`isDirectory`方法来检测何时进入目录。我个人更喜欢将它包装成一个函数，因为我不喜欢编写完整的方法:

我们还将创建一个名为`hasTest`的函数，它接受一个字符串数组，遍历它们，如果它发现有一个测试文件，它将返回`true`，否则返回`false`:

现在对于主函数，我们称之为`findEmptyTests`，它负责累积所有没有实现任何测试的模块:

我们可以看到这是一个递归，因为它在这一行中调用了*本身*:

```
emptyTests = { ...emptyTests, ...findEmptyTests(filepath) }
```

这是最重要的部分！

这个函数的工作方式是，我们可以通过传入一个文件路径来调用`findEmptyTests`。

如果我们传入的文件路径是一个目录，它会读取目录中的所有文件，并将文件名存储到`dir`数组中。

之后会执行一个循环，以便我们可以检查哪个是目录。如果遇到当前迭代`filepath`的目录，它将检查两个条件:

1.  当前迭代文件路径是`__test__`目录本身吗？如果是的话，检查一下那个目录，看看是否有以`.test.js`结尾的文件。如果没有，我们获取关于该模块在回购中的位置的信息。
2.  当前迭代的文件路径*是不是不是*是`__test__`目录而还是目录？如果是，则遍历该目录，并在该目录中启动整个函数*，并在其后的目录中启动，依此类推。*

最后，一旦它完成操作，就返回结果。

你可能已经注意到了`createMissingTestsObject`功能。它只是一个收集文件路径及其目录信息的函数:

这应该会返回一个丢失单元测试的位置对象！

# 结论

这个帖子到此结束！我希望你发现这是有价值的，并期待在未来更多！