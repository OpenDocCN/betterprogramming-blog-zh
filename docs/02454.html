<html>
<head>
<title>Smooth Sailing With Higher-Order Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高阶组件平稳运行</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/smooth-sailing-with-higher-order-components-4c6263d45fd?source=collection_archive---------23-----------------------#2019-12-01">https://betterprogramming.pub/smooth-sailing-with-higher-order-components-4c6263d45fd?source=collection_archive---------23-----------------------#2019-12-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="53b1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它们是什么，它们如何为你工作？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/55b20754c53c82b517bd6df1b38f8b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HuSztK4l7_i4Skh1JFaT4A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鲍比·伯奇在<a class="ae ky" href="https://unsplash.com/s/photos/boat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="cb4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的文档提供了定义高阶组件的流畅概述和清晰示例，并展示了它们如何在2020年保持和增强JavaScript代码性能。</p><p id="da73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://youtu.be/UcH2oLseKuc" rel="noopener ugc nofollow" target="_blank">现场视频</a>和<a class="ae ky" href="https://github.com/01Clarian/Higher-Order-Components-Example" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p><p id="5163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意:以下演示假设您对React有基本的了解，包括功能性组件与基于类的组件，以及命令提示符下的节点包管理器(<a class="ae ky" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank">NPM</a>)(Mac终端)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e722" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">定义高阶组件模式</h1><ul class=""><li id="7284" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated">理论定义:高阶组件，作为一个理论概念，在React中作为一种高级模式来重构组件逻辑，并在应用程序的代码中产生有益的结果。</li><li id="75c4" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">实用定义:hoc是<em class="nk">外部</em>功能组件，包裹<em class="nk">内部</em>组件以修改或增强内部组件。</li><li id="2e39" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">用例:通过在多个组件中识别相似的代码逻辑，hoc减少了逻辑开销，并删除了多余的JavaScript功能。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fe10" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">高阶模式和函数式编程</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/f19bcbc2a926fbc36c8161eefc739d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KcjzKQWbRKazTGdaJtMmQQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Clarian的特殊类型输入</p></figure><p id="b0f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在React中，高阶组件是将一个<em class="nk">原始组件</em>作为其参数的组件，并提供一个内部具有可扩展逻辑的新组件。</p><p id="7ecd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多第三方库实现了这种模式，<a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>的<code class="fe nm nn no np b">connect()</code>就是一个流行的例子。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="db92" class="nu md it np b gy nv nw l nx ny">export default <strong class="np iu">connect</strong>(mapStateToProps)(App);</span></pre><p id="8026" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no np b">connect()</code>是一个特设函数，它包装了一个React组件(app)来提供对Redux存储的访问。这将修改React组件，以便它可以从Redux接收动态状态和调度操作。</p><p id="f69f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某种意义上，高阶组件有助于函数式编程方法，例如避免共享状态<strong class="lb iu">。</strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="460c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">对比和评估</h1><p id="581e" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">比较高阶函数和高阶分量，观察<code class="fe nm nn no np b">Filter()</code>方法。</p><p id="3f0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no np b">Filter()</code>方法参数是一个回调函数，它测试数组中的每个元素并返回为真的元素。在下面的例子中，数组<code class="fe nm nn no np b">colors</code> <strong class="lb iu"> </strong>包含各种字符串。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="dc35" class="nu md it np b gy nv nw l nx ny">const colors = ['blue', 'white', 'green', 'black', 'yellow'];</span><span id="6d56" class="nu md it np b gy oc nw l nx ny">colors.filter(<strong class="np iu">functionArgument</strong> =&gt; <strong class="np iu">functionArgument</strong>[0] == "b");</span><span id="bc5c" class="nu md it np b gy oc nw l nx ny">//(2) ["blue", "black"]</span></pre><p id="9bf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，filter方法检查并只返回以字母“b”开头的字符串。通过将回调函数参数的第一个字符串值设置为等于“b”，高阶函数返回“蓝色”和“黑色”，从而成功完成其任务。</p><p id="2c9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于高阶函数可以通过把其他函数作为参数并返回来操作其他函数，高阶组件可以通过把其他组件作为参数并传递道具来操作其他组件。</p><p id="578c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一节评估一个React示例，以进一步阐明这种设计模式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="25b8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">特殊反应示例</h1><h2 id="5072" class="nu md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated"><em class="oo">识别特设实施</em></h2><p id="43a0" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">观察下面的应用程序，它由两个基本组件组成，一个点击计数器和一个悬停计数器。</p><p id="0e15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个基本的应用程序示例中，点击计数器组件将递增按钮元素的事件，而悬停计数器组件将递增鼠标悬停事件的标题标签。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/aa973427a9700ec6fb01ca3321f9f465.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*VI6dxQp5338ITbDVyiRpSw.png"/></div></figure><p id="f5d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是点击计数器的代码文件，通过构造函数将状态动态设置为基于类的组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="b24b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，count的状态在构造函数中被设置并初始化为零。一个递增函数被设置为按钮元素中的一个<code class="fe nm nn no np b">onClick</code>事件，它每点击一次就将先前的计数状态递增一。</p><p id="fdf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“渲染析构状态”关闭并渲染JSX，然后返回包含计数状态显示的按钮。</p><p id="bd08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然在浏览器上测试时，这些简单明了的代码执行起来有预期的结果，但是HOC的焦点集中在组件的逻辑构建上(特别是这个例子中的状态)。</p><p id="af07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了进一步检查<code class="fe nm nn no np b">ClickCounter.jsx</code>中的逻辑，通过观察应用程序的第二个组件的文件代码<code class="fe nm nn no np b">HoverCounter.jsx</code>来比较逻辑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="c6ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">悬停计数器组件也在其构造函数中将计数状态初始化为零的数值。它还建立了一个递增函数，将计数器的先前状态递增1，直到发生悬停事件<code class="fe nm nn no np b">onMouseOver</code>。</p><p id="5fae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，当在浏览器中测试时，该组件以预期的结果执行，并且应用程序相应地与点击计数器和悬停计数器一起运行。</p><p id="61df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当比较悬停计数器和点击计数器组件中的计数逻辑时，显而易见的是，不考虑触发更新状态函数的事件方法，增量状态逻辑在两个组件中几乎是相同的。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="ec38" class="nu md it np b gy nv nw l nx ny">constructor() {</span><span id="631f" class="nu md it np b gy oc nw l nx ny">    super()</span><span id="9ad6" class="nu md it np b gy oc nw l nx ny">    this.state = {</span><span id="757e" class="nu md it np b gy oc nw l nx ny">    count: 0}}</span><span id="0488" class="nu md it np b gy oc nw l nx ny">increment = () =&gt; {</span><span id="06b0" class="nu md it np b gy oc nw l nx ny">    this.setState(prevState =&gt; {</span><span id="3c87" class="nu md it np b gy oc nw l nx ny">    return {count: prevState.count + 1}</span><span id="a164" class="nu md it np b gy oc nw l nx ny">})}</span></pre><p id="6e78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如下一个代码示例所示，在这个应用程序示例中引入一个更高阶的组件减少了整体代码逻辑，实现了进一步增长潜力的可扩展性，并建立了增强的整体功能执行控制。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aaaf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">特设框架和示例实现</h1><p id="a5e1" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">既然已经确定了一个可能的特设模式实现，下面的代码文件<code class="fe nm nn no np b">EnhanceComponent.js</code>、<strong class="lb iu">、</strong>将一个更高阶的组件框架引入到我们的应用程序中。</p><p id="20fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还从/或计数器组件中取出复制的增量逻辑代码，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="9ef8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回顾上面的代码，高阶组件以<code class="fe nm nn no np b">EnhanceComponent</code>为名，因为它的目标是增强/修改点击和悬停组件。</p><p id="8d93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no np b">EnhanceComponent</code>的参数<strong class="lb iu">，</strong> origin组件，适用于点击和悬停组件。接下来，它为一个基于类的组件设置状态，名为<code class="fe nm nn no np b">ModComponent</code>(用于修改)。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="cd71" class="nu md it np b gy nv nw l nx ny">... const <strong class="np iu">EnhanceComponent</strong> = (<strong class="np iu">OrignComponent</strong>) =&gt; {</span><span id="35ac" class="nu md it np b gy oc nw l nx ny">class <strong class="np iu">ModComponent</strong> extends React.Component { ...</span></pre><p id="f9cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，<code class="fe nm nn no np b">ModComponent</code>处理状态计数逻辑，并用从悬停和点击组件中看到和复制的增量函数设置状态。</p><p id="96de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，HOC <code class="fe nm nn no np b">ModComponent</code>渲染原始组件，从<code class="fe nm nn no np b">ModComponent</code>获得道具访问。</p><p id="1154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从理论上讲，现在无论特设包装了什么，都可以访问包含计数器增量逻辑的<code class="fe nm nn no np b">ModComponent</code>状态。</p><p id="82dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意代码中<code class="fe nm nn no np b">OriginComponent</code>如何将道具<code class="fe nm nn no np b">name</code>设置为字符串<code class="fe nm nn no np b">‘milk and Sugar’</code>。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="f427" class="nu md it np b gy nv nw l nx ny">increment={this.increment} <strong class="np iu">name</strong>='Milk And Sugar'</span></pre><p id="253a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于本文档的作者喜欢喝咖啡，所以提供了以下咖啡类比。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f513" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">特设咖啡杯模拟和实施</h1><p id="48fa" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">通过在弦<code class="fe nm nn no np b">milk and sugar</code>上设置一个道具<code class="fe nm nn no np b">name</code>，观察以下与生活相关的类比和测试演示。</p><p id="34eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑点击组件和悬停组件各自表示在咖啡馆倒的一杯咖啡。想象一下，每个顾客都要糖，收银员不得不伸手到柜台后面拿糖罐给每个顾客分发糖。</p><p id="991b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于逻辑在本质上是重复的，为了节省收银员重复倒糖这一单调任务的时间，咖啡馆为顾客设置了一张糖和牛奶的桌子。</p><p id="2049" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，咖啡馆老板不会告诉收银员将糖倒入咖啡机中，因为这将使咖啡不再纯净，并给只想喝无糖咖啡的顾客带来麻烦。</p><p id="4f73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个意义上说，糖和牛奶的桌子就像是每一杯咖啡的附属品。每一杯咖啡代表一个组件——悬停计数器组件和点击计数器组件。</p><p id="397a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，咖啡就保持了纯粹的功能和目的，仅仅是一杯咖啡，而收银员则负责收银工作。</p><p id="037c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">牛奶和糖的桌子增强了选择喝咖啡的顾客的咖啡体验，因此创造了可扩展性和更纯粹和结构化的整体咖啡体验。</p><p id="a2fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到<code class="fe nm nn no np b">ClickCounter.jsx</code> <strong class="lb iu"> </strong>文件，导入<code class="fe nm nn no np b">EnhanceComponent</code>并将其包装在<code class="fe nm nn no np b">ClickCounter</code>组件上，提供了对<code class="fe nm nn no np b">‘milk and sugar’</code>字符串属性的访问。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="229e" class="nu md it np b gy nv nw l nx ny">import EnhanceComponent from './EnhanceComponent' ...</span><span id="6147" class="nu md it np b gy oc nw l nx ny">export default <strong class="np iu">EnhanceComponent(ClickCounter);</strong></span></pre><p id="3ac7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no np b">EnhanceComponent</code>环绕<code class="fe nm nn no np b">ClickCounter</code>，为其提供道具的通路。当将<code class="fe nm nn no np b">{this.props.name}</code>应用到<code class="fe nm nn no np b">ClickCounter</code>的渲染时，这在浏览器中反映出来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/2b45c364182fb9ddda191f8ed2f519e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:398/format:webp/1*4AMnCxx2rzbeUuyUb7Fw7A.png"/></div></figure><p id="f414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no np b">ClickCounter</code>成功接收浏览器中显示为<code class="fe nm nn no np b">Milk and Sugar</code>的道具。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="956b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">即席实现和重构</h1><p id="e7ef" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">如下面的代码示例所示，为了最终实现特设模式，<code class="fe nm nn no np b">ClickCounter</code>和<code class="fe nm nn no np b">HoverCounter</code>组件都重构了状态，并重新连接它们的呈现以接收特设状态逻辑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ClickCounter.jsx已重构</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">HoverCounter.jsx已重构</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1a7b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="f634" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated"><code class="fe nm nn no np b">HoverCounter</code>和<code class="fe nm nn no np b">ClickCounter</code>组件都根据各自的功能目的减少和缩小了它们的代码，遵循特设模式实现。</p><p id="7a0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">逻辑和状态增量现在由封装两个组件的特设<code class="fe nm nn no np b">EnhanceComponent</code>处理。</p><p id="4f8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于在咖啡杯类比中，如果咖啡馆将不同类型的咖啡添加到他们的菜单中，牛奶和糖将保留在桌子上，并且将在需要时被实现，从而使得咖啡杯纯净，并且系统结构可扩展用于增长。</p><p id="3845" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在应用程序示例中，如果要用计数器逻辑用例添加更多的组件，由于有了特设模式，就可以处理这些组件，而不必一遍又一遍地重复那个逻辑。</p><p id="b13d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">逻辑在特设中维护，围绕特定目标的任何组件包装，坚持函数式编程纯路线图。</p><p id="1639" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已。感谢检查这个例子和HOCs的解释。如果您有任何问题或意见，请随时在下面留下。</p><p id="ed4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视频演示和完整的源代码示例可以在这篇文章的顶部找到，并且不要忘记查看<a class="ae ky" href="https://reactjs.org/docs/higher-order-components.htm" rel="noopener ugc nofollow" target="_blank"> React文档</a>进行更深入的研究。</p></div></div>    
</body>
</html>