<html>
<head>
<title>Customizing Property Wrappers in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中定制酒店包装</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/customizing-property-wrappers-in-swift-abe0952fc504?source=collection_archive---------12-----------------------#2022-02-14">https://betterprogramming.pub/customizing-property-wrappers-in-swift-abe0952fc504?source=collection_archive---------12-----------------------#2022-02-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e406" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第一次看NotificationCenterPublisher属性包装器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4ff232bcd143dd9e4f42c60e8cd5b3a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*thfVnc0jX3T0FrJB"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">伊利亚·巴甫洛夫在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8ca2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顾名思义，属性包装器是一个包装通常的属性以提供附加功能的层。这一层充当你和实际财产之间的中间人。因此，无论何时想要设置或获取属性值，都必须通过属性包装器进行通信。现在，你可能会问“为什么要在这种互动中引入一个中间人？”。继续读下去，你会找到你的答案。</p><p id="50c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您是Twitter应用程序的开发人员，您想在一个属性中存储一条新的tweet。你可能知道，一条推文被限制在280个字符以内。理想情况下，您已经有了一个限制用户输入超过280个字符的UI。</p><p id="ce99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，这并不意味着我们必须将这种字符检查仅限于UI。如果用户界面坏了，突然有人在Twitter上发布文章怎么办？你不想被解雇，对吗？让我们看看属性包装器如何保存您的工作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例实现</p></figure><p id="c837" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们使用一个名为<code class="fe lu lv lw lx b">tweet</code>的属性来存储实际的tweet。如果你注意到，就在我们的变量声明之前，我们有<code class="fe lu lv lw lx b">@RestrictedCharacterCount(maxCharacterCount: 33)</code>。那是我们的属性包装器。</p><p id="3009" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用属性包装器，从<code class="fe lu lv lw lx b">@</code>符号开始，后跟属性包装器名称。我们还传入33作为我们的<code class="fe lu lv lw lx b">maxCharacterCount</code>值，因为这将是我们在这个例子中存储的最大字符数。</p><blockquote class="ly lz ma"><p id="bbe5" class="kw kx mb ky b kz la jr lb lc ld ju le mc lg lh li md lk ll lm me lo lp lq lr ij bi translated">从输出中，您可以观察到，只有我们发布的句子的前33个字符实际上存储在我们的属性中。其余的被忽略了。如果您还记得的话，这是因为我们之前明确地将“maxCharacterCount”设置为33。现在，您可以将这个数字设置为280个字符，并在twitter <em class="iq">上保留您的工作<em class="iq"> </em>。</em></p><p id="ff2d" class="kw kx mb ky b kz la jr lb lc ld ju le mc lg lh li md lk ll lm me lo lp lq lr ij bi translated">您可能还注意到，我们在属性名前使用$(美元)符号来访问属性包装器对象。这就是所谓的投影值。</p></blockquote><p id="1000" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们庆祝胜利之前，让我们先了解一下这是如何工作的。</p><p id="62e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要编写属性包装，</p><ol class=""><li id="c001" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr mk ml mm mn bi translated">您可以使用结构或类</li><li id="0428" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr mk ml mm mn bi translated">用<code class="fe lu lv lw lx b">@propertyWrapper</code>语法注释你的对象。</li><li id="5878" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr mk ml mm mn bi translated">声明一个名为<code class="fe lu lv lw lx b">wrappedValue</code>的属性。它必须是非静态的。这是我们将要包装的实际财产。该属性的数据类型由您决定。</li><li id="f991" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr mk ml mm mn bi translated">你可以给你的<code class="fe lu lv lw lx b">wrappedValue</code>，一个默认值，或者让用户提供它。要做到后者，确保将<code class="fe lu lv lw lx b">wrappedValue</code>作为对象初始化器的一部分。</li><li id="7541" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr mk ml mm mn bi translated">除了在初始化器中接收你的<code class="fe lu lv lw lx b">wrappedValue</code>的值之外，你还可以指定你认为属性包装器所需要的其他参数。</li><li id="2321" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr mk ml mm mn bi translated">现在就像一个中间人，每当属性为“set”或“get”时，你都可以按照你的逻辑自由地改变值。您决定的内容将成为存储或返回给用户的最终值。</li><li id="eb1f" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr mk ml mm mn bi translated">当用户在属性名称前加上$(美元符号)时，就可以访问预计值。你作为项目价值的回报完全取决于你。</li><li id="4b31" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr mk ml mm mn bi translated">例如，您的属性包装中可能有一些方法或属性为用户提供额外的功能。若要公开这一点，可以将属性包装本身作为投影值返回。</li></ol><p id="5ed0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在您已经对事情的工作原理有了基本的了解，让我们看看前面的属性包装器<code class="fe lu lv lw lx b">@RestrictedCharacterCount</code>的实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><blockquote class="ly lz ma"><p id="1774" class="kw kx mb ky b kz la jr lb lc ld ju le mc lg lh li md lk ll lm me lo lp lq lr ij bi translated">"兄弟，为什么你要把事情变得复杂，把它变得普通"</p></blockquote><p id="ec3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请耐心听我说几分钟。让我来给你解释一下，你会意识到这有多强大。这是核心思想。</p><blockquote class="ly lz ma"><p id="cde9" class="kw kx mb ky b kz la jr lb lc ld ju le mc lg lh li md lk ll lm me lo lp lq lr ij bi translated">创建一个属性包装器，将最大字符数作为参数，当存储在属性中的数据的字符数超过最大字符数时，从末尾截断多余的字符。属性包装还应该兼容多种数据类型，以实现最大的灵活性</p></blockquote><p id="6af7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们分解我们的属性包装器，</p><ol class=""><li id="67a5" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr mk ml mm mn bi translated">为了使它兼容广泛的数据类型，我们将我们的<code class="fe lu lv lw lx b">wrappedValue</code>的数据类型通用化，并将其命名为<strong class="ky ir"> T </strong>。</li><li id="c850" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr mk ml mm mn bi translated">我们还确保T是符合<code class="fe lu lv lw lx b">LosslessStringConvertible</code> <em class="mb"> </em>协议的东西。这允许T ←→ String之间的自由转换。</li><li id="cd2e" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr mk ml mm mn bi translated">现在，我们将数据类型T的<code class="fe lu lv lw lx b">wrappedValue</code>转换为String来计算字符数。如果我们超过了<code class="fe lu lv lw lx b">maxCharacterCount</code>，我们会在末尾删除多余的字符。最后，我们将这个修整过的字符串转换回它的原始数据类型T，并将其存储在<code class="fe lu lv lw lx b">wrappedValue</code>变量中。</li><li id="4715" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr mk ml mm mn bi translated">因此，每当用户为我们的属性设置一个值时，我们检查数据，计算字符数，修剪任何多余的字符，然后最终存储它。</li></ol><p id="39b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是一些例子，说明为什么使它通用化会使它真正强大:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="6043" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我再举几个例子来巩固你的理解。</p><p id="f247" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lu lv lw lx b">@RestrictedRange</code>是一个属性包装器，它帮助你将你的属性值限制在一个特定的范围内。每当任何用户试图设置一个不在有效范围内的值时，就会调用闭包来用有效值替换它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="190d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lu lv lw lx b">@NotificationCenterPublisher</code>是一个通用的属性包装器，它使用通知中心发布属性的每个新值。</p><p id="c590" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您必须传递通知名，也可以选择设置一个名为<code class="fe lu lv lw lx b">getUserInfo</code>的闭包，它将允许您在通知发布之前传递<code class="fe lu lv lw lx b">userInfo</code>字典。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><blockquote class="ly lz ma"><p id="3c17" class="kw kx mb ky b kz la jr lb lc ld ju le mc lg lh li md lk ll lm me lo lp lq lr ij bi translated">总之，属性包装器帮助您在每次用户读取或写入属性值时操作属性值。这种访问逻辑一旦以属性包装的形式编写，就可以重用并应用于代码库中的任何属性。</p><p id="3913" class="kw kx mb ky b kz la jr lb lc ld ju le mc lg lh li md lk ll lm me lo lp lq lr ij bi translated">您可以有选择地将一个<code class="fe lu lv lw lx b">projectedValue</code>添加到您的属性包装器中，然后可以通过奇特的$(美元)语法访问它。这对于在属性包装中公开任何附加功能非常有用。</p></blockquote><p id="c7ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">属性包装器是SwiftUI世界的重要组成部分，理解它们至关重要。</p></div></div>    
</body>
</html>