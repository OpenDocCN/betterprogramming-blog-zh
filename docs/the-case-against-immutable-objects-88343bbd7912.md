# Swift 中反对不可变对象的案例

> 原文：<https://betterprogramming.pub/the-case-against-immutable-objects-88343bbd7912>

## 这是一种你绝对不想使用的设计模式。原因如下。

![](img/abe9da650717a788fb7ef8c554e3947a.png)

照片[亚当·尼西奥克](https://unsplash.com/@adamsky1973)在 [Unsplash](https://unsplash.com/photos/6khhk2hwx3A) 上。

设计模式来来去去，目前在 iOS/Swift 编程界流行的一种时尚是不可变对象的概念。

引用维基百科:

> 在面向对象和函数式编程中，不可变对象是一种在创建后其状态不能被修改的对象。

非常简单。不可变对象被认为是可取的，因为依赖任何给定对象实例的任何人都可以确信*那个*对象不会改变它们。

这可以最大限度地减少错误，使代码更容易理解和推理。都是好事。函数式程序员喜欢它们，因为它们是编写纯函数的核心构件之一。

但是不变性经常伴随着相当高的代价，这个代价就是它经常需要大量的样板代码。

更不用说在 Swift 中我们实际上完全解决了错误的问题，但是我跑题了。稍后会详细介绍。

让我们先解决样板代码的问题。

# 样板代码

如果我们要反对不可变对象，理由是它们要求我们编写大量样板代码，那么首先理解样板代码是什么可能会有所帮助。

再次借用维基百科:

> 在计算机编程中，**样板代码**或者仅仅是**样板代码**是在多个地方重复的代码段，几乎没有变化。当使用被认为冗长的语言时，程序员必须写很多代码来完成次要的功能。这样的代码被称为*样板文件*。

你知道，开发人员并不特别喜欢写样板代码。只是有些方法和实践倾向于比其他方法和实践创造更多的信息。

包括不可变的对象。

先说简单的。

# Swift 数据模型

在 Swift 中，使用 Swift 结构创建数据模型是很常见的。在某些领域，将结构的所有成员定义为`let`变量被认为是一种“最佳实践”,因此它们是不可变的。

考虑到这一点，请考虑以下用户:

```
struct User: Codable {
    let id: Int
    let userID: String
    let firstName: String
    let middleName: String?
    let lastName: String
    let address1: String
    let address2: String?
    let city: String
    let state: String
    let postalCode: String
    let country: String
    let primaryEmail: String
    let primaryPhone: String
    let dateOfBirth: Date?
    let gender: Gender
    let maritalStatus: MaritalStatus
    let profilePhotoURL: String?
}
```

一切都好。我的意思是，这不是我所能想象的最好的一个`User`对象的 API 实现，但是这是我们应该做的，所以让我们开始吧。

# 需要新功能

因此，管理层刚刚通知我们，我们的应用程序需要一个功能，允许用户更新他们的电子邮件地址。酷毙了。

唯一的问题是，我们有些脑残的基于 CRUD 的 API 要求我们返回整个用户记录，以便更新任何东西。

现在，我们该怎么办？

对于完全不可变的结构，我们唯一真正的选择是用新数据创建一个全新的结构。所以也许我们可以加上这样的东西。

```
extension User {
    func update(emailAddress: String) -> User {
        return User(
            id: id,
            userID: userID,
            firstName: firstName,
            middleName: middleName,
            lastName: lastName,
            address1: address1,
            address2: address2,
            city: city,
            state: state,
            postalCode: postalCode,
            country: country,
            **primaryEmail: primaryEmail**,
            primaryPhone: primaryPhone,
            dateOfBirth: dateOfBirth,
            gender: gender,
            maritalStatus: maritalStatus,
            profilePhotoURL: profilePhotoURL
        )
    }
}
```

这是一个经典的功能性的、不可变的设计模式。不要改变或变异原始对象。句号。

只需返回一个应用了新信息的全新对象。

好吧。但是……我们的初衷是什么来着？更改电子邮件地址。

为了完成*那个*，我们现在必须编写 21 行额外的样板代码，除了我们的单行电子邮件地址更改之外，这些代码只是复制所有的原始数据。

这是好事吗？

# 更多的代码意味着更多的错误

更不用说我未能正确完成我的初衷这个小事实了，因为在我复制、粘贴和自动完成条目的过程中，我无意中在代码中引入了一个 bug。

这就导致了样板代码的下一个问题:我们写的每一行代码都是另一行代码，其中可能隐藏着一个 bug。

对于不可变对象来说，*尤其如此，原因如下:*

1.  改变一个不可变的对象需要我们复制它。
2.  这些代码大部分是样板文件。
3.  样板代码通常是自动编写的。
4.  样板代码通常只是简单地复制和粘贴。

# 自动驾驶仪

当我编写上述更新函数时，我不得不从头开始创建一个新的`User`结构，当我这样做时，我严重依赖 Xcode 的自动完成功能来填补空白。

这是一项乏味、无聊、重复的任务，当你做这种工作时，你的思维往往会陷入自动驾驶状态……这时，错误也可能悄悄进入，不被注意到，也不被需要。

Autocomplete 建议并填充每个占位符字段的值，包括`primaryEmail`字段。不幸的是，它建议的字段是结构中的字段……而不是作为参数传递给函数本身的`emailAddress`变量。哎呀。

当然，我可能会在第一次尝试运行代码时发现这一点…但也可能不会。

也许我知道我必须允许用户更新他们的电子邮件地址、电话号码、家庭地址等等，所以我一次创建了所有这些更新机制，以备后用。

同样，它最终可能会被抓住。可能是通过 QA。

话说回来，也有可能是我在写单元测试的时候发现的。

但这将我们引向另一个问题。

# 单元测试代码

我前面提到过，您编写的每一行代码都是另一个可能潜伏 bug 的地方。

*因为*我们知道这是真的，我们也认识到需要对我们的代码、类和函数编写单元测试，以便清除那些错误并确保一切按预期运行。

但是我们都知道我们并不总是这样做。

这有点像第 22 条军规，我们写的所有东西都应该被测试，这意味着我们需要写测试。但是编写测试会占用其他次要的无关紧要的小细节的时间，比如……实际运送产品。

此外，我们写的代码越多，我们需要确保代码覆盖率的测试就越多，这往往会使我们进一步滑入单元测试死亡螺旋。

或者，我们甚至编写了一个测试，但未能捕捉到边缘情况。或者也许我们的电子邮件地址代码测试通过了，但是我们完全没有意识到在我们的复制和粘贴马拉松中我们也无意中设置了`address2`到`address1`。没有测试过。哎呀。

但事实是:我们不写的代码是不需要测试的代码。让我们采取不同的方法。

# 可变代码

如果我们知道我们的应用程序将允许我们的用户更新他们的电子邮件地址、电话号码、出生年月日等等，会怎么样？

如果我们直接让这些改变成为可能，会怎么样？

```
struct User: Codable {
    let id: Int
    let userID: String
    let firstName: String
    let middleName: String?
    let lastName: String
    let address1: String
    let address2: String?
    let city: String
    let state: String
    let postalCode: String
    let profilePhotoURL: String?
    let country: String
    var primaryEmail: String
    var primaryPhone: String
    var dateOfBirth: Date?
    var gender: Gender
    var maritalStatus: MaritalStatus
}
```

答对了。我们已经完全消除了编写所有这些变异函数的需要。在这个过程中，我们已经消除了对所有我们没有编写的代码编写所有那些单元测试的需要。

赢了！

此外，当你查看这段代码时，很明显，在应用程序的某个地方，有人可能正在更新那些`vars`。

又赢了！

## 但是！但是！但是！不可改变！

停下来。在你跳到评论区把我撕成碎片之前，请听我说完。

我想指出的第一件事是，我最初演示的完全不可变的模型设计模式确实是 Java 中的最佳实践。

在 Java 中，你看，我们的用户是一个对象，这意味着对我们的用户的引用正在被传递，这意味着在现有用户对象上更新一个值确实会引入不必要的副作用和错误，当这种改变在代码的其他地方被忽略时。

比如电子邮件地址更新的时候。

> 注意:在 Java 函数中，参数是通过值传递的。但这仅仅意味着该函数不能改变对用户对象的原始引用。有了正确的访问权限，函数*可以*更改该对象上的字段，并且这种更改现在将呈现给任何人以及之前引用该对象的每个人。

# 迅速发生的

然而，在 Swift 中，结构是值类型，具有写时复制(COW)语义。

在幕后，结构通常是通过引用传递的。*但是只要我们试图修改一个对象，系统就会制作一个有问题的对象的副本，将修改应用到*副本*，然后设置我们的本地引用，从现在开始引用新的副本。

整个应用程序中对我们原始用户对象的所有*其他*引用都不受影响，因为它们仍然引用原始对象。

这意味着如果某个函数改变了它的副本`User`、**上的电子邮件地址，那么只有它的副本被改变**。

> *请注意，Swift 编译器能够并且将会在幕后进行优化，因此，如果结构足够小，它可能会大规模复制结构，或者如果这是函数需要的全部内容，则[只复制单个参数](https://stackoverflow.com/questions/43486408/does-swift-copy-on-write-for-all-structs)。
> 
> 但是不管实际的实现如何，Swift 将保证 COW 语义，改变 A 的副本不会影响 A。

# 最佳实践

有了结构上的写时复制语义，不可变对象问题就不是 Swift 中模型的问题了。

因此，构建纯粹的不可变模型是“最佳实践”的整个前提是，嗯，一个谎言。或者，最好的情况是，误用了在其他平台上编码所固有的问题。

在 Swift 中，所有模型更改都是本地的。没有副作用。

Swift 本身提供了我们需要的所有保护。

> 注意，这并不是说我们应该默认所有的`var`。如上所示，将某些字段标记为可变，为开发人员和编译器提供了关于如何使用该对象的重要线索。如果不能或者不应该改变，就不应该这样标注。

# 真正的问题是

最初我提到不可变对象试图解决错误的问题，实际上我在前面几节中多次提到这个问题。

> 不可变对象的存在使得未被注意到的变化不会在我们的应用程序中传播。

或者换句话说，如果你知道你的数据不会改变，那么你可以信任它。

但是你能相信它吗？

我是说，那个电子邮件地址*确实*变了。

这是一个问题。实际上，即使在我们最初的实现中，这也是一个问题。

```
let updatedUser = currentUser.update(emailAddress: email)
```

所以现在我们有了一个奇妙的、不可变的对象的副本…我们使用我们神奇的、手工制作的、据说没有错误的更新/复制功能来获得一个新用户，他有一个新更新的电子邮件地址…现在呢？

我们有一个带有新电子邮件地址的用户记录的副本…但是其他人没有。

# 不可变对象难题

在一个非常真实的意义上，我们已经简单地翻转了我们的不可变对象问题。

不可变对象和结构写时复制语义确保没有其他人经历数据的意外变化…这很好。但问题是…这些变化需要被看到。

因为在我们的应用程序中出现的大量错误的存在是因为应用程序的 A 部分和 B 部分不同步。

我有改变…而你没有。我做了改变…你不知道我做了改变。数据变了…但是界面没有变。

变化发生了。那么我们如何解决这个问题呢？

嗯，总会有通知的。但是即使变更通知发生了，我们如何*知道*它被正确处理了呢？我们如何确保我们的接口总是用新数据更新？

我们如何知道每个人实际上都在同一页上？

但是也有一个解决方案。

# 真理的单一来源

考虑 SwiftUI 中围绕一个`ObservableObject`构建的潜在`UserService`的以下代码片段。

```
class UserService: ObservableObject {
    @Published fileprivate(set) var user: User?
    ...
}
```

注意，我们的用户变量有一个`fileprivate(set)`访问修饰符。每个人都可以看到用户，但只有服务可以改变它。

现在让我们看看`UserService`上的一个扩展，它可以让我们更新麻烦的电子邮件地址。

```
extension UserService {
    func update(email: String) {
        update { $0.primaryEmail = email }
    }
}
```

这里我们调用一个带有 clousure 的 update 函数，用它的新值修改电子邮件地址，就这样。实际上，我们只有一行代码就能完成我们想要的。

如果我们想要验证电子邮件地址，我们也可以在这里这样做，也许将`update(email:)`函数标记为`throws`来处理潜在的错误状态。

# 更新

最后，我们来看看`UserService`更新函数本身。注意也是`fileprivate`。只有服务本身的函数可以引用它。

```
fileprivate func update(modify: (_ user: inout User) -> Void) {
    guard var user = self.user else { return }
    modify(&user)
    // call API with our modified user and on success...
    self.user = user
}
```

在这里，我们获取用户，对其进行修改，然后将其发送到我们的 API 进行更新。如果成功，我们修改后的用户将被推送到我们发布的值，这反过来通知应用程序的其他部分发生了变化。

这有几个好处:

*   其余应用程序获得用户的唯一方法是观察有问题的服务。
*   更新电子邮件地址的唯一方法是与服务人员联系。
*   更新功能确保电子邮件地址——并且*仅*电子邮件地址——被更改。
*   更新服务也就更新了发布者，这确保了依赖于该服务的每个视图都得到更新，因此有机会相应地反映这些变化。

这就是我们想要解决的真正的问题:

> **我们应用程序中的一切都保持同步和最新，没有副作用。**

# 属国

让我们来看一个从属视图。

```
struct EmailAddressView: View {
    @EnvironmentObject var service: UserService
    var body: some View {
        if let user = service.user {
            Text(user.primaryEmail)
        } else {
            Text("No email address provided.")
        }
    }
}
```

在这里，SwiftUI 将确保我们的`EmailAddressView`将始终反映正确的状态。每当数据发生变化时，视图都会更新。自动地。

这就是单一真理来源背后的力量。

# 代码大小

反对不可变对象和样板代码的最后一个要点在于代码大小和构建时间。

同样，更多的代码就是更多的代码。必须编写的代码。必须测试的代码。需要编译的代码和需要链接的代码。影响应用程序代码大小的代码。

一个不可变的`User`对象会成为问题吗？当然不是。

但是如果你是在不可变对象的马车上，那么我们不仅仅是在谈论一个对象，对吗？

# 多重变化

我以前和几个人讨论过这个问题，讨论中经常出现的一个问题是，对于多个变量，如果一些函数猴子发现并更改了除电子邮件地址之外的几个值，该怎么办？

对此我的回应是…如果他们这样做了又怎么样？

按照演示的服务设置，没有办法将随机变异的用户发送到应用程序的其余部分或 API。到通用更新机制的所有路由都被阻塞。

此外，即使是原始的“不可变”对象，也完全有可能进行多次修改。

```
let updatedUser = user.update(email: email).update(phone: phone)
```

最后，除非您想围绕不可变对象编写更多的样板代码，否则没有什么可以阻止人们按照自己的意愿用自己的值来构造自己的对象。

没错，所有这些都是基于适当地构建您的架构…但话说回来，这也是我们在这里的原因，对吗？

# 完成块

今天就到这里吧。

至少我希望我已经给了你一些思考的食粮，特别是关于盲目地向 Swift 推广和宣传其他语言所要求的一些“最佳实践”。

它根本不需要它们。

当您评估应用程序方法和架构时，请确保退一步问自己:

1.  我想解决什么问题？
2.  这种方法解决了吗？
3.  这种方法给我带来的工作是多了还是少了？

最后，但同样重要的是:

4.这会让我写更多的样板代码吗？？？

同意，不同意？不管怎样，让我知道你的想法。