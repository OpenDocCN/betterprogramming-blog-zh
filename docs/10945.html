<html>
<head>
<title>Golang: How To Implement Concurrency With Goroutines and Channels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang:如何用Goroutines和通道实现并发性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/golang-how-to-implement-concurrency-with-goroutines-channels-2b78b8077984?source=collection_archive---------0-----------------------#2022-02-06">https://betterprogramming.pub/golang-how-to-implement-concurrency-with-goroutines-channels-2b78b8077984?source=collection_archive---------0-----------------------#2022-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3650" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Go中的并发要简单得多</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4c872173fb18f56273d21fbcfab29a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mWUzwICKzj6a2lvyRYV3rg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">正如我们所看到的，goroutines是类固醇并发。</p></figure><p id="328f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一年前，我开始在一个团队中工作，为Mercado Libre的船运区域开发和维护一个核心服务，这个服务是用go构建的。我第一次使用围棋的经历(在得到这个机会之前)并不愉快。在Spring Boot，一切都是基于注释的，手动定义处理程序似乎是昨日黄花。我错了。</p><p id="7408" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">围棋是一门奇妙的语言。它被编译成二进制(如果我可以补充的话，用最少的编译时间)，令人难以置信的高性能(对于一种垃圾收集语言来说，相当接近C ),然而，与大多数流行的语言(25个关键字)相比，它真的很简单。它的语法类似于C语言，有一些令人困惑的元素，但是一旦你习惯了就会非常喜欢(多返回值、裸返回、隐式数据类型、错误检查等)。</p><p id="2488" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是以我的拙见(也是本文的主题)，Go最好的特性是Goroutines和Channels。</p><p id="1e05" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> Goroutines </strong>和<strong class="kx ir"> Channels </strong>是一个轻量级的内置特性，用于管理同时执行的几个函数之间的并发和通信。这样，可以编写在主程序之外执行的代码，这样就不会中断主程序并返回一个或多个值(如果只是一个独立的操作，则不返回任何值)。Go对此有两个关键词:<code class="fe lr ls lt lu b">go</code>和<code class="fe lr ls lt lu b">chan</code>。</p><p id="17ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">实现非常简单。首先，定义一个想要并发执行的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="585f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如你所见，这只是一个普通的函数，没什么特别的。现在我们用关键字<code class="fe lr ls lt lu b">go</code>将它作为一个goroutine执行:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="80ce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这为我们提供了以下控制台输出:</p><pre class="kg kh ki kj gt lx lu ly lz aw ma bi"><span id="22df" class="mb mc iq lu b gy md me l mf mg">We are executing a goroutine<br/>Done!<br/>9<br/>Process finished with the exit code 0</span></pre><p id="e285" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完成后，我们现在有一个并发执行的代码。如你所见，主程序创建了一个新的goroutine来执行<code class="fe lr ls lt lu b">timesThree</code>功能，并继续下一条指令。因此<code class="fe lr ls lt lu b">fmt.Println("Done!")</code>在goroutine之前执行。</p><p id="07b2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是如果我们需要从那个函数返回一些值来继续我们的主流程，会发生什么呢？这就是渠道拯救世界的地方。</p><h1 id="c457" class="mh mc iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">频道</h1><p id="5284" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">正如它们的名字告诉我们的那样，就像我们的数据在goroutines之间的双行道。我们必须用函数<code class="fe lr ls lt lu b">make</code>、关键字<code class="fe lr ls lt lu b">chan</code>和括号之间的数据类型来初始化它。</p><pre class="kg kh ki kj gt lx lu ly lz aw ma bi"><span id="f58e" class="mb mc iq lu b gy md me l mf mg">ch := make(chan dataType)</span></pre><p id="ac0f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设我们需要操作的结果。然后我们需要将通道作为参数传递给goroutine函数，以便它返回带有字符<strong class="kx ir"> &lt; - </strong>的结果来赋值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="1573" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我们得到的控制台输出:</p><pre class="kg kh ki kj gt lx lu ly lz aw ma bi"><span id="13e7" class="mb mc iq lu b gy md me l mf mg">We are executing a goroutine<br/>9<br/>The result is: 9<br/>Process finished with the exit code 0</span></pre><p id="9d00" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦主程序执行了goroutine，它在继续之前会等待通道获取一些数据，因此在go routine返回结果后会执行<code class="fe lr ls lt lu b">fmt.Println("The result is: %v", result)</code>。这并不意味着主程序将等待完整的goroutine执行，直到数据被提供给通道。</p><p id="c5f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，如果我们需要goroutine返回多个值呢？这就是为什么我们有缓冲通道。</p><h1 id="7f5b" class="mh mc iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">缓冲通道</h1><p id="2802" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">让我们让我们的<code class="fe lr ls lt lu b">timesThree</code>函数接收一个数字数组，并对它进行迭代，将每个元素乘以3</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="9a76" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们运行它，看看我们得到了什么:</p><pre class="kg kh ki kj gt lx lu ly lz aw ma bi"><span id="794c" class="mb mc iq lu b gy md me l mf mg">We are executing a goroutine<br/>The result is: 6<br/>Process finished with the exit code 0</span></pre><p id="6ee4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为什么主程序不打印所有3个值？因为通道只能容纳一个值。我们可以通过向<code class="fe lr ls lt lu b">make</code>函数传递第二个参数来分配通道容量，从而实现一个缓冲通道，该参数包含它在被读取之前可以获得的元素数量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="6b3b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这样我们就可以得到<code class="fe lr ls lt lu b">timesThree</code>函数返回的所有值。</p><pre class="kg kh ki kj gt lx lu ly lz aw ma bi"><span id="3c88" class="mb mc iq lu b gy md me l mf mg">We are executing a goroutine<br/>Result: 6 <br/>Result: 9 <br/>Result: 12</span><span id="3995" class="mb mc iq lu b gy nd me l mf mg">Process finished with the exit code 0</span></pre><h1 id="0e84" class="mh mc iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">作为goroutines的匿名函数</h1><p id="fd6c" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">另一个很棒的特性是，如果我们不重用匿名函数，它可以作为一个goroutine来执行。注意，我们在关键字<code class="fe lr ls lt lu b">go</code>后声明函数，并在最后一个花括号后的圆括号中传递参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="ed6e" class="mh mc iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">goroutines之间的通道</h1><p id="126b" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">通道不仅用于goroutine和主程序之间的交互，它们还提供了不同goroutine之间的通信方式。例如，让我们创建一个函数，它将从<code class="fe lr ls lt lu b">timesThree</code>返回的每个结果中减去3，但前提是它是偶数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="81b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">控制台输出:</p><pre class="kg kh ki kj gt lx lu ly lz aw ma bi"><span id="63d0" class="mb mc iq lu b gy md me l mf mg">We are executing a goroutine<br/>The functions continues after returning the result<br/>The functions continues after returning the result<br/>Result: 3 <br/>Result: 9 <br/>Result: 9</span><span id="633a" class="mb mc iq lu b gy nd me l mf mg">Process finished with the exit code 0</span></pre><p id="a234" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">即使在这种情况下，没有必要让<code class="fe lr ls lt lu b">minusThree</code>表现得像一个goroutine，并通过通道返回结果，它也说明了go routine之间的交互是如何工作的。当您在一个需要执行的解决方案中有两个不同的函数，并且其中一个函数的某些条件会影响另一个函数的结果时，这一点特别有用。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="048d" class="mh mc iq bd mi mj nl ml mm mn nm mp mq jw nn jx ms jz no ka mu kc np kd mw mx bi translated">范围和关闭</h1><p id="ae6d" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">这些特性使我们能够从goroutine接收连续的元素，直到它关闭通道。有了这条指令，<code class="fe lr ls lt lu b">for i := range ch</code>我们就可以在goroutine的结果发送后立即对其进行迭代。一旦发送完数据，goroutine应使用函数<code class="fe lr ls lt lu b">close</code>关闭通道。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="29b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果goroutine在发送完数据后没有关闭通道，程序将崩溃，并出现以下错误:</p><pre class="kg kh ki kj gt lx lu ly lz aw ma bi"><span id="3295" class="mb mc iq lu b gy md me l mf mg">fatal error: all goroutines are asleep - deadlock!</span></pre><p id="1981" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">发生这种情况是因为主程序试图从通道接收一个值，但是没有一个活动的goroutine能够发送它。</p><p id="594b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我之前没有提到过<code class="fe lr ls lt lu b">close</code>函数，因为正如《Go编程语言》一书中所说:</p><blockquote class="nq nr ns"><p id="c559" class="kv kw nt kx b ky kz jr la lb lc ju ld nu lf lg lh nv lj lk ll nw ln lo lp lq ij bi translated">当你看完一个频道时，你不必把它都关掉。<strong class="kx ir">只有在重要的时候才需要关闭一个通道，告诉接收程序所有数据已经发送。被垃圾收集器确定为不可达的通道将回收其资源，不管它是否关闭。</strong></p></blockquote></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="e108" class="mh mc iq bd mi mj nl ml mm mn nm mp mq jw nn jx ms jz no ka mu kc np kd mw mx bi translated">挑选</h1><p id="c38a" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">如何才能同时从多个通道读取？作为一种同时等待多个通道的方式，防止一个通道阻塞另一个通道。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="c945" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们查看控制台输出，我们可以看到主程序同时从两个goroutines接收数据。</p><pre class="kg kh ki kj gt lx lu ly lz aw ma bi"><span id="b7cb" class="mb mc iq lu b gy md me l mf mg">We are executing a goroutine<br/>Result minusThree: -1 <br/>Result timesThree: 6 <br/>Result minusThree: 0 <br/>Result timesThree: 9 <br/>Result timesThree: 12 <br/>Result timesThree: 15 <br/>Result minusThree: 1 <br/>Result timesThree: 18 <br/>Result minusThree: 2 <br/>Result minusThree: 3</span><span id="72bd" class="mb mc iq lu b gy nd me l mf mg">Process finished with the exit code 0</span></pre><p id="aa59" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们想在每次迭代中执行其他的东西，没有来自任何通道的数据，我们可以添加一个<strong class="kx ir"> default </strong> case(就像在switch语句中一样)。</p><h1 id="6014" class="mh mc iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">互斥</strong></h1><p id="d761" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">使用并发时可能出现的一个问题是当两个<code class="fe lr ls lt lu b">gshare</code>相同的资源不应该被多个goroutines同时访问时。</p><p id="163e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在并发中，修改共享资源的代码块被称为临界区<em class="nt">。</em>让我们举例说明它在控制台上打印的内容。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><pre class="kg kh ki kj gt lx lu ly lz aw ma bi"><span id="22d9" class="mb mc iq lu b gy md me l mf mg">We are executing a goroutine<br/>27<br/>81<br/>3<br/>9<br/>243<br/>6561<br/>729<br/>19683<br/>59049<br/>2187</span><span id="95f6" class="mb mc iq lu b gy nd me l mf mg">Process finished with the exit code 0</span></pre><p id="3ba6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为goroutines同时访问和重新分配相同的内存空间，所以我们会得到有问题的结果。在这种情况下，<code class="fe lr ls lt lu b">n *= 3</code>将成为<em class="nt">关键部分</em>。</p><p id="6e63" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过使用<code class="fe lr ls lt lu b">sync.Mutex</code>实现<strong class="kx ir">互斥</strong>来锁定访问变量的代码块，从而轻松解决这个问题。这可以防止多个goroutine同时访问<code class="fe lr ls lt lu b">Lock()</code>和<code class="fe lr ls lt lu b">Unlock()</code>函数之间的指令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="ae42" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们得到3的幂作为输出:</p><pre class="kg kh ki kj gt lx lu ly lz aw ma bi"><span id="5271" class="mb mc iq lu b gy md me l mf mg">We are executing a goroutine<br/>3<br/>9<br/>27<br/>81<br/>243<br/>729<br/>2187<br/>6561<br/>19683<br/>59049</span><span id="6f90" class="mb mc iq lu b gy nd me l mf mg">Process finished with the exit code 0</span></pre><h1 id="0cbb" class="mh mc iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">结论</strong></h1><p id="bbc8" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">Goroutines是一个令人惊叹的轻量级特性，它使得并发性非常容易实现，这也是Go的采用在最近几年没有停止增长的原因之一(也是为什么最近我如此喜欢它)。</p><p id="2c1c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">非常感谢你的阅读！</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="76ff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请务必关注我，以免错过我接下来的报道！</p></div></div>    
</body>
</html>