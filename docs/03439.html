<html>
<head>
<title>Everyone Can Build a Custom Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个人都可以建立一个自定义挂钩</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/everyone-can-build-a-custom-hook-e0f1c6802ffe?source=collection_archive---------12-----------------------#2020-02-10">https://betterprogramming.pub/everyone-can-build-a-custom-hook-e0f1c6802ffe?source=collection_archive---------12-----------------------#2020-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f281" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">React钩子只是函数，它们比你想象的要简单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e59d8b35249bd38818f724af4936eed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GvDNk85nkfcm--Kv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@alexacea?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alexandru Acea </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="e0f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/reactjs/rfcs/pull/68" rel="noopener ugc nofollow" target="_blank"> React钩子</a>是React 16.8中新增加的。此更新为开发人员提供了在函数组件中使用状态和其他React特性的能力。内置挂钩——如<code class="fe lv lw lx ly b">useState</code>、<code class="fe lv lw lx ly b">useEffect</code>等。—已在各种反应应用中广泛采用。这是向函数式编程的巨大飞跃。</p><p id="4a8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当钩子被引入时，它看起来有点可怕。文档本身有八章长，这个令人敬畏的React Hooks Github提供了关于这个主题的大量信息。你有机会通读它了吗？</p><p id="348d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最初被这么大的阅读量吓到了。然而，在使用了一些内置的挂钩后，我真的惊讶于它们的简单和干净。然后，我发现强大之处不仅在于内置挂钩，还在于定制挂钩的有效性。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="da11" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">单行自定义挂钩</h1><p id="3546" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">什么是自定义挂钩？它是一个JavaScript函数，可以调用其他钩子，其名称以“use”开头。</p><p id="58f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的第一个定制挂钩:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8801" class="nh mh it ly b gy ni nj l nk nl">const useMyName = initialName =&gt; `My name is ${initialName}.`;</span></pre><p id="5cf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没错，就是一行代码。</p><p id="2483" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个自定义钩子返回一个字符串。使用以下示例调用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ce8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码打印出一条消息:<code class="fe lv lw lx ly b">"My name is Larry."</code></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="851b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用方法返回对象的自定义挂钩</h1><p id="cea9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">自定义钩子是一个特殊的函数。它可能会调用其他钩子，典型的有<code class="fe lv lw lx ly b">useState</code>和<code class="fe lv lw lx ly b">useEffect</code>，以及其他内置钩子和自定义钩子。所有挂钩都遵循一些限制:</p><ol class=""><li id="54f2" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">钩子名必须以“use”开头。</li><li id="b5d0" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">必须从函数组件或另一个钩子调用钩子。</li><li id="fd11" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">只调用顶层的钩子。不要在循环、条件或嵌套函数中调用钩子。</li></ol><p id="8009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们编写了一个返回对象的钩子。它仍然像以前一样接受初始名称，但是它返回一个方法来设置一个新名称以及消息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="05c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不知何故，这段代码行不通。该消息不显示在屏幕上，第13行无限期地在开发人员控制台上打印出<code class="fe lv lw lx ly b">"My name is Larry."</code>。</p><p id="b329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发生了什么事？</p><p id="0d42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React的<a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank"> Hooks API参考</a>页面明确指出:</p><blockquote class="oc"><p id="4acd" class="od oe it bd of og oh oi oj ok ol lu dk translated">函数组件的主体内部不允许出现突变、订阅、定时器、日志和其他副作用(称为React的<em class="om">渲染阶段</em>)。这样做将导致UI中令人困惑的错误和不一致。</p></blockquote><p id="c522" class="pw-post-body-paragraph kz la it lb b lc on ju le lf oo jx lh li op lk ll lm oq lo lp lq or ls lt lu im bi translated">在这种情况下，<code class="fe lv lw lx ly b">myHook.setName(‘Larry’)</code>是一个突变。将它放在<code class="fe lv lw lx ly b">App</code>的主体中会导致更改不会反映在UI上。此外，<code class="fe lv lw lx ly b">setName</code>是一个状态变化，它触发一个重新渲染周期再次调用<code class="fe lv lw lx ly b">setName</code>。这种情况不断重复，这种连锁反应会无限循环下去。</p><p id="d7d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要把<code class="fe lv lw lx ly b">setName</code>放在<code class="fe lv lw lx ly b">useEffect</code>里。那么状态变化将反映在UI上。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5965" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们传递一个空数组(<code class="fe lv lw lx ly b">[]</code>)作为第二个参数来运行一次效果。有趣的是，如果没有那个，我们可以再次看到无限的<code class="fe lv lw lx ly b">console.log</code>循环。默认情况下，<code class="fe lv lw lx ly b">useEffect</code>在第一次渲染和每次更新后都运行。<code class="fe lv lw lx ly b">setName</code>是一个状态变化，导致重新渲染。然后再次调用<code class="fe lv lw lx ly b">useEffect</code>。这导致了无休止的重新渲染。</p><p id="2f3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<code class="fe lv lw lx ly b">useEffect</code>还有一个有趣的事实。第15行打印出来:<code class="fe lv lw lx ly b">“My name is undefined.”</code>为什么是<code class="fe lv lw lx ly b">undefined</code>而不是<code class="fe lv lw lx ly b">Larry</code>？那是因为<code class="fe lv lw lx ly b">setName</code>可能不会马上发生。</p><p id="67bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以向第16行传递可选的第二个参数(<code class="fe lv lw lx ly b">[myHook.message]</code>)，而不是传递一个空数组。如果<code class="fe lv lw lx ly b">myHook.message</code>在重新渲染之间没有变化，那么React跳过应用效果。使用这种方法，我们会看到两条控制台消息:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="1fd8" class="nh mh it ly b gy ni nj l nk nl">"<!-- -->My name is <!-- -->undefined<!-- -->."<br/>"My name is Larry."</span></pre><p id="994c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解释如下:<code class="fe lv lw lx ly b">setName</code>不会立即发生。它打印出<code class="fe lv lw lx ly b">"My name is undefined."</code>这个状态变化导致重新渲染，调用第二个输出，<code class="fe lv lw lx ly b">"My name is Larry."</code>之后，<code class="fe lv lw lx ly b">myHook.message</code>没有变化。因此，<code class="fe lv lw lx ly b">useEffect</code>将不再被执行。</p><p id="3555" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">写或者用钩子是不是陷阱太多？为了避免这种错误，建议为钩子安装一个专门的ESLint插件:<code class="fe lv lw lx ly b">npm install eslint-plugin-react-hooks --save-dev.</code></p><p id="de8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个ESLint插件需要如下配置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8fc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，<a class="ae ky" href="https://medium.com/better-programming/10-fun-facts-about-create-react-app-eb7124aa3785" rel="noopener">创建React App </a>包含<code class="fe lv lw lx ly b">eslint-plugin-react-hooks</code>。</p><p id="c3b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用<a class="ae ky" href="https://medium.com/better-programming/10-useful-plugins-for-visual-studio-code-6ab62c0b14ee" rel="noopener"> VSCode </a>，ESLint扩展可以在您编辑代码时显示错误或警告。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f93a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">返回带有用户界面的对象的自定义挂钩</h1><p id="a538" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们之前的fancier钩子返回一个两项对象:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="dc8d" class="nh mh it ly b gy ni nj l nk nl">{<br/>  setName: newName =&gt; setCurrentName(newName),<br/>  message: `My name is ${currentName}.`<br/>}</span></pre><p id="5a69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想通过添加一个选项来使它看起来更漂亮一些，使单选按钮名称选择UI看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/78fe4f88590b83ccdd2c1b5921e4bdc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*5m6iafsLbvhEf2U8va4Lfw.png"/></div></div></figure><p id="c17e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6ff8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个钩子返回一个三项对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="fffb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">display</code>值是<a class="ae ky" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank"> JSX </a>，是JavaScript的语法扩展。一般来说，自定义钩子可以返回值、对象、方法、JSX等等。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bd7b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">返回数组的自定义挂钩</h1><p id="8303" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">自定义钩子可以返回任何东西，只要调用方知道如何处理它。</p><p id="2176" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们重写了以前的花哨钩子，使它变得更加花哨。它以类似于<code class="fe lv lw lx ly b">useState</code>的方式返回一个数组。调用者析构方法、消息和UI的数组。因为没有使用该方法，所以不需要在第21行命名它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="97f9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">React挂钩的集合</h1><p id="984c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">钩子已经被广泛采用。每天都有新的定制挂钩出现。</p><p id="0fdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是React钩子的集合:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/f483be75b3390a828300b45080d992e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZyDD7ObUY8ZVH2iDZFeadQ.png"/></div></div></figure><p id="fa53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">钩子打开了一个充满可能性的新世界。你准备好建立一个自定义挂钩了吗？</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="6110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae ky" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p></div></div>    
</body>
</html>