<html>
<head>
<title>7 Things you Should Know Before Using Regular Expressions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中使用正则表达式之前应该知道的7件事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-things-you-should-know-before-using-regular-expressions-in-python-c79305e117d9?source=collection_archive---------6-----------------------#2021-04-29">https://betterprogramming.pub/7-things-you-should-know-before-using-regular-expressions-in-python-c79305e117d9?source=collection_archive---------6-----------------------#2021-04-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0faa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用这个强大的工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/efc5c1609ffd7e651df30e4fbe5b1ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GReYmy076Vrt1GBW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@vincentiu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">文森特·索罗门</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h1 id="f020" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="9d21" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">除了数字，文本是最常见的数据形式。几乎在任何Python项目中，我们都需要处理文本数据。尽管Python在String类中提供了有用的方法，但是一些使用场景超出了这些基本方法所能解决的范围，尤其是在复杂的模式匹配方面。在这些情况下，我们应该考虑使用正则表达式。</p><p id="1db6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正则表达式通常简称为regex或regexp，是定义文本中特定搜索模式的字符序列。应该注意的是，正则表达式可以被认为是一个独立的实体，尽管每种编程语言支持正则表达式的方式有所不同。由于它的相对独立性，好消息是一旦你学会了正则表达式，你就可以用最小的学习曲线在任何其他编程语言中应用这种文本处理技术。</p><p id="1f1f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">事不宜迟，我们开始吧。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="cef5" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">1.使用方式概述</h1><p id="166e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">作为标准库的一部分，<code class="fe ne nf ng nh b">re</code>模块专门提供Python中与正则表达式相关的特性。</p><p id="9ef3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用这个模块有两种常见的方式。</p><p id="9f32" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第一种方式属于Python的面向对象编程方面。本质上，您首先创建一个模式，它是一个Python对象。该模式有一系列您可以使用的方法，例如搜索和替换。考虑这种风格的以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用正则表达式的OOP风格</p></figure><p id="97b2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另一种风格或多或少采用了功能性方法。不是创建一个模式，而是直接调用函数，此时指定模式。这种风格如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用正则表达式的函数风格</p></figure><p id="61ff" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在幕后，Python为我们创建了模式，并调用相应的方法。因此，这个中间步骤强调了这两种风格之间的关键区别，尽管可用的方法和它们的调用签名几乎是相同的。当您使用compile函数创建模式对象时，编译后的模式将被缓存，这样，如果您多次使用该模式，它们会更有效。如果只使用一次，就不需要担心这两种方法的区别。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="b8c6" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">2.原始字符串</h1><p id="ae78" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">正则表达式使用具有特殊含义的特殊字符。例如，我们用<code class="fe ne nf ng nh b">\d</code>表示数字，用<code class="fe ne nf ng nh b">\w</code>表示Unicode单词字符。您会注意到，我们使用反斜杠来表示这些字符有特殊的含义。巧合的是，Python使用反斜杠来表示特殊字符，比如用<code class="fe ne nf ng nh b">\t</code>表示制表符，用<code class="fe ne nf ng nh b">\n</code>表示换行符。同时，反斜杠用于转义一些特殊字符，包括反斜杠本身。例如，如果您想匹配字符串中的<code class="fe ne nf ng nh b">\</code>，您可以指定<code class="fe ne nf ng nh b">\\</code>。</p><p id="b88a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当这两个需求结合在一起时，你最终不得不使用看起来很奇怪的模式。假设我们想在字符串中搜索<code class="fe ne nf ng nh b">\toe</code>。因为<code class="fe ne nf ng nh b">\t</code>在这里是一个文字，而不是文字制表符，所以我们必须使用<code class="fe ne nf ng nh b">\\toe</code>，这样Python字符串就会搜索<code class="fe ne nf ng nh b">\toe</code>。让事情变得复杂的是，在编译正则表达式模式时，必须对两个反斜杠进行转义，这产生了四个反斜杠<code class="fe ne nf ng nh b">\\\\toe</code>来在字符串中搜索<code class="fe ne nf ng nh b">\toe</code>。看看下面的一些相关代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正则表达式中的反斜杠</p></figure><p id="3b3f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意，match方法将在字符串的开头执行搜索。你觉得会配什么？上述代码将生成以下打印结果:</p><pre class="kj kk kl km gt nk nh nl nm aw nn bi"><span id="1cca" class="no la it nh b gy np nq l nr ns">Match '\toe': None<br/>Match '\\toe': &lt;re.Match object; span=(0, 4), match='\\toe'&gt;<br/>Match '\\\toe': None<br/>Match '\\\\toe': None</span></pre><p id="80c0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如您所见，只有<code class="fe ne nf ng nh b">“\\toe”</code>被匹配，因为两个连续的反斜杠被解释为一个文字反斜杠，这使得字符串有效地<code class="fe ne nf ng nh b">“\toe”</code>，匹配正则表达式。</p><p id="9409" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">显然，使用这么多反斜杠会让其他人感到困惑。为了解决这个问题，我们使用原始字符串符号，它要求Python不处理反斜杠。应用这种技术，我们可以更新上面的代码来达到同样的效果。请注意，我们现在使用原始字符串来创建模式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">原始字符串的使用</p></figure><p id="369d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以，你想用原始字符串创建正则表达式是个好主意。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="ce85" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">3.正则表达式的一般语法</h1><p id="be7d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">前两节更具体地针对Python。它们应该相对简单。我猜让很多程序员困惑的是正则表达式本身的语法。如前所述，正则表达式被认为是一种独立的语言，Python主要采用它们的语法。</p><p id="68ed" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">掌握正则表达式的核心语法需要大量的实践——反复试验。但是在我们开始尝试之前，我们需要对重要的类别有一个概述。</p><p id="92ba" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第一类是关于定义搜索字符串的边界，有时称为锚点:</p><pre class="kj kk kl km gt nk nh nl nm aw nn bi"><span id="ba7e" class="no la it nh b gy np nq l nr ns"><strong class="nh iu">#1 Boundary Anchors</strong></span><span id="6b9a" class="no la it nh b gy nt nq l nr ns"><strong class="nh iu">^hi</strong>        starts with hi<br/><strong class="nh iu">hey$</strong>       ends with hey<br/><strong class="nh iu">^hi hey$</strong>   starts and ends with "hi hey" (exact matching)</span></pre><p id="5da5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以下代码片段显示了一些Python示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正则表达式的锚</p></figure><p id="8575" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第二类是关于定义搜索字符串的数量。</p><pre class="kj kk kl km gt nk nh nl nm aw nn bi"><span id="7750" class="no la it nh b gy np nq l nr ns"><strong class="nh iu">#2 Quantifiers</strong></span><span id="527c" class="no la it nh b gy nt nq l nr ns"><strong class="nh iu">hi?</strong>       h followed by zero or one i<br/><strong class="nh iu">hi*</strong>       h followed by zero or more i<br/><strong class="nh iu">hi+</strong>       h followed by one or more i<br/><strong class="nh iu">hi{3}</strong>     h followed by iii<br/><strong class="nh iu">hi{1,3}</strong>   h followed by i, ii, or iii<br/><strong class="nh iu">hi{2,}</strong>    h followed by 2 or more i</span></pre><p id="3386" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面的代码片段向您展示了一些关于量词的Python示例。需要注意的一点是，使用使用<code class="fe ne nf ng nh b">*</code>、<code class="fe ne nf ng nh b">+</code>和<code class="fe ne nf ng nh b">?</code>的正则表达式进行搜索是“贪婪的”，这意味着它将尽可能尝试匹配最长的序列。要修改这种默认行为，您可以在这些量词后面添加后缀<code class="fe ne nf ng nh b">?</code>(即<code class="fe ne nf ng nh b">*?</code>、<code class="fe ne nf ng nh b">+?</code>和<code class="fe ne nf ng nh b">??</code>)。这将采用一种非贪婪的方法来搜索尽可能具有最短长度的匹配序列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正则表达式的量词</p></figure><p id="5be2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第三类是定义一个宽泛的类别或字符集。</p><pre class="kj kk kl km gt nk nh nl nm aw nn bi"><span id="c3c7" class="no la it nh b gy np nq l nr ns"><strong class="nh iu">3. Character Classes/Sets</strong></span><span id="ba2c" class="no la it nh b gy nt nq l nr ns"><strong class="nh iu">\d</strong>       any decimal digit<br/><strong class="nh iu">\D</strong>       any character that is not a decimal digit<br/><strong class="nh iu">\s</strong>       any whitespace, including space, \t, \n, \r, \f, \v<br/><strong class="nh iu">\S</strong>       any character that isn't a whitespace<br/><strong class="nh iu">\w</strong>       any word character, including underscores<br/><strong class="nh iu">\W</strong>       any character that is not a word character<br/><strong class="nh iu">.</strong>        any character except a newline<br/><strong class="nh iu">[]</strong>       a set of characters</span></pre><p id="eec2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们用方括号来定义一组字符。对于这种用法，有几点需要注意:</p><ul class=""><li id="5921" class="nu nv it lt b lu mn lx mo ma nw me nx mi ny mm nz oa ob oc bi translated">该集合可以是单个字符。例如，<code class="fe ne nf ng nh b">[abc]</code>将匹配<code class="fe ne nf ng nh b">“a”</code>、<code class="fe ne nf ng nh b">“b”</code>，或者<code class="fe ne nf ng nh b">“c”</code>、<code class="fe ne nf ng nh b">[3c]</code>将匹配<code class="fe ne nf ng nh b">“3”</code>或<code class="fe ne nf ng nh b">“c”</code>。</li><li id="ea6f" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">该集合可以是一系列字符。例如，<code class="fe ne nf ng nh b">[a-z]</code>将匹配<code class="fe ne nf ng nh b">“a”</code>和<code class="fe ne nf ng nh b">“z”</code>之间的任何字符，<code class="fe ne nf ng nh b">[A-Z]</code>将匹配<code class="fe ne nf ng nh b">“A”</code>和<code class="fe ne nf ng nh b">“Z”</code>之间的任何字符。</li></ul><p id="9b70" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面的代码片段向您展示了一些相关的使用示例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">字符类/正则表达式集</p></figure><p id="fc90" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第四类是关于定义逻辑操作。</p><pre class="kj kk kl km gt nk nh nl nm aw nn bi"><span id="f4f0" class="no la it nh b gy np nq l nr ns"><strong class="nh iu">4. Logical Operators</strong><br/><strong class="nh iu">a|b</strong>       a or b<br/><strong class="nh iu">(abc)  </strong>   abc as a group<br/>[^a]      any character other than a</span></pre><ul class=""><li id="2e06" class="nu nv it lt b lu mn lx mo ma nw me nx mi ny mm nz oa ob oc bi translated">严格地说，分组本身并不是一种逻辑操作。</li><li id="e291" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">可以使用插入符号将字符集创建为补码，插入符号“否定”指定的字符集。</li></ul><p id="1f37" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面显示了一些Python示例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正则表达式的逻辑运算符</p></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="c03e" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">4.编译标志</h1><p id="2795" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">编译正则表达式时，我们可以选择指定标志。这些将修改给定正则表达式的含义。以下是常用标志的列表:</p><pre class="kj kk kl km gt nk nh nl nm aw nn bi"><span id="8631" class="no la it nh b gy np nq l nr ns">re.A (re.ASCII)       match ASCII-only for character sets (e.g., \w)<br/>re.I (re.IGNORECASE)  ignore cases<br/>re.M (re.MULTILINE)   each line is considered with ^ and $<br/>re.S (re.DOTALL)      . will match newline too<br/>re.X (re.VERBOSE)     allow comments</span></pre><p id="75f3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">相关的Python示例如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正则表达式的标志</p></figure><ul class=""><li id="a78d" class="nu nv it lt b lu mn lx mo ma nw me nx mi ny mm nz oa ob oc bi translated">这些例子中的每一个都包括一个不使用相应标志的直接对比。</li><li id="13fe" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">该标志不仅在创建正则表达式模式时设置，还可以通过调用模块级函数来指定。</li><li id="b1cb" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">标志可以组合，比如<code class="fe ne nf ng nh b">flags=re.I|re.M</code>，如下例所示。</li></ul><pre class="kj kk kl km gt nk nh nl nm aw nn bi"><span id="0df1" class="no la it nh b gy np nq l nr ns">&gt;&gt;&gt; re.findall("^hi", "hi\nHi\nhI", flags=re.I|re.M)<br/>['hi', 'Hi', 'hI']</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="0066" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">5.匹配对象的多个方面</h1><p id="417e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当您使用正则表达式时，在许多情况下，您将处理<code class="fe ne nf ng nh b">Match</code>对象。关于Match类的详细信息当然可以在官方文档中找到。在这里，我将强调一下<code class="fe ne nf ng nh b">Match</code>对象的一些常用方面。</p><p id="0d54" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们首先看看正则表达式搜索中的一个<code class="fe ne nf ng nh b">Match</code>对象的默认表示。</p><pre class="kj kk kl km gt nk nh nl nm aw nn bi"><span id="ec10" class="no la it nh b gy np nq l nr ns">&gt;&gt;&gt; match = re.match(r"(.\d)*", "a1b2c3dd")<br/>&gt;&gt;&gt; print(match)<br/>&lt;re.Match object; span=(0, 6), match='a1b2c3'&gt;</span></pre><p id="70f4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">关于<code class="fe ne nf ng nh b">Match</code>对象的最基本信息是匹配的字符串及其跨度(开始和结束)。以下是检索这些信息的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">匹配对象的基本信息</p></figure><p id="d606" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ne nf ng nh b">Match</code>对象被评估为<code class="fe ne nf ng nh b">True</code>。当搜索相关的函数(如<code class="fe ne nf ng nh b">search</code>、<code class="fe ne nf ng nh b">match</code>)没有找到匹配时，将返回<code class="fe ne nf ng nh b">None</code>。因此，我们通常采用以下模式进行条件求值。</p><pre class="kj kk kl km gt nk nh nl nm aw nn bi"><span id="e2b1" class="no la it nh b gy np nq l nr ns">match = re.match("pattern", "string to match")<br/>if match:<br/>    print("do something with the matched")<br/>else:<br/>    print("found no matches)</span></pre><p id="799b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">匹配的字符串可以有多个组。您可能已经注意到，我们使用<code class="fe ne nf ng nh b">group</code>方法来检索匹配的字符串。还有一个密切相关的方法——<code class="fe ne nf ng nh b">groups</code>，观察下面这个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">访问正则表达式组</p></figure><p id="b76d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在上面的例子中，模式包括两组，如使用两对括号所示。识别的匹配将创建与模式的组相对应的单独的组。如您所见，默认情况下，组0是整个匹配。随后的组将向您展示根据每个组中的指定模式确定的内容。</p><p id="a6b3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">与分组相关，跨度可以按组检索。下面是一些例子。</p><pre class="kj kk kl km gt nk nh nl nm aw nn bi"><span id="d790" class="no la it nh b gy np nq l nr ns">&gt;&gt;&gt; float_match.span(0)<br/>(0, 5)<br/>&gt;&gt;&gt; float_match.span(1)<br/>(0, 2)<br/>&gt;&gt;&gt; float_match.span(2)<br/>(3, 5)</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h2 id="b085" class="no la it bd lb oi oj dn lf ok ol dp lj ma om on ll me oo op ln mi oq or lp os bi translated">6.命名组</h2><p id="de66" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在上一节中，我们看到了<code class="fe ne nf ng nh b">Match</code>对象中的组。具体来说，我们使用索引来检索适当的组，以便进一步检查。然而，索引很容易出错。</p><p id="66f9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了解决这个问题，我们可以利用命名组特性，这是与分组相关的最重要的特性之一。最好用一个例子来说明这个特性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">命名的正则表达式组</p></figure><p id="e86d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这段代码中有几件事值得注意。</p><ul class=""><li id="8582" class="nu nv it lt b lu mn lx mo ma nw me nx mi ny mm nz oa ob oc bi translated">要命名一个组，我们使用语法(？P <name> …)。该名称应该是有效的Python标识符，因为它必须能够在以后被检索以供参考。</name></li><li id="18b5" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">命名的组可以通过它们各自的名称来引用。例如，为了检索<code class="fe ne nf ng nh b">last_name </code>组，我们使用<code class="fe ne nf ng nh b">matched.group(‘last_name’)</code>。</li><li id="4665" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">虽然最好使用组名来检索它们的信息，但是也可以使用它们各自的索引来检索它们。</li><li id="bab6" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated"><code class="fe ne nf ng nh b">Match</code>对象有一个名为<code class="fe ne nf ng nh b">groupdict</code>的方法，它将检索指定组的信息。请注意以下特征:</li></ul><pre class="kj kk kl km gt nk nh nl nm aw nn bi"><span id="a428" class="no la it nh b gy np nq l nr ns">&gt;&gt;&gt; matched.groupdict()<br/>{'last_name': 'Robinson', 'first_name': 'Zoe', 'age': '37'}</span></pre><p id="e817" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如您可能看到的，当您需要处理由模式识别的子组时，命名组可能特别有用。这些名称可以显著提高代码的可读性。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="daa6" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">7.常用方法概述</h1><p id="a1b8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用正则表达式处理字符串数据有不同的方法。您可以在官方文档中找到受支持方法的完整列表。在这里，我只回顾一些常用的方法:</p><ul class=""><li id="c146" class="nu nv it lt b lu mn lx mo ma nw me nx mi ny mm nz oa ob oc bi translated"><code class="fe ne nf ng nh b">search</code>，如果在字符串中的任何地方发现匹配，它将返回一个<code class="fe ne nf ng nh b">Match</code>对象。</li><li id="339f" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated"><code class="fe ne nf ng nh b">match</code>，如果在字符串开头识别出匹配，则返回一个<code class="fe ne nf ng nh b">Match</code>对象。</li></ul><p id="8880" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以下代码向您展示了与这两种搜索方法相关的几个示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用正则表达式搜索</p></figure><ul class=""><li id="e784" class="nu nv it lt b lu mn lx mo ma nw me nx mi ny mm nz oa ob oc bi translated"><code class="fe ne nf ng nh b">findall</code>，返回与模式匹配的字符串列表。请注意，当模式中有多个组时，列表项将是一个匹配组的元组。</li><li id="74cb" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated"><code class="fe ne nf ng nh b">finditer</code>，返回产生<code class="fe ne nf ng nh b">Match</code>对象的迭代器。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用正则表达式查找所有内容</p></figure><ul class=""><li id="3daf" class="nu nv it lt b lu mn lx mo ma nw me nx mi ny mm nz oa ob oc bi translated"><code class="fe ne nf ng nh b">split</code>，按模式拆分字符串。您可以选择设置最大允许拆分。</li></ul><pre class="kj kk kl km gt nk nh nl nm aw nn bi"><span id="69b7" class="no la it nh b gy np nq l nr ns">&gt;&gt;&gt; text_to_split = 'a1b2c3d4e555f99'<br/>&gt;&gt;&gt; re.split(r"\d+", text_to_split, maxsplit=5)<br/>['a', 'b', 'c', 'd', 'e', 'f99']</span></pre><ul class=""><li id="3439" class="nu nv it lt b lu mn lx mo ma nw me nx mi ny mm nz oa ob oc bi translated"><code class="fe ne nf ng nh b">sub</code>，根据定义的模式和替换，通过替换第一个匹配的字符串来创建一个字符串。值得注意的是，替换可以是一个字符串或一个函数，后者将接受一个单独的<code class="fe ne nf ng nh b">Match</code>对象作为它的参数。</li></ul><pre class="kj kk kl km gt nk nh nl nm aw nn bi"><span id="0eca" class="no la it nh b gy np nq l nr ns">&gt;&gt;&gt; text_to_sub = '123,456,789_012_345/678'<br/>&gt;&gt;&gt; re.sub(r"\D", "-", text_to_sub)<br/>'123-456-789-012-345-678'</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="de0a" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">结论</h1><p id="c5d5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们回顾了Python中正则表达式的基本方面。作为总结，我推荐你掌握正则表达式的三个步骤。</p><ul class=""><li id="999f" class="nu nv it lt b lu mn lx mo ma nw me nx mi ny mm nz oa ob oc bi translated">理解正则表达式本身的基本语法，它们相对独立于您使用的编程语言。一旦你学会了它们，你几乎可以在任何支持正则表达式的语言中使用它们。</li><li id="c428" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">使用正则表达式作为编译模式或直接使用模块级函数。可用的函数应该简单明了，提供常见的文本操作技术，包括搜索、拆分和替换。</li><li id="63c8" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">学习一些高级技术，比如分组。本文也没有涉及其他一些高级正则表达式，比如使用<code class="fe ne nf ng nh b">lookahead</code>和<code class="fe ne nf ng nh b">lookbehind</code>断言，这些可以在官方文档中找到。</li></ul></div></div>    
</body>
</html>