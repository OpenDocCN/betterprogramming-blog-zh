<html>
<head>
<title>Generics and Subtypes in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的类属和子类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/generics-and-subtypes-in-swift-7f27638e1b99?source=collection_archive---------12-----------------------#2020-04-21">https://betterprogramming.pub/generics-and-subtypes-in-swift-7f27638e1b99?source=collection_archive---------12-----------------------#2020-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6b3f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">协变性和不变性之间的斗争</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/385d2647f8d6ac047360ed6b5585dda4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YMa48ktZDU8iOG5l"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@grohsfabian?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fabian Grohs </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="203d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你尝试过混合使用泛型和子类型吗？通过本文充分利用多态性。</p><p id="6e48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们都爱斯威夫特。它是一种年轻而强大的编程语言，但有时当你感觉已经掌握了它，你会开始与它的一些局限性作斗争。在本文中，我想讨论如何将泛型和子类型混合在一起，以及这种方法的局限性。</p><p id="8ffc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文要求至少具备Swift中泛型和子类型的基础知识。如果你不知道它们或者只是想回顾一下，你可以查看苹果官方文档中的这些链接:</p><ul class=""><li id="9ce9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html" rel="noopener ugc nofollow" target="_blank">Swift中的泛型</a></li><li id="74d4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/Inheritance.html" rel="noopener ugc nofollow" target="_blank">继承</a></li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2c1d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">泛型的不变性</h1><p id="bf8a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">想象一下，在美好的一天，你醒来，决定要建一个健身app。完美！让我们通过写一些代码来弄脏我们的手。</p><p id="646c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要一个类来代表我们的练习。我们可以称之为<code class="fe nn no np nq b">Exercise</code>，我们可以添加两个方法来使它更真实(在这个例子中我们不需要它们):</p><ul class=""><li id="20b1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nn no np nq b">perform()</code>开始练习。</li><li id="8b1c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nn no np nq b">stop()</code>停止了锻炼。</li></ul><p id="48ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个实际的练习都需要这些方法的不同实现，所以我们可以为每个方法创建一个子类。比如我想提高我的二头肌，所以我创建了一个<code class="fe nn no np nq b">Pushup</code>类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f87b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在脚本中看到的，当您的代码需要一个超类时，分配一个子类的实例是没问题的，因为这是几乎所有语言中继承的工作方式。</p><p id="1167" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是现在试着想象我们的应用有一个叫做<code class="fe nn no np nq b">Activity</code>的结构，它是通用的，因为它可以处理其他类——不仅仅是练习。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7e70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等，发生什么事了？XCode为什么会引发这个错误？</p><pre class="kj kk kl km gt nt nq nu nv aw nw bi"><span id="375b" class="nx mr it nq b gy ny nz l oa ob">Cannot assign value of type Activity&lt;Pushup&gt; to type Activity&lt;Exercise&gt;</span></pre><p id="90f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因很简单:泛型是不变的。这意味着即使泛型类型包装了子类型，也不会使它成为包装其超类的泛型的子类型。</p><p id="ed59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是最奇怪的事情还没发生。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b9a7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">内置泛型的协方差</h1><p id="eaa4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">还记得<code class="fe nn no np nq b">Array</code>和<code class="fe nn no np nq b">Optional</code>是引擎盖下的泛型吗？如果你不记得了，没关系。你唯一应该知道的是，你可以写<code class="fe nn no np nq b">Array&lt;Int&gt;</code> <em class="oc"> </em>而不是<code class="fe nn no np nq b">[Int]</code>，因为后者只是建立在它之上的语法糖。</p><p id="fddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，让我们再写一段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嘿，发生什么事了？为什么编译器没有显示任何错误？这个例子和前面的完全一样，但是有内置的泛型类型！嗯，正是这个原因。</p><p id="96a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift内置的泛型类型是协变的，<em class="oc"> </em>其中<em class="oc"> </em>允许泛型类型是其他泛型的子类型。这也是为什么如果一个函数需要一个<code class="fe nn no np nq b">Int?</code> <em class="oc">，你可以指定一个<code class="fe nn no np nq b">Int</code>。你想过这个问题吗？</em></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8e47" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">从这里去哪里</h1><p id="0f96" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我希望你能更好地理解泛型和子类型的工作原理，以及它们的局限性。Swift是一门年轻的语言，需要不变性来处理当前版本的多态性，但希望将来我们可以为泛型类型提供协方差！</p><p id="302f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我也希望这篇文章能帮助你更多地关注关于这种语言的小细节，我们通常不会注意到这些细节，因为我们已经习惯了。它们对于真正了解幕后发生的事情非常有用。</p><p id="1625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。我希望你喜欢这篇文章！如果你有任何问题让我知道。</p></div></div>    
</body>
</html>