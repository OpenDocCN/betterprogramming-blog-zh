# 如何在 Rust 中对 20G 文件进行排序

> 原文：<https://betterprogramming.pub/how-to-sort-a-20g-file-in-rust-12abfffbd92b>

## 并且知道如何处理文件

![](img/63397820e3b0a9b13700a6fefb298ed1.png)

如何对与内存不匹配的文件进行排序的问题已经有了一个标准的解决方案，叫做“外部排序”。

这个故事是关于如何用 Rust 实现这样一个外部排序算法的一些细节。

尽管已经有一些现成的解决这个问题的方法，但是从实现的角度来看，这是非常有趣的，因为它涉及到标准文件处理中的许多重要概念。

# 该算法

让我们快速回顾一下外部排序是如何工作的。标准排序算法的实现需要将目标列表保存在内存中。

如果可用内存不够大，我们首先将列表分成更小的部分来读取，以适合内存。通过使用某种排序算法对每个部分进行排序，并随后将其写入专用于该部分的文件。这给我们留下了许多文件，每个文件都包含一个排序列表，并且每个文件都可以放在内存中。

最后，我们将一个可读的流放到每个文件中，并总是选择最小的元素写入一个“大”的结果文件。如果您不熟悉这种合并策略，稍后您将很容易从代码中理解细节。

# 产生测试数据

为了有一个大约 20G 大小的大文件，我们将逻辑回归的第一个`n`迭代写在其混乱区域内:

```
x_n+1 = r * x_n * (1 - x_n )
```

这非常适合，因为它会产生大量不重复的数据。

该序列的`[Iterator](https://applied-math-coding.medium.com/an-introduction-into-rust-part-11-iterators-1985d077aa0a)`是这样实现的:

在 Rust 中，人们可以通过简单的操作在文件中创建一个可写的流，

```
use std::fs::{remove_file, File};let mut file = **File::create**("filename").unwrap();
```

然后我们可以开始一行一行地写，

```
let mut logistic = Logistic(0.35);...**writeln!**(file, "{}", logistic.next().unwrap());
```

这种方法适用于少量的数据，但是在我们的例子中，这可能需要很长时间。逐行写入文件是一种非常低效的 I/O 操作。

由于这个原因，我们首先在内存中缓冲尽可能多的写操作，当这个缓冲溢出时，它在一个 I/O 操作中被写入文件:

这个想法是用一个`BufWriter::with_capacity`包裹`File`。在这里，我们可以指定在实际写入文件之前应该缓冲多少字节。

使用这种缓冲时调用`file.flush().unwrap()`也很重要。这确保了在缓冲区被丢弃之前，所有数据都从缓冲区写入文件。

# 外部排序

该算法的核心方法如下:

这里我们从生成的大文件中读取适合内存的部分。为了打开文件以获得可读的流，

```
let file = File::open('filename').unwrap();
```

但是同样，逐行读取会导致非常低效的 I/O 操作。因此，我们再次使用缓冲技巧，但这次正好相反:

```
let file = **BufReader::with_capacity**(
  10_000_000, File::open(filename).unwrap()
);
```

接下来，我们将文件逐行缓冲读取到一个向量中。我们这样做，直到使用了一定量的内存`max_mem_use`，然后通过调用`sort_and_write_to_file`对列表的这一部分进行排序。为了方便起见，这个方法还将排序后的部分写入一个临时文件。

这里使用的排序只是 Rust 在`Vec`上的标准排序方法(当时是一种类似合并排序的算法):

```
v.**sort_by**(|a, b| a.**partial_cmp**(b).unwrap());
```

我们需要使用`partial_cmp`，因为在`f64`类型的数据上只实现了`PartialOrd`特征(而不是`Ord`)。

依然有趣的是方法`merge`。这里，缓冲的可读流被放到每个临时数据文件中，然后它们被逐行读取(缓冲)并相互比较。最小值被写入(缓冲)到结果文件中。我们只读取给定流中的下一行，以防其值是最低的:

`active_readers`是一个向量，保存所有缓冲的可读流到所有临时数据文件上的`Line`-迭代器(`tmp_file_names`)。然后创建一个名为`value`的向量，它最初保存每个临时文件的第一行。我们反复搜索`values`中的最小值，并将后者写入结果文件:`writeln!(file, “{}”, min_val);`

在这种情况下，我们用对应的临时文件的下一行替换对应的索引`values`，如果它还没有到达 e of。

这样，我们确保在一个“大”的结果文件中产生一个升序排序的列表。

为了方便起见，让我粘贴我用来生成和排序一个近 20G 文件的全部代码。为了在您的系统上运行，您可能需要调整系统内存中的全局变量`BUFFER_CAPACITY`和`MAX_MEM_USE`。但是请注意，根据这些设置，这可能会产生大量临时文件。

感谢阅读！