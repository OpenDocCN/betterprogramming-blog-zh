<html>
<head>
<title>How to schedule Node.js Scripts on Your Mac With Launchd</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Launchd在Mac上调度Node.js脚本</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/schedule-node-js-scripts-on-your-mac-with-launchd-a7fca82fbf02?source=collection_archive---------5-----------------------#2020-09-01">https://betterprogramming.pub/schedule-node-js-scripts-on-your-mac-with-launchd-a7fca82fbf02?source=collection_archive---------5-----------------------#2020-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="82c6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">自动化您的脚本</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f41447eba4bbd5c32ddf875ca25f315f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Yqr-n4mYS0QCfqTB"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@jessysmith?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">鞠波·史密斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="a77a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时，有些<a class="ae kv" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>脚本，您可能希望在没有任何交互的情况下定期运行。也许您希望每半小时ping一次服务器，或者定期从新闻API下载新数据。无论您的用例是什么，能够自动化这些脚本将会节省您的时间和精力。</p><p id="c0d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你在Mac上工作，自动化这些脚本的一个很好的方法是使用<code class="fe ls lt lu lv b">launchd</code>来设置一个自动化的时间表。它可以运行异步代码，将在Mac唤醒时运行您的任务，最重要的是，它已经是macOS的一部分，这意味着无需安装新工具！</p><p id="eb3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看如何开始使用<code class="fe ls lt lu lv b">launchd</code>和Node.js。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="6603" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">什么是launchd？</h1><blockquote class="mv"><p id="ef7a" class="mw mx iq bd my mz na nb nc nd ne lr dk translated">“launchd 管理整个系统和单个用户的流程。”—终端启动手册页</p></blockquote><p id="2a5d" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated"><code class="fe ls lt lu lv b">launchd</code>是一个在macOS上运行守护进程和代理的工具。如果您不熟悉这些术语，守护程序是一种始终在后台运行的系统范围的服务，而代理是根据用户特定的请求执行的服务。因此，<code class="fe ls lt lu lv b">launchd</code>是运行脚本的首选macOS自动化工具。</p><p id="0c32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我们将发出特定于用户的请求来运行Node.js脚本，因此我们将利用启动代理。这些代理允许用户通过使用属性列表(<code class="fe ls lt lu lv b">.plist</code>)文件来定义任务，该文件可以按照用户设置的常规时间表来执行。<code class="fe ls lt lu lv b">launchd</code>可以定期(使用设定的执行间隔)和基于日历的时间表自动执行任务，允许您灵活安排脚本的运行方式。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="ba6c" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">自动化Node.js脚本</h1><p id="9bbc" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">现在我们知道了什么是<code class="fe ls lt lu lv b">launchd</code>的基本知识，让我们一起编写一个简单的Node.js脚本来测试它。我们首先将代理设置为每分钟运行一次，然后将其更改为根据基于日历的计划执行，以演示我们可以定义自动化任务的两种方式。</p><h2 id="2de1" class="np me iq bd mf nq nr dn mj ns nt dp mn lf nu nv mp lj nw nx mr ln ny nz mt oa bi translated">创建一个测试脚本</h2><p id="dc4d" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">首先，我们将在桌面上创建一个新文件夹，并将一个空的JavaScript文件放入其中:</p><pre class="kg kh ki kj gt ob lv oc od aw oe bi"><span id="8921" class="np me iq lv b gy of og l oh oi">mkdir ~/Desktop/schedule-demo &amp;&amp; touch ~/Desktop/schedule-demo/schedule.js</span></pre><p id="29e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oj">注意:从技术上讲，这个文件可以随便叫，可以随便存，只要你把路径更新到剩余指令中的代码。</em></p><p id="1858" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了一个可以使用的文件，让我们通过将以下内容粘贴到新文件中，将一个简单的<code class="fe ls lt lu lv b">console.log</code>时间戳放入其中:</p><pre class="kg kh ki kj gt ob lv oc od aw oe bi"><span id="48e7" class="np me iq lv b gy of og l oh oi">const now = new Date();</span><span id="ba39" class="np me iq lv b gy ok og l oh oi">const currentTime = `${now.getHours()}:${now.getMinutes()}`;</span><span id="d97d" class="np me iq lv b gy ok og l oh oi">console.log(`The time is ${currentTime}`);</span></pre><p id="169c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个<code class="fe ls lt lu lv b">console.log</code>将在脚本运行时输出当前时间。我们可以使用Node测试这个脚本，并检查我们是否在终端中获得了正确的输出:</p><pre class="kg kh ki kj gt ob lv oc od aw oe bi"><span id="74f5" class="np me iq lv b gy of og l oh oi">node ~/Desktop/schedule-demo/schedule.js</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/82c550410a91fc6ba9de2e23627ea9d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eL9C8sf8fLzXglKVBNRekA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">你的时间可能会有所不同，取决于你什么时候跑。</p></figure><h2 id="60df" class="np me iq bd mf nq nr dn mj ns nt dp mn lf nu nv mp lj nw nx mr ln ny nz mt oa bi translated">创建一个<code class="fe ls lt lu lv b">plist</code>文件</h2><p id="023d" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">现在我们有一个脚本要运行，我们需要创建一个<code class="fe ls lt lu lv b">plist</code>文件<code class="fe ls lt lu lv b">launchd</code>可以用来自动化脚本。<code class="fe ls lt lu lv b">plist</code>文件是Apple用来设置配置的定制XML文件，因此它们将允许我们分配我们的时间表以及其他关于自动化的关键信息。</p><p id="d635" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行以下命令，在正确的位置创建一个空的<code class="fe ls lt lu lv b">plist</code>文件:</p><pre class="kg kh ki kj gt ob lv oc od aw oe bi"><span id="3f21" class="np me iq lv b gy of og l oh oi">touch ~/Library/LaunchAgents/com.schedule-demo.daemon.plist</span></pre><p id="5be5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用您喜欢的代码编辑器打开该文件，并将以下代码粘贴到其中，将<code class="fe ls lt lu lv b">{your directory}</code>更新到您正在使用的目录:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="2946" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种配置设置了一些东西:</p><ul class=""><li id="5ddc" class="oo op iq ky b kz la lc ld lf oq lj or ln os lr ot ou ov ow bi translated">守护程序的名称。</li><li id="3412" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated">只要用户登录，守护程序就会启动。</li><li id="3f95" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated">两次处决之间间隔60秒。</li><li id="e73b" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated">输出错误和日志将被发送到<code class="fe ls lt lu lv b">stderr.log</code>和<code class="fe ls lt lu lv b">stdout.log</code>。</li><li id="b92d" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated">设置环境路径(如果您的程序使用其他命令，这很有用)。</li><li id="e5c5" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated">代理将在分配的<code class="fe ls lt lu lv b">WorkingDirectory</code>中执行。</li><li id="c1a8" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated">脚本将通过执行<code class="fe ls lt lu lv b">/usr/local/bin/node schedule.js</code>在节点中运行。</li></ul><p id="be17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oj">注意:这只是本教程的一个简单配置。有关进一步的配置设置，请查看终端中的</em> <code class="fe ls lt lu lv b"><em class="oj">launchd.plist</em></code> <em class="oj">手册页。</em></p><h2 id="46d3" class="np me iq bd mf nq nr dn mj ns nt dp mn lf nu nv mp lj nw nx mr ln ny nz mt oa bi translated">定期启动计划</h2><p id="6629" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">要开始自动化，在终端中运行以下命令，将<code class="fe ls lt lu lv b">plist</code>加载到<code class="fe ls lt lu lv b">launchd</code>:</p><pre class="kg kh ki kj gt ob lv oc od aw oe bi"><span id="e124" class="np me iq lv b gy of og l oh oi">launchctl load ~/Library/LaunchAgents/com.schedule-demo.daemon.plist</span></pre><p id="36b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您现在应该能够看到脚本每60秒运行一次，将<code class="fe ls lt lu lv b">console.log</code>值输出到<code class="fe ls lt lu lv b">stdout.log</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/8b6ee3eb5b4693af5d6504a2ee2d908f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iEk3vaBhfWdYShZiPvDkNg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">就像时钟一样。</p></figure><p id="a618" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要停止计划，请在终端中运行以下命令:</p><pre class="kg kh ki kj gt ob lv oc od aw oe bi"><span id="19a4" class="np me iq lv b gy of og l oh oi">launchctl unload ~/Library/LaunchAgents/com.schedule-demo.daemon.plist</span></pre><h2 id="0cc9" class="np me iq bd mf nq nr dn mj ns nt dp mn lf nu nv mp lj nw nx mr ln ny nz mt oa bi translated">设置一个基于日历的时间表来运行测试脚本</h2><p id="beb3" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">我们现在可以将计划设置为按时间间隔运行，但是如果我们希望它在特定的时间运行呢？为此，我们可以更新我们的<code class="fe ls lt lu lv b">plist</code>文件，使用<code class="fe ls lt lu lv b">StartCalendarInterval</code>而不是<code class="fe ls lt lu lv b">StartInterval</code>来定义时间表。根据<a class="ae kv" href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html" rel="noopener ugc nofollow" target="_blank">苹果开发者文档</a>，日历语法与<code class="fe ls lt lu lv b">cron</code>类似，因此<code class="fe ls lt lu lv b">StartCalendarInterval</code>中省略的任何值都将被视为通配符。</p><p id="2bce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，假设我们想在每小时45分钟后运行脚本。语法应该是:</p><pre class="kg kh ki kj gt ob lv oc od aw oe bi"><span id="b4c3" class="np me iq lv b gy of og l oh oi">&lt;key&gt;StartCalendarInterval&lt;/key&gt;<br/>&lt;dict&gt;<br/>    &lt;key&gt;Minute&lt;/key&gt;<br/>    &lt;integer&gt;45&lt;/integer&gt;<br/>&lt;/dict&gt;</span></pre><p id="e350" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，假设我们只想在每周一上午11:30运行脚本。其语法如下:</p><pre class="kg kh ki kj gt ob lv oc od aw oe bi"><span id="8f3b" class="np me iq lv b gy of og l oh oi">&lt;key&gt;StartCalendarInterval&lt;/key&gt;<br/>&lt;dict&gt;<br/>    &lt;key&gt;Minute&lt;/key&gt;<br/>    &lt;integer&gt;30&lt;/integer&gt;<br/>    &lt;key&gt;Hour&lt;/key&gt;<br/>    &lt;integer&gt;11&lt;/integer&gt;<br/>    &lt;key&gt;Weekday&lt;/key&gt;<br/>    &lt;integer&gt;1&lt;/integer&gt;<br/>&lt;/dict&gt;</span></pre><p id="b272" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于如何设置时间表的更多信息可以在<code class="fe ls lt lu lv b">launchd.plist</code> man文件中找到，但是对于这个例子，让我们每小时在过去的45分钟运行这个脚本。</p><p id="517d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将下面的代码粘贴到您的<code class="fe ls lt lu lv b">plist</code>中，再次更新<code class="fe ls lt lu lv b">{your directory}</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="a1a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，像以前一样，我们可以加载<code class="fe ls lt lu lv b">plist</code>，它将根据时间表开始自动运行:</p><pre class="kg kh ki kj gt ob lv oc od aw oe bi"><span id="735e" class="np me iq lv b gy of og l oh oi">launchctl load ~/Library/LaunchAgents/com.schedule-demo.daemon.plist</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/fce960aac3bc68756caed546318a9790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*avB0BXcNKUk03uBRck0dsA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">当您第一次加载<code class="fe ls lt lu lv b">plist. And yes, this screenshot took a while.</code>时，它也会运行一次</p></figure><p id="43b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可以使用Node.js为要执行的任务安排一个特定的时间了！</p><p id="c43a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oj">注意:如果您想更快地看到以下部分的结果，您应该卸载基于日历的时间表，并将其替换为之前基于间隔的时间表，这样您就不必在日志之间等待一个小时。</em></p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="ee04" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">自动化异步脚本</h1><p id="aa23" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">既然我们已经看到简单的同步任务可以自动化，您可能会想“但是异步脚本呢？”好消息:<code class="fe ls lt lu lv b">launchd</code>只是按计划运行Node的一个实例，所以异步脚本也可以运行。让我们更新代码以包含对API的异步调用来测试这一点。</p><p id="2bb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们首先在我们的文件夹中创建一个npm包，并为我们的API调用安装<code class="fe ls lt lu lv b">axios</code>:</p><pre class="kg kh ki kj gt ob lv oc od aw oe bi"><span id="22be" class="np me iq lv b gy of og l oh oi">npm init -y &amp;&amp; npm install axios</span></pre><p id="322d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，将以下代码添加到您的<code class="fe ls lt lu lv b">schedule.js</code>文件的末尾，以调用Chuck Norris API(一个提供随机Chuck Norris笑话的外部API):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="d851" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不需要重新加载<code class="fe ls lt lu lv b">plist</code>。只要文件的路径没有改变，计划任务将自动使用脚本的新版本。现在，当脚本运行时，我们可以看到它不仅像以前一样记录时间，而且还从API获取信息！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/0fb6f9308dfed50a932d9d4ce53ffcf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yyD48Q-PIkBBgWxbMsPhMg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">感觉又回到了2006年。</p></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="56da" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">睡眠后运行任务</h1><p id="e5f9" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">我们已经知道，当你的Mac处于唤醒状态时,<code class="fe ls lt lu lv b">launchd</code>能够按计划运行任务，但如果你正在使用MacBook，你合上盖子，或者你的台式Mac启用了节能功能，但它进入睡眠状态，会发生什么情况呢？答案将取决于你是使用<code class="fe ls lt lu lv b">StartInterval</code>来设置一个周期性的时间表，还是使用<code class="fe ls lt lu lv b">StartCalendarInterval</code>来设置一个基于日历的时间表。</p><h2 id="56c4" class="np me iq bd mf nq nr dn mj ns nt dp mn lf nu nv mp lj nw nx mr ln ny nz mt oa bi translated">使用StartInterval时</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/cece5e211b1cd2164dee4ad19c79fe51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*txWJmyM1C2irwD79sSWfmw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">当Mac唤醒时，时间表会恢复。</p></figure><p id="c035" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面可以看到，Mac在18:15进入睡眠状态，然后在18:21被唤醒。一旦Mac被唤醒，时间表会自动继续，但当它处于睡眠状态时，任务不会运行。</p><h2 id="7feb" class="np me iq bd mf nq nr dn mj ns nt dp mn lf nu nv mp lj nw nx mr ln ny nz mt oa bi translated">使用StartCalendarInterval时</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/54e14f7780b908483b0ef058609dc530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DI63DQxJv85tyCHzNY6KcQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">该计划会在唤醒时立即执行，并继续执行。</p></figure><p id="6537" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，当Mac处于唤醒状态时，时间表会被遵守。当它在19:45后进入睡眠状态时，它跳过了20:45的预定任务，但在21:14被唤醒时自动完成了该任务。然后，它恢复了正常的时间表。</p><p id="ffdc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，Mac确实需要在其预定时间被唤醒，但有可能<a class="ae kv" href="https://support.apple.com/en-bn/guide/mac-help/mchlp2266/mac" rel="noopener ugc nofollow" target="_blank">自动唤醒您的Mac </a>以确保自动化发生。此外，如果任务的确切时间不重要，则当Mac被唤醒时，时间表会自动执行该任务。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="40bf" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="ac3b" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated"><code class="fe ls lt lu lv b">launchd</code>是macOS中非常强大的自动化工具。它也不仅限于节点。它可以用来在你的Mac上自动运行任何脚本，甚至可能从终端发送电子邮件。你可以用它来运行同步或异步代码，它可以在你的Mac进入睡眠状态后赶上来。</p><p id="fb4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">凭借其强大的功能，您可以轻松地安排任何需要自动化的事情。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="9e10" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">资源</h1><ul class=""><li id="7bb8" class="oo op iq ky b kz nk lc nl lf ph lj pi ln pj lr ot ou ov ow bi translated"><code class="fe ls lt lu lv b">launchd</code>终端手册页</li><li id="fc76" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated">苹果支持— <a class="ae kv" href="https://support.apple.com/en-au/guide/terminal/apdc6c1077b-5d5d-4d35-9c19-60f2397b2369/mac" rel="noopener ugc nofollow" target="_blank">在Mac终端中启动脚本管理</a></li><li id="977a" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated">苹果开发者文档— <a class="ae kv" href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html" rel="noopener ugc nofollow" target="_blank">创建启动守护进程和代理</a></li></ul></div></div>    
</body>
</html>