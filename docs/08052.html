<html>
<head>
<title>Git Merge, Squash, Rebase, or Pull — What To Choose?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git合并、挤压、重置或拉取——选择什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/git-merge-squash-rebase-or-pull-what-to-choose-50b331d3e7c1?source=collection_archive---------2-----------------------#2021-03-19">https://betterprogramming.pub/git-merge-squash-rebase-or-pull-what-to-choose-50b331d3e7c1?source=collection_archive---------2-----------------------#2021-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fafe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解决Git冲突的分步比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/68bdfe4b1d746f547884ff74196240d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F-gPwgTauIyc5mde"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Paul Steuber 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="9e3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Git是一个版本控制系统，它跟踪文件的变化。随着大量软件开发人员在不同的分支工作，合并每个人的工作并解决冲突成为一个持续的挑战。</p><p id="0daa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前一篇文章中，描述了Git引用、提交和分支。在一些Git命令的帮助下，我们演示了如何从合并混乱中恢复。</p><p id="57f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将使用示例来展示如何使用合并、挤压、重定基础和拉的选择来避免合并混乱。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="029e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">冲突案例</h1><p id="ff19" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们创建了一个有冲突的存储库，可以通过以下命令克隆它:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6c6c" class="ne md it na b gy nf ng l nh ni">$ git clone <a class="ae ky" href="https://github.com/JenniferFuBook/git-merge-conflicts.git" rel="noopener ugc nofollow" target="_blank">https://github.com/JenniferFuBook/git-merge-conflicts.git</a></span></pre><p id="ce92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存储库中有两个分支，<code class="fe nj nk nl na b">main</code>和<code class="fe nj nk nl na b">feature</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5f4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在上一篇文章中所指出的，<code class="fe nj nk nl na b">git log —-graph</code>在输出的左侧绘制了提交历史的基于文本的图形表示。每个<code class="fe nj nk nl na b">*</code>代表一个提交，<code class="fe nj nk nl na b">*</code>下的进入行代表父提交。多个传入行表示合并，而传出行标记一个共同的祖先。</p><p id="a73f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">--all</code>选项列出了所有分支的历史。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9f87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">feature</code>分支<code class="fe nj nk nl na b">main</code>后，都修改了<code class="fe nj nk nl na b">file.txt</code>(14线和8线)。当<code class="fe nj nk nl na b">feature</code>与<code class="fe nj nk nl na b">main</code>同步时，它得到两个变化:</p><ul class=""><li id="c03c" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><code class="fe nj nk nl na b">main</code>创建的<code class="fe nj nk nl na b">newFile.txt</code>(第2行):没有冲突。</li><li id="8115" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><code class="fe nj nk nl na b">file.txt</code>即<code class="fe nj nk nl na b">main</code>变化(第8行):有冲突。</li></ul><p id="c118" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在的情况是<code class="fe nj nk nl na b">main</code>和<code class="fe nj nk nl na b">feature</code>随着新的变化出现分歧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/a5b44ec53e72970f56f7c312dd7014f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VMAk6iAjxqT91wqTo0mF5A.png"/></div></div></figure><p id="ec70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有许多解决冲突的方法。让我们来探索和比较这些选项。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e8ba" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Git合并</h1><p id="0030" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nj nk nl na b">git merge</code>不对存储库历史进行任何更改。它只是为合并创建了一个额外的提交。</p><h2 id="1a47" class="ne md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">第一步。克隆存储库</h2><p id="8eb8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">克隆冲突存储库:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1081" class="ne md it na b gy nf ng l nh ni">$ git clone <a class="ae ky" href="https://github.com/JenniferFuBook/git-merge-conflicts.git" rel="noopener ugc nofollow" target="_blank">https://github.com/JenniferFuBook/git-merge-conflicts.git</a></span></pre><p id="41d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用我们的示例存储库，您可以遵循几乎所有的步骤。推送至远程将失败，因为您未被授予合并权限。但是，您仍然可以探索本地分支上的所有内容。</p><p id="1cc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是可选的，但是您可以在<code class="fe nj nk nl na b">https://github.com/&lt;your-repository&gt;</code>创建一个Git存储库。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/4dc1efb47cc6cbccdcd454e6e4d3a3a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XNdJVuOfQTuLaihyGtWyrg.png"/></div></div></figure><p id="897f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重置您克隆的存储库的上游，并推入所有代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3290" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了自己的存储库，本文中的每一步都可以按原样执行。</p><h2 id="eced" class="ne md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">第二步。执行合并</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第4–6行显示了冲突，它们可以通过<code class="fe nj nk nl na b">git status</code>进行验证:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0cef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是矛盾的<code class="fe nj nk nl na b">file.txt</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="6b94" class="ne md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">第三步。解决冲突</h2><p id="3660" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们手动解决冲突:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="29c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">准备并提交变更:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="c135" class="ne md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">第四步。将合并推送到远程</h2><p id="36f1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">运行<code class="fe nj nk nl na b">git push</code>，然后这个解析被推送到一个远程库。</p><h2 id="34dd" class="ne md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">第五步。检查合并历史</h2><p id="8fff" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们可以看到最终的变更被推送到<a class="ae ky" href="https://github.com/JenniferFuBook/git-merge" rel="noopener ugc nofollow" target="_blank"> git-merge存储库</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b66f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面基于文本的图形表示展示了额外的合并提交<code class="fe nj nk nl na b">cf1129a756bd0f2ef1641e4f5fd4c65684286ffa</code>(第2行)。</p><p id="9d16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是提交历史的概念图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/731f163825712cdfa30870781e71ade6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IKbbj3chza3ZfdLnbfMB5g.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e4f6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Git南瓜</h1><p id="8521" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Git合并中，每次合并都会生成一个额外的提交。更频繁的合并会有更多的额外提交，这可能很烦人。</p><p id="2719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">git merge</code>有一个选项<code class="fe nj nk nl na b">--squash</code>。它产生工作树和索引状态的方式与真正的合并相同，但是合并历史被丢弃了。</p><p id="b492" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了以下几点之外，前面的五步合并是相同的:</p><h2 id="a7bb" class="ne md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">第二步。使用挤压执行合并</h2><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2209" class="ne md it na b gy nf ng l nh ni">git merge --squash origin/main</span></pre><h2 id="dadc" class="ne md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">第五步。检查合并历史</h2><p id="593d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最终的变更被推送到<a class="ae ky" href="https://github.com/JenniferFuBook/git-squash.git" rel="noopener ugc nofollow" target="_blank"> git-squash库</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0306" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面基于文本的图形表示展示了额外的合并提交<code class="fe nj nk nl na b">8fe1ca0b47100ad13cf577efe364e2c3aed69008</code>(第2行)。提交看起来像是在<code class="fe nj nk nl na b">feature</code>上的普通提交。它将main上的提交(第20行和第14行)压缩成一个提交，并且没有来自<code class="fe nj nk nl na b">main</code>的提交路径。</p><p id="2cf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">git merge --squash</code>改变提交历史，但产生更干净的历史。似乎所有的发展都只发生在<code class="fe nj nk nl na b">feature</code>。</p><p id="8e66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种策略经常在合并拉请求时使用——从<code class="fe nj nk nl na b">feature</code>合并到<code class="fe nj nk nl na b">main</code>。我们的例子是反方向的，虽然概念是一样的。在某种程度上，在特性分支上有多少个合并提交并不重要。当用squash将它们合并到主分支中时，它将所有的特性开发显示为一次提交。</p><p id="0a52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是提交历史的概念图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/9cedd6737e8d58d9dab4c3a1b61468e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iCbu137F6U1Ne55YF3E7Aw.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1dc8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Git Rebase</h1><p id="c6cf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nj nk nl na b">git rebase</code>更改提交历史，但是通过将<code class="fe nj nk nl na b">feature</code>移动到<code class="fe nj nk nl na b">master</code>的顶端来创建线性历史。</p><h2 id="831b" class="ne md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">第一步。克隆存储库</h2><h2 id="4c44" class="ne md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">第二步。执行重置基础</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第4–6行显示了冲突，它们可以通过<code class="fe nj nk nl na b">git status</code>来验证:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7646" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">git rebase</code>输出和<code class="fe nj nk nl na b">git status</code>都列出了三个选项:</p><ol class=""><li id="756a" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu op nu nv nw bi translated">修复冲突，然后运行<code class="fe nj nk nl na b">git rebase —-continue</code>。</li><li id="56f1" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu op nu nv nw bi translated">使用<code class="fe nj nk nl na b">git rebase —-skip</code>跳过这个补丁。</li><li id="cd7b" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu op nu nv nw bi translated">使用<code class="fe nj nk nl na b">git rebase —-abort</code>检查原始分支。</li></ol><p id="f608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正处于重建基础的过程中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1d53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不允许留下未完成的基础。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="b391" class="ne md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">第三步。解决冲突</h2><p id="0751" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们必须在三个选项中选择一个。选择选项1来手动解决冲突:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c437" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">准备并提交变更，并完成基础变更。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="7cff" class="ne md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">第四步。将重置基础推至远程</h2><p id="252e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经准备好了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6230" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发生了什么事？</p><p id="bb69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是否应该按照输出中的建议去拉？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="df73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的输出清楚地表明这个建议是误导性的。</p><p id="e37e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行rebase命令后，远程分支不能快进到合并提交。<code class="fe nj nk nl na b">git push --force</code>是rebase所必需的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5600" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到<a class="ae ky" href="https://github.com/JenniferFuBook/git-rebase" rel="noopener ugc nofollow" target="_blank"> git-rebase库</a>。现在，重定基础的结果被推送到远程存储库。</p><h2 id="d480" class="ne md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">第五步。检查重置基础历史记录</h2><p id="edaa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">检查重置基础历史记录:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="50a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面基于文本的图形表示显示了漂亮的线性提交路径。从<code class="fe nj nk nl na b">main</code>(第8行)的顶端开始，<code class="fe nj nk nl na b">branch</code>上的提交被重写为<code class="fe nj nk nl na b">ba4c3fbd670c08f30d7a16371719a81714ea8899 </code>(第2行)。rebase不是创建额外的合并提交，而是通过为原始分支中的每个提交创建全新的提交来重写项目历史。最初的提交<code class="fe nj nk nl na b">d64444a78401995781a3efce9ab250d43c19a022</code>被替换为<code class="fe nj nk nl na b">ba4c3fbd670c08f30d7a16371719a81714ea8899</code>。</p><p id="6f5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是提交历史的概念图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/f3688724680db17f9e5dbd9650cb8ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r-zkl6KeFX-5FB84M2jgAQ.png"/></div></div></figure><p id="a6c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rebase将<code class="fe nj nk nl na b">main</code>中的所有提交移动到<code class="fe nj nk nl na b">feature</code>的顶端。对于私人分行来说是可以的。然而，如果这个分支被仍在使用最初的<code class="fe nj nk nl na b">main</code>的开发人员共享，带有全新提交的重基础分支会让Git认为你的<code class="fe nj nk nl na b">main</code>分支的历史已经与其他人的历史不同。</p><p id="1d75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，rebase的黄金法则是永远不要在公共分支上使用它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2964" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Git拉</h1><p id="f791" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nj nk nl na b">git pull [&lt;repository&gt;] [&lt;reference&gt;]</code>从另一个存储库或本地分支获取并与之集成。在默认模式下，<code class="fe nj nk nl na b">git pull</code>是<code class="fe nj nk nl na b">git fetch</code>后跟<code class="fe nj nk nl na b">git merge FETCH_HEAD</code>的简写。</p><p id="3b2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">git fetch</code>用<code class="fe nj nk nl na b">&lt;repository&gt;</code>的<code class="fe nj nk nl na b">&lt;reference&gt;</code>更新，在我们的例子中是远程跟踪分支。它将远程提示临时保存到<code class="fe nj nk nl na b">FETCH_HEAD</code>。随后的合并或重定基础发生在引用上，<code class="fe nj nk nl na b">FETCH_HEAD</code>。</p><h2 id="a58e" class="ne md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">三种拉动策略</h2><p id="d26e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">克隆我们的示例存储库并执行<code class="fe nj nk nl na b">git pull</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示显示有三种策略可以执行<code class="fe nj nk nl na b">git pull</code>:</p><ol class=""><li id="776d" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu op nu nv nw bi translated"><code class="fe nj nk nl na b">git pull —-no-rebase</code>(默认策略)</li><li id="b2b1" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu op nu nv nw bi translated"><code class="fe nj nk nl na b">git pull —-rebase</code></li><li id="582f" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu op nu nv nw bi translated"><code class="fe nj nk nl na b">git pull —-ff-only</code></li></ol><p id="0eb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">git pull origin main</code>执行默认策略，与<code class="fe nj nk nl na b">git pull —-no-rebase origin main</code>相同。也和<code class="fe nj nk nl na b">git merge origin/main</code>一样。</p><p id="9551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果继续下去，结果将与上面Git合并一节中描述的一样。</p><p id="29d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们退出与<code class="fe nj nk nl na b">git merge —-abort</code>的合并。</p><p id="41a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用rebase尝试第二种策略:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="546e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果继续下去，结果将与Git Rebase一节中描述的一样。</p><p id="ece9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用<code class="fe nj nk nl na b">git rebase —-abort</code>退出rebase。</p><p id="cbcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只看第三个策略快进。</p><p id="22e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">git pull </code>有三个设置来指定如何处理合并:</p><ul class=""><li id="8f06" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><code class="fe nj nk nl na b">—-ff</code>是默认设置。如果可能，它只快进分支指针以匹配合并的分支(不创建合并提交)。当这不可能时，它创建一个合并提交。</li><li id="1fa7" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><code class="fe nj nk nl na b">—-no-ff</code>在所有情况下都创建合并提交，即使合并可以被解析为快进。</li><li id="11a4" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><code class="fe nj nk nl na b">—-ff-only</code>尽可能将合并解析为快进。当这不可能时，它拒绝合并并以非零状态退出。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ea9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">git pull —-ff-only</code>是最安全的选择。当pull命令失败时，您可以决定使用哪种方法来解决冲突。</p><h2 id="f8c9" class="ne md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">Git配置</h2><p id="8812" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nj nk nl na b">git config</code>可用于获取和设置存储库或全局选项。这是我们的默认设置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以选择三种拉策略之一，将其设置到配置文件中:</p><ol class=""><li id="6f5c" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu op nu nv nw bi translated"><code class="fe nj nk nl na b">git config pull.rebase false</code> #合并(默认策略)</li><li id="2350" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu op nu nv nw bi translated"><code class="fe nj nk nl na b">git config pull.rebase true</code> # rebase</li><li id="1a71" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu op nu nv nw bi translated"><code class="fe nj nk nl na b">git config pull.ff only</code> #仅快进</li></ol><p id="2935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过配置设置，<code class="fe nj nk nl na b">git pull</code>将按照配置执行策略。</p><p id="0e16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以运行<code class="fe nj nk nl na b">git config —-unset pull.rebase</code>或<code class="fe nj nk nl na b">git config —-unset pull.ff</code>将其从配置文件中移除。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8e5c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="245b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要解决合并冲突，您可以从<code class="fe nj nk nl na b">git merge</code>、<code class="fe nj nk nl na b">git merge --squash</code>、<code class="fe nj nk nl na b">git rebase</code>或<code class="fe nj nk nl na b">git pull &lt;option&gt;</code>中选择。</p><p id="ef0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的偏好是什么？</p><p id="78a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢乌里扬·张、戈塔姆·穆塔和悉达多·钦塔帕利与我一起尝试这些选项！</p><p id="ac05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae ky" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p></div></div>    
</body>
</html>