<html>
<head>
<title>Utilizing Sets With Golang Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Golang泛型集合</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/utilizing-sets-with-golang-generics-316b4fe2ca28?source=collection_archive---------3-----------------------#2022-11-11">https://betterprogramming.pub/utilizing-sets-with-golang-generics-316b4fe2ca28?source=collection_archive---------3-----------------------#2022-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="21bf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Go中构建自己的全功能集合类型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/25d9fd77c05b6fc4f4c943bd33b46993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8bcnDys7jsViB1Knt3wrw.jpeg"/></div></div></figure><p id="f62f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我第一次学习Go(主要来自Python)时，我发现一个更令人沮丧的事情是缺少集合类型，比如集合和它们的公共操作。在本文中，我们将展示Go 1.18中泛型的引入如何允许我们构建自己的全功能集合类型。以下所有代码也可以在我的<a class="ae lq" href="https://github.com/noahschumacher/go-collections" rel="noopener ugc nofollow" target="_blank"> GitHub go-collections </a>中找到。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="d6f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能熟悉集合这种非常有用的数据收集类型。集合是唯一项目的无序集合。通常，集合是使用哈希表实现的，哈希表查找值O(1)(假设没有哈希冲突)。集合有4个主要操作，这使它们特别有用:</p><ol class=""><li id="a30a" class="ly lz it kw b kx ky la lb ld ma lh mb ll mc lp md me mf mg bi translated">并集(<strong class="kw iu"> A </strong> ⋃ <strong class="kw iu"> B </strong> ) —是包含集合a和b中所有元素的集合</li><li id="cadb" class="ly lz it kw b kx mh la mi ld mj lh mk ll ml lp md me mf mg bi translated">交集(<strong class="kw iu"> A </strong> ∩ <strong class="kw iu"> B </strong> )—是包含集合A和B中所有元素的集合。</li><li id="bfa8" class="ly lz it kw b kx mh la mi ld mj lh mk ll ml lp md me mf mg bi translated">补集(<strong class="kw iu">A</strong>c)——是在泛集S中但不在A中的元素的集合。<em class="mm">我们将忽略补集，因为它是由差来处理的。</em></li><li id="a336" class="ly lz it kw b kx mh la mi ld mj lh mk ll ml lp md me mf mg bi translated">差(<strong class="kw iu">A</strong>—<strong class="kw iu">B</strong>)<strong class="kw iu"/>—<strong class="kw iu">—</strong>是在<strong class="kw iu"> A </strong>中而不在<strong class="kw iu"> B </strong>中的元素的集合。</li></ol><p id="1ef2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从在Go中定义集合类型开始。首先，我们想定义什么是集合，通过泛型，我们可以利用约束来轻松扩展集合类型，以处理大量的数据类型。</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="ace4" class="ms mt it mo b be mu mv l mw mx">package collections<br/><br/>// A collection of unique comparable items. Uses a map with only true values<br/>// to accomplish set functionality.<br/>type Set[T comparable] map[T]bool<br/><br/>// Create a new empty set with the specified initial size.<br/>func NewSet[T comparable](size int) Set[T] {<br/>    return make(Set[T], size)<br/>}<br/><br/>// Add a new key to the set<br/>func (s Set[T]) Add(key T) {<br/>    s[key] = true<br/>}<br/><br/>// Remove a key from the set. If the key is not in the set then noop<br/>func (s Set[T]) Remove(key T) {<br/>    delete(s, key)<br/>}<br/><br/>// Check if Set s contains key<br/>func (s Set[T]) Contains(key T) bool {<br/>    return s[key]<br/>}</span></pre><p id="5140" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第一部分中，我们创建了利用内置映射类型的集合类型。我们将映射的键限制为Comparable类型。从文档中，我们知道可比较的类型包括</p><blockquote class="my mz na"><p id="1aa8" class="ku kv mm kw b kx ky ju kz la lb jx lc nb le lf lg nc li lj lk nd lm ln lo lp im bi translated">(布尔值、数字、字符串、指针、通道、可比较类型的数组、字段都是可比较类型的结构)</p></blockquote><p id="f6ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还在我们的类型上添加了一些基本方法，用于添加、删除和检查是否存在。这样，我们就不准备开始实现上面定义的集合操作了。先说<code class="fe ne nf ng mo b">Difference</code> <strong class="kw iu">。</strong></p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="b9b2" class="ms mt it mo b be mu mv l mw mx">// A difference B | NOTE: A-B != B-A<br/>func (a Set[T]) Difference(b Set[T]) Set[T] {<br/>    resultSet := NewSet[T](0)<br/>    for key := range a {<br/>        if !b.Contains(key) {<br/>             resultSet.Add(key)<br/>        }<br/>    }<br/>    return resultSet<br/>}</span></pre><p id="ef91" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相当简单的例子。我们简单地创建一个容量为0的新集合(因为我们不知道这个新集合有多大)，然后遍历集合<code class="fe ne nf ng mo b">A</code>，只添加不包含在<code class="fe ne nf ng mo b">B</code>中的元素。</p><p id="7c89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来的两个操作<code class="fe ne nf ng mo b">Union</code>和<code class="fe ne nf ng mo b">Intersection</code>遵循类似的模式——但是这一次我们添加了一个轻微的(或者潜在的大的)优化。</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="62ce" class="ms mt it mo b be mu mv l mw mx">// A union B<br/>func (a Set[T]) Union(b Set[T]) Set[T] {<br/>    small, large := smallLarge(a, b)<br/>    <br/>    for key := range small {<br/>        large.Add(key)<br/>    }<br/>    return large<br/>}<br/><br/>// A intersect B<br/>func (a Set[T]) Intersection(b Set[T]) Set[T] {<br/>    small, large := smallLarge(a, b)<br/>    <br/>    resultSet := NewSet[T](0)<br/>    for key := range small {<br/>        if large.Contains(key) {<br/>            resultSet.Add(key)<br/>        }<br/>    }<br/>    return resultSet<br/>}<br/><br/>// returns the small and large sets according to their len<br/>func smallLarge[T comparable](a, b Set[T]) (Set[T], Set[T]) {<br/>    small, large := b, a<br/>    if len(b) &gt; len(a) {<br/>        small, large = a, b<br/>    }<br/>    <br/>    return small, large<br/>}</span></pre><p id="d406" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这两种方法都相当简单。在<code class="fe ne nf ng mo b">Union</code>中，我们只是迭代一个集合，将值添加到另一个集合中。在<code class="fe ne nf ng mo b">Intersection</code>中，我们检查<code class="fe ne nf ng mo b">A</code>中的值是否也在<code class="fe ne nf ng mo b">B</code>中，并返回一个只包含两者中元素的集合。</p><p id="30c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">优化来自于区分哪个集合是<code class="fe ne nf ng mo b">smallLarge(a, b)</code>调用中较小的一个。通过这样做，我们允许循环只在两个集合中较小的集合上迭代。如果一组非常大而另一组很小，这可能会节省大量迭代。</p><blockquote class="my mz na"><p id="5dfe" class="ku kv mm kw b kx ky ju kz la lb jx lc nb le lf lg nc li lj lk nd lm ln lo lp im bi translated">然而，在<strong class="kw iu">联合</strong>中，我们正在覆盖可能是<strong class="kw iu"> A </strong>或<strong class="kw iu"> B </strong>的大集合。如果我们想在联合时保留原始集合，我们就必须在两个集合上循环。</p></blockquote></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="1372" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在有一个功能齐全的套装。再做一点工作，我们就可以为切片添加帮助器，并添加更多的实用方法，比如检查相等性的方法。</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="7db6" class="ms mt it mo b be mu mv l mw mx">// A == B (all elements of A are in B and vice versa)<br/>func (a Set[T]) Equals(b Set[T]) bool {<br/>    return len(a.Difference(b)) == 0 &amp;&amp; len(b.Difference(a)) == 0<br/>}<br/><br/>// Create a Set from a slice.<br/>func SliceToSet[T comparable](s []T) Set[T] {<br/>   set := NewSet[T](len(s))<br/>   for _, item := range s {<br/>       set.Add(item)<br/>   }<br/>   return set<br/>}<br/><br/>// Union two slices. The provided slices do not need to be unique. Order not guaranteed.<br/>func SliceUnion[T comparable](a, b []T) []T {<br/>   aSet, bSet := SliceToSet(a), SliceToSet(b)<br/>   union := aSet.Union(bSet)<br/>   return union.ToSlice()<br/>}<br/><br/>// Intersection of two slices. The provided slices do not need to be unique. Order not guaranteed.<br/>func SliceIntersection[T comparable](a, b []T) []T {<br/>   aSet, bSet := SliceToSet(a), SliceToSet(b)<br/>   intersection := aSet.Intersection(bSet)<br/>   return intersection.ToSlice()<br/>}</span></pre><p id="de81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过以上所有工作，我们能够执行如下所示的操作:</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="298d" class="ms mt it mo b be mu mv l mw mx">func TestSets(t *testing.T) {<br/>   A := SliceToSet([]int{1, 3, 5})<br/>   B := SliceToSet([]int{0, 1, 2, 3, 4})<br/>  <br/>   union := A.Union(B)<br/>   fmt.Println(union) // map[0:true 1:true 2:true 3:true 4:true 5:true]<br/>  <br/>   C := SliceToSet([]string{"a", "b", "noah"})<br/>   D := SliceToSet([]string{"a", "noah"})<br/>   intersection := C.Intersection(D)<br/>   fmt.Println(intersection) // map[a:true noah:true]<br/>  <br/>   fmt.Println(C.Equals(D)) // false<br/>}</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="7a25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望这篇文章对你有帮助！同样，所有代码都可以在我的GitHub <a class="ae lq" href="https://github.com/noahschumacher/go-collections" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>