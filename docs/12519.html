<html>
<head>
<title>Kubernetes on AWS: Deploy Kubernetes Cluster With Amazon EKS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS上的Kubernetes:使用亚马逊EKS部署Kubernetes集群</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kubernetes-on-aws-tutorial-to-deploy-kubernetes-cluster-with-amazon-eks-a62c23f5aa6?source=collection_archive---------7-----------------------#2022-06-10">https://betterprogramming.pub/kubernetes-on-aws-tutorial-to-deploy-kubernetes-cluster-with-amazon-eks-a62c23f5aa6?source=collection_archive---------7-----------------------#2022-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ef5a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">部署Kubernetes集群的更快捷方式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c47e0e95cd0a2e1d093a2de2109d2ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gV5BolRbQPkSdg36OnNFEg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f3c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在过去的五年里，计算机技术呈指数级增长。应用程序已经远远超出了客户机-服务器模型，分布式计算已经成为标准。AWS上的Kubernetes提供了最强大的分布式计算平台之一。</p><p id="c99f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于亚马逊Fargate等技术和亚马逊云计算基础设施的广泛覆盖，弹性Kubernetes服务或EKS可以提供一个真正的分布式环境，您的应用程序可以在其中运行和扩展。</p><p id="0738" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在AWS web控制台的帮助下用AWS设置Kubernetes可能不是最快的入门方式。在接下来的章节中，我们将提炼出在AWS上启动Kubernetes的最简单的方法，然后我们将在这个集群上启动一个Dockerized应用程序。</p><h1 id="0d52" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">AWS上Kubernetes的先决条件</h1><p id="f764" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在开始使用AWS上的Kubernetes之前，让我们先熟悉几个关键概念。其中包括以下内容:</p><ol class=""><li id="907a" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated">了解<a class="ae na" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank"> Docker容器</a>。我们稍后将模糊容器和虚拟机之间的界限，所以请确保您知道容器和传统虚拟机之间的区别。</li><li id="6924" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">熟悉AWS相关术语，如IAM角色、VPC，</li></ol><h1 id="81a8" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">为什么是Docker？Kubernetes不是掉了Docker支持吗？</h1><p id="6a6b" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Kubernetes是一个容器编排引擎。要将应用程序部署到Kubernetes集群，需要将其打包成一个或多个容器映像。Docker是目前最流行的处理容器的方式。它有助于您实现以下目标:</p><ol class=""><li id="15de" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated">在您的Windows、macOS或Linux工作站上本地运行容器</li><li id="d0a5" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">将您的应用程序打包成Docker图像</li></ol><p id="f647" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">自诞生以来，Kubernetes走过了漫长的道路。最初，它与Docker(这是最常见的)和rkt等容器运行时一起工作。这意味着每个Kubernetes节点都将安装并运行docker。运行在一个节点上的kubelet二进制文件将与Docker引擎对话，以创建由Kubernetes管理的pods和容器。</p><p id="df57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最近，<a class="ae na" href="https://kubernetes.io/blog/2020/12/02/dont-panic-kubernetes-and-docker/" rel="noopener ugc nofollow" target="_blank">Kubernetes项目已经停止支持Docker运行时</a>。相反，它使用自己的<a class="ae na" href="https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/" rel="noopener ugc nofollow" target="_blank">容器运行时接口(CRI) </a>，这减少了在节点上安装Docker的额外依赖性。</p><p id="92fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是却导致了一种误解，认为Docker老了，或者与想了解Kubernetes的人格格不入。</p><p id="3554" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这不是真的。您仍然需要Docker在本地运行和测试您的映像，任何在您的Docker运行时上工作的Docker映像也将在Kubernetes上工作！只是Kubernetes现在有了它的轻量级实现来启动那些Docker图像。</p><p id="3e73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">又念:<a class="ae na" href="https://www.clickittech.com/devops/kubernetes-vs-docker/" rel="noopener ugc nofollow" target="_blank"> Kubernetes vs Docker </a></p><h1 id="aafd" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">亚马逊上的库伯内特vs EKS</h1><p id="a7f0" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">那么，你为什么关心在亚马逊上建立一个EKS集群呢？为什么不选择创建自己的Kubernetes集群，或者使用其他云提供商，如GCP或Azure？</p><p id="dddb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">原因有很多，包括以下几点:</p><h2 id="3fa6" class="ng lv it bd lw nh ni dn ma nj nk dp me lh nl nm mg ll nn no mi lp np nq mk nr bi translated"><strong class="ak">复杂性</strong></h2><p id="15d7" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">引导您的Kubernetes集群不是一个好主意。您不仅要负责保护和管理您的应用程序，还要负责群集、网络和存储配置。除此之外，Kubernetes维护涉及到集群、底层操作系统等的升级。</p><p id="9b86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用AWS的托管Kubernetes服务，EKS，将确保您的集群配置正确，并及时获得更新和补丁。</p><h2 id="b663" class="ng lv it bd lw nh ni dn ma nj nk dp me lh nl nm mg ll nn no mi lp np nq mk nr bi translated"><strong class="ak">整合</strong></h2><p id="10a3" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">AWS的EKS与亚马逊的其余基础设施一起开箱即用。弹性负载平衡器(ELB)用于向外界公开服务。您的集群使用弹性块存储(EBS)来存储持久数据。Amazon确保数据在线，并且对您的集群可用。</p><h2 id="c5d2" class="ng lv it bd lw nh ni dn ma nj nk dp me lh nl nm mg ll nn no mi lp np nq mk nr bi translated"><strong class="ak">真正的可扩展性</strong></h2><p id="f4b2" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">亚马逊EKS提供了比自托管Kubernetes更好的可扩展性。控制平面确保你的吊舱跨多个物理节点发射(如果你愿意的话)。如果任何节点关闭，您的应用程序仍将在线。但是如果您管理自己的集群，您必须确保不同的虚拟机(EC2实例)位于不同的可用性区域。</p><p id="0c4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你不能保证这一点，那么在同一个物理服务器上运行不同的pods不会给你多少容错能力。</p><h2 id="e4e9" class="ng lv it bd lw nh ni dn ma nj nk dp me lh nl nm mg ll nn no mi lp np nq mk nr bi translated"><strong class="ak">鞭炮</strong></h2><p id="416f" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">虚拟机实例运行在虚拟化的硬件上，即软件伪装成硬件。这带来了更好的整体云基础架构安全性。但这是以较慢的性能为代价的，因为有一层软件正在虚拟化硬件资源。</p><p id="7aa4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，容器是轻量级的，因为它们都运行在相同的操作系统上，并共享相同的底层内核。这导致了更快的启动时间，并且没有性能影响！直接在硬件上运行容器被称为裸机上的容器。</p><p id="66d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在撰写本文时，亚马逊是极少数提供裸机容器的公共云之一。也就是说；您可以使用Amazon Fargate在裸机上运行容器，而不是启动EC2实例，然后在这些虚拟机中运行您的容器。</p><p id="dd6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">他们通过鞭炮来管理这一点，这是一种非常轻量级的基于Linux KVM的技术，它在一个microVM中运行Docker容器。这些为您提供了容器的性能和虚拟机的安全性。这就是亚马逊上的EKS优于任何竞争对手的原因。</p><h1 id="c56f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">剖析亚马逊EKS集群</h1><p id="f8ae" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">EKS集群由两大部分组成:</p><h2 id="b897" class="ng lv it bd lw nh ni dn ma nj nk dp me lh nl nm mg ll nn no mi lp np nq mk nr bi translated"><strong class="ak">控制平面</strong></h2><p id="1bc2" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">该服务完全由AWS管理，因为在您的帐户中不会创建EC2实例，而您可能会期望etcd、kube-apiserver和其他组件出现。相反，所有这些都是抽象的，控制平面只是作为一个服务器向您公开，即kube-api。</p><p id="0785" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">控制飞机每小时收费0.10美元。幸运的是，你可以使用单个集群运行多个应用程序，随着你推出更多的应用程序或服务，这个价格不会上涨。</p><h2 id="ce11" class="ng lv it bd lw nh ni dn ma nj nk dp me lh nl nm mg ll nn no mi lp np nq mk nr bi translated"><strong class="ak">节点</strong></h2><p id="410a" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">反过来，这些可以被管理EC2实例或在AWS Fargate上运行。托管EC2实例选项是AWS代表您启动EC2实例，并让控制平面控制这些实例。这些在您的帐户中显示为EC2实例。<a class="ae na" href="https://aws.amazon.com/ec2/pricing/" rel="noopener ugc nofollow" target="_blank">标准EC2定价</a>适用于这些节点。</p><p id="17ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于AWS Fargate，没有需要管理的EC2实例；相反，你的吊舱直接在裸机上运行，你只需为吊舱运行的时间付费。我强烈推荐为您的新集群使用AWS Fargate，我们也将在下一节创建集群时使用它。AWS Fargate定价详情可在<a class="ae na" href="https://aws.amazon.com/fargate/pricing/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="b1a9" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">在AWS上创建一个Kubernetes集群</h1><p id="7237" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">开始使用EKS最简单的方法是使用命令行实用程序，包括:</p><ol class=""><li id="039e" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated"><a class="ae na" href="https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html" rel="noopener ugc nofollow" target="_blank"> AWS-CLI </a>与您的AWS帐户互动</li><li id="1a94" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated"><a class="ae na" href="https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html" rel="noopener ugc nofollow" target="_blank"> eksctl </a>创建、管理和删除EKS集群，以及</li><li id="e0a9" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated"><a class="ae na" href="https://docs.aws.amazon.com/eks/latest/userguide/install-kubectl.html" rel="noopener ugc nofollow" target="_blank"> kubectl </a>与Kubernetes集群本身进行交互。</li><li id="81ed" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated"><a class="ae na" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"> docker </a>创建并封装你的应用程序。</li><li id="acbd" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated"><a class="ae na" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>账户托管您的Docker图片(免费层也可以)</li></ol><h1 id="a9b0" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">设置AWS CLI</h1><p id="944b" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">AWS为用户提供了命令行工具和直接从终端配置AWS资源的可能性。它直接与AWS API对话，并代表您提供资源。这消除了使用AWS Web控制台手动配置EKS集群或其他资源的需要。使用CLI实现自动化也减少了流程出错的可能性。</p><p id="550b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们在本地计算机上设置AWS CLI。</p><p id="34bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">1.首先，获取适合您的系统的CLI二进制文件。</p><p id="0227" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.AWS CLI允许您快速地以编程方式在AWS的云中创建资源，而不必在仪表板中瞎折腾。这也消除了人为错误。</p><p id="7767" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">3.为了创建和管理EKS集群，您需要是root用户或具有管理员访问权限的IAM用户。</p><p id="31df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">4.为了简洁起见，我将使用我的root帐户。单击AWS Web控制台右上角的个人资料，然后选择“我的安全凭证”</p><p id="9d79" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，导航到主菜单中的“访问键”选项卡。</p><p id="fc32" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">单击“创建新的访问密钥”按钮。</p><p id="7130" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后点击新弹出窗口中的“显示访问密钥”,小心地将访问ID和秘密访问密钥复制到您的本地计算机上。请务必注意，秘密访问密钥只会显示一次。</p><p id="10af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">5.打开您的终端，键入以下命令，出现提示时，输入您的访问密钥ID和秘密访问密钥:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="9e10" class="ng lv it nt b gy nx ny l nz oa">$ aws configure<br/>AWS Access Key ID [None]:<br/>AWS Secret Access Key [None]:<br/>Default region name [None]:us-east-2<br/>Default output format [None]: text</span></pre><p id="bfd2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还将被要求选择一个默认区域。我们将选择<code class="fe ob oc od nt b">us-east-2</code>，但您可以选择对您最有利的地区(或离您最近的地区)。在我们的例子中，默认的输出格式是文本。</p><p id="cc50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您的配置和凭证位于您的主目录的子目录中。aws和eksctl都将使用AWS和来管理资源。现在，我们可以继续创建集群了。</p><h1 id="92a6" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">2.使用Fargate创建和删除EKS集群</h1><p id="a0c7" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">要创建包含Fargate节点的集群，只需运行以下命令:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="a7a3" class="ng lv it nt b gy nx ny l nz oa">$ eksctl create cluster --name my-fargate-cluster --fargate</span></pre><p id="f4a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！该命令可能需要大约15–30分钟才能完成，在运行时，它会在您的终端中输出为启动群集而创建的所有资源。</p><p id="1f36" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以在下面看到一个示例输出:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="e1c5" class="ng lv it nt b gy nx ny l nz oa">2021-08-01 18:14:41 [ℹ]  eksctl version 0.59.0<br/>2021-08-01 18:14:41 [ℹ]  using region us-east-2<br/>2021-08-01 18:14:42 [ℹ]  setting availability zones to [us-east-2c us-east-2a us-east-2b]<br/>2021-08-01 18:14:42 [ℹ]  subnets for us-east-2c - public:192.168.0.0/19 private:192.168.96.0/19<br/>2021-08-01 18:14:42 [ℹ]  subnets for us-east-2a - public:192.168.32.0/19 private:192.168.128.0/19<br/>2021-08-01 18:14:42 [ℹ]  subnets for us-east-2b - public:192.168.64.0/19 private:192.168.160.0/19<br/>2021-08-01 18:14:42 [ℹ]  nodegroup "ng-5018c8ae" will use "" [AmazonLinux2/1.20]<br/>2021-08-01 18:14:42 [ℹ]  using Kubernetes version 1.20<br/>2021-08-01 18:14:42 [ℹ]  creating EKS cluster "my-fargate-cluster" in "us-east-2" region with Fargate profile and managed nodes<br/>2021-08-01 18:14:42 [ℹ]  will create 2 separate CloudFormation stacks for cluster itself and the initial managed nodegroup<br/>2021-08-01 18:14:42 [ℹ]  if you encounter any issues, check CloudFormation console or try 'eksctl utils describe-stacks --region=us-east-2 --cluster=my-fargate-cluster'<br/>2021-08-01 18:14:42 [ℹ]  CloudWatch logging will not be enabled for cluster "my-fargate-cluster" in "us-east-2"<br/>2021-08-01 18:14:42 [ℹ]  you can enable it with 'eksctl utils update-cluster-logging --enable-types={SPECIFY-YOUR-LOG-TYPES-HERE (e.g. all)} --region=us-east-2 --cluster=my-fargate-cluster'<br/>2021-08-01 18:14:42 [ℹ]  Kubernetes API endpoint access will use default of {publicAccess=true, privateAccess=false} for cluster "my-fargate-cluster" in "us-east-2"<br/>2021-08-01 18:14:42 [ℹ]  2 sequential tasks: { create cluster control plane "my-fargate-cluster", 3 sequential sub-tasks: { 2 sequential sub-tasks: { wait for control plane to become ready, create fargate profiles }, 1 task: { create addons }, create managed nodegroup "ng-5018c8ae" } }<br/>2021-08-01 18:14:42 [ℹ]  building cluster stack "eksctl-my-fargate-cluster-cluster"<br/>2021-08-01 18:14:44 [ℹ]  deploying stack "eksctl-my-fargate-cluster-cluster"<br/>2021-08-01 18:15:14 [ℹ]  waiting for CloudFormation stack "eksctl-my-fargate-cluster-cluster"<br/>2021-08-01 18:46:17 [✔]  EKS cluster "my-fargate-cluster" in "us-east-2" region is ready</span></pre><p id="2bd2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如输出所示，大量资源正在加速运转。包括所选可用性区域的几个新的专用子网、几个IAM角色以及Kubernetes集群的控制平面本身。如果你不知道这些是什么，不要惊慌！这些细节都是eksctl的问题。当我们使用以下命令删除集群时，您将会看到:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="6a28" class="ng lv it nt b gy nx ny l nz oa">$ eksctl delete cluster --name my-fargate-cluster<br/>2021-08-01 23:00:35 [ℹ]  eksctl version 0.59.0<br/>## A lot more output here<br/>2021-08-01 23:06:30 [✔]  all cluster resources were deleted</span></pre><p id="4984" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将拆除群集，删除所有节点组、专用子网和其他相关资源，并确保您不会有像ELB这样的资源闲置，浪费您的额外资金。</p><h1 id="5f6f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">将你的申请归档</h1><p id="c559" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">现在我们知道了如何创建和销毁集群。但是我们如何在其中启动应用程序呢？该过程的第一步是将您的应用程序容器化。</p><p id="4154" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要将应用程序容器化，您需要知道如何为它编写docker文件。Docker文件是容器编排系统构建Docker映像的蓝图。要编写Dockerfile文件，您需要:</p><ol class=""><li id="9ce9" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated">选择一个基础图像。例如，根据您的应用程序所依赖的内容，您可以将Docker映像用于Node或Python。</li><li id="20e5" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">在容器中选择一个工作目录。</li><li id="d6ce" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">将项目的构建工件(编译的二进制文件、脚本和库)转移到该目录</li><li id="ff14" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">为启动的容器设置要运行的命令。因此，举例来说，如果你有一个起点为<code class="fe ob oc od nt b">app.js</code>的节点应用程序，你将有一个命令CMD [ <code class="fe ob oc od nt b">node</code>，<code class="fe ob oc od nt b">app.js</code> ]作为你的docker文件的最后一行。这将启动你的应用程序。</li></ol><p id="2210" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个docker文件位于您项目的git repo的根目录中，使得CI系统可以轻松地为每个增量更新运行自动构建、测试和部署。</p><p id="c696" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们使用一个用Express.js编写的示例应用程序作为测试项目，在我们的EKS集群上进行dockerized和部署。</p><h1 id="d2c2" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">示例应用程序</h1><p id="4694" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">让我们创建一个简单的<code class="fe ob oc od nt b">express.js</code>应用程序，部署在我们的集群上。创建一个名为<code class="fe ob oc od nt b">example-app</code>的目录:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="9c57" class="ng lv it nt b gy nx ny l nz oa">$ mkdir example-app</span></pre><p id="fe93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，创建一个名为<code class="fe ob oc od nt b">app.js</code>的文件，它将包含以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="f665" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个<code class="fe ob oc od nt b">app.js</code>应用程序是一个简单的web服务器，它监听<code class="fe ob oc od nt b">port 80</code>并用<code class="fe ob oc od nt b">Hello World</code>进行响应！</p><h1 id="0d1e" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">创建Dockerfile文件</h1><p id="679d" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">为了将应用程序作为容器来构建和运行，我们在example-app目录中创建了一个名为Dockerfile的文件，其中包含以下内容:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="2729" class="ng lv it nt b gy nx ny l nz oa">FROM node:latest<br/>WORKDIR /app<br/>RUN npm install express<br/>COPY app.js .<br/>CMD ["node", "app.js"]</span></pre><p id="2bb2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将指示Docker引擎使用node:来自<a class="ae na" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>的最新基本映像来构建我们的容器。要构建Docker映像，请运行以下命令:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="83d7" class="ng lv it nt b gy nx ny l nz oa">$ docker build -t username/example-app</span></pre><p id="73c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，标签用户名需要替换为您实际的Docker Hub用户名。我们将在关于容器注册的章节中讨论为什么会出现这种情况。</p><h1 id="607e" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">在本地运行应用程序</h1><p id="53f9" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">一旦构建了映像，我们就可以测试它是否能在本地工作。运行以下命令启动容器:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="72c4" class="ng lv it nt b gy nx ny l nz oa">$ docker run --rm -d -p 80:80 --name test-container username/example-app<br/>$ curl <a class="ae na" href="http://localhost/" rel="noopener ugc nofollow" target="_blank">http://localhost</a><br/>Hello World!</span></pre><p id="ae84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这似乎是按计划进行的。让我们看看集装箱日志是怎么说的。使用特定容器的名称运行docker log命令:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="6899" class="ng lv it nt b gy nx ny l nz oa">$ docker logs test-container<br/>This app is listening at <a class="ae na" href="http://localhost/" rel="noopener ugc nofollow" target="_blank">http://localhost:80</a></span></pre><p id="ba0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，无论我们的express.js应用程序向标准输出写入了什么(使用console.log ),都会通过容器运行时记录下来。这有助于在测试和生产环境中调试您的应用程序。</p><h1 id="c6e8" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">关于容器注册表</h1><p id="850c" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">默认情况下，Docker图片保存在<a class="ae na" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>上。Docker Hub就像是Docker图片的GitHub。你可以对你的图片进行版本化、标记，并把它们放在Docker Hub上</p><p id="be27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">node:latest标记意味着最新发布的Node.js版本将用于这个映像的构建过程。对于Node.js的特定版本，如LTS版本，还有其他可用的标记。您可以随时访问特定图像的Docker Hub页面，查看可供您下载的各种选项。</p><p id="a64e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如GitLab和GitHub一样，您可以使用各种容器注册表。AWS有他们的<a class="ae na" href="https://aws.amazon.com/ecr/" rel="noopener ugc nofollow" target="_blank">弹性容器库</a>或ECR解决方案，<a class="ae na" href="https://cloud.google.com/container-registry" rel="noopener ugc nofollow" target="_blank"> GCP有类似的东西</a>，但是我们将在本文中坚持使用Docker Hub，因为它是Docker安装的默认设置。</p><p id="28f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了推送在上一步中构建的映像，我们首先登录我们的Docker Hub帐户:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="fb34" class="ng lv it nt b gy nx ny l nz oa">$ docker login</span></pre><p id="e172" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并在出现提示时提供您的用户名和密码。<br/>成功登录后，使用以下命令推送您的映像:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="9dad" class="ng lv it nt b gy nx ny l nz oa">$ docker push username/example-app</span></pre><p id="e8a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，示例应用程序Docker映像已准备好供EKS集群使用。</p><p id="8e3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另请阅读:<a class="ae na" href="https://www.clickittech.com/devops/kubernetes-alternatives/" rel="noopener ugc nofollow" target="_blank"> Kubernetes替代品和竞争对手</a></p><h1 id="da5a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">部署应用程序</h1><p id="491e" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">为了部署我们刚刚构建的应用程序，我们将使用kubectl，这是一个与Kubernetes控制平面交互的命令行工具。如果您已经使用eksctl创建了您的集群，那么kubectl已经通过了身份验证，可以与您的EKS集群对话。</p><p id="b48e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将创建一个名为eks-configs的目录，该目录将存储我们的集群和在其上运行的应用程序的期望状态的描述。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="9665" class="ng lv it nt b gy nx ny l nz oa">$ mkdir eks-configs</span></pre><h1 id="9b9d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">创建部署</h1><p id="e110" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">为了部署该应用程序，我们将创建一个<a class="ae na" href="https://kubernetes.io/docs/concepts/workloads/" rel="noopener ugc nofollow" target="_blank"> Kubernetes工作负载</a>，其类型为<a class="ae na" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank"> Deployment </a>，非常适合无状态应用程序。创建一个文件<code class="fe ob oc od nt b">example-deployment.yaml</code>并将以下内容添加到其中。</p><p id="6df1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正在使用的图像是Docker Hub的用户名/示例应用程序。请确保将“用户名”替换为您实际的Docker Hub用户名。运行此应用程序时，您将获得以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="5df2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用kubectl，我们可以如下启动这个部署:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="3b42" class="ng lv it nt b gy nx ny l nz oa">$ kubectl create -f example-deployment.yaml</span></pre><p id="8a79" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这创建了一个<code class="fe ob oc od nt b">Deployment</code>对象，这是Kubernetes逻辑处理运行在一个或多个pod上的应用程序(或应用程序的一部分)的方式。</p><p id="ef6a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们添加了一些元数据，包括部署的名称和标签，我们很快就会看到这些元数据将被集群的其他部分使用。此外，我们要求EKS发布示例应用程序容器的六个副本，以便在我们的集群中运行。</p><p id="34b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据您的需要，您可以动态地更改该数字——这将允许您放大或缩小应用程序。拥有许多副本还可以确保高可用性，因为您的pod跨多个节点进行调度。</p><p id="041d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用以下命令获取集群上运行的部署和pod的列表(在默认命名空间中):</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="5ee1" class="ng lv it nt b gy nx ny l nz oa">$ kubectl get pods<br/>$ kubectl get deployments</span></pre><h1 id="3d44" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">创建服务</h1><p id="4d6b" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">部署已经创建，但是我们如何访问它呢？因为它跨多个pod运行，那么另一个应用程序(比如用户的浏览器)如何访问它呢？我们不能让直接的DNS条目指向pod，因为它们是短暂的和可替换的。此外，将集群的内部组件直接暴露给外界并不是最安全的想法。</p><p id="a11b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相反，我们将创建一个Kubernetes服务。有几种类型的Kubernetes服务，你可以了解他们<a class="ae na" href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types" rel="noopener ugc nofollow" target="_blank">在这里</a>。我们现在将使用AWS的弹性负载平衡器，或ELB服务。</p><p id="affc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为旁注，这是一个具有大多数Kubernetes特性的通用主题。它们与底层云基础架构集成得非常好。例如，将EC2实例用于节点，将ELB用于向外界公开服务，将AWS的VPC用于集群内联网，将弹性块存储用于高可用性持久存储。</p><p id="0620" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过创建一个<code class="fe ob oc od nt b">example-service.yaml</code>文件并在其中添加以下内容来创建一个负载平衡器类型的Kubernetes服务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="30ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后使用以下命令创建它:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="d2ac" class="ng lv it nt b gy nx ny l nz oa">$ kubectl create -f example-service.yaml</span></pre><p id="8954" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Kubernetes服务将在几分钟后启动并运行，我们终于可以与我们的应用程序对话了。首先，我们需要获得服务的“外部IP”。这通常不是IP，而是指向我们服务的FQDN，如下所示:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="d582" class="ng lv it nt b gy nx ny l nz oa">$ kubectl get svc<br/>NAME              TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)        AGE<br/>example-service   LoadBalancer   10.100.88.189   <a class="ae na" href="http://a78b55c6b3a574e61accfe13b324bd08-1728675516.us-east2.elb.amazonaws.com/" rel="noopener ugc nofollow" target="_blank">a78b55c6b3a574e61accfe13b324bd08-1728675516.us-east2.elb.amazonaws.com</a>   80:31058/TCP   5m33<br/>kubernetes        ClusterIP      10.100.0.1      &lt;none&gt;  43/TCP        33m</span></pre><p id="5c66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该服务可以从您的web浏览器或使用命令行工具(如cURL)轻松访问，如下所示</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="0912" class="ng lv it nt b gy nx ny l nz oa">$ curl<br/>a78b55c6b3a574e61accfe13b324bd08-1728675516.us-east-2.elb.amazonaws.co<br/>Hello World!</span></pre><p id="28f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！现在，您可以开始将您的应用程序一部分一部分地推广到AWS EKS平台。将集群数量保持在最低水平，以降低成本，并将应用的不同部分划分到不同的Dockerized微服务中。</p><h1 id="a4c6" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">清除AWS上的Kubernetes</h1><p id="5e93" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">为了清理我们以前拥有的资源，我们将按照与创建它们相反的顺序删除每个Kubernetes资源，然后删除整个集群。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="976d" class="ng lv it nt b gy nx ny l nz oa">$ kubectl delete -f example-service.yaml<br/>$ kubectl delete -f example-deployment.yaml<br/>$ eksctl delete cluster --name my-fargate-cluster</span></pre><p id="2d96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过访问web用户界面，仔细检查没有留下任何资源。对于EKS和EC2服务，将web UI中的区域切换到<code class="fe ob oc od nt b">~/.aws/config</code>，并确保周围没有任何未使用的ELB/EC2实例或Kubernetes集群。</p><h1 id="0fc6" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="0469" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">如果你正在考虑一个托管的Kubernetes解决方案，在AWS上运行Kubernetes是最好的选择。可扩展性出色，升级过程流畅。通过使用AWS运行Kubernetes，您可以获得与其他AWS服务的紧密集成，这也是一个巨大的好处。</p><p id="3f5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在AWS上运行Kubernetes将把你的公司从管理基础设施的麻烦中解放出来，让你有更多的时间专注于核心产品。这将减少对额外It人员的需求，同时，使您的产品能够满足用户群不断增长的需求。</p><p id="a712" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">原帖:<a class="ae na" href="https://www.clickittech.com/devops/kubernetes-on-aws/?utm_source=kubernetes+on+aws&amp;utm_id=Blogs" rel="noopener ugc nofollow" target="_blank">https://www.clickittech.com/devops/kubernetes-on-aws/?UTM _ source = kubernetes+on+AWS&amp;UTM _ id = Blogs</a></p></div></div>    
</body>
</html>