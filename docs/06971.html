<html>
<head>
<title>How to useRef to Fix React Performance Issues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Ref来修复React性能问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-useref-to-fix-react-performance-issues-4d92a8120c09?source=collection_archive---------1-----------------------#2020-11-23">https://betterprogramming.pub/how-to-useref-to-fix-react-performance-issues-4d92a8120c09?source=collection_archive---------1-----------------------#2020-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b5d9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及我们如何阻止React上下文重新渲染所有内容</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8954e317fabb327e1d09b4ede7b661d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ychn1nsfNdNxt4fRIz2qkw@2x.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片。</p></figure><p id="7be7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Refs是React中很少使用的功能。如果你读过<a class="ae lr" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank">官方React指南</a>，它们被作为典型React数据流的“逃生出口”介绍，并警告要谨慎使用它们。它们主要被宣传为访问组件底层DOM元素的正确方法。</p><p id="9591" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是除了钩子的概念，React团队还引入了<code class="fe ls lt lu lv b"><a class="ae lr" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank">useRef</a></code>钩子，它扩展了这个功能:</p><blockquote class="lw"><p id="9f12" class="lx ly iq bd lz ma mb mc md me mf lq dk translated">"<code class="fe ls lt lu lv b">useRef()</code>比<code class="fe ls lt lu lv b">ref</code>属性更有用。用它来保存任何围绕着的可变值<a class="ae lr" href="https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables" rel="noopener ugc nofollow" target="_blank">很方便，就像在类中使用实例字段一样。”— </a><a class="ae lr" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank"> React的文档</a></p></blockquote><p id="a551" class="pw-post-body-paragraph kv kw iq kx b ky mg jr la lb mh ju ld le mi lg lh li mj lk ll lm mk lo lp lq ij bi translated">虽然我在新的Hook APIs发布时忽略了这一点，但事实证明它非常有用。</p><p id="ab55" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">👉<a class="ae lr" href="#f356" rel="noopener ugc nofollow">点击此处跳到解决方案和代码片段</a>。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="1d62" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">问题是</h1><p id="7098" class="pw-post-body-paragraph kv kw iq kx b ky nk jr la lb nl ju ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated">我是一名软件工程师，正在开发一款开源的React应用程序，它将电子表格用户界面与Firestore和Firebase的全部功能结合在一起。它的一个关键特性是侧边抽屉，这是一个类似表单的UI，用于编辑滑过主表的单行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/db2ca98c3fce85290e9bdb0db0d2901c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1h6w52_v9rflIGJ9WlDPGw.gif"/></div></div></figure><p id="0cc0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当用户单击表格中的一个单元格时，可以打开侧边的抽屉来编辑该单元格对应的行。换句话说，我们在侧边抽屉中呈现的内容取决于当前选择的行——这应该存储在state中。</p><p id="b1dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将该状态放入侧抽屉组件本身是最合理的位置，因为当用户选择不同的单元格时，应该只有<em class="nq">影响侧抽屉。然而:</em></p><ul class=""><li id="f6c3" class="nr ns iq kx b ky kz lb lc le nt li nu lm nv lq nw nx ny nz bi translated">我们需要从table组件中<em class="nq">设置</em>这个状态。我们使用<code class="fe ls lt lu lv b"><a class="ae lr" href="https://github.com/adazzle/react-data-grid" rel="noopener ugc nofollow" target="_blank">react-data-grid</a></code>来呈现表格本身，它接受一个回调属性，每当用户选择一个单元格时就会调用这个属性。目前，这是应对这一事件的唯一方法。</li><li id="6720" class="nr ns iq kx b ky oa lb ob le oc li od lm oe lq nw nx ny nz bi translated">但是侧抽屉和桌子组件是兄弟组件，所以它们不能直接访问彼此的状态。</li></ul><p id="0f62" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">React的建议是<a class="ae lr" href="https://reactjs.org/docs/lifting-state-up.html" rel="noopener ugc nofollow" target="_blank">将这个状态</a>提升到组件最接近的共同祖先(在本例中是<code class="fe ls lt lu lv b">TablePage</code>)。但是我们决定不把州搬到这里，因为:</p><ol class=""><li id="5bab" class="nr ns iq kx b ky kz lb lc le nt li nu lm nv lq of nx ny nz bi translated"><code class="fe ls lt lu lv b">TablePage</code>不包含任何状态，主要是桌子和侧抽屉组件的容器，它们都没有任何道具。我们宁愿保持这种方式。</li><li id="efaf" class="nr ns iq kx b ky oa lb ob le oc li od lm oe lq of nx ny nz bi translated">我们已经通过一个位于组件树根附近的<a class="ae lr" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文</a>共享了许多“全局”数据，我们认为将这个状态添加到中央数据存储是有意义的。</li></ol><p id="6990" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nq">注意:即使我们把状态放在</em> <code class="fe ls lt lu lv b"><em class="nq">TablePage</em></code> <em class="nq">中，我们还是会遇到下面同样的问题。</em></p><p id="f127" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">问题是每当用户选择一个单元格或打开侧抽屉时，对这个全局上下文的更新会导致整个应用程序重新呈现。这包括主表组件，它可以一次显示几十个单元格，每个单元格都有自己的编辑器组件。这将导致大约650毫秒的渲染时间，这足以在侧抽屉的打开动画中看到明显的延迟。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/13c689aad6ec6aba54ace51667fcce21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DPrtPDYRTq3IBR9_Hsh6dQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">请注意点击“打开”按钮和侧面抽屉动画打开之间的延迟。</p></figure><p id="7ffa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这背后的原因是上下文的一个关键特性，也是为什么在React中使用比在全局JavaScript变量中使用更好的原因:</p><blockquote class="lw"><p id="a027" class="lx ly iq bd lz ma mb mc md me mf lq dk translated">“每当提供者的<code class="fe ls lt lu lv b">value</code>属性发生变化时，作为提供者后代的所有消费者都将重新呈现。”— <a class="ae lr" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React的文档</a></p></blockquote><p id="cbd0" class="pw-post-body-paragraph kv kw iq kx b ky mg jr la lb mh ju ld le mi lg lh li mj lk ll lm mk lo lp lq ij bi translated">虽然这种对React的状态和生命周期的挂钩到目前为止为我们提供了很好的服务，但我们现在似乎搬起石头砸了自己的脚。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="310a" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">啊哈时刻</h1><p id="d712" class="pw-post-body-paragraph kv kw iq kx b ky nk jr la lb nl ju ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated">在选定<code class="fe ls lt lu lv b">useRef</code>之前，我们首先探索了几种不同的解决方案(来自<a class="ae lr" href="https://github.com/facebook/react/issues/15156#issuecomment-474590693" rel="noopener ugc nofollow" target="_blank">丹·阿布拉莫夫关于这个问题的帖子</a>):</p><ol class=""><li id="7944" class="nr ns iq kx b ky kz lb lc le nt li nu lm nv lq of nx ny nz bi translated">拆分上下文(即创建一个新的<code class="fe ls lt lu lv b">SideDrawerContext</code> ) —表格仍然需要使用新的上下文，当侧面抽屉打开时，新的上下文仍然会更新，<a class="ae lr" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">导致表格不必要地重新呈现</a>。</li><li id="ec1e" class="nr ns iq kx b ky oa lb ob le oc li od lm oe lq of nx ny nz bi translated">将表格组件包装在<code class="fe ls lt lu lv b">React.memo</code>或<code class="fe ls lt lu lv b">useMemo</code>中——表格仍然需要调用<code class="fe ls lt lu lv b">useContext</code>来访问侧面抽屉的状态，并且<a class="ae lr" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank">两个API都不会阻止它导致重新呈现</a>。</li><li id="41b4" class="nr ns iq kx b ky oa lb ob le oc li od lm oe lq of nx ny nz bi translated">记住用于呈现表格的<code class="fe ls lt lu lv b">react-data-grid</code>组件——这会给我们的代码带来更多的冗长。我们还发现它阻止了<em class="nq">必要的</em>重新渲染，要求我们花费更多的时间来修复或重新构建我们的代码，仅仅是为了实现侧抽屉。</li></ol><p id="6c81" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在通读Hook APIs和<code class="fe ls lt lu lv b">useMemo</code>的时候，我终于发现了关于<code class="fe ls lt lu lv b">useRef</code>的那一点:</p><blockquote class="lw"><p id="20e6" class="lx ly iq bd lz ma mb mc md me mf lq dk translated">"<code class="fe ls lt lu lv b">useRef()</code>比<code class="fe ls lt lu lv b">ref</code>属性更有用。用它来保存任何围绕的可变值<a class="ae lr" href="https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables" rel="noopener ugc nofollow" target="_blank">很方便，就像在类中使用实例字段一样。”— </a><a class="ae lr" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank"> React的文档</a></p></blockquote><p id="768a" class="pw-post-body-paragraph kv kw iq kx b ky mg jr la lb mh ju ld le mi lg lh li mj lk ll lm mk lo lp lq ij bi translated">更重要的是:</p><blockquote class="lw"><p id="5033" class="lx ly iq bd lz ma mb mc md me mf lq dk translated">"<code class="fe ls lt lu lv b">useRef</code> <em class="og">在其内容发生变化时</em>不会通知您。改变<code class="fe ls lt lu lv b">.current</code>属性<strong class="ak">不会导致重新渲染</strong>。”— <a class="ae lr" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank"> React的文档</a></p></blockquote><p id="3fdf" class="pw-post-body-paragraph kv kw iq kx b ky mg jr la lb mh ju ld le mi lg lh li mj lk ll lm mk lo lp lq ij bi translated">这时我突然想到:我们不需要存储侧抽屉的状态。我们只需要引用设置该状态的函数。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="f356" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">解决方案</h1><ol class=""><li id="7960" class="nr ns iq kx b ky nk lb nl le oh li oi lm oj lq of nx ny nz bi translated">将打开和单元状态保存在侧抽屉中。</li><li id="a9fc" class="nr ns iq kx b ky oa lb ob le oc li od lm oe lq of nx ny nz bi translated">创建对这些状态的引用，并将其存储在上下文中。</li><li id="93ab" class="nr ns iq kx b ky oa lb ob le oc li od lm oe lq of nx ny nz bi translated">当用户单击一个单元格时，使用表中的ref调用set state函数(在侧抽屉内)。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/1c665744b0b71c140048ca8ac8d90740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c-pLVaF283NbO5MlFqmzjw@2x.png"/></div></div></figure><p id="3057" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面的代码是Rowy上使用的代码的缩写版本，包括ref:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="c2b0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nq">注意:由于函数组件在重新渲染时运行整个函数体，每当</em> <code class="fe ls lt lu lv b"><em class="nq">cell</em></code> <em class="nq">或</em> <code class="fe ls lt lu lv b"><em class="nq">open</em></code> <em class="nq">状态更新(并导致重新渲染)，</em> <code class="fe ls lt lu lv b"><em class="nq">sideDrawerRef</em></code> <em class="nq">在</em> <code class="fe ls lt lu lv b"><em class="nq">.current</em></code> <em class="nq">中总是有最新的值。</em></p><p id="242a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种解决方案被证明是最好的，因为:</p><ol class=""><li id="452c" class="nr ns iq kx b ky kz lb lc le nt li nu lm nv lq of nx ny nz bi translated">当前单元格和打开状态存储在侧边抽屉组件本身中，这是放置它的最合理的位置。</li><li id="8481" class="nr ns iq kx b ky oa lb ob le oc li od lm oe lq of nx ny nz bi translated">当需要时，表格组件可以访问其兄弟的状态<em class="nq">。</em></li><li id="6b00" class="nr ns iq kx b ky oa lb ob le oc li od lm oe lq of nx ny nz bi translated">当当前单元格或打开状态被更新时，它只会触发侧面抽屉组件的重新呈现，而不会触发整个应用程序中的任何其他组件。</li></ol><p id="ce81" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在GitHub 上的Rowy <a class="ae lr" href="https://github.com/rowyio/rowy/blob/6e81191fc26714c4c212bae19cfc4c16440c322f/src/components/SideDrawer/index.tsx#L37" rel="noopener ugc nofollow" target="_blank">中看到这是如何使用的。</a></p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="2c3c" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">何时使用Ref</h1><p id="8df9" class="pw-post-body-paragraph kv kw iq kx b ky nk jr la lb nl ju ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated">但是，这并不意味着您应该继续将这种模式用于您构建的所有东西。当您需要在特定时间访问或更新另一个组件的状态，但您的组件不依赖于该状态或基于该状态进行渲染时，最好使用它。React的提升状态和单向数据流的核心概念，无论如何都足以覆盖大部分app架构。</p><p id="2ffa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>