<html>
<head>
<title>Make Your Workflows Better With This Classic Unix Tool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用这款经典的Unix工具改善您的工作流程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/make-your-data-science-workflows-better-with-this-classic-unix-tool-d9adc87ae2f5?source=collection_archive---------16-----------------------#2022-02-02">https://betterprogramming.pub/make-your-data-science-workflows-better-with-this-classic-unix-tool-d9adc87ae2f5?source=collection_archive---------16-----------------------#2022-02-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3185" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">数据管道的生成和生成文件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4e7174d97dec476f4549a1f7f6ef60da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WkTDKW7TyOwahM9dV29Nkg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">意大利佛罗伦萨。图片作者。</p></figure><p id="e29d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">make</code>是与<code class="fe lr ls lt lu b">grep</code>和<code class="fe lr ls lt lu b">ssh</code>同辈的经典命令行程序。</p><p id="985b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个经受住时间考验的强大工具，<code class="fe lr ls lt lu b">make</code>可以在任何进行严肃计算的终端中使用。最初用作构建自动化工具— <code class="fe lr ls lt lu b">make</code>可以用于任何涉及运行程序和制作文件的工作流。</p><p id="cc71" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">make</code>是一款智能工具，支持强大的工作流和数据管道管理。</p><p id="a1cd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在数据项目中并不常用——作为一名数据工程师，我发现它对于管理和运行数据工作流非常有价值。这篇文章主要关注在数据科学项目中使用<code class="fe lr ls lt lu b">make</code>——同样的一般原则也适用于其他涉及运行命令和制作文件的软件项目。</p><p id="3aa3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文将向您展示如何在现代数据项目中使用这一经典工具。</p><h1 id="7af7" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">最终目的地</h1><p id="535f" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">我们从我们将结束的地方开始，在<code class="fe lr ls lt lu b">Makefile</code>我们将在这篇文章中共同发展:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="1118" class="mw lw iq lu b gy mx my l mz na"># Makefile<br/><br/>all: ./data/clean.json<br/><br/>./data/raw.json: ./data/raw.json ./ingest.py<br/>	mkdir -p data<br/>	./ingest.py<br/><br/>./data/clean.json: ./data/raw.json ./clean.py<br/>	./clean.py</span></pre><p id="d27d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在说不通也不用担心。</p><p id="2593" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">到最后你会明白这一切是如何运作的！</p><h1 id="8639" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">注释</h1><p id="0ada" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">简单地说一下，确保我们在同一页上。</p><p id="f386" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Shell命令以<code class="fe lr ls lt lu b">$</code>开头，shell输出显示如下。</p><p id="0c4f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">文件名位于代码块的顶部，与文件的开头相隔一行。</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="b286" class="mw lw iq lu b gy mx my l mz na">file.name </span><span id="e8c5" class="mw lw iq lu b gy nc my l mz na">first_line_of_file - commonly a shebang like #!/usr/bin/env python3 <br/>second_line_of_file</span></pre><p id="518c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">外壳代码块与<code class="fe lr ls lt lu b">zsh</code>一起在<code class="fe lr ls lt lu b">MacOS</code>上运行，并且与<code class="fe lr ls lt lu b">bash</code>兼容。使用<code class="fe lr ls lt lu b">3.8.10</code>运行Python代码。</p><h1 id="1453" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">Makefile的剖析</h1><p id="9c0c" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated"><code class="fe lr ls lt lu b">Makefile</code>由三部分组成:</p><ol class=""><li id="429e" class="nd ne iq kx b ky kz lb lc le nf li ng lm nh lq ni nj nk nl bi translated">目标——您试图创建的文件(或一个<code class="fe lr ls lt lu b">PHONY</code>目标——稍后将详细介绍)，</li><li id="0c0b" class="nd ne iq kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated">依赖项—需要在目标之前运行的其他目标，</li><li id="44bc" class="nd ne iq kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated">工作流程——实现目标所需的一系列步骤。</li></ol><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="5c68" class="mw lw iq lu b gy mx my l mz na">target: dependencies<br/>&lt;TAB&gt;workflow step 1<br/>&lt;TAB&gt;workflow step 2</span></pre><p id="fac6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个<code class="fe lr ls lt lu b">Makefile</code>的强大之处在于能够让目标依赖于其他目标。</p><p id="8096" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面这个简单的<code class="fe lr ls lt lu b">Makefile</code>展示了一个简单的管道，有一个依赖关系——<code class="fe lr ls lt lu b">end</code><em class="nb">依赖</em> <code class="fe lr ls lt lu b">begin</code>。</p><p id="5348" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">begin</code>和<code class="fe lr ls lt lu b">end</code>都是<code class="fe lr ls lt lu b">PHONY</code>目标——这意味着它们不创建文件:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="dc04" class="mw lw iq lu b gy mx my l mz na"># Makefile<br/><br/>.PHONY: begin end<br/><br/>begin:<br/>  echo "The beginning is the end"<br/><br/>end: begin<br/>  echo "Der Anfang is das Ende"</span></pre><p id="46ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个<code class="fe lr ls lt lu b">Makefile</code>可以代表&amp;管理复杂的数据管道。</p><p id="1c43" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">单个工作流可以做任何您可以用shell做的事情，甚至使单个工作流变得任意强大。</p><h1 id="8088" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">运行Makefile</h1><p id="9cec" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">以下面的<code class="fe lr ls lt lu b">Makefile</code>为例，它创建了一个空的<code class="fe lr ls lt lu b">data.html</code>文件:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="7c7b" class="mw lw iq lu b gy mx my l mz na"># Makefile<br/><br/>data.html:<br/>	echo "making data.html"<br/>	touch data.html</span></pre><p id="56db" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">运行没有目标的<code class="fe lr ls lt lu b">make</code>将运行第一个目标——在我们的例子中是唯一的目标，<code class="fe lr ls lt lu b">data.html</code>。</p><p id="93ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">make</code>打印出它运行的命令:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="3cf5" class="mw lw iq lu b gy mx my l mz na">$ make<br/>making data.html<br/>touch data.html</span></pre><p id="ecb4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们再次运行这个，我们会看到<code class="fe lr ls lt lu b">make</code>以不同的方式运行——它不会再次生成<code class="fe lr ls lt lu b">data.html</code>:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="e632" class="mw lw iq lu b gy mx my l mz na">$ make<br/>make: `data.html' is up to date.</span></pre><p id="8447" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们重置了我们的管道(通过删除<code class="fe lr ls lt lu b">data.html</code>，运行<code class="fe lr ls lt lu b">make</code>将再次运行我们的管道:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="9dc1" class="mw lw iq lu b gy mx my l mz na">$ rm data.html; make<br/>making data.html<br/>touch data.html</span></pre><p id="d00d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面我们已经展示了<code class="fe lr ls lt lu b">make</code> - <strong class="kx ir">智能重新执行流水线</strong>的一个有用特性。</p><p id="b64d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在幕后，<code class="fe lr ls lt lu b">make</code>利用文件上的时间戳来理解运行(或不运行)什么。</p><p id="88ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们过于兴奋之前，让我们设定一下在数据项目中使用<code class="fe lr ls lt lu b">make</code>的动机。</p><h1 id="c154" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">为什么数据科学要用<code class="fe lr ls lt lu b">make</code>？</h1><h2 id="f014" class="mw lw iq bd lx nr ns dn mb nt nu dp mf le nv nw mh li nx ny mj lm nz oa ml ob bi translated">1.工作流文档</h2><p id="c2ae" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">记录项目工作流程是一个好的数据项目的基本素质。</p><p id="0c67" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">大多数项目只需要一个<code class="fe lr ls lt lu b">Makefile</code>——让这个文件成为你的项目的一个自然的中心位置(仅次于<code class="fe lr ls lt lu b">README.md</code>)。这是你的项目围绕的一个锚。</p><p id="5754" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">A <code class="fe lr ls lt lu b">Makefile</code>是优秀的文档——机器可读和可执行的——最好的文档。像任何文本文件一样，在git这样的源代码控制工具中跟踪变化是很容易的。</p><p id="1750" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在一系列<code class="fe lr ls lt lu b">make</code>目标中创建您的数据科学工作流还有一个好处，就是使您的管道更加模块化——鼓励shell或Python脚本的功能分解。</p><h2 id="30f0" class="mw lw iq bd lx nr ns dn mb nt nu dp mf le nv nw mh li nx ny mj lm nz oa ml ob bi translated">2.免费CLI</h2><p id="589e" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">一个<code class="fe lr ls lt lu b">Makefile</code>与它运行的shell环境紧密集成。</p><p id="ea6f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过shell环境变量或命令行参数在运行时轻松配置变量。</p><p id="b1da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面的<code class="fe lr ls lt lu b">Makefile</code>有两个变量- <code class="fe lr ls lt lu b">NAME</code>和<code class="fe lr ls lt lu b">COUNTRY</code>:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="4715" class="mw lw iq lu b gy mx my l mz na"># Makefile<br/><br/>all:<br/>	echo "$(NAME) is from $(COUNTRY)"</span></pre><p id="3829" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以用两种不同的方法设置两个变量:</p><ul class=""><li id="babf" class="nd ne iq kx b ky kz lb lc le nf li ng lm nh lq od nj nk nl bi translated"><code class="fe lr ls lt lu b">EXPORT name=adam</code> -将我们的变量<code class="fe lr ls lt lu b">NAME</code> by设置为一个shell环境变量，</li><li id="3018" class="nd ne iq kx b ky nm lb nn le no li np lm nq lq od nj nk nl bi translated"><code class="fe lr ls lt lu b">COUNTRY=NZ</code> -我们的<code class="fe lr ls lt lu b">COUNTRY</code>变量通过一个参数传递给<code class="fe lr ls lt lu b">make</code>命令。</li></ul><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="79b9" class="mw lw iq lu b gy mx my l mz na">$ export NAME=adam; make COUNTRY=NZ <br/>echo "$(NAME) is from $(COUNTRY)"<br/>adam is from NZ</span></pre><h2 id="f491" class="mw lw iq bd lx nr ns dn mb nt nu dp mf le nv nw mh li nx ny mj lm nz oa ml ob bi translated">3.智能流水线重新执行</h2><p id="dabc" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">我们已经看到了智能管道重新执行的功能——这是一种不重新运行不需要运行的代码的强大方法。</p><p id="5071" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">make</code>使用文件上的时间戳来跟踪要重新运行(或不重新运行)的内容——它不会重新运行已经运行过的代码，如果目标的依赖关系发生变化，它会重新运行。</p><p id="3d98" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这可以为您节省大量时间——在选择模型时，无需重新运行昂贵的数据接收和清理步骤。</p><h1 id="166b" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">我们的管道</h1><p id="4429" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">我们将构建一个数据管道——使用Python脚本模拟真实的数据任务——数据从左向右流动。</p><p id="b4bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的摄取步骤创建原始数据，我们的清理步骤创建干净的数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/d36a1c3e29fa7d09fc228fe24d7e12b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UJLdUffL15sjXPFk.png"/></div></div></figure><p id="c36a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以根据管道的数据工件和源代码之间的依赖关系来看同一个管道——依赖关系从右向左流动:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/b50440faf9ea3a1da263e2127e5617a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*piL3lvgxaoGB5dWS.png"/></div></div></figure><p id="b715" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的干净数据依赖于用来生成它的代码和原始数据。我们的原始数据只依赖于摄取Python脚本。</p><h1 id="2f8f" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">在<code class="fe lr ls lt lu b">Makefile</code>发展我们的管道</h1><h2 id="2cf6" class="mw lw iq bd lx nr ns dn mb nt nu dp mf le nv nw mh li nx ny mj lm nz oa ml ob bi translated">0.我们的管道组件</h2><p id="c86c" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">让我们看看管道中的两个组件——摄取步骤和清理步骤，这两个步骤都是Python脚本。</p><p id="4ac3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">ingest.py</code>将一些数据写入JSON文件:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="d703" class="mw lw iq lu b gy mx my l mz na">#  ingest.py<br/><br/>#!/usr/bin/env python3<br/>from datetime import datetime<br/>import json<br/>from pathlib import Path<br/><br/>fi = Path.cwd() / "data" / "raw.json"<br/>fi.parent.mkdir(exist_ok=True)<br/>fi.write_text(json.dumps({"data": "raw", "ingest-time": datetime.utcnow().isoformat()}))</span></pre><p id="1c77" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以运行这个Python脚本并使用<code class="fe lr ls lt lu b">cat</code>来查看它的JSON输出:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="f076" class="mw lw iq lu b gy mx my l mz na">$ ./ingest.py; cat data/raw.json<br/>{"data": "raw", "ingest-time": "2021-12-19T13:57:53.407280"}</span></pre><p id="b5d0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">clean.py</code>获取生成的原始数据，并将<code class="fe lr ls lt lu b">data</code>字段更新为<code class="fe lr ls lt lu b">clean</code>:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="50d3" class="mw lw iq lu b gy mx my l mz na">#  clean.py<br/><br/>#!/usr/bin/env python3<br/>from datetime import datetime<br/>import json<br/>from pathlib import Path<br/><br/>data = json.loads((Path.cwd() / "data" / "raw.json").read_text())<br/>data["data"] = "clean"<br/>data["clean-time"] = datetime.utcnow().isoformat()<br/>fi = Path.cwd() / "data" / "clean.json"<br/>fi.write_text(json.dumps(data))</span></pre><p id="1d64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以再次使用<code class="fe lr ls lt lu b">cat</code>来查看我们清理步骤的结果:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="8bb4" class="mw lw iq lu b gy mx my l mz na">$ ./clean.py; cat data/clean.json<br/>{"data": "clean", "ingest-time": "2021-12-19T13:57:53.407280", "clean-time": "2021-12-19T13:59:47.640153"</span></pre><h2 id="8f4f" class="mw lw iq bd lx nr ns dn mb nt nu dp mf le nv nw mh li nx ny mj lm nz oa ml ob bi translated">1.跟踪管道依赖关系</h2><p id="a5e0" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">让我们从运行两级数据管道的<code class="fe lr ls lt lu b">Makefile</code>开始。</p><p id="0231" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们已经利用了在我们的管道阶段之间创建依赖关系的能力，使得我们的<code class="fe lr ls lt lu b">clean</code>目标依赖于我们的<code class="fe lr ls lt lu b">raw</code>目标。</p><p id="0f21" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还包含了一个顶级元目标<code class="fe lr ls lt lu b">all</code>，它依赖于我们的<code class="fe lr ls lt lu b">clean</code>步骤:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="7d9c" class="mw lw iq lu b gy mx my l mz na">#  Makefile<br/><br/>all: clean<br/><br/>raw:<br/>	mkdir -p data<br/>	./ingest.py<br/><br/>clean: raw<br/>	./clean.py</span></pre><p id="4a4b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过运行<code class="fe lr ls lt lu b">make</code>从终端使用这个<code class="fe lr ls lt lu b">Makefile</code>，这将运行我们的元目标<code class="fe lr ls lt lu b">all</code>:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="d2d6" class="mw lw iq lu b gy mx my l mz na">$ make<br/>mkdir -p data<br/>./ingest.py<br/>ingesting {'data': 'raw', 'ingest-time': '2021-12-19T14:14:54.765570'}<br/>./clean.py<br/>cleaning {'data': 'clean', 'ingest-time': '2021-12-19T14:14:54.765570', 'clean-time': '2021-12-19T14:14:54.922659'}</span></pre><p id="1e19" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们只运行管道的<code class="fe lr ls lt lu b">clean</code>步骤，我们将再次运行摄取和清理步骤。这是因为我们的清理步骤取决于数据接收的输出:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="9ae1" class="mw lw iq lu b gy mx my l mz na">$ make clean<br/>mkdir -p data<br/>./ingest.py<br/>ingesting {'data': 'raw', 'ingest-time': '2021-12-19T14:15:21.510687'}<br/>./clean.py<br/>cleaning {'data': 'clean', 'ingest-time': '2021-12-19T14:15:21.510687', 'clean-time': '2021-12-19T14:15:21.667561'}</span></pre><p id="9fbf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们只想重新运行我们的清洗步骤呢？我们的下一次<code class="fe lr ls lt lu b">Makefile</code>迭代将避免这种不必要的重复执行。</p><h2 id="e7b7" class="mw lw iq bd lx nr ns dn mb nt nu dp mf le nv nw mh li nx ny mj lm nz oa ml ob bi translated">2.跟踪管道输出</h2><p id="f80d" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">现在让我们改进我们的<code class="fe lr ls lt lu b">Makefile</code>，将我们的目标变成实际的文件——由目标生成的文件。</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="b834" class="mw lw iq lu b gy mx my l mz na">all: clean<br/><br/>./data/raw.json:<br/>	mkdir -p data<br/>	./ingest.py<br/><br/>./data/clean.json: ./data/raw.json<br/>	./clean.py</span></pre><p id="2502" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用<code class="fe lr ls lt lu b">rm -rf ./data</code>删除之前运行的任何输出，我们可以用<code class="fe lr ls lt lu b">make</code>运行完整的管道:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="8667" class="mw lw iq lu b gy mx my l mz na">$ rm -rf ./data; make<br/>mkdir -p data<br/>./ingest.py<br/>ingesting {'data': 'raw', 'ingest-time': '2021-12-27T13:56:30.045009'}<br/>./clean.py<br/>cleaning {'data': 'clean', 'ingest-time': '2021-12-27T13:56:30.045009', 'clean-time': '2021-12-27T13:56:30.193770'}</span></pre><p id="4d86" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，如果我们第二次运行<code class="fe lr ls lt lu b">make</code>，什么也不会发生:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="0e50" class="mw lw iq lu b gy mx my l mz na">$ make<br/>make: Nothing to be done for `all'.</span></pre><p id="4110" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们只想重新运行我们的清理步骤，我们可以删除之前的输出并再次运行我们的管道——因为<code class="fe lr ls lt lu b">make</code>知道它只需要使用现有的原始数据再次运行清理步骤:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="984d" class="mw lw iq lu b gy mx my l mz na">$ rm ./data/clean.json; make <br/>./clean.py<br/>cleaning {'data': 'clean', 'ingest-time': '2021-12-27T13:56:30.045009', 'clean-time': '2021-12-27T14:02:30.685974'}</span></pre><h2 id="e283" class="mw lw iq bd lx nr ns dn mb nt nu dp mf le nv nw mh li nx ny mj lm nz oa ml ob bi translated">3.跟踪源代码依赖关系</h2><p id="132c" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">我们将对管道进行的最后一项改进是跟踪对源代码的依赖。</p><p id="d2ab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们更新我们的<code class="fe lr ls lt lu b">clean.py</code>脚本来跟踪<code class="fe lr ls lt lu b">clean-date</code>:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="9a4c" class="mw lw iq lu b gy mx my l mz na">#  clean.py<br/><br/>#!/usr/bin/env python3<br/>from datetime import datetime<br/>import json<br/>from pathlib import Path<br/><br/>data = json.loads((Path.cwd() / "data" / "raw.json").read_text())<br/>data["data"] = "clean"<br/>data["clean-time"] = datetime.utcnow().isoformat()<br/>data["clean-date"] = datetime.utcnow().strftime("%Y-%m-%d")<br/>fi = Path.cwd() / "data" / "clean.json"<br/>fi.write_text(json.dumps(data))</span></pre><p id="3a8c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在是我们最后的管道:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="3f1d" class="mw lw iq lu b gy mx my l mz na"># Makefile<br/><br/>all: ./data/clean.json<br/><br/>./data/raw.json: ./data/raw.json ./ingest.py<br/>	mkdir -p data<br/>	./ingest.py<br/><br/>./data/clean.json: ./data/raw.json ./clean.py<br/>	./clean.py</span></pre><p id="e3bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的最后一步，仅更新我们的<code class="fe lr ls lt lu b">clean.py</code>脚本后，<code class="fe lr ls lt lu b">make</code>将再次运行我们的清理步骤:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="0614" class="mw lw iq lu b gy mx my l mz na">$ make<br/>./clean.py<br/>ingesting {'data': 'clean', 'ingest-time': '2021-12-27T13:56:30.045009', 'clean-time': '2021-12-27T14:10:06.799127', 'clean-date': '2021-12-27'}</span></pre><h1 id="a626" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">摘要</h1><p id="bb2b" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">就是这样！我们希望您喜欢学习一些关于<code class="fe lr ls lt lu b">make</code> &amp; <code class="fe lr ls lt lu b">Makefile</code>的知识，并乐于在您的数据工作中尝试它。</p><p id="7128" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">make</code>和<code class="fe lr ls lt lu b">Makefile</code>有更多的深度和复杂性——到目前为止你所看到的足以鼓励你在自己的项目中使用<code class="fe lr ls lt lu b">Makefile</code>时进行更多的实验和学习。</p><p id="f87c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这篇文章的要点是:</p><ul class=""><li id="6df9" class="nd ne iq kx b ky kz lb lc le nf li ng lm nh lq od nj nk nl bi translated"><code class="fe lr ls lt lu b">make</code>是一个强大的、普遍可用的工具，可以运行任意的shell工作流，</li><li id="947c" class="nd ne iq kx b ky nm lb nn le no li np lm nq lq od nj nk nl bi translated">一个<code class="fe lr ls lt lu b">Makefile</code>形成了一个项目执行的自然中心点，一个简单的CLI与shell很好地集成，</li><li id="9476" class="nd ne iq kx b ky nm lb nn le no li np lm nq lq od nj nk nl bi translated"><code class="fe lr ls lt lu b">make</code>可以智能地重新执行您的数据管道，跟踪代码和数据之间的依赖关系，避免重新运行已经运行的任务，成本高昂。</li></ul></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="0d6b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读！</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="345e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nb">原载于https://www.datasciencesouth.com</em><a class="ae oc" href="https://www.datasciencesouth.com/blog/make" rel="noopener ugc nofollow" target="_blank"><em class="nb"/></a><em class="nb">。</em></p></div></div>    
</body>
</html>