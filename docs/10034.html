<html>
<head>
<title>Auto-expanding Lists With SwiftUI in iOS 15</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iOS 15中使用SwiftUI自动扩展列表</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/auto-expanding-lists-with-swiftui-in-ios-15-c525c7c80e5e?source=collection_archive---------9-----------------------#2021-11-16">https://betterprogramming.pub/auto-expanding-lists-with-swiftui-in-ios-15-c525c7c80e5e?source=collection_archive---------9-----------------------#2021-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a00c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在SwiftUI中创建一个自动扩展列表可能比预期的要困难</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/30610493a147b5d0f76d236174a8c8ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XSqIkVHOkNi8zALp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">雅各布·基索在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0e95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI是苹果在2019年9月发布的声明式框架。它有望彻底改变我们编写应用的方式，不仅在iOS上，而且在macOS、watchOS和tvOS上。</p><p id="c368" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该框架的第一个版本是有限的，并且有一些性能问题。苹果故意带着这些问题<a class="ae ky" href="https://www.swiftbysundell.com/podcast/59" rel="noopener ugc nofollow" target="_blank">发布了它</a>:目标是收集来自社区的反馈，并与社区合作开发框架。</p><p id="c26a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两年过去了，框架改进了很多。它有新的功能，可以用来实现更复杂的ui和uxe。这可能是实现比基本东西更复杂的东西的好时机。</p><h1 id="651b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">目标</h1><p id="9472" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在今天的文章中，我想实现一个项目列表，用户只需使用键盘就可以无缝地修改它。</p><p id="9494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个列表可以用于许多用例:待办事项列表、目标列表、任务、杂货等等。目标是当用户按下键盘上的<code class="fe ms mt mu mv b">return</code>时添加条目，当用户点击<code class="fe ms mt mu mv b">delete</code>按钮时删除一个空条目。下面的视频展示了我们想要达到的目标。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/8173b27d61a20e027df0cc6c9788397e.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*WuEvO8e5irZ_h9kmFPr4vQ.gif"/></div></figure><p id="d602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总结一下我们想要的:</p><ol class=""><li id="2aea" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">列表以空元素开始。</li><li id="2a12" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">用户可以输入一些文本。</li><li id="a539" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">按下键盘上的<code class="fe ms mt mu mv b">return</code>，一个新的空白字段被添加到列表中，它应该被聚焦。作为一种可能的改进，只有当<code class="fe ms mt mu mv b">TextField</code>不为空时，我们才能添加新项目。</li><li id="1c73" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">如果用户删除了<code class="fe ms mt mu mv b">TextField</code>中的所有文本并再次按下<code class="fe ms mt mu mv b">delete</code>，我们想要删除当前的<code class="fe ms mt mu mv b">TextField</code>。</li><li id="ecaa" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">至少应该有一个空的<code class="fe ms mt mu mv b">TextField</code>供用户添加新元素。</li></ol><h1 id="a449" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最初的看法</h1><p id="52cb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们从视图的脚手架开始。视图的标题由标题和副标题组成。然后，一个<code class="fe ms mt mu mv b"><a class="ae ky" href="https://developer.apple.com/documentation/swiftui/form" rel="noopener ugc nofollow" target="_blank">Form</a></code>组件包含了<code class="fe ms mt mu mv b">TextField</code>的列表。</p><p id="f4f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe ms mt mu mv b">Form</code>是一个很好的"<em class="nl">容器，用于分组用于数据输入的控件，比如在设置或检查器中"-</em>引用文档。<em class="nl"> </em>它为其内容提供了依赖于平台的样式，就像<code class="fe ms mt mu mv b">List</code>一样。</p><p id="cf70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图显示了如果我们把一个<code class="fe ms mt mu mv b">TextField</code>变成一个<code class="fe ms mt mu mv b">Form</code>，变成一个<code class="fe ms mt mu mv b">List</code>，变成一个简单的<code class="fe ms mt mu mv b">VStack</code>，会发生什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/405a86195e5fb3241aa2388bb98aaa0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fWIuyIAYgSWL78AIycmcQg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表单(第一张图)、列表(第二张图)和VStack(第三张图)中的文本字段。</p></figure><p id="5058" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以看到，<code class="fe ms mt mu mv b">Form</code> s和<code class="fe ms mt mu mv b">List</code> s自动为我们应用了一些样式，节省了很多时间。</p><p id="c475" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从创建SwiftUI <code class="fe ms mt mu mv b">View</code>的基本结构开始。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ae13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个代码片段中，我们正在创建<code class="fe ms mt mu mv b">View</code>的基本结构。我们在一些计算属性中提取了<code class="fe ms mt mu mv b">body</code>属性的内容，以保持其可读性。我们有一个标题属性、一个说明属性和一个表单属性。</p><p id="8cca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该表单目前为空，但我们很快就会填充它。</p><h2 id="0ed9" class="np lw it bd lx nq nr dn mb ns nt dp mf li nu nv mh lm nw nx mj lq ny nz ml oa bi translated">国家及其约束力</h2><p id="7c69" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于这个例子，我们想要跟踪用户可以为一天设置的一些目标。我们事先不知道用户将添加多少个目标，所以我们需要将它们存储在一个数组中。</p><p id="73aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们添加<code class="fe ms mt mu mv b">goals</code>属性并用<code class="fe ms mt mu mv b">@State</code>属性包装器标记它，这样<code class="fe ms mt mu mv b">View</code>就可以更新它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c6f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们总是希望至少有一个<code class="fe ms mt mu mv b">TextField</code>，数组以一个空目标开始。</p><p id="6d54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让<code class="fe ms mt mu mv b">View</code>更新数组，我们需要将它与<code class="fe ms mt mu mv b">View</code>绑定。主要方法是使用<code class="fe ms mt mu mv b"><a class="ae ky" href="https://developer.apple.com/documentation/swiftui/foreach" rel="noopener ugc nofollow" target="_blank">ForEach</a></code>组件。有两种不同的<code class="fe ms mt mu mv b">init</code> s:一种取常数范围；另一个获取我们可以在运行时更新的对象列表。</p><p id="d360" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目标列表的大小会随着用户的更新而增长，所以让我们使用第二个初始化器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="4a07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码中，我们添加了<code class="fe ms mt mu mv b">ForEach</code>组件。<code class="fe ms mt mu mv b">ForEach</code>要求所有项目都有唯一的<code class="fe ms mt mu mv b">id</code>。作为第一次尝试，我们可以使用目标本身:我们不想要一个重复的目标。但是，如果我们运行应用程序并尝试，我们会发现在每次输入之后，当前文本字段会失去焦点。</p><p id="b035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发生这种情况是因为我们正在修改也是标识符的目标。当状态改变时，SwiftUI更新屏幕并呈现其内容。该表单是一个新表单，它不再包含与具有焦点的表单具有相同标识符的项目。因此，<code class="fe ms mt mu mv b">TextField</code>失去焦点。</p><p id="95ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过给我们的目标分配一个稳定的标识符来解决这个问题。我们可以创建一个符合<code class="fe ms mt mu mv b">Identifiable</code>协议并包含目标的<code class="fe ms mt mu mv b">struct</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="33a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用一个<code class="fe ms mt mu mv b">struct</code>作为视图的状态，促使我们更新<code class="fe ms mt mu mv b">ForEach</code>。<code class="fe ms mt mu mv b">Goal</code>模型符合<code class="fe ms mt mu mv b">Identifiable</code>协议，并使用<code class="fe ms mt mu mv b">UUID</code>来跟踪<code class="fe ms mt mu mv b">Goal</code>的身份。因此，我们可以删除<code class="fe ms mt mu mv b">id:</code>参数，因为<code class="fe ms mt mu mv b">ForEach</code>能够自动推断出<code class="fe ms mt mu mv b">id</code>字段。然后，我们需要更新<code class="fe ms mt mu mv b">TextField</code>的绑定来绑定一个<code class="fe ms mt mu mv b">String</code>。</p><p id="828a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在运行应用程序，我们能够编辑文本字段而不会失去焦点，正如我们所预期的那样。</p><h2 id="0872" class="np lw it bd lx nq nr dn mb ns nt dp mf li nu nv mh lm nw nx mj lq ny nz ml oa bi translated">返回时添加新行</h2><p id="845b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于下一个需求，我们想在用户按下<code class="fe ms mt mu mv b">return</code>时添加一个新的<code class="fe ms mt mu mv b">TextField</code>和一个新的<code class="fe ms mt mu mv b">Goal</code>。有两种方法可以实现这一点:</p><ol class=""><li id="cdb9" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">使用<code class="fe ms mt mu mv b">TextField</code> <code class="fe ms mt mu mv b">init(_:text:onEditingChanged:onCommit:)</code>。每当用户按下<code class="fe ms mt mu mv b">return</code>时，就会调用<code class="fe ms mt mu mv b">onCommit</code>回调。这在iOS 15中已被弃用。</li><li id="45a7" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">使用<code class="fe ms mt mu mv b"><a class="ae ky" href="https://developer.apple.com/documentation/swiftui/view/onsubmit(of:_:)" rel="noopener ugc nofollow" target="_blank">onSubmit(of:_:)</a></code>视图修改器。iOS 15已经引入了这一功能。</li></ol><p id="fe22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了提高兼容性，为了支持更多的iOS版本，让我们坚持第一个选项。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="731b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第10行，我们添加了<code class="fe ms mt mu mv b">onCommit</code>闭包。当用户在列表的最后一个元素上提交操作时，会添加新元素。</p><p id="2fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行应用程序，它就能工作。然而，有一些奇怪的事情正在发生:一个新的项目被添加，但它没有焦点。我们需要手动点击元素来再次召唤键盘。</p><h2 id="560d" class="np lw it bd lx nq nr dn mb ns nt dp mf li nu nv mh lm nw nx mj lq ny nz ml oa bi translated">将焦点转移到新领域</h2><p id="0954" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在iOS 15之前，没有什么让我们处理焦点的事情。苹果只在新版iOS中引入了<code class="fe ms mt mu mv b">@FocusState</code>属性包装器和<code class="fe ms mt mu mv b">.focused</code>视图修改器。</p><p id="f81f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着遵循文档，看看我们是否能让它工作。</p><p id="af54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要一个标识我们的<code class="fe ms mt mu mv b">TextField</code>的hashable。每个<code class="fe ms mt mu mv b">TextField</code>都与一个<code class="fe ms mt mu mv b">Goal</code>相关联，该【】具有一个<code class="fe ms mt mu mv b">UUID</code>，即<code class="fe ms mt mu mv b">Hashable</code>。</p><p id="4966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们声明一个变量来保存<code class="fe ms mt mu mv b">@FocusState</code>。变量是<code class="fe ms mt mu mv b">private</code>并且是可选的，因为我们不允许任何组件获得焦点。</p><p id="f6d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步，我们需要首先添加<code class="fe ms mt mu mv b">.focused(_:equals:)</code>视图修改器到我们的组件中。然后，我们需要在创建新的<code class="fe ms mt mu mv b">TextField</code>时更新<code class="fe ms mt mu mv b">@FocusState</code>。最终的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="6981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我用这三个部分注释了代码。</p><ol class=""><li id="41bb" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated"><code class="fe ms mt mu mv b">@FocusState</code>的创造。</li><li id="2093" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe ms mt mu mv b">focusedGoal</code>的更新。</li><li id="cd68" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe ms mt mu mv b">.focused</code>视图修改器的应用。</li></ol><p id="bf87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行这个例子，它仍然不起作用:我们正在创建新聚焦的字段，同时我们在它上面设置焦点。SwiftUI无法在尚不存在的元素上设置焦点。</p><p id="5355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们要求在设置焦点状态之前执行run循环。代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="799d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个技巧是在第29行用<code class="fe ms mt mu mv b">RunLoop.current.run(until: Date())</code>完成的。这是可行的，因为主线程中发生的所有事情都在iOS调用的事件循环中执行<code class="fe ms mt mu mv b">RunLoop</code>。一般情况下，我们不应该关心这样的底层细节:系统为我们管理它。</p><p id="9328" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们必须确保组件已经被渲染。为此，我们要求run循环勾选一次来呈现列表。</p><blockquote class="ob oc od"><p id="9ad4" class="kz la nl lb b lc ld ju le lf lg jx lh oe lj lk ll of ln lo lp og lr ls lt lu im bi translated">注意:这种问题的另一个解决方法是插入一个小延迟。如果系统呈现表单的时间比我们预期的长，延迟方法就不起作用。</p></blockquote><p id="0a26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们设法实现了当用户按下<code class="fe ms mt mu mv b">return</code>时添加一个<code class="fe ms mt mu mv b">TextField</code>的需求，将焦点移到它上面。然而，我们添加了一个强大的<strong class="lb iu">约束</strong>:我们现在只支持iOS 15。</p><h2 id="4338" class="np lw it bd lx nq nr dn mb ns nt dp mf li nu nv mh lm nw nx mj lq ny nz ml oa bi translated">实现后退以删除行</h2><p id="d5dc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于下一个特性，我们希望在<code class="fe ms mt mu mv b">TextField</code>为空的情况下，当用户点击backspace时删除一行。如果这是唯一呈现的行，我们不会移除该行。</p><p id="2590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI没有提供任何实现这一点的方法。我们仍然可以做到这一点，但如果我们想留在苹果提供给我们的SwiftUI世界中，我们必须修补Objective-C运行时。</p><p id="7d79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案背后的理论是，每个SwiftUI <code class="fe ms mt mu mv b">TextField</code>都是从一个UIKit <code class="fe ms mt mu mv b">UITextField</code>开始实现的。<code class="fe ms mt mu mv b">UITextField</code>包含一个名为<code class="fe ms mt mu mv b">deleteBackward</code>的方法，每次用户点击退格键时都会调用这个方法。在UIKit应用程序中，我们可以子类化<code class="fe ms mt mu mv b">UITextField</code>来覆盖这个方法并实现自定义行为。</p><p id="f6fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这在SwiftUI中是不可能的，因为视图是结构化的，我们无法访问实现细节。但是，我们可以利用Objective-C运行时来用我们自己的实现替换默认的<code class="fe ms mt mu mv b">deleteBackward</code>实现。这种技术叫做<a class="ae ky" href="https://pspdfkit.com/blog/2019/swizzling-in-swift/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">搅打</strong> </a>。</p><p id="7f85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，该解决方案由以下步骤组成:</p><ol class=""><li id="b2e6" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">我们用一个方法创建一个扩展来模仿<code class="fe ms mt mu mv b">deleteBackward</code>。</li><li id="616b" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">我们将<strong class="lb iu">用原来的方法痛饮</strong>这个方法。</li><li id="b4c8" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">每当调用<strong class="lb iu"> swizzled </strong>方法时，我们会为按下的删除按钮发布一个值。</li><li id="b927" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">我们订阅了视图中发布者。</li><li id="6e43" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">当视图出现时，当它消失时，我们就开始调整方法。</li></ol><p id="3e4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着用代码把所有的东西放在一起。首先，我们创建<code class="fe ms mt mu mv b">UITextField+Extensions.swift</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><ul class=""><li id="631a" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu oh nd ne nf bi translated">在第1行，我们定义了<code class="fe ms mt mu mv b">UITextField</code>的扩展</li><li id="98cb" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu oh nd ne nf bi translated">在第7行，我们定义了<code class="fe ms mt mu mv b">swizzled_deleteBackward</code>方法。我们获取删除前后的<code class="fe ms mt mu mv b">TextField</code>内容，在中间调用原始的<code class="fe ms mt mu mv b">deleteBackward</code>。为了调用原来的<code class="fe ms mt mu mv b">deleteBackward</code>，我们实际上调用了<code class="fe ms mt mu mv b">swizzled_deleteBackward</code>。这不是递归:在重组之后，<code class="fe ms mt mu mv b">swizzle_deleteBackward</code>主体是最初的<code class="fe ms mt mu mv b">deleteBackward</code>实现。</li><li id="ba05" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu oh nd ne nf bi translated">在第13行，我们调用一个静态发布者来通知所有订阅者我们检测到一个删除。</li><li id="46ba" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu oh nd ne nf bi translated">在第17行，我们定义了要发布的数据结构和实际的发布者。</li></ul><p id="ef90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将扩展连接到<code class="fe ms mt mu mv b">GoalView</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><ul class=""><li id="68d4" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu oh nd ne nf bi translated">在第5行，我们实现了<code class="fe ms mt mu mv b">swizzle</code>方法。我们首先尝试检索<code class="fe ms mt mu mv b">deleteBackward</code>和<code class="fe ms mt mu mv b">swizzled_deleteBackward</code>方法的实现。然后，我们交换它们的实现。</li><li id="ebff" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu oh nd ne nf bi translated">在第27行，我们注册了<code class="fe ms mt mu mv b">UITextField.deletePublisher</code>来拦截任何删除。</li><li id="8513" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu oh nd ne nf bi translated">在第36行，我们实现了检测到删除时的逻辑。在删除行之前，需要检查一些先决条件:<br/>——文本<code class="fe ms mt mu mv b">before</code>和<code class="fe ms mt mu mv b">after</code>必须为空。<br/> -目标数大于1(我们总是至少需要一个<code class="fe ms mt mu mv b">TextField</code>)。<br/>——有重点的<code class="fe ms mt mu mv b">TextField</code>。<br/>如果满足所有这些前提条件，我们删除所需索引处的行，并将焦点移到列表中的前一行。</li><li id="e8f8" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu oh nd ne nf bi translated">在第59行和第60行，我们实际上混合了方法体。当视图出现时，我们需要这样做，以支持这种行为，当视图消失时，我们需要将方法体重置为它们的原始实现。</li></ul><p id="ceb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在运行该应用程序，它的行为就像我们实际想要的那样。</p><h2 id="3d4f" class="np lw it bd lx nq nr dn mb ns nt dp mf li nu nv mh lm nw nx mj lq ny nz ml oa bi translated">支持iOS 14，避免Swizzling</h2><p id="5b49" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们设法实现了我们想要的一切，但是代价是什么呢？</p><p id="034e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们放弃了对iOS 14和更低版本系统的支持，因为我们需要使用仅适用于iOS 15的<code class="fe ms mt mu mv b">@FocusState</code>属性包装器和<code class="fe ms mt mu mv b">.focused</code>修饰符。</p><p id="0561" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，我们正在修补Objective-C运行时。这种解决方案将在苹果保持由<code class="fe ms mt mu mv b">UITextField</code>支持的<code class="fe ms mt mu mv b">TextField</code>实现时起作用。如果苹果改变了<code class="fe ms mt mu mv b">TextField</code>的内部工作方式，这个解决方案可能会停止工作。</p><p id="b485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些问题的另一个解决方案是使用<code class="fe ms mt mu mv b"><a class="ae ky" href="https://developer.apple.com/documentation/swiftui/uiviewrepresentable" rel="noopener ugc nofollow" target="_blank">UIViewRepresentable</a></code>协议创建一个定制的SwiftUI组件。使用这个协议，我们可以创建一个UIKit组件，并将其包装在一个容器中，以便在SwiftUI中使用。</p><p id="5c7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的好处是我们可以完全控制新的组件。我们可以定义它的接口、行为和钩子。</p><p id="6b65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缺点是我们必须重新实现我们需要的每一个视图修改器:</p><ul class=""><li id="63cf" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu oh nd ne nf bi translated">我们需要手动实现如何处理焦点。</li><li id="8d88" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu oh nd ne nf bi translated">我们需要手动拦截所有我们感兴趣的事件。</li><li id="96c0" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu oh nd ne nf bi translated">我们还需要拦截和处理默认的SwiftUI修饰符:前景色、字体和所有其他属性。</li></ul><p id="7452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在这两种方法之间做出选择，您需要权衡利弊。正如工程中经常发生的那样，这是一个权衡取舍的问题。</p><h1 id="d5eb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="83de" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在今天的文章中，我们探讨了如何仅使用SwiftUI实现复杂的用户体验(UX)。</p><p id="5e36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们实现了一个自动扩展的列表<code class="fe ms mt mu mv b">TextView</code>,让用户只使用键盘就可以在列表中插入和删除条目。完整的代码可以在这里找到<a class="ae ky" href="https://gist.github.com/cipolleschi/2cc9acea222cd3e8e7afb93d2aa7ffdd" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="64c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了达成可行的解决方案，我们不得不做出很多妥协:</p><ol class=""><li id="00bc" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">我们必须只支持iOS 15。</li><li id="7c9c" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">我们必须修补一下<code class="fe ms mt mu mv b">RunLoop</code>。</li><li id="edfe" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">我们得痛饮一法<code class="fe ms mt mu mv b">UITextView</code>。</li></ol><p id="3209" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种探索的收获是，当我们实现标准UX时，SwiftUI是伟大和直观的，但对于高级体验，我们可能不得不与框架斗争。</p><p id="7e80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须从实现细节中提取，并且我们必须操纵它们。如果你有一些复杂的用例，我的建议是用UIKit实现它，或者用一种更快捷的UI友好的方式重新思考UX。</p></div></div>    
</body>
</html>