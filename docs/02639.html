<html>
<head>
<title>TypeScript and Jest: Testing Challenges</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript和Jest:测试挑战</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typescript-jest-testing-challenges-c010eaa8f3f2?source=collection_archive---------5-----------------------#2019-12-14">https://betterprogramming.pub/typescript-jest-testing-challenges-c010eaa8f3f2?source=collection_archive---------5-----------------------#2019-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b978" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我找到了用打字稿和笑话进行测试的圣杯</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/191006c579ace8eefbfaec05f7145f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AVl4t7aijBcQOugh7ivJHg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@zlg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">钟</a>在<a class="ae ky" href="https://unsplash.com/s/photos/test?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="f6fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将分享我对用<a class="ae ky" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>和TypeScript测试挑战的想法和见解。</p><p id="0a9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会深入讨论如何用Jest设置您的TypeScript项目，因为有许多指南，老实说，这相当简单。以下是一些例子:</p><ul class=""><li id="982e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://basarat.gitbooks.io/typescript/docs/testing/jest.html" rel="noopener ugc nofollow" target="_blank">git books上的笑话</a></li><li id="ec98" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://dev.to/muhajirdev/unit-testing-with-typescript-and-jest-2gln?source=post_page-6bf5db18119c" rel="noopener ugc nofollow" target="_blank">使用TypeScript和Jest进行单元测试</a></li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c4c7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">入门指南</h1><p id="96cb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">所以，一切都很好，你转向了Jest，你配置了TypeScript，<br/>并且你已经锁定并加载了一些测试！</p><p id="8bb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，像我一样，你可能会遇到一些挑战。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="efa2" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">模拟节点模块</h1><p id="6da4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">假设我有一个类<code class="fe nn no np nq b">UserApi</code>，它有一个获取用户的方法，例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/908d469c1d2f95511aca24abfa219546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*kuKw3xCAqDIL8-CbNxQ6Ug.png"/></div></figure><p id="bc75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该类在幕后使用<a class="ae ky" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>。当我测试那个类的时候，我不想调用服务器，如果它关闭了呢？</p><p id="1f1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在那种情况下我能做什么？嘲讽！</p><p id="651f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，我想模仿那个<code class="fe nn no np nq b">axios</code>对象，并控制调用<code class="fe nn no np nq b">get</code>时会发生什么。对于Jest，代码看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/0b526688ad1ce5e7fd5bf00fff5fd36d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*lt9FYcXTlm94nH4y5E3MHw.png"/></div></figure><pre class="kj kk kl km gt nt nq nu nv aw nw bi"><span id="b80c" class="nx mr it nq b gy ny nz l oa ob">jest.mock('axios')</span></pre><p id="eff7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行做的是告诉Jest:“嘿Jest，当你看到有人导入axios时，给它一个<a class="ae ky" href="https://jestjs.io/docs/en/es6-class-mocks#automatic-mock" rel="noopener ugc nofollow" target="_blank">自动模拟</a>。”</p><p id="6238" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好，酷，所以现在当代码调用<code class="fe nn no np nq b">axios.get</code>时，它不会触发任何代码，但我想要更多，我想决定<code class="fe nn no np nq b">get</code>将返回什么，以便测试多个场景。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/f0a351ccdc86f646b9843613ee704f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/1*7_MxujGXvG8uGCQU5Snf5g.gif"/></div></figure><p id="ac6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这正是这条线的作用。</p><p id="0701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我把axios当作一个被嘲笑的笑话对象，并从中获得智慧。<br/>基本上，我告诉它返回一个解析值为<code class="fe nn no np nq b">-&gt; data: stubUser</code>的承诺。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d37d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">清除和重置模拟</h1><p id="36bd" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果您在测试之间使用相同的模拟函数，并且您想要检查调用量，您必须重置模拟函数。</p><p id="f33a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会变得非常冗长:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/281d7c515d21f1211a7b050aed0f4b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*CAJnol28tOZfYfFZ6fETVg.png"/></div></figure><p id="f6a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我从<a class="ae ky" href="https://sinonjs.org/" rel="noopener ugc nofollow" target="_blank"> Sinon </a>来到Jest，在那里你有一个沙箱，你可以添加每个stub/mock，并在沙箱上调用reset，这将重置它的所有stub。</p><p id="a5cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，Jest有一个与Sinon相似的解决方案:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/f7530c03448df236ff194341cccb917a.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*GWDIYzRbOsyCG9D2ZEN9-w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jest中的清除、复位(如果启用了clearMocks jest配置，则可以移除清除、复位)</p></figure><p id="0fd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您甚至可以将<code class="fe nn no np nq b">clearMocks: true</code>添加到Jest配置中，它将在每次测试之前清除模拟！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="080a" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">嘲笑类型</h1><p id="ad71" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">使用依赖注入时，通常会有一个类似这样的类:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/14066a4350a324a0c1708b03e21c8766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*KMjm6oSr_vmi3ql-f6-zUA.png"/></div></div></figure><p id="0060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，像以前一样，我想测试<code class="fe nn no np nq b">UserApi</code>，但是我不想实际发送请求到服务器，所以你想做的是通过<code class="fe nn no np nq b">SuperRequest</code>的a类模拟实现。</p><p id="db26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试可能看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/1e602c29e8d483299fe35a8f426c7a30.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*HlHH9b0JAPvvYn7fVxFh-Q.png"/></div></figure><p id="7b50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能会变得冗长，每次你需要模拟一个接口时，你必须声明一个用<code class="fe nn no np nq b">jest.fn()</code>模拟函数实现它的对象。</p><p id="bddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输入<a class="ae ky" href="https://www.npmjs.com/package/jest-mock-extended" rel="noopener ugc nofollow" target="_blank"> jest-mock-extended </a>。</p><p id="adf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用jest-mock-extended，代码看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/714433d25a9d3beaee137d87dead7e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*woTOZlm5bu6eR54FJwebWw.png"/></div></figure><p id="4892" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干净多了！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0e67" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">模拟复杂的NPM/本地模块</h1><p id="a1ab" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">因此，到目前为止，我向您展示了我认为是在TypeScript项目中进行嘲弄的构件。</p><p id="476d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些场景中，要模拟的模块很复杂，简单的<code class="fe nn no np nq b">jest.mock(‘module_name’)</code>无法完成这项工作。</p><p id="9584" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最好的学习方法是从例子中学习。我将使用<a class="ae ky" href="https://www.npmjs.com/package/typeorm" rel="noopener ugc nofollow" target="_blank"> TypeORM </a>(一种与TypeScript配合良好的ORM)作为复杂模块的例子。</p><p id="05c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这段代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/c76d08966ef4014f3c95cf25727d268d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*9kOWq77TBomIk_VVfh7UoQ.png"/></div></figure><p id="0549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这段代码在逻辑上是没有意义的(为什么我要给一个结果加上<code class="fe nn no np nq b">fromDb</code>),但是为了我们的例子，它可以做到。</p><p id="7c98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那里有很多事情在进行，我们有一个<code class="fe nn no np nq b">getRepository</code>返回一个<code class="fe nn no np nq b">createQueryBuild</code>函数，该函数有构建器设计模式中的方法。</p><p id="3234" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后我们要控制<code class="fe nn no np nq b">getRawMany</code>返回什么，为什么？</p><p id="039f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的逻辑将<code class="fe nn no np nq b">fromDb</code>属性添加到结果中，因此我们希望控制逻辑的输入，它是从<code class="fe nn no np nq b">getRawMany</code>接收的。</p><p id="97db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试是什么样的？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/49ec8a3a86523a29f6ea1f8a66c5bb4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*IkWcGTv6Yj_LfT9alk_SxQ.png"/></div></figure><p id="e844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哦，哇，这太复杂了。因此..里面发生了什么事？</p><ul class=""><li id="d386" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第3–4行:为TypeORM接口准备模拟。</li><li id="05ea" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第6–18行:我们正在使用<a class="ae ky" href="https://jestjs.io/docs/en/es6-class-mocks#calling-jestmockdocsenjest-objectjestmockmodulename-factory-options-with-the-module-factory-parameter" rel="noopener ugc nofollow" target="_blank"> Jest的模块工厂</a>，它允许我们返回一个手动模拟(而不是Jest的自动模拟)。</li><li id="934e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第7–8行:告诉<code class="fe nn no np nq b">queryBuilder</code>当<code class="fe nn no np nq b">select</code>和<code class="fe nn no np nq b">where</code>被调用返回自身时，这就是你模仿构建器设计模式的方式。</li><li id="af85" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第9行:告诉存储库mock在调用<code class="fe nn no np nq b">createQueryBuilder</code>函数时返回<code class="fe nn no np nq b">queryBuilder</code> mock。</li><li id="be6d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第11–17行:声明调用以下代码时将返回的对象:</li></ul><pre class="kj kk kl km gt nt nq nu nv aw nw bi"><span id="ccb8" class="nx mr it nq b gy ny nz l oa ob">import typeorm from 'typeorm'</span></pre><ul class=""><li id="8939" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第12行:告诉<code class="fe nn no np nq b">getRepository</code>返回我们的库模拟。</li><li id="815d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第13–16行:与<code class="fe nn no np nq b">User</code>实体声明相关的嘲讽。</li><li id="8895" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第26行:告诉查询构建器mock在<code class="fe nn no np nq b">getRawMany</code> - &gt;我们的目标中返回什么！</li></ul><p id="5a41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等！我知道你在想什么，我真的需要在每个使用复杂模块的测试中编写所有的代码吗？</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0e3b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">让它变漂亮</h1><p id="601c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们能做的就是把TypeORM的嘲讽声明单独放到自己的文件里！Jest有一个内置的系统。</p><p id="2a06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在<code class="fe nn no np nq b">__mocks__/typeorm.ts</code>中创建一个文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/1c4684336c346d8344a59a7470162fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*CGstFJiLeKcvpRuLyJCETA.png"/></div></figure><p id="15aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们的测试文件将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/f044992e9a4c72d1830b287f5ad7c08a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*I1pi5Gjloh03gWInLyk9Iw.png"/></div></figure><p id="3a9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，<code class="fe nn no np nq b">qbuilderMock</code>不存在于<code class="fe nn no np nq b">typeorm</code>的类型中，但是我们的模拟版本<code class="fe nn no np nq b">typeorm</code>包含了它，所以测试将会运行。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0451" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="3295" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我希望这篇文章增加了您处理测试的工具库。</p></div></div>    
</body>
</html>