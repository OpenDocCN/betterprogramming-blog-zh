<html>
<head>
<title>Run Multiple Containers With Docker Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker Compose运行多个容器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/run-multiple-containers-with-docker-compose-9297957f7a3c?source=collection_archive---------8-----------------------#2022-04-27">https://betterprogramming.pub/run-multiple-containers-with-docker-compose-9297957f7a3c?source=collection_archive---------8-----------------------#2022-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dbb5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">并排执行多个容器而不互相干扰</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/2a25cd08ea6d8a037a7c08e106f11d44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*mAg1MJxj9iFd84e1RdcR3g.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">docker撰写</p></figure><h1 id="a4ec" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">Docker是什么？</h1><p id="a7b5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Docker受到欢迎有多种原因。其中之一是创建快速且易于部署的便携式容器。</p><p id="a785" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">正如在他们的<a class="ae mn" href="https://www.docker.com/resources/what-container/" rel="noopener ugc nofollow" target="_blank">网站</a>上提到的:“容器是将你的代码和任何其他依赖项打包在一起的东西，这样它就可以可靠地跨多个平台部署”。</p><p id="b1bd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这些容器可以在您的Windows、Mac和Linux上本地运行。其次，像AWS或Azure这样的主要云系统确实支持开箱即用。最后，它可以在任何可以安装和运行它的托管空间上使用。如果你想学习更多的Docker基础知识，并且需要docker CLI的备忘单，我在这里<a class="ae mn" href="https://www.daveops.co.in/post/docker-a-beginner-s-cheat-sheet-2022" rel="noopener ugc nofollow" target="_blank">写了一篇关于它的介绍性文章</a>。</p><p id="9013" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里我们将深入了解一些高级特性，比如运行多个容器。</p><h1 id="6ee4" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">Docker撰写</h1><p id="7464" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">使用docker-compose，可以用一个YAML文件配置和启动多个容器。如果您正在使用包含多种技术的技术堆栈，这将非常有帮助。举个例子，如果你正在做一个需要MySQL数据库、python for AI/ML、Node.js进行实时处理的项目。NET来提供API。为每个团队成员建立这样的环境是很麻烦的。Docker借助compose缓解了这个问题。</p><h1 id="d1e1" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">了解Docker撰写</h1><p id="2aa9" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe mo mp mq mr b">docker compose</code>是一个YAML文件，我们可以在其中配置不同类型的服务。然后，随着一个简单的命令，所有的集装箱都建立和发射。主要包括3个步骤</p><ul class=""><li id="9ab0" class="ms mt it lo b lp mi ls mj lv mu lz mv md mw mh mx my mz na bi translated">为每个项目生成一个docker文件。</li><li id="7efe" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated">在<code class="fe mo mp mq mr b">docker-compose.yml</code>文件中设置服务。</li><li id="f78a" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated">点燃容器。</li></ul><p id="0f25" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们现在要为上面的问题陈述实现一个解决方案。</p><h1 id="5713" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">先决条件</h1><p id="aef4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">人们可能希望安装所有的技术来运行上面讨论的MySQL、Python、NodeJS等技术栈。NET和PHP。相反，你所需要的是一个docker引擎运行。docker的最新版本安装了docker-compose。目前，不需要其他安装。</p><h1 id="32ee" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">路标</h1><p id="ab0f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在我们开始之前，先简单介绍一下我们要做的事情。我们将逐一解决每项技术。对于每种技术，我们将创建一个示例应用程序(除了MySQL)并为每种技术创建一个Dockerfile。然后我们将这个docker文件指向我们的docker-compose YAML文件。最后，我们将配置docker-compose，以便每个应用程序做它应该做的事情。</p><p id="586a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在我们开始创建一个名为super-app的文件夹之前。其次，创建一个<code class="fe mo mp mq mr b">docker-compose.yml</code>文件。在这个文件中，我们将配置所有的应用程序。所以让我们开始吧！</p><p id="fd6e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对于那些对代码感兴趣的人，你可以访问这里的<a class="ae mn" href="https://github.com/shenanigan/super-app-docker" rel="noopener ugc nofollow" target="_blank">库。</a></p><h1 id="8e2f" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">如何用Docker配置MySQL</h1><p id="2011" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在您的<code class="fe mo mp mq mr b">docker-compose.yml</code>文件中设置以下内容。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="4a4e" class="nk kv it mr b gy nl nm l nn no">version: '3.4'<br/>services:<br/>  super-app-db:<br/>    image: mysql:8.0.28<br/>    environment:<br/>      MYSQL_DATABASE: 'super-app'<br/>      MYSQL_ROOT_PASSWORD: '$SuperApp1'<br/>    ports:<br/>      - '3306:3306'<br/>    expose:<br/>      - '3306'</span></pre><p id="0d17" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在<code class="fe mo mp mq mr b">services</code>部分，我们将列出所有需要配置的应用类型。首先，我们配置了一个<code class="fe mo mp mq mr b">super-app-db</code> <em class="np"> </em>服务，该服务从8.0.28版本中提取MySQL的docker映像。接下来，我们指示容器创建一个名为<code class="fe mo mp mq mr b">super-app</code>的数据库，默认用户为<code class="fe mo mp mq mr b">root</code>，密码设置为<code class="fe mo mp mq mr b">$SuperApp1</code>。</p><p id="1724" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，由于MySQL的默认端口是3306，我们将其映射到容器的端口3306，并公开该端口以供访问。</p><p id="394c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一旦上面的文件被创建，运行下面的命令来创建你的docker镜像，并把它作为一个容器运行。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="0659" class="nk kv it mr b gy nl nm l nn no">docker compose up</span></pre><p id="184d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">MySQL图像将被拉，然后docker将旋转一个容器来运行这个图像。可以通过MySQL客户端连接MySQL服务器进行验证。如果没有，不用担心，我们将在下面看到如何通过我们的应用程序连接到它。只要容器没有被删除，表就会被持久化。</p><p id="491f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们配置下一个应用程序节点。</p><h1 id="6675" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">如何用Docker配置NodeJS</h1><p id="3cb5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们将创建一个非常简单的express节点应用程序。为此，在我们的<code class="fe mo mp mq mr b">super-app</code>文件夹中创建一个名为<code class="fe mo mp mq mr b">node</code>的文件夹。在<em class="np">节点</em>文件夹中添加以下三个文件<code class="fe mo mp mq mr b">server.js</code> <em class="np">、</em> <code class="fe mo mp mq mr b">package.json</code> <em class="np">和</em> <code class="fe mo mp mq mr b">Dockerfile</code>。</p><p id="c065" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">server.js</code> <em class="np"> : </em></p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="9faa" class="nk kv it mr b gy nl nm l nn no">const server = require("express")();<br/>server.listen(3000, async () =&gt; { });<br/>server.get("/super-app", async (_, response) =&gt; {<br/>    response.json({ "super": "app" });<br/>});</span></pre><p id="17b2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">package.json</code> <em class="np"> : </em></p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="8d85" class="nk kv it mr b gy nl nm l nn no">{<br/>    "name": "super-app-node",<br/>    "dependencies": {<br/>        "express": "^4.17.1"<br/>    }<br/>}</span></pre><p id="e6a9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">Dockerfile</code> <em class="np"> : </em></p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="ffaf" class="nk kv it mr b gy nl nm l nn no"># Download the slim version of node<br/>FROM node:17-slim</span><span id="6143" class="nk kv it mr b gy nq nm l nn no"># Set the work directory to app folder. <br/># We will be copying our code here<br/>WORKDIR /node</span><span id="4c51" class="nk kv it mr b gy nq nm l nn no">#Copy package.json file in the node folder inside container<br/>COPY package.json .</span><span id="a530" class="nk kv it mr b gy nq nm l nn no"># Install the dependencies in the container<br/>RUN npm install</span><span id="5654" class="nk kv it mr b gy nq nm l nn no"># Copy the rest of the code in the container<br/>COPY . .</span><span id="e294" class="nk kv it mr b gy nq nm l nn no"># Run the node server with server.js file<br/>CMD ["node", "server.js"]</span><span id="84df" class="nk kv it mr b gy nq nm l nn no"># Expose the service over PORT 3000<br/>EXPOSE 3000</span></pre><p id="41bc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里我们创建了一个节点应用程序，当我们在浏览器中点击<code class="fe mo mp mq mr b">localhost:3000/super-app</code>时，它会返回JSON。现在，我们不会直接从这个文件夹运行项目。</p><p id="659e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">相反，返回到您的<code class="fe mo mp mq mr b">super-app</code> <em class="np"> </em>文件夹，并将下面几行添加到您的<code class="fe mo mp mq mr b">docker-compose.yml</code>文件中。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="11ac" class="nk kv it mr b gy nl nm l nn no">super-app-node:<br/>    build: ./node<br/>    ports:<br/>      - "3000:3000"</span></pre><p id="7d2a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们只是提到创建一个名为<code class="fe mo mp mq mr b">super-app-node</code>的服务。我们还将容器端口映射到主机端口3000。最后，运行下面的命令来运行您的两个容器，即MySQL &amp; NodeJS。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="b4cb" class="nk kv it mr b gy nl nm l nn no">docker compose up</span></pre><p id="67eb" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，如果你点击<code class="fe mo mp mq mr b">localhost:3000/super-app</code>，你会看到一个回应<code class="fe mo mp mq mr b">{“super”:”app”}</code>。同时你的MySQL服务也是。耶！我们已经使用docker-compose文件成功创建了两个容器。</p><p id="88ec" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下一个应用程序。让我们创建一个与数据库交互并返回字符串列表的. NET应用程序。</p><h1 id="f1b3" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">如何配置。带有Docker的NET 6.0</h1><p id="c321" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们想要。NET应用程序来连接数据库。其次，它将通过GET API从数据库中获取数据，并在浏览器中显示出来。为此，在我们的<code class="fe mo mp mq mr b">super-app</code> <em class="np"> </em>项目中创建一个名为<code class="fe mo mp mq mr b">dotnet</code>的. NET项目。</p><p id="eef3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">由于写下创建和设置项目的所有步骤对于这个博客来说将是相当冗长的，并且也使这篇文章专注于docker，所以一篇单独的<a class="ae mn" href="https://arjavdave.com/2022/04/17/code-first-entity-framework-core-mysql/" rel="noopener ugc nofollow" target="_blank">文章</a>是关于如何实现上述目标的。</p><p id="2baa" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><a class="ae mn" href="https://arjavdave.com/2022/04/17/code-first-entity-framework-core-mysql/" rel="noopener ugc nofollow" target="_blank">文章</a>提供了使用EF Core创建连接到MySQL数据库的. NET 6应用程序的分步说明。EF Core是一个对象关系映射器，用于数据库和代码之间的通信。<strong class="lo iu"> <em class="np">注意:</em> </strong> <em class="np">忽略先决条件部分，因为我们已经有一个MySQL服务器在docker中运行。</em></p><h2 id="e26e" class="nk kv it bd kw nr ns dn la nt nu dp le lv nv nw lg lz nx ny li md nz oa lk ob bi translated">。网络应用变化</h2><p id="68d9" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">由于项目将在它们自己的容器中运行，它们不能通过<code class="fe mo mp mq mr b">localhost</code> url进行通信。因此为了。NET app与MySQL通信，需要更新连接字符串。为此，打开<code class="fe mo mp mq mr b">appsettings.json</code>和<code class="fe mo mp mq mr b">appsettings.Development.json</code> <em class="np"> </em>文件，并将<code class="fe mo mp mq mr b">DefaultConnection</code> <em class="np">中<em class="np">服务器</em>的<code class="fe mo mp mq mr b">localhost</code>替换为<code class="fe mo mp mq mr b">super-app-db</code>。</em></p><p id="e1a9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，容器中的应用程序不需要HTTPS重定向。因为HTTPS应该由服务器处理，所以从<code class="fe mo mp mq mr b">Program.cs</code>中删除下面一行。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="f0a5" class="nk kv it mr b gy nl nm l nn no">app.UseHttpsRedirection();</span></pre><h2 id="1f0d" class="nk kv it bd kw nr ns dn la nt nu dp le lv nv nw lg lz nx ny li md nz oa lk ob bi translated">码头工人</h2><p id="3d0c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">一旦项目建立并运行，就应该使用Dockerfile和docker-compose配置它在docker中运行。在<code class="fe mo mp mq mr b">dotnet</code>文件夹中用以下内容创建<code class="fe mo mp mq mr b">Dockerfile</code> <em class="np"> </em>。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="e0d8" class="nk kv it mr b gy nl nm l nn no">#Get the SDK image to build and publish the project<br/>FROM mcr.microsoft.com/dotnet/sdk:6.0 AS build-env<br/>WORKDIR /app</span><span id="e685" class="nk kv it mr b gy nq nm l nn no"># Copy everything<br/>COPY . ./</span><span id="74bd" class="nk kv it mr b gy nq nm l nn no"># Restore as distinct layers<br/>RUN dotnet restore</span><span id="2d2a" class="nk kv it mr b gy nq nm l nn no"># Build and publish a release<br/>RUN dotnet publish -c Release -o out</span><span id="983b" class="nk kv it mr b gy nq nm l nn no"># Build runtime image<br/>FROM mcr.microsoft.com/dotnet/aspnet:6.0<br/>WORKDIR /app</span><span id="5b39" class="nk kv it mr b gy nq nm l nn no">#Copy the build file to the app directory<br/>COPY --from=build-env /app/out .<br/>ENTRYPOINT ["dotnet", "dotnet.dll"]</span><span id="b449" class="nk kv it mr b gy nq nm l nn no">#Expose the port for communication<br/>EXPOSE 80</span></pre><p id="b3f3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在回到docker-compose.yml文件，添加下面的内容。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="fe2e" class="nk kv it mr b gy nl nm l nn no">super-app-dotnet:<br/>    build: ./dotnet<br/>    ports:<br/>    - "8080:80"</span></pre><p id="780e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里，我们将主机的端口8080绑定到容器的端口80。目前就这些。执行下面的命令来启动所有的容器。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="6fb2" class="nk kv it mr b gy nl nm l nn no">docker compose up</span></pre><p id="0546" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，在浏览器中点击<a class="ae mn" href="http://127.0.0.1:8080/api/job" rel="noopener ugc nofollow" target="_blank"> localhost:8080/api/job </a>。GET API将从数据库中获取作业列表。</p><h1 id="9677" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">如何用Docker配置Python</h1><p id="23c2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">到目前为止，您可能已经猜到在我们的<code class="fe mo mp mq mr b">super-app</code>文件夹中创建了一个<em class="np"> python </em>文件夹。</p><p id="f090" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">其次，创建我们项目需要的三个文件，分别是<code class="fe mo mp mq mr b">ai-ml.py</code>、<code class="fe mo mp mq mr b">requirements.txt</code>和<code class="fe mo mp mq mr b"><em class="np">Dockerfile</em></code>，内容如下。</p><p id="cd58" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">ai-ml.py</code>:</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="a8ed" class="nk kv it mr b gy nl nm l nn no">import matplotlib.pyplot as plt<br/>import pandas as pd<br/>from scipy import signal</span><span id="2ee1" class="nk kv it mr b gy nq nm l nn no">if __name__ == "__main__":<br/>    print("All working good")</span></pre><p id="eed9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">requirements.txt</code>:</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="9ea0" class="nk kv it mr b gy nl nm l nn no">pandas<br/>scipy<br/>matplotlib</span></pre><p id="447e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">Dockerfile</code>:</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="998b" class="nk kv it mr b gy nl nm l nn no"># Get the python image<br/>FROM python:3.7.13-slim</span><span id="970d" class="nk kv it mr b gy nq nm l nn no"># Switch to app directory<br/>WORKDIR /app</span><span id="90f2" class="nk kv it mr b gy nq nm l nn no"># Copy the requirements in to the app<br/>COPY requirements.txt ./</span><span id="7bd2" class="nk kv it mr b gy nq nm l nn no"># Install dependencies<br/>RUN pip install --no-cache-dir -r requirements.txt</span><span id="76c7" class="nk kv it mr b gy nq nm l nn no"># Copy everything else<br/>COPY . .</span><span id="7b6b" class="nk kv it mr b gy nq nm l nn no">#Run the python script<br/>CMD [ "python", "./ai-ml.py" ]</span></pre><p id="1c7d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，回到<code class="fe mo mp mq mr b">docker-compose.yml</code>文件，添加下面的内容。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="4e1c" class="nk kv it mr b gy nl nm l nn no">super-app-python:<br/>    build: ./python</span></pre><p id="a490" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">就这么简单。因为这只是一个简单的脚本，它将运行一次，然后容器将退出。但是容器的日志将显示<em class="np">所有工作正常</em>打印出来。这就是Python的全部内容。</p><h1 id="59f6" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">如何用Docker配置PHP</h1><p id="3f8c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">用docker设置PHP是最简单的。创建两个文件<code class="fe mo mp mq mr b">index.php</code>和<code class="fe mo mp mq mr b">Dockerfile</code> <em class="np">，如下图。</em></p><p id="043f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">index.php</code> <em class="np"> : </em></p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="ba4e" class="nk kv it mr b gy nl nm l nn no">&lt;?php echo "I am running in a container."; ?&gt;</span></pre><p id="cc0a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">Dockerfile</code> <em class="np"> : </em></p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="0d23" class="nk kv it mr b gy nl nm l nn no"># Get the php apache image<br/>FROM php:8.0-apache</span><span id="1d07" class="nk kv it mr b gy nq nm l nn no"># Switch to app directory<br/>WORKDIR /var/www/html</span><span id="4355" class="nk kv it mr b gy nq nm l nn no"># Copy everything<br/>COPY . .</span><span id="3d37" class="nk kv it mr b gy nq nm l nn no">EXPOSE 80</span></pre><p id="3d4f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，将以下内容添加到<code class="fe mo mp mq mr b">docker-compose.yml</code>。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="a6e4" class="nk kv it mr b gy nl nm l nn no">super-app-php:<br/>    build: ./php<br/>    ports:<br/>    - "8000:80"</span></pre><p id="ed16" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，用<code class="fe mo mp mq mr b">docker compose up</code>再次点燃所有容器。当你点击<a class="ae mn" href="http://localhost:8000" rel="noopener ugc nofollow" target="_blank"> http://localhost:8000 </a>时，一条好消息说<em class="np">“我正在一个容器中运行。”</em>会出现。</p><p id="0f7d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这是最终的<a class="ae mn" href="https://github.com/shenanigan/super-app-docker" rel="noopener ugc nofollow" target="_blank">库</a>，包含所有other文件和其他设置。</p><h1 id="1b75" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结论</h1><p id="d682" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Docker是一个很棒的容器化工具，通过docker-compose它变得更加强大。它允许并排运行多个容器，而不会相互干扰。它应该在知识库的工具库中。</p></div></div>    
</body>
</html>