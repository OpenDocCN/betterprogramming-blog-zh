<html>
<head>
<title>Implementing Manual Dependency Injection in Android Libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android库中实现手动依赖注入</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-manual-dependency-injection-in-android-libraries-6149bb7c477d?source=collection_archive---------3-----------------------#2021-07-21">https://betterprogramming.pub/implementing-manual-dependency-injection-in-android-libraries-6149bb7c477d?source=collection_archive---------3-----------------------#2021-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ab87" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建您自己的DI框架</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/89da1cbee3a914a0f3244586c22b799c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YkmibkajvwL962Fx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="4024" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多资源可供开发人员在Android应用程序中实现DI。但是当谈到Android库中的DI时，我只发现了几个——其中只有几个是真正有用的。</p><p id="0082" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我决定写一篇关于为什么以及如何在一个Android库中实现手工依赖注入的文章。我在图书馆与DI合作的经历可以追溯到2018年，当时我工作的公司与一家行业领导者达成了协议。他们现在想要我们应用程序的一部分，将他们的应用程序作为一个库包含进来。</p><p id="0d7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当谈到库时，开发人员最初没有太多考虑的是，与实际的Android应用程序开发相比，我们在开发中受到了多大的限制。如果您对某个应用程序类有一些依赖，并且已经在库中创建了自己的应用程序类，那么实际的应用程序级应用程序类应该扩展库应用程序类。否则，您会得到一个编译时错误。</p><p id="0a42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到Android库中的DI，它非常依赖于应用程序类。如果你把dagger或者hilt作为你的DI框架，你需要从application类触发代码生成。库的这种应用程序级依赖性在集成时会产生摩擦。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cd60" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么我在Android库中选择手动DI</h1><ol class=""><li id="dce6" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated">以减少整合时的摩擦。</li><li id="ffca" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">主机应用可能会也可能不会使用库使用的DI框架，所以在SDK中使用dagger这样的大型库会增加主机应用的大小。</li><li id="41d6" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">让事情尽在我们的掌控之中。Dagger2可以在库中使用，而不必在主机应用程序中使用，但这需要大量的努力，不值得。</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0bdc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">手动DI框架的蓝图</h1><p id="6b5a" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我喜欢把事情简单化。我的手动DI框架所依赖的主要特性是Kotlin的<code class="fe nn no np nq b">object</code>和<code class="fe nn no np nq b">lazy</code>。所以在继续之前，让我们唤起你对它们的记忆。</p><h2 id="c21e" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">科特林物体</h2><p id="eb45" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">一个Kotlin <code class="fe nn no np nq b">object</code>就像一个不能被实例化的类，所以它必须被名字调用。我们可以把它看作一个具有应用程序会话生命周期的单例类。在内部，Kotlin基于所有最佳实践(如线程安全等)维护这个单例类。看一看:</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="b4a7" class="nr md it nq b gy oh oi l oj ok"><strong class="nq iu">object</strong> NetworkModule {</span><span id="8911" class="nr md it nq b gy ol oi l oj ok">}</span></pre><p id="343f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面这段代码相当于下面的Java类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="737d" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">懒惰的</h2><p id="ead7" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Kotlin中的<code class="fe nn no np nq b">lazy</code>关键字是许多Android开发者的救命稻草。假设您的类中有一个变量，它的值是通过执行一项昂贵的工作获得的，但该变量只有在用户访问屏幕上的特定功能时才有用。处理这个问题的最简单的方法是初始设置变量<code class="fe nn no np nq b">null</code>，并在用户访问该特性时初始化该值。但是我们必须在每次访问变量时使用<code class="fe nn no np nq b">null</code>检查。</p><p id="646f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以做得更好，我们可以通过两种方式做到:</p><ul class=""><li id="f54f" class="mu mv it lb b lc ld lf lg li oo lm op lq oq lu or nc nd ne bi translated">将该变量命名为<code class="fe nn no np nq b">lateinit var</code> <strong class="lb iu"> </strong>并在需要时初始化。</li><li id="c531" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu or nc nd ne bi translated">惰性初始化。</li></ul><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="6c96" class="nr md it nq b gy oh oi l oj ok">val gson : Gson by <em class="os">lazy </em><strong class="nq iu">{ </strong>provideGson() <strong class="nq iu">}</strong></span></pre><p id="44b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你已经知道了我的DI配方的两个主要组成部分，接下来的部分就是设计了。对于每个目的，我们将创建一个科特林<code class="fe nn no np nq b">object</code>。所以对于网络相关的依赖，我们创建一个<code class="fe nn no np nq b">NetworkModulr</code> Kotlin <code class="fe nn no np nq b">object</code>。对于与数据库相关的依赖项，我们创建<code class="fe nn no np nq b">DatabaseModule</code>。在这些Kotlin <code class="fe nn no np nq b">objects</code>中，我们使用<code class="fe nn no np nq b">lazy</code>来创建每个依赖项。仅此而已。就这么简单。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="09e5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设计一个简单的DI框架</h1><p id="6e0b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这里，我们有三种类型的依赖——网络、数据库和特定于Android的，比如应用程序类实例。为此，我们需要创建三个Kotlin <code class="fe nn no np nq b">objects</code>如下所示:</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="fca2" class="nr md it nq b gy oh oi l oj ok">object NetworkModule {</span><span id="49a4" class="nr md it nq b gy ol oi l oj ok">}</span><span id="e68a" class="nr md it nq b gy ol oi l oj ok">object DatabaseModule {</span><span id="308f" class="nr md it nq b gy ol oi l oj ok">}</span><span id="0265" class="nr md it nq b gy ol oi l oj ok">object LibraryModule {</span><span id="a651" class="nr md it nq b gy ol oi l oj ok">}</span></pre><h2 id="1d72" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">库模块</h2><p id="13db" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">为了简单起见，让我们从<code class="fe nn no np nq b">LibraryModule</code>开始。现在，我们只有一个单一的需求。这是应用程序类的实例。这不能通过<code class="fe nn no np nq b">lazy</code>操作符创建。相反，我们使用<code class="fe nn no np nq b">lateinit var</code>和<code class="fe nn no np nq b">@Volatile</code>注释使其线程安全。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">库模块</p></figure><p id="5b9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，在库初始化的时候，我们需要用一个应用实例调用<code class="fe nn no np nq b">initializeDI</code>函数。这是我们DI框架的入口点(就像初始化dagger组件一样)。</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="8949" class="nr md it nq b gy oh oi l oj ok"><strong class="nq iu"><em class="os">activity</em></strong>?.<em class="os">application</em>?.<em class="os">let </em><strong class="nq iu">{ </strong>LibraryHelpers.<strong class="nq iu">initializeDI</strong>(<strong class="nq iu">it</strong>) <strong class="nq iu">}</strong></span></pre><h2 id="5a93" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">网络模块</h2><p id="8808" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">既然我们已经完成了库模块并有了一个应用程序实例，那么是时候创建与网络相关的依赖项了，比如具有应用程序级生命周期的<code class="fe nn no np nq b">retrofit</code>。为了创建一个<code class="fe nn no np nq b">retrofit</code>实例，我们需要一个序列化器、OkHttp客户端、一些添加头的头拦截器等等。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3f37" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据库模块</h1><p id="ed49" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">最后，我们谈到了与数据库相关的依赖性。这里，我们需要通过<code class="fe nn no np nq b">lazy</code>操作符创建房间数据库实例。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="50e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，您可以为每个目的创建所需数量的对象，并在整个生命周期中维护<code class="fe nn no np nq b">lazy</code>实例。(例如，对于存储库、用例等。).</p><p id="2dc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还没有考虑作用域，因为我构建的库最多只有4-5个屏幕，我不喜欢为这样的事情实现作用域。如果您对基于范围的依赖关系感兴趣，那么您可以将依赖关系设为<code class="fe nn no np nq b">null</code>类型，并清除该范围破坏的对象。我的建议是不要做这件事。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7f7f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">奖金</h1><p id="d56f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我最近看到了<a class="ae ky" href="https://medium.com/u/d255c4fc9d76?source=post_page-----4c9f44d04e68--------------------------------" rel="noopener">萨提亚·帕万·坎塔马尼</a>发表的这篇关于安卓系统中<code class="fe nn no np nq b">BroadcastReceiver</code>的优秀文章:</p><div class="ot ou gp gr ov ow"><a href="https://pavan-careers5208.medium.com/broadcastreceiver-in-android-adcfe2801a6b" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">Android中的广播接收器</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">处理系统范围和自定义广播</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">pavan-careers5208.medium.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ks ow"/></div></div></a></div><p id="67a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>