<html>
<head>
<title>JavaScript: MutationObserver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:变异观察器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/js-mutationobserver-1d7aed479da2?source=collection_archive---------0-----------------------#2019-09-10">https://betterprogramming.pub/js-mutationobserver-1d7aed479da2?source=collection_archive---------0-----------------------#2019-09-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="192d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用代码示例解释变异观测器</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/60246a5ba71db0437547a41a6dbd638a.png" data-original-src="https://miro.medium.com/v2/format:webp/0*UzaG_alYU6vQ8MIt.jpg"/></div></figure><p id="4540" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您可能已经在代码的很多地方用JavaScript操作了DOM。</p><p id="4c36" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果是的话，那么很可能在某个时候，您必须处理DOM中的动态变化，例如，添加或删除元素或者属性值的变化。就在那时，<code class="fe lm ln lo lp b">MutationObserver</code>出现了。</p><p id="3278" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe lm ln lo lp b">MutationObserver</code>接口允许监听DOM中的变化。</p><p id="a36b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在本文中，我们将用简单明了的方法来解释这个接口。为了帮助实现这一目标，所有内容都将通过代码示例进行演示。</p><p id="943a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，让我们谈谈你应该知道的几件重要的事情。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="868b" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">浏览器支持</h1><p id="e55d" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated"><code class="fe lm ln lo lp b">MutationObserver</code>并非所有浏览器版本都支持。如果我们在<a class="ae mu" href="https://caniuse.com/#feat=mutationobserver" rel="noopener ugc nofollow" target="_blank">中检查<em class="mv">我可以用</em></a><em class="mv"/>我们得到这个结果:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/f23e1763dc6638f9407d55c8ecf1c5c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TnGBoiV8AgFtdPC4ATcbWg.png"/></div></div></figure><p id="f3ff" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你的目标是IE 10或更低版本，或者Opera mini(以及其他不支持<code class="fe lm ln lo lp b">MutationObserver</code>的浏览器)，这是一个问题。</p><p id="5f40" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你的目标浏览器不支持<code class="fe lm ln lo lp b">MutationObserver</code>，并不意味着你不能在你的实现中使用它。</p><p id="24b8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您可以实现一个简单的验证来检查浏览器是否支持它。如果有，你就用，如果没有，你就用老办法:<a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Mutation_events" rel="noopener ugc nofollow" target="_blank">突变事件</a>。这种方法实际上是不赞成的，但是如果你需要支持旧的浏览器，你需要添加它。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/47ac738d27c4256f8a3b3d9d199cf1a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*OnZsIm6GxYtM0i0HuAmdRQ.png"/></div></figure><p id="abd3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在本文中，我们不打算讨论如何实现不推荐的方法(突变事件)，但是我认为，如果浏览器支持对您来说是个问题，那么知道如何解决兼容性问题是很重要的。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="00bc" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">当心性能</h1><p id="d274" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">不言而喻，操作DOM是一件需要小心的事情。此外，通过使用<code class="fe lm ln lo lp b">MutationObserver</code>，您将在每次您正在监听的更改被触发时执行代码。</p><ul class=""><li id="f3b2" class="nc nd it ks b kt ku kw kx kz ne ld nf lh ng ll nh ni nj nk bi translated">确保在操作DOM时遵循良好的实践。</li><li id="6c74" class="nc nd it ks b kt nl kw nm kz nn ld no lh np ll nh ni nj nk bi translated">避免任何不必要的代码执行。以这样一种方式构建您的代码，即任何操作只在需要运行时才运行。</li><li id="4b13" class="nc nd it ks b kt nl kw nm kz nn ld no lh np ll nh ni nj nk bi translated">在好看的代码上执行代码。有时候，对某些人来说，执行代码有点难看，没关系，就这样吧，我们希望我们的代码尽可能具有高性能！</li></ul><p id="42b7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我认为在进入我们的主要活动之前提及这些事情是很重要的。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="a39e" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">使用变异观测器</h1><p id="db93" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">现在来说说<code class="fe lm ln lo lp b">MutationObserver</code>。以下是我们将要讨论的内容:</p><ul class=""><li id="a05e" class="nc nd it ks b kt ku kw kx kz ne ld nf lh ng ll nh ni nj nk bi translated">我们能听出什么变化？</li><li id="ce4f" class="nc nd it ks b kt nl kw nm kz nn ld no lh np ll nh ni nj nk bi translated">初始配置。</li><li id="8eaa" class="nc nd it ks b kt nl kw nm kz nn ld no lh np ll nh ni nj nk bi translated">监听属性变化的代码示例(<a class="ae mu" href="https://github.com/SantiagoGdaR/mutation-observer" rel="noopener ugc nofollow" target="_blank"> GitHub链接</a>)。</li><li id="2acb" class="nc nd it ks b kt nl kw nm kz nn ld no lh np ll nh ni nj nk bi translated">监听<code class="fe lm ln lo lp b">childList</code>变化的代码示例(<a class="ae mu" href="https://github.com/SantiagoGdaR/mutation-observer" rel="noopener ugc nofollow" target="_blank"> GitHub链接</a>)。</li></ul><h2 id="e210" class="nq ly it bd lz nr ns dn md nt nu dp mh kz nv nw mj ld nx ny ml lh nz oa mn ob bi translated">我们能听出什么变化？</h2><p id="0c3c" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">为了初始化<code class="fe lm ln lo lp b">MutationObserver</code>，我们需要创建一个构造函数期望的配置对象。</p><p id="fa5c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">该对象设置我们将要收听的更改类型:</p><ul class=""><li id="f059" class="nc nd it ks b kt ku kw kx kz ne ld nf lh ng ll nh ni nj nk bi translated"><code class="fe lm ln lo lp b">attributes</code>:如果为真，我们就要听元素属性的变化。</li><li id="cef6" class="nc nd it ks b kt nl kw nm kz nn ld no lh np ll nh ni nj nk bi translated"><code class="fe lm ln lo lp b">childList</code> : <strong class="ks iu"/></li><li id="adff" class="nc nd it ks b kt nl kw nm kz nn ld no lh np ll nh ni nj nk bi translated"><code class="fe lm ln lo lp b">subtree</code> : <strong class="ks iu"> </strong>如果为真，我们不仅要观察我们的目标节点，还要观察它的所有后代。</li></ul><p id="fa99" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这三个是我们将在示例中看到的，但是配置对象还可以处理其他属性:</p><ul class=""><li id="97a0" class="nc nd it ks b kt ku kw kx kz ne ld nf lh ng ll nh ni nj nk bi translated"><code class="fe lm ln lo lp b">attributeFilter</code>:监听变化的属性名数组。</li><li id="9ce9" class="nc nd it ks b kt nl kw nm kz nn ld no lh np ll nh ni nj nk bi translated"><code class="fe lm ln lo lp b">characterData</code>:监听文本变化。</li><li id="6650" class="nc nd it ks b kt nl kw nm kz nn ld no lh np ll nh ni nj nk bi translated"><code class="fe lm ln lo lp b">attributeOldValue</code>:如果您想在回调函数中接收属性的旧值，您需要将这个属性设置为true。</li><li id="39e7" class="nc nd it ks b kt nl kw nm kz nn ld no lh np ll nh ni nj nk bi translated"><code class="fe lm ln lo lp b">characterDataOldValue</code>:如果想在回调函数中接收文本的旧值，需要将这个属性设置为true。</li></ul><h2 id="71d3" class="nq ly it bd lz nr ns dn md nt nu dp mh kz nv nw mj ld nx ny ml lh nz oa mn ob bi translated">初始配置</h2><p id="5c7a" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">当您创建<code class="fe lm ln lo lp b">MutationObserver</code>对象时，您需要提供一个回调函数作为参数，当您正在监听的更改被触发时，该函数将被执行。</p><p id="36f5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们将在下面的代码示例中看到这一点，但它看起来会像这样:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/3677a0862e1370ea5f468ac9ba3e76a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*KJfyjNGYIOU55Dk1wz_H-Q.png"/></div></figure><p id="256f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe lm ln lo lp b">callback</code> param表示当一个改变被触发时要执行的函数。</p><p id="4ca0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一旦创建了<code class="fe lm ln lo lp b">mutationObserver</code>对象，就需要通过执行observe函数来初始化它。</p><p id="8e8d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这个函数接收两个参数，第一个是目标节点(这个节点将扮演根节点的角色来侦听更改)，第二个是包含前面提到的侦听器配置的配置对象。</p><p id="8702" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">例如:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi od"><img src="../Images/589f9172f570948b997909a0a89c976b.png" data-original-src="https://miro.medium.com/v2/resize:fit:346/format:webp/1*4rGmcoDwBOk19oxqCw8SYA.png"/></div></figure><p id="ce32" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在上面的例子中，您正在配置观察者来监听我们将要处理的三种类型的变更(<code class="fe lm ln lo lp b">attributes</code>、<code class="fe lm ln lo lp b">childList</code>和<code class="fe lm ln lo lp b">subtree</code>)。有关这方面的更多信息，请参阅章节<em class="mv">我们能听到哪些变化？</em>本条。</p><p id="1351" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">作为目标，让我们在所有的例子中使用body，最后，让我们使用observe函数初始化观察者。在我们的每个示例中，这段代码都会有一点点变化，但结构看起来总是类似于:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/482001b8a5ffd02b194bc11e0f5f1956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*dPQv5s3NXaTWQdft3DxJ7A.png"/></div></figure><p id="8ca8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们已经讨论了这个JavaScript文件中的所有内容。</p><p id="c833" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe lm ln lo lp b">init</code>函数首先检查浏览器是否支持突变观察器，如果支持，它就启动突变观察器。如果没有，它将启动突变事件(正如我们之前提到的，本文没有涉及)。</p><p id="6f1f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe lm ln lo lp b">startMutationObserver</code> <em class="mv"> </em>功能有以下步骤:</p><ul class=""><li id="82aa" class="nc nd it ks b kt ku kw kx kz ne ld nf lh ng ll nh ni nj nk bi translated">获取作为目标节点的正文。</li><li id="d4a5" class="nc nd it ks b kt nl kw nm kz nn ld no lh np ll nh ni nj nk bi translated">在这种情况下，设置配置对象来监听所有的更改类型。</li><li id="77b3" class="nc nd it ks b kt nl kw nm kz nn ld no lh np ll nh ni nj nk bi translated">它实例化了提供回调函数的<code class="fe lm ln lo lp b">MutationObserver</code>(尚未实现)。</li><li id="776c" class="nc nd it ks b kt nl kw nm kz nn ld no lh np ll nh ni nj nk bi translated">它通过向<code class="fe lm ln lo lp b">MutationObserver</code>对象的observe函数提供目标节点和配置对象来初始化监听器。</li></ul><p id="cd90" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe lm ln lo lp b">callback</code>函数接收两个参数，第一个是突变记录列表，第二个是观察者对象。</p><p id="caf6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们命名所有的突变记录属性:</p><ul class=""><li id="8dd4" class="nc nd it ks b kt ku kw kx kz ne ld nf lh ng ll nh ni nj nk bi translated"><code class="fe lm ln lo lp b">target</code>:发生变化的元素。</li><li id="c59d" class="nc nd it ks b kt nl kw nm kz nn ld no lh np ll nh ni nj nk bi translated"><code class="fe lm ln lo lp b">type</code>:它所代表的变异类型(属性、字符数据或子列表)</li><li id="92df" class="nc nd it ks b kt nl kw nm kz nn ld no lh np ll nh ni nj nk bi translated"><code class="fe lm ln lo lp b">oldValue</code>:之前的值(只有当变异配置对象的<code class="fe lm ln lo lp b">oldValue</code>属性被设置为真时，我们之前在<em class="mv">中讨论过这个问题，我们可以监听哪些变化？</em>一节。).</li></ul><p id="edae" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">值得一提的是，您可以通过使用<code class="fe lm ln lo lp b">disconnect</code>功能随时断开界面监听变化:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi of"><img src="../Images/8518b1dd9ad0a49cd5a27d99d9b71831.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*AeSguNkcU9IvGZzopWqa0A.png"/></div></figure><h2 id="706f" class="nq ly it bd lz nr ns dn md nt nu dp mh kz nv nw mj ld nx ny ml lh nz oa mn ob bi translated">监听属性更改</h2><p id="89ec" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">为了只监听属性的变化，我们需要将上面的config对象改为只监听属性的变化，到现在为止，您可能已经知道如何去做了。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi og"><img src="../Images/bb7273b6b0781639467474e344f3a94a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*_Utt_pnf-C-TDWjjZuViJQ.png"/></div></figure><p id="c874" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">代码和以前一样，不同之处在于我创建了一个函数，它返回config对象，只监听属性的变化。</p><p id="e5b7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">值得一提的是，使用这种配置，您只能听到目标节点属性的变化。如果您还想监听子节点属性的变化，您需要将属性<code class="fe lm ln lo lp b">subtree</code> <em class="mv"> </em>设置为true。</p><p id="fac1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们更改配置来监听<code class="fe lm ln lo lp b">subtree</code>属性的变化:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/7a44267211ada94947a28418566f3214.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*dP4JoGt5wdI79jUYedVIVw.png"/></div></figure><p id="5d38" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，我们正在监听目标节点及其所有子节点树的属性变化。</p><p id="48d1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">很好，让我们看看HTML:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/d813156be447ceddde86044f3fb6833f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*g_hXDSfHhnRAUWV3-X9yxA.png"/></div></figure><p id="0395" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这个HTML非常简单，其思想是通过按下一个按钮来执行一个功能，这个按钮将改变标签<code class="fe lm ln lo lp b">p</code>的属性文本颜色。这是函数:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi oj"><img src="../Images/5f8750ffa32863a6b2f798abc3bf8537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*so0zCa2ezmU_uVOkFQkeyA.png"/></div></div></figure><p id="2a75" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">同样，这个函数很简单。它获取元素，检查颜色属性，并更改它。</p><p id="f4e7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们这样做，我们的回调函数对这个属性文本颜色的变化作出反应，并将新的颜色应用于实际的文本:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ok"><img src="../Images/4504128b4fb576cfcf42dc0a96bbf9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KdggCR6z76UpfXTixoJVsA.png"/></div></div></figure><p id="99b7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">正如我们提到的，我们的<code class="fe lm ln lo lp b">callback</code>函数接收两个prams:突变记录列表和我们的突变观察者。</p><p id="65f2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们要做的第一件事是迭代突变列表。</p><p id="75d7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在<code class="fe lm ln lo lp b">for</code>内部，我们要做的第一件事是生成一个过滤代码，以避免执行我们的逻辑，除非它是我们想要做出反应的实际变化。</p><p id="b029" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这种情况下，我们使用一个<code class="fe lm ln lo lp b">if</code>语句检查改变的突变属性的名称是否是我们关心的属性(<code class="fe lm ln lo lp b">data-text-color</code>)。</p><p id="441a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果是这样的话，我们取突变目标，也就是发生变化的节点，将该节点的样式颜色设置为<code class="fe lm ln lo lp b">data-text-color</code> <em class="mv"> </em>属性中设置的颜色。</p><p id="cfb4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">不要忘记更改观察器初始化的代码，以便将该函数用作回调函数:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/b4918c26e9122943ea76846870c28f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*NXr-R3QUuHYP8hA8RokHaA.png"/></div></figure><p id="771e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">太好了！所以，这是一个如何处理属性变化的好例子。</p><h2 id="243c" class="nq ly it bd lz nr ns dn md nt nu dp mh kz nv nw mj ld nx ny ml lh nz oa mn ob bi translated">监听子列表更改</h2><p id="928d" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">假设我们还想添加一个侦听器，用于子列表发生变化时，这意味着我们的目标节点的一个子节点已经被添加或删除。</p><p id="125b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">再次考虑，如果您还想监听我们的目标节点的子节点何时被添加或删除，我们需要将<code class="fe lm ln lo lp b">subtree</code>属性设置为<code class="fe lm ln lo lp b">true</code>。</p><p id="e007" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这样，我们将侦听何时从目标节点添加或删除子节点，以及何时从目标节点的子节点添加或删除节点。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi om"><img src="../Images/2fa95294d8b7aa3bf483ea1fea6feb75.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*bu-LBm58XVT7NaiRPAif7Q.png"/></div></figure><p id="0e81" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">通过设置如上图所示的配置对象，现在您不仅可以监听属性更改，还可以监听子列表更改。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi on"><img src="../Images/1cdaaf19cb2c812a47414168a04bbf26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w7gKlMvM3Tx274nBSAv4LA.png"/></div></div></figure><p id="5b26" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我们可以使用突变的<code class="fe lm ln lo lp b">type</code>属性来区分我们想要对哪种类型的突变做出反应。</p><p id="452c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这个代码示例中，我们对前面示例中的<code class="fe lm ln lo lp b">attribute</code> <em class="mv"> </em>类型变化做出反应，也对<em class="mv"> </em> <code class="fe lm ln lo lp b">childList</code>类型变化做出反应。</p><p id="603c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于<code class="fe lm ln lo lp b">childList</code> <em class="mv"> </em>类型的部分，我们循环遍历<code class="fe lm ln lo lp b">removedNodes</code>和<code class="fe lm ln lo lp b">addedNodes</code>，以展示如何实际迭代触发变更的节点。</p><p id="022e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们添加一点代码:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/5e5ec925f34977345d4a80825d345d6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*r_-3Lf6k1M2ySQw5PlvBew.png"/></div></figure><p id="7043" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们对HTML进行了一些修改，以计算添加的节点数，并添加了一个按钮来执行添加节点的功能。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi op"><img src="../Images/e42e429db24dfc8c2bb36ace0f8a80d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*6dQJHGCGp_-pHXGPoJ5UZw.png"/></div></figure><p id="7b5b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在我们的JS中，我们添加了一个向DOM添加节点的函数，这个函数在单击add node按钮时执行。</p><p id="328c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们还添加了一个函数来更新HTML中的节点数。第二个函数将在突变观察器<code class="fe lm ln lo lp b">callback</code>函数中执行。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi oq"><img src="../Images/1acac6df2fa5d2cf504f0aaf761326e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pa44Dsf8WlF1U2oqdWKQng.png"/></div></div></figure><p id="9217" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，在我们的<code class="fe lm ln lo lp b">callback</code>函数的<code class="fe lm ln lo lp b">childList</code> <em class="mv"> </em>部分中，我们将在每次添加一个节点(名称不是test)时增加added nodes变量。</p><p id="e2d7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果在执行函数<code class="fe lm ln lo lp b">updateNodeCount</code> <em class="mv"> </em>时，我们不把执行代码的条件只放在所添加的节点不是名字<code class="fe lm ln lo lp b">#text</code> <em class="mv"> </em>的情况下，我们将进入一个无限循环。</p><p id="99ee" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是因为该函数将替换文本，这将触发一个<code class="fe lm ln lo lp b">childList</code> <em class="mv"> </em>变化，这将再次调用<code class="fe lm ln lo lp b">updateNodeCount</code>，以此类推。所以我们需要那个条件。</p><p id="526c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">原来如此！我们通过一些很好的例子展示了如何使用<code class="fe lm ln lo lp b">MutationObserver</code>接口。</p><p id="3d44" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里是<a class="ae mu" href="https://github.com/SantiagoGdaR/mutation-observer" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>，继续玩代码。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="400d" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">结论</h1><p id="ee8e" class="pw-post-body-paragraph kq kr it ks b kt mp ju kv kw mq jx ky kz mr lb lc ld ms lf lg lh mt lj lk ll im bi translated">即使看起来有点难，理解<code class="fe lm ln lo lp b">MutationObserver</code>接口还是很简单的。另一方面，如果你对实际发生的事情没有很好的理解，正确地使用它会非常复杂。</p><p id="b13a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我希望这篇文章能让你对这个问题有所了解。</p><p id="4f9e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">干杯！</p></div></div>    
</body>
</html>