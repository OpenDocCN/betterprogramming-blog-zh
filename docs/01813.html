<html>
<head>
<title>Advanced Python List Methods and Techniques</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级Python列表方法和技术</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/advanced-python-list-methods-and-techniques-python-like-a-pro-bcc52e93c646?source=collection_archive---------8-----------------------#2019-10-15">https://betterprogramming.pub/advanced-python-list-methods-and-techniques-python-like-a-pro-bcc52e93c646?source=collection_archive---------8-----------------------#2019-10-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f7b3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中最强大的数据结构之一是列表；以下是一些更高级的列表用法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/29ef57d5f27a5f851775555c14227b79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pVbVFN7cilCtp3DtC0d8SA.png"/></div></div></figure><p id="8d86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Python中最强大的数据结构之一是列表。我并不真的相信这一点，直到我开始研究文档，并意识到在构建列表数据结构时投入了多少工作。</p><p id="cf17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Python列表本身支持用作队列、堆栈和数组。这就是为什么要像专业人士一样使用Python，很好地理解列表是很重要的。</p><p id="3158" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们将涵盖列表理解、<code class="fe lq lr ls lt b">zip</code>方法和<code class="fe lq lr ls lt b">sort</code>方法。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="2ea1" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">列出理解</h1><p id="dd07" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">理解是Python列表的一个高级特性，它有助于使代码更加清晰易读。</p><p id="c23c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">合成就是用一行代码在一个列表上执行一系列操作的一种方式。理解通常用括号内的<code class="fe lq lr ls lt b">for</code>语句来表示。</p><p id="f135" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是列表理解的模板:</p><pre class="kj kk kl km gt my lt mz na aw nb bi"><span id="fa4a" class="nc mc it lt b gy nd ne l nf ng">newList = [returned_value  for item in list condition_logic ]</span></pre><h2 id="fb87" class="nc mc it bd md nh ni dn mh nj nk dp ml ld nl nm mn lh nn no mp ll np nq mr nr bi translated">提取特定元素</h2><p id="4182" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">列表理解可用于提取满足特定标准的某些元素。在下面的例子中，我们用一个理解从一个列表中取出所有的偶数。</p><pre class="kj kk kl km gt my lt mz na aw nb bi"><span id="17f2" class="nc mc it lt b gy nd ne l nf ng"># Create a list of numbers from 0 - 49<br/>numRange = range(0,50)</span><span id="f2f4" class="nc mc it lt b gy ns ne l nf ng"># Pull out all the numbers that are even<br/>evenNums = [num for num in numRange if num % 2 == 0 ]</span></pre><p id="384f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的例子中，从左向右阅读，我们用从for循环返回的<code class="fe lq lr ls lt b">num</code>创建一个新列表，其中<code class="fe lq lr ls lt b">num</code>的余数(<code class="fe lq lr ls lt b">%</code>模)除以2等于零。</p><p id="e8a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个常见的用例，所有偶数都需要从列表中取出。</p><h2 id="ea6a" class="nc mc it bd md nh ni dn mh nj nk dp ml ld nl nm mn lh nn no mp ll np nq mr nr bi translated">对元素执行操作</h2><p id="1ce8" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">列表理解可用于对列表中的元素执行操作。下面的例子展示了如何对列表中的所有元素求平方。</p><pre class="kj kk kl km gt my lt mz na aw nb bi"><span id="be00" class="nc mc it lt b gy nd ne l nf ng"># Create a list of numbers from 0 - 49<br/>numRange = range(0,50)</span><span id="6f19" class="nc mc it lt b gy ns ne l nf ng"># Pull out all the numbers that are even<br/>evenNums = [num * num for num in numRange]</span></pre><h2 id="b4cf" class="nc mc it bd md nh ni dn mh nj nk dp ml ld nl nm mn lh nn no mp ll np nq mr nr bi translated">使用记忆限制函数调用</h2><p id="9ccd" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">这是一段特别有用的代码，它可以让你避免不必要的昂贵的函数调用。来源是<a class="ae nt" href="https://stackoverflow.com/questions/15812779/python-list-comprehension-want-to-avoid-repeated-evaluation" rel="noopener ugc nofollow" target="_blank">这个关于栈溢出的帖子</a>。</p><p id="1f60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记忆化是将值存储在内存中的过程，这样我们就不需要在以后重新计算结果。</p><p id="8a0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">情况是这样的:您有一个可能包含重复数据的列表，或者需要运行函数来检查输出并返回值。</p><p id="968f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，记忆化可以通过使用字典来跟踪具有相同输入参数的函数调用的结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="4335" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你运行上面的例子时，你会发现这个函数只运行了五次，尽管在列表理解中有两次对<code class="fe lq lr ls lt b">f(x)</code>的调用，并且列表中有六个元素。</p><p id="db35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个唯一的号码只能调用一次。否则，提供缓存的值。如果函数调用开销很大，可以通过记忆结果来大大提高代码速度。</p><p id="bf24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这对于合理大小的列表非常有效，可以提高速度，但是对于非常大的列表可能会出现问题，因为当函数在作用域内时，所有的输入/输出都会被缓存，需要大量使用内存来存储值。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="602f" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">列出高级方法</h1><p id="784c" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">除了理解之外，还有其他几种对列表有用的方法。这里有一些可能未被充分利用或不为人知。</p><h2 id="3fc0" class="nc mc it bd md nh ni dn mh nj nk dp ml ld nl nm mn lh nn no mp ll np nq mr nr bi translated">Zip(列表，列表2，…)</h2><p id="ed9c" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">zip方法用于将Python中的多个列表组合成元组。如果两个列表的长度不同，那么两个列表中较长的列表将被截断为较短列表的长度。</p><pre class="kj kk kl km gt my lt mz na aw nb bi"><span id="9629" class="nc mc it lt b gy nd ne l nf ng">first_names = ['John', 'Jeff', 'Chris']<br/>last_names = ['Wick', 'Chen', 'Test', 'Truncated']</span><span id="f19c" class="nc mc it lt b gy ns ne l nf ng">names = zip(first_names, last_names)</span><span id="2736" class="nc mc it lt b gy ns ne l nf ng">for name in names:<br/>  print(name)</span><span id="2eb9" class="nc mc it lt b gy ns ne l nf ng"># Outputs: <br/>('John', 'Wick')<br/>('Jeff', 'Chen')<br/>('Chris', 'Test')</span></pre><h2 id="8af3" class="nc mc it bd md nh ni dn mh nj nk dp ml ld nl nm mn lh nn no mp ll np nq mr nr bi translated">列表。排序(key=func，reversed=T/F)</h2><p id="01b4" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">我知道。将排序方法放入这样的文章中似乎很奇怪。我把它放在这里，因为我觉得使用自定义排序功能的排序是超级利用不足。</p><p id="63c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我尝试做的一个小排序函数，它将返回给定一天的热门帖子。我确保在最后也使用了列表理解。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="d7da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样做的输出将是下面的列表，其中最新和排名最高的文章排在第一位，然后是其他文章和昨天的文章。</p><p id="41a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这并不能解释为什么昨天的文章表现得足够好，仍然有必要占据榜首，但我认为这一点是有道理的。</p><pre class="kj kk kl km gt my lt mz na aw nb bi"><span id="7e13" class="nc mc it lt b gy nd ne l nf ng">['Python Like a Pro - Lists and Their Many Uses', <br/>'Other today post', <br/>'Yesterdays news']</span></pre></div></div>    
</body>
</html>