<html>
<head>
<title>AWS Kinesis vs. SNS vs. SQS — A Comparison With Python Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS kine sis vs . SNS vs . SQS——与Python示例的比较</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/aws-kinesis-vs-sns-vs-sqs-a-comparison-with-python-examples-6fc688bfd244?source=collection_archive---------4-----------------------#2021-06-02">https://betterprogramming.pub/aws-kinesis-vs-sns-vs-sqs-a-comparison-with-python-examples-6fc688bfd244?source=collection_archive---------4-----------------------#2021-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8206" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何选择适合您的用例的解耦服务</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/34b2fad18b1083f55f3dec3a2e21328f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SdUH4jtkLL6EUbr1"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Wil Stewart 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a> | <a class="ae ky" href="https://www.annageller.com/disclosure" rel="noopener ugc nofollow" target="_blank">品牌内容披露</a>上的照片。</p></figure><p id="73a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解耦提供了无数的优势，但是为这项工作选择正确的工具可能具有挑战性。仅AWS就提供了几种服务，允许我们分离发送和接收数据。虽然这些服务表面上看起来提供了相似的功能，但它们是为不同的用例设计的，如果恰当地应用于手头的问题，它们中的每一个都是有用的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f9ea" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">AWS SQS</h1><p id="6912" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">作为历史最悠久的AWS服务之一，SQS在提供极其简单有效的解耦机制方面有着良好的记录。整个服务基于向队列<strong class="lb iu"> </strong>发送消息，并允许应用程序(例如ECS容器、Lambda函数)轮询消息并处理它们。消息会一直留在队列中，直到某个应用程序获取它，处理它，并在完成后删除消息。</p><p id="0d06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQS和其他去耦服务之间最重要的区别是它不是发布-订阅服务。SQS没有生产者、消费者、主题或订阅者的概念。它所做的只是提供一个分布式队列，允许:</p><ul class=""><li id="ed2c" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">向队列发送消息。</li><li id="5c7f" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">轮询队列中的消息。</li><li id="96a0" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">从队列中提取消息。</li><li id="a720" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">成功处理消息后，从队列中删除消息。</li></ul><p id="99d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQS不向任何应用程序推送消息。相反，一旦消息被发送到SQS，应用程序必须主动轮询消息以接收和处理它们。此外，从队列中提取消息并使其消失是不够的。消息会一直留在队列中，直到:</p><ul class=""><li id="16e8" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">它已被成功处理并从队列中删除。</li><li id="9ab7" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">可见性超时已过期。想象一下，一个容器化的应用程序获得了一条消息，但是在处理它的时候，它陷入了一个僵死的进程。为了确保此消息将被处理，一旦可见性超时过期，它将对其他工作人员可见。该超时可以设置为从0秒到12小时，默认值为30秒。</li></ul><p id="b273" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码片段演示了如何:</p><ul class=""><li id="0548" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">创建一个队列。</li><li id="5b8d" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">向队列发送消息。</li><li id="af38" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">接收、处理和删除消息。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d24c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，SQS不保证消息将按照发送到队列的顺序进行处理，除非您选择FIFO队列。这可以在创建队列时轻松配置:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="37af" class="nv md it nr b gy nw nx l ny nz">sqs.create_queue(<em class="mz">QueueName</em>=queue_name,<br/>      <em class="mz">Attributes</em>={'VisibilityTimeout': '3600', 'FifoQueue': 'true'})</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0855" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">社交网站（Social Network Site的缩写）</h1><p id="8653" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">尽管SNS代表简单通知服务，但它提供的功能远不止发送推送通知(电子邮件、短信和移动推送)的能力。事实上，它是一个无服务器的发布-订阅消息系统，允许您同时向多个应用程序(订阅者)发送事件(扇出)，包括SQS队列、Lambda函数、Kinesis数据流和通用HTTP端点。</p><p id="c2a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用该服务，我们只需:</p><ul class=""><li id="6a4b" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">创建一个主题。</li><li id="7174" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">订阅一个话题。</li><li id="b6ec" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">确认订阅。</li><li id="b07e" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">开始向一个主题发送事件，以便将它们传递给所有订阅者(可能是多个应用程序和人员)。</li></ul><p id="be2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你如何决定是否需要使用SQS vs. SNS？<strong class="lb iu"> </strong>任何时候多个服务需要接收同一个事件，你应该考虑SNS而不是SQS。来自SQS队列的消息只能由单个工作节点或进程成功处理。因此，如果需要扇出机制，就需要创建一个SNS主题，以及一个或多个SQS队列，用于需要从SNS接收特定事件或数据的所有应用程序。然后，多个SQS队列可以订阅这个SNS主题并同时接收消息。</p><p id="7db1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，想象一个简单的场景，有可能将同一个事件(消息)发布到开发(登台)和生产环境中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/7dc3162512d41989d1dcb7db7328787a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4EXOP-N9qcPrmY4RbTmuzA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用SNS实施扇出机制，以区分开发和生产资源。图片由作者提供。</p></figure><p id="8cee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下Python脚本演示了如何:</p><ul class=""><li id="b8da" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">创建一个社交网络话题。</li><li id="5c0e" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">订阅社交网络话题。</li><li id="06e7" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">向SNS主题发布消息。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="482c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">AWS Kinesis数据流</h1><p id="c751" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">AWS在Kinesis家族下提供一整套服务。当人们提到Kinesis时，他们通常指的是Kinesis数据流——一种允许你通过利用生产者和消费者对数据记录碎片进行操作来几乎实时地处理大量流数据的服务。</p><ul class=""><li id="cd26" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">生产者是由Kinesis代理、生产者库或AWS SDKs生成的脚本，它们将数据发送到数据流。</li><li id="555d" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">消费者是客户端库或AWS服务(AWS Lambda，Kinesis Data Firehose，Kinesis Data Analytics)，它们处理来自这些数据流的数据。</li><li id="41ca" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">每个数据流由一个或多个碎片组成。</li><li id="fca6" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">碎片是由序列号唯一标识的数据记录的集合。</li><li id="e813" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">每个数据记录都有一个分区键，用于确定哪个碎片将存储特定的数据记录。这应该有助于将经常一起访问的数据记录分组到同一个碎片中。</li><li id="0720" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">每个数据记录还有一个保存实际数据的数据blob。这些数据可以以各种形式存储，只要它适合一个1 MB的blob对象。</li><li id="4129" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">一旦数据记录被发送到数据流，它就可以在数据流中保留指定的保留期，从24小时到7天不等。</li></ul><p id="c902" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了Kinesis数据流，“Kinesis系列”还包括:</p><ul class=""><li id="71d1" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">Kinesis Data Firehose —一种通过通用HTTP端点将数据记录自动传送到S3、红移、Datadog、New Relic、MongoDB或Splunk等服务提供商以及其他来源的服务。这项服务背后的警告是，它不是实时提供数据，而是以微批处理的方式提供数据。数据以60-900秒的速度或在预定义的缓冲区大小(1-128 MB)填满后被传送到选定的目的地。</li><li id="7835" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">Kinesis数据分析—一种允许我们在数据进入数据流时对其进行转换和分析的服务。我们可以使用类似SQL的接口进行转换(例如，使用regex解析来自JSON或流日志的信息)，并通过滑动窗口聚合将流数据聚合到及时的时段(例如，15分钟时段)来收集见解。</li></ul><h2 id="604e" class="nv md it bd me ob oc dn mi od oe dp mm li of og mo lm oh oi mq lq oj ok ms ol bi translated">一个使用Python的Kinesis数据流的简单演示</h2><p id="87e1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了演示如何使用Kinesis数据流，我们将请求当前的加密货币市场价格(数据生产者)，并使用Python生产者将它们摄取到Kinesis数据流<strong class="lb iu"> </strong>中。</p><p id="471e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在AWS控制台中创建数据流，我们需要提供一个流名称并配置碎片的数量:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/c0c6b96b4c6827bd8b23cdee4e626ffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c1qYoiU6Xs6ndPApGeMs5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建数据流。图片由作者提供。</p></figure><p id="c77d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以开始向流中发送实时市场价格。在下面的示例中，我们每十秒钟发送一次:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="aa2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该脚本将无限期运行，直到我们手动停止它。</p><h2 id="8362" class="nv md it bd me ob oc dn mi od oe dp mm li of og mo lm oh oi mq lq oj ok ms ol bi translated">使用Kinesis数据消防水带来消耗数据</h2><p id="72f8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止，我们配置了一个Kinesis数据生成器，向数据流发送实时市场价格。有许多方法可以实现Kinesis消费者。对于这个演示，我们将实现最简单的方法，即利用一个消防软管交付流。</p><p id="5dde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在AWS控制台中配置Kinesis Data Firehose直接向S3发送数据。我们需要选择之前创建的数据流，对于其他所有东西，我们可以应用默认值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/a0388e3b678c682a660acd429a7005e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x__g939mzs5h_fBmWcZ5ww.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建交付流。图片由作者提供。</p></figure><p id="f185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的部分是配置目的地。对于我们的用例，我们选择S3，并选择一个特定的存储桶:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/cefd233a364ef6a0dddd65ff807a33cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MytTTH03R3PPj4waPStlig.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建交付流。图片由作者提供。</p></figure><p id="142b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要配置微批量数据发送到S3的频率:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/eef9b5a9a2b6ceed63562d181236e299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I_R6gIw3kNpmVaHfDE5G8g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建交付流。图片由作者提供。</p></figure><p id="693f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以确认创建一个交付流:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/210c63bdc14fe1322b9807e136eb672a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*48n4RD5XDLuFXhSYTlzaBA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建交付流。图片由作者提供。</p></figure><p id="799d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在交付流创建后不久，我们应该能够看到每分钟都有新数据到达我们的S3桶(假设您的Python生成器代码仍在运行):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/372da2c0d07f46f258b6a8088b84669d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQWir9ihtapp-xS1hjzy6g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自S3交付流的数据。图片由作者提供。</p></figure><p id="d806" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了查看这些数据，我们可以从S3下载一个文件并检查其内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/74fa036dbd00419228644479d9320b45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*huoIHz4qLVBd-2MzBJAZ8Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自传递流的数据。图片由作者提供。</p></figure><h2 id="ebb2" class="nv md it bd me ob oc dn mi od oe dp mm li of og mo lm oh oi mq lq oj ok ms ol bi translated">如何监控数据流的健康状况</h2><p id="5a1c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">尽管Kinesis数据流是无服务器的，但它需要跨分片的适当数据分配。跟踪任何写限制的一种可能方式是使用<a class="ae ky" href="https://dashbird.io/" rel="noopener ugc nofollow" target="_blank"> Dashbird </a>。在下图中，我们可以看到每分钟有多少记录被发送到流中。这表明我们并不总是每分钟收到十条记录。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/39887bc94c067b8a5174ae906ac09111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*py-GXw12kSHDsb-Lm1BN1Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://dashbird.io/" rel="noopener ugc nofollow" target="_blank">仪表板</a>中的Kinesis数据流。图片由作者提供。</p></figure><p id="a2c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Dashbird允许您配置读取或写入限制的警报:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/f1ff2a91a17a6ccc9b3df8c84862b130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQEP4RxiuxJrTd7DMru5Rw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://dashbird.io/" rel="noopener ugc nofollow" target="_blank"> Dashbird </a>中的Kinesis数据流警报。图片由作者提供。</p></figure><p id="0470" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是警报触发后的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/98a0e337af3aead0a467b343cb917191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bwC7uSiDADn0vOnyD5t31g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://dashbird.io/" rel="noopener ugc nofollow" target="_blank"> Dashbird </a>中的Kinesis数据流警报。图片由作者提供。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dd82" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">您应该为您的用例选择哪种服务？</h1><p id="f8da" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这三个服务中，Kinesis是最难使用和规模化运营的一个。最好从一个SNS主题和一个或多个订阅它的SQS队列开始。当你需要对流数据执行类似于<code class="fe ow ox oy nr b">map-reduce</code>的操作时，Kinesis大放异彩，因为它允许你聚合类似的记录并构建实时分析应用程序。但与此同时，监控碎片和Kinesis流吞吐量增加了一些额外的复杂性，并增加了可能出错的错误空间。随着数据的增长或缩减，您需要注意重新分片(当通过向上扩展添加新分片时，<code class="fe ow ox oy nr b">shard split</code>当通过向下扩展删除分片时)，以确保您有足够的吞吐量，并且您不会为空闲分片付费。</p><p id="1d75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对Kinesis数据流的唯一论点是重放数据的能力，那么你可以通过引入一个Lambda函数来达到同样的目的，该函数订阅SNS主题并将所有收到的消息加载到某个数据库，如Timestream、DynamoDB或Aurora。通过利用数据插入的时间戳，您将确切地知道特定消息是何时收到的，这简化了出错时的调试。</p><p id="96f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更容易地为您的用例选择解耦服务，请查看下表，比较这三种服务的特征:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/ab982e111f3e2815c780248c743033dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1UxaEcPZpWx5EAxSUuuGhw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">社交网络对SQS对Kinesis数据流。图片由作者提供。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1c65" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="5981" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们研究了SNS、SQS和Kinesis数据流之间的差异。我们构建了一个简单的演示，展示如何将数据从数据生产者发送到Kinesis，交付流如何消费数据，以及如何监控任何潜在的写节流。对于每个服务，我们演示了如何在Python中使用它，并以一个比较服务特征的表格结束。</p><p id="27d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7f79" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">参考文献</strong></h1><ul class=""><li id="0061" class="na nb it lb b lc mu lf mv li pa lm pb lq pc lu nf ng nh ni bi translated"><a class="ae ky" href="https://docs.aws.amazon.com/streams/latest/dev/key-concepts.html" rel="noopener ugc nofollow" target="_blank">亚马逊Kinesis数据流术语和概念</a></li><li id="49c8" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/26623673/why-should-i-use-amazon-kinesis-and-not-sns-sqs" rel="noopener ugc nofollow" target="_blank">为什么我应该使用亚马逊Kinesis而不是SNS-SQS？</a></li></ul></div></div>    
</body>
</html>