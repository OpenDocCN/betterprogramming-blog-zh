<html>
<head>
<title>UIStackView: Distribution vs. Alignment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">UIStackView:分布与对齐</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/uistackview-distribution-vs-alignment-146b9612e24c?source=collection_archive---------0-----------------------#2019-11-13">https://betterprogramming.pub/uistackview-distribution-vs-alignment-146b9612e24c?source=collection_archive---------0-----------------------#2019-11-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8398" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">UIStackView通过减少约束的数量来简化视图布局</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4f6e3414df50eef390a4aca1b3fc5d28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ikkLy7APUw7_XqQitpE7mw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安妮·斯普拉特在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2ed1" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍</h1><p id="f7a6" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe mu mv mw mx b">UIStackView</code>是iOS 9中引入的最重要、最强大的<code class="fe mu mv mw mx b">UIKit</code>组件之一。它如此强大和优雅，以至于它真的加速了我们许多人放弃对iOS 8的支持。</p><p id="460c" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">对于经常使用自动布局的人来说，你会知道创建<code class="fe mu mv mw mx b">NSLayoutConstraint</code>并不是特别有趣和容易。由于2D屏幕上的每个视图都有四个自由度，这意味着，一般来说，我们必须为每个视图创建至少四个约束。</p><p id="0539" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">那么，回到堆栈视图的介绍，它是一个很大的创新吗？</p><p id="c123" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">不完全是，因为Android的对等物<code class="fe mu mv mw mx b"><a class="ae ky" href="https://developer.android.com/reference/android/widget/LinearLayout" rel="noopener ugc nofollow" target="_blank">LinearLayout</a></code>是在宇宙之初引入的(也称为API级)。不确定为什么苹果花了八年时间才推出这个组件。</p><p id="afa6" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">但不管怎样，我们都很高兴它终于面世了。</p><p id="bd04" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">尽管<code class="fe mu mv mw mx b">UIStackView</code>通过减少我们必须实现的约束数量，大大简化了视图布局，但它仍然会变得相当复杂和令人困惑。</p><p id="6f94" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">堆栈视图有四个主要属性<a class="ae ky" href="https://developer.apple.com/documentation/uikit/uistackview" rel="noopener ugc nofollow" target="_blank">和</a>:</p><ul class=""><li id="0728" class="nd ne it ma b mb my me mz mh nf ml ng mp nh mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uistackview/1616223-axis" rel="noopener ugc nofollow" target="_blank">axis</a></code></li><li id="f3e0" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uistackview/1616233-distribution" rel="noopener ugc nofollow" target="_blank">distribution</a></code></li><li id="cd45" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uistackview/alignment" rel="noopener ugc nofollow" target="_blank">alignment</a></code></li><li id="633d" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uistackview/1616225-spacing" rel="noopener ugc nofollow" target="_blank">spacing</a></code></li></ul><p id="6bfe" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">第一个和最后一个相对简单。我们使用<code class="fe mu mv mw mx b">axis</code>来定义堆栈视图的方向，可以是<code class="fe mu mv mw mx b">vertical</code>或<code class="fe mu mv mw mx b">horizontal</code>。(如果一叠被翻到了一边，就不应该再叫叠了，还是应该🤔？)对于最后一个，<code class="fe mu mv mw mx b">spacing</code>，顾名思义，它指定了栈视图内部视图之间的间距。剩下的两个怎么样:<code class="fe mu mv mw mx b">distribution</code>和<code class="fe mu mv mw mx b">alignment</code>？</p><p id="a4a0" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">尽管<code class="fe mu mv mw mx b">UIStackView</code>已经变得如此流行，在如此多的应用程序中如此常用，但许多人可能并不完全理解它，也可能没有正确使用它。</p><p id="f4fb" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">这就是我们今天要关注的。我们将比较各种<code class="fe mu mv mw mx b">distribution</code>和<code class="fe mu mv mw mx b">alignment</code>设置，看看它们之间有何不同。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5220" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">准备</h1><p id="1567" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在开始之前，我们需要创建几个虚拟视图放入堆栈视图。我们开始吧:</p><pre class="kj kk kl km gt nr mx ns nt aw nu bi"><span id="cc53" class="nv lh it mx b gy nw nx l ny nz">let redDummy = DummyBoxView(width: 40, height: 40, color: .red)<br/>let greenDummy = DummyBoxView(width: 30, height: 80, color: .green)<br/>let blueDummy = DummyBoxView(width: 80, height: 30, color: .blue)</span></pre><p id="f360" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><code class="fe mu mv mw mx b">DummyBoxView</code>的实现非常简单。有一个虚线边框，在中间，有一个标签表明相对宽度和高度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/cc34a791377c878ac0d96e2c6e27dd0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*oKSwkMJyTkHSxJyZiQCFig.jpeg"/></div></figure><p id="ca6f" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">如前所述，堆栈视图有两个<code class="fe mu mv mw mx b">axes</code>(方向:<code class="fe mu mv mw mx b">horizontal</code>或<code class="fe mu mv mw mx b">vertical</code>。但是为了简单起见，我们现在只关注水平堆栈视图。</p><p id="1106" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">对于垂直堆栈视图，我们只需将头部转动90度，对吗？</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="370b" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">分配</h1><p id="1ab8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe mu mv mw mx b">distribution</code>的可能配置有:</p><ul class=""><li id="d406" class="nd ne it ma b mb my me mz mh nf ml ng mp nh mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b">fill</code></li><li id="5c34" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b">fillEqually</code></li><li id="354d" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b">fillProportionally</code></li><li id="8f8b" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b">equalSpacing</code></li><li id="b8b0" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b">equalCentering</code></li></ul><p id="4769" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">让我们看看它们的样子:</p><div class="kj kk kl km gt ab cb"><figure class="ob kn oc od oe of og paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/faed52a7c8ffd49e93c1936e87d281f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*13NdcTUjuEK3xEMrr4chpQ.jpeg"/></div></figure><figure class="ob kn oc od oe of og paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/cbe6103e8d558622faff220323d00010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*4sxQa2VnNm0_Cxrvc1sJvA.jpeg"/></div></figure></div><div class="ab cb"><figure class="ob kn oh od oe of og paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/4836defe7cbf1a4a990874fae90e0785.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*l3XlQSOAIUuu6ixnW0_i_A.jpeg"/></div></figure><figure class="ob kn oh od oe of og paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/31c676ab8a64f3b2dccafb86170529b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*ejjVyhwjbLKL5eXWw8S70Q.jpeg"/></div></figure><figure class="ob kn oh od oe of og paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/219fd8f48df7cb1bcb1486f0aa23f0d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*eVUAw5WaSINWQY3v14Z6MQ.jpeg"/></div></figure></div><p id="7480" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">上面两张图是<code class="fe mu mv mw mx b">equalCentering</code>(左)和<code class="fe mu mv mw mx b">equalSpacing</code>(右)。它们的差异不是很明显，尤其是当子视图的大小相似时。</p><p id="ced1" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">对于<code class="fe mu mv mw mx b">equalCentering</code>，子视图的放置使得视图之间的中心间距相同。对于<code class="fe mu mv mw mx b">equalSpacing</code>，视图之间的间距是相同的。</p><p id="9e7d" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">下面三个图分别是<code class="fe mu mv mw mx b">fillEqually</code>(左)、<code class="fe mu mv mw mx b">fillProportionally</code>(中)、<code class="fe mu mv mw mx b">fill</code>(右)。</p><p id="7c62" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">注意，对于这三个设置，子视图都以某种方式调整大小以填充堆栈视图。<code class="fe mu mv mw mx b">fillEqually</code>和<code class="fe mu mv mw mx b">fillProportionally</code>根据名字应该是相当清楚的。<code class="fe mu mv mw mx b">fillEqually</code>意味着所有的子视图都将被调整大小，使其宽度相同(对于水平堆栈视图)。<code class="fe mu mv mw mx b">fillProportionally</code>另一方面，将根据子视图的大小按比例调整其大小。</p><p id="ddfd" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">但是，刚刚的<code class="fe mu mv mw mx b">fill</code>会怎么样呢？为什么我们的红盒子宽了这么多？</p><p id="caa8" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">使用<code class="fe mu mv mw mx b">fill</code>，堆栈视图将选择一个子视图来调整大小。</p><p id="dc03" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在这种情况下，堆栈视图将选择拥抱优先级最低的子视图。因为我们从来没有明确地设置它，所有的子视图都有相同的默认拥抱优先级。当这种情况发生时，堆栈视图将选择第一个进行拉伸。在这种情况下，红色的会被拉伸，而绿色和蓝色会保持它们的大小。</p><p id="e881" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">关于这三个<code class="fe mu mv mw mx b">fill*</code>设置，最后一件重要的事情是，堆栈视图使用子视图的固有内容大小进行计算。<strong class="ma iu">不是</strong>的车架尺寸！<strong class="ma iu">不是</strong>约束尺寸！</p><p id="38d0" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">你是否好奇为什么它们都排列在堆栈视图的底部？让我们继续下一部分。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2a25" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">对齐</h1><p id="cce1" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe mu mv mw mx b">alignment</code>的可能配置有:</p><ul class=""><li id="a793" class="nd ne it ma b mb my me mz mh nf ml ng mp nh mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b">fill</code></li><li id="5af2" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b">top</code></li><li id="e157" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b">firstBaseline</code></li><li id="4d18" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b">center</code></li><li id="ab95" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b">bottom</code></li><li id="12a8" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b">lastBaseline</code></li></ul><p id="6c22" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">实际上还有两个，即<code class="fe mu mv mw mx b">leading</code>和<code class="fe mu mv mw mx b">trailing</code>，我们现在将忽略它们，因为它们仅适用于垂直堆栈视图。</p><div class="kj kk kl km gt ab cb"><figure class="ob kn oh od oe of og paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/942b78fee7d135365ef4c51e700caf55.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*13NdcTUjuEK3xEMrr4chpQ.jpeg"/></div></figure><figure class="ob kn oh od oe of og paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/988a182da03be101a78f7fd662b89cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*U_k8UTb8sr7Wt1_xqndbjg.jpeg"/></div></figure><figure class="ob kn oh od oe of og paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/c5c489fe65448d7fe6b9092f37eb1930.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*_RJsCSVc36AU98rK_sO6Lw.jpeg"/></div></figure></div><div class="ab cb"><figure class="ob kn oh od oe of og paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/69a02441474e3d50fc81a1b4d7f1a01e.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*tiucGaO1pZSCkvqh5fIEGg.jpeg"/></div></figure><figure class="ob kn oh od oe of og paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/8d5911e831524cb357e4200d35330902.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*dMdTacmeg15Tjlp1lM9vWQ.jpeg"/></div></figure><figure class="ob kn oh od oe of og paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/1489ee68dcec34d305c98c038bc0183d.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*_FKQiqkAuDGwr-xNmNAfkg.jpeg"/></div></figure></div><p id="c748" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">前三个非常清楚:它们是<code class="fe mu mv mw mx b">bottom</code>(左上)、<code class="fe mu mv mw mx b">center</code>(中上)和<code class="fe mu mv mw mx b">top</code>(右上)。正如您可能猜到的，在前面的部分中，所有的图表实际上都使用了<code class="fe mu mv mw mx b">bottom</code>对齐。</p><p id="eb7e" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">下一个是<code class="fe mu mv mw mx b">fill</code>(左下)，stack视图调整其所有视图的大小，以便它们填充垂直于stack视图轴的可用空间。</p><p id="b38c" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">最后两个是最令人困惑的:<code class="fe mu mv mw mx b">firstBaseline</code>(中下)和<code class="fe mu mv mw mx b">lastBaseline</code>(右下)。我不确定光靠名字能得到多少。</p><p id="226b" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">让我们来看看官方的定义:</p><ul class=""><li id="938c" class="nd ne it ma b mb my me mz mh nf ml ng mp nh mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b">firstBaseline</code> : <strong class="ma iu"> </strong>堆栈视图根据其第一条基线排列视图的布局。</li><li id="ea32" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b">lastBaseline</code>:一种布局，其中堆栈视图根据其最后的基线对齐其排列的视图。</li></ul><p id="2e3f" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">定义类似于我问你什么是“火柴盒”，你告诉我是“火柴盒”。让我们再看一组带有更多子视图的例子。</p><div class="kj kk kl km gt ab cb"><figure class="ob kn oc od oe of og paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/19cf4115a9dcf019838afbdec7e4e816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*0O67XCrPLF-aZtDhxhxOmg.jpeg"/></div></figure><figure class="ob kn oc od oe of og paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/0bd1424e7b1acfc698d8b6b209154014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*-So4xHGaX2XN-gPTndDvBg.jpeg"/></div></figure></div><ul class=""><li id="e233" class="nd ne it ma b mb my me mz mh nf ml ng mp nh mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b">firstBaseline</code>(左)类似于<code class="fe mu mv mw mx b">top</code>，所有子视图都是顶部对齐的。但是，它们被放置在堆栈视图的底部。</li><li id="76d7" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated"><code class="fe mu mv mw mx b">lastBaseline</code>(右)类似于<code class="fe mu mv mw mx b">bottom</code>，所有子视图都是底部对齐的。但是，它们被放置在堆栈视图的顶部。</li></ul><p id="f451" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我很难想象这会有什么用处。但是显然，它对于对齐多行文本视图是有意义的。这里就不赘述了。但是如果你有兴趣的话，stackoverflow上的这个<a class="ae ky" href="https://stackoverflow.com/a/33934323/1035008" rel="noopener ugc nofollow" target="_blank">回答</a>解释的很好。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6d9b" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">垂直堆栈视图怎么样？</h1><p id="9749" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">实际上，一切都还是老样子。唯一的一点就是<code class="fe mu mv mw mx b">top</code>和<code class="fe mu mv mw mx b">bottom</code>要换成<code class="fe mu mv mw mx b">leading</code>和<code class="fe mu mv mw mx b">trailing</code>。实际上，它们在枚举中是相同的整数。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="419a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">结尾</strong></h1><p id="e27f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">好了，这就是堆栈视图的全部内容。最后，你能猜出这个堆栈视图的设置是什么吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/81b456a62b420bdfbfd9748d85d4f0ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*eJj3epLuParK2-HCX-vojw.jpeg"/></div></figure><ul class=""><li id="bc87" class="nd ne it ma b mb my me mz mh nf ml ng mp nh mt ni nj nk nl bi translated">提示1:不是底部对齐。</li><li id="40b5" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated">有一个看不见的视角。</li></ul><p id="67d3" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">一如既往的感谢阅读！在<a class="ae ky" href="https://github.com/yzhong52/StackViewDemo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上可以找到演示代码和完整的示例集。</p></div></div>    
</body>
</html>