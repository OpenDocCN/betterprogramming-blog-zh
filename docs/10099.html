<html>
<head>
<title>Why You Shouldn’t Use @EnvironmentObject in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么不应该在SwiftUI中使用@EnvironmentObject</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-you-shouldnt-use-environmentobject-in-swiftui-a527d5c2bd?source=collection_archive---------1-----------------------#2021-11-29">https://betterprogramming.pub/why-you-shouldnt-use-environmentobject-in-swiftui-a527d5c2bd?source=collection_archive---------1-----------------------#2021-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9c99" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">默认SwiftUI依赖注入机制的缺点</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/10f6bedf63f8aa728ede8232397277bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9CAdJ46eL90PekPq"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@agungraharja?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿贡·拉哈尔贾</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="01a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建可伸缩和可维护的应用程序需要掌握的主要主题之一是<a class="ae ky" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>。SwiftUI附带了一个用于注入依赖项的舒适API:<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/swiftui/environmentobject" rel="noopener ugc nofollow" target="_blank">EnvironmentObject</a></code>API，由一个属性包装器和一个视图修改器组成。</p><p id="fbd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这些API非常舒适，但它们有几个限制，使它们不适合大型应用程序。主要缺点是:</p><ul class=""><li id="5869" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">它们使得针对接口编程变得困难。</li><li id="bd8f" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">它们使得编写测试变得困难。</li></ul><p id="7aaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天的文章中，我们将探索什么是<code class="fe lv lw lx ly b">EnvironmentObject</code>，我们将深入探究其局限性，并尝试探索如何克服它们。</p><h1 id="11dd" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">实践中的环境目标</h1><p id="4299" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">当我们必须在视图之间共享对象时，使用<code class="fe lv lw lx ly b">@EnvironmentObject</code>属性包装器是Apple建议的基本方法。通常，我们希望共享依赖关系:执行应用程序多个部分所需操作的对象。</p><p id="e1e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个基本的设置来使用<code class="fe lv lw lx ly b">EnvironmentObject</code> API。对于本文，我创建了一个简单的<code class="fe lv lw lx ly b">PIDecimalGenerator</code>，它生成<code class="fe lv lw lx ly b">PI</code>的第一个十进制数字。这是我们想要注入到我们的层次结构中的对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9a6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发电机必须符合<code class="fe lv lw lx ly b">ObservableObject</code>，并且必须是<code class="fe lv lw lx ly b">class</code>。当它被创建时，我们将<code class="fe lv lw lx ly b">PI</code>的数字存储在一个数组中，而不是每次都重新计算它们。</p><p id="1c51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器提供了一个名为<code class="fe lv lw lx ly b">getElement(at:)</code>的方法来检索给定<code class="fe lv lw lx ly b">position</code>中的数字。</p><p id="f639" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们有了目标，我们就开始注射。让我们转到<code class="fe lv lw lx ly b">App.swift</code>文件，然后:</p><ol class=""><li id="c2c1" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu nm mf mg mh bi translated">添加一个属性来存储生成器。</li><li id="1857" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">使用<code class="fe lv lw lx ly b">.environmentObject</code>视图修改器将其注入。</li></ol><p id="669a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="cd7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第3行，我们创建了生成器；在第7行，我们注入它。</p><p id="5151" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们在<code class="fe lv lw lx ly b">ContentView</code>中消费注入的对象。代码很简单:我们创建一个相同类型的变量，并用<code class="fe lv lw lx ly b">@EnvironmentObject</code>属性包装器对其进行注释。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0327" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个玩具示例中，我们希望呈现列表中的数字。我们定义想要呈现的位数和生成器，将其标注为<code class="fe lv lw lx ly b">@EnvironmentObject</code>。</p><p id="d746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">body</code>属性中，我们创建了一个<code class="fe lv lw lx ly b">List</code>，其中每个元素都是一个数字。在屏幕底部，我们添加了一个按钮来添加额外的数字。当生成器停止返回有效数字时，我们开始追加<code class="fe lv lw lx ly b">-1</code>。</p><p id="4ba1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的GIF说明了应用程序的行为。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/74424b2c208caf6008227da3f49ae989.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/1*s6VA3P-1ldm_Ckcqku8h2Q.gif"/></div></figure><h1 id="6f5d" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">交换实现</h1><p id="594f" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><strong class="lb iu">依赖注入</strong>的好处之一就是<a class="ae ky" href="https://en.wikipedia.org/wiki/Late_binding" rel="noopener ugc nofollow" target="_blank">后期绑定</a>。后期绑定让我们可以推迟决定使用哪个实现作为依赖项。</p><p id="dd6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，一个应用程序可以从配置文件中选择要使用的存储类型。如果有内存存储、文件存储和SQL存储的实现，应用程序可以等到启动后才知道必须使用哪个实现。使用依赖关系的组件并不关心实际使用的是哪个存储。正是注入依赖关系的组合根决定了实现。</p><p id="7e91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们这个简单的例子中，这意味着我们的<code class="fe lv lw lx ly b">ContentView</code>不应该关心我们是为<code class="fe lv lw lx ly b">PI</code>、为<code class="fe lv lw lx ly b">e</code>传递一个生成器，一个RNG还是一个常量生成器。它必须和所有人一起工作。</p><p id="0b5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们查看视图的代码，我们可以看到它被绑定到了<code class="fe lv lw lx ly b">PIDecimalGenerator</code>类型。这将<code class="fe lv lw lx ly b">ContentView</code>与生成器的具体实现结合起来。</p><p id="dfb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Swift中解决这个问题的典型方法是定义一个描述我们对象行为的协议:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a5ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">PIDecimalGenerator</code>必须符合它。在编写协议一致性时，我们还可以添加一个<code class="fe lv lw lx ly b">ConstantGenerator</code>，这样我们就有两个不同的生成器可以使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="23b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们试图使用<code class="fe lv lw lx ly b">NumberGenerator</code>协议作为<code class="fe lv lw lx ly b">ContentView</code>中的类型，我们会得到一个糟糕的惊喜:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/b101751ff16b47cc9746c44bab6511e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7M3N3w7yLeHoC3CzufHRUQ.png"/></div></div></figure><p id="d641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误说<code class="fe lv lw lx ly b">NumberGenerator</code>不符合<code class="fe lv lw lx ly b">ObservableObject</code>。这是一个简单的解决方法:让我们使<code class="fe lv lw lx ly b">NumberGenerator</code>协议符合<code class="fe lv lw lx ly b">ObservableObject</code>。这让我们从特定的生成器中删除了<code class="fe lv lw lx ly b">ObservableObject</code>一致性:此时对<code class="fe lv lw lx ly b">ObservableObject</code>的一致性变得多余，因为它被对<code class="fe lv lw lx ly b">NumberGenerator</code>的一致性所隐含。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ee95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果我们再次尝试构建，我们会得到一个不同的错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/7c8a9eeca224b14366883cba0d36a1d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8RQUQA2ZUoqpAmpHUtrb_g.png"/></div></div></figure><p id="5621" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们在处理带有关联值的协议时遇到的典型错误。事实上，ObservableObject协议有一个关联的类型<code class="fe lv lw lx ly b">ObjectWillChangePublisher</code>，它也在使用<code class="fe lv lw lx ly b">Self</code>。</p><p id="cf83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种方法可以解决这个问题:使用继承和使用类型擦除。</p><h2 id="b01c" class="nq mo it bd mp nr ns dn mt nt nu dp mx li nv nw mz lm nx ny nb lq nz oa nd ob bi translated"><strong class="ak">继承</strong></h2><p id="57d5" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">这是最直观的解决方法。我们不能使用协议，但是我们可以使用类。所以我们可以创建一个抽象的<code class="fe lv lw lx ly b">NumberGenerator</code>类，让我们的生成器成为它们的具体实现。</p><p id="a5e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们以这段代码结束:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8f6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将<code class="fe lv lw lx ly b">protocol</code>转换成了一个抽象类。Swift没有它们的语法，所以我们使用了一个<code class="fe lv lw lx ly b">fatalError</code>来强制子类实现所需的方法。</p><p id="0165" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须在<code class="fe lv lw lx ly b">init()</code>和两个<code class="fe lv lw lx ly b">getElement(at:)</code>方法之前添加<code class="fe lv lw lx ly b">override</code>关键字。</p><p id="4353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在应用程序构建完毕，让我们试着运行它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/f94ce83d1b06fd340db8d8dbbdb360d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gflj3yKmPkJdr2xrZzMBLA.png"/></div></div></figure><p id="8ee9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在运行应用程序，它会构建，但我们会得到这个致命的错误。问题是SwiftUI试图获得一个类型完全是<code class="fe lv lw lx ly b">NumberGenerator</code>的<code class="fe lv lw lx ly b">EnvironmentObject</code>。</p><p id="2734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们所有的生成器，特别是我们传递给视图的<code class="fe lv lw lx ly b">PIDecimalGenerator</code>，都是<code class="fe lv lw lx ly b">NumberGenerator</code>。由于<a class="ae ky" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">利斯科夫替代原理</strong> </a>，我们期望这段代码能够正常工作，但事实并非如此。SwiftUI和<code class="fe lv lw lx ly b">@EnvironmentObject</code>违反了这一原则，因为属性包装器正在搜索一个类型正好是<code class="fe lv lw lx ly b">NumberGenerator</code>的对象，并且它的一个子类不允许。</p><p id="0a08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为属性包装和视图修饰符实际上使用通用包装改变了属性和视图的类型。具体来说，使用<code class="fe lv lw lx ly b">.environmentObject</code>视图修饰符的视图变成了<code class="fe lv lw lx ly b">ModifiedView&lt;OriginalViewType, _&gt;</code>，而使用<code class="fe lv lw lx ly b">@EnvironmentObject</code>属性包装的属性注释变成了类型<code class="fe lv lw lx ly b">EnvironmentObject&lt;PropertyType&gt;</code>的属性。</p><p id="e235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Swift中，泛型不享受<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/generics-and-subtypes-in-swift-7f27638e1b99">协方差属性</a> : <code class="fe lv lw lx ly b">GenericWrapper&lt;Subclass&gt;</code>不是<code class="fe lv lw lx ly b">GenericWrapper&lt;ParentClass&gt;</code>的子类。在Swift不支持通用参数的协方差之前，我们无法拥有与子类无缝协作的属性包装器。</p><p id="3cdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这是一个容易解决的问题。我们必须确保<code class="fe lv lw lx ly b">App</code>通过使用父类型来声明生成器。当这种情况发生时，SwiftUI使用父类创建树:如果所有组件都使用父类，一切都正常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ddc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在第2行中指定<code class="fe lv lw lx ly b">generator</code>类型，我们放弃了类型推断的能力，但是现在我们可以用<code class="fe lv lw lx ly b">ConstantGenerator</code>替换<code class="fe lv lw lx ly b">PIDecimalGenerator</code>，应用程序可以工作了。</p><h2 id="39f0" class="nq mo it bd mp nr ns dn mt nt nu dp mx li nv nw mz lm nx ny nb lq nz oa nd ob bi translated">类型擦除</h2><p id="c2e6" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">前一个解决方案迫使我们使用继承，并使我们在如何指定应用程序中的类型上妥协。我们可以使用另一个解决方案来避免这种情况:我们可以定义一个类型擦除来定义任何生成器的行为。</p><p id="f77f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案使用组合而不是继承:我们将生成器包装成它的类型擦除版本。这是苹果很多框架中常用的解决方案:<code class="fe lv lw lx ly b">Combine</code>有<code class="fe lv lw lx ly b">AnyPublisher</code>，SwiftUI有<code class="fe lv lw lx ly b">AnyView</code>。</p><p id="770c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们创建我们的<code class="fe lv lw lx ly b">AnyGenerator</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="448c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要重新创建<code class="fe lv lw lx ly b">NumberGenerator</code>协议:所有的生成器都遵循相同的接口。<code class="fe lv lw lx ly b">protocol</code>不再需要延伸<code class="fe lv lw lx ly b">ObservableObject</code>就可以作为普通类型使用。</p><p id="0d98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">AnyGenerator</code>型符合<code class="fe lv lw lx ly b">ObservableObject</code>和<code class="fe lv lw lx ly b">NumberGenerator</code>协议。该类型将生成器作为参数，并将对<code class="fe lv lw lx ly b">getElement(at:)</code>的调用转发给生成器的等效方法。</p><p id="260d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他生成器必须符合<code class="fe lv lw lx ly b">NumberGenerator</code>协议:它们不需要成为<code class="fe lv lw lx ly b">ObservableObject</code>。</p><p id="d769" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们更新应用程序，使用<code class="fe lv lw lx ly b">AnyGenerator</code>类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9bdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里可以看到生成器类型声明可以省略。我们正在创建<code class="fe lv lw lx ly b">AnyGenerator</code>对象，传递其他生成器之一。</p><p id="1a61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也必须更新<code class="fe lv lw lx ly b">ContentView</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d55c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以运行应用程序，它工作了。我们可以将<code class="fe lv lw lx ly b">PIDecimalGenerator</code>与<code class="fe lv lw lx ly b">ConstantGenerator</code>互换，应用程序继续工作。</p><p id="3620" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的权衡是代码的复杂性。我们正在针对一个接口进行编程，即<code class="fe lv lw lx ly b">NumberGenerator</code>协议，但是我们必须将其具体化为另一种类型，即<code class="fe lv lw lx ly b">AnyGenerator</code>。为了创建一个<code class="fe lv lw lx ly b">AnyGenerator</code>，我们需要传递期望的生成器，因此对象图变得更加复杂。</p><h1 id="a9a5" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">易测性</h1><p id="ea3a" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">依赖注入的另一个好处是你的代码很容易被测试。我们可以为我们所有的依赖项创建测试副本，并且我们可以根据需要模拟它们、窥探它们或者截掉它们。</p><p id="9b35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原则上，<code class="fe lv lw lx ly b">EnvironmentObject</code>也应该允许我们这么做。我们可以准备一个单元测试，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="fc6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们用<code class="fe lv lw lx ly b">⌘+U</code>运行它，它会崩溃并出现致命错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/5eff43e5ad0a71c176b02eaf686e5fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VIb7kXrRvmVyXkH5pNNWgw.png"/></div></div></figure><p id="1503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是意料之中的:我们没有以任何方式注入发生器。我们可以想到的第一个想法是使用<code class="fe lv lw lx ly b">.environmentObject</code>视图修改器将一个生成器注入到测试中。代码将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9eaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，这样做的话，我们最终会得到这个错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/62765ad982064b61e0ad9eba922b5e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U4TIX8_SaUJz165bpKLvpw.png"/></div></div></figure><p id="1687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe lv lw lx ly b">sut</code>的型号从<code class="fe lv lw lx ly b">ContentView</code>变成了<code class="fe lv lw lx ly b">some View</code>。如果我们实际尝试打印<code class="fe lv lw lx ly b">sut</code>类型，它的具体值是:</p><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="5026" class="nq mo it ly b gy oj ok l ol om"><strong class="ly iu">ModifiedContent&lt;ContentView, _EnvironmentKeyWritingModifier&lt;Optional&lt;AnyGenerator&gt;&gt;&gt;</strong></span></pre><p id="e277" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为<code class="fe lv lw lx ly b">environmentObject</code>修饰符实际上通过使用一个通用的包装器来改变视图的类型。并且包装器没有<code class="fe lv lw lx ly b">getDecimal</code>方法。</p><p id="ff61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写这个测试的另一个尝试是设置备份属性包装器的<code class="fe lv lw lx ly b">_generator</code>属性。但是，这个财产是私有的，我们不能操纵。</p><h2 id="e314" class="nq mo it bd mp nr ns dn mt nt nu dp mx li nv nw mz lm nx ny nb lq nz oa nd ob bi translated">如何检验这个观点</h2><p id="669c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">遗憾的是，无法使用普通的SwiftUI方法测试视图。至少，我找不到一种简单的方法。为了实现这个目标，我们可以依靠像<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/nalexn/ViewInspector/" rel="noopener ugc nofollow" target="_blank">ViewInspector</a></code>这样的库。</p><p id="8787" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-test-swiftui-views-smartly-6c6b13f9edb1">将这个库添加到我们的测试目标</a>中，然后我们可以检查SwiftUI层次结构并访问内容视图。还有其他与属性包装器相关的可测试性问题，这使得测试SwiftUI视图变得很困难:来自<code class="fe lv lw lx ly b">ViewInspector</code>的人创建了一个<a class="ae ky" href="https://github.com/nalexn/ViewInspector/blob/master/guide.md#views-using-state-environment-or-environmentobject" rel="noopener ugc nofollow" target="_blank">指南</a>，其中有一章专门介绍如何测试使用它们的<code class="fe lv lw lx ly b">Views</code>。</p><p id="5d7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用这个库，我们需要修改生产代码，这样<code class="fe lv lw lx ly b">ViewInspector</code>库就可以施展它的魔法了。这些必需的更改是为了支持测试而添加的，我们不会在生产中使用它们。</p><h1 id="73cf" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="7d64" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在今天的文章中，我们探索了<code class="fe lv lw lx ly b">EnvironmentObject</code>属性包装器和相关的视图修饰符。我们实现了它们，并在一些类似真实世界的环境中使用它们。</p><p id="cc1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们发现这项技术打破了利斯科夫替代原理，否定了后期绑定。尽管如此，我们讨论了如何利用继承或类型擦除来解决这个问题。</p><p id="279b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们看到他们很难测试我们的观点。我们试图了解问题的根本原因，如果不使用外部库，我们无法找到简单的解决方案。</p><p id="36f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">失去后期绑定和可测试性是完全避免环境对象API的足够大的理由。一个更好的方法是显式定义依赖项，并在<code class="fe lv lw lx ly b">View</code>初始化器中传递它们。</p></div></div>    
</body>
</html>