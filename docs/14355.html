<html>
<head>
<title>Create an Avengers Snap Effect With Canvas and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用画布创建复仇者联盟快照效果并做出反应</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/avengers-snap-effect-with-canvas-and-react-ab698de17bc?source=collection_archive---------5-----------------------#2022-12-02">https://betterprogramming.pub/avengers-snap-effect-with-canvas-and-react-ab698de17bc?source=collection_archive---------5-----------------------#2022-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f3de" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们让另一个漫威角色消失吧！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/17e029892a79dc259858999448349d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P-wQVmiEFdrgWnou"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.marvel.com/movies/avengers-infinity-war" rel="noopener ugc nofollow" target="_blank">图片来自复仇者联盟3：无限战争</a></p></figure><p id="caa5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近我在迪士尼+上狂看复仇者联盟电影(又一次！)，当我看到灭霸打响指，把几乎所有人都变成了尘土时，我想起了多年前用Adobe Flash制作的一部老动画。这是一个与电影惊人相似的图像的溶解效果。</p><p id="7f3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章将教我们如何用图像像素制作粒子，并分别制作它们的动画。</p><p id="6865" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，这是我们要做的效果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="69f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">酷，我们开始吧！</p><blockquote class="lu lv lw"><p id="d0d9" class="kw kx lx ky b kz la jr lb lc ld ju le ly lg lh li lz lk ll lm ma lo lp lq lr ij bi translated"><strong class="ky ir">快速提示:</strong>尽管标题写的是React，但是动画代码是用裸JavaScript写的，所以你可以很容易地用document.querySelector或者等效的东西改变React部分。</p></blockquote><h1 id="b9dd" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">准备我们的画布</h1><p id="c607" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">我们这个项目的受害者，正如你在视频中看到的，将是旺达·马克西莫夫，又名斯嘉丽女巫。当然，你可以选择任何你想要的MCU字符。只是要注意，图像应该有一个透明的背景，不要因为性能原因而太大。600x400之类的应该可以。</p><p id="8c38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们首先添加一个画布，并在其中加载我们的图像。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my lt l"/></div></figure><p id="cf0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的代码非常简单。首先，我们为画布创建<code class="fe mz na nb nc b">ref</code>，然后在<code class="fe mz na nb nc b">useEffect</code>中检查画布是否被加载。如果是这样，我们访问上下文并将画布的宽度和高度设置为窗口的内部尺寸。这使得我们的画布占据了整个屏幕(画布大小应该以单位来定义，CSS单位本身是不够的)。</p><p id="024a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些样式的宽度和高度都是100%，所以我们将在完整的视口中工作。</p><p id="1cd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们加载图像元素，并通过context的<code class="fe mz na nb nc b">drawImage</code>方法将它绘制到画布中。第二个和第三个参数是图像的位置，所以通过简单的计算，我们可以将图像放在页面的中央。</p><p id="61d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前为止，没什么特别的。我们只是在屏幕中间展示我们的旺达。我们现在将为这些粒子生成粒子和一个发生器(或者说，如果你想的话，控制器)。</p><h1 id="2ad3" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">粒子类别</h1><p id="badf" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">为了创建粒子，我们将从OOP语言中编写你可能熟悉的类。这将使我们的代码变得干净，并允许我们更容易地进行修改。</p><p id="3c1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们从这样一个<code class="fe mz na nb nc b">Particle</code>类开始。您可以将这段代码放在React函数之外的任何地方。</p><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="2953" class="nh mc iq nc b be ni nj l nk nl">class Particle {<br/>  constructor(x, y, color) {<br/>    this.color = color;<br/>    this.x = x;<br/>    this.y = y;<br/>    this.size = 5;<br/>   }<br/><br/>  draw(context) {<br/>    context.fillStyle = this.color;<br/>    context.fillRect(this.x, this.y, this.size, this.size);<br/>  }<br/>  update() {<br/>    <br/>  }<br/>}</span></pre><p id="9397" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的粒子将是一个在<code class="fe mz na nb nc b">5px</code>中的小矩形，它采用<code class="fe mz na nb nc b">x</code>和<code class="fe mz na nb nc b">y</code>参数来确定它在画布中的位置，以及哪些<code class="fe mz na nb nc b">color</code>参数需要用哪种颜色填充。<code class="fe mz na nb nc b">draw</code>方法使我们的矩形以指定的大小和颜色出现。此外，我们添加了一个更新方法，我们将很快实现它。</p><p id="d94f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">继续我们的<code class="fe mz na nb nc b">Generator</code>，在<code class="fe mz na nb nc b">Particle</code>类之后添加这段代码:</p><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="ab04" class="nh mc iq nc b be ni nj l nk nl">class Generator {<br/>  constructor(width, height) {<br/>    this.width = width;<br/>    this.height = height;<br/>    this.particlesArray = [];<br/>  }<br/><br/>  init(context) {<br/>    this.particlesArray.push(new Particle(10, 10, 'red'));<br/>  }<br/><br/>  draw(context) {<br/>    this.particlesArray.forEach((particle) =&gt; particle.draw(context));<br/>  }<br/><br/>  update() {<br/>    this.particlesArray.forEach((particle) =&gt; particle.update());<br/>  }<br/>}</span></pre><p id="1909" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">generator</code>类也非常简单。它的行为就像一个控制器和一个容器，具有与<code class="fe mz na nb nc b">Particle</code>类相同的方法，允许我们生成、绘制和更新屏幕上的所有粒子。我们通过创建一个空数组并将每个生成的粒子推入其中，然后循环遍历该数组并调用粒子自己的draw和update方法来实现这一点。它画了一个红色的粒子，但是稍后我们会把它变成我们的图像像素。</p><p id="6890" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不错！到目前为止，我希望没有什么是不清楚的，因为我们将潜入更具挑战性的东西。</p><h1 id="2631" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">从图像中获取像素信息</h1><p id="f6a8" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">如前所述，我们将根据图像的像素生成粒子，并通过这些粒子重建图像。为此，<code class="fe mz na nb nc b">Canvas</code>元素具有<code class="fe mz na nb nc b">getImageData</code>方法，该方法返回指定画布区域的所有像素的颜色数据(更多信息请访问:<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/getImageData" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/canvasrenderingcontext 2d/getImageData</a>)。</p><p id="d304" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，在<code class="fe mz na nb nc b">Generator</code>的<code class="fe mz na nb nc b">init</code>方法中，用下面的一行替换我们生成粒子的那一行:</p><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="deec" class="nh mc iq nc b be ni nj l nk nl">init(context) {<br/>    const pixels = context.getImageData(0, 0, this.width, this.height).data;<br/>}</span></pre><p id="1b9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们<code class="fe mz na nb nc b">console.log(pixels)</code>在这一点上，并检查开发人员的工具，我们会看到像这样的嵌套数组吨:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/4a11efc71469f870e869ea57f542aee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*RZpPXnmn-HpiMgGE5Tc9HQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">什么da！？？</p></figure><p id="1eb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为<code class="fe mz na nb nc b">getImageData</code>在<code class="fe mz na nb nc b">Uint8ClampedArray</code>中返回原始数据(此处钳位表示其值在0到255之间)而不是格式化数据。现在，如果您检查该数组的值，您会注意到大多数值都是<code class="fe mz na nb nc b">0</code>。但是，如果您在列表中间选择一个数组系列，您可能会看到如下一些值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/58b4548d8f1705da6f323d33dc869ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*8zPu-QLKMUSJgXQE2CL4pg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">现在我们有进展了！</p></figure><p id="583e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为这很明显。这些值是像素的颜色数据。<code class="fe mz na nb nc b">255</code>是alpha值，在它们之前的每三个值分别是红色、绿色和蓝色。因为我们的图像位于屏幕的中间，所以我们遇到中间行的值也就不足为奇了。</p><p id="1d80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好，那么我们如何处理这些数组呢？因为它们是嵌套的，所以我们需要一个嵌套结构来解析它们。修改<code class="fe mz na nb nc b">init</code>如下:</p><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="ceba" class="nh mc iq nc b be ni nj l nk nl">init(context) {<br/>    const pixels = context.getImageData(0, 0, this.width, this.height).data;<br/>     for (let y = 0; y &lt; this.height; y++) {<br/>      for (let x = 0; x &lt; this.width; x++) {<br/>        const index = (y * this.width + x) * 4;<br/>        const red = pixels[index];<br/>        const green = pixels[index + 1];<br/>        const blue = pixels[index + 2];<br/>        const alpha = pixels[index + 3];<br/>        const color = `rgb(${red}, ${green}, ${blue})`;<br/><br/>        if (alpha &gt; 0) {<br/>          this.particlesArray.push(new Particle(x, y, color));<br/>        }<br/>      }<br/>    }<br/>}</span></pre><p id="4419" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该死的代码！嗯，我能说的是，你不需要理解它，但我们做的是他们所说的图像算法中的“扫描线”。我们遍历画布的每一个像素，每四个值得到一个锚。然后我们选择它们之间的值，并将它们连续分配给RGBA变量。最后，我们用alpha值为每个像素生成一个粒子——意味着不为空。</p><p id="3ae1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你运行代码时，你会看到我们的图像的副本显示在我们的原始图像之上，但是这次，它是由我们的粒子组成的。在动画开始时，我们将删除原始图像，这样我们将只看到我们的粒子。</p><p id="b471" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们回到我们的<code class="fe mz na nb nc b">useEffect</code>并添加以下几行:</p><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="7279" class="nh mc iq nc b be ni nj l nk nl">useEffect(() =&gt; {<br/>    const canvas = canvasRef.current;<br/><br/>    if (canvas) {<br/>      const ctx = canvas.getContext("2d");<br/>      ctx.imageSmoothingEnabled = false;<br/><br/>      canvas.width = window.innerWidth;<br/>      canvas.height = window.innerHeight;<br/><br/>      const generator = new Generator(canvas.width, canvas.height);<br/><br/>      const image = new Image();<br/><br/>      image.onload = function () {<br/>        ctx.drawImage(<br/>          image,<br/>          canvas.width / 2 - image.width / 2,<br/>          canvas.height / 2 - image.height / 2<br/>        );<br/><br/>        generator.init(ctx);<br/>       <br/>        startAnimation(<br/>          generator,<br/>          ctx,<br/>          canvas.width,<br/>          canvas.height,<br/>        );<br/>      };<br/>      image.src = "/images/wanda.png";<br/>    }<br/>  }, []);</span></pre><p id="3602" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们初始化我们的<code class="fe mz na nb nc b">Generator</code>，在<code class="fe mz na nb nc b">init</code>中传递我们的画布大小和上下文。此外，我们单独定义我们的动画功能。我们可能会将它保存在<code class="fe mz na nb nc b">useEffect</code>中，但是我们需要确保它运行一次。所以，我们用<code class="fe mz na nb nc b">useCallback</code>把这个部分包起来，放在<code class="fe mz na nb nc b">useEffect</code>上面。</p><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="d998" class="nh mc iq nc b be ni nj l nk nl">const startAnimation = useCallback((generator, ctx, w, h, count) =&gt; {<br/>     function animate() {<br/>      ctx.clearRect(0, 0, w, h);<br/>      generator.draw(ctx);<br/>      generator.update();<br/>      requestAnimationFrame(animate);<br/>    }<br/>    setTimeout(() =&gt; animate(), 2000);<br/>  }, []);</span></pre><p id="b10b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是动画发生的地方。首先，我们从<code class="fe mz na nb nc b">setTimeout</code>开始，给观众一小段时间看原始图像，这样他们就能明白动画是如何开始的。稍后，我们的<code class="fe mz na nb nc b">animate()</code>函数运行并首先清除我们的画布(我们的原始图像以这种方式消失)，然后调用<code class="fe mz na nb nc b">Generator</code>的draw和update方法，这实际上是调用<code class="fe mz na nb nc b">Particle</code>的draw和update方法来使用更新的粒子绘制整个画布。用<code class="fe mz na nb nc b">window.requestAnimationFrame</code>或简单地说，<code class="fe mz na nb nc b">requestAnimationFrame</code>我们冲洗并重复这个过程。</p><p id="1d55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好，所以在运行我们的代码之前，我们需要更新我们的<code class="fe mz na nb nc b">Particle</code>类，否则什么都不会发生:</p><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="c85f" class="nh mc iq nc b be ni nj l nk nl">lass Particle {<br/>  constructor(x, y, color) {<br/>    this.color = color;<br/>    this.x = x;<br/>    this.y = y;<br/>    this.size = 5;<br/>    this.vx = -Math.random() * 2;<br/>    this.vy = -Math.random() * 2;<br/>    this.vFactor = 1.01;<br/>  }<br/><br/>  draw(context) {<br/>    context.fillStyle = this.color;<br/>    context.fillRect(this.x, this.y, this.size, this.size);<br/>  }<br/>  update() {<br/>    this.x += this.vx;<br/>    this.y += this.vy;<br/>    this.vx *= this.vFactor;<br/>    this.vy *= this.vFactor;<br/>  }<br/>}</span></pre><p id="54fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们将速度值添加为<code class="fe mz na nb nc b">vx</code>和<code class="fe mz na nb nc b">vy</code>，并让它们具有在<code class="fe mz na nb nc b">0</code>和<code class="fe mz na nb nc b">2</code>之间的随机值。还要注意，它们是负值，允许粒子在屏幕的左边向上移动。这将产生一些微风从右边吹来的效果。我还添加了一个速度倍增器<code class="fe mz na nb nc b">vFactor</code>，让粒子随着时间加速。</p><p id="1b12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，让我们来看看目前我们有什么:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my lt l"/></div></figure><p id="141a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很好！现在，如果我们运行代码，我们短暂地看到旺达的图像，然后它会完全爆发成粒子而不是溶解。这不是我们想要的，而且它也很慢。</p><p id="a0ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为我们添加了比我们需要的更多的粒子。粒子大小是<code class="fe mz na nb nc b">5</code>，但是我们为每个像素生成粒子。为了解决这个问题，引入一个<code class="fe mz na nb nc b">gap</code>变量，这样我们可以生成更少的粒子:</p><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="6190" class="nh mc iq nc b be ni nj l nk nl">class Generator {<br/>  constructor(width, height) {<br/>    this.width = width;<br/>    this.height = height;<br/>    this.particlesArray = [];<br/>    this.gap = 5;<br/>  }<br/><br/>  init(context) {<br/>    const pixels = context.getImageData(0, 0, this.width, this.height).data;<br/>    for (let y = 0; y &lt; this.height; y += this.gap) {<br/>      for (let x = 0; x &lt; this.width; x += this.gap) {<br/>        const index = (y * this.width + x) * 4;<br/>        const red = pixels[index];<br/>        const green = pixels[index + 1];<br/>        const blue = pixels[index + 2];<br/>        const alpha = pixels[index + 3];<br/>        const color = `rgb(${red}, ${green}, ${blue})`;<br/><br/>        if (alpha &gt; 0) {<br/>          this.particlesArray.push(new Particle(x, y, color));<br/>        }<br/>      }<br/>    }<br/><br/>   ...<br/>}</span></pre><p id="4da7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">间隙值等于像素大小。这样，我们可以获得图像中每五个像素的颜色值，而不是更多，并相应地生成粒子。</p><p id="57e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您现在运行它，您会看到动画已被修复，但它仍然是错误的。我们更希望看到一种始于头部，止于脚趾的瓦解效果，就像电影里那样。让我们进入下一章，就这样做吧。</p><h1 id="e533" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">丰富</h1><p id="9f48" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">好的，那么动画从顶部开始，在底部结束的方式是什么？我们应该告诉上面的像素立即动画，其他人等待他们的线。JavaScript中延迟事情的方法是用<code class="fe mz na nb nc b">setTimeout</code>函数包装它们，在这里使用会非常冒险。这是因为我们只有<code class="fe mz na nb nc b">requestAnimationFrame</code>，它以毫秒为单位运行。那么，我们为什么不用这个函数呢？让我们修改一些部分:</p><p id="ece7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先让我们得到<code class="fe mz na nb nc b">Generator</code>中粒子的长度:</p><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="5130" class="nh mc iq nc b be ni nj l nk nl">init(context) {<br/>    const pixels = context.getImageData(0, 0, this.width, this.height).data;<br/>    for (let y = 0; y &lt; this.height; y += this.gap) {<br/>      for (let x = 0; x &lt; this.width; x += this.gap) {<br/>       ....<br/>      }<br/>    }<br/><br/>    return this.particlesArray.length;<br/>}</span></pre><p id="877d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后得到这个总数，并将其传递给<code class="fe mz na nb nc b">useEffect</code>上的<code class="fe mz na nb nc b">startAnimation</code>。</p><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="9413" class="nh mc iq nc b be ni nj l nk nl">...  <br/>const particlesCount = generator.init(ctx);<br/>   startAnimation(<br/>      generator,<br/>      ctx,<br/>      canvas.width,<br/>      canvas.height,<br/>      particlesCount<br/>   );<br/>...<br/></span></pre><p id="ee7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，给我们的<code class="fe mz na nb nc b">startAnimation</code>函数添加一个计数器变量。因为我们知道有多少个粒子，所以当我们到达总粒子长度时，我们可以停止计数。</p><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="fe45" class="nh mc iq nc b be ni nj l nk nl">const startAnimation = useCallback((generator, ctx, w, h, count) =&gt; {<br/>    let d = 0;<br/>    function animate() {<br/>      ctx.clearRect(0, 0, w, h);<br/>      generator.draw(ctx);<br/>      generator.update(d);<br/>      if (d &lt;= count) d++;<br/>      requestAnimationFrame(animate);<br/>    }<br/>    setTimeout(() =&gt; animate(), 2000);<br/>  }, []);</span></pre><p id="fd6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，根据计数器值编辑<code class="fe mz na nb nc b">Generator</code>的更新函数，如下所示:</p><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="811a" class="nh mc iq nc b be ni nj l nk nl">update(counter) {<br/>    this.particlesArray.forEach((particle, index) =&gt; {<br/>      if (index &lt; counter) particle.update();<br/>    });<br/>  }</span></pre><p id="31e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这段代码中，我们说，“如果粒子的位置低于计数器值，什么也不做，因为还没轮到这个粒子。否则开始更新，只要计数器值超过位置，就一直更新。”</p><p id="c946" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，如果我们现在运行代码，我们可以看到动画按照我们想要的方式从上到下进行。尽管如此，像素开始动画在严格的顺序，这感觉不自然。整体效果看起来有点像散开的布料。</p><p id="db2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们解决这个问题，给我们的代码增加一些随机性。我们首先从修改像素的顺序开始。我的解决方案是复制<code class="fe mz na nb nc b">particlesArray</code>并把它们分成一些包含50个左右元素的小数组，把它们单独洗牌并展平成一个数组。对于这种操作，lodash库中有超级有用的函数，我们来安装一下:</p><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="45a7" class="nh mc iq nc b be ni nj l nk nl">npm install lodash --save</span></pre><p id="ccf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后在<code class="fe mz na nb nc b">Generator</code>的<code class="fe mz na nb nc b">init</code>函数的底部添加这些行。</p><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="0876" class="nh mc iq nc b be ni nj l nk nl">import {chunk, shuffle} from 'lodash';<br/><br/>...<br/><br/>init(context) {<br/>    ...<br/><br/>    let chunks = chunk(this.particlesArray, 50);<br/>    this.particlesArray = [];<br/>    chunks.forEach((chunk) =&gt; {<br/>      this.particlesArray.push(...shuffle(chunk));<br/>    });<br/><br/>    return this.particlesArray.length;<br/><br/> <br/>  }<br/> <br/></span></pre><p id="7fa7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不希望整个数组被打乱，因为我们不希望底部的像素一开始也是动态的。所以这样，我们同时保持了随机性和有序性。</p><p id="3cb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后但并非最不重要的，你可能想加速粒子接近尾声。这样，我们的动画可能看起来更真实。改变<code class="fe mz na nb nc b">startAnimation</code>中的计数器值，使其随时间增加一个以上。</p><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="d009" class="nh mc iq nc b be ni nj l nk nl">const startAnimation = useCallback((generator, ctx, w, h, count) =&gt; {<br/>    let d = 0;<br/>    function animate() {<br/>     ...<br/>      if (d &lt;= count) d += 1 + d /100;<br/>      requestAnimationFrame(animate);<br/>    }<br/>    ...<br/>  }, []);</span></pre><p id="adc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以用不同于100的值来试验这个速度。</p><p id="dfbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是了！最终的代码应该是这样的。我还添加了一个按钮来重新加载页面并轻松地重新运行效果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my lt l"/></div></figure><h1 id="13eb" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">结论</h1><p id="7bda" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">用画布和动画工作是纯粹的乐趣。在这里，我们学习了如何在像素的基础上通过获取图像数据来制作溶解效果。一旦你用自己的粒子重建了图像，你就可以通过添加一些简单的算法和值来尝试不同的效果。</p><p id="ff40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">别为旺达难过。MCU总是复活人物！</p><p id="fab1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下次见！</p></div></div>    
</body>
</html>