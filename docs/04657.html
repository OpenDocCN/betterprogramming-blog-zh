<html>
<head>
<title>Create Avro Producers With Python and the Confluent Kafka Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python和融合的Kafka库创建Avro生产者</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/avro-producer-with-python-and-confluent-kafka-library-4a1a2ed91a24?source=collection_archive---------3-----------------------#2020-04-28">https://betterprogramming.pub/avro-producer-with-python-and-confluent-kafka-library-4a1a2ed91a24?source=collection_archive---------3-----------------------#2020-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4336" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将Avro记录发送到Kafka主题的命令行可执行Python脚本</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/667ab30fa55831c6ade4799726243454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c2KXzBXDBLVY53Uf"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Susan Yin 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="b06f" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">概观</h1><p id="5d47" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在本教程中，我们将学习如何使用Confluent的Kafka Python客户端<a class="ae ky" href="https://github.com/confluentinc/confluent-kafka-python" rel="noopener ugc nofollow" target="_blank">库</a>编写Avro生成器。</p><p id="11ff" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们将编写的脚本可以从命令行执行，并接受一些参数作为输入。将它编写为命令行可执行文件使我们可以灵活地从任何地方调用它。</p><p id="fbf1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">本教程的代码可以在这个GitHub <a class="ae ky" href="https://github.com/billydh/python-avro-producer/" rel="noopener ugc nofollow" target="_blank"> repo </a>中找到。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="428c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">属国</h1><p id="83f5" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">首先，让我们创建<code class="fe mz na nb nc b">requirements.txt</code>文件并编写这个项目所需的包。实际上我们只需要一个包:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">requirements.txt</p></figure><p id="9200" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">然后，让我们设置并激活我们的虚拟环境，这样我们将要安装的包将被隔离，只用于我们的项目。对于本教程，使用<code class="fe mz na nb nc b">virtualenv</code>。</p><p id="45e2" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">假设您已经安装了<code class="fe mz na nb nc b">virtualenv</code>，让我们从终端执行以下命令:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="8906" class="nj lh it nc b gy nk nl l nm nn">~ ❯ mkdir python-avro-producer</span><span id="6dba" class="nj lh it nc b gy no nl l nm nn">~ ❯ cd python-avro-producer</span><span id="504c" class="nj lh it nc b gy no nl l nm nn">~/python-avro-producer ❯</span><span id="657e" class="nj lh it nc b gy no nl l nm nn">~/python-avro-producer ❯ virtualenv ./venv</span><span id="5bbd" class="nj lh it nc b gy no nl l nm nn">~/python-avro-producer ❯ source ./venv/bin/activate</span><span id="20c3" class="nj lh it nc b gy no nl l nm nn">~/python-avro-producer (venv) ❯</span></pre><p id="b294" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在，让我们继续安装我们需要的依赖项:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="124c" class="nj lh it nc b gy nk nl l nm nn">~/python-avro-producer (venv) ❯ pip install -r requirements.txt</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/106ace2fcdce3b7b54a1883dca6656fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BnOM3UI3HBE35g-z"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@parktroopers?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">公园巡警</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8c7a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">Avro生产商</h1><p id="cc64" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">好了，现在有趣的部分开始了！</p><p id="0c13" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">为了使本教程易于理解，我们将把它分成几个部分，每个部分将讨论脚本的一个部分。</p><h2 id="a8c4" class="nj lh it bd li nq nr dn lm ns nt dp lq mh nu nv ls ml nw nx lu mp ny nz lw oa bi translated">函数来解析命令行参数</h2><p id="aa61" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如前所述，这个脚本将是可执行的，并接受命令行参数。所以，首先要做的是写一个函数来处理这个问题。</p><p id="f2d2" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们将创建一个名为<code class="fe mz na nb nc b">utils</code>的文件夹和一个名为<code class="fe mz na nb nc b">parse_command_line_args.py</code>的新Python文件。Python文件的内容如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">parse _命令行_args.py</p></figure><p id="106f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们为引导服务器和模式注册中心定义默认值以指向<code class="fe mz na nb nc b">localhost</code>。当我们想在本地测试时，这很有用。还要注意，这两个<em class="ob"> x </em>值是Kafka的引导服务器和模式注册表的标准地址和URL。</p><p id="5c88" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">还有一个<code class="fe mz na nb nc b">--schema-file</code>论点。这将告诉我们的脚本在将记录值发布到Kafka主题时使用哪个Avro模式来序列化记录值。</p><p id="434f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">对于记录键，如果不提供，我们将生成一个随机的UUID，以最大限度地利用卡夫卡的分区。我们稍后将讨论UUID一代。</p><p id="6ba1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">记录值将作为JSON字符串传入(例如<code class="fe mz na nb nc b">{"name": "Owen", "task": "Build Avro Producer"}</code>)。</p><h2 id="51e0" class="nj lh it bd li nq nr dn lm ns nt dp lq mh nu nv ls ml nw nx lu mp ny nz lw oa bi translated">创建Avro模式并添加到项目中</h2><p id="79f2" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Avro生产者需要一个Avro模式来序列化将发布到Kafka主题的记录值。因此，让我们创建一个简单的Avro模式，并将其添加到我们的项目中。</p><p id="c7a6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这个Avro模式包含一个新的用户创建请求(假设我们有一个拥有用户订阅的应用程序)。它有三个<em class="ob"> x </em>字段，分别是<code class="fe mz na nb nc b">email</code>、<code class="fe mz na nb nc b">firstName</code>和<code class="fe mz na nb nc b">lastName</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建用户请求</p></figure><p id="e7ea" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">酷毙了。现在，在我们的项目中创建一个名为<code class="fe mz na nb nc b">avro</code>的文件夹，并将<code class="fe mz na nb nc b">create-user-request.avsc</code>放在那里。</p><p id="316d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们还将编写另一个<code class="fe mz na nb nc b">util</code>函数来将这个模式文件加载到我们的主脚本中。让我们在<code class="fe mz na nb nc b">utils</code>文件夹中创建一个新文件，命名为<code class="fe mz na nb nc b">load_avro_schema_from_file.py</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe mz na nb nc b">load_avro_schema_from_file.py</code></p></figure><p id="5282" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">注意，我们的记录键的模式是类型<code class="fe mz na nb nc b">string</code>。如果您的键模式不是类型<code class="fe mz na nb nc b">string</code>，您需要调整这一部分。</p><h2 id="d9b8" class="nj lh it bd li nq nr dn lm ns nt dp lq mh nu nv ls ml nw nx lu mp ny nz lw oa bi translated">向Kafka主题发送记录的功能</h2><p id="b60d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这是我们需要编写的最后一个函数，也是最重要的一个，因为它会将记录发送到Kafka主题。</p><p id="b8f1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在，继续创建一个名为<code class="fe mz na nb nc b">send_record.py</code>的新Python文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">发送_记录. py</p></figure><p id="dac1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们一起来看一下代码:</p><ul class=""><li id="b16c" class="oc od it ma b mb mu me mv mh oe ml of mp og mt oh oi oj ok bi translated">第15–20行。这是我们配置Avro生成器的地方。我们首先在<code class="fe mz na nb nc b">producer_config</code>对象中定义生产者配置。这里没什么特别的。我们基本上只是设置要使用的引导服务器和模式注册表URL。</li><li id="065d" class="oc od it ma b mb ol me om mh on ml oo mp op mt oh oi oj ok bi translated">接下来，我们创建一个<code class="fe mz na nb nc b">AvroProducer</code>的实例，它是一个Kafka producer客户端，能够将消息序列化到Avro记录中，并将模式注册到模式注册中心。我们传入生产者配置以及键和值的模式。</li><li id="100b" class="oc od it ma b mb ol me om mh on ml oo mp op mt oh oi oj ok bi translated">第22行。我们的脚本检查是否传递了<code class="fe mz na nb nc b">--record-key</code>参数，如果没有，它将生成一个随机的UUID版本4。</li><li id="6912" class="oc od it ma b mb ol me om mh on ml oo mp op mt oh oi oj ok bi translated">第25–30行。在这里，我们调用我们的<code class="fe mz na nb nc b">AvroProducer</code>的<code class="fe mz na nb nc b">produce()</code>方法，它将把记录发送到我们使用前面定义的模式指定的Kafka主题。如果有一个<code class="fe mz na nb nc b">Exception</code>，它会把它打印到控制台，这样我们就知道哪里出错了。在一切正常的情况下，它会打印一条成功消息。</li><li id="29c4" class="oc od it ma b mb ol me om mh on ml oo mp op mt oh oi oj ok bi translated">第32行。我们调用我们的<code class="fe mz na nb nc b">AvroProducer</code>的<code class="fe mz na nb nc b">flush()</code>方法，这基本上意味着它将等待直到所有的消息被发送。</li><li id="0176" class="oc od it ma b mb ol me om mh on ml oo mp op mt oh oi oj ok bi translated">现在，<code class="fe mz na nb nc b">produce()</code>方法就是<code class="fe mz na nb nc b">asynchronous</code>。你可能会想，如果我们调用<code class="fe mz na nb nc b">flush()</code>方法，它就会变成<code class="fe mz na nb nc b">synchronous</code>。答案是肯定的。然而，在我们的例子中，这很好，因为我们的脚本被设计成一次只发送一条消息。</li></ul><p id="864e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">有关这方面的更多信息，您可以访问<code class="fe mz na nb nc b">flush()</code>上的<a class="ae ky" href="https://docs.confluent.io/current/clients/confluent-kafka-python/index.html#confluent_kafka.Producer.flush" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><p id="fa10" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">太棒了，伙计们。我们实际上已经完成了代码的编写。在下一节中，我们将测试刚刚编写的代码。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/0ef9d22c2912c7ba36a47e69c00e038e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jYK9tZGsKxUHWRjO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿尔文·列宁的照片。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a819" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">测试Avro生成器</h1><p id="a98f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">为了测试我们的脚本，我们需要建立一个环境，在这个环境中有融合的Kafka和Schema Registry。我们还希望有一个汇合控制中心，这样我们就可以在一个漂亮的UI上观察消息是否被实际传递。</p><p id="d7a9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">为此，我们可以遵循<a class="ae ky" href="https://medium.com/better-programming/your-local-event-driven-environment-using-dockerised-kafka-cluster-6e84af09cd95" rel="noopener">我前段时间写的教程</a><a class="ae ky" href="https://medium.com/better-programming/adding-schema-registry-to-kafka-in-your-local-docker-environment-49ada28c8a9b" rel="noopener"/>。到第二篇教程结束时，您将能够启动本地Docker容器，这些容器运行所有融合的Kafka和Schema Registry组件。</p><p id="e366" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">不管怎样，让我们继续测试我们的代码。</p><p id="fc60" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">因此，让我们从您的终端执行以下命令:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="82cc" class="nj lh it nc b gy nk nl l nm nn">~/python-avro-producer ❯ python send_record.py --topic create-user-request --schema-file create-user-request.avsc --record-value '{"email": "<a class="ae ky" href="mailto:email@email.com" rel="noopener ugc nofollow" target="_blank">email@email.com</a>", "firstName": "Bob", "lastName": "Jones"}'</span><span id="e1be" class="nj lh it nc b gy no nl l nm nn">Successfully producing record value - {'email': '<a class="ae ky" href="mailto:email@email.com" rel="noopener ugc nofollow" target="_blank">email@email.com</a>', 'firstName': 'Bob', 'lastName': 'Jones'} to topic - create-user-request</span></pre><p id="dc50" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">耶！我们收到了成功消息，这意味着一切都按预期进行。</p><p id="da41" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在，打开浏览器，进入<a class="ae ky" href="http://localhost:9021," rel="noopener ugc nofollow" target="_blank"> http://localhost:9021 </a>，这是合流控制中心的地址。然后，导航到主题<code class="fe mz na nb nc b">create-user-request</code>并转到偏移<code class="fe mz na nb nc b">0</code>。这是你应该看到的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/897b86f1a6f145df1718f9336be38d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VwehMOtkdlNrmgcwaL4sCg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">合流控制中心</p></figure><p id="a912" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">完美！干得好，各位。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7cc1" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">包扎</h1><p id="ee52" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">祝贺您完成本教程。至此，我们已经学会了如何编写一个能够将消息序列化为Avro记录的Kafka生成器。现在，我鼓励您在现有的应用程序中实现这一点，以便您的应用程序成为事件驱动的应用程序。</p><p id="03a3" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果你想学习如何在Kotlin中做到这一点，你可以遵循下面的综合教程。它有一个完整的端到端指南来构建一个与DynamoDB和Kafka交互的Kotlin应用程序。</p><div class="os ot gp gr ou ov"><a href="https://medium.com/better-programming/a-comprehensive-guide-to-build-an-event-driven-application-with-kotlin-kafka-and-dynamodb-a8d9bfb19e42" rel="noopener follow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">用Kotlin、Kafka和DynamoDB构建事件驱动应用程序的综合指南</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">构建您自己的事件驱动应用程序</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">medium.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj ks ov"/></div></div></a></div></div></div>    
</body>
</html>