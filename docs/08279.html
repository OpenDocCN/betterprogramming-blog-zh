<html>
<head>
<title>Exploring the Spread Operator and Rest Parameter in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探究JavaScript中的Spread运算符和Rest参数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-the-spread-operator-and-rest-parameter-in-javascript-8f425b4031e2?source=collection_archive---------5-----------------------#2021-04-13">https://betterprogramming.pub/exploring-the-spread-operator-and-rest-parameter-in-javascript-8f425b4031e2?source=collection_archive---------5-----------------------#2021-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="90e6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">spread操作符有许多用例。让我们来看看其中的几个</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9aca882682f6618e228ad6120b2364b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dUWxgK1nC-YwG_gs"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@drew_saurus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上画出Saurus </a>。</p></figure><p id="bd63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将解释JavaScript中的<em class="ls">扩展操作符</em>和<em class="ls">剩余参数</em>是什么。但是首先，让我们看看JavaScript中的逻辑运算符是什么。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="1fb8" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">逻辑运算符</h1><p id="bcb0" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><code class="fe mx my mz na b">&amp;&amp;</code>和<code class="fe mx my mz na b">||</code> <strong class="ky ir"> </strong>称为逻辑运算符。JavaScript中的逻辑运算符不像其他编程语言那样只返回布尔值。JavaScript中的逻辑运算符返回值。这就是为什么许多开发人员称它们为选择操作符。</p><p id="14b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">规则:</p><ul class=""><li id="ebf4" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">真理<code class="fe mx my mz na b">&amp;&amp;</code>无论如何</li><li id="51f2" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">falsy <code class="fe mx my mz na b">&amp;&amp;</code>随便= falsy</li><li id="7e32" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">真实<code class="fe mx my mz na b">||</code>无论如何=真实</li><li id="2003" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">无论如何</li></ul><p id="eecd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是什么是真实和虚假呢？如果您将一个值作为参数传递给<code class="fe mx my mz na b">Boolean</code>构造函数，并且它返回<code class="fe mx my mz na b">true</code>，则该值为the。如果返回<code class="fe mx my mz na b">false</code>，则为falsy。<br/>更简单的规则是，值<code class="fe mx my mz na b">false</code>、<code class="fe mx my mz na b">null</code>、<code class="fe mx my mz na b">undefined</code>、<code class="fe mx my mz na b">0</code>、<code class="fe mx my mz na b">-0</code>、<code class="fe mx my mz na b">‘’</code>、<code class="fe mx my mz na b">NaN</code>、<code class="fe mx my mz na b">0n</code>、<code class="fe mx my mz na b">-0n</code>为假，其他都为真。</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="1b5b" class="nt mb iq na b gy nu nv l nw nx">const user = null;<br/>const currentUser = user || {};</span></pre><p id="570d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的例子是一个添加默认值的简单方法。因为<code class="fe mx my mz na b">user</code>是<code class="fe mx my mz na b">null</code>(falsy)<code class="fe mx my mz na b">currentUser</code>将是<code class="fe mx my mz na b">{}</code>。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="645f" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">传播算子</h1><p id="cd67" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">展开运算符是类似于<code class="fe mx my mz na b">+</code>、<code class="fe mx my mz na b">-</code>、<code class="fe mx my mz na b">/</code>等的运算符。这需要一个iterable(我们可以循环遍历的东西)并将其扩展为单个元素。语法是三个点(<code class="fe mx my mz na b">...</code>)，有很多用例。</p><h2 id="65ca" class="nt mb iq bd mc ny nz dn mg oa ob dp mk lf oc od mm lj oe of mo ln og oh mq oi bi translated">浅拷贝一个对象</h2><p id="5db3" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">对象是通过引用保存的非基元类型。如果一个对象等于另一个对象，当您更改第一个对象时，第二个对象也会自动更改。</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="204d" class="nt mb iq na b gy nu nv l nw nx">const user1 = { name: 'George', surname: 'ruby' };<br/>const user2 = user1;<br/>user2.surname = 'Roubie';</span></pre><p id="09cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，<code class="fe mx my mz na b">user1</code>中的姓也被改变了。我们可以使用spread运算符来修复它。</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="7763" class="nt mb iq na b gy nu nv l nw nx">const user1 = { name: 'George', surname: 'ruby' };<br/>const user2 = { ...user1 };<br/>user2.surname = 'Roubie';</span></pre><p id="5a93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以这样优化上面的代码:</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="35b2" class="nt mb iq na b gy nu nv l nw nx">const user1 = { name: 'George', surname: 'ruby' };<br/>const user2 = { ...user1, surname: 'Roubie' };</span></pre><p id="8576" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码之所以有效，是因为如果同一个键在一个对象中出现了两次，那么最后一次出现的键会胜出。这个特性在状态管理技术中非常有用。</p><p id="4cd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">浅复制意味着如果复制的对象中有嵌套对象，引用将会保留。</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="de3d" class="nt mb iq na b gy nu nv l nw nx">const roles = { isAdmin: true };<br/>const user1 = { name: 'George', surname: 'Roubie', role: roles };<br/>const user2 = { ...user1 };<br/>user2.role.isAdmin = false;</span></pre><p id="60fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上例中的角色在<code class="fe mx my mz na b">user1</code>中也有变化，所以要小心。</p><h2 id="58e4" class="nt mb iq bd mc ny nz dn mg oa ob dp mk lf oc od mm lj oe of mo ln og oh mq oi bi translated">组合对象</h2><p id="f058" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">使用spread操作符，我们可以将任意多的对象组合成一个新的对象。</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="1836" class="nt mb iq na b gy nu nv l nw nx">const userInfo = { name: 'George', surname: 'Roubie' };<br/>const userRoles = { roles: ['admin', 'it'] };<br/>const token = { accessToken: '123', refreshToken: '456' };<br/>const currentUser = { ...userInfo, ...userRoles, ...token };</span></pre><h2 id="c9ef" class="nt mb iq bd mc ny nz dn mg oa ob dp mk lf oc od mm lj oe of mo ln og oh mq oi bi translated">有条件地向对象添加属性</h2><p id="dd93" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在逻辑运算符<code class="fe mx my mz na b">&amp;&amp;</code>和扩展运算符的帮助下，你可以很容易地给一个对象添加属性。</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="c6d9" class="nt mb iq na b gy nu nv l nw nx">const getRole = () =&gt; 'admin';<br/>const user = { <br/>  name: 'George', <br/>  surname: 'Roubie',<br/>  ...(getRole() === 'admin' &amp;&amp; { admin: true })<br/>};</span></pre><p id="1a27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为<code class="fe mx my mz na b">getRole() === 'admin'</code>返回<code class="fe mx my mz na b">true</code>，<code class="fe mx my mz na b">&amp;&amp;</code>返回<code class="fe mx my mz na b">{ admin: true }</code>。这就是为什么在用户对象中添加<code class="fe mx my mz na b">admin: true</code>的原因。</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="080d" class="nt mb iq na b gy nu nv l nw nx">const getRole = () =&gt; 'dev';<br/>const user = {<br/>  name: 'George',<br/>  surname: 'Roubie',<br/>  ...(getRole() === 'admin' &amp;&amp; { admin: true })<br/>};</span></pre><p id="683b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在<code class="fe mx my mz na b">getRole() === 'admin'</code>返回<code class="fe mx my mz na b">false</code><strong class="ky ir"/><code class="fe mx my mz na b">&amp;&amp;</code>返回<code class="fe mx my mz na b">false</code>。<strong class="ky ir"> </strong>但是如果展开<code class="fe mx my mz na b">false</code>(例如<code class="fe mx my mz na b">{ ...(false) }</code>)，展开操作符将返回nothing ( <code class="fe mx my mz na b">{}</code>)。这就是为什么用户对象中没有添加任何内容。</p><h2 id="f8a4" class="nt mb iq bd mc ny nz dn mg oa ob dp mk lf oc od mm lj oe of mo ln og oh mq oi bi translated">复制数组(浅层)</h2><p id="b005" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">数组是像对象一样的非基本类型。如果一个数组等于另一个数组，当您更改第一个数组时，第二个数组也会自动更改。</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="e6db" class="nt mb iq na b gy nu nv l nw nx">const a = [1, 2, 3];<br/>const b = [...a];<br/>b.push(4);</span></pre><p id="0f1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码也可以用slice方法实现。</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="6b5f" class="nt mb iq na b gy nu nv l nw nx">const a = [1, 2, 3];<br/>const b = [...a, 4];</span></pre><p id="defa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是使用slice方法，当我们复制一个数组时，我们不能添加一个值，就像我们在上面的例子中做的那样。</p><p id="5271" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个副本是浅层的，所以如果数组中有对象或数组，引用将会保留。</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="7e6f" class="nt mb iq na b gy nu nv l nw nx">const data = { test: 1 };<br/>const arr1 = [1, 2, 3, data];<br/>const arr2 = [...arr1];<br/>arr2[3].test = 3;</span></pre><p id="39d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，<code class="fe mx my mz na b">arr1</code>和<code class="fe mx my mz na b">arr2</code>将在数组的第三个索引中具有值<code class="fe mx my mz na b">{ test: 3 }</code>，因为副本是浅的。</p><h2 id="00ab" class="nt mb iq bd mc ny nz dn mg oa ob dp mk lf oc od mm lj oe of mo ln og oh mq oi bi translated">串联数组</h2><p id="879b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">使用spread操作符，我们可以将任意多的数组连接成一个新数组。</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="7659" class="nt mb iq na b gy nu nv l nw nx">const a = [1, 2, 3];<br/>const b = [4, 5, 6];<br/>const c = [7, 8, 9];<br/>const d = [...a, ...b, ...c];</span></pre><p id="5451" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想连接两个数组，我们也可以使用<code class="fe mx my mz na b">concat</code>方法，但是<code class="fe mx my mz na b">concat</code>方法只能连接两个数组。使用spread操作符，我们可以连接任意多的数组，还可以在数组之间添加值，这是用<code class="fe mx my mz na b">concat</code>方法做不到的。</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="1d6c" class="nt mb iq na b gy nu nv l nw nx">const a = [1, 2, 3];<br/>const b = [5, 6, 7];<br/>const c = [9, 10, 11];<br/>const d = [0, ...a, 4, ...b, 8, ...c, 12];</span></pre><h2 id="68ed" class="nt mb iq bd mc ny nz dn mg oa ob dp mk lf oc od mm lj oe of mo ln og oh mq oi bi translated">使用数组作为参数</h2><p id="2e9e" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">因为spread操作符将数组扩展为单个元素，所以我们可以将数组作为函数中的参数传递。首先，让我们看看在没有spread操作符的情况下如何实现它。</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="202f" class="nt mb iq na b gy nu nv l nw nx">const userInfo = ['George', 'Roubie'];<br/>const getUser = function(name, surname) {<br/>  console.log(name, surname);<br/>};<br/>getUser(userInfo[0], userInfo[1]);</span></pre><p id="ab1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用spread操作符，我们可以很容易地做到这一点:</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="5b94" class="nt mb iq na b gy nu nv l nw nx">const userInfo = ['George', 'Roubie'];<br/>const getUser = function(name, surname) {<br/>  console.log(name, surname);<br/>};<br/>getUser(...userInfo);</span></pre><p id="e0f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当有多个参数时，这非常有用。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="05d2" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">休息参数</h1><p id="f190" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">语法与spread运算符相同，但它不是运算符。事实上，它与spread操作符正好相反，将剩余的元素组合成一个元素。</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="5e2e" class="nt mb iq na b gy nu nv l nw nx">const user = function (name, age, ...hobbies) {<br/>  console.log(name);<br/>  console.log(age);<br/>  console.log(hobbies);<br/>}<br/>user('George', 30, 'coding', 'killing zombies');</span></pre><p id="aabf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">hobbies</code> <strong class="ky ir"> </strong>参数现在是一个值为<code class="fe mx my mz na b">['coding', 'killing zombies']</code>的数组。</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="17b5" class="nt mb iq na b gy nu nv l nw nx">var user = function (name, age, ...hobbies) {<br/>  console.log(name);<br/>  console.log(age);<br/>  console.log(hobbies);<br/>}<br/>user('George', 30);</span></pre><p id="bd5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当没有值时，rest参数使<code class="fe mx my mz na b">hobbies</code>成为一个空数组。这是非常有帮助的，因为当我们没有增加额外的价值时，我们不必担心。</p></div></div>    
</body>
</html>