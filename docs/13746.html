<html>
<head>
<title>Build a PyTorch Model for Face ID Spoofing Detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Face ID欺骗检测建立PyTorch模型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-pytorch-model-for-face-id-spoofing-detection-1f8d9d89eb3?source=collection_archive---------4-----------------------#2022-09-22">https://betterprogramming.pub/build-pytorch-model-for-face-id-spoofing-detection-1f8d9d89eb3?source=collection_archive---------4-----------------------#2022-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3522" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何构建PyTorch分类模型的快速指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/e9e982300226a91c386b90188a819be8.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*HreNhDRY5TqDzFapbsFhuA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来源:<a class="ae ku" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank">https://pytorch.org/</a></p></figure><p id="bc02" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你好，在这篇文章中我想展示如何建立简单的多类分类PyTorch模型。PyTorch是发展最快的深度学习框架，拥有非常活跃的社区。周围有许多教程，它的文档是相当完整和广泛的。因为我们将执行检测Face ID欺骗企图的任务。</p><h1 id="220a" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">数据</h1><p id="5cd7" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">我们将使用来自<a class="ae ku" href="https://ods.ai/competitions/idrnd-facial-antispoofing" rel="noopener ugc nofollow" target="_blank"> IDRND反欺骗挑战</a>的数据集。我们的目标是建立一个模型来检测不同的面部身份欺诈方法:冒名顶替者展示打印的肖像，把它戴在脸上，或者从另一个屏幕上重播视频。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/21926f4f230fa2183f5490b1e9403feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FI9-m5vuFxrhgIAo_BJeGw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来源:<a class="ae ku" href="https://github.com/datasouls/idrnd-antispoofing-challenge" rel="noopener ugc nofollow" target="_blank">https://github.com/datasouls/idrnd-antispoofing-challenge</a></p></figure><p id="5270" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">该数据集代表了来自11500名受试者的直播和恶搞图像。对于每个对象，它有5帧以200毫秒的间隔和1080P高清分辨率拍摄的图像。该数据集是从野外收集的，有不同的姿势和背景变化。攻击可以是以下三种类型之一:</p><ul class=""><li id="85a4" class="mt mu it kx b ky kz lb lc le mv li mw lm mx lq my mz na nb bi translated">2D面具，</li><li id="f8d6" class="mt mu it kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">重播，</li><li id="cff4" class="mt mu it kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">印刷纸。</li></ul><p id="5684" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将使用以下指标作为衡量标准</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="07f8" class="nm ls it ni b gy nn no l np nq">minC = min(P(false_alarm) + 19 P(miss)) by threshold<br/>minC = min(FP/(FP+TN) + 19 FN/(FN+TP))) by threshold</span></pre><p id="ed8f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">其中<code class="fe nr ns nt ni b">P(false_alarm)</code> —假阳性的概率，<code class="fe nr ns nt ni b">P(miss)</code> —假阴性的概率。阈值将欺骗的概率二进制化。当模型没有检测到实际的欺骗企图时，因子19用于增加惩罚。</p><h2 id="49a3" class="nm ls it bd lt nu nv dn lx nw nx dp mb le ny nz md li oa ob mf lm oc od mh oe bi translated">数据处理</h2><p id="1fd1" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">为了提高模型泛化能力，我们将使用来自<code class="fe nr ns nt ni b"><a class="ae ku" href="https://pytorch.org/vision/stable/index.html" rel="noopener ugc nofollow" target="_blank">torchvision</a></code>库的标准扩充:</p><ul class=""><li id="1ebc" class="mt mu it kx b ky kz lb lc le mv li mw lm mx lq my mz na nb bi translated">RandomResizedCrop</li><li id="649a" class="mt mu it kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">随机水平翻转</li><li id="6cba" class="mt mu it kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">色彩抖动</li><li id="227c" class="mt mu it kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">随机旋转</li></ul><p id="90d9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于训练数据，我们将应用随机变换，对于验证，我们只应用确定性变换。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="f051" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们使用torch <a class="ae ku" href="https://pytorch.org/tutorials/beginner/basics/data_tutorial.html" rel="noopener ugc nofollow" target="_blank">数据集和Dataloader </a>来处理小批数据，并在每个时期对它们进行洗牌，以减少模型过拟合。使用数据集，我们可以索引加载的图像和相应的标签。Dataloader为我们提供了iterable，它抽象出了对数据进行批处理的逻辑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="c3ce" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">扩充是在定义数据集对象时应用的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="8291" class="nm ls it bd lt nu nv dn lx nw nx dp mb le ny nz md li oa ob mf lm oc od mh oe bi translated">模型</h2><p id="1c1c" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">作为模型，我们将使用在ImageNet数据集上预先训练的<code class="fe nr ns nt ni b">resnet50</code>。我们将解冻特征提取器的顶部70层，并添加自定义的全连接块。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="ddef" class="nm ls it bd lt nu nv dn lx nw nx dp mb le ny nz md li oa ob mf lm oc od mh oe bi translated">培训和验证</h2><p id="5b26" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">为了训练模型，我们设置了经典的<a class="ae ku" href="https://pytorch.org/docs/stable/generated/torch.optim.Adam.html" rel="noopener ugc nofollow" target="_blank">亚当</a>优化器和<a class="ae ku" href="https://pytorch.org/docs/stable/generated/torch.nn.BCEWithLogitsLoss.html" rel="noopener ugc nofollow" target="_blank"> BCEWithLogitsLoss </a>。在每个验证时期，我们将模型切换到评估模式，并停止梯度计算。我们还计算损失、准确性和自定义加权<code class="fe nr ns nt ni b">minC</code>的运行指标，并在数据集上对它们进行平均。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="a2f1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">结果，我们获得了以下指标。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/e16a6f41f5a6c3543f94af7fafc8212a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*0Lc7b8euAOJrHVKTDu1BoA.png"/></div></figure><h1 id="3fce" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">最后的想法</h1><p id="65e8" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">在本文中，我们看到了如何构建分类PyTorch模型。作为基础，我们使用预训练的<code class="fe nr ns nt ni b">resnet-50</code>，然后在我们的特定数据集上对其进行微调。我们还看到了如何通过torch Dataset和Dataloader使用混洗的数据批次。</p><h2 id="a015" class="nm ls it bd lt nu nv dn lx nw nx dp mb le ny nz md li oa ob mf lm oc od mh oe bi translated">链接</h2><ul class=""><li id="fe99" class="mt mu it kx b ky mj lb mk le oi li oj lm ok lq my mz na nb bi translated"><a class="ae ku" href="https://ods.ai/competitions/idrnd-facial-antispoofing/data" rel="noopener ugc nofollow" target="_blank">https://ods.ai/competitions/idrnd-facial-antispoofing/data</a></li><li id="6967" class="mt mu it kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated"><a class="ae ku" href="https://pytorch.org/tutorials/beginner/basics/data_tutorial.html" rel="noopener ugc nofollow" target="_blank">https://py torch . org/tutorials/初学者/基础知识/数据_教程. html </a></li><li id="7c62" class="mt mu it kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated"><a class="ae ku" href="https://pytorch.org/vision/stable/index.html" rel="noopener ugc nofollow" target="_blank">https://pytorch.org/vision/stable/index.html</a></li></ul><div class="ol om gp gr on oo"><a href="https://levelup.gitconnected.com/kafka-in-machine-learning-for-real-time-predictions-45a4adf4620b" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">用于实时预测的机器学习中的卡夫卡</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">使用scikit运行Kafka学习实时应用程序</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ko oo"/></div></div></a></div><div class="ol om gp gr on oo"><a rel="noopener  ugc nofollow" target="_blank" href="/kafka-with-python-how-to-get-your-projects-up-and-running-34bc58c46652"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">使用Python的Kafka:如何启动和运行您的项目</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">使用Kafka运行流式作业</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">better编程. pub</p></div></div><div class="ox l"><div class="pd l oz pa pb ox pc ko oo"/></div></div></a></div></div></div>    
</body>
</html>