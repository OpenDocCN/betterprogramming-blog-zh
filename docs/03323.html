<html>
<head>
<title>Python and String Concatenation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python和字符串串联</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/python-and-string-concatenation-31772a10fed?source=collection_archive---------23-----------------------#2020-02-03">https://betterprogramming.pub/python-and-string-concatenation-31772a10fed?source=collection_archive---------23-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4fab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Python中连接字符串最有效的方法是什么？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8733361abb55ae4c11af3539af961f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N9usxxIXFGae2qRFVwrXEQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">雅各布·科普斯在<a class="ae ky" href="https://unsplash.com/s/photos/symmetry?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2116" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python是我最早学习的语言之一。当时，我被告知将一系列字符串连接成一个字符串的方法是这样做的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用+=连接字符串列表中的所有元素。</p></figure><p id="674e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过了一会儿，人们就知道了<code class="fe lx ly lz ma b">.join</code>函数的奇妙之处，它极大地简化并减少了使用的行数。使用<code class="fe lx ly lz ma b">.join</code>,我们可以编写如下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">调用<code class="fe lx ly lz ma b">join()</code>上所有元素的字符串列表。</p></figure><p id="1079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2018年末，我在里斯本与一家公司的一个非常有才华的工程团队一起工作，这家公司正在经历一个大的增长阶段。代码库相当旧，有相当数量的“锤打”代码，所以当公司开始成长时，许多以前不存在的问题开始出现。</p><p id="7cb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在那些日子里，工程师们共同努力找出如何改进我们系统的旧部分是很常见的。有一天，他们正在研究一个操作，该操作将一个正则表达式应用于一个字符串，并将所有结果元素连接在一起。当操作面对一个很大的字符串时，它需要几分钟才能完成，而它应该需要几秒钟。</p><p id="d745" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，导致这个问题的最明显的一段代码是使用<code class="fe lx ly lz ma b">+=</code>操作符将列表的所有元素连接在一起。</p><h2 id="781c" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">+=有什么问题？</h2><p id="a29f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Python医生说:</p><blockquote class="mz na nb"><p id="834a" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">串联不可变序列总是会产生一个新的对象。这意味着通过重复连接构建序列将在总序列长度上具有二次运行时间成本。</p></blockquote><p id="1a1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为字符串是不可变的，无论何时你将一个字符串连接到另一个字符串，它都会创建一个新的字符串。随着字符串变得越来越大，需要复制更多的数据来创建这些更大的字符串。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="c948" class="nn mc it bd md no np nq mg nr ns nt mj jz nu ka mm kc nv kd mp kf nw kg ms nx bi translated">Python 3</h1><p id="7955" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">以前的文章(检查参考资料)已经探讨了获取字符串列表并将所有元素连接在一起的问题。这些内容是不久前用Python 2编写的，所以我很好奇它与Python 3的最新版本(目前是3.7.5)有什么不同。</p><h2 id="4bd0" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">测试设置</h2><p id="bbed" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将探索Python中连接字符串的三种不同方式:</p><ul class=""><li id="ca92" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">使用<code class="fe lx ly lz ma b">+=</code>操作符</li><li id="963e" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">使用<code class="fe lx ly lz ma b">.join</code>功能</li><li id="2e8e" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">使用<code class="fe lx ly lz ma b">StringIO</code></li></ul><p id="5cb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用的列表有900M个不同大小的元素，由这个1.01 GB <a class="ae ky" href="http://mattmahoney.net/dc/textdata.html" rel="noopener ugc nofollow" target="_blank">文本文件中的文本组成。</a></p><p id="a9e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试是在2014年15英寸的Macbook Pro上进行的，配备了2,2 GHz的英特尔酷睿i7和16 GB的内存。</p><p id="b6a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是针对上述每种可能性运行的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用<code class="fe lx ly lz ma b">+=</code>操作符</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用<code class="fe lx ly lz ma b">.join</code>功能</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用<code class="fe lx ly lz ma b">StringIO</code></p></figure><h2 id="312f" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">结果</h2><pre class="kj kk kl km gt om ma on oo aw op bi"><span id="0159" class="mb mc it ma b gy oq or l os ot">               Runtime(ms)   Concatenations per second  <br/> ------------ ------------- --------------------------- <br/>  Function 1      130.99            6,870,753  <br/>  Function 2       13.07           68,859,985    <br/>  function 3       96.01            9,374,024</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/ce9aa74c5663cee506d17b6bef6ea900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Us61DdEP_fgcjktp_0dBdA.png"/></div></div></figure><p id="999d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到目前最好的函数是使用<code class="fe lx ly lz ma b">.join</code>的函数，这与Python 2非常相似。</p><p id="40ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，令人惊讶的结果是看到<code class="fe lx ly lz ma b">StringIO</code>和<code class="fe lx ly lz ma b">+=</code>表现几乎一样。我预计它的性能至少会提高一倍，因为在Python 3文档中，它和<code class="fe lx ly lz ma b">.join</code>一起被引用，作为连接<code class="fe lx ly lz ma b">str</code>对象的一种方式。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="adb0" class="nn mc it bd md no np nq mg nr ns nt mj jz nu ka mm kc nv kd mp kf nw kg ms nx bi translated">特别感谢</h1><p id="a86f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">感谢当时Unbabel工程团队的成员，他们让我从他们身上学到了很多东西。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="3f23" class="nn mc it bd md no np nq mg nr ns nt mj jz nu ka mm kc nv kd mp kf nw kg ms nx bi translated">参考</h1><div class="ov ow gp gr ox oy"><a href="https://waymoot.org/home/python_string/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">Python中高效的字符串连接</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">对在Python编程语言中构建长字符串的几种方法的性能进行评估，可以帮助我们更好地理解</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">waymoot.org</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://blog.mclemon.io/python-efficient-string-concatenation-in-python-2016-edition" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">Python中的Python高效字符串串联(2016版)</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">读完Philip Guo在CPython VM上的精彩系列讲座后，我发现自己在看…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">blog.mclemon.io</p></div></div><div class="ph l"><div class="pn l pj pk pl ph pm ks oy"/></div></div></a></div></div></div>    
</body>
</html>