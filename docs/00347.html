<html>
<head>
<title>Handling ViewState With Retry Support on Android Using RxJava</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RxJava在Android上处理支持重试的视图状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/handling-viewstate-with-retry-support-on-android-using-rxjava-d9c5cc01b093?source=collection_archive---------0-----------------------#2019-04-29">https://betterprogramming.pub/handling-viewstate-with-retry-support-on-android-using-rxjava-d9c5cc01b093?source=collection_archive---------0-----------------------#2019-04-29</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="81ca" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">在重试操作的支持下实现加载、内容和错误状态</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/7653801fc8fffddce69eb4ecb9407e48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EU_fqXZhdlDbC9Cq"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@mattiasmilos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马蒂亚斯·米洛斯</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b167" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们考虑这个用例:</p><p id="5514" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的行动可能需要一些时间，可能成功也可能失败。当失败时，我们希望允许用户通过单击重试按钮来重试操作。</p><p id="51a0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以我们这样设计我们的<code class="fe lw lx ly lz b">ViewState</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ma mb l"/></div></figure><p id="08db" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">处于<code class="fe lw lx ly lz b">Error</code>状态的<code class="fe lw lx ly lz b">onRetryClicked()</code>将向我们的刷新事件流发布一个事件。这个函数的映射在这篇文章中是不可见的，因为它是不相关的，但是你可以认为它是将<code class="fe lw lx ly lz b">Unit</code>发布给了<code class="fe lw lx ly lz b">PublishSubject</code>。</p><p id="4063" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们这样写我们的<code class="fe lw lx ly lz b">ViewState</code>处理:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ma mb l"/></div></figure><p id="52ea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里发生了什么:</p><ol class=""><li id="fce5" class="mc md iu lc b ld le lg lh lj me ln mf lr mg lv mh mi mj mk bi translated">我们的<code class="fe lw lx ly lz b">upstream</code>是一个无限的流，发出我们的领域实体</li><li id="d790" class="mc md iu lc b ld ml lg mm lj mn ln mo lr mp lv mh mi mj mk bi translated">将域实体映射到<code class="fe lw lx ly lz b">ViewEntity</code>。</li><li id="9062" class="mc md iu lc b ld ml lg mm lj mn ln mo lr mp lv mh mi mj mk bi translated">将<code class="fe lw lx ly lz b">ViewEntity</code>映射到<code class="fe lw lx ly lz b">ViewState.Content</code>。</li><li id="8776" class="mc md iu lc b ld ml lg mm lj mn ln mo lr mp lv mh mi mj mk bi translated">发布<code class="fe lw lx ly lz b">ViewState.Loading</code>当我们订阅这个蒸汽。</li><li id="5c5b" class="mc md iu lc b ld ml lg mm lj mn ln mo lr mp lv mh mi mj mk bi translated">当我们收到一个错误时，我们创建一个<code class="fe lw lx ly lz b">ViewState.Error</code>并将其发布到我们的<a class="ae kz" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank"> LiveData </a>。</li><li id="3926" class="mc md iu lc b ld ml lg mm lj mn ln mo lr mp lv mh mi mj mk bi translated"><code class="fe lw lx ly lz b">retryWhen()</code>当它收到一个项目时不做任何事情。但是当它接收到错误时，它不允许错误向下游传播。取而代之的是，它开始监听<code class="fe lw lx ly lz b">refreshSignalStream</code>，当有一个项目时，它重新向上游订阅。</li><li id="9e3c" class="mc md iu lc b ld ml lg mm lj mn ln mo lr mp lv mh mi mj mk bi translated">我们正在订阅并向我们的LiveData发布项目。我们在订阅中也有错误处理，因为<code class="fe lw lx ly lz b"><em class="mq">retryWhen()</em></code>会向下游发送<code class="fe lw lx ly lz b">refreshSignalStream</code>的错误。</li></ol><p id="a291" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">尽管这种处理<code class="fe lw lx ly lz b">ViewStates</code>的方式有效，但是我们的流并没有发出完整的<code class="fe lw lx ly lz b">ViewStates</code>。它只散发出<code class="fe lw lx ly lz b">ViewState.Content</code>。<code class="fe lw lx ly lz b">Loading</code>和<code class="fe lw lx ly lz b">Error ViewState</code>被当作副作用处理(使用<code class="fe lw lx ly lz b">doOnError()</code>和<code class="fe lw lx ly lz b">doOnSubscribe()</code> <em class="mq">)，</em>但实际上，它们不是任何副作用。如果你有另一个依赖于这个<code class="fe lw lx ly lz b">ViewState</code>流的流，你就不能使用它。</p><p id="97c3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们通过在同一个流中发出完整的<code class="fe lw lx ly lz b">ViewStates</code>来改进我们的流，而不是把其中的一些当作副作用。</p><h2 id="205a" class="mr ms iu bd mt mu mv dn mw mx my dp mz lj na nb nc ln nd ne nf lr ng nh ni nj bi translated">正在修复<em class="nk">视图状态。正在加载</em></h2><p id="87b4" class="pw-post-body-paragraph la lb iu lc b ld nl jv lf lg nm jy li lj nn ll lm ln no lp lq lr np lt lu lv in bi translated">我们可以很容易地用<code class="fe lw lx ly lz b">startWith()</code>代替<code class="fe lw lx ly lz b">doOnSubscribe()</code>。当我们重新订阅该蒸汽时，它将具有相同的效果。</p><pre class="kk kl km kn gu nq lz nr ns aw nt bi"><span id="039e" class="mr ms iu lz b gz nu nv l nw nx">upstream<br/>    .map(viewEntityMapper)<br/>    .map&lt;ViewState&gt; { ViewState.Content(it) }<br/>    .startWith(ViewState.Loading)<br/>    ...</span></pre><h2 id="becd" class="mr ms iu bd mt mu mv dn mw mx my dp mz lj na nb nc ln nd ne nf lr ng nh ni nj bi translated">正在修复<em class="nk">视图状态。错误</em></h2><p id="c66d" class="pw-post-body-paragraph la lb iu lc b ld nl jv lf lg nm jy li lj nn ll lm ln no lp lq lr np lt lu lv in bi translated">当我们想在出现错误时发出另一个项目时，我们可以使用<code class="fe lw lx ly lz b">onErrorResumeNext(aNewStream)</code>。这不会让错误向下游传播，但它会用我们提供的新流替换该流。</p><p id="c066" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将使用等效的<code class="fe lw lx ly lz b">onErrorReturnItem(anotherItem)</code>，因为我们只有一个项目(也就是<code class="fe lw lx ly lz b">ViewState.Error</code>)，而且更简单。</p><p id="2a0a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，如果您想要记录错误，您需要在<code class="fe lw lx ly lz b">onErrorReturnItem()</code>之前完成，因为它不允许错误向下游传播。</p><p id="35a7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们增加了用于记录的<code class="fe lw lx ly lz b">doOnError()</code>和用于发射的<code class="fe lw lx ly lz b">onErrorReturnItem()</code><code class="fe lw lx ly lz b">ViewState.Error</code>:</p><pre class="kk kl km kn gu nq lz nr ns aw nt bi"><span id="b1ef" class="mr ms iu lz b gz nu nv l nw nx">upstream<br/>    .map(viewEntityMapper)<br/>    .map&lt;ViewState&gt; { ViewState.Content(it) }<br/>    .startWith(ViewState.Loading)<br/>    .doOnError { Timber.e(it, "Error while executing operation.") }<br/>    .onErrorReturnItem(createErrorState())</span></pre><p id="b578" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，重试的部分。这是棘手的部分，因为当出现错误时<code class="fe lw lx ly lz b">retryWhen()</code>开始起作用。但是我们不会有错误，因为我们有<code class="fe lw lx ly lz b">onErrorReturnItem()</code>不会让错误传到下游<em class="mq">。</em></p><p id="ae43" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">好在<code class="fe lw lx ly lz b">retryWhen()</code>有个妹子叫<code class="fe lw lx ly lz b">repeatWhen()</code> <em class="mq">。</em>不同的是，<code class="fe lw lx ly lz b">retryWhen()</code>监听错误事件，而<code class="fe lw lx ly lz b">repeatWhen()</code>监听完成事件。</p><p id="569c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是完美的，因为当有一个错误时，<code class="fe lw lx ly lz b">onErrorReturnItem()</code>将只发出一个项目，然后它完成。我们的<code class="fe lw lx ly lz b">ViewState.Error</code>将通过这个链并被发布到我们的LiveData。</p><p id="659d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe lw lx ly lz b">ViewState.Error</code>之后发生的完成事件将触发<code class="fe lw lx ly lz b">repeatWhen()</code> <em class="mq">、</em>，我们将开始监听来自<code class="fe lw lx ly lz b">refreshSignalStream</code>的刷新事件。用户将在屏幕上看到重试按钮(因为<code class="fe lw lx ly lz b">ViewState.Error</code>)，当他们点击按钮<code class="fe lw lx ly lz b">refreshSignalStream</code> <em class="mq">，</em>时，它将发出，我们将从<code class="fe lw lx ly lz b">ViewState.Loading</code>开始重新订阅我们的上游。</p><p id="9c64" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们最后的链条变成这样:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ma mb l"/></div></figure><p id="f780" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我认为这种方式更好，因为现在我们有了一个发出完整视图状态的流。侦听这些视图状态所需的其他操作现在可以这样做，因为视图状态都没有不同的处理方式。</p><p id="589b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个帖子到此为止。请在评论中告诉我你对此的看法！</p></div></div>    
</body>
</html>