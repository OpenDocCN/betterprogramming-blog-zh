<html>
<head>
<title>5 Reasons Why You Should Know The Composite Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该知道复合设计模式的5个理由</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-reasons-why-you-should-know-the-composite-design-pattern-226ecc651ce9?source=collection_archive---------8-----------------------#2022-01-18">https://betterprogramming.pub/5-reasons-why-you-should-know-the-composite-design-pattern-226ecc651ce9?source=collection_archive---------8-----------------------#2022-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="db5e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用复合模式编写智能代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2cb812cd106fb01b5e19150629f0d315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JonntXTk_pCnUbjo4MeO3g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">穆罕默德·拉赫马尼在Unsplash上的照片</em></p></figure><p id="b71c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开发动态用户界面时，复合模式可以成为你的瑞士军刀。当我们开发web应用程序时，我们在客户端使用DOM。这是完美的，因为DOM是如何构造的。</p><p id="2dfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目标是将一个以上的对象组成一个特定的树形结构，代表一个<em class="lv">部分-整体层次</em>。</p><p id="7e25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">部分-整体</em>关系是指集合中的每个对象都是<em class="lv">整体</em>组合的<em class="lv">部分</em>。这个<em class="lv">【整体】</em>构图是<em class="lv">部分</em>的集合。当我们想到部分-整体层次结构时，它是一个树形结构，其中每个单独的<em class="lv">【叶子】</em>或<em class="lv">【节点】</em>被视为与树中的每个其他叶子或节点相同，允许它们在我们的程序中被统一处理。这意味着对象的集合或组(叶子/节点的子树)是<em class="lv">也是</em>叶子或节点。</p><p id="a5fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们从视觉角度看它的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/097c46f8c582cff801665aab0a38add8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iSrAizTF4FT6ckWn.png"/></div></div></figure><p id="ecc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在软件工程中，开发人员可以利用这种模式，在这种模式下，他们需要处理深度嵌套的对象，而不必担心以后的实现细节。这是一个强大的技术，可以帮助解决复杂的问题，我们将在这篇文章中看到。</p><p id="6a25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将解释为什么知道复合设计模式是至关重要的。</p><h1 id="676b" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">您可以像处理单个对象一样处理集合</h1><p id="b625" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">统一处理对象和对象集合已经很强大了。</p><p id="24a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您很可能已经处理过使用它的代码。如果您熟悉DOM，那么您已经熟悉了从DOM节点遍历子节点</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为DOM是结构化的，其中节点与其周围的节点具有部分-整体关系，所以我们可以统一使用DOM。下面的例子是使用简单的遍历函数突出显示元素的<code class="fe mw mx my mz b">img</code>子元素的简单方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/555533cc3b041c7c763616e1c73ad066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nei5YTNVLeCB89_p.png"/></div></div></figure><h1 id="80b8" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">递归变得更容易</h1><p id="945e" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在前面的代码示例中，我们看到了遍历DOM是如何让我们突出显示DOM节点集合的。但是代码还显示了<code class="fe mw mx my mz b">traverse</code>函数中的<em class="lv">递归</em>。</p><p id="ba80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归变得很容易，因为代码变得很小，这有助于更容易地维护和阅读代码。<em class="lv">不需要执行</em> <code class="fe mw mx my mz b"><em class="lv">for loop</em></code> <em class="lv">或跟踪任何状态来遍历和访问所有后代</em>。</p><h1 id="2be9" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">你可以找到任何DOM元素的位置</h1><p id="6efd" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">由于复合结构的性质，我们可以利用这种能力遍历DOM节点的树。</p><p id="14b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在DOM中寻找一个元素的位置可能是一场噩梦，尤其是当它们被调整为不同的<code class="fe mw mx my mz b">position</code>值时。</p><p id="a9b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们可以使用类似于<code class="fe mw mx my mz b">myElement.getBoundingClientRect()</code>的东西，因为它会返回我们的位置，所以今天就到此为止。但是这并不真正可靠，因为如果你向下滚动页面，你实际上可以得到一个负值(在这种情况下，你必须包括<code class="fe mw mx my mz b">window.pageYOffset</code>)，因为它是相对于滚动窗口计算的。</p><p id="7170" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以利用这个模式，通过遍历树来找到元素在DOM中的位置，因为它们都是这个接口:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="1f54" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">您可以了解如何在react中进行支撑训练</h1><p id="5ef1" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">这听起来可能很傻，但是你应该意识到正确的钻探依赖于共享<code class="fe mw mx my mz b">children</code>接口的每个react组件(返回的元素/组件是幕后的<code class="fe mw mx my mz b">children</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="d802" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们需要扩展现有对象时，只要我们保持叶节点/复合节点的签名或接口，保持对象的一致性是一项非常简单的任务。这意味着可伸缩性在未来不会成为大问题。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="f71d" class="lx ly it bd lz ma ni mc md me nj mg mh jz nk ka mj kc nl kd ml kf nm kg mn mo bi translated">可以轻松创建表单</h1><p id="f571" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">表单很好地展示了它们在创建健壮的应用程序中的有效性。下面的例子展示了这种模式在开发表单时提供的强大功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1443" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">扩展<code class="fe mw mx my mz b">Field</code>类简单而简短。由于实例的复合性质，我们能够通过调用统一的<code class="fe mw mx my mz b">value</code> getter函数将所有值抓取到一个漂亮的JSON对象中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="3f49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="d9eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当开发人员使用组件时，他们不必担心任何实现细节，这使他们能够专注于为他们的应用程序编写实际代码。</p><h1 id="29bb" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">结论</h1><p id="ba5f" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">本帖到此结束！我希望你发现这是有用的，并期待在未来更多！</p></div></div>    
</body>
</html>