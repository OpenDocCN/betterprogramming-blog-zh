<html>
<head>
<title>6 Concepts To Master When Dockerizing Python Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">整理Python应用程序时需要掌握的6个概念</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-concepts-to-master-when-dockerizing-python-applications-e5f5a6a87845?source=collection_archive---------3-----------------------#2021-11-04">https://betterprogramming.pub/6-concepts-to-master-when-dockerizing-python-applications-e5f5a6a87845?source=collection_archive---------3-----------------------#2021-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="beba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">映像变体、增量构建、内部缓存等。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c0da2feddc1c1323e5cafa2de206e71b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cpUReiHuhlhuhk61"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sonuba?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ragnar Vorel </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a9a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不久前，我开始尝试为Python应用程序构建极简容器图像的各种方法。因此，我想分享一些我一路走来学到的技巧和诀窍。</p><p id="0b44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文涵盖了以下关键概念:</p><ul class=""><li id="95d4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">图像变体</li><li id="b7cf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">工作目录和结构</li><li id="155f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">增量构建</li><li id="4029" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">内部缓存</li><li id="8d45" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Pip安装缓存</li><li id="8b41" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Pip从setup.py安装</li></ul><h1 id="6ecb" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">1.图像变体</h1><p id="5dfd" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">除了Python版本，Docker Hub中还托管了它的多个变体。</p><h2 id="6132" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">标准</h2><p id="c436" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">开发人员通常基于他们想要的Python版本来使用defacto图像变体。它表示如下:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="b333" class="ng mk it nt b gy nx ny l nz oa">FROM python:&lt;version&gt;</span></pre><p id="c84b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您将在Python版的docker文件中使用以下代码行:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="c9e7" class="ng mk it nt b gy nx ny l nz oa">FROM python:3.7</span></pre><h2 id="92b4" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">微小的</h2><p id="2114" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">除此之外，还有另一个叫做<code class="fe ob oc od nt b">slim</code>的变种，它只包含运行<code class="fe ob oc od nt b">Python</code>所需的最小软件包。以下是命令:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="5756" class="ng mk it nt b gy nx ny l nz oa">python:&lt;version&gt;-slim</span></pre><p id="6b1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的应用程序不需要外部依赖，并且只使用Python就可以开箱即用，那么这个变体是一个不错的选择。</p><h2 id="8973" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">阿尔卑斯山的</h2><p id="ea5d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">如果你关心的主要是最终图像的大小，你应该使用基于Alpine Linux项目的<code class="fe ob oc od nt b">alpine</code>版本。基本映像大约5MB，比其他任何发行版都小。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="3b5e" class="ng mk it nt b gy nx ny l nz oa">python:&lt;version&gt;-alpine</span></pre><p id="624d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过这个镜像内部用的是<a class="ae ky" href="https://musl.libc.org" rel="noopener ugc nofollow" target="_blank"> musl libc </a>而不是<a class="ae ky" href="https://www.etalabs.net/compare_libcs.html" rel="noopener ugc nofollow" target="_blank"> glibc和friends </a>。这可能是一个问题，因为大多数Linux发行版都是基于标准C库(glibc)的GNU版本。因此，您将需要编译和构建大多数重要的库，比如来自源代码的<code class="fe ob oc od nt b">matplotlib</code>。这可能会导致各种不必要的问题，并导致最终的图像要大得多，如果你使用其他变体。</p><h2 id="1b45" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">windowsservercore</h2><p id="f2bb" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">对于那些使用Windows 10专业版/企业版(周年纪念版)或Windows Server 2016的用户，可以选择<code class="fe ob oc od nt b">windowsservercore</code>版本，使用以下代码:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="f050" class="ng mk it nt b gy nx ny l nz oa">python:&lt;version&gt;-windowsservercore</span></pre><p id="69f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关在Windows上运行Docker的更多信息，请查看官方文档:</p><ul class=""><li id="1420" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://msdn.microsoft.com/en-us/virtualization/windowscontainers/quick_start/quick_start_windows_server" rel="noopener ugc nofollow" target="_blank"> Windows Server快速入门</a></li><li id="225b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://msdn.microsoft.com/en-us/virtualization/windowscontainers/quick_start/quick_start_windows_10" rel="noopener ugc nofollow" target="_blank"> Windows 10快速入门</a></li></ul><h1 id="ae27" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">2.工作目录和结构</h1><p id="acc5" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">容器图像具有不同的文件夹结构，其中之一如下:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="3d95" class="ng mk it nt b gy nx ny l nz oa">.<br/>├── app<br/>│   ├── __init__.py<br/>│   └── main.py<br/>├── Dockerfile<br/>└── requirements.txt</span></pre><p id="3669" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个结构中，<code class="fe ob oc od nt b">app</code>文件夹包含了您的项目的所有相关文件和文件夹。随后，您的docker文件应该如下所示:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="0f38" class="ng mk it nt b gy nx ny l nz oa">FROM python:3.7</span><span id="bc37" class="ng mk it nt b gy oe ny l nz oa">WORKDIR /app</span><span id="296c" class="ng mk it nt b gy oe ny l nz oa">COPY ./requirements.txt requirements.txt</span><span id="454c" class="ng mk it nt b gy oe ny l nz oa">RUN pip install -r /requirements.txt</span><span id="2034" class="ng mk it nt b gy oe ny l nz oa">COPY ./app /app</span><span id="f623" class="ng mk it nt b gy oe ny l nz oa">CMD ["python", "main.py"]</span></pre><p id="b9e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些开发人员会将项目文件放在另一个子目录中。比如下面是官方FastAPI文档提供的<a class="ae ky" href="https://fastapi.tiangolo.com/deployment/docker/#dockerfile" rel="noopener ugc nofollow" target="_blank"> DockerFile </a>:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="a6b9" class="ng mk it nt b gy nx ny l nz oa">FROM python:3.9</span><span id="c6c1" class="ng mk it nt b gy oe ny l nz oa">WORKDIR /code</span><span id="8669" class="ng mk it nt b gy oe ny l nz oa">COPY ./requirements.txt /code/requirements.txt</span><span id="42b5" class="ng mk it nt b gy oe ny l nz oa">RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt</span><span id="89ba" class="ng mk it nt b gy oe ny l nz oa">COPY ./app /code/app</span><span id="cbfd" class="ng mk it nt b gy oe ny l nz oa">CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "80"]</span></pre><p id="a609" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该DockerFile将<code class="fe ob oc od nt b">code</code>文件夹设置为工作目录，并通过<code class="fe ob oc od nt b">app.main:app</code>运行主文件。一般来说，这个docker文件在大多数用例中应该工作得很好。但是，如果在应用程序中调用自定义Python模块，以这种方式编写DockerFile会导致相对导入问题，如下所示:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="0cf1" class="ng mk it nt b gy nx ny l nz oa">ImportError: Cannot import name &lt;module&gt;</span></pre><p id="c860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用标准的文件夹结构，<code class="fe ob oc od nt b">app</code>文件夹应该是工作目录，您将运行<code class="fe ob oc od nt b">main:app</code>。这有助于解决相关的导入问题。</p><h1 id="bd4c" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">3.增量构建</h1><p id="dc63" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">Docker容器是从上到下递增构建的。在每一行代码上，它都会添加一层。后续层将被添加到彼此之上。层数越多，最终图像就越大。因此，您应该尽量减少RUN命令的数量，并尽可能将它们作为一个命令堆叠起来。例如，您的docker文件中没有两个不同的RUN命令，如下所示:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="c263" class="ng mk it nt b gy nx ny l nz oa">RUN python -m pip install -U pip<br/>RUN pip install -r requirements.txt</span></pre><p id="560c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该将它们合并成一个，如下所示:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="33a6" class="ng mk it nt b gy nx ny l nz oa">RUN python -m pip install -U pip &amp;&amp; pip install -r requirements.txt</span></pre><h1 id="23e9" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">4.内部缓存</h1><p id="611c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">到目前为止，您应该已经注意到需求文件和项目文件是分开复制的，而不是从一开始就复制所有的东西。DockerFile文件编写如下:</p><ul class=""><li id="7eb4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">复制需求文件</li><li id="30df" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">安装Python包</li><li id="c1cc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">复制应用程序文件</li></ul><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="2cfc" class="ng mk it nt b gy nx ny l nz oa">COPY ./requirements.txt requirements.txt</span><span id="766b" class="ng mk it nt b gy oe ny l nz oa">RUN pip install -r /requirements.txt</span><span id="369a" class="ng mk it nt b gy oe ny l nz oa">COPY ./app /app</span></pre><p id="c74d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker有自己的内部缓存，如果文件自上次构建以来没有变化，它将重用同一层。因为需求文件和安装不会经常改变，所以您可以用这种方式编写DockerFile，以便在每次重新构建容器映像时重用相同的层。因此，您将节省大量时间，因为您不再需要等待<code class="fe ob oc od nt b">pip install</code>进程运行。</p><h1 id="c353" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">5.Pip安装缓存</h1><p id="adb2" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">此外，每次通过pip install安装软件包时，pip都会存储自己的缓存。这个缓存通常对Docker映像没有用。因此，您应该使用<code class="fe ob oc od nt b">--no-cache-dir</code>标志来运行您的命令，以防止任何缓存。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="c8ab" class="ng mk it nt b gy nx ny l nz oa">pip install --no-cache-dir -r requirements.txt</span></pre><p id="1cd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的话，容器图像的尺寸会稍微减小。</p><h1 id="c012" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">6.Pip从setup.py安装</h1><p id="885e" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">并非所有Python包都可以直接从pypi安装。有些存储库要求您克隆存储库并通过setup.py安装它。</p><p id="50ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请看下面的示例命令，该命令用于通过setup.py克隆存储库并安装软件包:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="8011" class="ng mk it nt b gy nx ny l nz oa">git clone --recursive https://github.com/user/package.git<br/>cd package-master &amp;&amp; pip install .</span></pre><p id="387f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，您需要在docker文件中添加代码install git依赖项，如下所示:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="6f90" class="ng mk it nt b gy nx ny l nz oa">RUN apt-get -y install git</span></pre><p id="cc2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，运行以下命令:</p><ul class=""><li id="d5cf" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">克隆存储库</li><li id="75ab" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">切换到包含setup.py的工作目录</li><li id="fac0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">安装软件包</li><li id="50c1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">移除文件夹，因为我们不再需要它</li></ul><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="ba75" class="ng mk it nt b gy nx ny l nz oa">RUN git clone --recursive https://github.com/user/package.git &amp;&amp; cd package-master &amp;&amp; pip install --no-cache-dir . &amp;&amp; rm -R /app/package-master</span></pre><p id="cec6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，您可以预先在项目文件中克隆存储库，并像往常一样复制它，如下面的代码所示:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="6267" class="ng mk it nt b gy nx ny l nz oa">COPY ./package-master package-master<br/>RUN cd package-master &amp;&amp; pip install --no-cache-dir . &amp;&amp; cd .. &amp;&amp; rm -r package-master</span></pre><p id="1958" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法减少了安装git依赖项的需要，这将减少最终的映像大小。缺点是，每当有更新并且您希望使用最新版本时，您需要将存储库重新克隆到您的项目文件中。</p><h1 id="c8b4" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="776b" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">让我们回顾一下你今天所学的内容。</p><p id="4214" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文首先提供了DockerHub中提供的Python图像的不同变体的例子。</p><p id="b8b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，介绍了工作目录和文件夹结构。它概述了将项目文件放在子目录中的缺点。</p><p id="eeea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它继续深入解释了Docker的增量构建和内部缓存特性。随后，它还提到了通过在pip安装期间删除缓存和预先克隆存储库来减小容器映像大小的技巧。</p><p id="6a9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。祝你有美好的一天！</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="67c6" class="mj mk it bd ml mm om mo mp mq on ms mt jz oo ka mv kc op kd mx kf oq kg mz na bi translated">参考</h1><ol class=""><li id="10f5" class="lv lw it lb b lc nb lf nc li or lm os lq ot lu ou mb mc md bi translated"><a class="ae ky" href="https://hub.docker.com/_/python/" rel="noopener ugc nofollow" target="_blank"> DockerHub — Python官方图片</a></li><li id="f251" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ou mb mc md bi translated"><a class="ae ky" href="https://fastapi.tiangolo.com/deployment/docker/" rel="noopener ugc nofollow" target="_blank">集装箱中的FastAPI码头工人</a></li></ol></div></div>    
</body>
</html>