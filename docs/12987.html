<html>
<head>
<title>The “Real” Clean Architecture in Android: S.O.L.I.D.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中“真正”干净的架构:S.O.L.I.D。</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-real-clean-architecture-in-android-part-1-s-o-l-i-d-6a661b103451?source=collection_archive---------0-----------------------#2022-07-18">https://betterprogramming.pub/the-real-clean-architecture-in-android-part-1-s-o-l-i-d-6a661b103451?source=collection_archive---------0-----------------------#2022-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2c54" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如果你认为好的建筑很贵，那就去试试坏的建筑。布莱恩·福特和约瑟夫·约德</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/ffb1b78a42f9d0da98de8fbba86a3768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b69nu6FaKG4ofQGPpAnc4A.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">干净的架构图</p></figure><p id="89e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在过去的几年中，干净的架构可能是Android社区中最热门的话题，这种趋势似乎不会消失(谢天谢地)。</p><p id="c85d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本系列基于以下书籍和文档:</p><ol class=""><li id="74b2" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae mb" href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=sr_1_1?crid=9GR6QM8XY4T9&amp;keywords=the+clean+code&amp;qid=1657047914&amp;sprefix=the+clean+code%2Caps%2C186&amp;sr=8-1" rel="noopener ugc nofollow" target="_blank">罗伯特·c·马丁的干净代码</a></li><li id="d60e" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated"><a class="ae mb" href="https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164/ref=sr_1_1?keywords=clean+architecture&amp;qid=1657047966&amp;sprefix=clean+ar%2Caps%2C180&amp;sr=8-1" rel="noopener ugc nofollow" target="_blank">罗伯特·马丁的清洁建筑</a></li><li id="37a7" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">Martin Fowler的《企业应用架构模式》</li><li id="7443" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated"><a class="ae mb" href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=sr_1_1?keywords=domain+driven+design&amp;qid=1657048072&amp;sprefix=Domain+dri%2Caps%2C182&amp;sr=8-1" rel="noopener ugc nofollow" target="_blank">Eric Evans的领域驱动设计</a></li><li id="df6d" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">阿利斯泰尔·考克伯恩的六角形建筑</li><li id="8b56" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated"><a class="ae mb" href="https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/" rel="noopener ugc nofollow" target="_blank">杰弗里·巴勒莫的洋葱建筑</a></li></ol><p id="48f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些作者都同意大多数事情，但有时他们倾向于采取不同的路线，我也是！<br/>因此，这一系列不会是原始材料的总结，而是基于该领域和我的大多数专家的偏好的一种自以为是的清洁建筑方法。</p><p id="0e75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PS:在这篇文章里，我不会说<strong class="ky ir">你想听到的</strong>而是<strong class="ky ir">你需要听到的。</strong></p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="3040" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">什么是干净的建筑？</h1><p id="13f7" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">首先，我们假设CA不是什么:</p><ol class=""><li id="f59d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">要遵循的模板</li><li id="563b" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">一个不必要的样板文件会让你慢下来(除非你做错了)</li><li id="5965" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">一个新的流行架构，只在Android上工作(看看你的iOS、Web和后端家伙)</li></ol><blockquote class="nm nn no"><p id="841b" class="kw kx mh ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated"><em class="iq">那么什么是清洁建筑呢？</em></p></blockquote><p id="1aee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简短的回答是:</p><blockquote class="ns"><p id="69ff" class="nt nu iq bd nv nw nx ny nz oa ob lr dk translated">清洁建筑是S.O.L.I.D .原则的产物。</p></blockquote><p id="bda6" class="pw-post-body-paragraph kw kx iq ky b kz oc jr lb lc od ju le lf oe lh li lj of ll lm ln og lp lq lr ij bi translated"><em class="mh">因此，如果你不遵循它们，你就不是在做CA，你只是在遵循一个永远没有意义的模板。</em></p><p id="31df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我对其他文章的不满是，它们很少提到S.O.L.I.D原则，它们只关注关注点分离部分(SRP)，正因为如此，它们给读者留下了比阅读本文之前更多的疑问:<em class="mh">为什么那个用例只有一个方法？为什么我需要那个接口呢？为什么我需要不同的对象和映射器？</em></p><p id="bfa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些问题的答案都在S.O.L.I.D .原则中，所以在第1部分中，我将集中讨论这个理论，我将展示每个原则如何塑造干净的架构，然后我将在下面的文章中深入探讨每个组件。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="b45e" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">神盾局。</h1><p id="cd09" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">你需要意识到的是，神盾局的原则不仅仅是一个神话或者是你需要放在简历上的一个要点。</p><p id="39f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们是确定你的代码有多干净的基准。T9】</p><p id="145c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你不知道你的设计对不对？<em class="mh">检查您的代码是否符合S.O.L.I.D. </em>就像医生会检查您的血液测试一样，如果有问题，您的血液测试会告诉您，这同样适用于S.O.L.I.D .和您的代码。</p><p id="14e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，仅仅因为一个原则被违反了，并不意味着你会有问题，但是如果你有问题，错误或者效率低，你很可能违反了一个或多个S.O.L.I.D原则。</p><p id="a094" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mh">将S.O.L.I.D .原则视为可以帮助你远离麻烦的常识性原则，你可能不需要总是使用它们，但是你最好了解它们！</em> </p><h1 id="2a74" class="mp mq iq bd mr ms oh mu mv mw oi my mz jw oj jx nb jz ok ka nd kc ol kd nf ng bi translated">利斯科夫替代原理</h1><blockquote class="ns"><p id="0499" class="nt nu iq bd nv nw nx ny nz oa ob lr dk translated">派生类必须可以替换它们的基类。</p></blockquote><p id="498e" class="pw-post-body-paragraph kw kx iq ky b kz oc jr lb lc od ju le lf oe lh li lj of ll lm ln og lp lq lr ij bi translated">继承是你能拥有的最紧密的耦合，<em class="mh">不好的使用它会导致高度耦合和低内聚的代码</em>。</p><p id="9045" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数没有经验的工程师使用继承作为实现可重用性的主要方式，但是这通常使得维护几乎不可能实现(正如你所知道的，重复代码比耦合代码好得多，维护&gt;可重用性)。</p><p id="8f3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这在面向对象编程的早期非常普遍，甚至在高级开发人员中也是如此，<strong class="ky ir">LSP是用来规范继承的主要原则</strong>。</p><p id="6e9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看这个过于简单的例子(这不是你将在周围看到的常见的正方形/矩形例子),其中LSP被违反了:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="dc57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在你怀疑之前，不LSP没有被违反，因为Android开发人员的工资太低(尽管这是一个很好的论据😈).</p><p id="a4e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，开发人员决定让CTO成为Employee的子类，以重用<code class="fe oo op oq or b">getSalary</code>方法，因此，如果在CTO对象上调用<code class="fe oo op oq or b">getLineManager</code>方法，应用程序可能会崩溃。</p><p id="3374" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我确信你们中99%的人不会犯这个错误，因为你们知道CTO是一个<em class="mh">主管</em>而不是一个<em class="mh">员工</em>，但是代码库中的关系并不总是清晰的。事实上，我敢打赌，你已经看过很多大型的<code class="fe oo op oq or b">BaseActivity</code>、<code class="fe oo op oq or b">BaseFragment</code>、<code class="fe oo op oq or b">BaseViewModel</code> …类，这是违反LSP的另一个明显的例子。</p><blockquote class="nm nn no"><p id="bf85" class="kw kx mh ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">所以只要我不破坏LSP，使用继承是没问题的？</p></blockquote><p id="5f77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要使用继承，然后在违反LSP时切换到另一种方法，<strong class="ky ir"> <em class="mh">你应该改变你的思维方式，默认为composition </em> </strong>。</p><p id="5e55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">99%你想用继承做的事情都可以用合成来完成，所以你应该总是<strong class="ky ir"> <em class="mh">偏爱</em> <em class="mh">合成胜过继承</em> </strong>。<br/>如果碰巧不能使用组合，即使有任何<strong class="ky ir"> G.o.F .设计模式的帮助，</strong>那么你可以使用继承(通过确保你遵守LSP！).</p><blockquote class="nm nn no"><p id="e8bd" class="kw kx mh ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">使用继承最常见的场景是什么？</p></blockquote><p id="3336" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在一些情况下，可以使用继承(IS-A relationship)而不是组合(HAS-A relationship)，或者可能不是，但您必须使用它，例如:</p><ol class=""><li id="3619" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">当您正在使用的框架需要您使用它时(扩展活动、片段、视图模型…)</li><li id="d18b" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">做数据建模时(动物-&gt;哺乳动物…)</li></ol><p id="1fb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了模型和框架，<em class="mh">通常是</em>，架构组件不应该依赖于继承，因此任何依赖于继承的架构都不是好的和干净的。</p><h2 id="6409" class="os mq iq bd mr ot ou dn mv ov ow dp mz lf ox oy nb lj oz pa nd ln pb pc nf pd bi translated">测试</h2><p id="31a5" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">测试继承总是痛苦的，比测试合成需要更多的努力。</p><p id="2a87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当实现一个新的子类时，你不仅要测试新添加的公共方法和你从父类中覆盖的方法，而且你还要测试父类中你没有覆盖的所有其他方法！</p><p id="e3f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">毕竟，你不希望父类的改变破坏你的子类行为，不是吗？</p><p id="2cae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试作文反而是小菜一碟，因为你的测试不会关心合作者是如何工作的，他们只会关心你的合作者的合同，如果需要的话，它很容易被嘲笑/破坏/伪造。</p><p id="70dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mh">参考文献:<br/></em><strong class="ky ir"><em class="mh">*</em></strong><em class="mh">洁净架构，第九章</em>(<strong class="ky ir">LSP</strong>)<em class="mh"><br/>*</em><a class="ae mb" href="https://www.youtube.com/watch?v=-Z-17h3jG0A&amp;ab_channel=TuringAwardeeClips" rel="noopener ugc nofollow" target="_blank"><em class="mh">LSP</em></a>由来</p><h1 id="8684" class="mp mq iq bd mr ms oh mu mv mw oi my mz jw oj jx nb jz ok ka nd kc ol kd nf ng bi translated"><strong class="ak">单一责任原则</strong></h1><blockquote class="nm nn no"><p id="3594" class="kw kx mh ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">一个类应该做一件事，而且只能做一件事。</p></blockquote><p id="6083" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯……你的意思是<em class="mh">“一个</em> <strong class="ky ir"> <em class="mh">函数</em> </strong> <em class="mh">应该做一件，而且只能做一件事？”。<br/> </em> <strong class="ky ir">错误原理</strong>，再试一次。</p><blockquote class="nm nn no"><p id="65a2" class="kw kx mh ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">一个类应该有且只有一个改变的理由。</p></blockquote><p id="4d2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更好，但也许可以换一种方式来解释什么是<em class="mh">“改变的理由”</em>…</p><blockquote class="ns"><p id="5a4f" class="nt nu iq bd nv nw nx ny nz oa ob lr dk translated"><em class="kf">一个类应该只对一个参与者(用户组或利益相关者)负责。</em></p></blockquote><p id="c1a4" class="pw-post-body-paragraph kw kx iq ky b kz oc jr lb lc od ju le lf oe lh li lj of ll lm ln og lp lq lr ij bi translated">现在我们正在谈话！<br/>我使用术语<em class="mh">“类”</em>是因为我们在Java-Kotlin领域工作，更通用的描述是“<em class="mh">模块(不是Java模块)或包含一组内聚的函数和数据结构的源文件</em>”。</p><p id="dc5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“内聚”是SRP中的关键词:类的方法必须是内聚的，如果不是，你应该把那些方法移到另一个类中。</p><p id="2b5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">演员是谁？实际上有很多，因此会有很多类。<em class="mh">【登录】</em><em class="mh">【购买】</em>最有可能引起不同参与者的兴趣，例如<em class="mh">入职团队</em>和<em class="mh">销售团队</em>。所以把他们放在同一个班级就是违规了。</p><p id="3e43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最重要的是，<em class="mh">“登录”</em>特性不仅会引起PO的兴趣，还会引起定义如何执行用户交互的UI/UX设计者以及为您提供REST API的BE团队(以及其他可能涉及的参与者)的兴趣。</p><p id="f987" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些参与者，即使都参与到同一个特性中，也会希望尽可能地相互独立，不希望受到其他参与者的影响(UI更改不应该破坏你的API代码，API更改不应该破坏你的UI代码，UI更改和API更改都不应该破坏你的业务逻辑代码)。</p><blockquote class="nm nn no"><p id="6d2d" class="kw kx mh ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">康威定律:软件系统的最佳结构受到使用它的组织的社会结构的严重影响，因此每个软件模块都有一个，而且只有一个，改变的理由。</p></blockquote><p id="b4a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就带来了纵横切片的概念:<strong class="ky ir">特性</strong>(登录、搜索、购买…)<strong class="ky ir"/><strong class="ky ir">层</strong>(表示层、域、数据…..).</p><p id="da5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mh">每个跨职能团队的功能集。</em> <br/> <em class="mh">一层为跨职能团队的每个演员。</em></p><p id="2ea9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将在接下来的文章中详细阐述垂直和水平切片。</p><h2 id="1951" class="os mq iq bd mr ot ou dn mv ov ow dp mz lf ox oy nb lj oz pa nd ln pb pc nf pd bi translated">从SRP到CCP</h2><p id="c624" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">在<strong class="ky ir">组件级，</strong><strong class="ky ir">SRP</strong>成为<strong class="ky ir">通用关闭原则(CCP) </strong>，其表述如下:</p><blockquote class="ns"><p id="73f4" class="nt nu iq bd nv nw nx ny nz oa ob lr dk translated"><em class="kf">将那些因相同原因在相同时间改变的类聚集成组件。</em></p><p id="6db5" class="nt nu iq bd nv nw nx ny nz oa ob lr dk translated"><em class="kf">将那些在不同时间因不同原因而改变的类分成不同的组件</em>。</p></blockquote><p id="72cb" class="pw-post-body-paragraph kw kx iq ky b kz oc jr lb lc od ju le lf oe lh li lj of ll lm ln og lp lq lr ij bi translated"><strong class="ky ir"> CCP </strong>是拥有坚如磐石的<strong class="ky ir">模块化</strong>要遵循的最重要的原则之一(另一个主题我将在下面的文章中涉及)。</p><p id="a9fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过仅应用SRP，系统的架构看起来是这样的:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi pe"><img src="../Images/a3668baf5bd2bddd56f69d6b6ca82aa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ce3NgapFzBamtg1Xqt_H3w.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">战略成果计划的成果</p></figure><p id="86a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，我将在下面的文章中解释每个组件。</p><p id="838e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mh">参考文献:<br/></em><strong class="ky ir"><em class="mh">*</em></strong><em class="mh">清洁架构，第七章(</em><strong class="ky ir"><em class="mh">SRP</em></strong><em class="mh">)<br/></em><strong class="ky ir"><em class="mh">*</em></strong><em class="mh">清洁架构，第十三章(</em><strong class="ky ir"><em class="mh">【CCP</em></strong><em class="mh">)<br/>*企业应用架构模式，第一章</em></p><h1 id="0793" class="mp mq iq bd mr ms oh mu mv mw oi my mz jw oj jx nb jz ok ka nd kc ol kd nf ng bi translated">从属倒置原则</h1><blockquote class="ns"><p id="4065" class="nt nu iq bd nv nw nx ny nz oa ob lr dk translated">最灵活的系统是那些源代码依赖仅指抽象而非具体化的系统。</p></blockquote><p id="8aa0" class="pw-post-body-paragraph kw kx iq ky b kz oc jr lb lc od ju le lf oe lh li lj of ll lm ln og lp lq lr ij bi translated">这是最容易遵循的原则，但却是被开发人员粗暴违反的原则。</p><p id="1c6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不知何故，开发者认为你应该有一个接口<em class="mh">“只有在多重实现的情况下”</em>。<br/> <strong class="ky ir">这再错不过了。</strong></p><p id="9013" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任何名副其实的现代软件架构(六角形、洋葱形、干净)都严重依赖于DIP。我们不希望我们的高级业务规则依赖于低级细节。我们希望将高层次的抽象与低层次的细节隔离开来。</p><p id="8e5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多开发人员很难理解隔离的问题，因为他们不知道编译器是如何工作的，不知道可传递的依赖关系，也不知道他们从错误的类开始编写代码(下一篇文章将详细介绍)。</p><p id="62a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们以上一章(SRP)的图表为例，其中所有的箭头都指向同一个方向:</p><pre class="kh ki kj kk gt pf or pg ph aw pi bi"><span id="385d" class="os mq iq or b gy pj pk l pl pm">View -&gt; ViewModel -&gt; Interactor -&gt; Repository -&gt; Data Store...</span></pre><p id="832e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类<code class="fe oo op oq or b">ViewModel</code>将有一个对<code class="fe oo op oq or b">Interactor</code>的导入。<br/>类<code class="fe oo op oq or b">Interactor</code>将有一个<code class="fe oo op oq or b">Repository</code>的导入。诸如此类。</p><p id="993b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很多开发者不知道的是，<code class="fe oo op oq or b">ViewModel</code>还导入了<code class="fe oo op oq or b">Repository</code>和<code class="fe oo op oq or b">DataStore</code><strong class="ky ir"><em class="mh"/></strong>。<br/>对<code class="fe oo op oq or b">Data Store</code>的任何改变都将触发<code class="fe oo op oq or b">Repository</code>的重新编译，这将导致<code class="fe oo op oq or b">Interactor</code>和<code class="fe oo op oq or b">ViewModel</code>的重新编译，以此类推..直到<strong class="ky ir">控制流的第一级</strong>。</p><p id="d6e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个好的架构应该隔离变化，而不是将它们传播到每一个地方。</p><p id="9321" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最重要的是，箭头的方向不仅决定了编译，还决定了开发人员将要编写的第一个类，在这种情况下是<code class="fe oo op oq or b">Data Source</code>，我们将在下一篇文章中看到，这是开始实现的错误类。</p><p id="f421" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们将倾角原理应用于上一章的图表，它看起来会是这样的:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/9971238c46e29922beb5bca7e919a201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*ySw5cRfql7kUhMYEiDADhg.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">SRP + DIP的结果</p></figure><h2 id="18b0" class="os mq iq bd mr ot ou dn mv ov ow dp mz lf ox oy nb lj oz pa nd ln pb pc nf pd bi translated">测试</h2><p id="dea3" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated"><strong class="ky ir"> <em class="mh">可测性</em> </strong>也深受这个原理的影响。一旦你有了一个接口，创建一个测试替身就成了一项主流工作。</p><blockquote class="nm nn no"><p id="2030" class="kw kx mh ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">但是我用的是Mockito，测试用的不需要接口…</p></blockquote><p id="3e1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，我知道，你仍然可以通过使用一个使用<em class="mh">反射</em>的模仿框架来“模仿”合作者的行为。但是我也知道嘲弄框架会使测试变慢。事实上，在我的机器上，每次我运行一个测试类，Mockito都会额外增加5-10秒的执行时间，这对于TDDer来说意味着每个TDD周期要额外等待5-10秒(这仍然比完全不进行TDD要快)。</p><p id="da92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mh"> PS:当您在您的CI上运行测试时，额外的5-10秒成为一个小问题，因为这是Mockito为每个模块启动所花费的时间(</em> <a class="ae mb" href="https://github.com/mockk/mockk/issues/13" rel="noopener ugc nofollow" target="_blank"> <em class="mh">如果您认为通过切换框架可以解决问题，mock</em></a><em class="mh">也会发生同样的事情)。</em></p><p id="1fb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建您自己的测试替身而不是使用嘲讽框架的最后一个优点是，您永远不必引用合作者的方法。</p><p id="a18c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，当使用Mockito进行嘲讽时，您会这样做:</p><pre class="kh ki kj kk gt pf or pg ph aw pi bi"><span id="f1f2" class="os mq iq or b gy pj pk l pl pm">@Test<br/>fun test1() {<br/>    whenever(collaborator.method()).thenReturn(...)<br/>    //...<br/>}</span><span id="5b2b" class="os mq iq or b gy po pk l pl pm">@Test<br/>fun test2() {<br/>    whenever(collaborator.method()).thenReturn(...)<br/>    //...<br/>}</span><span id="26c7" class="os mq iq or b gy po pk l pl pm">@Test<br/>fun test3() {<br/>    whenever(collaborator.method()).thenReturn(...)<br/>    //...<br/>}</span><span id="e578" class="os mq iq or b gy po pk l pl pm">//... you got the point</span></pre><p id="7601" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而当您创建自己的测试替身时:</p><pre class="kh ki kj kk gt pf or pg ph aw pi bi"><span id="6bbe" class="os mq iq or b gy pj pk l pl pm">class CollaboratorTestDouble: Collaborator {<br/>    fun mockMethod(...) { ... }</span><span id="c236" class="os mq iq or b gy po pk l pl pm">    override fun method() {<br/>        // stub, mock, spy...<br/>    }<br/>}</span></pre><p id="3ddd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的测试将不再引用<code class="fe oo op oq or b">method</code>:</p><pre class="kh ki kj kk gt pf or pg ph aw pi bi"><span id="af87" class="os mq iq or b gy pj pk l pl pm">@Test<br/>fun test1() {<br/>    collaborator.mockMethod(...)<br/>    //...<br/>}</span><span id="c276" class="os mq iq or b gy po pk l pl pm">@Test<br/>fun test2() {<br/>    collaborator.mockMethod(...)<br/>    //...<br/>}</span><span id="c149" class="os mq iq or b gy po pk l pl pm">@Test<br/>fun test3() {<br/>    collaborator.mockMethod(...)<br/>    //...<br/>}</span><span id="be20" class="os mq iq or b gy po pk l pl pm">//... </span></pre><p id="3cff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并且，通过不引用合作者的方法，您的测试可以更好地避免方法签名的改变，从而减少需要更新的代码和需要评审的代码。测试看起来也更具可读性。</p><p id="e0a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时你甚至不需要创建一个测试替身，因为你可以<strong class="ky ir">使用一个真实的实现。<br/> </strong>当这样的实现<strong class="ky ir">需要最少的设置</strong>(它没有合作者)并且它是在当前被测试的类之前创建的时候，这通常是更可取的。</p><p id="ec97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其他时候，模拟根本就不能很好地工作。<br/>想想<code class="fe oo op oq or b">SharedPreferences.Editor</code>接口，每个方法都返回对象实例，直到<code class="fe oo op oq or b">apply</code>或<code class="fe oo op oq or b">commit</code>被调用，事务才被执行。<br/>这里的许多人放弃了嘲笑，只是将测试转移到<code class="fe oo op oq or b">androidTest</code>文件夹，这样他们就可以使用真正的首选项，但在我看来这是一个彻底的失败。<br/>最快最干净的解决方案是创建一个<strong class="ky ir">假的</strong>，如下所示:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="om on l"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">对于使用内存中实现的SharedPreferences为Fake</p></figure><p id="0dd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个伪代码使用SharedPreferences接口的内存实现。<br/>通过在你的测试类中使用它，不需要任何设置，你只需要做<br/> <code class="fe oo op oq or b">fakePreferences.putString("key", "value").apply()</code> <br/>就可以预先设置你的偏好，就像你在<code class="fe oo op oq or b">androidTest</code>中使用真正的SharedPreferences一样，不同的是，使用这种方法，你的测试将在<strong class="ky ir"> JVM </strong>上运行，并且会快得多(显然比使用mocks更快)。</p><h2 id="12b1" class="os mq iq bd mr ot ou dn mv ov ow dp mz lf ox oy nb lj oz pa nd ln pb pc nf pd bi translated">有趣的故事</h2><p id="6645" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">几年前，Mockito不支持final类，当开发人员将他们的代码库从Java迁移到Kotlin(默认情况下类是final)时，他们的测试会失败。</p><p id="1dae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是他们糟糕的架构的明显标志，在这一点上，只有干净的解决方案(添加抽象)和肮脏的解决方案(使类开放)。</p><p id="e3c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你认为大多数开发人员采用了哪种解决方案？😈</p><p id="3ebb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这么说吧，我知道有很多公司在Mockito发布了他们的<code class="fe oo op oq or b">mock-maker-inline</code>解决方案后，做了一次大规模的重构公关，在所有地方都删除了<code class="fe oo op oq or b">open</code>关键词(这仍然不适用于<code class="fe oo op oq or b">spy</code>，也不能用于<code class="fe oo op oq or b">androidTest</code> btw)。</p><p id="75ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mh">参考文献:<br/></em><strong class="ky ir"><em class="mh">*</em></strong><em class="mh">洁净建筑，第十一章</em> ( <strong class="ky ir">倾角</strong> ) <em class="mh"> <br/> * </em> <a class="ae mb" href="https://alistair.cockburn.us/hexagonal-architecture/" rel="noopener ugc nofollow" target="_blank"> <em class="mh">六角形建筑</em></a><em class="mh"><br/>*</em><a class="ae mb" href="https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/" rel="noopener ugc nofollow" target="_blank"><em class="mh">洋葱式建筑，第一部</em></a><em class="mh"><br/>*</em><a class="ae mb" href="https://martinfowler.com/articles/mocksArentStubs.html" rel="noopener ugc nofollow" target="_blank"><em class="mh">马丁·福勒，莫克</em></a></p><h1 id="0d23" class="mp mq iq bd mr ms oh mu mv mw oi my mz jw oj jx nb jz ok ka nd kc ol kd nf ng bi translated">界面分离原理</h1><blockquote class="ns"><p id="95db" class="nt nu iq bd nv nw nx ny nz oa ob lr dk translated">保持小界面，这样用户就不会依赖他们不需要的东西。</p></blockquote><p id="0bbc" class="pw-post-body-paragraph kw kx iq ky b kz oc jr lb lc od ju le lf oe lh li lj of ll lm ln og lp lq lr ij bi translated">这主要是针对我们静态类型语言用户的，事实上，在动态类型语言中，开发人员甚至可以只使用<strong class="ky ir"> S.O.L.D. </strong>而不是<strong class="ky ir"> S.O.L.I.D. </strong>(在动态类型语言中遵守ISP仍然有好处，但我不会涉及它们，因为Android是基于Java/Kotlin的)。</p><p id="a39f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ISP可以被视为DIP的延伸，因为如果你根本没有接口，就不可能有小接口😉。</p><p id="75ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用DIP的目的是保护你的代码不受控制流和传递依赖的影响，而使用ISP <em class="mh">我们确保我们的合作者不仅是接口(或任何其他类型的抽象),而且它们也很小，所以我们不依赖于我们不使用的东西，当改变时，会导致额外的重新编译</em>。</p><p id="fb19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看这个例子:</p><pre class="kh ki kj kk gt pf or pg ph aw pi bi"><span id="8d5c" class="os mq iq or b gy pj pk l pl pm">interface UserService {<br/>    fun login(...)<br/>    fun logout(...)<br/>    fun createAccount(...)<br/>    //...<br/>}</span><span id="e7ae" class="os mq iq or b gy po pk l pl pm">class LoginViewModel(<br/>    private val userService: UserService<br/>): ViewModel() {<br/>    fun doSomething() {<br/>        //...<br/>        userService.login(...)<br/>        //...<br/>    }<br/>}</span></pre><p id="0ef4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oo op oq or b">LoginViewModel</code>只使用了<code class="fe oo op oq or b">UserService</code>的一种方法，然而它依赖于所有的方法+它们需要的所有对象参数。<br/>这意味着<code class="fe oo op oq or b">logout</code>中的变化将会重新编译<code class="fe oo op oq or b">LoginViewModel</code>。<br/>此外，向<code class="fe oo op oq or b">UserService</code>添加/移除方法将导致重新编译。</p><p id="8bfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个怎么解决？很简单，你可以创建更多更小的接口，而不是一个大的接口:</p><pre class="kh ki kj kk gt pf or pg ph aw pi bi"><span id="decc" class="os mq iq or b gy pj pk l pl pm">interface LoginInteractor {<br/>    fun execute(...)<br/>}<br/>interface LogoutInteractor {<br/>    fun execute()<br/>}<br/>interface CreateAccountInteractor {<br/>    fun execute()<br/>}<br/>//...</span></pre><h2 id="c1a5" class="os mq iq bd mr ot ou dn mv ov ow dp mz lf ox oy nb lj oz pa nd ln pb pc nf pd bi translated">ISP和SRP</h2><p id="3b0c" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">如果还不清楚的话，神盾局的原则并不是相互独立的，所以遵循一个原则，你很可能也会遵循其他一些原则，而违反一个原则，你很可能也会违反其他一些原则(这就是为什么大多数开发人员会违反大多数原则)。</p><p id="0039" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类可以实现接口，所以如果接口很小，那么类很可能遵循SRP。</p><p id="710a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mh">说到底，你觉得哪个职业更容易打破SRP？<br/>单一方法的类还是100个方法的类？</em></p><p id="2e96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时候，你需要小的接口，但是稍微大一点的类。接口最好是小的，因为它们是为使用它们的类而优化的。 <br/>类应该负责一件事，这通常会使它们变得更小，但是正如SRP所说，你不应该将一项职责分成多个类，因为你应该将内聚方法聚集在一个类中。</p><p id="5154" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种情况下该怎么办？<br/>简单，<em class="mh">你让你的类实现多个接口</em>！</p><h2 id="1b0d" class="os mq iq bd mr ot ou dn mv ov ow dp mz lf ox oy nb lj oz pa nd ln pb pc nf pd bi translated">从ISP到CRP</h2><p id="6cab" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">在<strong class="ky ir">组件级，</strong><strong class="ky ir">ISP</strong>变成了<strong class="ky ir">通用重用原则(CRP) </strong>，可以用以下方式表述:</p><blockquote class="ns"><p id="3a57" class="nt nu iq bd nv nw nx ny nz oa ob lr dk translated">不要强迫一个组件的用户依赖他们不需要的东西。</p></blockquote><p id="d16a" class="pw-post-body-paragraph kw kx iq ky b kz oc jr lb lc od ju le lf oe lh li lj of ll lm ln og lp lq lr ij bi translated">这是模块化的另一个重要原则。<br/> <em class="mh">一起重用的类应该是同一个组件的一部分。<br/> </em>像CCP一样，它告诉我们如何对类进行分组，但也告诉我们哪些类不能放在同一个组件下。</p><p id="fc22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像一个类在一个未使用的合作者的方法改变时重新编译一样，一个<em class="mh">组件</em>在一个<em class="mh">导入组件</em>的未使用的类改变时重新编译。</p><h2 id="8136" class="os mq iq bd mr ot ou dn mv ov ow dp mz lf ox oy nb lj oz pa nd ln pb pc nf pd bi translated">测试</h2><p id="3b68" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">当创建一个test double时，必须处理大的接口是很烦人的，因为你必须stub/mock接口的所有方法。</p><p id="8ca4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避免这个问题，你可以<strong class="ky ir">使用嘲讽框架</strong>或者<strong class="ky ir">坚持ISP。</strong></p><p id="5a57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就我个人而言，我并不反对嘲讽框架，我实际上在我所有的项目中都使用了它们，但我不喜欢的是，通过使用它们，开发人员可能会违反1条或更多的原则:</p><ul class=""><li id="3d2e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr pp ly lz ma bi translated">因为您可以模仿类，所以您可能会试图避免接口(DIP💔)</li><li id="63ed" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr pp ly lz ma bi translated">因为您不必模仿所有的方法，所以您可能想保留大的接口/类(SRP和ISP💔)</li></ul><p id="c518" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">遵循S.O.L.I.D .原则使测试更容易，并且<em class="mh">消除了使用模仿框架的需要。<br/> </em>不知何故，Android开发人员认为，如果他们不使用嘲讽框架，就无法测试他们的代码，不像iOS开发人员倾向于尽可能保持香草(古典主义者)风格。<br/> <em class="mh">这是因为Java/Kotlin库开发人员在过去的几年里做了非常好的营销</em> <strong class="ky ir"> <em class="mh">并不是因为单元测试天生就带着嘲讽的心态</em> </strong>。</p><p id="d7a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的观点是，在模仿框架和测试替身之间做出选择取决于你的团队的偏好(<em class="mh">如果这是你的团队编写测试的唯一方式，那么它就是正确的方式</em>)但是<strong class="ky ir">不管你使用什么样的模仿策略，你的代码都应该是可测试的！</strong></p><p id="51dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">参考资料:<br/> *清洁架构，第10章(<strong class="ky ir"> ISP </strong> ) <br/> *清洁架构，第13章(<strong class="ky ir"> CRP </strong>)</p><h1 id="968a" class="mp mq iq bd mr ms oh mu mv mw oi my mz jw oj jx nb jz ok ka nd kc ol kd nf ng bi translated">开闭原理</h1><blockquote class="ns"><p id="f5bf" class="nt nu iq bd nv nw nx ny nz oa ob lr dk translated">软件工件应该对扩展开放，但对修改关闭。</p></blockquote><p id="0a93" class="pw-post-body-paragraph kw kx iq ky b kz oc jr lb lc od ju le lf oe lh li lj of ll lm ln og lp lq lr ij bi translated">软件架构的最终目标是添加新的特性，而不必重写或重新编译任何现有的代码。这是因为每次你修改现有的代码时，你都可能引入回归错误并破坏先前构建的功能，更不用说合并冲突和非常大的拉请求了！</p><p id="4103" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">OCP是最不独立的神盾局原则，也是你最应该监控的原则，事实上，违反任何其他原则都很可能违反OCP原则:</p><ol class=""><li id="23a0" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">当LSP被违反</strong>时，继承被错误地使用，为了不破坏其他子类，添加子类可能需要对父类进行<strong class="ky ir">修改。</strong></li><li id="6fc7" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated"><strong class="ky ir">当SRP被违反</strong>时，因此一个类属于不止一个actor，无论何时actor需要新的集成，那么新的集成将<strong class="ky ir">修改现有的方法</strong>，这也将影响其他actor。</li><li id="f2a7" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated"><strong class="ky ir">当DIP被违反</strong>，<strong class="ky ir"> </strong>时，具体的类依赖于具体的类(也创建了可传递的依赖关系)，在某处添加一个新方法将需要对所有的类进行<strong class="ky ir">重新编译</strong>直到流程开始(是的，如果您想知道，重新编译也算作修改)。</li><li id="04cc" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated"><strong class="ky ir">当ISP被违反</strong>时，合作者的抽象拥有比所需更多的方法，向合作者添加新方法将<strong class="ky ir">重新编译</strong>不使用该方法的类。</li></ol><blockquote class="nm nn no"><p id="e328" class="kw kx mh ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">那么，如果我遵循其他4个原则，我能免费得到这个吗？</p></blockquote><p id="6af4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不，很不幸。</p><p id="5a45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在不违反其他原则的情况下，还有其他方法可以打破OCP，但幸运的是，检测这些额外的场景非常容易。</p><h2 id="2cd6" class="os mq iq bd mr ot ou dn mv ov ow dp mz lf ox oy nb lj oz pa nd ln pb pc nf pd bi translated">标志参数又名“魔法布尔”</h2><p id="2355" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">有多少次你想过<em class="mh">“我就在这里加一个布尔，如果真我做A，如果假我做B”？</em></p><p id="2543" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是对现有代码的修改，通过添加一个布尔值来支持B的集成。</p><p id="0b0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加一个新函数，而不是添加一个布尔值和修改一个现有的函数。</p><p id="9df6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，代替:</p><pre class="kh ki kj kk gt pf or pg ph aw pi bi"><span id="9e2f" class="os mq iq or b gy pj pk l pl pm">fun pay(isDebitCard: Boolean) { ... }</span></pre><p id="dfc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">做:</p><pre class="kh ki kj kk gt pf or pg ph aw pi bi"><span id="c8b5" class="os mq iq or b gy pj pk l pl pm">fun payWithDebitCard() { ... }</span><span id="4555" class="os mq iq or b gy po pk l pl pm">fun payWithCreditCard() { ... }</span></pre><h2 id="509d" class="os mq iq bd mr ot ou dn mv ov ow dp mz lf ox oy nb lj oz pa nd ln pb pc nf pd bi translated">枚举</h2><p id="6030" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">它们存在相同的标志参数问题，但破坏现有特性的可能性更高，因为您可以有很多值，不像布尔型最多有2个值(除非您传递多个布尔型😈).</p><p id="b5d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以再一次，不是:</p><pre class="kh ki kj kk gt pf or pg ph aw pi bi"><span id="1357" class="os mq iq or b gy pj pk l pl pm">enum class PaymentType {<br/>    DEBIT_CARD, CREDIT_CARD, BANK_TRANSFER, GOOGLE_PAY<br/>}</span><span id="f416" class="os mq iq or b gy po pk l pl pm">fun pay(paymentType: PaymentType)</span></pre><p id="36ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">做:</p><pre class="kh ki kj kk gt pf or pg ph aw pi bi"><span id="8841" class="os mq iq or b gy pj pk l pl pm">fun payWithDebitCard() { ... }</span><span id="d288" class="os mq iq or b gy po pk l pl pm">fun payWithCreditCard() { ... }</span><span id="bc31" class="os mq iq or b gy po pk l pl pm">fun payWithBankTransfer() { ... }</span><span id="6db8" class="os mq iq or b gy po pk l pl pm">fun payWithGooglePay() { ... }</span></pre><p id="e991" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这种方式添加支付方法不会破坏以前实现的支付方法，也不需要重新编译所有导入枚举的类。</p><blockquote class="nm nn no"><p id="baa9" class="kw kx mh ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">这是否意味着我不能使用标志和枚举？</p></blockquote><p id="7851" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不使用标志和枚举编写软件几乎是不可能的，因此，显然，不是所有的类和函数都严格遵守OCP。重要的是，当你必须使用标志参数或枚举时，你的函数只做那条<code class="fe oo op oq or b">if/else</code>或<code class="fe oo op oq or b">when</code>语句，不做任何其他事情。</p><p id="a8c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">参考资料:<br/> *干净的架构，第8章<br/> *干净的代码，第3章</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="313e" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">摘要</h1><p id="e3c7" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">我们可以用以下方式总结这些原则:</p><ol class=""><li id="5efe" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">SRP:类应该属于一个参与者</li><li id="bfe2" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">OCP:新的集成不应该触及现有的代码</li><li id="9f7a" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">LSP:正确使用继承，支持合成</li><li id="5408" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">ISP:抽象应该尽可能的小</li><li id="869b" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">DIP:合作者应该是抽象的</li></ol></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="0ac7" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">最后的笔记</h1><p id="5195" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">我知道S.O.L.I.D .原则不是最有趣的话题，这篇文章很长，但是希望现在你对干净建筑背后的理论有了更好的理解。</p><p id="9f36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您仍然难以理解它们，不要担心，我们将在下一篇文章中看到它们在实践中是如何工作的。</p></div></div>    
</body>
</html>