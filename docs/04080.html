<html>
<head>
<title>3 Examples of When Not to Use JavaScript Arrow Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">何时不使用JavaScript箭头函数的3个示例</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-examples-of-when-not-to-use-javascript-arrow-functions-90eebfbf7bb0?source=collection_archive---------1-----------------------#2020-03-23">https://betterprogramming.pub/3-examples-of-when-not-to-use-javascript-arrow-functions-90eebfbf7bb0?source=collection_archive---------1-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cf03" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">没有放之四海而皆准的语法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0668c0d211b9392f2681e0980a1f24bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G262fmRgxb1gnPgQDpcTBQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jannerboy62?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">缺口编号</a>在<a class="ae ky" href="https://unsplash.com/s/photos/arrow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">防溅板</a>上拍摄</p></figure><h1 id="12c4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">ES6箭头功能</h1><p id="b251" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">你知道他们，你爱他们，你可能一直在使用他们！作为2015年ECMAScript 6 更新的一部分，arrow函数大受欢迎，这是有充分理由的。Arrow函数语法是非常棒的语法糖，它消除了对以下内容的需求:</p><ul class=""><li id="f07e" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm mu mv mw mx bi translated">return关键字(对于单行函数)</li><li id="ead6" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">function关键字</li><li id="5758" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">波形括号</li></ul><p id="37b9" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">箭头函数还降低了JavaScript函数作用域中的一些复杂性，以及<code class="fe ng nh ni nj b">this</code>关键字，因为有时您真正需要的只是一个匿名函数。</p><p id="4e29" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">尽管如此，arrow函数并不是一个适合您在编写JavaScript函数时遇到的所有需求的万能解决方案。让我们深入探讨一下箭头函数不是正确答案的几种情况。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="39dc" class="kz la it bd lb lc nr le lf lg ns li lj jz nt ka ll kc nu kd ln kf nv kg lp lq bi translated">对象方法</h1><p id="6770" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">假设您想要创建一个绑定到对象的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="df9d" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">在这个例子中，如果我们调用<code class="fe ng nh ni nj b">mario.oneUp()</code>，我们期望<code class="fe ng nh ni nj b">mario.lives</code>的值从3增加到4。然而，正如目前所写的，无论调用多少次<code class="fe ng nh ni nj b">oneUp()</code>，值<code class="fe ng nh ni nj b">lives</code>都将保持不变。</p><p id="d6ab" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">这是为什么呢？答案是<code class="fe ng nh ni nj b">this</code>！</p><p id="2cf1" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">正如MDN所说:</p><blockquote class="ny nz oa"><p id="84b6" class="lr ls ob lt b lu mp ju lw lx mq jx lz oc nd mc md od ne mg mh oe nf mk ml mm im bi translated">箭头函数没有自己的<code class="fe ng nh ni nj b">this</code>。使用封闭词法范围的<code class="fe ng nh ni nj b">this</code>值；箭头函数遵循正常的变量查找规则。因此，在搜索当前作用域中不存在的<code class="fe ng nh ni nj b">this</code>时，一个arrow函数最终从它的封闭作用域中找到了<code class="fe ng nh ni nj b">this</code>。</p></blockquote><p id="a2bd" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">在我们的例子中，封闭范围是<code class="fe ng nh ni nj b">window</code>对象。调用<code class="fe ng nh ni nj b">oneUp()</code>会要求程序增加<code class="fe ng nh ni nj b">window</code>对象中<code class="fe ng nh ni nj b">lives</code>的值。不存在这样的值，所以代码不起作用。</p><p id="43f7" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">相反，我们希望使用传统的函数语法，这将把函数的<code class="fe ng nh ni nj b">this</code>绑定到调用该函数的特定对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="dae5" class="kz la it bd lb lc nr le lf lg ns li lj jz nt ka ll kc nu kd ln kf nv kg lp lq bi translated">对象原型</h1><p id="049b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">以下是我们将在本例中使用的JavaScript代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="ea3c" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">我们在第15行的函数调用会产生如下结果:</p><pre class="kj kk kl km gt of nj og oh aw oi bi"><span id="65e6" class="oj la it nj b gy ok ol l om on">true<br/><em class="ob">undefined</em></span></pre><p id="17fd" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">我们定义了<code class="fe ng nh ni nj b">speak()</code>原型函数，并为新的<code class="fe ng nh ni nj b">Robot</code>对象传入了一个标语，那么为什么这段代码的结果是未定义的呢？</p><p id="8a90" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">《T2》揭示了原因。如你所见，当我们要求控制台评估是否<code class="fe ng nh ni nj b">(this === window)</code>时，它返回<code class="fe ng nh ni nj b">true</code>。这为我们在前面的对象方法示例中讨论的内容提供了证据。</p><p id="ba6f" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">当使用需要上下文的函数时，我们必须使用常规函数语法，以便正确绑定<code class="fe ng nh ni nj b">this</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="ce6c" class="kz la it bd lb lc nr le lf lg ns li lj jz nt ka ll kc nu kd ln kf nv kg lp lq bi translated">动态语境</h1><p id="7606" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是我们的最后一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="94a3" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">到目前为止，您可能已经意识到这段代码不能工作，以及为什么它不能工作。给你个提示:又和<code class="fe ng nh ni nj b">this</code>有关。</p><p id="160e" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">Arrow函数语法在函数声明时静态地绑定上下文<strong class="lt iu">，这与我们在使用事件处理程序或事件监听器时试图实现的相反，事件处理程序或事件监听器本来就是动态的<strong class="lt iu">。</strong></strong></p><p id="f5cb" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">当通过事件处理程序或监听器操作DOM时，触发的事件指向属于目标元素的<code class="fe ng nh ni nj b">this</code>。</p><p id="f00e" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">对于在全局执行上下文中定义的箭头函数，<code class="fe ng nh ni nj b">this</code>将指向<code class="fe ng nh ni nj b">window</code>。所以在上面的代码中，<code class="fe ng nh ni nj b">this.classList</code>会对<code class="fe ng nh ni nj b">window.classList</code>求值，产生一个<code class="fe ng nh ni nj b">TypeError</code>。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="e954" class="kz la it bd lb lc nr le lf lg ns li lj jz nt ka ll kc nu kd ln kf nv kg lp lq bi translated">就这些了，伙计们！</h1><p id="1aa2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我希望这些例子容易理解。如果没有，我建议阅读JavaScript中的<code class="fe ng nh ni nj b">this</code>,帮助你理解何时使用或不使用箭头函数。</p><p id="6daf" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">一如既往，感谢阅读。</p></div></div>    
</body>
</html>