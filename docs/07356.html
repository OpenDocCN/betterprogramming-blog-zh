<html>
<head>
<title>Distributed Task Queues With Django, RabbitMQ, and Celery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django、RabbitMQ和Celery的分布式任务队列</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/distributed-task-queues-with-celery-rabbitmq-django-703c7857fc17?source=collection_archive---------1-----------------------#2021-01-07">https://betterprogramming.pub/distributed-task-queues-with-celery-rabbitmq-django-703c7857fc17?source=collection_archive---------1-----------------------#2021-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="85d3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解用于发出异步API请求的分布式任务队列</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2adc07c5fe6e810e2e3dd360bbc40568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KsG4cN2NREx9FBeAu3V_Xg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="80ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当用户发送请求，但是处理请求的时间比HTTP请求-响应周期长时，会发生什么情况？如果您正在访问多个数据库，或者想要返回一个太大而无法在时间窗口内处理的文档，该怎么办？如果您想要访问一个API，但是请求的数量被限制为每个<em class="lu"> t </em>时间窗口最多有<em class="lu"> n </em>个请求，该怎么办？</p><p id="4b1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是我硕士论文资料收集过程中提出的部分问题。在我的研究中，来自Twitter的微博客是通过Twitter API收集的。分布式任务队列解决了两个主要问题:</p><ol class=""><li id="3c5e" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">Twitter API将每个15分钟的请求窗口中的请求限制为最多900个获取状态/查找。数据收集包括超过10万个请求，或30多个小时。事实证明，在规划中，将这一过程转移到服务器上是不可或缺的。</li><li id="2fe8" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">数据库操作，特别是在我们的服务器托管的注释工具中为注释器创建实例，超出了请求/响应时间窗口。为了能够创建这些实例，我需要使用分布式任务队列。</li></ol><p id="3f26" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文将涵盖:</p><ul class=""><li id="e594" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt mj mb mc md bi translated">芹菜分布式任务队列</li><li id="cd21" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt mj mb mc md bi translated">兔子工人</li><li id="0c74" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt mj mb mc md bi translated">Django实施</li><li id="bb09" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt mj mb mc md bi translated">创建视图</li><li id="6f56" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt mj mb mc md bi translated">激活工人</li><li id="482a" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt mj mb mc md bi translated">更新和故障排除</li></ul><p id="bbb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些步骤可以通过localhost Django项目离线执行，也可以在服务器上在线执行(例如，通过DigitalOcean、Transip或AWS)。拥有服务器的好处是，您不需要打开计算机来运行这些分布式任务队列，对于Twitter API用例，这意味着24/7的数据收集请求。</p><p id="0f86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">请注意</strong>，分布式任务队列的实现可能有点麻烦，而且会变得相当困难。不要犹豫，去寻求帮助！本文假设对Django中的MVC架构(表单、URL端点和视图)有一个基本的了解。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="0562" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">芹菜分布式任务队列</h1><p id="482c" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">什么是分布式任务队列，为什么它们有用？每当您想要解决上面列举的问题时，您都在寻找异步任务队列。这些是可以在服务器上安排和/或在后台运行的任务队列。<a class="ae no" href="https://docs.celeryproject.org/en/stable/index.html" rel="noopener ugc nofollow" target="_blank"> Celery </a>是处理这些进程最常用的Python库。</p><p id="7b98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">任务队列的输入是一个叫做<em class="lu">任务</em>的工作单元。专用的工作进程不断地监视任务队列，寻找要执行的新工作。</p><p id="a5f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Celery通过消息进行通信，通常使用一个代理在客户和工人之间进行调解。为了启动一个任务，客户机向队列中添加一条消息，然后代理将这条消息传递给一个工人。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="06fc" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">兔子工人</h1><p id="53c1" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">Celery需要一个消息传输器，通常称为<em class="lu">代理</em>。受欢迎的经纪人包括RabbitMQ和Redis。代理是发送和接收消息的解决方案。它们利用所谓的<em class="lu">工作器</em>，这些工作器被初始化来运行某个任务。这些工作人员可以运行任务并更新这些任务的状态。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="e9d7" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">Django实施</h1><p id="ad91" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">对于整个设置和实现，Celery有非常好的文档。使用他们的文档。每当你遇到问题时，就用这个作为额外的补充。</p><p id="d226" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Django有一个非常棒的<a class="ae no" href="https://docs.djangoproject.com/en/3.0/ref/contrib/admin/" rel="noopener ugc nofollow" target="_blank">管理站点</a>，我们希望在那里包含我们的芹菜应用程序。Django-celery-results 是一个扩展，使我们能够使用管理站点存储芹菜任务结果。</p><p id="65ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从要安装的命令行包开始。我强烈建议您使用虚拟环境，并将包添加到虚拟环境的<code class="fe np nq nr ns b">requirements.txt</code>中。我们还为我们的用例安装了Twitter API的Python库包装器<code class="fe np nq nr ns b">Tweepy</code>。</p><pre class="kj kk kl km gt nt ns nu nv aw nw bi"><span id="3ea7" class="nx ms it ns b gy ny nz l oa ob">$ pip install celery<br/>$ pip install django-celery-results<br/>$ pip install tweepy</span><span id="bba0" class="nx ms it ns b gy oc nz l oa ob">$ pip freeze &gt; requirements.txt</span></pre><h2 id="5d36" class="nx ms it bd mt od oe dn mx of og dp nb lh oh oi nd ll oj ok nf lp ol om nh on bi translated">安装RabbitMQ用户</h2><p id="07e6" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">接下来，我们将创建一个RabbitMQ用户。我在DigitalOcean的Ubuntu 18.04服务器上工作，但是有其他平台的<a class="ae no" href="https://www.rabbitmq.com/admin-guide.html#:~:text=Operating%20Systems%20and%20Platforms" rel="noopener ugc nofollow" target="_blank">安装指南</a>。</p><pre class="kj kk kl km gt nt ns nu nv aw nw bi"><span id="44e7" class="nx ms it ns b gy ny nz l oa ob">$ sudo apt-get install rabbitmq-server<br/>$ sudo rabbitmqctl add_user myuser mypassword<br/>$ sudo rabbitmqctl add_vhost myvhost<br/>$ sudo rabbitmqctl set_user_tags myuser mytag<br/>$ sudo rabbitmqctl set_permissions -p myvhost myuser ".*" ".*" ".*"</span></pre><h2 id="d6fc" class="nx ms it bd mt od oe dn mx of og dp nb lh oh oi nd ll oj ok nf lp ol om nh on bi translated">Django项目</h2><p id="1f4c" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">接下来，我们将在Django应用程序中创建一些文件，我们的项目结构如下所示:</p><pre class="kj kk kl km gt nt ns nu nv aw nw bi"><span id="227b" class="nx ms it ns b gy ny nz l oa ob">[projectname]/<br/>├── [projectname]/<br/>├── ├── migrations/<br/>├── ├── static/<br/>├── ├── templates/<br/>│   ├── <strong class="ns iu">__init__.py</strong><br/>│   ├── admin.py<br/>│   ├── <strong class="ns iu">celery.py</strong><br/>│   ├── forms.py<br/>│   ├── <em class="lu">models.py</em><br/>│   ├── <em class="lu">settings.py</em><br/>│   ├── <strong class="ns iu">tasks.py<br/></strong>│   ├── <strong class="ns iu">twitter.py<br/></strong>│   ├── urls.py<br/>│   ├── <em class="lu">views.py</em><br/>│   ├── wsgi.py<br/>└── manage.py</span></pre><p id="3893" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先出场的是我们的<code class="fe np nq nr ns b">__init__.py</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="e9b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们创建主<code class="fe np nq nr ns b">celery.py</code>文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="55e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe np nq nr ns b">settings.py</code>中，我们包含了芹菜应用的设置，也包含了Django管理页面中芹菜更新的<code class="fe np nq nr ns b">django_celery_results</code>包。</p><p id="166c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe np nq nr ns b">'projectname'</code>(第9行)是您的Django项目的名称，可以替换为您自己的项目名称。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="c3da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经在我们的<code class="fe np nq nr ns b">INSTALLED_APPS</code>中包含了<code class="fe np nq nr ns b">django_celery_results</code>，但是我们仍然需要在我们的应用程序中迁移这个变化:</p><pre class="kj kk kl km gt nt ns nu nv aw nw bi"><span id="b7eb" class="nx ms it ns b gy ny nz l oa ob">$ cd projectname<br/>$ python3 manage.py makemigrations<br/>$ python3 manage.py migrate</span></pre><p id="8ed6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，当我们转到服务器的<code class="fe np nq nr ns b">/admin</code>页面时，我们可以看到任务已经被添加。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/a5df704e598fb82481a32073782815cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*yVHCnHqKuAoU4OGEet6XZw.png"/></div></figure><p id="5adc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们将为异步和分布式队列任务创建一个<code class="fe np nq nr ns b">tasks.py</code>文件。我已经包含了一个使用Twitter API的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="4b46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在芹菜函数前面加上了一个<code class="fe np nq nr ns b">c_</code>，这样我就不会忘记它们是异步函数。第12行确保这是一个异步任务，在第20行，我们可以通过对<code class="fe np nq nr ns b">tweet_ids</code>的迭代来更新状态。在我们的Django管理页面中，我们将看到每次迭代中任务增量的状态。</p><p id="bd64" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们将创建使用Twitter API的函数，并在<code class="fe np nq nr ns b">twitter.py</code>文件中获取tweets或状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="25e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Twitter API的认证密钥保存在一个单独的<code class="fe np nq nr ns b">.config</code>文件中。Twitter API设置需要一点时间，你可以遵循Twitter的部分的<a class="ae no" href="https://developer.twitter.com/en/docs/getting-started" rel="noopener ugc nofollow" target="_blank">安装指南。为了再现性，我还在<code class="fe np nq nr ns b">models.py</code>文件中包含了Tweet Django模型。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="75c5" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">创建视图</h1><p id="4214" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">现在我们已经有了Celery设置、RabbitMQ设置和Twitter API设置，为了组合这些功能，我们必须在一个视图中实现所有内容。现在，我假设您知道如何在Django中创建一个视图、一个带有表单的HTML模板和一个URL端点。如果没有，看看<a class="ae no" href="https://medium.com/javascript-in-plain-english/create-interactive-data-visualisations-with-django-chart-js-8c4d0b98770e" rel="noopener">这篇文章</a>。我还使用了<a class="ae no" href="https://docs.djangoproject.com/en/3.1/ref/contrib/messages/" rel="noopener ugc nofollow" target="_blank">消息框架</a>，这是一种在你的Django项目中提供用户反馈的神奇方式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="d444" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意</strong>函数名和参数之间的<code class="fe np nq nr ns b">.delay()</code>。这非常重要，因为这是Django和Celery理解您调用异步函数的方式。我经常忘记这一部分，让我告诉你，这需要永远的调试。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="b598" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">激活工人</h1><p id="471b" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">既然我们的视图中已经包含并链接了所有内容，我们将通过几个芹菜命令行命令来激活我们的工人。如果不激活我们的工作线程，任何后台任务都无法运行。确保您处于安装了Celery和RabbitMQ依赖项的虚拟环境中。</p><p id="c607" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您正在处理一个localhost Django项目，那么您将需要两个终端:一个通过<code class="fe np nq nr ns b">$ python manage.py runserver</code>运行您的项目，另一个运行下面的命令。如果您是服务器托管项目的工作人员，您只需要一个终端通过SSH或HTTPS登录到服务器。</p><pre class="kj kk kl km gt nt ns nu nv aw nw bi"><span id="a205" class="nx ms it ns b gy ny nz l oa ob"><strong class="ns iu">$</strong> celery -A projectname worker1 -l INFO<br/><strong class="ns iu">$</strong> celery -A projectname worker1 control shutdown</span></pre><p id="82d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">被激活的工人的名字是<code class="fe np nq nr ns b">worker1</code>，使用<code class="fe np nq nr ns b">-l</code>命令，您可以指定<a class="ae no" href="https://docs.python.org/3/howto/logging.html" rel="noopener ugc nofollow" target="_blank">日志记录级别</a>。第二个命令是关闭worker。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/a503196f54b69e860a86420cf1557ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*OhmmLImozNxwMZUYsoY7ZQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="fb62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦您的worker被激活，您应该能够运行Django项目中的视图。<em class="lu"/>导入种子用户<em class="lu"/>按钮激活<code class="fe np nq nr ns b">views.py</code>中的<code class="fe np nq nr ns b">scrape_tweets()</code>功能，包括使用<code class="fe np nq nr ns b">worker1</code>的分布式任务队列功能<code class="fe np nq nr ns b">c_get_tweets.delay()</code>。您可以在Django <code class="fe np nq nr ns b">/admin</code>页面中看到这个工人被激活了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/fbc3934ff66811e4be49cd9cadb062bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ErX63Ab5kXpad1AzTi7MDg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="242c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，我有其他分布式任务队列，<code class="fe np nq nr ns b">c_in_reply_to_user_id()</code>和<code class="fe np nq nr ns b">c_get_tweets_from_followers()</code>，它们类似于<code class="fe np nq nr ns b">c_get_tweets()</code>。当打开其中一个任务时，您可以看到该任务的元信息和结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/fd9740a44cb9f5e503d91e26ec733009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O4NFKj-M3MKO5RJWe3Tr5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8a0a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上一张图片中的<code class="fe np nq nr ns b">TASK STATE</code>在<code class="fe np nq nr ns b">tasks.py</code>的第27行被更新，这个函数为它正在收集的每个tweet ID更新<code class="fe np nq nr ns b">PROGRESS</code>中的任务状态。当任务完成时，它显示在<code class="fe np nq nr ns b">tasks.py</code>的第32行返回的字符串，这可以在Django <code class="fe np nq nr ns b">/admin</code>页面的<code class="fe np nq nr ns b">Result Data</code>中看到。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="260f" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">更新和故障排除</h1><p id="6efc" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">下面的命令专门用于检查状态，并在您使用上面的命令初始化worker后更新它。</p><pre class="kj kk kl km gt nt ns nu nv aw nw bi"><span id="0510" class="nx ms it ns b gy ny nz l oa ob"><strong class="ns iu">$</strong> celery status<br/><strong class="ns iu">$</strong> celery multi restart worker1 -A projectname</span><span id="e581" class="nx ms it ns b gy oc nz l oa ob"><strong class="ns iu">$</strong> celery multi stopwait worker1 -A projectname<br/><strong class="ns iu">$</strong> celery multi start worker1 -A projectname</span><span id="fbe9" class="nx ms it ns b gy oc nz l oa ob"><strong class="ns iu">$</strong> celery control shutdown</span></pre><p id="34e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">故障排除可能有点困难，尤其是在处理服务器托管的项目时，因为您还必须更新Gunicorn和守护进程。有关这方面的更多信息，请遵循<a class="ae no" href="https://www.digitalocean.com/community/tutorials/how-to-set-up-django-with-postgres-nginx-and-gunicorn-on-ubuntu-16-04" rel="noopener ugc nofollow" target="_blank">数字海洋指南</a>。我总是用下面的命令更新这些并检查日志。</p><pre class="kj kk kl km gt nt ns nu nv aw nw bi"><span id="da8c" class="nx ms it ns b gy ny nz l oa ob"><strong class="ns iu">$</strong> sudo systemctl restart gunicorn<br/><strong class="ns iu">$</strong> sudo systemctl daemon-reload<br/><strong class="ns iu">$</strong> sudo journalctl -u gunicorn --since "1 hour ago"</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="2e1f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是了。我知道这很多，我花了一段时间才理解到可以使用分布式任务队列。最后，我用它来为我的论文收集数据(见下面的SQL DB)。如果您有任何问题，请告诉我，祝您编码愉快！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/364414bcabc65c008f9892d3cdf61c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cr6ve1c27FI4pFrfksDY0A.png"/></div></div></figure></div></div>    
</body>
</html>