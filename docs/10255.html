<html>
<head>
<title>Make Your Code 2x Faster With This Simple Python Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用这个简单的Python库，让您的代码速度提高2倍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/make-your-code-2x-faster-with-this-simple-python-library-83d92bf29aec?source=collection_archive---------0-----------------------#2021-12-17">https://betterprogramming.pub/make-your-code-2x-faster-with-this-simple-python-library-83d92bf29aec?source=collection_archive---------0-----------------------#2021-12-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2cfa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何在Python中轻松并行化任务以提升性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d433004a62a177c977a497c5498cb425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GyJeHm56HUTBTW0K95iHkw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片来源:作者</p></figure><p id="4d95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Celery是一个用Python编写的异步任务队列框架。Celery使执行后台任务变得容易，但也提供了并行执行和任务协调的工具。</p><p id="8991" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上一篇文章中，我们谈到了Python的Celery框架的基本原则。你可以点击查看上一篇文章<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/slow-http-response-times-celery-to-the-rescue-76346eb4212c">。</a></p><p id="282e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我们将讨论一种在Celery中构建工作流并轻松并行执行任务的方法。</p><p id="07ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当涉及大量后台任务时，监控和协调它们的执行是一项挑战。如果任务是独立的，执行顺序并不重要，那么它们可以并行执行而不会产生任何后果。Celery提供了一种既设计协调工作流又并行执行任务的方法。不用说，并行执行提供了显著的性能提升，应该尽可能地实现。</p><p id="1482" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在本帖中讨论以下主题:</p><ul class=""><li id="491c" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">从后台任务中检索结果</li><li id="885a" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">访问NewsAPI</li><li id="97e8" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">带有签名的任务协调</li><li id="97aa" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">密码</li><li id="c4f1" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">基准</li><li id="5817" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">结论</li></ul><p id="be92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章结束时，你将学会如何让几乎所有的Python代码更快，以及如何在这个过程中组织任务。</p><p id="8f22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们开始吧！</p><h1 id="1a1e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">从后台任务中检索结果</h1><p id="e752" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">后台任务可以定义如下:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="cbc6" class="nl mk it nh b gy nm nn l no np"><a class="ae lu" href="http://twitter.com/celery" rel="noopener ugc nofollow" target="_blank">@celery</a>.task()<br/>def add(num1, num2):<br/>    return num1 + num2</span></pre><p id="2e1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以使用以下语法执行后台任务:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="fc86" class="nl mk it nh b gy nm nn l no np">add.delay(4, 4)</span></pre><p id="35dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了检索任务的结果，我们需要使用一个允许Celery存储结果的后端。有很多选择，但对于这篇文章，我们将使用<em class="nq"> Redis </em>。<br/> <em class="nq">请注意:Windows上不支持Redis。</em></p><blockquote class="nr ns nt"><p id="6685" class="ky kz nq la b lb lc ju ld le lf jx lg nu li lj lk nv lm ln lo nw lq lr ls lt im bi translated">根据<a class="ae lu" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> redis </a>的说法，“Redis是一个开源(BSD许可的)、内存中的数据结构存储，用作数据库、缓存和消息代理”</p></blockquote><p id="59f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为内存中的数据存储意味着对Redis的读写操作特别快，使其适合于需要频繁读写操作的任务。</p><p id="a00c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://flaviocopes.com/redis-installation/" rel="noopener ugc nofollow" target="_blank">安装Redis的Linux指南</a>。</p><p id="224d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于MacOS，你可以用自制软件安装Redis。<br/>打开终端并运行:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="6e2e" class="nl mk it nh b gy nm nn l no np">brew install redis</span></pre><p id="8c7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后使用以下命令启动服务:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="c627" class="nl mk it nh b gy nm nn l no np">brew services start redis</span></pre><p id="fdbf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要检查服务是否正在运行，您可以运行:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="2952" class="nl mk it nh b gy nm nn l no np">brew services list</span></pre><p id="4700" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">芹菜实例现在可以这样定义:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="c5c7" class="nl mk it nh b gy nm nn l no np">from celery import Celery</span><span id="595f" class="nl mk it nh b gy nx nn l no np">celery = Celery(<br/>        'calc',<br/>        backend='redis://localhost',<br/>        broker='pyamqp://guest@localhost//'<br/>    )</span></pre><p id="a61f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">后台任务的结果可以很容易地用如下的<code class="fe ny nz oa nh b">get()</code>来检索:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="2e48" class="nl mk it nh b gy nm nn l no np">res = add.delay(4, 4)<br/>res.get()<br/>&gt;&gt; 8</span></pre><h1 id="3e6a" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">访问NewsAPI</h1><p id="6e81" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">出于本教程的目的，我们需要从API调用中检索数据。<br/>我们将从<a class="ae lu" href="https://newsapi.org" rel="noopener ugc nofollow" target="_blank"> NewsAPI </a>中检索数据。您可以在此注册从<a class="ae lu" href="https://newsapi.org/register" rel="noopener ugc nofollow" target="_blank">获取API密钥。注册后，您可以在此</a>查看top headlines API调用<a class="ae lu" href="https://newsapi.org/docs/endpoints/top-headlines" rel="noopener ugc nofollow" target="_blank">的文档。我们将使用top headlines端点，每次用一个国家代码名称来称呼它。</a></p><p id="144a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们需要五个国家的头条新闻。通过并行调用来加速该过程比进行五次顺序调用要快得多。但是首先，我们需要查看芹菜中的<code class="fe ny nz oa nh b">signatures</code>以及用<code class="fe ny nz oa nh b">chord</code>函数协调结果的方法。</p><h1 id="44e0" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">芹菜的任务协调</h1><blockquote class="nr ns nt"><p id="5731" class="ky kz nq la b lb lc ju ld le lf jx lg nu li lj lk nv lm ln lo nw lq lr ls lt im bi translated">签名以某种方式包装单个任务调用的参数、关键字参数和执行选项，以便将其传递给函数，甚至序列化并通过网络发送来自<a class="ae lu" href="https://docs.celeryproject.org/en/stable/userguide/canvas.html#canvas-chord" rel="noopener ugc nofollow" target="_blank">芹菜</a></p></blockquote><p id="6d54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基本上，签名允许我们创建并传递对Celery任务对象的引用。<br/>这意味着我们可以这样做:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="7eed" class="nl mk it nh b gy nm nn l no np">task = add.s(2, 2)</span></pre><p id="b534" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们可以简单地用<code class="fe ny nz oa nh b">delay()</code>调用这个函数，并像以前一样对它调用<code class="fe ny nz oa nh b">get()</code>:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="eb4d" class="nl mk it nh b gy nm nn l no np">res = task.delay()<br/>res.get()<br/>&gt;&gt; 8</span></pre><p id="86b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在你可能想知道为什么我们需要签名。签名允许我们将命令链接在一起，并使用Celery提供的工作流功能。假设我们想并行调用<code class="fe ny nz oa nh b">add()</code>多次并存储结果。你将如何着手做那件事？没有签名，就无法保存对芹菜任务对象的引用。</p><p id="76ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">芹菜中的<code class="fe ny nz oa nh b">group</code>函数将签名作为参数并并行执行，将结果存储在一个列表中。如果我们希望并行执行<code class="fe ny nz oa nh b">add()</code>调用，我们可以用<code class="fe ny nz oa nh b">group()</code>这样做:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="bd5b" class="nl mk it nh b gy nm nn l no np">g = group(add.s(1, 1), add.s(3, 3))<br/>res = g()<br/>res.get()<br/>&gt;&gt; [2, 6]</span></pre><p id="e730" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个有用的功能是<code class="fe ny nz oa nh b">chord()</code>。这类似于<code class="fe ny nz oa nh b">group()</code>命令，但是允许我们定义一个回调。因此，不是返回结果列表，而是使用结果列表作为参数调用回调函数。我们自己定义回调函数。当所有任务都被执行时，回调函数被调用。这意味着我们不必跟踪哪个任务仍在运行，以及所有任务是否都已完成。</p><p id="50fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在获得结果后必须对其进行操作的情况下,<code class="fe ny nz oa nh b">chord()</code>函数非常有用。例如，如果必须合并先前任务的结果以生成PDF报告。或者从几个API调用中检索的数据需要合并。</p><p id="c3a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在将从NewsAPI中并行检索头条新闻，并汇总呼叫结果。</p><p id="c7b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们来编码吧！</p><p id="adc1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你感兴趣，你可以在这里查看Celery <a class="ae lu" href="https://docs.celeryproject.org/en/stable/userguide/canvas.html" rel="noopener ugc nofollow" target="_blank">提供的工作流功能的完整列表。</a></p><h1 id="89d4" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">定义芹菜应用程序</h1><p id="db72" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">确保在您的newsAPI帐户中用API密钥替换<code class="fe ny nz oa nh b">&lt;API_KEY&gt;</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="50b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们定义一个芹菜应用程序，然后用<code class="fe ny nz oa nh b">@</code>符号定义两个芹菜任务。在<code class="fe ny nz oa nh b">getNewsData</code>中，我们执行一个简单的GET请求来检索作为参数提供的国家的头条新闻。这是将被并行化的函数。</p><p id="fea4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们希望检索所有调用的结果并将它们连接起来。为此，我们定义<code class="fe ny nz oa nh b">genReport</code>作为回调函数。在<code class="fe ny nz oa nh b">genReport</code>中，我们只是将JSON对象转换成Pandas数据帧，这样它们就可以很容易地连接起来。</p><p id="1171" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦它们被连接，我们重置索引以避免JSON转换错误，然后将连接的<code class="fe ny nz oa nh b">dataframe</code>作为JSON返回。Celery任务函数的返回类型必须是JSON serializable，这就是我们为什么回转型为JSON的原因。</p><h1 id="08ae" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">定义API</h1><p id="7ed6" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">记得用您的API密钥替换<code class="fe ny nz oa nh b">&lt;API_KEY&gt;</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="9bf8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们获得我们想要从中检索新闻的国家列表，然后创建一个任务签名列表。每个签名函数都是对<code class="fe ny nz oa nh b">getNewsData</code>任务的引用，其中一个国家作为参数提供。签名函数列表作为参数传递给<code class="fe ny nz oa nh b">chord</code>函数。最后，<code class="fe ny nz oa nh b">genReport</code>函数作为回调函数传递。</p><p id="92d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ny nz oa nh b">chord</code>函数将并行执行任务，然后用结果列表调用<code class="fe ny nz oa nh b">genReport</code>。</p><h1 id="31ca" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">测试和基准</h1><p id="90f1" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">太好了！现在让我们测试代码，确保一切正常。</p><p id="36e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">确保Redis服务正在运行。在项目根目录中打开一个终端窗口，然后使用以下命令运行Flask应用程序:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="f829" class="nl mk it nh b gy nm nn l no np">python3 newsapi.py</span></pre><p id="0f41" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，打开一个新的终端窗口，运行Celery应用程序:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="2017" class="nl mk it nh b gy nm nn l no np">celery -A celerynews worker --loglevel=INFO</span></pre><p id="4d72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一切都应该像这样运行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/3117b46b23ff1ff4ee05381b9e41c7ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JZVVhZeQDSoI5SS2.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">烧瓶应用程序在左边运行。芹菜应用程序在右边运行。</p></figure><p id="f1df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们使用Postman调用API，看看它是否有效！<br/>我们将数据编码为一个JSON对象，传递一个国家列表，使用国家代码指定每个国家。确保选择POST作为请求类型，并插入正确的url: <code class="fe ny nz oa nh b"><a class="ae lu" href="http://0.0.0.0:5000/api/send" rel="noopener ugc nofollow" target="_blank"><em class="nq">http://0.0.0.0:5000/api/send</em></a></code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/05fd559b79958f6d0de95793e900d5c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AtbVHqBLOG30P31o.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用Postman测试并行API调用</p></figure><p id="bf77" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">点击发送，你应该会在一两秒钟后看到一些回应。</p><p id="4083" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我认为看看这种并行化实际上有多快会很有趣。标题为“慢速版本”的代码文件中有一些注释代码。你可以把“快速版”下的代码放在注释里，把“慢速版”下的代码注释掉。注释后保存文件，Flask将自动重启网络服务器。</p><p id="349e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在可以复制之前使用的Postman中的选项卡，并再次点击Send。</p><p id="d9d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你会注意到得到回应的时间会稍长一些。我们可以在Postman中查看响应窗口的右上角，查看响应用了多少时间。如果您将它与快速版本进行比较，您会注意到它大约快了1.5倍。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/0464850b57b44643410dd8851aa89233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zVQ_3JjPYcqlpYSL.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不使用和弦功能时，响应时间较慢。</p></figure><p id="905d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我的例子中，使用<code class="fe ny nz oa nh b">chord</code>函数的并行化产生的代码比我没有使用它时快了2.5倍以上。考虑到只涉及5个API调用，这是一个相当显著的性能提升。对于更多的调用，性能提升会更大，因为如果调用是连续的，响应时间会线性增长。</p><h1 id="7620" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">不仅仅是API调用</h1><p id="612b" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">希望你喜欢这篇文章的内容！</p><p id="6861" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经看到了如何使用Redis作为芹菜的后端存储来检索后台任务的结果。此外，我们看到了在Celery中使用签名，以及如何使用内置的Celery函数(如<code class="fe ny nz oa nh b">chord</code>和<code class="fe ny nz oa nh b">group</code>)来协调和并行化任务。</p><p id="d1aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个话题超级有意思，也很有用。我相信它值得不仅仅是一个单一的职位。在离开之前，我想再谈一些使用案例。</p><p id="e1db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了便于演示，我在本教程中使用了API调用。然而，这种技术可以用于大量不同的情况。只要单个任务是无序的，也就是说，如果执行的顺序不重要，它们就可以并行化。</p><p id="6915" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我想到了以下三个案例:</p><ul class=""><li id="418b" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">机器学习任务——在同一个数据集上训练多个不同的模型。</li><li id="975f" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">网页抓取任务。</li><li id="2499" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">自动化脚本</li></ul><p id="f348" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第一种情况下，不同的模型可以被独立地训练。然后可以根据累积的结果计算验证分数。然后，可以保存给出最佳验证分数的模型以供将来使用。在这种情况下，使用<code class="fe ny nz oa nh b">chord</code>函数是最理想的。</p><p id="17a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第二种情况下，可以独立抓取多个网站并存储结果。如果只需要存储结果而不需要进一步操作，我们可以使用类似于<code class="fe ny nz oa nh b">group</code>函数的东西。</p><p id="61a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，Celery中可用的各种函数可以在自动化脚本中使用。自动化脚本通常需要一堆需要执行和协调的重复性任务。使用内置的Celery工作流函数来编写脚本会产生更干净、更易维护的代码。</p><p id="1ced" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个帖子到此为止。希望你学到了一些东西。<br/>下次见！</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="9595" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nq">最初发表于</em><a class="ae lu" href="https://haseebkamal.com/2021/12/14/make-your-code-2x-faster-with-this-simple-python-library/" rel="noopener ugc nofollow" target="_blank">T5【https://haseebkamal.com】</a><em class="nq">。</em></p></div></div>    
</body>
</html>