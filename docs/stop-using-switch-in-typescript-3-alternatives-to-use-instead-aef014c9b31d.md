# 停止在 TypeScript 中使用 Switch 改为使用 3 个替代选项

> 原文：<https://betterprogramming.pub/stop-using-switch-in-typescript-3-alternatives-to-use-instead-aef014c9b31d>

## 您可以避免 switch 语句，因为 TypeScript 有自己的版本

![](img/519b0f6a47f750a0539e0ea96cbab0d8.png)

Victoriano Izquierdo 在 [Unsplash](https://unsplash.com/s/photos/options?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片。

以下代码有什么问题？

你完全可以说“没什么”这将是一个有效的答案。但是，如果您发现这些代码是一个更大的代码库的一部分，其中有更多的逻辑，那么这些代码可以被认为是代码味道。说实话，声明并没有那么好。

使用`switch`语句，您创建了一个巨大的代码块，它必须被连续执行，一个接一个地检查条件。它的语法考虑到了诸如忘记写一个`break`子句和导致多个案例被意外执行的问题。如果可以避免的话，你不想使用一个`switch`语句，但是有哪些替代方法呢？

根据您使用的语言，您将有不同的选择。鉴于我们正在处理的是 TypeScript(因此也是 JavaScript)，我们可以混合搭配。以下是我在编码时避免`switch`语句的三种最喜欢的方法。

# 使用对象文字

这可能是三种方法中我最喜欢的一种，因为它非常简单，并且完全是 JavaScript 和 TypeScript 固有的。你不需要任何额外的知识，库，或者复杂的设计模式。您所需要的只是最基本的构造:一个对象文字(`{}`)。

这个解决方案的关键是将每个`case`块中的逻辑封装到一个单独的函数中，然后在一个对象文字中索引它们。没错，“索引它们。”我们的对象文字将作为这些代码块的索引，查找时间将变成 *O(1)* ，这是一个很大的额外好处。

我的意思是:

诚然，这里的复杂性是微不足道的，但你得到了要点。我已经设法将每个`case`语句的逻辑封装在每个语句的一个方法中。这已经是一个很好的实践了，但是我通过创建`theIndex`消除了对整个`switch`构造的需要，它只是一个对象文字。

理解这段代码所需的认知负荷比经历一大段`switch`要小。找到要执行的正确代码所需的查找时间也更短，因为引擎不必验证每一个`case`。相反，它可以准确地知道要寻找哪一个。

我知道你在想什么:如果你需要一个`default`案例来解释那些未知的价值呢？就像加个`IF`一样简单。你甚至可以这样做:

# 利用多态性

如果你是 OOP 的忠实粉丝，这个可能更适合你。

在我们的问题中，我们试图封装同一概念行为的不同版本:让我们的“动物”说话。它们可以发出“汪”、“喵”、“嘎嘎”或任何我们需要它们发出的声音，尽管这可能需要不同的代码，但它们在概念上做着同样的事情。

因此，我们可能对所有的方法都使用相同的方法，而不是对每一个都使用一种方法。唯一的区别是我们创建了不同的类。

这允许我们在每个不同的类中专门化我们的逻辑:

我们现在的问题？我们需要区别对待每个对象。我们不能只有一个动物列表来决定调用哪种方法——当然，除非我们确定它们是同一类型。我们可以通过一个更高阶的类(即通过使用继承)或一个公共接口来实现。

如果我们的动物都有一些需要重复编码的共同行为，那么一个共同的父类就有意义了。然而，在我们的例子中，一个简单的公共接口就足够了:

注意一些事情:

*   我们的接口为我们所有的类声明了一个公共的形状(必需的`speak`方法)。
*   我们所有的类现在都实现了相同的`IAnimal`接口。
*   我们现在可以忘记我们在和哪种动物打交道，只需要让它说话。

最后一个是这里的主要好处。我们不再关心寻找合适的动物。我们所要做的就是创建正确的动物类型，然后不再需要最初使用`switch`语句来检查正确类型的逻辑。

这是一种非常优雅的解决问题的方式——特别是如果 OOP 是你的代码库的一部分。

# 无商标消费品

想象一下，试图用工厂方法解决与你的`switch`相关的问题，却发现你需要一个大的`switch`语句来解决它。太讽刺了，不是吗？不是阿兰妮斯·莫利塞特式的。你知道，这个词的真正含义。

假设你已经编写了你的第一个解决方案，你已经把自己逼到了下面的情况:

多亏了仿制药，我们可以做得更好。

泛型是语言给你的一种表示类型的方式，而不需要实际指定它们。TypeScript 甚至允许您使用它们来定义函数签名。解决我们的问题需要两步:

1.  将我们依赖于`switch`的函数转换成一个通用函数，它实例化我们给它的任何类型的动物，而不需要一个`switch`语句。
2.  找到一种方法来专门化这个通用工厂，这样我们就不需要费心添加逻辑来决定我们要构建哪种类型的动物。

第二步实质上是`switch`声明的全部要点，如果我们能废除它，那么我们就不再需要它了。

第一步是通过将我们的`animalCreator`变成这样来解决的:

这个函数将一个“类型”作为第一个参数——事实上，它是一个类(注意需要调用`new`方法的能力)——然后是一堆通用属性(即`...args`部分，也称为 rest 属性)。

现在这已经足够了，但是在使用它的时候，您必须做这样的事情:

它们是有效的，但是在第二个例子中，我们创建了一只有九条命的狗(实际上，这个参数可以忽略，但是你明白了)。我们的代码不能“强制”正确的类型。

所以我们可以更进一步，为我们的生成器函数创建一个泛型类型——一个我们可以应用和专门化的类型。例如，如果我们想创建一个只能创建狗的函数，但要重用相同的通用代码，我们可以这样做:

现在我们可以做:

到目前为止，我们已经成功地消除了对`switch`语句的需求。你不需要有一大堆案例来决定实例化哪个类。我们现在直接传入我们想要的类。但是这还不够——当我们处理 JavaScript 和 TypeScript 时还不够——因为我们可以更进一步，从`dogMaker`中删除多余的`Dog`参数。我们已经很确定我们在造一只狗。我们不需要将它作为参数传递。它还从我们的代码中删除了对该类的直接依赖。

要做到这一点，我们可以使用 currying，这是一种函数式编程技术，涉及到创建一个包装器函数，该函数将预设我们想要的参数，并允许将其余的参数传递给该函数。对于我们的例子，我们想要一个`dogMaker`，这意味着将它作为参数传递不应该是开发人员的责任。以下是最终结果:

虽然这可能看起来是三个选项中最复杂的，但是如果您试图实现工厂模式，这可能是一种使您的代码更加专门化并且更容易理解的方法。

# 结论

事实:在许多情况下,`switch`陈述并不是最佳解决方案。另一个事实:虽然在某些情况下，90%的情况下这样做是完全有意义的，但是有一种更声明性的方法可以做到这一点。

在本文中，我与您分享了三种方法。

你觉得怎么样？你还在考虑使用`switch`还是我改变了你的想法？