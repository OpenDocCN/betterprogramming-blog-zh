# 如何在 Raspberry Pi 集群上安装 Kubernetes

> 原文：<https://betterprogramming.pub/how-to-install-kubernetes-on-a-raspberry-pi-cluster-49ad9a762d08>

## 在 Raspberry Pi 集群上开发和部署 Kubernetes 应用程序

![](img/f899383c7bc2a61efeb6160e9c88c926.png)

弗拉维奥·加斯佩里尼在 [Unsplash](https://unsplash.com/s/photos/sailor?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

这是在[在 Raspberry Pi 集群上开发和部署 Kubernetes 应用](https://medium.com/better-programming/develop-and-deploy-kubernetes-applications-on-a-raspberry-pi-cluster-fbd4d97a904c)中描述的系列文章的第三篇。上一篇文章介绍了[设置 Raspberry Pi 集群](https://medium.com/better-programming/how-to-set-up-a-raspberry-pi-cluster-ff484a1c6be9)。下一篇文章是[在 Raspberry Pi 集群上安装 Kubernetes](https://medium.com/@RichYoungkin/install-kubernetes-ingress-on-a-raspberry-pi-cluster-e8d5086c5009)。

本文是橡胶遇到道路的地方，让一个完全可操作的、多节点的 Kubernetes 集群启动并运行。本文假设读者对 Kubernetes 有基本的了解。

# 流程概述、修改和问题

如前一篇文章所述，我不会复制现成的信息。为了与这一理念保持一致，文章中的大部分内容实际上都是对 Kubernetes on(vanilla)Raspbian Lite 的引用。本指南是由 [TeamServerless](https://www.teamserverless.com) 维护的 GitHub 上 [k8s-on-raspbian](https://github.com/teamserverless/k8s-on-raspbian) repo 的一部分。这是关于如何在一个集群上启动和运行 Kubernetes 的极好参考。

在本文中，我将介绍该指南的概要，强调该指南和我所做的之间的任何差异。我还会解释一些我最初不理解的指南中的细节。

由于这篇文章引用了 Kubernetes on(vanilla)Raspbian Lite，您可能会发现在另一个浏览器窗口中打开它会很有帮助，这样您就可以根据需要在那篇文章和这篇文章之间进行交叉引用。

下面的标题名称与指南中的标题相匹配。

## 更新— K3s 和 D `ocker`

为了与我的目标保持一致，我选择使用完整的 Kubernetes 安装，而不是 K3s。也就是说，我的 Kubernetes 主节点非常繁忙，尽管它部署在 Raspberry Pi 4B 上。如果您担心系统负载/响应，尤其是如果您使用的是 Raspberry Pi 3 或更早版本，您可能会考虑安装 K3s。

## 先决条件

我使用有线网络连接集群，并使用 Wi-Fi 将路由器连接到外部网络。

## 主节点设置

*   我不需要刷新任何 SD 卡，因为我已经在[如何设置一个 Raspberry Pi 集群](https://medium.com/@RichYoungkin/raspberry-pi-cluster-setup-ff484a1c6be9)中描述过了。
*   关于网络的信息(例如，设置静态 IP 地址和 DHCP 配置)之前在[如何设置 Raspberry Pi 集群](https://medium.com/@RichYoungkin/raspberry-pi-cluster-setup-ff484a1c6be9)中有所介绍。在那篇文章中，我采用了不同的方法，选择使用 DHCP 根据 MAC 地址为集群分配静态地址。作为预防措施，我确实执行了步骤`sudo sysctl net.bridge.bridge-nf-call-iptables=1`。
*   我安装了 [Docker](https://www.docker.com/) 和`kubeadm`，如指南所述。
*   因为根据我以前的文章，我确信我已经禁用了 swap，所以我跳过了禁用 swap 这一节。但是确定不代表正确。我漏掉了关于 Debian 的那一点，说明你需要运行`sudo systemctl disable dphys-swapfile` *。这是关键的一步。如果你使用的是 [Raspbian](https://www.raspberrypi.org/downloads/raspbian/) (它是基于 Debian 的)，别忘了这么做。务必确认您的交换设置是正确的，如指南中所述(`sudo swapon --summary`)。*

除了以上所述，我基本上遵循了本节的内容。

## 初始化您的主节点

除了以下例外，我基本上照原样遵循了这一部分:

*   没有别的原因，除了这是我工作的地方使用的，我选择使用[法兰绒](https://coreos.com/flannel/docs/latest/)作为 pod 网络插件。[织](https://www.weave.works/docs/net/latest/overview/)是提到的另一种选择。

1.  如果你不熟悉 IP 地址 CIDR 的概念或符号(如`--pod-network-cidr=10.244.0.0/16`，[)，维基百科有一个很好的概述](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)。

完成后，我验证了一切都正常，但事实并非如此。一组`coredns-*`吊舱处于`CrashLoopBackoff`状态。

```
$ kubectl —namespace kube-system get pods
NAME                                  READY   STATUS             ...
coredns-5c98db65d4-hk78m              1/1     **CrashLoopBackOff**   ...
coredns-5c98db65d4-ts8nf              1/1     **CrashLoopBackOff**   ...
etcd-kubemaster                       1/1     Running            ...
...
```

这个 [reddit 帖子](https://www.reddit.com/r/kubernetes/comments/9fl7cg/coredns_crashloopbackoff_on_fresh_install/)最终找到了我的问题的答案。这个问题似乎有两种可能发生的方式。第一个看起来像是 SELinux 和 Docker 旧版本的结合。这是线程 OP 问题的原因，但不是我的问题(因为我没有运行 SELinux，也没有过时的 Docker 版本)。不过，该主题的第二篇文章确实给出了我的问题的答案。作为黑客，我手动修改了`resolve.conf`:

```
$ cat /etc/resolv.conf
# Generated by resolvconf
domain hsd1.co.comcast.net
nameserver 127.0.0.1
```

注意`nameserver`被设置为本地主机(127.0.0.1)。这将导致 CoreDNS 检测到一个循环，如本文 [StackOverflow 文章](https://stackoverflow.com/questions/53075796/coredns-pods-have-crashloopbackoff-or-error-state/53414041#53414041)所述(引用自上面的 reddit 文章)。我把`resolv.conf`的`nameserver`线去掉了。对于生产环境来说，这绝对不是一个推荐的解决方案，但是它对我来说是有效的。不出所料，重启后，`nameserver 127.0.0.1`返回到了`resolv.conf`文件，但是`coredns*`吊舱运行正常。根据上面 StackOverflow 文章的建议，我检查了一下是否使用了`resolved`:

```
$ systemctl list-unit-files | grep systemd-resolved
systemd-resolved.service               disabled
```

既然不是，我也就没再深究，继续前行。

另一件值得一提的事情是，该指南包括将`kubectl`的配置复制到另一个位置，即`~/.kube/config`。我还把这个配置文件`scp`到了我的 MacBook 上。这很有帮助，因为我的大部分管理工作都是在这台计算机上完成的，而不是在安装在 Raspberry Pi 上的 Kubernetes 主节点上完成的。我还在我的 MacBook 上运行了 [Minikube](https://kubernetes.io/docs/setup/learning-environment/minikube/) ，所以这个文件中有两个上下文。如果你不熟悉 Kubernetes 的上下文，这个资源是一个很好的介绍。

## 用编织网或法兰绒搭建网络

如上所述，我选择了法兰绒。

## 加入其他节点

此步骤不变。

## 部署容器

此步骤不变。

## 启动 Kubernetes 仪表板

此步骤不变。注意:为了从外部网络(例如，我的家庭网络)访问 Kubernetes 集群，运行`kubectl proxy`是必要的。我错过了这一步，损失了一些时间来找出我做错了什么。

## 移除测试部署

此步骤不变。

## 包扎

此步骤不变。虽然我对 [OpenFaaS](https://www.openfaas.com) 很感兴趣，但我并没有像本节建议的那样去探索它。

# 摘要

在本文中，我们安装了 Docker 并设置了一个完整的 Kubernetes 集群，包括 Kubernetes 仪表板。我们还部署了一个简单的 Kubernetes pod 来测试 Kubernetes 部署。

至此，我们已经有了一个可运行的 Kubernetes 集群，现在可以开始处理在集群上运行应用程序的后续步骤了。这些步骤将在不久的将来发布的文章中介绍。当这些文章可用时，我将更新介绍性文章[和这篇文章。](https://medium.com/@RichYoungkin/develop-and-deploy-kubernetes-applications-on-a-raspberry-pi-cluster-fbd4d97a904c)

# 参考

*   对我来说，这是在 Raspberry Pi 集群上设置 Kubernetes 的权威指南。
*   Kubernetes 官方指南安装 Kubernetes——这是一个很好的通用资源，尽管并不专门针对 Raspbian。这是值得熟悉的。