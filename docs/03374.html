<html>
<head>
<title>RabbitMQ vs. Kafka</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RabbitMQ vs .卡夫卡</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rabbitmq-vs-kafka-1ef22a041793?source=collection_archive---------0-----------------------#2020-02-06">https://betterprogramming.pub/rabbitmq-vs-kafka-1ef22a041793?source=collection_archive---------0-----------------------#2020-02-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="47c0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">建筑师的困境</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7454d2273c4e1c99510efea4c2b1f1d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ZVx9mJtt-nxe5x_UOzIKA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Justin Luebke 在<a class="ae ky" href="https://unsplash.com/s/photos/justin-luebke-coat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="37d4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="a310" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">作为一名处理大量基于微服务的系统的软件架构师，我经常遇到一个不断重复的问题，“我应该使用<a class="ae ky" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>还是<a class="ae ky" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Kafka </a>？”出于某种原因，许多开发人员认为这些技术是可以互换的。虽然在某些情况下确实如此，但这些平台之间存在各种潜在的差异。</p><p id="47d9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，不同的场景需要不同的解决方案，选择错误的解决方案可能会严重影响您设计、开发和维护软件解决方案的能力。</p><p id="9abd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这篇文章的目标是首先介绍基本的异步消息传递模式。然后，它继续介绍RabbitMQ和卡夫卡及其内部结构。<a class="ae ky" href="https://medium.com/better-programming/rabbitmq-vs-kafka-1779b5b70c41" rel="noopener">第2部分</a>强调了这些平台之间的关键差异、它们的各种优势和劣势，以及如何在两者之间做出选择。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="e178" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">异步消息传递模式</h1><p id="9a76" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><em class="ne">异步消息传递</em>是一种消息传递方案，在这种方案中，生产者的消息生产与消费者的消息处理是分离的。在处理消息传递系统时，我们通常识别两种主要的消息传递模式— <em class="ne">消息队列</em>和<em class="ne">发布/订阅。</em></p><h2 id="a296" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">消息排队</h2><p id="a5ec" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在消息队列通信模式中，队列暂时将生产者与消费者分离开来。多个生成器可以向同一个队列发送消息；但是，当使用者处理消息时，它会被锁定或从队列中删除，并且不再可用。只有一个消费者使用特定的消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/baacb1ac1c529fd77a42ecfb0ca0e5e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sKXP4QfrwFCGZy1fKZ_FnA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">消息队列</p></figure><p id="34b3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">顺便提一下，如果消费者未能处理某个消息，消息传递平台通常会将该消息返回到队列中，供其他消费者使用。除了时间解耦，队列还允许我们独立地扩展生产者和消费者，并提供一定程度的对处理错误的容错。</p><h2 id="85d6" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">发布/订阅</h2><p id="dec4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在发布/订阅(或发布/订阅)通信模式中，多个订阅者可以同时接收和处理一条消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/f60abaa4ede1109ff0c2dd68a5d07717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q1Ou71PmWgiqP7KeMyhajw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">发布/订阅</p></figure><p id="adb7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如，该模式允许发布者通知所有订阅者系统中发生了一些事情。很多排队平台经常把pub/sub和<em class="ne">话题这个词联系在一起。</em>在RabbitMQ中，主题是一种特定类型的发布/订阅实现(确切地说，是一种交换类型)，但是对于这一部分，我将主题称为发布/订阅的整体表示。</p><p id="2436" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一般来说，有两种类型的订阅:</p><ol class=""><li id="2d36" class="nt nu it lt b lu mn lx mo ma nv me nw mi nx mm ny nz oa ob bi translated"><strong class="lt iu">短期订阅</strong>，订阅只有在用户启动并运行时才有效。一旦消费者关闭，他们的订阅和待处理的消息就会丢失。</li><li id="ca7f" class="nt nu it lt b lu oc lx od ma oe me of mi og mm ny nz oa ob bi translated"><strong class="lt iu">持久订阅</strong>，只要订阅没有被明确删除，它就会被维护。当消费者关闭时，消息传递平台保持订阅，并且消息处理可以在以后恢复。</li></ol></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="bb69" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">兔子q</h1><p id="78a2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">RabbitMQ是一个消息代理的实现，通常被称为<em class="ne">服务总线。</em>它本身支持上述两种消息传递模式。其他流行的消息代理实现还有<a class="ae ky" href="https://activemq.apache.org/" rel="noopener ugc nofollow" target="_blank"> ActiveMQ </a>、<a class="ae ky" href="https://zeromq.org/" rel="noopener ugc nofollow" target="_blank"> ZeroMQ </a>、<a class="ae ky" href="https://azure.microsoft.com/en-us/services/service-bus/" rel="noopener ugc nofollow" target="_blank"> Azure服务总线</a>和<a class="ae ky" href="https://aws.amazon.com/sqs/" rel="noopener ugc nofollow" target="_blank">亚马逊简单队列服务(SQS) </a>。所有这些实现都有很多共同点；这篇文章中描述的许多概念适用于它们中的大多数。</p><h2 id="f9c4" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">行列</h2><p id="6d06" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">RabbitMQ支持开箱即用的经典消息队列。开发人员定义命名队列，然后发布者可以向该命名队列发送消息。反过来，消费者使用相同的队列来检索消息并进行处理。</p><h2 id="4476" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">消息交换</h2><p id="daad" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">RabbitMQ通过使用消息交换来实现发布/订阅。发布者将其消息发布到消息交换，而不知道这些消息的订阅者是谁。</p><p id="d1f1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">每个希望订阅交换的消费者创建一个队列；然后，消息交换将生成的消息排队，供消费者使用。它还可以根据各种路由规则为一些订户过滤消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/91f0fb3e7d5a085a210981a4087cd874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ucX-gnGYuKl71LsmfOmSQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">RabbitMQ消息交换</p></figure><p id="0a2a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">值得注意的是RabbitMQ支持短期和长期订阅。消费者可以通过RabbitMQ的API决定他们想要使用的订阅类型。</p><p id="cb5b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于RabbitMQ的架构，我们还可以创建一种混合方法——其中一些订阅者组成消费者组，这些消费者组在特定队列上以竞争消费者的形式共同处理消息。通过这种方式，我们实现了发布/订阅模式，同时还允许一些订阅者扩大规模来处理接收到的消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/5ba84a5eb4e5ad0361165ad3f4c9c67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xs5SsartNsVAg-npF6Lruw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">发布/订阅和排队相结合</p></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="c2ab" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">阿帕奇卡夫卡</h1><p id="ae40" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Apache Kafka不是消息代理的实现。相反，它是一个分布式流媒体平台。</p><p id="1588" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">与基于队列和交换的RabbitMQ不同，Kafka的存储层是使用分区事务日志实现的。Kafka还提供了实时处理流的Streams API和便于与各种数据源集成的Connectors API然而，这些超出了本文的范围。</p><p id="4473" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">云供应商为Kafka的存储层提供了替代解决方案。这些解决方案包括<a class="ae ky" href="https://azure.microsoft.com/en-us/services/event-hubs/" rel="noopener ugc nofollow" target="_blank"> Azure事件中心</a>，在某种程度上还有<a class="ae ky" href="https://aws.amazon.com/kinesis/data-streams/" rel="noopener ugc nofollow" target="_blank"> AWS Kinesis数据流</a>。Kafka的流处理能力也有特定于云的开源替代方案，但是，同样，这些超出了本文的范围。</p><h2 id="9177" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">主题</h2><p id="66c9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">卡夫卡没有实现队列的概念。取而代之的是，Kafka将记录集合存储在名为<em class="ne">主题的类别中。</em></p><p id="1999" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于每个主题，Kafka维护一个消息的分区日志。每个分区都是一个有序的、不可变的记录序列，其中不断追加消息。</p><p id="fa2b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当消息到达时，Kafka将消息附加到这些分区。默认情况下，它使用循环划分器将消息均匀地分布到各个分区。</p><p id="aa79" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">生产者可以修改这种行为来创建逻辑消息流。例如，在多租户应用程序中，我们可能希望根据每个消息的租户ID创建逻辑消息流。在物联网场景中，我们可能希望让每个生产者的身份不断地映射到特定的分区。确保来自同一个逻辑流的所有消息都映射到同一个分区，可以保证它们按顺序传递给消费者。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/9db817f4666a7cc2bad0798c775eb2ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ex6oX0h2k39fK_KPq5gVQQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡夫卡制片人</p></figure><p id="dd6c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">消费者通过维护这些分区的偏移量(或索引)并顺序读取它们来消费消息。</p><p id="5c40" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一个消费者可以消费多个主题，并且消费者可以扩展到可用分区的数量。</p><p id="c767" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，在创建主题时，应该仔细考虑该主题的预期消息吞吐量。一群共同消费一个话题的消费者被称为<em class="ne">消费者群体。Kafka的API通常处理消费者组中的消费者之间的分区处理的平衡以及消费者的当前分区偏移的存储。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/d186d138ac8447aa3ae5855a8e275e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fB3VV7HLNI9Vg1VjjLCPkQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡夫卡消费者</p></figure><h2 id="6ef7" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">用Kafka实现消息传递模式</h2><p id="0cb6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Kafka的实现很好地映射到了发布/订阅模式。</p><p id="ab23" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一个生产者可以向一个特定的主题发送消息，多个消费者组可以消费同一个消息。每个用户群都可以单独扩展来处理负载。因为使用者维护他们的分区偏移量，所以他们可以选择拥有一个在重新启动时维护其偏移量的持久订阅，或者拥有一个临时订阅，该订阅在每次启动时丢弃偏移量并从每个分区中的最新记录重新启动。</p><p id="aa2f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，它并不完全适合消息队列模式。当然，我们可以有一个只有一个消费者群体的主题来模拟经典的消息队列。然而，这有许多缺点<a class="ae ky" href="https://medium.com/better-programming/rabbitmq-vs-kafka-1779b5b70c41" rel="noopener">这篇文章的第2部分</a>详细讨论。</p><p id="5b01" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">重要的是要注意Kafka在预先配置的时间段内将消息保留在分区中，而不管消费者是否消费了这些消息。这种保留意味着消费者可以自由地重读过去的信息。此外，开发人员还可以使用Kafka的存储层来实现事件源和审计日志等机制。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="ee21" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">结束语</h1><p id="1709" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">虽然RabbitMQ和Kafka有时可以互换，但它们的实现却大相径庭。因此，我们不能将它们视为同一类工具的成员；一个是消息代理，另一个是分布式流媒体平台。</p><p id="2482" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">作为解决方案架构师，我们应该承认这些差异，并积极考虑对于给定的场景，我们应该使用哪种类型的解决方案。<a class="ae ky" href="https://medium.com/better-programming/rabbitmq-vs-kafka-1779b5b70c41" rel="noopener">第2部分</a>阐述了这些差异，并提供了何时使用它们的指导。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="a63c" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">进一步阅读</h1><p id="76d6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果您想了解更多关于RabbitMQ和Kafka的内部实现，我推荐以下资源:</p><ul class=""><li id="c6f3" class="nt nu it lt b lu mn lx mo ma nv me nw mi nx mm ok nz oa ob bi translated"><a class="ae ky" href="https://www.rabbitmq.com/tutorials/amqp-concepts.html" rel="noopener ugc nofollow" target="_blank"> AMQP 0.9.1车型讲解— RabbitMQ </a></li><li id="b0a8" class="nt nu it lt b lu oc lx od ma oe me of mi og mm ok nz oa ob bi translated"><a class="ae ky" href="https://kafka.apache.org/intro" rel="noopener ugc nofollow" target="_blank">阿帕奇卡夫卡简介</a></li></ul></div></div>    
</body>
</html>