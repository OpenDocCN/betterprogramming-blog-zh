<html>
<head>
<title>Smart Contracts: Which Is Better, Ethereum or Flow?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能合约:以太坊和流量哪个更好？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/smart-contracts-which-is-better-ethereum-or-flow-39f766c72e5d?source=collection_archive---------16-----------------------#2022-08-22">https://betterprogramming.pub/smart-contracts-which-is-better-ethereum-or-flow-39f766c72e5d?source=collection_archive---------16-----------------------#2022-08-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f3ce" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">希望编写智能合同的开发人员有几个可靠的选择。以下是帮助您做出决定的差异</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cebc2e3d69e02c4274ba33312d832e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aFTzmSRq2jqQxfO6pGdXvA.jpeg"/></div></div></figure><p id="594b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">自从引入智能合约技术以来，Solidity一直是智能合约开发人员选择的编码语言。</p><p id="f0c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，如果你是一个Solidity开发者，你已经知道它有缺点。在其他缺陷中，主要的安全问题可能源于对某些数据类型的简单错误处理，并且没有内置的访问控制。</p><p id="4f4a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为流量区块链开发的一种新的智能合同语言Cadence借鉴了Solidity的疏忽，并自然地解决了它的许多固有问题。而且如果你已经知道了扎实，学起来也很直接！</p><p id="c67a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文介绍了Cadence智能合同语言，详细说明了它如何改进Solidity，然后在一些常见的智能合同示例上对这两种语言进行了并排比较。最后，你应该对Cadence很熟悉，并准备好开始心流了！</p><h1 id="e111" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">关于凯登丝</h1><p id="8b5b" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Cadence是支持流量区块链的编程语言，由<a class="ae mk" href="https://www.google.com/url?q=https://www.dapperlabs.com/&amp;sa=D&amp;source=editors&amp;ust=1660707011831346&amp;usg=AOvVaw2svO7O5k7V2jqwbOSfn15E" rel="noopener ugc nofollow" target="_blank"> Dapper Labs </a>创建，用于支持大规模加密游戏和NFT项目。(你可能听说过NBA顶级投篮——他们最成功的项目之一。)它的语法可能很熟悉，因为它的灵感来自流行的现代语言，如Swift、Rust和Kotlin。Cadence是静态的<a class="ae mk" href="https://www.google.com/url?q=https://www.techopedia.com/definition/22321/statically-typed&amp;sa=D&amp;source=editors&amp;ust=1660707011831732&amp;usg=AOvVaw0hpO0Zm4xuNSFGVkHmFegV" rel="noopener ugc nofollow" target="_blank"/>和强类型的<a class="ae mk" href="https://www.google.com/url?q=https://www.techopedia.com/definition/24434/strongly-typed&amp;sa=D&amp;source=editors&amp;ust=1660707011832018&amp;usg=AOvVaw1mt0j90hN9XQGbPnV03ZDV" rel="noopener ugc nofollow" target="_blank"/>，具有面向资源的方法和基于能力的安全模型。</p><p id="d1bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着Cadence针对数字资产创建和管理进行了高度优化。</p><p id="21af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Cadence引入的最重要的创新是其基于资源的范例。这种方法使得创建、跟踪和管理用户资产变得非常容易。资产与用户的账户存储直接相关，而不是像以太坊那样依赖中央公共账本作为事实的来源。因此，作为资源创建的资产(如NFT)一次只能存在于一个位置。这确保他们只有一个所有者—外部拥有的帐户或智能合同。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/315d7b8e60b566b20b9b231fbd91070f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kq2OXffkbb_jQKzeHZuO_w.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated"><em class="mq">资源是具有受控创建和运行时支持的线性类型</em></p></figure><h1 id="750d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">踏频如何提高稳定性</h1><p id="e7c3" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Cadence在许多方面都优于Solidity。让我们看三个例子——小的编码错误、安全性和访问控制以及契约部署。</p><h1 id="bdec" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">那些小小的编码错误</h1><p id="aa97" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">一些最大的可靠性问题通常源于最小的错误。例如，仅用默认值初始化变量——尽管有时很方便——如果变量不变，可能会导致意想不到的结果。固定范围的数据类型可能导致潜在的下溢或上溢情况，如果该数据类型表示货币值，这将是灾难性的。</p><p id="56a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Cadence中，变量值必须在初始化时设置，从默认值中删除任何不需要的结果。此外，Cadence中的整数会自动检查下溢或溢出情况，而你需要继承OpenZeppelin的<a class="ae mk" href="https://docs.openzeppelin.com/contracts/2.x/api/math" rel="noopener ugc nofollow" target="_blank">安全数学库</a>或使用高于0.8的版本。</p><h1 id="336b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">安全和访问控制</h1><p id="03bc" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">当涉及到安全性和访问控制时，Solidity要求您创建自定义修饰符或继承其他基于安全性的智能合约，但也有许多默认情况下是公共的功能。</p><p id="a420" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">借助Cadence的<a class="ae mk" href="https://docs.onflow.org/cadence/language/capability-based-access-control/#gatsby-focus-wrapper" rel="noopener ugc nofollow" target="_blank">基于能力的安全模型</a>，账户只能执行他们有权访问的功能。这意味着Cadence将访问控制从根本上构建到了语言本身中。此外，Cadence中资源对象上定义的方法不容易受到<a class="ae mk" href="https://hackernoon.com/hack-solidity-reentrancy-attack" rel="noopener ugc nofollow" target="_blank">重入攻击</a>，这是Solidity开发人员在创建他们的逻辑流时必须敏锐意识到的。</p><h1 id="932b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">智能合同部署</h1><p id="d66b" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">当发现Solidity smart contracts中的问题时，如果不部署一个全新的合同，开发人员就无法修复它们。即使这样，脆弱的契约仍然存在。开发人员必须确保他们的用户群切换到新的合同。</p><p id="bcd2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Cadence中，<a class="ae mk" href="https://docs.onflow.org/cadence/language/contract-updatability/" rel="noopener ugc nofollow" target="_blank">智能合同可升级性</a>是内置的且透明的。当代码被声明为安全的和最终的时，可以通过从智能契约的所有者移除密钥来使契约不可变。</p><p id="90b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总的来说，Cadence是一种更安全、更可靠的智能合同语言，错误空间更小。</p><p id="3e15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们看看用Solidity和Cadence编写的智能合同之间的区别。我们将完成一个简单的Hello World契约和一个更复杂的NFT实现。</p><h1 id="780b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">简单合同</h1><p id="aac7" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">先说一个空前的经典。我们都用多种语言写过“Hello World ”,所以这是对Cadence的一个简单介绍。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/23a60be1cd85ce4bb42a7675969118da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Mrq1G-MWr-FArw4FFF35w.png"/></div></div></figure><p id="08e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们一步一步来。</p><h1 id="bf51" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">合同定义</h1><p id="3eb5" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">首先，我们有了契约定义。明显的区别是Cadence契约有一个访问控制修饰符:在本例中是pub。该修改器确保流网络中的每个人都可以访问契约，这是实体契约的默认行为。</p><p id="446f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，在Cadence中，我们也可以将访问控制设置为<code class="fe ms mt mu mv b">access(account)</code>。这将合同访问权限限制为部署该合同的帐户。在这里，我们已经看到了心流和以太坊之间的主要区别。我们不会简单地将合同部署到流量区块链；我们将它们部署到我们的帐户存储中。在流区块链上，每个帐户都用存储初始化，在存储中可以存储资源和结构。这个存储有自己的权限，这允许我们对谁可以执行我们的契约的方法进行细粒度的控制。</p><h1 id="181e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">合同变量</h1><p id="8190" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">下一行定义了一个作用于我们的契约的字符串变量。分号在Cadence中是可选的，一个<code class="fe ms mt mu mv b">let</code>关键字用于定义变量。</p><p id="3f25" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Cadence有两种类型的变量——可变的和不可变的。用<code class="fe ms mt mu mv b">let</code>创建的变量是不可变的，也称为常量；我们只能设置一次，并且在合同有效期内不能更改。我们用<code class="fe ms mt mu mv b">var</code>关键字定义可变变量(可以改变的变量)。</p><p id="0bfe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，我们在init方法中设置变量值，因为Cadence确保这个方法对于每个契约部署只调用一次。</p><h1 id="9065" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">方法</h1><p id="41d4" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">与Solidity的<code class="fe ms mt mu mv b">constructor</code>相当的抑扬顿挫就是<code class="fe ms mt mu mv b">init</code>法。此方法只被调用一次，即在部署协定时。</p><p id="6ebd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在init方法中，我们设置了greeting变量的值。虽然Solidity默认写入契约变量，但Cadence写入局部变量，并要求您使用self-object来访问契约变量。这个决定可以防止您在输入错误时意外写入合同变量。</p><p id="c236" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们契约的第二个方法返回问候变量。在Cadence和Solidity中，我们必须声明方法的访问是公共的，这两种语言都要求我们定义返回类型。在这种情况下，它是一个字符串。</p><p id="9b15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是扎实在这里要求我们更低级。它要求我们明确地告诉它字符串的位置。它还让我们将函数标记为view，这样我们就不会意外地修改区块链的状态。</p><p id="a3e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，Cadence不需要这种底层控制，因为它是强静态类型的。潜在的错误在程序运行之前就被捕获了，通过删除多余的关键字使整个方法声明更具可读性。</p><h1 id="86a0" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">NFT合同</h1><p id="991c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">接下来，让我们看一个来自两种语言的基本NFT契约:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/9111355d8a07356be8350c3f6d751f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I7FbCVVAkXBkGeVh79L1tQ.png"/></div></div></figure><p id="6b1e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为两种语言对这个例子有不同的处理方式，所以让我们分别来看一下:首先遍历Solidity例子，然后是Cadence。</p><h1 id="5dc0" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">固态</h1><p id="2c64" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在Solidity中，NFT是id的列表。您必须在智能合约中跟踪这些id，并手动增加它们以确保唯一性。Solidity对NFT和它们的唯一性一无所知。只是一个映射到它们主人的id列表。全部在合同内手动管理。如果ID增量处理不当，这就为错误留下了空间，可能导致多个NFT具有相同的ID。</p><p id="a27c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本例中，NFT没有附加任何附加数据，但是您可以向URI添加另一个映射ID。该合同确保每一个新铸造的NFT映射到一个所有者的地址。</p><p id="96a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这当然是一个简单的例子。通常，您需要扩展几个接口来获得远程安全的NFT契约和特性，比如用于将众所周知的jpg附加到您的NFT的元数据，但是基本机制是相同的。</p><h1 id="e1fc" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">节奏</h1><p id="a36d" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">现在，让我们看看Cadence版本以及它如何改进这个Solidity示例。</p><h1 id="5158" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">资源定义</h1><p id="c7c9" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Cadence示例从一个名为<code class="fe ms mt mu mv b">NFT</code>的资源类型开始。注意到<code class="fe ms mt mu mv b">NFT</code>前面的@符号了吗？此符号是必需的，因为它确保资源类型的用法和行为保持明确。</p><p id="9f51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以从资源中创建实例，并且它可以像结构一样具有属性。与常规结构的不同之处在于，资源是一种特殊的类型，除了它存储的数据之外，它还处理所有权。</p><p id="ac8f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在资源类型<code class="fe ms mt mu mv b">NFT</code>中，有一个id字段。<code class="fe ms mt mu mv b">id</code>字段是一个整数，<code class="fe ms mt mu mv b">UInt64</code>，它是赋予每个NFT资源的唯一id。这个<code class="fe ms mt mu mv b">id</code>对于每个NFT资源都是不同的，这意味着资源不能被复制或组合。接下来，使用<code class="fe ms mt mu mv b">init</code>函数初始化<code class="fe ms mt mu mv b">id</code>字段。</p><p id="5cad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就像<a class="ae mk" href="https://blog.logrocket.com/introducing-the-rust-borrow-checker/" rel="noopener ugc nofollow" target="_blank"> Rust的借用检查器</a>确保只有一个函数可以修改一个变量一样，Cadence确保它的资源也是如此。</p><h1 id="220d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">资源创建</h1><p id="ab07" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">创建新资源时，我们必须在存储位置之间移动它。如果我们让资源保持原样，我们的智能契约将无法正常运行，因此这迫使我们对资源及其存储位置进行仔细考虑。这种形式的控制还确保资源永远不会丢失或被意外删除；他们一次只能在一个地方。</p><p id="e2c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们调用mint函数时，它将创建我们的<code class="fe ms mt mu mv b">NFT</code>资源的一个新实例。该函数返回一个类型为<code class="fe ms mt mu mv b">NFT</code>的资源，并从前面定义的资源中获取字段<code class="fe ms mt mu mv b">id</code>。<code class="fe ms mt mu mv b">create</code>关键字有点像面向对象编程中的new操作符，创建一个新的资源。<code class="fe ms mt mu mv b">&lt;-</code>或move-operator表明，在我们调用它之后，这个资源在源上是不可用的。</p><h1 id="5e65" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">存储资源</h1><p id="b9a4" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated"><code class="fe ms mt mu mv b">self.account</code>变量将指向我们用作合同部署目标的账户。正如我们之前了解到的:智能合约不是部署在流网络上的全局名称空间中，而是部署在属于您的帐户的特殊链上存储中。因此，智能契约知道它被部署到哪个帐户，并可以在其方法中使用该信息。</p><p id="3565" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个例子中，我们使用帐户的save方法。在最后一个<code class="fe ms mt mu mv b">init</code>函数中，我们将资源移动到<code class="fe ms mt mu mv b">save</code>方法的第一个参数中，并告诉它帐户中的哪个路径应该存储我们的NFT。</p><p id="2bef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">既然我们的NFT是资源，那么流网上的任何实体都无法复制；我们不必明确地跟踪它的唯一性。</p><h1 id="b1e0" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">摘要</h1><p id="794e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Cadence是针对资产创建和管理而优化的智能合约编程语言的新版本。这是一种现代的替代方案，通过强制管理变量和资源、基础级别的安全和访问控制以及在智能合同变得不可改变之前升级智能合同的能力等手段，缓解了可靠性的不足。Cadence向您展示了流生态系统的可能性，并整合了Rust等语言的许多功能。</p><p id="26c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，如果您是一名开发人员，希望用一种更安全的语言编写智能合同，Cadence是一个很好的选择。要了解更多信息，请查看<a class="ae mk" href="https://docs.onflow.org/cadence/" rel="noopener ugc nofollow" target="_blank"> Cadence文档</a>和<a class="ae mk" href="https://developers.onflow.org/" rel="noopener ugc nofollow" target="_blank"> Flow开发者门户</a>。</p><p id="2164" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">祝您愉快！</p></div></div>    
</body>
</html>