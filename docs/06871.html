<html>
<head>
<title>Building Your Own Kubernetes Operator Easily</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">轻松构建自己的Kubernetes运营商</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-your-own-kubernetes-operator-easily-cab29ca51f96?source=collection_archive---------9-----------------------#2020-11-12">https://betterprogramming.pub/building-your-own-kubernetes-operator-easily-cab29ca51f96?source=collection_archive---------9-----------------------#2020-11-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c78a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这些讨厌的完成Kubernetes工作无处不在！让我们构建一个运算符来处理它们。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4582a4eb7bd1d6b1fec21d977fe32a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hVoIqwGjajzqumOS"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@hudsoncrafted?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">王思然·哈德森</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="7a7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一点永远不变:你总是要做一些批处理。Kubernetes通过使用<code class="fe lv lw lx ly b">Job</code>对象有自己的批处理风格。例如，创建计算圆周率前2000位小数的作业很容易:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="f8fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将它推到您的集群中，观察作业的生命周期。应该在大约10秒钟后完成:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="f411" class="mf mg it ly b gy mh mi l mj mk">$ kubectl create -f job.yaml<br/>$ kubectl get job pi</span><span id="8f71" class="mf mg it ly b gy ml mi l mj mk">NAME   COMPLETIONS   DURATION   AGE<br/>pi     1/1           10s         7s</span><span id="f576" class="mf mg it ly b gy ml mi l mj mk">$ kubectl get pod | grep -E "NAME|pi-"</span><span id="94be" class="mf mg it ly b gy ml mi l mj mk">NAME        READY   STATUS             RESTARTS   AGE<br/>pi-pdrbw    0/1     Completed          0          3m40s</span></pre><p id="f4dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您注意到该作业被标记为已完成。它还创建了一个pod来运行给定的容器——这个容器也已经完成，并且由于错误或其他原因还没有重新启动。</p><p id="01c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您运行许多作业，或者如果您运行<code class="fe lv lw lx ly b"><a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/" rel="noopener ugc nofollow" target="_blank">CronJob</a></code>，终止的作业数量将会迅速增加。一个好处是，作业历史允许您调查故障，或者让您的监控工具有时间报告这些错误。但是，另一方面，这些作业的绝对数量对Kubernetes API造成了压力，并使您的<code class="fe lv lw lx ly b">kubectl get</code>命令输出变得混乱。</p><p id="223f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能想删除已终止的职务。为此，删除作业，然后<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/#:~:text=Delete%20the%20job%20with%20kubectl,it%20created%20are%20deleted%20too." rel="noopener ugc nofollow" target="_blank">它会根据官方文档为您删除完成的pod</a>:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="29f2" class="mf mg it ly b gy mh mi l mj mk">$ kubectl delete job pi<br/>$ kubectl get pod pi-pdrbw</span><span id="2eca" class="mf mg it ly b gy ml mi l mj mk">&lt;nothing&gt;</span></pre><p id="d9f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，但如果它可以自动完成呢？</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="72d3" class="mt mg it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">清除终止的Kubernetes作业</h1><p id="5eb6" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">有几个选项可供选择:</p><ul class=""><li id="152c" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><strong class="lb iu">非最佳解决方案</strong>:从外部工具自动运行您刚刚输入的命令行，该工具将定期运行kubectl命令。</li><li id="da00" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><strong class="lb iu">合理的解决方案</strong>:简单地创建一个具有适当服务帐户权限的<code class="fe lv lw lx ly b">CronJob</code>来执行一个脚本，该脚本将清理终止的作业。</li><li id="2460" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><strong class="lb iu">最佳解决方案</strong>:在给定TTL后，使用<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/ttlafterfinished/" rel="noopener ugc nofollow" target="_blank"> TTL控制器</a>清理作业。</li></ul><p id="1144" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们安装TTL控制器吧！但是你很快就会意识到它仍然是它的alpha版本，隐藏在一个特性门的后面。你管理的Kubernetes最先进的云提供商集群<a class="ae ky" href="https://github.com/aws/containers-roadmap/issues/255" rel="noopener ugc nofollow" target="_blank">不允许你设置这些标志</a>，或者它允许但只在<a class="ae ky" href="http://managed Kubernetes cluster" rel="noopener ugc nofollow" target="_blank">阿尔法集群中设置，这些集群在30天后</a>会自动删除。</p><p id="01a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许我们可以开发自己的控制器来处理这个问题，而不是将我们的整个集群转移到一个由Kubespray管理的庞然大物上。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="53a8" class="mt mg it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">开发作业监视器控制器</h1><p id="8376" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我们将按照操作符模式来开发控制器。</p><h2 id="a02f" class="mf mg it bd mu od oe dn my of og dp nc li oh oi ne lm oj ok ng lq ol om ni on bi translated">接线员？</h2><p id="9d2b" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">操作符是一种特殊的Kubernetes控制器进程，它有自己的自定义资源定义——也就是说，是一个Kubernetes对象。这些CRD又允许您扩展Kubernetes API的功能。你可以在<a class="ae ky" href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/" rel="noopener ugc nofollow" target="_blank">官方文档</a>中了解更多。</p><p id="c36e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用<a class="ae ky" href="https://github.com/operator-framework/operator-sdk" rel="noopener ugc nofollow" target="_blank">操作符SDK </a>，而不是自己编写所有代码。它本质上是一个代码生成器，用来构建一个全功能的操作符。</p><p id="edec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将<a class="ae ky" href="https://sdk.operatorframework.io/docs/installation/install-operator-sdk/" rel="noopener ugc nofollow" target="_blank">安装SDK </a>并运行一些命令来引导项目。</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="4a89" class="mf mg it ly b gy mh mi l mj mk">brew install operator-sdk</span><span id="efa9" class="mf mg it ly b gy ml mi l mj mk">operator-sdk init job-purger --domain my.github.com --repo github.com/xxx/job-watcher-operator</span><span id="f9a9" class="mf mg it ly b gy ml mi l mj mk">operator-sdk create api --group batch --kind JobWatcher --version v1 --resource true --controller true</span></pre><h2 id="bc11" class="mf mg it bd mu od oe dn my of og dp nc li oh oi ne lm oj ok ng lq ol om ni on bi translated">创造你的CRD</h2><p id="1715" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">现在，您应该已经创建了一个完整的项目。我们先来看看<code class="fe lv lw lx ly b">api/v1/jobwatch_types.go</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="f1f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们定义了CRD及其规格和状态信息:</p><ul class=""><li id="ee31" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">用于已完成或失败作业的单独TTL，在此之后作业将被删除。</li><li id="2788" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">一些命名空间和作业名模式(regex ),用于识别可能要删除的作业。</li><li id="d923" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">两次删除检查之间的延迟。</li></ul><p id="533d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">状态信息将是上次开始和结束的时间。注意，默认情况下，我们的操作符不是并发运行的。</p><p id="d8a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<code class="fe lv lw lx ly b">//+kubebuilder</code>这样的特殊注释会为我们生成约束代码。</p><h2 id="be5d" class="mf mg it bd mu od oe dn my of og dp nc li oh oi ne lm oj ok ng lq ol om ni on bi translated">实施协调循环</h2><p id="0df8" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><em class="oo">你可以在这里</em>  <em class="oo">找到</em> <a class="ae ky" href="https://gist.github.com/esys/e9214229d175c265f37913e19def5dcc" rel="noopener ugc nofollow" target="_blank"> <em class="oo">完整的控制器代码。</em></a></p><p id="6e85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们转到实现代码。主要逻辑在对账循环中。它将接收一个<code class="fe lv lw lx ly b">Request</code>作为参数，其中只包含资源的名称空间和名称。</p><p id="57bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法将被调用用于你的操作者关心的每一个对象，当然，从我们的自定义<code class="fe lv lw lx ly b">JobWatcher</code> CRD开始。此外，生成的操作符自带一个记录器和一个Kubernetes客户端来操作对象。</p><p id="2c74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现的逻辑很简单:</p><ol class=""><li id="8773" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu op nv nw nx bi translated">首先，我们将获取与<code class="fe lv lw lx ly b">Request</code>匹配的<code class="fe lv lw lx ly b">JobWatcher</code>对象。</li><li id="9c72" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu op nv nw nx bi translated">然后，我们将列出并保留与我们的名称空间模式之一相匹配的名称空间。</li><li id="a99a" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu op nv nw nx bi translated">接下来，我们将识别具有匹配名称的作业，如果作业终止且TTL过期，我们将删除它。</li><li id="d019" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu op nv nw nx bi translated">最后，我们将更新CRD的状态信息。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h2 id="2302" class="mf mg it bd mu od oe dn my of og dp nc li oh oi ne lm oj ok ng lq ol om ni on bi translated">讨论</h2><p id="41b7" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">当您的一个CRD改变或者返回的<code class="fe lv lw lx ly b">ctrl.Result</code>不为空(或者返回一个错误)时，就会调用<code class="fe lv lw lx ly b">Reconcile</code>。我们利用这种行为，以CRD规范中给定的频率重新调度对<code class="fe lv lw lx ly b">Reconcile</code>函数的调用。</p><p id="3d6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您指定了生成器注释:<code class="fe lv lw lx ly b">//+kubebuilder:rbac:groups:resources:verbs</code>，那么集群角色和绑定会自动创建。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="d8b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">SetupWithManager</code>方法中，我们表示操作员正在通过<code class="fe lv lw lx ly b">For</code>方法管理<code class="fe lv lw lx ly b">JobWatcher</code> CRD。其他方法允许您收到其他对象的通知:</p><ul class=""><li id="b717" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">Owns()</code>对于您正在创建的子对象。</li><li id="617a" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">Watches()</code>对于集群中的任何对象。</li></ul><p id="62b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您添加了<code class="fe lv lw lx ly b">Owns(&amp;kbatch.Job{})</code>，那么您的协调循环将为每个创建、删除或修改的作业调用，并且您的CRD作为其<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/garbage-collection/#owners-and-dependents" rel="noopener ugc nofollow" target="_blank">所有者</a>。<code class="fe lv lw lx ly b">Reconcile</code>方法的输入<code class="fe lv lw lx ly b">Request</code>参数将是作业的所有者实例。当然，这里我们不是在创造就业机会，所以这只是为了举例。</p><p id="a659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与我们更相关的是，如果您在构建器中为<code class="fe lv lw lx ly b">Job</code>类添加一个对<code class="fe lv lw lx ly b">Watches</code>方法的调用，那么集群中作业的每个变化都会通知您。您可以(也应该)通过设置适当的选项来过滤您感兴趣的事件。</p><p id="37ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，不要忘记在循环结束时更新CRD的状态。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="9068" class="mt mg it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">构建和部署操作符</h1><p id="442e" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">Makefile提供了生成清单、构建Go应用程序、将Docker映像推送到您选择的注册表以及打包应用程序所需的一切。</p><p id="d6ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://codeburst.io/creating-a-local-development-kubernetes-cluster-with-k3s-and-traefik-proxy-7a5033cb1c2d" rel="noopener" target="_blank">准备好测试Kubernetes集群</a>并配置好您的kubectl。安装目标将生成清单，并使用Kustomize将它们部署到您的集群:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="2f61" class="mf mg it ly b gy mh mi l mj mk">make install</span></pre><p id="836c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">清单现在位于<code class="fe lv lw lx ly b">config</code>文件夹下，包含所有Kustomize补丁。</p><p id="e4a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，出于开发目的，您可以直接在集群之外运行您的操作符二进制文件。它将使用您的kubectl配置与您的集群通信。</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="6f8a" class="mf mg it ly b gy mh mi l mj mk">$ make run </span><span id="b9f9" class="mf mg it ly b gy ml mi l mj mk">2020-11-09T20:56:08.279+0100    INFO    controller-runtime.metrics      metrics server is starting to listen    {"addr": ":8080"}<br/>2020-11-09T20:56:08.281+0100    INFO    setup   starting manager<br/>2020-11-09T20:56:08.281+0100    INFO    controller-runtime.manager      starting metrics server {"path": "/metrics"}<br/>2020-11-09T20:56:08.281+0100    INFO    controller-runtime.controller   Starting EventSource    {"controller": "jobwatcher", "source": "kind source: /, Kind="}<br/>2020-11-09T20:56:08.382+0100    INFO    controller-runtime.controller   Starting Controller     {"controller": "jobwatcher"}<br/>2020-11-09T20:56:08.382+0100    INFO    controller-runtime.controller   Starting workers        {"controller": "jobwatcher", "worker count": 1}</span></pre><p id="6e23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现实部署的替代方案是将控制器打包成Docker映像(运行<code class="fe lv lw lx ly b">make docker-build docker-push</code>)并用<code class="fe lv lw lx ly b">make deploy</code>生成一个<code class="fe lv lw lx ly b">Deployment</code>对象。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="ba9a" class="mt mg it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">测试操作员</h1><p id="06ee" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">为了进行测试，我们将首先创建CRD的一个实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="65cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和一个测试任务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="a525" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应用两种资源:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="bc1a" class="mf mg it ly b gy mh mi l mj mk">$ kubectl apply -f jobwatcher-sample.yaml</span><span id="33d9" class="mf mg it ly b gy ml mi l mj mk">jobwatcher.batch.my.github.com/jobwatcher-sample created</span><span id="d580" class="mf mg it ly b gy ml mi l mj mk">$ kubectl apply -f job.yaml</span><span id="7769" class="mf mg it ly b gy ml mi l mj mk">job.batch/pi created</span><span id="288c" class="mf mg it ly b gy ml mi l mj mk"># after a few seconds, but before TTL expired</span><span id="3403" class="mf mg it ly b gy ml mi l mj mk">$ kubectl get job pi   <br/>NAME   COMPLETIONS   DURATION   AGE<br/>pi     1/1           6s         15s</span></pre><p id="a9d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您查看一下控制器日志，应该会看到在TTL结束后，作业被删除了。</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="203b" class="mf mg it ly b gy mh mi l mj mk">2020-11-12T08:23:55.056+0100    INFO    controllers.JobWatcher  deleted terminated job  {"JobWatcher": "default/jobwatcher-sample", "Job": "default/pi", "Finished": "2020-11-12T08:23:40.000+0100", "Elapsed": "15.043938698s"}</span></pre><p id="9850" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以确认作业已被删除:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="21a3" class="mf mg it ly b gy mh mi l mj mk">kubectl get job pi</span><span id="d8c0" class="mf mg it ly b gy ml mi l mj mk">&lt;nothing&gt;</span></pre></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="882f" class="mt mg it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">不完全适合生产</h1><p id="9e1c" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">作为一个例子，这个操作符已经构建得足够好了，但是它肯定不能用于生产。</p><h2 id="812b" class="mf mg it bd mu od oe dn my of og dp nc li oh oi ne lm oj ok ng lq ol om ni on bi translated">调整日志级别</h2><p id="5ebd" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">首先，您需要调整日志级别。由于logger实现是Zap，您应该向命令行公开logger标志。修改<code class="fe lv lw lx ly b">main.go</code>文件，添加<code class="fe lv lw lx ly b">BindFlags</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="4b75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以使用更适合生产的设置运行:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="f821" class="mf mg it ly b gy mh mi l mj mk">make run ARGS="--zap-devel=false --zap-log-level=warn"</span></pre><p id="6a1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想在集群中将控制器部署为容器时保留任何标志，请编辑<code class="fe lv lw lx ly b">config/default/manager_auth_proxy_patch.yaml</code>。</p><h2 id="f0b7" class="mf mg it bd mu od oe dn my of og dp nc li oh oi ne lm oj ok ng lq ol om ni on bi translated">添加网页挂钩</h2><p id="99b8" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">您可能想添加一个<a class="ae ky" href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/" rel="noopener ugc nofollow" target="_blank"> admission webhook </a>来检查您的CRD——例如，验证所使用的job-name模式是否是格式良好的正则表达式。</p><p id="d8fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SDK操作符通过创建服务器和注册钩子使得部署webhook变得容易。更多详情<a class="ae ky" href="https://book.kubebuilder.io/cronjob-tutorial/webhook-implementation.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><h2 id="20e5" class="mf mg it bd mu od oe dn my of og dp nc li oh oi ne lm oj ok ng lq ol om ni on bi translated">查看代码逻辑</h2><p id="48c6" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">例如，如果您的集群中有这个CRD的多个实例，会发生什么情况？由于每个CRD的范围显然是全局的，您可能希望合并它们的配置。</p><p id="a401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有很多名称空间和作业或者TTL很低会怎么样？这个控制器会变慢，并进行大量的kube API调用。</p><p id="d8d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于所有这些原因，尽管它适用于中小型集群，但是您不应该在大型集群中运行它。更好的编码方式是:</p><ul class=""><li id="55f0" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">让<code class="fe lv lw lx ly b">JobWatcher</code> CRD只处理它所在的名称空间中的作业。</li><li id="28e3" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">如果在一个名称空间中创建了多个<code class="fe lv lw lx ly b">JobWatcher</code>，那么在控制器全局范围内合并它们的配置。</li><li id="8072" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">此外，您应该配置您的操作员来观察<code class="fe lv lw lx ly b">Job</code>上的更新事件，而不是每隔TTL秒触发一次协调循环。这样，您将避免对API的不必要调用。</li></ul></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="c9d2" class="mt mg it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">结论</h1><p id="2eec" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">如果您很好奇，看一眼生成的代码量，您会意识到即使编写一个简单的操作符也不是一件容易的事情。通过为您处理底层问题，运营商SDK在抽象这种复杂性方面做得非常好。</p></div></div>    
</body>
</html>