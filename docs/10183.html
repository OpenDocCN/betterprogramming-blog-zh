<html>
<head>
<title>How and Why You Should Store React UI State in the URL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何以及为什么应该在URL中存储React UI状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-and-why-you-should-store-react-ui-state-in-the-url-f2013a204cb2?source=collection_archive---------0-----------------------#2021-12-09">https://betterprogramming.pub/how-and-why-you-should-store-react-ui-state-in-the-url-f2013a204cb2?source=collection_archive---------0-----------------------#2021-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5669" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React中的深度链接，就像useState一样简单</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9174d219a1dc104f75b10bc4b8f9b6c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sziKHspzSQXVx5U4DQm2rQ@2x.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片。</p></figure><p id="1459" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你曾经使用过一个复杂的web应用程序，它有许多功能、模态窗口或侧面板吗？在不同的屏幕上点击几次后，你达到了屏幕上只有正确信息的完美状态，但随后你不小心关闭了标签。(还是Windows决定更新？)</p><p id="703d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果有一种方法可以回到这种状态，而不用经历同样繁琐的过程，那就太好了。或者能够分享这种状态，这样队友就可以和你做同样的事情。</p><p id="c188" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个问题可以通过深度链接来解决，深度链接目前在移动应用程序中用于打开应用程序到特定的页面或UI状态。但是为什么很多web apps都没有这个呢？</p><p id="b748" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="#694f" rel="noopener ugc nofollow">点击这里跳到解决方案和代码片段。</a></p><h1 id="bdec" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">带回网络上的深层链接</h1><p id="c1d1" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">单页应用程序(SPAs)的出现使我们能够创造新的用户体验，在网络上即时互动。通过在客户端使用JavaScript做更多的事情，我们可以立即响应用户事件，从打开定制的对话窗口到像Google Docs这样的实时文本编辑器。</p><p id="d706" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">传统的服务器渲染网站每次都会发送一个请求来获取一个新的HTML页面。一个很好的例子是Google，它用URL: <code class="fe mp mq mr ms b"><a class="ae lr" href="https://www.google.com/search?q=your+query+here" rel="noopener ugc nofollow" target="_blank">https://www.google.com/search?<strong class="kx ir">q=your+query+here</strong></a></code>中的用户搜索查询向其服务器发送请求。这个模型的伟大之处在于，如果我通过过去一周的结果进行过滤，我可以通过简单地共享URL来共享同一个搜索查询:<code class="fe mp mq mr ms b"><a class="ae lr" href="https://www.google.com/search?q=react+js&amp;tbs=qdr:w" rel="noopener ugc nofollow" target="_blank">https://www.google.com/search?q=react+js&amp;<strong class="kx ir">tbs=qdr:w</strong></a></code>。这种模式对网络用户来说是完全自然的——自从它被发明以来，共享链接已经成为万维网的一部分！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/2c188c400c232468e25c79abb6fee443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BQq9yGZ_9RxrNsM4Youg3g@2x.png"/></div></div></figure><p id="c228" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当SPAs出现时，我们不需要在URL中存储这些数据，因为我们不再需要向服务器请求改变屏幕上显示的内容(因此有了<em class="mu">单页</em>)。但是这很容易失去一个独特的网络体验，一个可共享的链接。</p><p id="b83b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">桌面和移动应用从来没有真正的标准化方法来链接到应用的特定部分，深度链接的现代实现依赖于网络上的URL。那么，当我们构建功能更像本地应用的网络应用时，我们为什么要抛弃已经使用了几十年的URL深层链接功能呢？</p><h1 id="22fc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">非常简单的深度链接</h1><p id="67bc" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">当构建一个有多个页面的web应用程序时，你最起码应该做的是在显示不同页面时改变URL，比如<code class="fe mp mq mr ms b">/login</code>和<code class="fe mp mq mr ms b">/home</code>。在React生态系统中，<a class="ae lr" href="https://reactrouter.com/" rel="noopener ugc nofollow" target="_blank"> React路由器</a>非常适合这样的客户端路由，<a class="ae lr" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>是一个优秀的全功能React框架，也支持服务器端渲染。</p><p id="df38" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是我说的是深度链接，只需点击几下鼠标和键盘输入就能进入UI状态。对于注重效率的web应用程序来说，这是一个杀手级的功能，因为它允许用户在关闭应用程序或与其他人共享应用程序之后，立即返回到他们所在的位置，这样他们就可以毫无摩擦地开始工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/c956e98772ea97011757a298829c017e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*trWHeF3QtAypmyogD7lgLQ@2x.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">请注意，当模式打开时，URL如何更新以添加#modal="webhooks"。</p></figure><p id="49a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以使用npm包，如<a class="ae lr" href="https://www.npmjs.com/package/query-string" rel="noopener ugc nofollow" target="_blank"> query-string </a>并编写一个基本的React Hook来同步URL查询参数到您的状态，并且有很多<a class="ae lr" href="https://medium.com/swlh/using-react-hooks-to-sync-your-component-state-with-the-url-query-string-81ccdfcb174f" rel="noopener">的</a><a class="ae lr" href="https://www.npmjs.com/package/use-query-params" rel="noopener ugc nofollow" target="_blank">教程</a>针对<a class="ae lr" href="https://dev.to/gaels/an-alternative-to-handle-global-state-in-react-the-url--3753" rel="noopener ugc nofollow" target="_blank">这个</a>，但是有一个更直接的解决方案。</p><p id="68f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在探索React的现代状态管理库以重写React应用程序<a class="ae lr" href="https://rowy.io/?utm_source=medium.com&amp;utm_medium=blog&amp;utm_campaign=How%20and%20why%20you%20should%20store%20React%20UI%20state%20in%20the%20URL" rel="noopener ugc nofollow" target="_blank"> Rowy </a>的架构时，我遇到了<a class="ae lr" href="https://jotai.org/" rel="noopener ugc nofollow" target="_blank"> Jotai </a>，这是一个基于原子的微型状态库，灵感来自React团队的<a class="ae lr" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>库。</p><p id="ed50" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种模型的主要好处是状态原子被声明为独立于组件层次结构，并且可以在应用程序的任何地方操作。这解决了React上下文导致不必要的重新渲染的问题，我之前用 <code class="fe mp mq mr ms b"><a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/how-to-useref-to-fix-react-performance-issues-4d92a8120c09">useRef</a></code>解决了这个问题。你可以在Jotai的文档中读到更多关于原子状态的概念，在反冲的文档中可以读到更技术性的版本。</p><h1 id="694f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">代码</h1><p id="5fca" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">Jotai有一种叫做<code class="fe mp mq mr ms b"><a class="ae lr" href="https://jotai.org/docs/api/utils#atom-with-hash" rel="noopener ugc nofollow" target="_blank">atomWithHash</a></code>的原子，它将状态原子同步到URL散列。</p><p id="8b84" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设我们希望一个模态的打开状态存储在URL中。让我们从创建一个原子开始:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c6f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后在模态分量本身，我们可以像<code class="fe mp mq mr ms b">useState</code>一样使用这个原子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ce65" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是它的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/fccd65043c676ecc871c01fe775a455c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*eDQ6gdfnKnk4JmuMKdLKNg@2x.gif"/></div></div></figure><p id="abcc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样！就这么简单。</p><p id="27b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Jotai的<code class="fe mp mq mr ms b">atomWithHash</code>的奇妙之处在于，它可以存储<code class="fe mp mq mr ms b">useState</code>可以存储的任何数据，并且它自动对要存储在URL中的对象进行字符串化。所以我可以在URL中存储一个更复杂的状态，使它可以共享。</p><p id="2e83" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<a class="ae lr" href="https://rowy.io/?utm_source=medium.com&amp;utm_medium=blog&amp;utm_campaign=How%20and%20why%20you%20should%20store%20React%20UI%20state%20in%20the%20URL" rel="noopener ugc nofollow" target="_blank"> Rowy </a>中，我们使用这种技术为云日志实现了一个UI。我们正在建立一个开源平台，使后端开发更容易，并消除常见工作流的摩擦。因此，减少共享日志的摩擦对我们来说是完美的。您可以在我们的演示中看到这一点，我可以将您链接到一个特定的部署日志:</p><pre class="kg kh ki kj gt my ms mz na aw nb bi"><span id="0da4" class="nc lt iq ms b gy nd ne l nf ng"><a class="ae lr" href="https://demo.rowy.io/table/roadmap#modal=%22cloudLogs%22&amp;cloudLogFilters=%7B%22type%22%3A%22build%22%2C%22timeRange%22%3A%7B%22type%22%3A%22days%22%2C%22value%22%3A7%7D%2C%22buildLogExpanded%22%3A1" rel="noopener ugc nofollow" target="_blank">https://demo.rowy.io/table/roadmap#modal="cloudLogs"&amp;cloudLogFilters={"type"%3A"build"%2C"timeRange"%3A{"type"%3A"days"%2C"value"%3A7}%2C"buildLogExpanded"%3A1</a>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/e30c14bc0a9d941318b6d3b94f994c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ojst8ZL97umsmUpD2dbILQ@2x.gif"/></div></div></figure><p id="e55f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">解码URL组件揭示了React中使用的确切状态:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1a28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mp mq mr ms b">atomWithHash</code>的一个副作用是，它默认将状态推送到浏览器历史，这样用户可以点击后退和前进按钮在UI状态之间切换。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/0f042dfcdbe0ed908749c2160c9055e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8m0sxOyuwQcjztYxlR3Nmw@2x.gif"/></div></div></figure><p id="1a62" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该行为是可选的，可使用<code class="fe mp mq mr ms b"><a class="ae lr" href="https://jotai.org/docs/api/utils#atom-with-hash" rel="noopener ugc nofollow" target="_blank">replaceState</a></code> <a class="ae lr" href="https://jotai.org/docs/api/utils#atom-with-hash" rel="noopener ugc nofollow" target="_blank">选项</a>禁用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="b101" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读！我希望这已经说服你在URL中暴露更多的UI状态，使其易于共享并减少用户的摩擦——特别是因为它实现起来毫不费力。</p><pre class="kg kh ki kj gt my ms mz na aw nb bi"><span id="f26e" class="nc lt iq ms b gy nd ne l nf ng"><strong class="ms ir">Want to Connect With the Author?</strong></span><span id="f055" class="nc lt iq ms b gy np ne l nf ng">You can follow me on Twitter <a class="ae lr" href="https://twitter.com/nots_dney" rel="noopener ugc nofollow" target="_blank">@nots_dney</a> for more articles and Tweet threads about front-end engineering.</span></pre></div></div>    
</body>
</html>