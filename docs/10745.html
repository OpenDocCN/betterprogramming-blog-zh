<html>
<head>
<title>Speed Up Your Python Code With 100% Thread Utilization Using This Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用这个库，以100%的线程利用率加速您的Python代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/speed-up-your-python-code-with-100-thread-utilization-using-this-library-31378a45f0ec?source=collection_archive---------10-----------------------#2022-01-25">https://betterprogramming.pub/speed-up-your-python-code-with-100-thread-utilization-using-this-library-31378a45f0ec?source=collection_archive---------10-----------------------#2022-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9935" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">FastAPI带来惊人的单线程性能—优化您的代码，大幅提升性能！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/464b776453b952dadc7105b16e308c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oZRuzTJK7hDpZ_-E"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@verneho?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Verne Ho </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="36ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python有许多web框架，最流行的是Django和Flask。<br/>我自己最熟悉Flask，并广泛使用它来构建爱好项目和提高我的编程技能。</p><p id="9846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，就像科技领域的所有事物一样，新的框架也在不断地被开发。作为一名程序员，了解最新最棒的东西是很重要的。</p><p id="5a39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">FastAPI是一个用于Python的web框架，在许多方面类似于Flask的简单性。FastAPI的不同之处在于，它运行在ASGI web服务器上(比如uvicorn)，而Flask只运行在WSGI web服务器上。这种差异会导致巨大的性能差距。</p><p id="37eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ASGI是Python中的一个新兴趋势，所以了解它是很重要的。使用FastAPI和ASGI，开发高性能Python应用程序变得非常容易。我们将看到如何在FastAPI中开发一个简单的API，然后我们将它与Flask进行比较，看它到底快了多少。</p><p id="d1e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始吧！</p><p id="6b24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，快速介绍一下WSGI和ASGI。</p><h1 id="cf38" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">WSGI与ASGI</h1><p id="69b3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">WSGI代表<strong class="lb iu"> Web服务器网关接口</strong>。简单地说，这个软件位于web服务器(比如nginx)和Python web框架(比如Flask)之间。它指定了web服务器应该如何将请求转发到web框架。WSGI于2003年首次发布，所以你可以想象它有多古老。WSGI本质上是同步的。这可能会导致执行缓慢。</p><p id="1a7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ASGI代表<strong class="lb iu">异步服务器网关接口</strong>。ASGI是将取代WSGI的新兴趋势。关键的区别在于ASGI支持带有异步代码的web框架。也就是说，它本质上是异步的。如果你的代码是异步的(例如，如果它使用<code class="fe ms mt mu mv b"><strong class="lb iu">async await</strong></code>)，这可以加速执行</p><p id="afba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迷茫？别担心。这里有一个简短的例子来强调同步和异步执行之间的区别。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/43effc964398629dcce0fb0be7a7f1ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*s2OdGt1kp2_3FNVR.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">同步与异步执行。请注意异步节省了大量时间。</p></figure><p id="b53d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，在同步执行(WSGI)中，一个线程一次只能处理一个请求。因此，如果当前请求有一些阻塞代码，需要等待一些结果，就会浪费大量时间(正如上图中的等待块所示)。<br/>只有当整个<strong class="lb iu">任务A </strong>完成后，线程才能移动到<strong class="lb iu">任务B </strong>。</p><p id="ca97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，在异步执行(ASGI)中，一个线程可以处理多个请求。当执行在<strong class="lb iu">任务A </strong>上等待时，线程可以跳到<strong class="lb iu">任务B </strong>上，并在<strong class="lb iu">任务A </strong>返回所需的时间内完成它。然后线程跳回到任务A 并完成它。从上面的图表中，我们看到，通过异步执行，我们以这种方式节省了大量时间。更重要的是，通过异步执行，我们100%地利用了线程，这意味着<strong class="lb iu"> <em class="mx">更少的等待和更多的工作</em> </strong>。这使得某些应用程序的性能得到了巨大的提升。</p><p id="cf4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之:使用异步代码，线程可以在相同的时间内做更多的工作。这导致单位时间内完成更多的工作。这就是性能提升的来源。</p><h1 id="6873" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">标杆管理</h1><p id="5ab9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">理论很好，但更有趣的是看到一个真实的例子来说明性能差异。</p><p id="0563" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先为FastAPI安装以下库:</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="d794" class="nc lw it mv b gy nd ne l nf ng">pip3 install fastapi[all]</span></pre><p id="3a20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们对FastAPI使用以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="ceed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有两个端点:根端点<code class="fe ms mt mu mv b"><strong class="lb iu"><em class="mx">/</em></strong></code>和第二个端点<code class="fe ms mt mu mv b">dummy</code>。<br/>根端点执行一些繁重的工作，我们通过将计时器设置为20秒来模拟这些工作。</p><p id="a99f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将端点本身定义为<code class="fe ms mt mu mv b">async</code>，并使用<code class="fe ms mt mu mv b">await</code>关键字来表示线程可以在这个调用结束返回时去做其他工作。我们也使用<code class="fe ms mt mu mv b">asyncio</code>的睡眠功能，因为它支持<code class="fe ms mt mu mv b">async</code>和<code class="fe ms mt mu mv b">await</code>。<code class="fe ms mt mu mv b">dummy</code>端点只是返回一条消息。</p><p id="e48a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，在FastAPI中定义API非常简单。我们只需要初始化一个FastAPI应用程序，并用<code class="fe ms mt mu mv b">@app</code>符号定义端点。</p><p id="1cb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码用于Flask:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2cca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码与FastAPI的代码相同。</p><p id="61fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个想法是，我们调用根端点，当它等待20秒时，我们调用<code class="fe ms mt mu mv b">dummy</code>端点。</p><p id="70c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是关键点:如果接口是异步的(ASGI)，对<code class="fe ms mt mu mv b">dummy</code>的调用应该立即返回。</p><p id="1a02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mx">注意:我们在Flask中将</em> <code class="fe ms mt mu mv b"><em class="mx">threaded</em></code> <em class="mx">标志设置为false，因为我们只想测试单线程性能以供学习之用。对于多线程应用来说，关键的要点仍然应该是相同的。</em></p><p id="5c9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用以下命令启动FastAPI服务器:</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="99e0" class="nc lw it mv b gy nd ne l nf ng">uvicorn tfastapi:app --reload</span></pre><p id="fff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在控制台中检查它在哪个端口上运行。默认为端口<code class="fe ms mt mu mv b">8000</code>。</p><p id="05ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，打开两个终端窗口。(我在Windows上使用PowerShell，也可以使用Git Bash或Linux或macOS终端)</p><p id="39f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一个粘贴卷曲命令:</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="26a3" class="nc lw it mv b gy nd ne l nf ng">curl <a class="ae ky" href="http://localhost:8000" rel="noopener ugc nofollow" target="_blank">http://localhost:8000</a></span></pre><p id="2e2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二个例子中，粘贴下面的curl命令来点击<code class="fe ms mt mu mv b">dummy</code>端点:</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="3fd5" class="nc lw it mv b gy nd ne l nf ng">curl <a class="ae ky" href="http://localhost:8000/dummy" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/dummy</a></span></pre><p id="9abb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按下第一个窗口上的<code class="fe ms mt mu mv b">Enter</code>，然后按下第二个窗口。<br/>您应该注意到对<code class="fe ms mt mu mv b">dummy</code>的请求几乎立即返回:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/e4d1e245c55f35a5d54bb2a17e5f1723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dn-fLnKEE6QKBmEG.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">FastAPI中异步端点的立即返回</p></figure><p id="91e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您等待20秒，对root的调用应该会返回。</p><p id="2427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生了什么事？线程首先处理对根的调用。在等待睡眠功能时，调用<code class="fe ms mt mu mv b">dummy/</code> <strong class="lb iu"> <em class="mx"> </em> </strong>端点。然后线程跳转来处理请求。一旦它被处理，线程返回处理根请求。</p><p id="2d2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看Flask的情况。</p><p id="d33b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用以下命令运行Flask服务器:</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="b395" class="nc lw it mv b gy nd ne l nf ng">py tflask.py</span></pre><p id="dd2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它应该在端口<code class="fe ms mt mu mv b">5000</code>上运行。</p><p id="75b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，像以前一样将curl请求复制并粘贴到root，然后将curl请求复制并粘贴到<code class="fe ms mt mu mv b">dummy</code>。<br/>首先运行根请求，然后运行另一个请求。</p><p id="8b78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会注意到，对<code class="fe ms mt mu mv b">dummy/</code> <strong class="lb iu"> </strong>的呼叫不会立即返回！两个请求返回都需要20秒。这里发生了什么事？</p><p id="aca8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管代码是异步的，但是Flask使用了服务器框架接口的WSGI实现。这意味着Flask中的端点不是真正异步的。我们向root用户发出请求，它会等待。当我们向线程<em class="mx">发出第二个请求时，线程</em>不会跳转来处理这个请求。它会等待对根的请求被处理。换句话说，代码会等待20秒钟，然后再做其他事情。在这段时间内，线程除了等待之外什么也不做！如此低效！</p><h1 id="04ce" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="911c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这篇文章中，我们回顾了同步和异步代码。我们还学习了WSGI和ASGI接口实现。</p><p id="61b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们了解了FastAPI如何帮助实现100%的线程利用率，并显著提高缓慢代码的速度。</p><p id="68dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要利用FastAPI，您需要做的就是在每个端点前使用<code class="fe ms mt mu mv b">async</code>，并确保您的代码是异步的。实际上，我想进一步阐述这最后一点，并发表一些一般性意见:</p><ul class=""><li id="ac78" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">ASGI仍然很新，所以可能很难找到它的文档。与WSGI相比，它也较少被测试。</li><li id="1572" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">如果你想获得性能提升，你的代码需要是异步的。并非所有的图书馆都支持这一点。例如，Python的某些数据库库只有同步实现。在这种情况下，您可能不会获得太多的性能提升。</li><li id="375e" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">最后，FastAPI支持类型提示，并且与Pydantic集成得很好。你可以查看我的帖子<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/writing-robust-and-error-free-python-code-using-pydantic-151a135a9ff0">这里</a>了解更多。</li></ul><p id="7faa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="0f58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mx">原载于</em>【https://haseebkamal.com】<em class="mx"/></p></div></div>    
</body>
</html>