# 编码面试问题:将罗马数字转换成小数

> 原文：<https://betterprogramming.pub/coding-interview-question-convert-roman-numerals-to-decimals-868b2694f497>

## 掌握这个简单但令人生畏的算法

![](img/52d9e03050329a0e1ca5590c6e6d7579.png)

Thomas Bormans 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片。

我一次又一次地看到这个问题。因为罗马数字系统包含一个类似于计数的、有时是无序的布局，所以当被要求以编程方式将罗马数字转换成十进制(以 10 为基数)时，无数的软件工程师被吓住了。

说来有趣，在编码面试中，我已经接受过无数次这个任务，直到第三次或第四次遇到时，我才自信地给出了一个 ace 回答。

尽管这个问题并不复杂，但风险很高。这通常是热身，后面会有更难的问题。因此，重要的是你不要马上犯错，而是要用你的分析和技术技巧让面试官惊叹。

如果你想找一份软件工程的工作，你会在某个时候看到这一点——这是有保证的。但是不要担心，我会带你通过一系列的步骤来解决这个问题。

# 基础和方法

花些时间向你的面试官展示你真正理解了问题的本质。你必须解释罗马数字是如何运作的——尤其是加法和减法如何在每个数字中共存。

记住，罗马人曾经使用的基本数字——而不是数字——有计数值:`I: 1`、`V: 5`、`X: 10`、`L: 50`、`C: 100`、`D: 500`、`M: 1000`等等。

然后，用基本术语解释将罗马数字转换成十进制数字的过程。如果你不知道，这个过程如下:

1.  从左到右遍历罗马数字字符串，一次检查两个相邻的字符。如果你真的想要，指定迭代的方向无关紧要，只要比较(下一步)被相应地实现。
2.  如果左边的字符比右边的字符排名(计数值)高，则从最终总和中减去该位置的计数值。否则，添加它。
3.  字符串遍历完成后，最终的和表示数字的现代对应值。

我甚至建议用白板演示一个转换的例子。例如，演示`CMXCVIII`如何产生值为 998 的表达式`-100 + 1000 — 10 + 100 + 5 + 1 + 1 + 1`。

建立理解的基础对你的成功至关重要。通常，如果你走错了路，你的面试官甚至会纠正你。没有什么比你没有先调查手头的问题就一头扎进编码中更让你的面试官讨厌的了。

# 代码

还记得算法的解释吗？是时候把它翻译成计算机能理解的了。

首先，使用给定的值为地图中的每个数字定义与每个数字相关联的计数:

您还需要跟踪数字的持续总和，从零开始:

```
sum = 0
```

现在，遍历数字字符串并提取当前的数字对。确保迭代到倒数第二个数字，以防止越界异常:

```
for i in range(len(romanNumeral) - 1):
    left = romanNumeral[i]
    right = romanNumeral[i + 1]
```

进行关键比较，并相应地增加/减少`sum`:

```
 if tallies[left] < tallies[right]:
        sum -= tallies[left]
    else:
        sum += tallies[left]
```

注意，一旦退出`for`循环，最右边的数字就不会被计算。我们将通过在`for`循环后立即更新总和来说明这一点。因为它的右边没有数字，所以在这种情况下加法是唯一的可能:

```
sum += tallies[romanNumeral[-1]]
```

差不多就是这样！只需将代码包装在一个可调用的函数中，返回`sum`，代码就可以针对测试用例运行了。在我们的实现中，`“”`(空字符串)作为输入的边缘情况仍然提供了`0`的适当输出:

# 理论和分析

你大概能猜到接下来会发生什么:你的面试官会问:“有什么大不了的？”

由于`romanNumeral`字符串中的每个字符必须被遍历两次，该算法表现出最好情况、一般情况和最坏情况的时间复杂度为`O(n)`或*线性时间*。这由算法的单个`for`循环支持。

你的面试官可能还会问空间复杂度或者内存使用如何随着输入大小而增长。我们的函数只使用内存来实例化和更新变量`sum`、`i`、`left`和`right`。不管`romanNumeral`的长度如何，所有这些变量都有一个固定大小的实例。因此，算法的空间复杂度为*常数*或`O(1)`。

由于这个解决方案是最优的，你可以通过解释为什么它是最优的以及什么使其他方法不如它来进一步展示你的技能。首先，这个解决方案将每个字符分别作为左数字和右数字处理一次。实现更有效的工作解决方案是不可能的。此外，我们设法用单个循环来构建函数，而具有多个嵌套循环的解决方案被超过*线性时间*的时间复杂度所阻碍。从风格上来说，代码是可读的，有组织的，易于理解的。指出这一点没有坏处，因为另一方希望确保您理解现实世界的最佳实践。

我们的 Python 实现在原样形式下比提交给 [LeetCode 的评估](https://leetcode.com/problems/roman-to-integer/)的 92.08%更快，内存使用率低于所有提交的 72.29%。我鼓励你做出更多的改进，并尝试通过自己的努力提高这些百分点。

[](https://leetcode.com/problems/roman-to-integer/) [## 罗马到整数- LeetCode

### 符号值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如，2 在罗马数字中写成 II，只是两个一的…

leetcode.com](https://leetcode.com/problems/roman-to-integer/) 

# 结论

一如既往，祝你编码愉快，面试好运！