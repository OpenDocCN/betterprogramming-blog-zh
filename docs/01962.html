<html>
<head>
<title>How To Make a React Component Editor with Live Preview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何制作带实时预览的React组件编辑器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-a-simple-live-react-editor-a6cc17e77beb?source=collection_archive---------3-----------------------#2019-10-27">https://betterprogramming.pub/creating-a-simple-live-react-editor-a6cc17e77beb?source=collection_archive---------3-----------------------#2019-10-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c80f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">快速游乐场吃你的心了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/61092116802609479bf27fa259808f7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h6HNBPAce564SZkFHshJDw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最终演示</p></figure><p id="e545" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你有没有想过那些像<a class="ae lu" href="https://codesandbox.com" rel="noopener ugc nofollow" target="_blank"> codesandbox </a>和<a class="ae lu" href="https://codepen.io" rel="noopener ugc nofollow" target="_blank"> codepen </a>这样的live react编辑器是如何工作的？如果你曾经使用过<a class="ae lu" href="https://react.semantic-ui.com/" rel="noopener ugc nofollow" target="_blank"> semantic react </a>或<a class="ae lu" href="https://react-styleguidist.js.org/" rel="noopener ugc nofollow" target="_blank"> react styleguidist </a>你应该知道你可以在浏览器中通过实时预览与它们的例子进行交互。</p><p id="6319" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个周末，我终于把这些碎片拼凑在一起，创造了一个简单的工作解决方案。这篇文章是这个实验的概述。如果您不确定我们正在构建什么，我建议您滚动到本文的底部，首先与嵌入式codesandbox演示进行交互。</p><p id="7478" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好了，让我们开始吧。</p><h2 id="3e7c" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">我们必须克服的挑战:</h2><ul class=""><li id="76a4" class="mo mp it la b lb mq le mr lh ms ll mt lp mu lt mv mw mx my bi translated">在浏览器中传输JSX/ES6。</li><li id="f247" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">某种模块解析，所以我们可以将模块导入到编辑器中。</li><li id="8098" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">一些解析和修改JavaScript代码的方法。</li></ul><h2 id="6e68" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">使用的包:</h2><ul class=""><li id="04c8" class="mo mp it la b lb mq le mr lh ms ll mt lp mu lt mv mw mx my bi translated"><code class="fe ne nf ng nh b">@babel/standalone</code>在浏览器中传输JSX/ES6。</li><li id="ec32" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated"><code class="fe ne nf ng nh b">acorn</code>将JS解析成AST(不要担心我们的用例，AST操作非常简单)。</li><li id="cf2d" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated"><code class="fe ne nf ng nh b">escodegen</code>将修改后的AST转换回JS代码。</li><li id="7efe" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated"><code class="fe ne nf ng nh b">debounce</code>和<code class="fe ne nf ng nh b">object-path</code>的各自用法。</li></ul></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="1ec8" class="np lw it bd lx nq nr ns ma nt nu nv md jz nw ka mg kc nx kd mj kf ny kg mm nz bi translated">战略</h1><p id="569e" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">出奇的简单。以下是步骤:</p><ol class=""><li id="00c9" class="mo mp it la b lb lc le lf lh od ll oe lp of lt og mw mx my bi translated">传输JSX/ES6代码</li><li id="3ad0" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt og mw mx my bi translated">从传输的代码体中找到一个JSX表达式语句。我们将在稍后讨论AST处理部分时深入探讨这一点。</li><li id="c5c4" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt og mw mx my bi translated">修改JSX表达式，使其包含在一个<code class="fe ne nf ng nh b">render</code>调用中。</li><li id="e66f" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt og mw mx my bi translated">创建一个新的包装函数，其中包含目前为止从上述步骤中生成的代码以及作为参数传递的所有依赖项。</li><li id="4926" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt og mw mx my bi translated">每当代码发生变化时，调用第四步中创建的函数</li></ol><p id="b9e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">迷茫？别担心，让我们举一个实际的例子来说明这一点。</p><p id="7dd0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们从下面的代码开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/0aed3cb7cc4f6404c54dbd575d6edc85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ek2ggkkOSOIofBMEQ29KZg.png"/></div></div></figure><p id="0087" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们怎样才能让这段代码呈现在网页上的任意DOM元素上呢？</p><p id="dc7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在的任务是传输上述代码，解析所需的按钮组件，并在第12行呈现JSX。</p><p id="db4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是翻译版本:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/6301f1e29de5bb03c85ac17fb6ef40b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZaMjQxmonRLkMCeMMe_aBQ.png"/></div></div></figure><p id="e471" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是我们想要动态生成的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/57d0d02e76ad9aef731d26d2abeecc27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HG2lcinUvX3z28ehsboVGw.png"/></div></div></figure><p id="7474" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们能够生成上面的函数，我们就可以用React模块对象、渲染函数和模块解析函数作为参数来调用它(按照这个顺序)。</p><p id="14e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另外，请注意，我们已经用render函数调用包装了transpiled代码的第10行。</p><p id="5c73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你现在明白了。让我们看一些代码:</p><pre class="kj kk kl km gt ok nh ol om aw on bi"><span id="735e" class="lv lw it nh b gy oo op l oq or">import React from "react";<br/>import ReactDOM from "react-dom";<br/>import ObjPath from "object-path";<br/><br/>import * as Acorn from "acorn";<br/><br/>import { generate as generateJs } from "escodegen";<br/>import { transform as babelTransform } from "@babel/standalone";<br/><br/>function isReactNode(node) {<br/>    const type = node.type; //"ExpressionStatement"<br/>    const obj = ObjPath.get(node, "expression.callee.object.name");<br/>    const func = ObjPath.get(node, "expression.callee.property.name");<br/>    return (<br/>        type === "ExpressionStatement" &amp;&amp;<br/>        obj === "React" &amp;&amp;<br/>        func === "createElement"<br/>    );<br/>}<br/><br/>export function findReactNode(ast) {<br/>    const { body } = ast;<br/>    return body.find(isReactNode);<br/>}<br/><br/>export function createEditor(domElement, moduleResolver = () =&gt; null) {<br/>    function render(node) {<br/>        ReactDOM.render(node, domElement);<br/>    }<br/><br/>    function require(moduleName) {<br/>        return moduleResolver(moduleName);<br/>    }<br/><br/>    function getWrapperFunction(code) {<br/>        try {<br/>            // 1. transform code<br/>            const tcode = babelTransform(code, { presets: ["es2015", "react"] })<br/>                .code;<br/><br/>            // 2. get AST<br/>            const ast = Acorn.parse(tcode, {<br/>                sourceType: "module"<br/>            });<br/><br/>            // 3. find React.createElement expression in the body of program<br/>            const rnode = findReactNode(ast);<br/><br/>            if (rnode) {<br/>                const nodeIndex = ast.body.indexOf(rnode);<br/>                // 4. convert the React.createElement invocation to source and remove the trailing semicolon<br/>                const createElSrc = generateJs(rnode).slice(0, -1);<br/>                // 5. transform React.createElement(...) to render(React.createElement(...)), <br/>                // where render is a callback passed from outside<br/>                const renderCallAst = Acorn.parse(`render(${createElSrc})`)<br/>                    .body[0];<br/><br/>                ast.body[nodeIndex] = renderCallAst;<br/>            }<br/><br/>            // 6. create a new wrapper function with all dependency as parameters<br/>            return new Function("React", "render", "require", generateJs(ast));<br/>        } catch (ex) {<br/>            // in case of exception render the exception message<br/>            render(&lt;pre style={{ color: "red" }}&gt;{ex.message}&lt;/pre&gt;);<br/>        }<br/>    }<br/><br/>    return {<br/>        // returns transpiled code in a wrapper function which can be invoked later<br/>        compile(code) {<br/>            return getWrapperFunction(code);<br/>        },<br/><br/>        // compiles and invokes the wrapper function<br/>        run(code) {<br/>            this.compile(code)(React, render, require);<br/>        },<br/><br/>        // just compiles and returns the stringified wrapper function<br/>        getCompiledCode(code) {<br/>            return getWrapperFunction(code).toString();<br/>        }<br/>    };<br/>}</span></pre><p id="77bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们通过调用<code class="fe ne nf ng nh b">createEditor</code>函数创建一个新的编辑器实例。该函数接受两个参数:</p><ol class=""><li id="7e7a" class="mo mp it la b lb lc le lf lh od ll oe lp of lt og mw mx my bi translated">将呈现结果的目标DOM元素。</li><li id="fbdd" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt og mw mx my bi translated">模块解析器回调函数。</li></ol><p id="ae71" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里的主力是<code class="fe ne nf ng nh b">getWrapperFunction</code>。另外，请参考下面默认示例代码中生成的AST树的图像，以帮助您理解我们如何检测和修改程序体中的JSX表达式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/8ec503d151448207d591c16371dabb6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X9sK_QOroNuC3Gp6GwW6CA.png"/></div></div></figure><p id="872f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了理解<code class="fe ne nf ng nh b">isReactNode</code>和<code class="fe ne nf ng nh b">findReactNode</code>函数是如何工作的，将代码与上面的AST进行比较。这里要记住的重要一点是，当我们用任意代码串调用<code class="fe ne nf ng nh b">Acorn.parse</code>时，解析器将代码串视为完整的JavaScript程序，因此主体数组代表全局级别的语句。我们想在这里找到<code class="fe ne nf ng nh b">React.createElement</code>语句。</p><p id="b32a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们看看下面的例子:</p><pre class="kj kk kl km gt ok nh ol om aw on bi"><span id="6c78" class="lv lw it nh b gy oo op l oq or">import "./styles.scss";<br/>import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { createEditor } from "./editor";<br/>import debounce from "debounce";<br/><br/>// default code <br/>const code = `import x from 'x';<br/><br/>// edit this example<br/><br/>function Greet() {<br/>  return &lt;span&gt;Hello World!&lt;/span&gt;<br/>}<br/><br/>&lt;Greet /&gt;<br/>`;<br/><br/><br/>class SandBox extends React.Component {<br/>  state = {<br/>    code<br/>  };<br/><br/>  editor = null;<br/><br/>  el = null;<br/><br/>  componentDidMount() {<br/>    this.editor = createEditor(this.el);<br/>    this.editor.run(code);<br/>  }<br/><br/>  onCodeChange = ({ target: { value } }) =&gt; {<br/>    this.setState({ code: value });<br/>    this.run(value);<br/>  };<br/><br/>  run = debounce(() =&gt; {<br/>    const { code } = this.state;<br/>    this.editor.run(code);<br/>  }, 500);<br/><br/>  render() {<br/>    const { code } = this.state;<br/>    return (<br/>      &lt;div className="app"&gt;<br/>        &lt;div className="split-view"&gt;<br/>          &lt;div className="code-editor"&gt;<br/>            &lt;textarea value={code} onChange={this.onCodeChange} /&gt;<br/>          &lt;/div&gt;<br/>          &lt;div className="preview" ref={el =&gt; (this.el = el)} /&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}<br/><br/>const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;SandBox /&gt;, rootElement);</span></pre></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="1845" class="np lw it bd lx nq nr ns ma nt nu nv md jz nw ka mg kc nx kd mj kf ny kg mm nz bi translated">你能在哪里使用这个？</h1><p id="cec1" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">这是一个非常有趣的实验，我认为技术在以下场景中非常有用:</p><ul class=""><li id="c037" class="mo mp it la b lb lc le lf lh od ll oe lp of lt mv mw mx my bi translated">组件文档。</li><li id="f2ba" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">在线IDEs</li><li id="404d" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">作为一个简单动态JSX渲染</li></ul><p id="a21c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看你的了！</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h2 id="6548" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">链接</h2><p id="68b8" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">现场试用(沙盒中的沙盒):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="6fd5" class="np lw it bd lx nq nr ns ma nt nu nv md jz nw ka mg kc nx kd mj kf ny kg mm nz bi translated">包扎</h1><p id="33d7" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">大概就是这样。</p><p id="958c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可能已经注意到，我还没有实现模块解析器部分。这真的很简单，也很容易实现，所以我把它留给读者。</p><p id="1846" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>