<html>
<head>
<title>Extending TypeScript Generics for Additional Type Safety</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扩展TypeScript泛型以实现额外的类型安全</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/extending-typescript-generics-for-additional-type-safety-313f35aca5b3?source=collection_archive---------3-----------------------#2022-04-14">https://betterprogramming.pub/extending-typescript-generics-for-additional-type-safety-313f35aca5b3?source=collection_archive---------3-----------------------#2022-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0184" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让您的类型脚本多态性更上一层楼</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c47564d9fe5983f2e7ec2e22c451ea07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFXRVjUM9qixmzBcsIsQjw.jpeg"/></div></div></figure><p id="550f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">泛型是TypeScript更复杂的方面之一，所以循序渐进很重要。在本文中，我将做一些快速的例子来说明如何通过扩展泛型类型来进行更高级的操作。</p><p id="e99d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你还不熟悉泛型的概念，我建议你先阅读我的<a class="ae lq" href="https://jasonbyrne.medium.com/brief-intro-to-typescript-generics-538228098b5f" rel="noopener">TypeScript泛型简介</a>文章，然后继续阅读。</p><p id="5dcb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">欢迎回来！</p><p id="fd85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们有一个类型为<code class="fe lr ls lt lu b">Menu</code>的类，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="bd44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们有以下类型的项目:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="1dc7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从上面我们可以实例化一个食物或饮料菜单，如下所示:</p><pre class="kj kk kl km gt lx lu ly lz aw ma bi"><span id="2aad" class="mb mc it lu b gy md me l mf mg">const drinkMenu = new Menu&lt;Drink&gt;();<br/>const foodMenu = new Menu&lt;Food&gt;();</span></pre><p id="f9a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的泛型确保每个菜单只能包含它们应该包含的项目类型。如果我试图在饮料菜单上添加一个汉堡，TypeScript就会对我大喊大叫。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/81302ce9c1d39d83cb66d70faad5b103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PB6RnMF36UekxCLHSkXMsQ.png"/></div></div></figure><p id="1636" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以这很好！问题是我也有可能创建一个<code class="fe lr ls lt lu b">Waiter</code>菜单，那会很奇怪。</p><pre class="kj kk kl km gt lx lu ly lz aw ma bi"><span id="ce7f" class="mb mc it lu b gy md me l mf mg">const waiterMenu = new Menu&lt;Waiter&gt;();   // WTF?!?!?</span></pre><p id="f82d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么如何才能防止这种情况呢？轻松点。我们将回到最初的菜单定义，并在我们的泛型周围添加一些约束。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="aaaf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过在我们的泛型<code class="fe lr ls lt lu b">T</code>后添加<code class="fe lr ls lt lu b">extends Food | Drink</code>，我们在那里添加了一个额外的规则。只有属性与这两个类重叠的类型才会被接受。</p><p id="a807" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果我试图实例化一个<code class="fe lr ls lt lu b">Waiter</code>菜单，我的IDE会告诉我，要求服务员菜单是一件令人毛骨悚然的事情，在这家餐厅不受欢迎。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/d87914c0bc70c7b05545768d67fe8bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nMyDxjSILeULx_99aI7dcQ.png"/></div></div></figure><p id="c36d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好家伙！我一定饿了。我们再来做一个食物的例子。我们将创建一个类型来定义菜单上某个食物项目的所有属性。然后我们将创建一个用这些属性实例化的类。</p><p id="04d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们添加了一个<code class="fe lr ls lt lu b">get</code>方法，它接受一个属性参数，将返回该属性的适当值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3d34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有两个主要问题。首先，当我调用<code class="fe lr ls lt lu b">get</code>方法来找出本尼迪克特鸡蛋的价格时，我的VS代码不知道数据类型<code class="fe lr ls lt lu b">price</code>应该是什么，所以它只会认为它是可怕的<code class="fe lr ls lt lu b">any</code>。我们知道在代码库中允许使用<code class="fe lr ls lt lu b">any</code>是TypeScript开发人员的六大罪过之一！</p><p id="8cc9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其次，我们可以自由地请求任何字符串作为属性名。例如，我们可以要求使用<code class="fe lr ls lt lu b">calories</code>，TypeScript完全没有问题。但是，众所周知，你从来不会问本尼迪克特鸡蛋里有多少卡路里。尽情享受美味吧！相信我，你不会想知道卡路里数的！！</p><p id="fc71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，我离题了，我们的<code class="fe lr ls lt lu b">EggsBenedict</code>对象没有<code class="fe lr ls lt lu b">calories</code>属性，所以我们希望我们的IDE能够阻止我们请求它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/a1f36266de18b4ee84d444af1a9b854b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ndjLjd6yAcgUMEU-xWDDww.png"/></div></div></figure><p id="990b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以做得更好，伙计们！让我们在泛型的帮助下再试一次。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="9349" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不要不知所措。让我们走一遍。首先，让我们放大一下<code class="fe lr ls lt lu b">keyof</code>这个关键词。这为我们动态地创建了一个类型，它包含了<code class="fe lr ls lt lu b">FoodProperties</code>的所有属性。然后我们之前学过的<code class="fe lr ls lt lu b">extends</code>关键字告诉TypeScript将<code class="fe lr ls lt lu b">T</code>的可能值约束到属性列表中。</p><p id="2663" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于我们的返回值，我们使用<code class="fe lr ls lt lu b">FoodProperties[T]</code>，这表示基于<code class="fe lr ls lt lu b">property</code>参数，我们的返回类型将匹配<code class="fe lr ls lt lu b">FoodProperties</code>中为该属性定义的类型。</p><p id="1fdb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，当我们再次尝试访问<code class="fe lr ls lt lu b">price</code>和<code class="fe lr ls lt lu b">calories</code>时，它将知道<code class="fe lr ls lt lu b">price</code>是一个数字，并且知道<code class="fe lr ls lt lu b">calories</code>不是一个有效的属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/455887b8f5e28f2bbc66abe28f54ff97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WpVsumWLctDzbyWezPAupw.png"/></div></div></figure><p id="e8b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您可能已经猜到的，您可以使用相同的概念来创建setter方法，该方法只接受正确类型的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="4a86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的IDE现在很高兴，并适当地进行了验证！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/54de447f01e28e1a52b55b14c3c1370d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V9kCnsYuYzqzKymMWPpncA.png"/></div></div></figure><p id="5923" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望这有助于将您的TypeScript多态性提高一个档次。比这更深入，但你已经上路了！</p></div></div>    
</body>
</html>