<html>
<head>
<title>Diving Deep into SwiftUI (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入SwiftUI(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/diving-deep-into-swiftui-using-view-preferences-part-2-of-5-ebd8a91d6c3e?source=collection_archive---------9-----------------------#2019-12-17">https://betterprogramming.pub/diving-deep-into-swiftui-using-view-preferences-part-2-of-5-ebd8a91d6c3e?source=collection_archive---------9-----------------------#2019-12-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="08aa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在SwiftUI中使用视图首选项</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b66667cfad7448ef81243dfbc057104a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RiyeyDDm2wCkLKVCT3VamQ.jpeg"/></div></div></figure><h1 id="88aa" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">介绍</h1><p id="43df" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这是五部分系列的第二部分。如果您从第1部分以外的地方来到这里，您可以从<a class="ae mf" href="https://github.com/tugayac/swiftui-custom-tab-bar-tutorial/commit/7da95b88365d79a12bb0668d0e64d22d04a9c287" rel="noopener ugc nofollow" target="_blank">这个</a>提交开始。</p><ul class=""><li id="1ec4" class="mg mh iq ll b lm mi lp mj ls mk lw ml ma mm me mn mo mp mq bi translated">在第1部分的<a class="ae mf" href="https://medium.com/@ardactugay/diving-deep-into-swiftui-a-simple-custom-tab-bar-part-1-of-5-680d05d7f99b" rel="noopener">中，我们设置了自定义标签栏项目，没有使用视图首选项，只简单使用了一次<code class="fe mr ms mt mu b">GeometryReader</code>。我们将模仿默认iOS标签栏的功能。</a></li><li id="213f" class="mg mh iq ll b lm mv lp mw ls mx lw my ma mz me mn mo mp mq bi translated"><strong class="ll ir">在第2部分中，我们将深入探讨如何使用视图首选项，并使我们的视图层次结构更像SwiftUI。</strong></li><li id="bfca" class="mg mh iq ll b lm mv lp mw ls mx lw my ma mz me mn mo mp mq bi translated">在第3部分中，我们将研究用锚偏好替换我们的一些视图偏好。</li></ul><p id="21af" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><em class="nd">快速提示:最初，我打算将这个系列分成5部分，但是自从写了这些文章之后，我就转向了Flutter。然而，这些文章的所有3个部分中的信息仍然是相关的，所以如果您想了解更多关于SwiftUI的信息，请继续阅读！</em></p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="14ab" class="kr ks iq bd kt ku nl kw kx ky nm la lb jw nn jx ld jz no ka lf kc np kd lh li bi translated">具有视图首选项的高级内容视图实施</h1><p id="3e68" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">到目前为止，您所做的一切都足够好，并且会很好地工作，但感觉不太“快捷”。我的意思是标签栏项目的内容看起来与代码中的标签栏项目没有联系。如果我们能这样做就更好了:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="2aaf" class="nu ks iq mu b gy nv nw l nx ny">CustomTabBarItem(...) {</span><span id="69f9" class="nu ks iq mu b gy nz nw l nx ny">Text("This is my content view")</span><span id="b8cd" class="nu ks iq mu b gy nz nw l nx ny">}<br/>CustomerTabBarItem(...) {</span><span id="618e" class="nu ks iq mu b gy nz nw l nx ny">Text("This is another content view")</span><span id="f33a" class="nu ks iq mu b gy nz nw l nx ny">}</span></pre><p id="205a" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">这在理论上听起来很简单，但是如何在视图层次结构中的其他地方显示<code class="fe mr ms mt mu b">CustomTabBarItem</code>下的内容呢？这就是<strong class="ll ir">视图偏好</strong>非常有用的地方。</p><h2 id="0376" class="nu ks iq bd kt oa ob dn kx oc od dp lb ls oe of ld lw og oh lf ma oi oj lh ok bi translated"><strong class="ak">什么是视图偏好？</strong></h2><p id="e3dd" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">视图首选项本质上允许子视图将数据向上传递给它们的父视图。您将在编码时进行一些调试，以了解SwiftUI层次结构中的数据流。我们开始吧！</p><p id="0e89" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">首先，你如何应对偏好的变化？如果您查看 <code class="fe mr ms mt mu b"><a class="ae mf" href="https://developer.apple.com/documentation/swiftui/view" rel="noopener ugc nofollow" target="_blank">View</a></code>的<a class="ae mf" href="https://developer.apple.com/documentation/swiftui/view" rel="noopener ugc nofollow" target="_blank">文档，您会看到在“响应视图首选项”部分有三个选项:</a></p><p id="4378" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b"><em class="nd">func onPreferenceChange&lt;K&gt;(K.Type, perform: (K.Value) -&gt; Void) -&gt; View</em></code></p><p id="90df" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">这将添加一个在指定首选项的值更改时要执行的操作。</p><p id="f880" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b"><em class="nd">func backgroundPreferenceValue&lt;Key, T&gt;(Key.Type, (Key.Value) -&gt; T) -&gt; View</em></code></p><p id="b995" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">这将使用视图中指定的首选项值来生成另一个视图，作为第一个视图的背景。</p><p id="cec4" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b"><em class="nd">func overlayPreferenceValue&lt;Key, T&gt;(Key.Type, (Key.Value) -&gt; T) -&gt; View</em></code></p><p id="6a37" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">这将使用视图中指定的首选项值来生成另一个视图，作为第一个视图的覆盖图。</p><p id="728f" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">你不能使用<code class="fe mr ms mt mu b">onPreferenceChange</code>,因为它的<code class="fe mr ms mt mu b">perform</code>函数参数不返回任何东西，这意味着你不能从它返回任何<code class="fe mr ms mt mu b">View</code>——这取决于另外两个。既然你一直在使用<code class="fe mr ms mt mu b">background</code>，那就用<code class="fe mr ms mt mu b">overlayPreferenceValue</code>，尽管在这种情况下，<code class="fe mr ms mt mu b">backgroundPreferenceValue</code>也可以。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="02e8" class="kr ks iq bd kt ku nl kw kx ky nm la lb jw nn jx ld jz no ka lf kc np kd lh li bi translated">使用<code class="fe mr ms mt mu b">overlayPreferenceValue</code></h1><p id="30d9" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">让我们仔细看看<code class="fe mr ms mt mu b">overlayPreferenceValue</code>。文档非常简单，但是它没有告诉您它实际上会对偏好值的变化做出反应。稍后你会看到。<a class="ae mf" href="https://developer.apple.com/documentation/swiftui/view/3278625-overlaypreferencevalue" rel="noopener ugc nofollow" target="_blank">进一步深入其文档，</a>您可以看到该声明如下所示:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="ee7a" class="nu ks iq mu b gy nv nw l nx ny">func overlayPreferenceValue&lt;Key, T&gt;(_ key: Key.Type = Key.self, _ transform: @escaping (Key.Value) -&gt; T) -&gt; some View where Key : PreferenceKey, T : View</span></pre><p id="f8fe" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">看起来您必须首先创建一个新的实现<code class="fe mr ms mt mu b"><a class="ae mf" href="https://developer.apple.com/documentation/swiftui/preferencekey" rel="noopener ugc nofollow" target="_blank">PreferenceKey</a></code>协议的<code class="fe mr ms mt mu b">struct</code>。继续在<code class="fe mr ms mt mu b">ContentView.swift</code>中添加一个采用该协议的结构:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="ea5c" class="nu ks iq mu b gy nv nw l nx ny">struct Placeholder {<br/>    <br/>}<br/><br/>struct TabBarPreferenceKey: PreferenceKey {<br/>    typealias Value = Placeholder<br/>    <br/>    static var defaultValue: Placeholder = Placeholder()<br/>    <br/>    static func reduce(value: inout Placeholder, nextValue: () -&gt; Placeholder) {<br/>        value = nextValue()<br/>    }<br/>}<br/><br/>// ContentView hasn't changed...</span></pre><p id="3ff2" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">在继续之前，我们先来看看<code class="fe mr ms mt mu b"><a class="ae mf" href="https://developer.apple.com/documentation/swiftui/preferencekey" rel="noopener ugc nofollow" target="_blank">PreferenceKey</a></code> <a class="ae mf" href="https://developer.apple.com/documentation/swiftui/preferencekey" rel="noopener ugc nofollow" target="_blank">文档</a>。概述指出:</p><blockquote class="ol om on"><p id="a932" class="lj lk nd ll b lm mi jr lo lp mj ju lr oo na lu lv op nb ly lz oq nc mc md me ij bi translated">具有多个子视图的视图会自动将其给定首选项的值合并成对其祖先可见的单个值。</p></blockquote><p id="521b" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">这是个好消息！这意味着您可以拥有一个单独的<code class="fe mr ms mt mu b">PreferenceKey</code>，它可以包含您的子视图的所有首选项的数组。事实上，这就是为什么它需要由协议采用者实现<code class="fe mr ms mt mu b">reduce</code>方法的原因。记住这一点，想想你需要什么:</p><ul class=""><li id="5a6d" class="mg mh iq ll b lm mi lp mj ls mk lw ml ma mm me mn mo mp mq bi translated">为了绘制内容视图，您需要知道选项卡栏的边界，这样内容视图的大小才刚刚好，不会覆盖选项卡栏。</li><li id="fbd0" class="mg mh iq ll b lm mv lp mw ls mx lw my ma mz me mn mo mp mq bi translated">为了让您的代码看起来更快捷，您需要让<code class="fe mr ms mt mu b">CustomTabBarItem</code>通过preferences将其内容传递给<code class="fe mr ms mt mu b">overlayPreferenceValue</code>。</li></ul><p id="2aab" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">记住这一点，更新<code class="fe mr ms mt mu b">TabBarPreferenceKey</code>和<code class="fe mr ms mt mu b">Placeholder</code>:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="4b66" class="nu ks iq mu b gy nv nw l nx ny">struct TabBarItemData { // 2<br/>    var tag: Int<br/>    var content: AnyView<br/>}<br/><br/>struct TabBarPreferenceData { // 1<br/>    var tabBarBounds: CGRect? = nil<br/>    var tabBarItemData: [TabBarItemData] = []<br/>}<br/><br/>struct TabBarPreferenceKey: PreferenceKey {<br/>    typealias Value = TabBarPreferenceData // 3<br/><br/>    static var defaultValue: TabBarPreferenceData = TabBarPreferenceData() // 4<br/><br/>    static func reduce(value: inout TabBarPreferenceData, nextValue: () -&gt; TabBarPreferenceData) { // 5<br/>        value.tabBarItemData.append(contentsOf: nextValue().tabBarItemData) // 6<br/>    }<br/>}<br/><br/>// ContentView hasn't changed...</span></pre><p id="9d88" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//1</code>这是<code class="fe mr ms mt mu b">struct</code>，它将保存你需要的数据。</p><p id="e9d4" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//2</code>因为你只需要一个标签栏的数据，所以它的数据存储在<code class="fe mr ms mt mu b">TabBarPreferenceData</code>中一个名为<code class="fe mr ms mt mu b">tabBarBounds</code>的<code class="fe mr ms mt mu b">CGRect</code>变量中。因为有多个标签栏条目，所以它们有一个独立的数据结构，它们的所有信息都存储在<code class="fe mr ms mt mu b">tabBarItemData</code>下的一个数组中。</p><p id="213a" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//3</code>这是您通过定义自定义<code class="fe mr ms mt mu b">PreferenceKey</code>将保存的数据类型来满足所采用的协议的地方。在这种情况下，它是一个<code class="fe mr ms mt mu b">Array</code>。原因就像你在上面的文档中看到的那样:</p><blockquote class="ol om on"><p id="1a67" class="lj lk nd ll b lm mi jr lo lp mj ju lr oo na lu lv op nb ly lz oq nc mc md me ij bi translated">具有多个子视图的视图会自动将其给定首选项的值合并成对其祖先可见的单个值。</p></blockquote><p id="f658" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//4</code> <a class="ae mf" href="https://developer.apple.com/documentation/swiftui/preferencekey/3272135-defaultvalue" rel="noopener ugc nofollow" target="_blank">根据<code class="fe mr ms mt mu b">PreferenceKey</code>的文档</a>，这是<code class="fe mr ms mt mu b">defaultValue</code>的作用:</p><blockquote class="ol om on"><p id="cdab" class="lj lk nd ll b lm mi jr lo lp mj ju lr oo na lu lv op nb ly lz oq nc mc md me ij bi translated">没有显式键值的视图会生成此默认值。</p></blockquote><p id="11c2" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">当使用<code class="fe mr ms mt mu b">transformPreference</code>时，调用此<code class="fe mr ms mt mu b">defaultValue</code>，而不是首先调用<code class="fe mr ms mt mu b">preference</code>，即给首选项一个“默认值”。两者的区别在于，<code class="fe mr ms mt mu b">transformPreference</code>让你更新一个偏好值，而<code class="fe mr ms mt mu b">preference</code>直接设置偏好值，覆盖任何现有的值。</p><p id="53e3" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//5</code>当SwiftUI合并具有多个子视图的视图时，调用<code class="fe mr ms mt mu b">reduce</code>方法，这些子视图的首选项设置为同一个<code class="fe mr ms mt mu b">PreferenceKey</code>，在本例中为<code class="fe mr ms mt mu b">TabBarPreferenceData</code>。因此，任何正在监视这个首选项的祖先实际上将只获得一个值，这个值已经用<code class="fe mr ms mt mu b">reduce</code>方法实现减少了。</p><p id="1fa1" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//6</code>这可能看起来很奇怪，但你实际上是在合并<code class="fe mr ms mt mu b">TabBarPreferenceData</code>偏好。如果不合并，您将丢弃旧数据并用新数据替换它，本质上是丢弃其他兄弟视图的偏好数据。现在还不要担心<code class="fe mr ms mt mu b">tabBarBounds</code>(这就是为什么它还没有被设置)——我们稍后会回来讨论这个问题。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="4b63" class="kr ks iq bd kt ku nl kw kx ky nm la lb jw nn jx ld jz no ka lf kc np kd lh li bi translated">可选步骤:如何设置首选项值？</h1><p id="17d0" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">为了理解上面的项目<code class="fe mr ms mt mu b">//5</code>和<code class="fe mr ms mt mu b">//6</code>是如何工作的，让我们做一些调试来理解偏好值是如何设置的。转到<code class="fe mr ms mt mu b">CustomTabBarItem.swift</code>并添加对<code class="fe mr ms mt mu b">preference</code>方法的调用:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="878d" class="nu ks iq mu b gy nv nw l nx ny">var body: some View {<br/>    VStack(alignment: .center) {<br/>        Image(systemName: iconName)<br/>            .frame(minWidth: 25, minHeight: 25)<br/>        Text(label)<br/>            .font(.caption)<br/>    }<br/>    .padding([.top, .bottom], 5)<br/>    .foregroundColor(fgColor())<br/>    .frame(maxWidth: .infinity)<br/>    .contentShape(Rectangle())<br/>    .onTapGesture { self.selection.wrappedValue = self.tag }<br/>    .preference(key: TabBarPreferenceKey.self,<br/>                value: TabBarPreferenceData(<br/>                    tabBarItemData: [TabBarItemData(tag: tag,<br/>                                                    content: AnyView(Text("Arda"))<br/>                    )]<br/>                )<br/>    )<br/>}<br/><br/>// Nothing else has changed...</span></pre><p id="d853" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">转到<code class="fe mr ms mt mu b">ContentView.swift</code>，在<code class="fe mr ms mt mu b">TabBarPreferenceData</code>中，添加以下初始化程序:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="4314" class="nu ks iq mu b gy nv nw l nx ny">struct TabBarPreferenceData {<br/>    var tabBarBounds: CGRect? = nil<br/>    var tabBarItemData: [TabBarItemData] = []<br/>    <br/>    init(tabBarBounds: CGRect? = nil, tabBarItemData: [TabBarItemData] = []) {<br/>        self.tabBarBounds = tabBarBounds<br/>        self.tabBarItemData = tabBarItemData<br/>        <br/>        print(tabBarItemData)<br/>    }<br/>}</span></pre><p id="a48e" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">回想一下在<code class="fe mr ms mt mu b">ContentView.swift</code>中，您按照以下顺序创建<code class="fe mr ms mt mu b">CustomTabBarItem</code> s:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="d28c" class="nu ks iq mu b gy nv nw l nx ny">CustomTabBarItem(iconName: "star.fill",<br/>                 label: "Favorites",<br/>                 selection: $selection,<br/>                 tag: 0)<br/>CustomTabBarItem(iconName: "clock.fill",<br/>                 label: "Recents",<br/>                 selection: $selection,<br/>                 tag: 1)<br/>CustomTabBarItem(iconName: "person.crop.circle",<br/>                 label: "Contacts",<br/>                 selection: $selection,<br/>                 tag: 2)<br/>CustomTabBarItem(iconName: "circle.grid.3x3.fill",<br/>                 label: "Keypad",<br/>                 selection: $selection,<br/>                 tag: 3)<br/>CustomTabBarItem(iconName: "recordingtape",<br/>                 label: "Voicemail",<br/>                 selection: $selection,<br/>                 tag: 4)</span></pre><p id="0dfd" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">最后，给<code class="fe mr ms mt mu b">ContentView.swift</code>中的顶层<code class="fe mr ms mt mu b">VStack</code>添加一个<code class="fe mr ms mt mu b">overlayPreferenceValue</code>方法，并在<code class="fe mr ms mt mu b">return</code>语句行放置一个断点:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="5d07" class="nu ks iq mu b gy nv nw l nx ny">VStack {<br/>  // Views...<br/>}<br/>.frame(maxHeight: .infinity, alignment: .bottom)<br/>.overlayPreferenceValue(TabBarPreferenceKey.self) { preferences in<br/>    return Rectangle().fill(Color.clear)<br/>}</span></pre><p id="0a84" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">您已经准备好在模拟器中运行应用程序了。</p><p id="6d7d" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">到达断点后，展开日志。您应该会看到类似这样的内容:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="da75" class="nu ks iq mu b gy nv nw l nx ny">[SwiftUICustomTabBar.TabBarItemData(tag: 0, content: SwiftUI.AnyView(storage: SwiftUI.(unknown context at $1070824d4).AnyViewStorage&lt;SwiftUI.Text&gt;))]</span><span id="2461" class="nu ks iq mu b gy nz nw l nx ny">[SwiftUICustomTabBar.TabBarItemData(tag: 1, content: SwiftUI.AnyView(storage: SwiftUI.(unknown context at $1070824d4).AnyViewStorage&lt;SwiftUI.Text&gt;))]</span><span id="9cb6" class="nu ks iq mu b gy nz nw l nx ny">[SwiftUICustomTabBar.TabBarItemData(tag: 2, content: SwiftUI.AnyView(storage: SwiftUI.(unknown context at $1070824d4).AnyViewStorage&lt;SwiftUI.Text&gt;))]</span><span id="9e18" class="nu ks iq mu b gy nz nw l nx ny">[SwiftUICustomTabBar.TabBarItemData(tag: 3, content: SwiftUI.AnyView(storage: SwiftUI.(unknown context at $1070824d4).AnyViewStorage&lt;SwiftUI.Text&gt;))]</span><span id="49fd" class="nu ks iq mu b gy nz nw l nx ny">[SwiftUICustomTabBar.TabBarItemData(tag: 4, content: SwiftUI.AnyView(storage: SwiftUI.(unknown context at $1070824d4).AnyViewStorage&lt;SwiftUI.Text&gt;))]</span><span id="45db" class="nu ks iq mu b gy nz nw l nx ny">[]</span></pre><p id="096f" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">仔细观察<code class="fe mr ms mt mu b">tag</code> s:它们的顺序和我们在代码中看到的一样！<strong class="ll ir">这意味着SwiftUI可能会按照它们在您的代码</strong>、<strong class="ll ir">中被调用的顺序来初始化首选项，但是请注意这只是一个假设——没有关于这种行为的文档。</strong></p><p id="ecae" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">最后一个<code class="fe mr ms mt mu b">[]</code>呢？那个对我来说是个谜。我的猜测是SwiftUI正在创建一个空的首选项来合并包含我们的<code class="fe mr ms mt mu b">CustomTabBarItem</code>的<code class="fe mr ms mt mu b">HStack</code>下的所有首选项，但是我不能确定(如果你已经知道为什么会这样，请告诉我！).</p><p id="b1ff" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">现在，在调试器中，键入<code class="fe mr ms mt mu b">p preferences</code>然后运行这个调试语句。您应该得到以下内容:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="75c9" class="nu ks iq mu b gy nv nw l nx ny">(SwiftUICustomTabBar.TabBarPreferenceKey.Value) $R0 = {<br/>  tabBarBounds = nil<br/>  tabBarItemData = 5 values {<br/>    [0] = {<br/>      tag = 0<br/>      content = (storage = 0x000060000311adc0)<br/>    }<br/>    [1] = {<br/>      tag = 1<br/>      content = (storage = 0x00006000031fc980)<br/>    }<br/>    [2] = {<br/>      tag = 2<br/>      content = (storage = 0x00006000031c3840)<br/>    }<br/>    [3] = {<br/>      tag = 3<br/>      content = (storage = 0x00006000031e1e80)<br/>    }<br/>    [4] = {<br/>      tag = 4<br/>      content = (storage = 0x00006000031e2280)<br/>    }<br/>  }<br/>}</span></pre><p id="1e43" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">您已经从子视图中获得了所需的所有信息！</p><p id="b967" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">你可以删除<code class="fe mr ms mt mu b">TabBarPreferenceData</code>中的初始化器，因为我们不再需要它了。其他的都可以留下。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="2cfa" class="kr ks iq bd kt ku nl kw kx ky nm la lb jw nn jx ld jz no ka lf kc np kd lh li bi translated">使用overlayPreferenceValue(续)</h1><p id="2c86" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">首先，转到<code class="fe mr ms mt mu b">CustomTabBarItem.swift</code>，进行以下更改:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="9449" class="nu ks iq mu b gy nv nw l nx ny">struct CustomTabBarItem&lt;Content: View&gt;: View { // 2<br/>    let iconName: String<br/>    let label: String<br/>    let selection: Binding&lt;Int&gt;<br/>    let tag: Int<br/>    let content: () -&gt; Content<br/>    <br/>    init(iconName: String,<br/>         label: String,<br/>         selection: Binding&lt;Int&gt;,<br/>         tag: Int,<br/>         @ViewBuilder _ content: @escaping () -&gt; Content) { // 1<br/>        self.iconName = iconName<br/>        self.label = label<br/>        self.selection = selection<br/>        self.tag = tag<br/>        self.content = content<br/>    }<br/>    <br/>    var body: some View {<br/>        VStack(alignment: .center) {<br/>            Image(systemName: iconName)<br/>                .frame(minWidth: 25, minHeight: 25)<br/>            Text(label)<br/>                .font(.caption)<br/>        }<br/>        .padding([.top, .bottom], 5)<br/>        .foregroundColor(fgColor())<br/>        .frame(maxWidth: .infinity)<br/>        .contentShape(Rectangle())<br/>        .onTapGesture { self.selection.wrappedValue = self.tag }<br/>        .preference(key: TabBarPreferenceKey.self,<br/>                    value: TabBarPreferenceData(<br/>                        tabBarItemData: [TabBarItemData(tag: tag,<br/>                                                        content: AnyView(self.content()) // 3<br/>                        )]<br/>                    )<br/>        )<br/>    }<br/>    <br/>    private func fgColor() -&gt; Color {<br/>        return selection.wrappedValue == tag ? Color(UIColor.systemBlue) : Color(UIColor.systemGray)<br/>    }<br/>}<br/><br/>struct CustomTabBarItem_Previews: PreviewProvider {<br/>    static var selection: Int = 0<br/>    static var selectionBinding = Binding&lt;Int&gt;(get: { selection }, set: { selection = $0 })<br/>    <br/>    static var previews: some View {<br/>        CustomTabBarItem(iconName: "clock.fill", label: "Recents", selection: selectionBinding, tag: 0) {<br/>            Text("Empty View")<br/>        }<br/>        .previewLayout(.fixed(width: 80, height: 80))<br/>    }<br/>}</span></pre><p id="0dcf" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//1</code>使用该参数，您可以做所有其他SwiftUI视图所做的事情:它允许您在自己的视图中使用您一直用于SwiftUI视图的类似DSL的语法(@ViewBuilder实际上是一个<em class="nd">函数构建器</em>，这是Swift 5.1中的一个新的实验性功能。<em class="nd"> </em>你可以在这里<a class="ae mf" href="https://blog.vihan.org/swift-function-builders/" rel="noopener ugc nofollow" target="_blank"/>了解更多！<code class="fe mr ms mt mu b">@escaping</code>属性基本上允许这个参数“逃离”初始化器并在别处被调用。</p><p id="91ef" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//2</code>因为您指定了一个从<code class="fe mr ms mt mu b">content</code>实例变量返回的泛型类型<code class="fe mr ms mt mu b">Content</code>，所以您需要在该结构上指定一些约束。所有的<code class="fe mr ms mt mu b">Content</code>必须是SwiftUI <code class="fe mr ms mt mu b">View</code>。</p><p id="995e" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//3</code>这是您设置首选项的地方。您指定之前创建的键，然后为它赋予一个值<em class="nd">，对于这个视图只有</em> <strong class="ll ir"> </strong>(当SwiftUI调用<code class="fe mr ms mt mu b">reduce</code>方法时，合并会在稍后自动发生。在这个子视图中就不用担心这个了)。注意，您将内容包装在<code class="fe mr ms mt mu b">AnyView</code>中，这是SwiftUI视图的一个<a class="ae mf" href="https://medium.com/swiftworld/swift-world-type-erasure-5b720bc0318a" rel="noopener">类型擦除器</a>，以便它们可以在运行时传递。</p><p id="8895" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">现在转到<code class="fe mr ms mt mu b">ContentView.swift</code>。你要在这里做几处改动，所以我把它分成几块。首先，更新<code class="fe mr ms mt mu b">TabBarPreferenceKey</code>:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="0a59" class="nu ks iq mu b gy nv nw l nx ny">struct TabBarPreferenceKey: PreferenceKey {<br/>    typealias Value = TabBarPreferenceData<br/><br/>    static var defaultValue: TabBarPreferenceData = TabBarPreferenceData()<br/><br/>    static func reduce(value: inout TabBarPreferenceData, nextValue: () -&gt; TabBarPreferenceData) {<br/>        if let tabBarBounds = nextValue().tabBarBounds {<br/>            value.tabBarBounds = tabBarBounds<br/>        }<br/>        value.tabBarItemData.append(contentsOf: nextValue().tabBarItemData)<br/>    }<br/>}</span></pre><p id="dceb" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">您在这里添加的唯一新行是在<code class="fe mr ms mt mu b">reduce</code>方法中设置<code class="fe mr ms mt mu b">tabBarBounds</code>。您会注意到对<code class="fe mr ms mt mu b">nil</code>值的检查:这是为了确保不会重置任何已经为<code class="fe mr ms mt mu b">value.tabBarBounds</code>设置的值。在这种情况下，这是一个必需的检查，我们稍后将讨论原因(从中可以获得一些非常有用的信息)。</p><p id="6366" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">更新<code class="fe mr ms mt mu b">ContentView</code>的<code class="fe mr ms mt mu b">body</code>:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="2c76" class="nu ks iq mu b gy nv nw l nx ny">var body: some View {<br/>    VStack(alignment: .center, spacing: 0) {<br/>        HStack(alignment: .lastTextBaseline) {<br/>            CustomTabBarItem(iconName: "star.fill",<br/>                             label: "Favorites",<br/>                             selection: $selection,<br/>                             tag: 0)<br/>            {<br/>                Text("Favorites Content") // 1<br/>            }<br/>            CustomTabBarItem(iconName: "clock.fill",<br/>                             label: "Recents",<br/>                             selection: $selection,<br/>                             tag: 1)<br/>            {<br/>                Text("Recents Content")<br/>            }<br/>            CustomTabBarItem(iconName: "person.crop.circle",<br/>                             label: "Contacts",<br/>                             selection: $selection,<br/>                             tag: 2)<br/>            {<br/>                Text("Contacts Content")<br/>            }<br/>            CustomTabBarItem(iconName: "circle.grid.3x3.fill",<br/>                             label: "Keypad",<br/>                             selection: $selection,<br/>                             tag: 3)<br/>            {<br/>                Text("Keypad Content")<br/>            }<br/>            CustomTabBarItem(iconName: "recordingtape",<br/>                             label: "Voicemail",<br/>                             selection: $selection,<br/>                             tag: 4)<br/>            {<br/>                Text("Voicemail Content")<br/>            }<br/>        } // 2<br/>        .background(<br/>            GeometryReader { parentGeometry in<br/>                Rectangle()<br/>                    .fill(Color(UIColor.systemGray2))<br/>                    .frame(width: parentGeometry.size.width, height: 0.5)<br/>                    .position(x: parentGeometry.size.width / 2, y: 0)<br/>            }<br/>        )<br/>        .background(Color(UIColor.systemGray6))<br/>        .overlay(<br/>            GeometryReader { geometry in<br/>                Rectangle()<br/>                    .fill(Color.clear)<br/>                    .preference(key: TabBarPreferenceKey.self,<br/>                                value: TabBarPreferenceData(tabBarBounds: geometry.frame(in: .named("customTabBar"))) // 5<br/>                    )<br/>            }<br/>        ) // 3<br/>    }<br/>    .frame(maxHeight: .infinity, alignment: .bottom)<br/>    .overlayPreferenceValue(TabBarPreferenceKey.self) { (preferences: TabBarPreferenceData) in<br/>        return GeometryReader { geometry in<br/>            self.createTabBarContentOverlay(geometry, preferences) // 6<br/>        }<br/>    }<br/>    .coordinateSpace(name: "customTabBar") // 4<br/>}</span></pre><p id="01fa" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">您不再需要返回视图内容的函数！每个选项卡栏项目现在都有一个传递给它的SwiftUI视图层次结构，就像您使用SwiftUI框架提供的视图一样。看起来干净多了，不是吗？</p><p id="23eb" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//2</code>这里曾经有一个<code class="fe mr ms mt mu b">frame</code>方法调用。不再需要，因此您可以将其移除。</p><p id="d34c" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//3</code>调用<code class="fe mr ms mt mu b">overlay</code>方法并传递一个空的<code class="fe mr ms mt mu b">Rectangle</code>给它。这可能看起来不太直观，但这是有原因的:您需要一种方法来读取将包含内容的视图的几何结构，以便您可以设置<code class="fe mr ms mt mu b">tabBarBounds</code>。你可以通过创建一个透明的<code class="fe mr ms mt mu b">Rectangle</code>(用户甚至不会知道它的存在)，然后在其中设置<code class="fe mr ms mt mu b">tabBarBounds</code>首选项。由于<code class="fe mr ms mt mu b">Rectangle</code>是视图层次结构的一部分，首选项也将是层次结构的一部分。</p><p id="a2c8" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//4</code> <code class="fe mr ms mt mu b">coordinateSpace</code>定义了调用<code class="fe mr ms mt mu b">GeometryProxy</code>的<code class="fe mr ms mt mu b">frame</code>方法时的具体坐标参考系。在这种情况下，在正在绘制<code class="fe mr ms mt mu b">overlay</code>的父对象上定义一个自定义坐标参考框架。</p><p id="cf0d" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//5</code>在这里使用(4)中定义的<code class="fe mr ms mt mu b">coordinateSpace</code>，获取标签栏相对于其父标签栏的大小和位置，并保存在首选项中。</p><p id="7244" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//6</code>您已经创建了<code class="fe mr ms mt mu b">overlayPreferenceValue</code>方法调用，但是现在您要用一个私有方法替换它(稍后您将定义它)。当所有的首选项都被初始化和合并(如果需要的话)时，以及当这些首选项改变时，将调用 <code class="fe mr ms mt mu b">overlayPreferenceValue</code> <strong class="ll ir">方法，尽管在我们的例子中它们不应该改变。</strong></p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="6f4f" class="kr ks iq bd kt ku nl kw kx ky nm la lb jw nn jx ld jz no ka lf kc np kd lh li bi translated">可选:<code class="fe mr ms mt mu b">Using Overlay</code> vs <code class="fe mr ms mt mu b">Background and How it Affects Preferences</code></h1><p id="25d2" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我想更深入地研究一下在<code class="fe mr ms mt mu b">HStack</code>上调用的<code class="fe mr ms mt mu b">overlay</code>方法。如果你使用<code class="fe mr ms mt mu b">background</code>方法，你认为会发生什么？让我们来了解一下！</p><p id="cc80" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">在<code class="fe mr ms mt mu b">TabBarPreferenceKey</code>结构的<code class="fe mr ms mt mu b">reduce</code>方法中放置一个<code class="fe mr ms mt mu b">print</code>语句，打印如下内容:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="ffd5" class="nu ks iq mu b gy nv nw l nx ny">print(value.tabBarItemData.count, value.tabBarBounds)</span></pre><p id="2025" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">现在在模拟器中运行应用程序。您应该会看到类似这样的内容:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="d1ef" class="nu ks iq mu b gy nv nw l nx ny">2 nil<br/>3 nil<br/>4 nil<br/>5 nil<br/>5 Optional((0.0, 761.5, 414.0, 56.5))</span></pre><p id="75bf" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">第一个数字显示已经保存的标签栏项目首选项的数量。注意，它从<code class="fe mr ms mt mu b">2</code>开始，意味着两件事:</p><ul class=""><li id="c765" class="mg mh iq ll b lm mi lp mj ls mk lw ml ma mm me mn mo mp mq bi translated">只有在视图层次结构中的同一个首选项键上设置了<code class="fe mr ms mt mu b">2</code>或更多的值时，才会调用<code class="fe mr ms mt mu b">reduce</code>方法。</li><li id="5b44" class="mg mh iq ll b lm mv lp mw ls mx lw my ma mz me mn mo mp mq bi translated">只有当另一个视图为与另一个视图相同的首选项设置了一个值时，才会调用<code class="fe mr ms mt mu b">reduce</code>方法，以便将任何现有的首选项与新设置的首选项合并。</li></ul><p id="2b64" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">现在记住<code class="fe mr ms mt mu b">PreferenceKey</code>的文档:</p><blockquote class="ol om on"><p id="aa2b" class="lj lk nd ll b lm mi jr lo lp mj ju lr oo na lu lv op nb ly lz oq nc mc md me ij bi translated">具有多个子视图的视图会自动将其给定首选项的值合并成对其祖先可见的单个值。</p></blockquote><p id="9ace" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><strong class="ll ir">上面的发现表明，这种说法不仅适用于单个视图的兄弟视图，也适用于整个视图层次结构</strong>。这是个好消息，因为SwiftUI将自动为我们合并所有这些偏好。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/9d7a35fa9d19be231f3aab4f9493fc6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*9iOVsBHDt21sXEqoXI6nFQ.png"/></div></div><p class="os ot gj gh gi ou ov bd b be z dk translated">使用覆盖时查看层次结构。</p></figure><p id="b1f6" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">当您使用<code class="fe mr ms mt mu b">overlay</code>时，视图层次看起来像您在左边看到的。这有点令人困惑，因为它看起来不完全像我们的SwiftUI代码。然而，它包含了很多信息:当有多个<code class="fe mr ms mt mu b">background</code>调用时，每个后续的<code class="fe mr ms mt mu b">background</code>调用都会包装前一个调用——因为层次结构中更深层次的视图会出现在那些没有的视图之上。当您还调用<code class="fe mr ms mt mu b">overlay</code>来获取边界时，该覆盖包装了所有内容，并将其自身作为兄弟添加到最后一个<code class="fe mr ms mt mu b">background</code>中。</p><p id="0d8a" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><strong class="ll ir">这向我们表明，当有兄弟视图时，靠近视图子元素数组末尾的视图会出现在那些没有的视图之上。在这种情况下，我们的覆盖将出现在标签栏上的所有内容之上，因为它是覆盖层次结构中的最后一个兄弟。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi gj"><img src="../Images/60ee734150ac35220b68a9cb915780bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UHOLbezWAbrI970vKFDHtw.png"/></div></div><p class="os ot gj gh gi ou ov bd b be z dk translated">蓝色突出显示的框是“覆盖”。</p></figure><p id="6b73" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">通过视觉化可能更容易看出发生了什么。突出显示的蓝色方框是视图层次调试器中的<code class="fe mr ms mt mu b">Overlay</code>视图。在最前面的截图之外扩展的大框架是<code class="fe mr ms mt mu b">GeometryReader</code>——<code class="fe mr ms mt mu b">Overlay</code>的直接子代。它看起来覆盖了标签栏，但那是因为视图层次显示了<code class="fe mr ms mt mu b">GeometryReader</code>正在读取其几何图形的视图。</p><p id="0aa8" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">现在从<code class="fe mr ms mt mu b">TabBarPreferenceKey</code>中的<code class="fe mr ms mt mu b">reduce</code>方法中删除以下几行:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="f113" class="nu ks iq mu b gy nv nw l nx ny">if let tabBarBounds = nextValue().tabBarBounds {<br/>    value.tabBarBounds = tabBarBounds<br/>}</span></pre><p id="a9b0" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">运行应用程序。这一次，您应该会看到<code class="fe mr ms mt mu b">tabBarBounds</code>没有像预期的那样设置好:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="a75d" class="nu ks iq mu b gy nv nw l nx ny">2 nil<br/>3 nil<br/>4 nil<br/>5 nil<br/>5 nil</span></pre><p id="4a66" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">但是如果<code class="fe mr ms mt mu b">overlay</code>是<code class="fe mr ms mt mu b">background</code>方法呢？当您更改它并再次运行应用程序时，您应该会看到以下内容:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="49c0" class="nu ks iq mu b gy nv nw l nx ny">2 nil<br/>3 nil<br/>4 nil<br/>5 nil<br/>5 Optional((0.0, 761.5, 414.0, 56.5))</span></pre><p id="0be5" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">这很有趣，因为您不再在<code class="fe mr ms mt mu b">reduce</code>方法中设置<code class="fe mr ms mt mu b">tabBarBounds</code>。它是如何设置的？首先检查视图层次结构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/6085ea198a7152eafd0b0cf9c8611529.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*SvkIGbbFj_zWlE1RpbiPHQ.png"/></div></figure><p id="7007" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">靠近顶部的<code class="fe mr ms mt mu b">GeometryReader</code>是用来获取标签栏大小的。另一个包含标签栏的上边框。从你打印的内容来看，<strong class="ll ir">似乎孩子的偏好总是在父母设定偏好之前就设定好了。然而，</strong> <code class="fe mr ms mt mu b">background</code> <strong class="ll ir">和</strong> <code class="fe mr ms mt mu b">overlay</code> <strong class="ll ir">在设置首选项时的区别似乎在于，</strong> <code class="fe mr ms mt mu b">background</code> <strong class="ll ir">视图首选项在合并时不必减少，而</strong> <code class="fe mr ms mt mu b">overlay</code> <strong class="ll ir">首选项会减少。</strong></p><p id="15fc" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">但是为什么呢？让我们潜入更深的地方。向<code class="fe mr ms mt mu b">TabBarPreferenceData</code>添加如下初始化式:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="5e2d" class="nu ks iq mu b gy nv nw l nx ny">init(tabBarBounds: CGRect? = nil, tabBarItemData: [TabBarItemData] = []) {<br/>    self.tabBarBounds = tabBarBounds<br/>    self.tabBarItemData = tabBarItemData<br/>        <br/>    print(tabBarItemData.first?.tag, tabBarBounds)<br/>}</span></pre><p id="9a4d" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">现在运行应用程序。您应该会看到以下内容:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="892d" class="nu ks iq mu b gy nv nw l nx ny">Optional(0) nil<br/>Optional(1) nil<br/>Optional(2) nil<br/>Optional(3) nil<br/>Optional(4) nil<br/>nil Optional((0.0, 761.5, 414.0, 56.5))<br/>2 nil<br/>3 nil<br/>4 nil<br/>5 nil<br/>5 Optional((0.0, 761.5, 414.0, 56.5))</span></pre><p id="56f1" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">看起来SwiftUI在合并它们之前初始化了所有的首选项。另外，好像在调用 <code class="fe mr ms mt mu b">reduce</code>之前，<code class="fe mr ms mt mu b">background</code>内视图上设置的首选项是设置在传递给<code class="fe mr ms mt mu b">reduce</code> <em class="nd">的<code class="fe mr ms mt mu b">inout</code> <code class="fe mr ms mt mu b">value</code>上，而<code class="fe mr ms mt mu b">overlay</code>内视图上设置的首选项是<em class="nd">而不是传递给<code class="fe mr ms mt mu b">reduce</code>的<code class="fe mr ms mt mu b">inout</code> <code class="fe mr ms mt mu b">value</code>上设置的</em>并且<em class="nd">必须在减速器中处理</em>，因为它是作为<code class="fe mr ms mt mu b">nextValue</code>传递的。<strong class="ll ir"> </strong> <em class="nd">不过注意，这只是推测，没有任何文档，所以要谨慎使用这些信息。</em></em></p><p id="a325" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">您可以继续并删除此调试部分中添加的任何内容。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="81f9" class="kr ks iq bd kt ku nl kw kx ky nm la lb jw nn jx ld jz no ka lf kc np kd lh li bi translated">使用overlayPreferenceValue(续)</h1><p id="f786" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们还有一件事要做:创建<code class="fe mr ms mt mu b">createTabBarContentOverlay</code>方法。再次在<code class="fe mr ms mt mu b">ContentView.swift</code>中，在<code class="fe mr ms mt mu b">ContentView</code>结构中添加以下内容:</p><pre class="kg kh ki kj gt nq mu nr ns aw nt bi"><span id="4c0e" class="nu ks iq mu b gy nv nw l nx ny">private func createTabBarContentOverlay(_ geometry: GeometryProxy,<br/>                                        _ preferences: TabBarPreferenceData) -&gt; some View {<br/>    let tabBarBounds = preferences.tabBarBounds != nil ? preferences.tabBarBounds! : .zero // 1<br/>    let contentToDisplay = preferences.tabBarItemData.first(where: { $0.tag == self.selection }) // 2<br/>    <br/>    return ZStack {<br/>        if contentToDisplay == nil { // 3<br/>            Text("Empty View")<br/>        } else {<br/>            contentToDisplay!.content // 4<br/>        }<br/>    }<br/>    .frame(width: geometry.size.width,<br/>           height: geometry.size.height - tabBarBounds.size.height,<br/>           alignment: .center) // 5<br/>    .position(x: geometry.size.width / 2,<br/>              y: (geometry.size.height - tabBarBounds.size.height) / 2) // 6<br/>}<br/><br/>// Nothing else has changed...</span></pre><p id="6271" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//1</code>因为<code class="fe mr ms mt mu b">tabBarBounds</code>是可选的，你必须确保它已经被设置。你可以使用一个防护，但是不要什么都不做就退出函数。相反，我们使用默认值<code class="fe mr ms mt mu b">CGRect</code>，所有值都设置为<code class="fe mr ms mt mu b">0</code>，以便稍后提供默认视图。</p><p id="3f3e" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//2</code>创建一个可选变量，尝试查找当前选定选项卡的首选项。</p><p id="3197" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//3</code> SwiftUI视图在其内容中接受条件语句，因此检查以确保有内容要显示。如果没有要显示的内容，返回显示“空视图”的<code class="fe mr ms mt mu b">Text</code>。注意，不能使用<code class="fe mr ms mt mu b">EmptyView</code>，因为它没有实现<code class="fe mr ms mt mu b">View</code>协议(而<code class="fe mr ms mt mu b">else</code>语句中的视图实现了)，所以返回一个表示“空视图”的东西。另外，你不能在这里使用一个<code class="fe mr ms mt mu b">guard</code>语句，因为<code class="fe mr ms mt mu b">@ViewBuilder</code>函数构建器不理解它们。</p><p id="575e" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//4</code>如果代码到了这里，你就知道肯定有内容要显示，那就强制解开，显示在这里。</p><p id="0808" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">请记住，框架包围了它们被调用的视图。在这里，您显式地设置了它的高度，这样当定位时，它不会覆盖底部的标签栏。你在这里处理的<code class="fe mr ms mt mu b">geometry</code>是包裹一切的<code class="fe mr ms mt mu b">VStack</code>的几何图形，它恰好也覆盖了整个屏幕。</p><p id="3c89" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><code class="fe mr ms mt mu b">//6</code>您必须重新定位该视图，因为覆盖图会自动在屏幕上居中，就像堆栈中的所有其他视图一样。注意，<code class="fe mr ms mt mu b"><a class="ae mf" href="https://developer.apple.com/documentation/swiftui/view/3278632-position" rel="noopener ugc nofollow" target="_blank">position</a></code>总是在被调用的视图的中心工作。在SwiftUI中没有办法改变视图的“定位锚”,所以在重新定位视图时要考虑视图的<code class="fe mr ms mt mu b">geometry</code>。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="4db4" class="kr ks iq bd kt ku nl kw kx ky nm la lb jw nn jx ld jz no ka lf kc np kd lh li bi translated">一个高级的工作自定义标签栏</h1><p id="27c3" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">你完了！是时候运行应用程序，看看标签栏是什么样子了:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/39e36050ec3f9a038761b8a441f26447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/1*1UrA-5R0ZMVBlBj3Sdf3pQ.gif"/></div><p class="os ot gj gh gi ou ov bd b be z dk translated">所有的努力都有了回报！</p></figure><p id="8df4" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated">这里是提交，包含了到这里为止的所有内容。</p><p id="fb29" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><strong class="ll ir">第3部分即将推出，届时我们将介绍如何使用锚点首选项！</strong></p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="a1c3" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls na lu lv lw nb ly lz ma nc mc md me ij bi translated"><em class="nd">注意到一个问题？认为有更好的方法来做我上面列出的事情吗？请务必在下方留下评论或发送私信，以便我们讨论。感谢阅读——我希望你今天学到了新东西！</em></p></div></div>    
</body>
</html>