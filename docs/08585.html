<html>
<head>
<title>Stop Using Python Lists Everywhere — Consider Using Deques Instead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止到处使用Python列表——考虑改用Deques</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stop-using-python-lists-everywhere-consider-using-deques-instead-74d37441be4e?source=collection_archive---------1-----------------------#2021-05-18">https://betterprogramming.pub/stop-using-python-lists-everywhere-consider-using-deques-instead-74d37441be4e?source=collection_archive---------1-----------------------#2021-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5180" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">知道何时使用deques作为Python列表的替代</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/999b4e066c46d0b20ac41e3d17787173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fhweT_N5e9QlxvzY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔纳森·肯珀在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="67bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当谈到存储有序序列数据时，许多人可能会把列表作为他们的第一选择。列表可能是最流行的容器数据结构，通常用于存储任何类型的数据，如整数、字符串或自定义实例。这种流行的一个主要原因是列表的可变性。我们可以很容易地在列表中添加和删除条目。</p><p id="f952" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就数据可变性而言，现有数据变量有不同种类的突变。在某些应用中，我们希望我们的数据具有先进先出(FIFO)能力。FIFO强调先加入序列(先进先出)的项目将先从序列中移除(先进先出)。这种业务需求可以使用list对象和deques来解决。然而，deques在这种业务需求上优于lists，因为它们在实现上存在固有的差异。因此，当考虑FIFO时，我们应该考虑使用deques而不是lists。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8097" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用列表实现FIFO</h1><p id="0e87" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设我们正在为一家企业构建一个在线客户聊天系统。在整个营业时间，客户登记入住，我们需要有一个列表来跟踪登记入住的顺序。合理的做法是，一旦客户支持人员有空，就让他们先联系客户支持人员。以下代码片段向您展示了使用列表的可能实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">FIFO实现列表</p></figure><ul class=""><li id="a7c9" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">我们使用一个列表对象(<code class="fe nk nl nm nn b">clients</code>)来保存数据。</li><li id="e37f" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated">当客户进入系统时，我们将该客户添加到等待列表的末尾。</li><li id="d95a" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated">每当一个同事有空的时候，我们通过调用<code class="fe nk nl nm nn b">pop(0)</code>来删除等待列表中的第一个客户。这个方法不仅返回列表中的第一项，还将它从列表中移除。</li></ul><p id="1e7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，我们需要先检查<code class="fe nk nl nm nn b">clients</code>是否有任何条目，因为在空列表上调用<code class="fe nk nl nm nn b">pop()</code>会导致一个<code class="fe nk nl nm nn b">IndexError</code>。利用这两个函数，让我们模拟一个真实的场景:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用FIFO列表</p></figure><p id="64df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">移除列表对象开头的项目是有意义的。在引擎盖下，Python会对列表中的每一项进行移位，以调整内存中第一项的空位，这是一个开销很大的操作，时间复杂度为<em class="nt"> O(n) </em>。鉴于其相当大的时间复杂性，我们应该考虑一个替代解决方案——使用deques。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e4c4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用Deques实现FIFO</h1><p id="e541" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">deque数据类型是双端队列，其发音与“deck”相同。由于其双端特性，它支持从两端插入和移除，这使它成为实现客户端聊天管理系统的完美数据类型。</p><p id="fc8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，在list对象上调用<code class="fe nk nl nm nn b">pop()</code>方法是一个耗费时间和内存的操作。</p><p id="ead3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们直接比较一下这个特性的列表和deques。考虑下面的简化设置，该设置专门关注移除等待队列中的第一个项目:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比较FIFO操作列表和队列的函数</p></figure><ul class=""><li id="1ee0" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated"><code class="fe nk nl nm nn b">deque</code>数据类型可通过<code class="fe nk nl nm nn b">collections</code>模块获得。</li><li id="8603" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated">为了比较性能，我们使用了<code class="fe nk nl nm nn b">timeit</code>函数，它可以计算已定义操作的平均运行时间。</li><li id="ebf2" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated">类似于列表的<code class="fe nk nl nm nn b">pop</code>方法，deques使用<code class="fe nk nl nm nn b">popleft</code>方法删除deques数据类型左端的第一项。</li></ul><p id="5d72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过此功能设置，我们可以在项目数量变化时进行多次比较。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">FIFO性能:队列与列表</p></figure><p id="b061" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个简单的例子中，使用deques对lists的性能提升似乎并不显著，但是对于企业应用程序来说，即使是很小的提升也是非常显著的。重要的是，使用deque数据类型不涉及任何复杂的实现，因为deque是标准库的一部分。那么，除了使用内置数据类型之外，为什么不在没有任何成本的情况下享受性能提升呢？</p><p id="679e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是模拟应用程序的修改版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">FIFO应用程序的队列</p></figure><p id="7806" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，该实现主要涉及数据模型和弹出序列第一项的方法(即<code class="fe nk nl nm nn b">popleft</code>)的改变。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="511e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="af4b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们回顾了当FIFO是我们的应用程序所关心的问题时，deque数据类型作为列表的替代数据模型。</p><p id="2363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为deques是一种双端序列数据结构，所以它是为在两端添加或删除项的操作而设计的。因此，我们不应该将数据模型的选择仅限于列表或其他常见的数据类型。当特定的业务需求(例如FIFO)出现时，我们应该考虑替代的数据模型。</p></div></div>    
</body>
</html>