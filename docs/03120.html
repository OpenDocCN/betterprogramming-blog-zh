<html>
<head>
<title>Functional Programming With Java: What’s in the Box</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java函数式编程:盒子里是什么</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-programming-with-java-whats-in-the-box-4c0ee20035af?source=collection_archive---------18-----------------------#2020-01-21">https://betterprogramming.pub/functional-programming-with-java-whats-in-the-box-4c0ee20035af?source=collection_archive---------18-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f068" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JDK中可用的不同种类的<em class="ki">功能接口</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/3e75f5999faad1959e83e9c4fab4726d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8RAbmxkISaIRymVMYGWXbg.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@erdaest?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Erda Estremera </a>在<a class="ae kz" href="https://unsplash.com/s/photos/box?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="126c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在<a class="ae kz" href="https://medium.com/better-programming/functional-programming-with-java-an-introduction-daa783355731" rel="noopener">的前一部分</a>中，我们学习了Java的功能特性。这一次，我们将回顾自Java 8引入lambdas以来JDK中包含的<a class="ae kz" href="https://medium.com/@benweidig/best-of-java-8-e5aa8cbed673#f751" rel="noopener"> <em class="lw">函数接口</em> </a>。</p><p id="4e8b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">包<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" rel="noopener ugc nofollow" target="_blank">java.util.function</a></code>提供了43个功能接口，包含了创建非常复杂的功能代码所需的所有构件。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="589b" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">四大</h1><p id="572c" class="pw-post-body-paragraph la lb it lc b ld na ju lf lg nb jx li lj nc ll lm ln nd lp lq lr ne lt lu lv im bi translated">我们可能最常用的四个功能界面是:</p><ul class=""><li id="11b2" class="nf ng it lc b ld le lg lh lj nh ln ni lr nj lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b">T Supplier&lt;T&gt;#get()</code> —不接受参数，但返回一个对象。对一个简单的POJO-Getter的方法引用被称为<code class="fe lx ly lz ma b">Supplier</code>。</li><li id="ffe4" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b">void Consumer&lt;T&gt;#accept(T t)</code> —接受单个参数，不返回任何内容。每个POJO-Setter都有资格成为一个<code class="fe lx ly lz ma b">Consumer</code>。</li><li id="4dea" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b">R Function&lt;T, R&gt;#apply(T t)</code> —接受单个参数并返回一个对象。</li><li id="d567" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b">boolean Predicate&lt;T&gt;#test(T t)</code> —接受对象并返回<code class="fe lx ly lz ma b">boolean</code>原语的专用函数。</li></ul><p id="db4e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">仅凭这四点，我们就可以进行大量的函数式编程:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="2cc4" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">函数Arity</h1><p id="01a2" class="pw-post-body-paragraph la lb it lc b ld na ju lf lg nb jx li lj nc ll lm ln nd lp lq lr ne lt lu lv im bi translated">Lambdas通常使用相同的类型作为参数和返回类型。</p><p id="2bf2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">由于Java是一种冗长的语言，我们不想一直写参数化类型。为了避免这种情况，Java提供了更专用的接口和更简单的通用签名:</p><pre class="kk kl km kn gt nv ma nw nx aw ny bi"><span id="cc48" class="nz mj it ma b gy oa ob l oc od"> Arity | Specialized       | Super-Interface<br/>-------+-------------------+-------------------<br/>   1   | UnaryOperator&lt;T&gt;  | Function&lt;T,T&gt;<br/>   2   | BiConsumer&lt;T,U&gt;   | -<br/>   2   | BiFunction&lt;T,U,R&gt; | -<br/>   2   | BinaryOperator&lt;T&gt; | BiFunction&lt;T,T,T&gt;<br/>   2   | BiPredicate&lt;T,U&gt;  | -</span></pre><p id="76fa" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">请注意，不要使用<code class="fe lx ly lz ma b">...Operator&lt;T&gt;</code>作为方法中的参数，我们应该更喜欢使用它的超接口，以使方法更加灵活。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="839b" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">原始类型</h1><p id="9bef" class="pw-post-body-paragraph la lb it lc b ld na ju lf lg nb jx li lj nc ll lm ln nd lp lq lr ne lt lu lv im bi translated">在<a class="ae kz" href="https://openjdk.java.net/projects/valhalla/" rel="noopener ugc nofollow" target="_blank">项目Valhalla </a>和通用专门化(<a class="ae kz" href="https://openjdk.java.net/jeps/218" rel="noopener ugc nofollow" target="_blank"> JEP-218 </a>)可用之前，我们不能使用原语作为参数化类型。</p><p id="969c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">尽管自动装箱/取消装箱在编译时“自动地”工作，但是增加的内存占用和可能的性能影响会抵消更简洁和高性能代码的最初目标。</p><p id="8cd8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">就像原语包装器一样，Java也为原语类型提供了多个专门的函数接口。</p><h2 id="c368" class="nz mj it bd mk oe of dn mo og oh dp ms lj oi oj mu ln ok ol mw lr om on my oo bi translated">数字原语</h2><p id="dffe" class="pw-post-body-paragraph la lb it lc b ld na ju lf lg nb jx li lj nc ll lm ln nd lp lq lr ne lt lu lv im bi translated">数字原语<code class="fe lx ly lz ma b">int</code>、<code class="fe lx ly lz ma b">long</code>和<code class="fe lx ly lz ma b">double</code>都有自己专门的功能接口。下面是给<code class="fe lx ly lz ma b">int</code>的:</p><ul class=""><li id="90c5" class="nf ng it lc b ld le lg lh lj nh ln ni lr nj lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/IntConsumer.html" rel="noopener ugc nofollow" target="_blank">IntConsumer</a></code></li><li id="cde2" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated">一个类似于T6的接口，接受一个对象类型和一个参数。它应该有副作用，会影响被消费的对象参数。</li><li id="2f53" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/IntSupplier.html" rel="noopener ugc nofollow" target="_blank">IntSupplier</a></code></li><li id="a4ad" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/IntPredicate.html" rel="noopener ugc nofollow" target="_blank">IntPredicate</a></code></li><li id="3e5b" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/IntFunction.html" rel="noopener ugc nofollow" target="_blank">IntFunction&lt;R&gt;</a></code></li><li id="741f" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/IntUnaryOperator.html" rel="noopener ugc nofollow" target="_blank">IntUnaryOperator</a></code></li><li id="ef13" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/IntBinaryOperator.html" rel="noopener ugc nofollow" target="_blank">IntBinaryOperator</a></code></li><li id="1fa8" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/ToIntFunction.html" rel="noopener ugc nofollow" target="_blank">ToIntFunction&lt;T&gt;</a></code> —接受对象类型参数并产生一个<code class="fe lx ly lz ma b">int</code>值。</li><li id="5867" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/ToIntBiFunction.html" rel="noopener ugc nofollow" target="_blank">ToIntBiFunction&lt;T,U&gt;</a></code> —接受两个对象类型参数并产生一个<code class="fe lx ly lz ma b">int</code>值。</li></ul><p id="1f67" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所有这些接口都存在于另外两种类型<code class="fe lx ly lz ma b">long</code>和<code class="fe lx ly lz ma b">double</code>中，它们都有相应的类型名称。一些基本类型的缺失并不太糟糕，通过强制转换，它们可以很容易地被现有的类型所替代。</p><h2 id="25f7" class="nz mj it bd mk oe of dn mo og oh dp ms lj oi oj mu ln ok ol mw lr om on my oo bi translated">转换函数</h2><p id="bc1f" class="pw-post-body-paragraph la lb it lc b ld na ju lf lg nb jx li lj nc ll lm ln nd lp lq lr ne lt lu lv im bi translated">以前的函数接口要么接受要么返回原始类型。但有时我们想接受<em class="lw">和</em>返回一个原语。Java在这种情况下也为您提供了保护:</p><ul class=""><li id="2e94" class="nf ng it lc b ld le lg lh lj nh ln ni lr nj lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/IntToLongFunction.html" rel="noopener ugc nofollow" target="_blank">IntToLongFunction</a></code></li><li id="cec0" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/IntToDoubleFunction.html" rel="noopener ugc nofollow" target="_blank">IntToDoubleFunction</a></code></li><li id="4fd8" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/LongToIntFunction.html" rel="noopener ugc nofollow" target="_blank">LongToIntFunction</a></code></li><li id="6f9c" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/LongToDoubleFunction.html" rel="noopener ugc nofollow" target="_blank">LongToDoubleFunction</a></code></li><li id="18c3" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/DoubleToIntFunction.html" rel="noopener ugc nofollow" target="_blank">DoubleToIntFunction</a></code></li><li id="15ca" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/DoubleToLongFunction.html" rel="noopener ugc nofollow" target="_blank">DoubleToLongFunction</a></code></li></ul><h2 id="7a75" class="nz mj it bd mk oe of dn mo og oh dp ms lj oi oj mu ln ok ol mw lr om on my oo bi translated">布尔代数学体系的</h2><p id="0974" class="pw-post-body-paragraph la lb it lc b ld na ju lf lg nb jx li lj nc ll lm ln nd lp lq lr ne lt lu lv im bi translated"><code class="fe lx ly lz ma b">boolean</code>原语不像数字原语类型那样受欢迎。只有一个功能接口是显式前缀:</p><ul class=""><li id="7551" class="nf ng it lc b ld le lg lh lj nh ln ni lr nj lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/BooleanSupplier.html" rel="noopener ugc nofollow" target="_blank">BooleanSupplier</a></code></li></ul><p id="57d2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但是<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html" rel="noopener ugc nofollow" target="_blank">Predicate&lt;T&gt;</a></code>和它的原语对应物可以被看作是返回<code class="fe lx ly lz ma b">boolean</code>原语的专用函数接口。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="7d29" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">函数接口上的默认方法</h1><p id="1051" class="pw-post-body-paragraph la lb it lc b ld na ju lf lg nb jx li lj nc ll lm ln nd lp lq lr ne lt lu lv im bi translated">为了创建非常复杂的表达式，或者简化lambda的创建，JDK提供的许多函数接口都有默认方法。它们通常被设计成流畅的界面。</p><p id="92e7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里有两个例子，查看本文中提到的<a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" rel="noopener ugc nofollow" target="_blank">功能接口</a>可以找到更多。</p><h2 id="0608" class="nz mj it bd mk oe of dn mo og oh dp ms lj oi oj mu ln ok ol mw lr om on my oo bi translated">比较仪</h2><p id="d560" class="pw-post-body-paragraph la lb it lc b ld na ju lf lg nb jx li lj nc ll lm ln nd lp lq lr ne lt lu lv im bi translated">一个简单的函数接口，用于比较两个相同类型的对象。让我们看一个简单的例子:</p><pre class="kk kl km kn gt nv ma nw nx aw ny bi"><span id="b72d" class="nz mj it ma b gy oa ob l oc od">Comparator&lt;MyBean&gt; lambda =<br/>    (lhs, rhs) -&gt; lhs.getProperty().compareTo(rhs.getProperty());</span></pre><p id="15af" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">多亏了默认方法<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#comparing-java.util.function.Function-" rel="noopener ugc nofollow" target="_blank">Comparator.comparing(Function&lt;T,U&gt;)</a></code>，我们可以简化代码:</p><pre class="kk kl km kn gt nv ma nw nx aw ny bi"><span id="bafb" class="nz mj it ma b gy oa ob l oc od">Comparator&lt;MyBean&gt; lambda =<br/>    Comparator.comparing(MyBean::getProperty);</span></pre><p id="fc2b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">更简单，它可以很好地内联到<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#sorted-java.util.Comparator-" rel="noopener ugc nofollow" target="_blank">Stream#sorted(Comparator&lt;? super T&gt; comparator)</a></code>中。</p><h2 id="c564" class="nz mj it bd mk oe of dn mo og oh dp ms lj oi oj mu ln ok ol mw lr om on my oo bi translated">述语</h2><p id="cd1a" class="pw-post-body-paragraph la lb it lc b ld na ju lf lg nb jx li lj nc ll lm ln nd lp lq lr ne lt lu lv im bi translated">另一个带有默认方法的功能接口是已经提到过的<code class="fe lx ly lz ma b">Predicate&lt;T&gt;</code>。它提供了一切，是构建多标准谓词链的基本构件:</p><ul class=""><li id="52db" class="nf ng it lc b ld le lg lh lj nh ln ni lr nj lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html#and-java.util.function.Predicate-" rel="noopener ugc nofollow" target="_blank">and(Predicate&lt;T&gt; other)</a></code></li><li id="d91a" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html#or-java.util.function.Predicate-" rel="noopener ugc nofollow" target="_blank">or(Predicate&lt;T&gt; other)</a></code></li><li id="d2b8" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html#negate--" rel="noopener ugc nofollow" target="_blank">negate()</a></code></li></ul><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="3fef" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结论</h1><p id="873f" class="pw-post-body-paragraph la lb it lc b ld na ju lf lg nb jx li lj nc ll lm ln nd lp lq lr ne lt lu lv im bi translated">JDK为我们提供了许多不同的功能界面。由于Java的双重类型系统区分对象类型和原语，如果我们想有效地处理它们，就需要原语的专用接口。</p><p id="6a2d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">很多函数接口的fluent接口提供了很多部件来构建复杂的表达式。特别是结合<a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" rel="noopener ugc nofollow" target="_blank">流API </a>和方法引用，我们可以精心制作相当简洁易读的代码。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="d284" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">资源</h1><ul class=""><li id="2c88" class="nf ng it lc b ld na lg nb lj op ln oq lr or lv nk nl nm nn bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" rel="noopener ugc nofollow" target="_blank">java.util.function</a></code> <a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" rel="noopener ugc nofollow" target="_blank">包</a>(甲骨文)</li><li id="ce53" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html" rel="noopener ugc nofollow" target="_blank">功能接口</a>(甲骨文)</li><li id="5303" class="nf ng it lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><a class="ae kz" href="https://www.baeldung.com/java-8-functional-interfaces" rel="noopener ugc nofollow" target="_blank">Java 8中的函数接口</a> (Baeldung)</li></ul><div class="os ot gp gr ou ov"><a href="https://medium.com/better-programming/functional-programming-with-java-immutability-8dc748e85f9e" rel="noopener follow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">Java函数式编程:不变性</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">具有不可变状态的更好的数据结构</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">medium.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj kt ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a href="https://medium.com/better-programming/functional-programming-with-java-streams-f930e0e4d184" rel="noopener follow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">Java函数式编程:流</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">最佳实践概述</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">medium.com</p></div></div><div class="pe l"><div class="pk l pg ph pi pe pj kt ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a href="https://medium.com/better-programming/functional-programming-with-java-an-introduction-daa783355731" rel="noopener follow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">Java函数式编程:简介</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">Java从来就不是函数式语言，但这并不意味着我们不能尝试。</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">medium.com</p></div></div><div class="pe l"><div class="pl l pg ph pi pe pj kt ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a href="https://medium.com/@benweidig/best-of-java-8-e5aa8cbed673" rel="noopener follow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">最佳:Java 8</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">Java 8是一个非常大的更新，有很多很棒的新特性！他们中的许多人相互合作，所以让我们…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">medium.com</p></div></div><div class="pe l"><div class="pm l pg ph pi pe pj kt ov"/></div></div></a></div></div></div>    
</body>
</html>