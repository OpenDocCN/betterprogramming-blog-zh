<html>
<head>
<title>How ViewModels Work on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">视图模型如何在Android上工作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/everything-to-understand-about-viewmodel-400e8e637a58?source=collection_archive---------1-----------------------#2020-02-02">https://betterprogramming.pub/everything-to-understand-about-viewmodel-400e8e637a58?source=collection_archive---------1-----------------------#2020-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8bc7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用视图模型及其内部工作原理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/738f746e243b9de082bf68f3e53e5617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ujwRpU19dL74jJnHql-gnQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比尔·牛津在<a class="ae ky" href="https://unsplash.com/s/photos/machinery?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="58c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<a class="ae ky" href="https://developer.android.com/topic/libraries/architecture" rel="noopener ugc nofollow" target="_blank"> Android的文档</a>:</p><blockquote class="lv lw lx"><p id="2413" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">" Android架构组件是一个库的集合，帮助你构建健壮的、可测试的和可维护的应用."</p></blockquote><p id="a58d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Android架构组件有很多东西，包括文档中所说的“管理UI组件生命周期和处理数据持久性”的类。在这一段中，我们来学习一下<code class="fe mc md me mf b">ViewModel</code>及其用法。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="6892" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">介绍</h1><p id="36d8" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><code class="fe mc md me mf b">ViewModel</code>是一个负责准备和管理UI组件(活动或片段)数据的类。它还为活动和片段之间或者不同片段之间的通信提供了一种简单的方式。</p><p id="ee33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">ViewModel</code>总是与一个作用域(一个片段或者一个活动)相关联地被创建，并且只要这个作用域还存在，它就会被保留——也就是说..，如果是活动直到完成。换句话说，这意味着如果一个<code class="fe mc md me mf b">ViewModel</code>的所有者因为配置更改(例如，轮换)而被销毁，它也不会被销毁。所有者的新实例将重新连接到现有的<code class="fe mc md me mf b">ViewModel</code>。让我们看看这是如何发生的</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/e3f3fd28e5f97da66f65fca071d8321a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*Ls1GAobtqGc8G7fXUjdZ0g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://developer.android.com/topic/libraries/architecture/viewmodel" rel="noopener ugc nofollow" target="_blank">通过Android文档查看模型概述</a></p></figure><p id="fb3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">ViewModel</code>的目的是获取并保存活动或片段所需的信息。活动或片段应该能够观察到<code class="fe mc md me mf b">ViewModel</code>中的变化。通常通过LiveData或Android数据绑定来公开这些信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/e35bcc02cdda864657fd5079e02a4272.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*mkRQf65m6l0Jw5-l9GZT6w.png"/></div></figure><p id="f7d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">ViewModel</code>的唯一职责是管理UI的数据。它不应该访问您的视图层次结构，也不应该保留对活动或片段的引用。</p><p id="34ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们先来了解一下使用<code class="fe mc md me mf b">ViewModel</code>的好处。</p><h2 id="4130" class="nm mo it bd mp nn no dn mt np nq dp mx li nr ns mz lm nt nu nb lq nv nw nd nx bi translated">利益</h2><ol class=""><li id="c64b" class="ny nz it lb b lc nf lf ng li oa lm ob lq oc lu od oe of og bi translated"><code class="fe mc md me mf b">ViewModel</code>经受住旋转和其他配置变化。</li></ol><p id="2b37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<code class="fe mc md me mf b">ViewModel</code>当activity在back stack上时继续运行。</p><p id="2d42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.<code class="fe mc md me mf b">ViewModel</code>具有生命周期意识。</p><p id="5d46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.<code class="fe mc md me mf b">ViewModel</code> s在LiveData的帮助下，被动地执行UI更改。每当数据发生变化时，UI就会根据观察到的LiveData和<code class="fe mc md me mf b">ViewModel</code>中的当前数据进行更新。</p><p id="c610" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.<code class="fe mc md me mf b">ViewModel</code>易于理解，易于检验。</p><p id="8eeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将深入探讨<code class="fe mc md me mf b">ViewModel</code>的三个重要方面。</p><p id="4001" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.创建和使用一个简单的<code class="fe mc md me mf b">ViewModel</code>。<br/> 2。使用<code class="fe mc md me mf b">ViewmodelProvide.Factory</code>创建和使用带有参数的<code class="fe mc md me mf b">ViewModel</code>。<strong class="lb iu"> <br/> </strong> 3。共享<code class="fe mc md me mf b">ViewModel</code>用于活动和片段之间的通信。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="b650" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">简单视图模型</h1><p id="06dc" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">让我们通过创建一个简单的例子来更好地理解<code class="fe mc md me mf b">ViewModel</code> s。</p><h2 id="0870" class="nm mo it bd mp nn no dn mt np nq dp mx li nr ns mz lm nt nu nb lq nv nw nd nx bi translated">例子</h2><p id="b616" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">创建和使用<code class="fe mc md me mf b">ViewModel</code>有四个主要步骤:</p><ol class=""><li id="0f73" class="ny nz it lb b lc ld lf lg li oh lm oi lq oj lu od oe of og bi translated">在您的应用程序级别添加依赖关系<code class="fe mc md me mf b">build.gradle</code>。</li><li id="5fd7" class="ny nz it lb b lc ok lf ol li om lm on lq oo lu od oe of og bi translated">通过创建一个扩展<code class="fe mc md me mf b">ViewModel</code>的类，将所有数据从活动中分离出来。</li><li id="c82f" class="ny nz it lb b lc ok lf ol li om lm on lq oo lu od oe of og bi translated">在您的活动中创建一个<code class="fe mc md me mf b">ViewModel</code>实例来使用它。</li><li id="0477" class="ny nz it lb b lc ok lf ol li om lm on lq oo lu od oe of og bi translated">设置<code class="fe mc md me mf b">ViewModel</code>和<code class="fe mc md me mf b">View</code>层之间的通信。</li></ol><h2 id="1c4b" class="nm mo it bd mp nn no dn mt np nq dp mx li nr ns mz lm nt nu nb lq nv nw nd nx bi translated">添加依赖关系</h2><p id="a117" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">为了使用<code class="fe mc md me mf b">ViewModel</code>，我们需要将依赖项添加到我们的<code class="fe mc md me mf b">app/build.gradle</code>文件中。</p><pre class="kj kk kl km gt op mf oq or aw os bi"><span id="e744" class="nm mo it mf b gy ot ou l ov ow">implementation "android.arch.lifecycle:extensions:1.0.0"<br/>annotationProcessor "android.arch.lifecycle:compiler:1.0.0"</span></pre><p id="6734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，如果您将Kotlin与AndroidX配合使用，请添加:</p><pre class="kj kk kl km gt op mf oq or aw os bi"><span id="93b0" class="nm mo it mf b gy ot ou l ov ow">implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0'</span></pre><h2 id="e56f" class="nm mo it bd mp nn no dn mt np nq dp mx li nr ns mz lm nt nu nb lq nv nw nd nx bi translated">创建视图模型类</h2><p id="8bec" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">让我们为没有任何数据的活动创建一个<code class="fe mc md me mf b">SampleViewModel</code>类。这可以简单地通过扩展<code class="fe mc md me mf b">ViewModel</code> <strong class="lb iu"> </strong>类来实现。</p><pre class="kj kk kl km gt op mf oq or aw os bi"><span id="0011" class="nm mo it mf b gy ot ou l ov ow">package com.example.viewmodel<br/><br/>import androidx.lifecycle.ViewModel<br/><br/>class SampleViewModel :<strong class="mf iu">ViewModel</strong>() {<br/><br/>    override fun <strong class="mf iu">onCleared</strong>() {<br/>        super.onCleared()<br/>        // Dispose All your Subscriptions to avoid memory leaks<br/>    }<br/>}</span></pre><p id="9a9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">onCleared()</code> : <strong class="lb iu"> </strong>当这个<code class="fe mc md me mf b">ViewModel</code>不再被使用并且将被销毁时，这个方法将被调用。当<code class="fe mc md me mf b">ViewModel</code>观察到一些数据时，这是很有用的，你需要清除这个订阅来防止这个<code class="fe mc md me mf b">ViewModel</code>的泄露。</p><h2 id="29c8" class="nm mo it bd mp nn no dn mt np nq dp mx li nr ns mz lm nt nu nb lq nv nw nd nx bi translated">在活动中创建ViewModel实例</h2><p id="c0fb" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">使用<code class="fe mc md me mf b">ViewModelProvider</code>在活动中创建一个<code class="fe mc md me mf b">ViewModel</code>实例。<strong class="lb iu"> </strong>我们需要将上下文和<code class="fe mc md me mf b">ViewModel</code>类名传递给<code class="fe mc md me mf b">ViewModelProvider</code> <strong class="lb iu"> </strong>来获取实例。</p><pre class="kj kk kl km gt op mf oq or aw os bi"><span id="3e53" class="nm mo it mf b gy ot ou l ov ow">package com.example.viewmodel<br/><br/>import androidx.appcompat.app.AppCompatActivity<br/>import android.os.Bundle<br/>import androidx.lifecycle.ViewModelProvider<br/><br/>class MainActivity : AppCompatActivity() {<br/><br/>   lateinit var viewModel : SampleViewModel<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.<em class="ly">activity_main</em>)<br/>        viewModel =  <strong class="mf iu">ViewModelProvider</strong>(<strong class="mf iu">this</strong>).get(<strong class="mf iu">SampleViewModel</strong>::class.<em class="ly">java</em>)<br/>       <br/>    }<br/>}</span></pre><p id="7b93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">ViewModelProvider</code>是<code class="fe mc md me mf b">ViewModelStore</code>的一个实用类。它在内部引用<code class="fe mc md me mf b">ViewModelStore</code>来返回<code class="fe mc md me mf b">ViewModel</code>的现有实例(如果它存在的话)——否则，它创建一个新的实例。<code class="fe mc md me mf b">ViewModelStore</code>内部使用<code class="fe mc md me mf b">HashMap</code>跟踪<code class="fe mc md me mf b">ViewModel</code> s。</p><h2 id="1561" class="nm mo it bd mp nn no dn mt np nq dp mx li nr ns mz lm nt nu nb lq nv nw nd nx bi translated">设置视图模型和活动之间的通信</h2><p id="4e8b" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">现在让我们看看如何从<code class="fe mc md me mf b">ViewModel</code>中获取值，并在<code class="fe mc md me mf b">View</code>层中显示它们。让我们在<code class="fe mc md me mf b">ViewModel</code>中创建一个<code class="fe mc md me mf b">LiveData</code>，点击其中的一个按钮，activity更新它的值来显示一个toast消息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="0bb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们处理活动内部的UI层代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="4219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当<code class="fe mc md me mf b">badgeCount</code> <strong class="lb iu"> </strong>到<code class="fe mc md me mf b">LiveData</code>的数据在后台发生变化时，我们都会在我们注册的<code class="fe mc md me mf b">Observer</code>内部收到一个回调。所以用户界面总是用最新的可用数据进行更新。</p><p id="27b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经完成了<code class="fe mc md me mf b">ViewModel</code>及其通信的基础知识，但是还有更多。我们继续。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="479f" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated"><strong class="ak">视图模型提供者。工厂</strong></h1><p id="ebeb" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">由于上面的<code class="fe mc md me mf b">ViewModel</code>在构造函数中没有任何参数，这样做很容易。</p><p id="d619" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你有一个参数需要传递给<code class="fe mc md me mf b">ViewModel</code>的构造函数，那么你需要<code class="fe mc md me mf b">ViewModelFactory</code>。如果您在没有工厂的情况下尝试上述方法，则会导致编译时错误。</p><pre class="kj kk kl km gt op mf oq or aw os bi"><span id="b8b5" class="nm mo it mf b gy ot ou l ov ow">class SampleViewModel :<strong class="mf iu">ViewModel</strong>(name:String) {<br/><br/>    override fun <strong class="mf iu">onCleared</strong>() {<br/>        super.onCleared()<br/>        // Dispose All your Subscriptions to avoid memory leaks<br/>    }<br/>}</span></pre><p id="969f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您运行应用程序时，进程崩溃并出现错误:<code class="fe mc md me mf b">java.lang.RuntimeException: Cannot create an instance of class com.example.viewmodel.SampleViewModel</code>。</p><p id="7812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">ViewModelProvider()</code> <strong class="lb iu"> </strong>方法在内部创建一个默认的<code class="fe mc md me mf b">ViewModelProvider.Factory</code>实现，用于创建不带参数的<code class="fe mc md me mf b">ViewModel</code>。因此，当您在构造函数中添加参数时，<code class="fe mc md me mf b">ViewModelProvider.Factory</code>的内部实现无法初始化您的<code class="fe mc md me mf b">ViewModel</code>，因为<code class="fe mc md me mf b">ViewModelProvider.Factory</code>调用主构造函数来创建<code class="fe mc md me mf b">ViewModel</code>的实例。</p><p id="eeb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要使用<code class="fe mc md me mf b">ViewModelProvider.Factory</code>来创建带有自定义参数的<code class="fe mc md me mf b">ViewModel </code>实例。如果没有争论，那么定制工厂就没有存在的必要。</p><p id="1456" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">ViewModelProvider.Factory</code>是负责实例化<code class="fe mc md me mf b">ViewModel</code>的工厂接口的实现。我们需要创建自己的工厂来创建带有参数的<code class="fe mc md me mf b">ViewModel</code>实例</p><p id="ba5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最简单的方法是创建我们自己的定制工厂扩展ViewModelProvider。工厂<strong class="lb iu"> </strong>接口，<strong class="lb iu"> </strong>给出一个被覆盖的方法，<code class="fe mc md me mf b">create</code>，<strong class="lb iu">，</strong>负责创建我们的<code class="fe mc md me mf b">ViewModel</code>的实例。</p><pre class="kj kk kl km gt op mf oq or aw os bi"><span id="0f3c" class="nm mo it mf b gy ot ou l ov ow">package com.example.viewmodel<br/><br/>import androidx.lifecycle.ViewModel<br/>import androidx.lifecycle.ViewModelProvider<br/><br/>class SampleViewModelFactory (val arg: <strong class="mf iu">String</strong>): <strong class="mf iu">ViewModelProvider.Factory</strong> {<br/><br/>    override fun &lt;T : ViewModel?&gt; <strong class="mf iu">create</strong>(modelClass: Class&lt;T&gt;): T {<br/>        return   modelClass.getConstructor(<strong class="mf iu">String</strong>::class.<em class="ly">java</em>).newInstance(arg)<br/>    }<br/>}</span></pre><p id="dd05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">modelClass.getConstructor(String::class.java)</code>获取类型为<code class="fe mc md me mf b">String</code>的构造函数，并通过调用<code class="fe mc md me mf b">newInstance</code>方法并将构造函数值传递给该方法来创建<code class="fe mc md me mf b">ViewModel</code>的实例。</p><p id="d381" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们检查活动内部的实现。</p><pre class="kj kk kl km gt op mf oq or aw os bi"><span id="c07f" class="nm mo it mf b gy ot ou l ov ow">class MainActivity : AppCompatActivity() {<br/><br/>    lateinit var viewModel: SampleViewModel<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.<em class="ly">activity_main</em>)<br/>        val factory = SampleViewModelFactory("sample")<br/>        viewModel = ViewModelProvider(this,factory).get(SampleViewModel::class.<em class="ly">java</em>)<br/>    }<br/>}</span></pre><p id="c828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的<code class="fe mc md me mf b">ViewModel</code>有依赖项或参数，并且您想要创建您的<code class="fe mc md me mf b">ViewModel</code>实例，那么您应该创建您的自定义<code class="fe mc md me mf b">ViewModelProvider.Factory</code>，并通过<code class="fe mc md me mf b">ViewModel</code>构造函数传递依赖项或参数，并给<code class="fe mc md me mf b">ViewModelProvider.Factory</code>实例赋值。</p><pre class="kj kk kl km gt op mf oq or aw os bi"><span id="8cf7" class="nm mo it mf b gy ot ou l ov ow">val <strong class="mf iu">factory</strong> = SampleViewModelFactory("sample")<br/>ViewModelProvider(this,<strong class="mf iu">factory</strong>).get(SampleViewModel::class.<em class="ly">java</em>)</span></pre><p id="f1dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，我们可以简单地使用<code class="fe mc md me mf b">ViewModelProvider(this)</code> <strong class="lb iu"> </strong>来创建实例。</p><pre class="kj kk kl km gt op mf oq or aw os bi"><span id="ebc0" class="nm mo it mf b gy ot ou l ov ow">ViewModelProvider(this).get(SampleViewModel::class.<em class="ly">java</em>)</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="a022" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">活动和片段之间通信的共享视图模型</h1><p id="71b5" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">为了在不同的片段之间或者一个片段和一个活动之间进行通信，我们通常使用接口或者目标片段。</p><p id="8c37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果它们共享一个活动范围的公共<code class="fe mc md me mf b">ViewModel</code>，那么使用<code class="fe mc md me mf b">ViewModel</code>进行通信会更容易。让我们来看看怎么做。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/0c2f61d8d788ef7b0fce4d858e4b33d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jO6FHDhzcElE0TksGWPMYQ.png"/></div></div></figure><p id="d207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现上面的流程，我们需要在片段和活动的活动范围内创建一个<code class="fe mc md me mf b">ViewModel</code>实例，这样只有一个公共实例被创建并在不同的片段间共享。</p><h2 id="7396" class="nm mo it bd mp nn no dn mt np nq dp mx li nr ns mz lm nt nu nb lq nv nw nd nx bi translated">问题</h2><p id="934c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">一个活动中的两个或多个片段需要相互通信是很常见的。</p><p id="5d1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下两个片段的常见情况:您有一个片段1，其中用户从列表中选择一个项目，还有一个片段2，显示所选项目的内容。这种情况绝不是微不足道的，因为两个片段都需要定义一些接口描述，并且所有者活动必须将两者绑定在一起。此外，两个片段都必须处理另一个片段尚未创建或不可见的情况。</p><h2 id="ee86" class="nm mo it bd mp nn no dn mt np nq dp mx li nr ns mz lm nt nu nb lq nv nw nd nx bi translated">解决办法</h2><p id="4671" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">这个常见的痛点可以通过<strong class="lb iu"> <em class="ly"> </em> </strong>使用<code class="fe mc md me mf b">ViewModel</code>对象来解决。这些片段可以共享一个<code class="fe mc md me mf b">ViewModel</code>,使用它们的活动范围来处理这种通信。</p><p id="4d1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们创建<code class="fe mc md me mf b">SharedViewModel</code>。</p><pre class="kj kk kl km gt op mf oq or aw os bi"><span id="1d3e" class="nm mo it mf b gy ot ou l ov ow">class SharedViewModel : ViewModel() {<br/>      val selected = MutableLiveData&lt;String&gt;()</span><span id="d83f" class="nm mo it mf b gy pa ou l ov ow">      fun selectedItem(item: String) {<br/>       selected.value = item<br/>      }<br/>}</span></pre><p id="a73b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用例:让我们假设有两个片段——<code class="fe mc md me mf b">Fragment1</code>和<code class="fe mc md me mf b">Fragment2</code>——以及这两个片段所连接的主活动。我们需要在点击按钮时从<code class="fe mc md me mf b">Fragment1</code>向<code class="fe mc md me mf b">Fragment2</code>发送一些东西。</p><p id="f63c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">Fragment1</code>看起来像:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="6806" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">Fragment2</code>看起来像:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="beea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这两个片段都检索包含它们的活动。这样，当每个片段都获得了<code class="fe mc md me mf b">ViewModelProvider</code>时，它们会收到同一个<code class="fe mc md me mf b">SharedViewModel</code>实例，该实例的作用范围是活动。</p><p id="49ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法具有以下优点:</p><ul class=""><li id="764e" class="ny nz it lb b lc ld lf lg li oh lm oi lq oj lu pb oe of og bi translated">该活动不需要做任何事情，也不需要知道任何关于该通信的信息</li><li id="93e6" class="ny nz it lb b lc ok lf ol li om lm on lq oo lu pb oe of og bi translated">除了<code class="fe mc md me mf b">SharedViewModel</code>契约之外，片段之间不需要相互了解。如果其中一个碎片消失了，另一个会照常工作。</li><li id="f96a" class="ny nz it lb b lc ok lf ol li om lm on lq oo lu pb oe of og bi translated">每个片段都有自己的生命周期，不受另一个的影响。如果一个片段替换了另一个片段，UI将继续工作，不会出现任何问题。</li></ul><p id="9596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以<code class="fe mc md me mf b">ViewModel</code>可以用来简化UI组件之间的通信。</p></div></div>    
</body>
</html>