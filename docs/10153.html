<html>
<head>
<title>8 Algorithms Destined for the Standard Library in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Swift标准库指定的8种算法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/8-algorithms-destined-for-the-standard-library-in-swift-d5a407ae625a?source=collection_archive---------8-----------------------#2021-12-06">https://betterprogramming.pub/8-algorithms-destined-for-the-standard-library-in-swift-d5a407ae625a?source=collection_archive---------8-----------------------#2021-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c872" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">未来可能应用于Swift X的X算法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d630613dc482f32408e0f2e71f0b493e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bKOgrLpKBswnJQlV_Kn8Bw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">WWDC2021关于算法和集合的演讲截图</p></figure><p id="6996" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">WWDC2021 <a class="ae lu" href="https://developer.apple.com/videos/play/wwdc2021/10256/" rel="noopener ugc nofollow" target="_blank">发布会</a>苹果分享了未来的预览——对于这样一个神秘的公司来说，这是一个不寻常的举动。和我一起探索他们所说的，并为自己尝试一些新的编码想法。在本文中，我想介绍八种算法，它们肯定会在未来的版本中成为Swift的标准库——和我一起参观一下吧。</p><p id="c0c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们从<code class="fe lv lw lx ly b">import Algorithms</code>开始。Xcode不喜欢的代码，需要提示才能更努力地尝试，返回这个弹出窗口，假设你告诉它这样做。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/bf382811560939bd7d6972c2524c7095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vJWOnbTlETFMuttLoah-sg.png"/></div></div></figure><p id="3ff5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">点击添加包，超过这个窗口就会弹出，确认你的决定。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/294309fe1e23a12d3e9479560a8516b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*zFCIovp-x9v29KZ4epcn4A.png"/></div></figure><p id="c34b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好的，让我们开始吧，通过创建一个模板，我们可以用它来可视化正在发生的事情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="3c16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好，现在如果你运行这个——它看起来会像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/76efd4fc93ebb55cbc86877ff705515f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XE0tJUg6cD3Demz4rDjIWw.gif"/></div></div></figure><p id="ed75" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你现在看到的是12个圆圈，它们的颜色在一个单独的阵列中，还有一个旗帜阵列，指示它们应该有什么样的轮廓，黑色还是白色。</p><p id="a036" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目前，我使用一个定时器在它们之间切换，这个定时器基本上是打开它们，然后关闭它们。我还没有使用您在这段代码中看到的任何更改函数。</p><h1 id="fcea" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">更简单的循环</h1><p id="965a" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">现在这里有另一种方法来做同样的事情(几乎):</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="45dd" class="nf mf it ly b gy ng nh l ni nj">let settings = [true, false]<br/>for (colorx, choose) in product(colors, settings) {<br/>  changeX(objects: [colorx], stat: choose)<br/>}</span></pre><p id="8e6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码相当于两个循环——一个在另一个里面。我通过双击圆圈来启动它。您将代码放在带有B1代码注释的背景循环中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/8e4d0f6f50945b7a5580cf4c6a09faa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2RqK_JQkn01znQjrAHjHUA.gif"/></div></div></figure><p id="9368" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这肯定比嵌套数组更容易阅读，在我们的示例中先显示白色，然后显示黑色。我在后台线程上运行代码的唯一原因是，我想在循环之间延迟它的执行，以便您可以看到正在发生什么。</p><h1 id="80d0" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">旋转我们的颜色阵列</h1><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="2f6c" class="nf mf it ly b gy ng nh l ni nj">colors.rotate(toStartAt: 1)</span></pre><p id="3d6a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这在另一方面是完全不同的。这个代码需要放在计时器下面(所以在代码A1下面),它将旋转颜色数组的元素。迪斯科效果！是的，仅仅一行代码就做到了这一点！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/059714d9b7bc4f8be598f6bcedaafb8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fWOOK_OF3ZcNW59I_0IABQ.gif"/></div></div></figure><h1 id="b5e0" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">选择数组的X个元素</h1><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="a328" class="nf mf it ly b gy ng nh l ni nj">for window in colors.windows(ofCount: 4) {<br/>  change(objects: window, stat: true)<br/>  change(objects: window, stat: false)<br/>}</span></pre><p id="0706" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码将选择4个圆，翻转它们，然后关闭——只移动一个圆，做同样的事情。注意它们是重叠的…它在B1代码标签下，事实上我展示的所有其他片段也是如此。</p><p id="e89d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将再次通过双击来触发它——事实上，我演示的所有例程也将从这一点开始使用这个手势。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/f90c806161d446e427a3608bcab411af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1ulQToovxeY4wKHkxUmmoA.gif"/></div></div></figure><h1 id="a628" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">从数组中恰好选择两个元素</h1><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="c457" class="nf mf it ly b gy ng nh l ni nj">for window in colors.adjacentPairs() {<br/>  change(objects: [window.0,window.1], stat: true)<br/>  change(objects: [window.0,window.1], stat: false)<br/>}</span></pre><p id="6278" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这实际上和以前是一样的，只是这次它只选择了两个，并且没有返回一个数组——而是返回给我一个元组。代码和输出看起来几乎是一样的(很明显你每次选择的内容更少)——所以我就不贴这个的动画GIF了。</p><h2 id="67fb" class="nf mf it bd mg nk nl dn mk nm nn dp mo lh no np mq ll nq nr ms lp ns nt mu nu bi translated">选择数组的Y元素</h2><p id="530c" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">我使用了一个不同的字母，因为这段代码选择的元素没有重叠，就像他们所说的块一样。</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="63b3" class="nf mf it ly b gy ng nh l ni nj">for chunk in colors.chunks(ofCount: 3) {<br/>  change(objects: chunk, stat: true)<br/>  change(objects: chunk, stat: false)<br/>}</span></pre><p id="0532" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它看起来像下面——仔细看，它走得很快。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/2d4b56d92cf5351f66fd0d0f7d972cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hvrnzprTvw0zRH0r_JcslQ.gif"/></div></div></figure><h2 id="f18c" class="nf mf it bd mg nk nl dn mk nm nn dp mo lh no np mq ll nq nr ms lp ns nt mu nu bi translated">大步穿过阵列</h2><p id="68e3" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">当然，您可以在swift中轻松地做到这一点，但是下面的代码难道不简单得令人愉快吗？</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="0295" class="nf mf it ly b gy ng nh l ni nj">for loop in colors.striding(by: 2) {<br/>  change(objects: [loop], stat: true)<br/>  change(objects: [loop], stat: false)<br/>}</span></pre><p id="e14f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它看起来像这样——不，它不像。我添加了第二个循环和这个简短的例程来让交替的圆圈进入画面。</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="5a8e" class="nf mf it ly b gy ng nh l ni nj">func rnc(color:Color) -&gt; Color {<br/>  let found = colors.firstIndex(of: color)!<br/>  return colors[found + 1]<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/d5be913f6db9d7c1271e82a154a35f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*i5TGoP_lv9ptX8T0fqHJcA.gif"/></div></div></figure><h1 id="8228" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">阵列中元素的排列</h1><p id="7153" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">bon——如果你还在这里，你已经做得很好了——这个花了一分钟构建，然后永远运行。</p><p id="9454" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">排列返回集合元素的所有不同排列的序列。我应该承认，用了十秒钟甚至更长的时间来构建这个数组，这个数组在这段代码中缓慢地运行。仔细观察它——它以不同的顺序显示圆圈。</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="b2ba" class="nf mf it ly b gy ng nh l ni nj">for newColors in colors.permutations() {<br/>  for newColor in newColors {<br/>    let foo = colors.firstIndex(of: newColor)<br/>      changeV(index:foo!, stat: true)<br/>      changeV(index:foo!, stat: false)<br/>    }<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/59a8796903df7f9afe8e120df4506054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Kpcin90YiO7Jp9pAPSxDWg.gif"/></div></div></figure><p id="1787" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，我在动画GIF中作弊了，因为它很难看到，它显示的代码将圆圈分成四组，每组3个元素。我还加快了视频的速度——生成视频的实际代码也使用了链式算法，在试图显示它们之前将排列集合粘在一起。</p><p id="78a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码如下所示:</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="5a45" class="nf mf it ly b gy ng nh l ni nj">let react1 = colors[0..&lt;3].permutations()<br/>let react2 = colors[3..&lt;6].permutations()<br/>let reactA = chain(react1,react2)</span></pre><h1 id="4f9e" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">数组中元素的组合</h1><p id="7f17" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">最后—这里有四个元素的组合，按顺序选择，代码如下所示:</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="a145" class="nf mf it ly b gy ng nh l ni nj">for newColors in colors.combinations(ofCount: 4) {<br/>  for newColor in newColors {<br/>    let foo = colors.firstIndex(of: newColor)<br/>      changeV(index:foo!, stat: true)<br/>      changeV(index:foo!, stat: false)<br/>  }<br/>}</span></pre><p id="bc42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">产生这个输出，再次仔细观察，它不是很清楚发生了什么，这个算法和之前的一样，最终不适用于这种演示。这个序列也没有在GIF中结束——它太长了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/7329e2e30a365ef811740d143e5518b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*b4j-oRqyk4YvgscW0oGo3Q.gif"/></div></div></figure><p id="bc61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有这些让我对一些强大的抽象概念有了一个迷人的了解，我认为所有这些都将及时进入Swift库。</p></div></div>    
</body>
</html>