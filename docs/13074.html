<html>
<head>
<title>Unit Testing a GORM Application With a Real DB Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用真实的数据库服务器对GORM应用程序进行单元测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unit-testing-a-grom-application-with-a-real-db-server-81a1b95ad473?source=collection_archive---------2-----------------------#2022-07-26">https://betterprogramming.pub/unit-testing-a-grom-application-with-a-real-db-server-81a1b95ad473?source=collection_archive---------2-----------------------#2022-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="354f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通常，使用运行在docker中的DB服务器进行单元测试是比Sqlmock更好的选择</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e643cf6117ba3f368ecf28ca51295913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-QV5--qmBkgma4ab"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@miniminion?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">菲利斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大约两年前，我写了一篇<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-unit-test-a-gorm-application-with-sqlmock-97ee73e36526">文章</a>，讨论如何用Sqlmock测试GORM应用程序。</p><p id="5c89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时光飞逝，我意识到大多数开发人员并没有采用这种方法(至少在我的团队中)。使用Sqlmock编写测试用例太复杂，难以上手。</p><p id="2ae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">核心问题是您需要手动编写整个SQL片段，然后将其与GORM的输出进行比较。这种工作量已经远远超过了编写要测试的代码。毕竟，我们使用GORM的原因是为了避免手工编写原始SQL。</p><p id="27c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要找到更好的方法。</p><h1 id="a910" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">改进单元测试过程</h1><p id="bbeb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一般来说，测试数据库应用程序是困难的。主要原因是数据库服务器本身。</p><ul class=""><li id="df2a" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">如果开发团队共享远程数据库服务器，那么数据冲突是不可避免的。</li><li id="3091" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">如果我们在这个数据库服务器上为每个开发人员创建帐户，那么单元测试应该用不同的帐户运行。需要有人来维护这些账户。</li><li id="5682" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">如果我们要求每个开发人员在他们的本地工作站上安装和设置数据库服务器，我们增加了设置开发环境的难度。</li></ul><p id="363e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">似乎没有答案就足够好了。但是如果我们可以用docker在本地运行数据库服务器，并且用docker集成测试用例，那就完美了。</p><p id="8595" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图流程:</p><ol class=""><li id="7d1b" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu ng my mz na bi translated">在每个测试套件之前，用docker启动一个数据库服务器。打开到此服务器的GORM连接</li><li id="1dcc" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ng my mz na bi translated">在每个测试用例运行之前，如果需要的话，清除数据库中的数据并重新创建表格</li><li id="7d13" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ng my mz na bi translated">运行所有测试用例</li><li id="b770" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ng my mz na bi translated">测试套件执行后停止数据库服务器</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/ee6b54294862ab874d55d6a82882f368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*OesvpiDGukwRyW4fuoq1Tw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">单元测试的顺序图</p></figure><p id="b9f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论上，我们可以用命令行控制docker守护进程。但是在<a class="ae ky" href="https://github.com/ory/dockertest" rel="noopener ugc nofollow" target="_blank"> dockertest </a>的帮助下，这个目标可以轻松实现。</p><h1 id="9b00" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Docker中针对数据库服务器的单元测试</h1><p id="4a38" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这里有一个分步教程，用一个运行在docker中的真实数据库服务器对GORM应用程序进行单元测试。</p><p id="f238" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将重用上一篇文章中的示例应用程序。你可以在<a class="ae ky" href="https://github.com/dche423/dbtest" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到源代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/cf6bd3ab066e6d81d4ad3bb6ff338027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*0PP63mJHJ1mrZjh7z1s9jQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">类图</p></figure><p id="95b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们以Postgres为例，但它也适用于任何其他数据库。</p><h2 id="68aa" class="nj lw it bd lx nk nl dn mb nm nn dp mf li no np mh lm nq nr mj lq ns nt ml nu bi translated"><strong class="ak">设置测试套件</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="5a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据顺序图，我们做一系列准备工作:</p><ul class=""><li id="53aa" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">在<code class="fe nx ny nz oa b">BeforeSuite</code>中，我们创建了一个<code class="fe nx ny nz oa b">*gorm.DB</code>的实例和一个清理docker资源的函数。功能<code class="fe nx ny nz oa b">setupGormWithDocker</code>将在后面解释</li><li id="f77d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">在<code class="fe nx ny nz oa b">AfterSuite</code>中，我们调用<code class="fe nx ny nz oa b">cleanupDocker</code>来释放docker相关资源。</li><li id="b7ea" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">在<code class="fe nx ny nz oa b">BeforeEach</code>中，我们删除默认模式，然后重新创建它，以确保数据库在每个测试用例运行之前是干净的和准备好的。</li></ul><p id="910b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是对核心功能<code class="fe nx ny nz oa b">setupGormWithDocker</code>的解释:</p><ul class=""><li id="8ca8" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">用<code class="fe nx ny nz oa b">dockertest.NewPool</code>创建一个docker资源池，用于运行docker容器</li><li id="a238" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">用<code class="fe nx ny nz oa b">dockertest.RunOptions</code>指定图像名称、图像版本和环境变量</li><li id="cd3a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><code class="fe nx ny nz oa b">fnConfig</code>是控制引导策略的功能。在这种情况下，我们需要docker容器在停止后自动移除，并且永远不要自动重启</li><li id="ab3d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">我们使用<code class="fe nx ny nz oa b">pool.RunWithOptions</code>运行容器，然后创建清理函数<code class="fe nx ny nz oa b">fnCleanup.</code></li><li id="d448" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">因为启动容器需要一些时间，所以我们需要等到容器准备好。只有在这之后，我们才能返回<code class="fe nx ny nz oa b">*gorm.DB</code>实例。这里，<code class="fe nx ny nz oa b">pool.Retry</code>来救援了。<code class="fe nx ny nz oa b">pool.Retry</code>将重复执行参数函数，直到函数返回<code class="fe nx ny nz oa b">nil</code>(表示容器准备好)</li></ul><h2 id="27ff" class="nj lw it bd lx nk nl dn mb nm nn dp mf li no np mh lm nq nr mj lq ns nt ml nu bi translated"><strong class="ak">建筑测试案例</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a03d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过测试套件中的准备工作，我们可以获得一个可用的<code class="fe nx ny nz oa b">*gorm.DB</code>实例，连接到一个本地数据库服务器，并且数据库将在每个测试用例执行之前被清空。</p><ul class=""><li id="65d2" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">在<code class="fe nx ny nz oa b">BeforeEach</code>中，我们为测试创建了一个<code class="fe nx ny nz oa b">Repository</code>的实例。调用<code class="fe nx ny nz oa b">repo.Migrate</code>自动创建表格，然后创建示例博客数据。</li><li id="0d24" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">测试用例非常直观。我们调用repo方法，并验证是否返回了预期的结果。这里没有模拟，因为我们使用的是真正的数据库服务器。</li><li id="46f5" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">与Sqlmock相比，不需要手动编写原始SQL，我们可以用不到一百行代码完成整个测试用例。</li></ul><h1 id="45e8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">其他值得注意的事项</h1><ul class=""><li id="b192" class="ms mt it lb b lc mn lf mo li ob lm oc lq od lu mx my mz na bi translated">dockertest将在必要时提取图像，但没有下载进度提示。我们的建议是在第一次运行测试用例之前运行<code class="fe nx ny nz oa b">docker pull postgres:14</code>。</li><li id="07e0" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">运行测试套件可能需要几秒钟，因为我们需要启动Postgres数据库服务器。这可能比大多数内存中的单元测试要慢，但是这是可以接受的。</li><li id="56aa" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">在<code class="fe nx ny nz oa b">pool.Retry</code>期间，会输出一些连接错误。如果你不喜欢这种干扰，通过<code class="fe nx ny nz oa b">&amp;gorm.Config{Logger: logger.Default.LogMode(logger.Silent)}</code>到<code class="fe nx ny nz oa b">gorm.Open</code>关闭日志</li><li id="8222" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">您的应用程序可能依赖于某个<a class="ae ky" href="https://wiki.postgresql.org/wiki/Extensions" rel="noopener ugc nofollow" target="_blank"> Postgres扩展</a>。在这种情况下，您可以用自定义的Postgres图像替换标准的Postgres图像。例如，如果你需要<a class="ae ky" href="https://github.com/citusdata/postgresql-hll" rel="noopener ugc nofollow" target="_blank"> postgres all </a>，你可以使用这个<a class="ae ky" href="https://github.com/vishnudxb/docker-postgres-hll" rel="noopener ugc nofollow" target="_blank"> docker镜像</a></li></ul><h1 id="80ce" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><ul class=""><li id="0f89" class="ms mt it lb b lc mn lf mo li ob lm oc lq od lu mx my mz na bi translated">在真实的数据库服务器上测试GORM应用程序具有巨大的优势。</li><li id="ea08" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">在<code class="fe nx ny nz oa b">dockertest</code>的帮助下，本地docker容器可以无缝地与golang单元测试一起工作。</li><li id="81bb" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">与<code class="fe nx ny nz oa b">Sqlmock</code>不同，所有的数据库逻辑都运行在真实的数据库服务器上，不需要任何模仿，测试用例也大大简化了。</li><li id="3e8d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">现在还有坚持使用Sqlmock的理由吗？</li><li id="002d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">完整的源代码，请访问它的<a class="ae ky" href="https://github.com/dche423/dbtest" rel="noopener ugc nofollow" target="_blank">库</a>。</li></ul><p id="b858" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干杯！</p><h1 id="1f00" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">资源</h1><p id="f163" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-unit-test-a-gorm-application-with-sqlmock-97ee73e36526">如何用Sqlmock对GORM应用进行单元测试</a>。</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt ol oa om on aw oo bi"><span id="8016" class="nj lw it oa b gy op oq l or os"><strong class="oa iu">Want to Connect?</strong></span><span id="9408" class="nj lw it oa b gy ot oq l or os">Follow me on <a class="ae ky" href="https://twitter.com/dche423" rel="noopener ugc nofollow" target="_blank">Twitter</a>.</span></pre></div></div>    
</body>
</html>