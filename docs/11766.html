<html>
<head>
<title>Clean Architecture in Software Engineering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件工程中的干净架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/clean-architecture-in-software-engineering-6de3a6eb19a?source=collection_archive---------5-----------------------#2022-04-14">https://betterprogramming.pub/clean-architecture-in-software-engineering-6de3a6eb19a?source=collection_archive---------5-----------------------#2022-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aea3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用最简单的方式替换过时的元素</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/76080b31c8b1ffed64f29a6d4e392e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B7LkQDyDqLN3rRSrNYkETA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">https://blog . clean coder . com/uncle-bob/2012/08/13/the-clean-architecture . html</a></p></figure><p id="628a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在过去的几年里，我们已经看到了一系列关于系统架构的想法。其中包括:</p><ul class=""><li id="1201" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="http://alistair.cockburn.us/Hexagonal+architecture" rel="noopener ugc nofollow" target="_blank">六边形架构</a>(又名端口和适配器)，由阿利斯泰尔·考克伯恩提出，史蒂夫·弗里曼和纳特·普莱斯在他们的精彩著作<a class="ae kv" href="http://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627" rel="noopener ugc nofollow" target="_blank">中采用，开发面向对象软件</a></li><li id="e5c8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">杰弗里·巴勒莫的洋葱建筑</li><li id="26b6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">尖叫的建筑来自我去年的一个博客</li><li id="f89d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="http://www.amazon.com/Lean-Architecture-Agile-Software-Development/dp/0470684208/" rel="noopener ugc nofollow" target="_blank"> DCI </a>来自詹姆斯·科普林和特里格夫·雷恩斯卡格。</li><li id="32e6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">Ivar Jacobson的著作<em class="mg">面向对象软件工程:一种用例驱动的方法</em></li></ul><p id="339d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管这些架构在细节上有所不同，但它们非常相似。它们都有相同的目标，那就是关注点的分离。它们都是通过将软件分层来实现这种分离的。每一层至少有一层用于业务规则，另一层用于接口。</p><p id="10a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些体系结构中的每一种都会产生具有以下特点的系统:</p><ol class=""><li id="4dad" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr mh ly lz ma bi translated">独立于框架。该体系结构不依赖于某些功能丰富的软件库的存在。这允许您将这样的框架用作工具，而不是将您的系统塞进它们有限的约束中。</li><li id="7e1f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mh ly lz ma bi translated">可测试。可以在没有UI、数据库、Web服务器或任何其他外部元素的情况下测试业务规则。</li><li id="f22a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mh ly lz ma bi translated">独立于UI。用户界面可以很容易地改变，而不需要改变系统的其他部分。例如，Web用户界面可以用控制台用户界面代替，而不需要改变业务规则。</li><li id="5365" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mh ly lz ma bi translated">独立于数据库。您可以将Oracle或SQL Server换成Mongo、BigTable、CouchDB或其他。您的业务规则没有绑定到数据库。</li><li id="ebd5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mh ly lz ma bi translated">独立于任何外部机构。实际上，你的商业规则根本就对外界一无所知。</li></ol><p id="6077" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文顶部的图表试图将所有这些架构集成到一个可行的想法中。</p><h1 id="0d91" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">依赖性规则</h1><p id="0ab5" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">同心圆代表软件的不同领域。一般来说，你越深入，软件的水平就越高。外面的圆圈是机械装置。内圈是政策。</p><p id="9e52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使这个架构工作的首要规则是<em class="mg">依赖规则</em>。这条规则说<em class="mg">源代码依赖</em>只能向内指向<em class="mg"/>。内圈的任何东西都不可能了解外圈的任何东西。特别是外圈声明的东西的名字一定不能被内圈的代码提及。这包括函数和类。变量或任何其他命名的软件实体。</p><p id="4c6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于同样的原因，外圈使用的数据格式不应该被内圈使用，尤其是如果那些格式是由外圈的框架生成的。我们不希望外圈的任何东西影响内圈。</p><h1 id="e422" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">实体</h1><p id="c40a" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">实体封装了企业范围的业务规则。实体可以是具有方法的对象，也可以是一组数据结构和函数。只要实体可以被企业中许多不同的应用程序使用，这都没有关系。</p><p id="f592" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你没有企业，只是编写一个应用程序，那么这些实体就是应用程序的业务对象。它们封装了最通用和最高级的规则。当外界发生变化时，他们是最不可能改变的。例如，您不希望这些对象受到页面导航或安全性更改的影响。任何特定应用程序的操作更改都不会影响实体层。</p><h1 id="d2fc" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">用例</h1><p id="30f3" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">这一层中的软件包含<em class="mg">特定于应用的</em>业务规则。它封装并实现了系统的所有用例。这些用例编排了实体之间的数据流，并指导这些实体使用它们的<em class="mg">企业范围的</em>业务规则来实现用例的目标。</p><p id="7541" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不希望这一层的变化影响到实体。我们也不希望这一层受到外部变化的影响，比如数据库、UI或任何公共框架。这一层与此类问题无关。</p><p id="27ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我们<em class="mg">确实</em>期望应用<em class="mg">操作的变化将</em>影响用例，并因此影响该层中的软件。如果一个用例的细节发生变化，那么这一层的一些代码肯定会受到影响。</p><h1 id="970d" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">接口适配器</h1><p id="7588" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">这一层中的软件是一组适配器，它们将数据从对用例和实体最方便的格式转换为对某些外部机构(如数据库或Web)最方便的格式。例如，正是这一层将完全包含GUI的MVC架构。演示者、视图和控制器都属于这里。模型可能只是从控制器传递到用例，然后从用例返回到呈现者和视图的数据结构。</p><p id="4620" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似地，在这一层中，数据从对实体和用例最方便的形式转换成对正在使用的持久性框架最方便的形式。即数据库。这个圈子内部的代码不应该知道任何关于数据库的事情。如果数据库是SQL数据库，那么所有的SQL都应该限制在这一层，特别是这一层中与数据库有关的部分。</p><p id="a289" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一层中还有将数据从某种外部形式(比如外部服务)转换成用例及实体所使用的内部形式所需的任何其他适配器。</p><h1 id="4519" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">框架和驱动因素。</h1><p id="9370" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">最外层通常由数据库、Web框架等框架和工具组成。一般来说，在这一层你不用写太多代码，除了粘合代码与下一个圈沟通。</p><p id="77ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一层是所有细节的所在。网络是一个细节。数据库是一个细节。我们把这些东西放在外面，它们不会造成什么伤害。</p><h1 id="28c8" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">只有四个圈？</h1><p id="b29f" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">不，圆圈是示意性的。你可能会发现你需要的不仅仅是这四个。没有规定说你必须总是只有这四个。然而，<em class="mg">依赖规则</em>总是适用的。源代码依赖总是指向内部。当你向内移动时，抽象层次增加。最外面的一圈是低层次的具体细节。当你向内移动时，软件变得更加抽象，并封装了更高层次的策略。最里面的圈是最一般的。</p><h1 id="965b" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">跨越界限。</h1><p id="3d17" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">在图的右下方是一个我们如何跨越圆圈边界的例子。它显示了控制器和演示者与下一层中的用例进行通信。注意控制流。它从控制器开始，经过用例，然后在表示器中结束执行。还要注意源代码的依赖性。它们中的每一个都向内指向用例。</p><p id="766c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通常通过使用<a class="ae kv" href="http://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank">依赖倒置原则</a>来解决这个明显的矛盾。例如，在像Java这样的语言中，我们会安排接口和继承关系，使得源代码依赖关系在边界的正确点上反对控制流。</p><p id="6cd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，考虑用例需要调用演示者。然而，这个调用不能是直接的，因为那会违反<em class="mg">依赖规则</em>:外圈的名字不能被内圈提及。因此，我们让内部圆圈中的用例调用一个接口(这里显示为用例输出端口),让外部圆圈中的演示者实现它。</p><p id="e9a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样的技术被用来跨越架构中的所有边界。我们利用动态多态来创建与控制流相反的源代码依赖关系，这样无论控制流走向何方，我们都可以遵循<em class="mg">依赖规则</em>。</p><h1 id="91cf" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">哪些数据跨越了边界。</h1><p id="e478" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">通常，跨越边界的数据是简单的数据结构。如果您愿意，可以使用基本结构或简单的数据传输对象。或者数据可以只是函数调用中的参数。或者你可以把它打包成一个散列表，或者把它构造成一个对象。重要的是，隔离的、简单的数据结构是跨边界传递的。我们不想欺骗和传递<em class="mg">实体</em>或数据库行。我们不希望数据结构有任何违反依赖规则的依赖。</p><p id="7a77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，许多数据库框架会返回一种方便的数据格式来响应查询。我们可以称之为行结构。我们不想跨越边界向内传递行结构。这将违反依赖规则，因为这将迫使内圈了解外圈的一些情况。</p><p id="19ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，当我们跨越边界传递数据时，它总是以最方便内部循环的形式进行。</p><h1 id="97cc" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">结论</h1><p id="b0dd" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">遵守这些简单的规则并不难，而且会让你在前进的道路上省去很多麻烦。通过将软件分成不同的层，并遵循<em class="mg">依赖规则</em>，你将创建一个本质上可测试的系统，并具有隐含的所有好处。</p><p id="81d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当系统的任何外部部分过时时，如数据库或web框架，您可以毫不费力地替换那些过时的元素。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="ed14" class="nk mj iq ng b gy nl nm l nn no"><strong class="ng ir">Want to Connect?</strong></span><span id="5736" class="nk mj iq ng b gy np nm l nn no">This article is written by Han Sheng, Technical Lead in <a class="ae kv" href="https://arkmind.com.my" rel="noopener ugc nofollow" target="_blank">Arkmind</a>, Malaysia. He has a passion for Software Design/Architecture related stuff, Computer Vision and also Edge Devices. He made several AI-based Web/Mobile Applications to help clients solving real-world problems. Feel free to read about him via his <a class="ae kv" href="https://github.com/hansheng0512" rel="noopener ugc nofollow" target="_blank">Github profile</a>.</span></pre></div></div>    
</body>
</html>