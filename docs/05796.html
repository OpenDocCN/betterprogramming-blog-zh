<html>
<head>
<title>Why You Need Decorators in Your Python Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么在Python代码中需要装饰器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-you-need-decorators-in-your-python-code-df12d43eac9c?source=collection_archive---------4-----------------------#2020-08-06">https://betterprogramming.pub/why-you-need-decorators-in-your-python-code-df12d43eac9c?source=collection_archive---------4-----------------------#2020-08-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3ccc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">元编程是关键</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ec5683f9df5f25672bf4dcc82977982c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Adya6LYNOLGNojOB.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1478831" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae ky" href="https://pixabay.com/users/freephotocc-2275370/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1478831" rel="noopener ugc nofollow" target="_blank">免费照片</a>拍摄。</p></figure><p id="dcc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python因其清晰和语法上的甜蜜而受到称赞。在这篇文章中，我将教你使用Python中的decorators来使你的代码变得可读和干净。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f6b0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是装修工？</h1><p id="c65f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要理解decorators是什么，首先需要熟悉Python处理函数的方式。从它的角度来看，函数和普通对象没什么区别。它们具有属性，可以重新分配:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e46b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您可以将它们作为参数传递给其他函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a02e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，对于装修工来说。装饰器用于修改函数或类的行为。实现这一点的方法是定义一个返回另一个函数的函数(decorator)。这听起来很复杂，但是通过这个例子你会明白一切:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e454" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一步一步来:</p><ul class=""><li id="040b" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">首先，我们在第1行定义了<code class="fe nk nl nm nn b">logging_decorator</code>函数。它接受单个参数，这是我们试图修饰的函数。</li><li id="6809" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated">在里面，我们定义了另一个函数:<code class="fe nk nl nm nn b">logging_wrapper</code>。然后,<code class="fe nk nl nm nn b">logging_wrapper</code>被返回并代替原来的修饰函数使用。</li><li id="b005" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated">在第7行，您可以看到装饰器是如何应用于<code class="fe nk nl nm nn b">sum</code>函数的。</li><li id="28e4" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated">在第11行，当我们调用<code class="fe nk nl nm nn b">sum</code>时，它不会只调用<code class="fe nk nl nm nn b">sum</code>。它将调用<code class="fe nk nl nm nn b">logging_wrapper</code>，后者将在调用<code class="fe nk nl nm nn b">sum</code>前后记录日志。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c62e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么需要装修工？</h1><p id="0282" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">很简单:可读性。Python因其清晰简洁的语法而备受赞誉，decorators也不例外。如果有超过一个函数共有的行为，你可能需要做一个装饰器。以下是一些例子，说明它们何时会派上用场:</p><ul class=""><li id="501d" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">运行时检查参数类型</li><li id="e3a3" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated">基准函数调用</li><li id="8569" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated">缓存函数结果</li><li id="3007" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated">计算函数调用</li><li id="4b7b" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated">检查元数据(权限、角色等。)</li><li id="5268" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated">元编程</li><li id="aef0" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated">还有更多…</li></ul><p id="38fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我将列出一些代码示例。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0bd8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">具有返回值的装饰器</h1><p id="b5a2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设我们想知道每个函数调用需要多长时间。此外，函数大多数时候会返回一些东西，所以装饰器也必须处理这些:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4376" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到我们将返回值存储在第5行的<code class="fe nk nl nm nn b">result</code>中。但是在返回之前，我们必须完成函数的计时。这是一个没有装饰者就不可能的行为的例子。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="90bb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">有争论的装饰者</h1><p id="3365" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时，我们想要一个接受值的装饰器(比如Flask中的<code class="fe nk nl nm nn b">@app.route('/login')</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7645" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，我们定义了一个额外的函数，它接受一个参数并返回一个装饰器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6509" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用类装饰</h1><p id="a9f0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用类而不是函数来修饰是可能的。唯一的区别是语法，所以做你更喜欢的。下面是使用类重写的日志装饰器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="83bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好处是您不必处理嵌套函数。您需要做的就是定义一个类并覆盖<code class="fe nk nl nm nn b">__call__</code>方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1214" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">装饰课</h1><p id="b6d7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时候你可能想要修饰一个类中的每一个方法。你可以这样写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你有很多方法，这可能会失去控制。令人欣慰的是，有一种方法可以同时装饰整个班级:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="2565" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，不要惊慌。这看起来很复杂，但这是相同的逻辑:</p><ul class=""><li id="d971" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">首先，我们让<code class="fe nk nl nm nn b">logging_decorator</code>保持原样。它将应用于一个类的所有方法。</li><li id="d829" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated">然后我们定义一个新的装饰器:<code class="fe nk nl nm nn b">log_all_class_methods</code>。它就像一个常规的装饰器，但是返回一个类。</li><li id="bc61" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated"><code class="fe nk nl nm nn b">NewCls</code>有一个习俗<code class="fe nk nl nm nn b">__getattribute__</code>。对于所有对原始类的调用，它将用<code class="fe nk nl nm nn b">logging_decorator</code>来修饰函数。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e99e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">内置装饰器</h1><p id="5017" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你不仅可以定义自己的装饰器，而且标准库中也有一些。我将列出与我合作最多的三个:</p><ul class=""><li id="a0bf" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated"><code class="fe nk nl nm nn b">@property</code> —内置的装饰器，允许您为类属性定义getters和setters。</li><li id="539d" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated"><code class="fe nk nl nm nn b">@lru_cache</code>—<code class="fe nk nl nm nn b">functools</code>模块中的装饰器。它记忆函数参数和返回值，这对于纯函数来说很方便(比如<code class="fe nk nl nm nn b">factorial</code>)。</li><li id="3dfe" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated"><code class="fe nk nl nm nn b">@abstractmethod</code> —来自<code class="fe nk nl nm nn b">abc</code>模块的装饰器。指示该方法是抽象的，并且缺少实现细节。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1361" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结束语</h1><p id="4c75" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">谢谢你的阅读，我希望你喜欢我的文章。继续订阅更多Python内容！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="18bf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="a968" class="nb nc it lb b lc mu lf mv li nt lm nu lq nv lu ng nh ni nj bi translated"><a class="ae ky" href="https://www.python.org/dev/peps/pep-0318/" rel="noopener ugc nofollow" target="_blank"> PEP 318 —函数和方法的装饰器</a></li><li id="ed7d" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated"><a class="ae ky" href="https://docs.python.org/3/library/functools.html" rel="noopener ugc nofollow" target="_blank">对可调用对象的高阶函数和操作</a></li></ul></div></div>    
</body>
</html>