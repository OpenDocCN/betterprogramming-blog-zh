<html>
<head>
<title>How Far Can We Exploit the TypeScript Compiler? Let’s Fibonacci It Beyond Integer Max Value</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们能在多大程度上利用TypeScript编译器？让我们斐波纳契它超越整数的最大值</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-far-can-we-exploit-the-typescript-compiler-lets-fibonacci-it-beyond-integer-max-value-3c70ce142b01?source=collection_archive---------25-----------------------#2022-01-24">https://betterprogramming.pub/how-far-can-we-exploit-the-typescript-compiler-lets-fibonacci-it-beyond-integer-max-value-3c70ce142b01?source=collection_archive---------25-----------------------#2022-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6bf2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你不知道的类型脚本的类型系统的使用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4943ecedd11dac277295e673338b27f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AlGc8NdJLABF8aZE"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">米歇尔·比特托在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e7cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TypeScript编译器被设计用来完成初学者的任务，比如带有一些类型操作的类型检查。但是如果你仔细观察——我们会的——我们可以在编译时做真正的工作。</p><p id="9dc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，你没看错，在编译时！我们选择的武器是打字系统。我们可以使用TypeScript类型系统在编译期间执行大量的计算。我们能走多远？让我们疯狂吧！</p><p id="df8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们试着在编译时计算一些非常大的斐波那契数。</p><h1 id="79a3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">斐波那契数</h1><p id="8c71" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">斐波纳契数被递归定义为:</p><ul class=""><li id="7dce" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><code class="fe my mz na nb b">Fib(0) = 0</code></li><li id="5525" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">Fib(1) = 1</code></li><li id="f6e7" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">Fib(n) = Fib(n-1) + Fib(n-2)</code></li></ul><p id="de67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个完美的问题，可以看出TypeScript的类型系统有多强大。首先，我们需要一些基本的操作。一开始，我们从一位数的运算开始。</p><h1 id="5c3a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">一位数的基本算术运算</h1><p id="0bd6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">最简单的算术运算是增加或减少一个数字。所以让我们定义一个减量类型<code class="fe my mz na nb b">Decrement&lt;Digit&gt;</code>，它可以从一个位数开始减1。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="03ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们如何检查我们的减量类型是否有效？我们如何输出结果类型文本？一种可能性是引发类型错误。引发类型错误的最简单方法是将错误的类型赋给结果类型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="bddd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似地，我们可以创建一个<code class="fe my mz na nb b">Increment&lt;Digit&gt;</code>类型来增加一个位数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f48b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这很容易。现在我们可以使用递增和递减类型来添加一个<code class="fe my mz na nb b">Addition</code>类型。</p><p id="01df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">加法可以实现为递归类型，即第一个操作数加1，第二个操作数减1。然后调用结果的加法。如果第二个操作数达到零，则第一个操作数是原始操作数的和。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="585d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！现在我们可以计算一些斐波纳契数。</p><h1 id="dcad" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在编译期间计算斐波那契数</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="bef0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用上面的脚本，我们可以计算第6个斐波那契数。这是很好的，但它不能是关于这个话题的最后一句话。我们应该争取更多。</p><h1 id="c8ac" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">创建合成数字格式</h1><p id="3955" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于更大的数字，我们可以为<code class="fe my mz na nb b">Increment</code>和<code class="fe my mz na nb b">Decrement</code>类型创建一个巨大的列表，其中映射了每个数字的增量或减量。但是这工作量很大，而且很无聊。</p><p id="5d73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">表示较大数字的更聪明的方法是使用分层列表:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5cd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">列表代表一个从最后一个数字到最高一个数字的数字，并以<code class="fe my mz na nb b">null</code>结束。例如，数字142表示为:</p><pre class="kg kh ki kj gt nj nb nk nl aw nm bi"><span id="389c" class="nn lt iq nb b gy no np l nq nr">Num&lt;2, Num&lt;4, Num&lt;1, null&gt;&gt;&gt;</span></pre><p id="aef4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个递归列表的<code class="fe my mz na nb b">Decrement</code>操作符按照以下规则变成递归的:</p><ul class=""><li id="927c" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">10的减量是9</li><li id="38b5" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">如果一个数字以0结尾，最后一个数字将是9，数字的下一项将递减</li><li id="f1df" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">否则，我们只减少最后一个数字</li></ul><p id="5b01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们新数字格式的<code class="fe my mz na nb b">Increment</code>操作符遵循非常相似的规则:</p><ul class=""><li id="422e" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">9的增量是10</li><li id="87e2" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">如果一个数字以9结尾，最后一个数字将是0，数字的下一项将递增</li><li id="3797" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">否则，我们只增加最后一位数字</li></ul><p id="46da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新的斐波那契数字程序——使用我们的组合数字格式——增加了上述的递增和递减功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="fc8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这种优化，我们能够计算第18个斐波纳契数，即2584！我们正在到达那里。</p><p id="8fac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是将数字2584表示为<code class="fe my mz na nb b">Num&lt;4, Num&lt;8, Num&lt;5, Num&lt;2, null&gt;&gt;&gt;&gt;</code>非常令人困惑。我们能使输入和输出的表示更具可读性吗？</p><h1 id="c843" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">很好地格式化输出</h1><p id="6572" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了使输出更具可读性，数字必须以自然的顺序排列，我们希望摆脱所有这些<code class="fe my mz na nb b">Num&lt;…&gt;</code>类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8039" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe my mz na nb b">PrettyOutput</code>类型将一个数字从我们的列表表示转换成一个带有数字自然排序的字符串。用<code class="fe my mz na nb b">PrettyOutput</code>键入我们的错误信息如下</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="563f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">很好地格式化输入</h1><p id="7d1e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">此外，数字18 ( <code class="fe my mz na nb b">Num&lt;8, Num&lt;1, null&gt;&gt;</code>)的输入可读性不强。我们需要一个类似于<code class="fe my mz na nb b">Pretty</code>类型的概念，颠倒数字的顺序，去掉所有这些<code class="fe my mz na nb b">Num&lt;…&gt;</code>类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="40bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们将<code class="fe my mz na nb b">Pretty</code>和<code class="fe my mz na nb b">CreateNum</code>类型应用于我们的斐波纳契类型，数字变得更加可读。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="a426" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">更巧妙的添加</h1><p id="a052" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果我们试图计算19的斐波纳契数，我们会得到错误<code class="fe my mz na nb b">Type instantiation is excessively deep and possibly infinite</code>。TypeScript只允许我们进行一定深度的递归。从100开始，我们的加法只能进行到一定的深度。</p><p id="7c90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多递归在加法中被浪费了，因为为了增加130 + 80这个数，我们浪费了80个递归。如果我们仔细观察加法，我们会发现加法不能使加数一直递减到零。如果我们在最后一位数达到零就足够了。</p><p id="be93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我们只关心倒数第二位。如果倒数第二位是零，我们只关心倒数第三位，以此类推。如果我们优化加法，它需要做以下事情:</p><ul class=""><li id="efff" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">如果第二个操作数是0，我们就完成了。返回第一个操作数作为结果</li><li id="18cc" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">如果第二个操作数以0结尾，我们只需要查看高位</li><li id="d205" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">否则，递增第一个操作数的当前位数，递减第二个操作数的当前位数。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="405b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哇，我们可以算出第70个斐波那契数了！是<code class="fe my mz na nb b">190'392'490'709'135</code>。这个数字甚至不适合32位整数，并且会影响双精度变量的尾数大小。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="ab99" class="ls lt iq bd lu lv nz lx ly lz oa mb mc jw ob jx me jz oc ka mg kc od kd mi mj bi translated">故事时间</h1><p id="81c0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在获得科学计算硕士学位后，我从事部署在世界上最大的超级计算机上的高性能C++应用程序的工作。后来我创办了一家网络公司，把目光转向了TypeScript。我从来不认为TypeScript是一种简单的脚本语言，它可以与大家伙站在一起。</p></div></div>    
</body>
</html>