<html>
<head>
<title>Understanding the “this” Keyword in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的“this”关键字</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-the-this-keyword-in-javascript-cb76d4c7c5e8?source=collection_archive---------0-----------------------#2018-01-30">https://betterprogramming.pub/understanding-the-this-keyword-in-javascript-cb76d4c7c5e8?source=collection_archive---------0-----------------------#2018-01-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="92fe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在不同的场景中“this”的值是如何分配的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/5ceac07abe5534dbe67cd336325b01c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Tf_5D80dK8H0XQvj7_JSQ.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://www.zeolearn.com/magazine/understanding-the-this-keyword-in-javascript" rel="noopener ugc nofollow" target="_blank">图像信用</a></p></figure><p id="e3b6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在本文中，我们将学习JavaScript关键字<code class="fe lr ls lt lu b">this</code>以及在不同场景中<code class="fe lr ls lt lu b">this</code>的值是如何分配的。理解本文内容的最佳方式是在浏览器控制台中快速执行代码片段。按照以下步骤在您的Chrome浏览器中启动控制台:</p><ul class=""><li id="149c" class="lv lw it kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">在Chrome中打开新标签页</li><li id="9157" class="lv lw it kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">右键单击页面，并从上下文菜单中选择“检查元素”</li><li id="57d0" class="lv lw it kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">转到控制台面板</li><li id="36f7" class="lv lw it kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">开始执行JavaScript代码</li></ul><p id="8f10" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对象是JavaScript中的基本构件。JavaScript中有一个特殊的对象，<code class="fe lr ls lt lu b">this</code>对象。您可以在JavaScript执行的每一行看到<code class="fe lr ls lt lu b">this</code>的值。<code class="fe lr ls lt lu b">this</code>的值是根据代码的执行方式决定的。</p><p id="cb90" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在开始使用<code class="fe lr ls lt lu b">this</code>之前，我们需要了解一点JavaScript运行时环境以及JavaScript代码是如何执行的。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="caec" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">执行上下文</strong></h1><p id="7c23" class="pw-post-body-paragraph kv kw it kx b ky ni ju la lb nj jx ld le nk lg lh li nl lk ll lm nm lo lp lq im bi translated">执行该行的环境(或范围)被称为<em class="nn">执行上下文</em>。JavaScript运行时维护这些执行上下文的堆栈，位于堆栈顶部的执行上下文是当前正在执行的上下文。对象<code class="fe lr ls lt lu b">this</code>指每次执行上下文改变时的改变。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="04b0" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">“此”指一个全局对象</strong></h1><p id="388e" class="pw-post-body-paragraph kv kw it kx b ky ni ju la lb nj jx ld le nk lg lh li nl lk ll lm nm lo lp lq im bi translated">默认情况下，执行的执行上下文是全局的——这意味着如果代码作为简单函数调用的一部分被执行，那么<code class="fe lr ls lt lu b">this</code>指的是一个全局对象。</p><p id="0387" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在浏览器的情况下,<code class="fe lr ls lt lu b">window</code>对象是全局对象。而在NodeJS环境中，一个叫做<code class="fe lr ls lt lu b">global</code>的特殊对象将是<code class="fe lr ls lt lu b">this</code>的值。</p><p id="6f8c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="97dd" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">立即调用函数表达式(life)</strong></h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="fee9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果为任何功能启用了严格模式，那么<code class="fe lr ls lt lu b">this</code>的值将被标记为<code class="fe lr ls lt lu b">undefined</code>,如同在严格模式中一样。全局对象引用<code class="fe lr ls lt lu b">undefined</code>代替<code class="fe lr ls lt lu b">windows</code>对象。</p><p id="7ade" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ff38" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">foo();</code>将false打印到控制台，因为在严格模式下，全局执行上下文中<code class="fe lr ls lt lu b">this</code>的值是<code class="fe lr ls lt lu b">undefined</code>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="912f" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">“这”是指一个新的实例</strong></h1><p id="2be8" class="pw-post-body-paragraph kv kw it kx b ky ni ju la lb nj jx ld le nk lg lh li nl lk ll lm nm lo lp lq im bi translated">当用<code class="fe lr ls lt lu b">new</code>关键字调用一个函数时，这个函数被称为构造函数，并返回一个新的实例。在这种情况下，<code class="fe lr ls lt lu b">this</code>的值指的是一个新创建的实例。</p><p id="3148" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="675d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在<code class="fe lr ls lt lu b">person.displayName</code>的情况下，<code class="fe lr ls lt lu b">this</code>是指一个新的实例人，在<code class="fe lr ls lt lu b">person2.displayName()</code>的情况下，<code class="fe lr ls lt lu b">this</code>是指<code class="fe lr ls lt lu b">person2</code>(与<code class="fe lr ls lt lu b">Person</code>是不同的实例)。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c420" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">“这个”是指一个调用程序对象(父对象)</strong></h1><p id="4614" class="pw-post-body-paragraph kv kw it kx b ky ni ju la lb nj jx ld le nk lg lh li nl lk ll lm nm lo lp lq im bi translated">在JavaScript中，对象的属性可以是方法或简单的值。当一个对象的方法被调用时，那么<code class="fe lr ls lt lu b">this</code>指的是包含被调用方法的对象。</p><p id="2a79" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这个例子中，我们将使用第一个例子中定义的方法<code class="fe lr ls lt lu b">foo</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d4a1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">user.foo()</code>打印false，因为现在<code class="fe lr ls lt lu b">this</code>引用用户对象而不是全局对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="608a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">通过上面的例子，很清楚<code class="fe lr ls lt lu b">this</code>的值在某些情况下是如何令人困惑的。</p><p id="79b4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">foo1</code>的函数定义是相同的，但是当它作为一个简单的函数调用被调用时，那么<code class="fe lr ls lt lu b">this</code>指的是一个全局对象。当同一个定义作为一个对象的方法被调用时，那么<code class="fe lr ls lt lu b">this</code>引用父对象。所以<code class="fe lr ls lt lu b">this</code>的值取决于方法是如何被调用的。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8208" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">“此”同调用和应用方法</strong></h1><p id="4333" class="pw-post-body-paragraph kv kw it kx b ky ni ju la lb nj jx ld le nk lg lh li nl lk ll lm nm lo lp lq im bi translated">JavaScript中的函数也是一种特殊类型的对象。每个函数都有<code class="fe lr ls lt lu b">call</code>、<code class="fe lr ls lt lu b">bind</code>和<code class="fe lr ls lt lu b">apply</code>方法。这些方法可用于在函数的执行上下文中为<code class="fe lr ls lt lu b">this</code>设置一个自定义值。</p><p id="6a1b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将使用上面定义的第二个例子来解释<code class="fe lr ls lt lu b">call</code>的用法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0050" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">call</code>和<code class="fe lr ls lt lu b">apply</code>方法之间的唯一区别是传递参数的方式。在<code class="fe lr ls lt lu b">apply</code>的情况下，第二个参数是一个参数数组，而在<code class="fe lr ls lt lu b">call</code>方法的情况下，参数是单独传递的。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="bbf0" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">“这个”用的是绑定方法</strong></h1><p id="63a4" class="pw-post-body-paragraph kv kw it kx b ky ni ju la lb nj jx ld le nk lg lh li nl lk ll lm nm lo lp lq im bi translated"><code class="fe lr ls lt lu b">bind</code>方法返回一个新方法，其中<code class="fe lr ls lt lu b">this</code>引用传递的第一个参数。我们将使用上面的例子来解释<code class="fe lr ls lt lu b">bind</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="338c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">“this”带有粗箭头功能</strong></h1><p id="8702" class="pw-post-body-paragraph kv kw it kx b ky ni ju la lb nj jx ld le nk lg lh li nl lk ll lm nm lo lp lq im bi translated">作为ES6的一部分，引入了一种新的方法来定义函数。</p><p id="c3d3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让displayName = (fn，ln) =&gt; {</p><p id="9030" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">console.log(名称:$ { fn } $ { ln })；</p><p id="b424" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi">};</p><p id="834f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当使用粗箭头时，它不会为<code class="fe lr ls lt lu b">this</code>创建新值。<code class="fe lr ls lt lu b">this</code>继续引用它在函数外引用的同一个对象。</p><p id="a51e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们再看一些例子来测试我们对<code class="fe lr ls lt lu b">this</code>的知识。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7a42" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因为回调是作为一个简单的函数调用在一个多重函数中被调用的，<code class="fe lr ls lt lu b">this</code>引用回调方法的执行上下文中的全局对象<code class="fe lr ls lt lu b">windows</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ce23" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">test()</code>打印true，因为<code class="fe lr ls lt lu b">count</code>变量声明发生在全局执行上下文中，所以<code class="fe lr ls lt lu b">count</code>将成为全局对象的一部分。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="497e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">总结</strong></h1><p id="b4b3" class="pw-post-body-paragraph kv kw it kx b ky ni ju la lb nj jx ld le nk lg lh li nl lk ll lm nm lo lp lq im bi translated">所以现在你可以通过遵循这些简单的规则计算出<code class="fe lr ls lt lu b">this</code>的值:</p><ul class=""><li id="c50d" class="lv lw it kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">默认情况下，<code class="fe lr ls lt lu b">this</code>是指一个全局对象，对于NodeJS来说是全局的，对于浏览器来说是一个<code class="fe lr ls lt lu b">window</code>对象</li><li id="bfd5" class="lv lw it kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">当一个方法作为一个对象的属性被调用时，那么<code class="fe lr ls lt lu b">this</code>指的是父对象</li><li id="38cd" class="lv lw it kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">当用<code class="fe lr ls lt lu b">new</code>操作符调用一个函数时，那么<code class="fe lr ls lt lu b">this</code>引用新创建的实例</li><li id="c5f7" class="lv lw it kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">当使用<code class="fe lr ls lt lu b">call</code>和<code class="fe lr ls lt lu b">apply</code>方法调用函数时，<code class="fe lr ls lt lu b">this</code>引用作为<code class="fe lr ls lt lu b">call</code>或<code class="fe lr ls lt lu b">apply</code>方法的第一个参数传递的值</li></ul><p id="0d65" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如你在上面看到的，<code class="fe lr ls lt lu b">this</code>的值有时会令人困惑，但是上面的规则可以帮助你计算出<code class="fe lr ls lt lu b">this</code>的值。</p></div></div>    
</body>
</html>