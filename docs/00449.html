<html>
<head>
<title>Surviving RxSwift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">幸存的RxSwift</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/surviving-rxswift-d6bfe562fb22?source=collection_archive---------3-----------------------#2019-05-23">https://betterprogramming.pub/surviving-rxswift-d6bfe562fb22?source=collection_archive---------3-----------------------#2019-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1328" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">最佳实践以及如何理解Swift中的反应式编程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f76ffe3dac6fb7e98aa8f919f9d8a023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cr69nK8irBt76zOkoQbJLw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://burst.shopify.com/laptop?utm_campaign=photo_credit&amp;amp;utm_content=Browse+Free+HD+Images+of+Shocked+Bitcoin+Investor+On+Laptop&amp;amp;utm_medium=referral&amp;amp;utm_source=credit" rel="noopener ugc nofollow" target="_blank">爆裂</a>的<a class="ae ky" href="https://burst.shopify.com/@sarahpflugphoto?utm_campaign=photo_credit&amp;amp;utm_content=Browse+Free+HD+Images+of+Shocked+Bitcoin+Investor+On+Laptop&amp;amp;utm_medium=referral&amp;amp;utm_source=credit" rel="noopener ugc nofollow" target="_blank">莎拉·普弗卢格</a>的照片</p></figure><p id="8c7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我开始之前，我需要提到这些是我个人用来最大限度地利用RxSwift并避免许多常见陷阱的一组最佳实践。它们绝不是一套适用于所有人的硬性规定，但我鼓励你去尝试一下。</p><h1 id="ee7e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">为什么要用Rx？</h1><p id="78cf" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果这么多人纠结Rx，那到底为什么还要用？这是一个完全合理的问题。</p><p id="3c78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的职业中，有很多方法可以解决问题，Rx也不例外。Rx有一个陡峭的学习曲线，通常不清楚解决问题的一种方法是否比另一种更好。弄清楚其中的微妙之处需要时间，但是当你做到的时候是非常值得的。</p><p id="394a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用Rx的原因在于它最大的优势:能够从许多来源获取输入，驯服组合它们所需的通常复杂的逻辑，并留给您随时更新输入的输出。</p><p id="ac14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着，如果你遵循SRP之类的原则，你通常不需要对单个的、较低层次的组件进行Rx。然而，它的力量在更高层次上变得非常明显。</p><p id="0773" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住这一点，让我们开始吧。</p><h1 id="5245" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">谨慎使用</h1><p id="7f69" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我工作过的、听到人们抱怨的最有问题的Rx代码库是那些使<em class="lv">每个部分</em>都反应的代码库。你用的Rx越多，你的堆栈痕迹就越大越可怕。穿过一个长的反应链是很难的，操作者只能帮你做到这一步。</p><p id="1a9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我前面提到的，我的解决方案是<em class="lv">仅</em>在更高层次的组件中使用Rx，比如视图模型和视图控制器。</p><p id="5370" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是…我们如何让所有这些非Rx的东西在Rx中工作呢？</p><h1 id="0e56" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">在Rx中包装组件</h1><p id="ee90" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们可以构建组件，比如API层，使用更广泛理解的范例，比如闭包，来异步交付东西。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0ae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让Rx很好地工作，我们只需要几行代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="57fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了它，我们的<code class="fe mt mu mv mw b">APIClient</code>现在可以轻松用于Rx链。那么这样做的好处是什么呢？</p><p id="55d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调试现在容易多了，我们可以在非Rx代码中设置断点，并且在没有Rx添加到堆栈跟踪中的所有额外噪声的情况下单步执行。我们也可以使用标准的XCTest框架编写测试。最后，我们有了一个更加可移植的组件——现在没有什么可以阻止我们在其他可能不使用Rx的应用程序中使用相同的API层。</p><h1 id="5a5d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">你不需要大多数特质</h1><p id="1ac8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">RxSwift提供了广泛的<a class="ae ky" href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md" rel="noopener ugc nofollow" target="_blank">特质</a>。特征是标准<code class="fe mt mu mv mw b">Observable</code>的包装，提供额外的语义/行为。这听起来可能很棒——毕竟我们想利用Swifts的类型系统，对吗？对于上面的API层例子，使用<code class="fe mt mu mv mw b">Single</code>而不是<code class="fe mt mu mv mw b">Observable</code>的代码是很常见的。</p><p id="73ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些不同特征的问题是它们并不总是很好地组合在一起。有许多自定义扩展可以帮助它们之间的转换。只要坚持使用标准的<code class="fe mt mu mv mw b">Observable</code>，你就可以避免跳过所有这些关卡。回避特质没有坏处。</p><p id="fa9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">眼尖的读者会发现标题中的“最多”。这个有一个例外！当你为你的视图公开要消费的值时，你100%应该使用像<code class="fe mt mu mv mw b">Driver</code>这样的RxCocoa特征，以及当你使用像<code class="fe mt mu mv mw b">UIButton.rx.tap</code>这样的属性时遇到的<code class="fe mt mu mv mw b">ControlEvent</code>或<code class="fe mt mu mv mw b">ControlProperty</code>。这是因为这些特征是专门为与用户界面交互而设计的。它们将确保共享值，并且所有事情都发生在主线程上。</p><h1 id="0a46" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">回避主题</h1><p id="3eb7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在学习Rx时，你需要改变对数据的看法。其中最大的一个挑战是学习构造流，使得从流中输出的值是组合和/或转换在流中发送的值的结果。一种简单的思考流的方式就像一个映射函数<code class="fe mt mu mv mw b">(A) -&gt; B</code>或<code class="fe mt mu mv mw b">(A, B) -&gt; C</code></p><p id="d5bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，当这种转变还没有发生时，你会看到代码依赖于主题来弥补差距。主题是Rx中既是输入<em class="lv">又是输出</em>的对象。可以订阅它们，也可以向它们发送传入的值。</p><p id="8089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个用于执行搜索的视图模型的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6f1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就其本身而言，这看起来非常简单。收到一些文本，我们用它来进行搜索。由此，我们可以定义另外两个流，一个用于结果列表，一个用于显示计数的字符串。</p><p id="57aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，因为<code class="fe mt mu mv mw b">searchText</code>既是输入<em class="lv">又是输出</em>，我们意外地在视图模型中引入了一个额外的输出。我们没有办法阻止其他东西订阅<code class="fe mt mu mv mw b">searchText</code>并执行其他代码。如果这是您需要做的事情，那么您应该:</p><ul class=""><li id="6597" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">直接订阅底层输入源(即文本字段)；或者</li><li id="c93c" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">为此行为创建另一个显式输出</li></ul><p id="ac27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于没有在输入和输出之间建立明确的界限，调试值可能来自哪里变得更加困难。也很难推断系统的输入和输出实际上是什么。</p><p id="5d5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们看看如何重构同一个视图模型来删除主题的使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="491a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的变化非常微妙。我们要求输入通过构造函数传递。这种变化对输入和输出的内容提供了更细粒度的控制。我们现在有一个单一的起点来搜索与文本输入和搜索结果输出相关的错误。</p><blockquote class="nn no np"><p id="edc1" class="kz la lv lb b lc ld ju le lf lg jx lh nq lj lk ll nr ln lo lp ns lr ls lt lu im bi translated"><em class="it">值得注意的是，当然，还有其他方法可以移除/封装主题。</em></p></blockquote><p id="5057" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，这也有例外，但我不打算在这里深入讨论…如果你真的觉得你需要使用主题，至少要确保你把它们封装起来，这样它们就不会公开暴露给任何随机代码与之交互。然而，我鼓励你尽可能地避免它们！</p><h1 id="0123" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">将DisposeBags限制为查看控制器</h1><p id="9975" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在我提到的转变发生之前，你会看到的另一个问题是<code class="fe mt mu mv mw b">DisposeBag</code>在它们不属于的地方。一个<code class="fe mt mu mv mw b">DisposeBag</code>是持有订阅的东西。订阅是你使用<code class="fe mt mu mv mw b">subscribe</code>、<code class="fe mt mu mv mw b">drive</code>或<code class="fe mt mu mv mw b">bind</code>等功能时得到的。这些订阅也是你的应用程序副作用被包含的地方。</p><p id="7633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些订阅应该仅限于您的视图控制器。像视图模型这样的其他组件不应该包含订阅，因为它们不应该包含副作用。</p><p id="fdaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，如上所述，这个问题经常出现在主语被误用的时候。经常看到订阅直接调用<code class="fe mt mu mv mw b">onNext</code>这样的函数。这表明您的流输出没有被建模为它们输入的转换。</p><p id="a33d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和其他的一样，这个也有罕见的例外。如果由于某种原因，流没有输出，您可能需要一个单独的私有订阅来确保流被启用。但是，与其他例外情况一样，尽最大努力避免这种情况。</p><h1 id="d9a6" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">摘要</h1><p id="757a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">所以快速总结一下:</p><ul class=""><li id="9c7e" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">将Rx限制到更高级别的组件，如视图模型和视图控制器。</li><li id="30d6" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">构建不带Rx的低级组件，然后添加Rx包装扩展。</li><li id="642f" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">把自己限制在<code class="fe mt mu mv mw b">Observable</code>和<code class="fe mt mu mv mw b">Driver</code>。</li><li id="e4e0" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">写你的Rx尽量不带主语。</li><li id="c877" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe mt mu mv mw b">DisposeBag</code> s真的只属于视野控制者。</li></ul><p id="77b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我强烈建议任何刚接触Rx或者正被它弄得不知所措的人，用这些技巧来简化你的使用。随着你对Rx越来越熟悉，你会开始意识到这些技巧何时、如何适用，以及何时不适用。</p></div></div>    
</body>
</html>