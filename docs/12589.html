<html>
<head>
<title>Django Performance Improvements — Optimising the Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django性能改进—优化数据库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/django-performance-improvements-f9d0324f9f45?source=collection_archive---------3-----------------------#2022-06-15">https://betterprogramming.pub/django-performance-improvements-f9d0324f9f45?source=collection_archive---------3-----------------------#2022-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f76c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第1部分，共4部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/66053be48748cd0b37f77d76b5ded0f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fcg7XfsjJu-e-fxH"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@ivvndiaz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊万·迪亚兹</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e31b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Django项目中优化的主要目标是通过确保您的项目通过充分利用系统资源来运行，从而使执行数据库查询更快。适当优化的数据库将减少响应时间，从而提供更好的用户体验。</p><p id="5b21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个4部分系列中，您将学习如何优化Django应用程序的不同领域。</p><p id="27fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一部分将着重于优化Django应用程序中的数据库速度。</p><h1 id="27fc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">理解查询</h1><p id="8f0c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">理解querysets如何工作将会产生更好的代码。在进行任何优化之前，首先要理解这些概念:</p><ol class=""><li id="56e8" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">Querysets是懒惰的:您可以编写任意多的查询，但是Django只会在查询被求值时从数据库中查询。</li><li id="b3f3" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">总是通过指定应该返回多少个值来限制从数据库中获得的结果。</li><li id="f09a" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">在Django中，您可以通过迭代、切片、缓存和python方法(如<code class="fe nd ne nf ng b">len()</code>、<code class="fe nd ne nf ng b">count()</code>、e.t.c)来评估您的<code class="fe nd ne nf ng b">queryset</code>，因此请确保您充分利用它们。</li><li id="10a9" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">Django在每个queryset中执行缓存，以最小化数据库访问。理解缓存的工作原理将使您能够编写更好、更高效的代码。</li><li id="e368" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">只取回你需要的东西</li><li id="ccf3" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">如果你认为你以后会用到它，立刻取回所有东西</li><li id="1b95" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">总是在数据库中而不是在Python中执行数据库工作</li></ol><h1 id="744a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">查询优化</h1><p id="ad7a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">数据库是任何应用程序的核心。与信念相反，复杂性并不总是保证效率。Postgresql是Django应用程序的首选数据库，因为它是开源的，也是复杂查询的理想选择。</p><p id="6cdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了优化任何Django应用程序中的查询，我们将覆盖以下领域来执行数据库优化，即:</p><ol class=""><li id="da39" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">数据库索引</li><li id="ef37" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">贮藏</li><li id="64d6" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">选择相关与提取相关</li><li id="12ad" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">散装法</li><li id="cd64" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">RawSql</li><li id="a070" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">外键</li></ol><h1 id="a6cf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.数据库索引</h1><p id="0750" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">数据库索引是一种用于在从数据库中检索记录时加速查询的技术。当处理产生大量数据的大型数据库时，索引是提高应用速度的不可避免的做法。</p><p id="b95a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着应用程序变得越来越重要，它可能会变慢，用户会注意到这一点，因为获取所请求的数据将花费相当长的时间。为了说明这一点，我们将使用一个电子商务商店的例子，该商店有一个桌子产品，型号如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1d13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着数据库的增长，您可能会注意到检索数据需要很长时间。例如，假设您希望对price列应用索引以加快对该列的搜索。</p><pre class="kg kh ki kj gt nj ng nk nl aw nm bi"><span id="96a1" class="nn lt iq ng b gy no np l nq nr">price = models.DecimalField(decimal_places= 2,max_digits=8,db_index=True)</span></pre><p id="b915" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用索引后，您需要运行迁移，以便创建索引。</p><p id="b06e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样重要的是要注意，如果表有很多行，那么创建索引就需要更长的时间。您也可以为两个字段创建单个索引:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="16fd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.贮藏</h1><p id="d6e6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">数据库中的缓存是快速响应的最佳方法。它确保很少调用数据库，防止数据库过载。标准缓存结构如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/0e6c848f73a4f6c267163ceff038c2d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u24mXiY4ErK7oZ-J.png"/></div></div></figure><p id="ce6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Django提供了一种缓存机制，可以使用不同的缓存后端，比如Memcached和Redis，这样可以避免多次运行查询。</p><p id="030a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Memcached是一个简单而强大的开源内存系统，保证在不到一毫秒的时间内返回缓存的结果。Memcached也易于使用和扩展。</p><p id="b1b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，Redis也是一个开放源码的缓存系统，提供与Memcached相同的功能。大多数离线应用程序使用已经缓存的数据，这意味着大多数请求甚至不会命中数据库。</p><p id="d091" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用户会话应该存储在Django应用程序的缓存中，因为redis将数据保存在磁盘中，所以登录用户的所有会话不是来自数据库，而是来自缓存。要启用redis数据库缓存，您需要通过pip安装redis。</p><pre class="kg kh ki kj gt nj ng nk nl aw nm bi"><span id="cce4" class="nn lt iq ng b gy no np l nq nr">pip install redis</span></pre><p id="32bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦安装了<a class="ae kv" href="https://docs.djangoproject.com/en/4.0/topics/cache/" rel="noopener ugc nofollow" target="_blank"> redis </a>，在settings.py文件中添加以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0956" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还可以使用Memcached和Redis来存储用户身份验证令牌。因为每个登录的用户都必须提供一个令牌，所以所有这些操作都会导致数据库的高开销。从缓存中获取令牌将使数据库的性能更快。</p><h1 id="b60e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.选择相关与预取相关</h1><p id="edfd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Django提供了优化查询集的参数，称为select related和<code class="fe nd ne nf ng b">prefetch_related</code>。这两种方法减少了对数据库的查询次数。例如，考虑下面有两个表的模型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1879" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">person表与tweet表有一对多的关系，即一个人可以有很多条Tweet，但是一条Tweet只能属于一个人。假设您想找出数据库中所有tweet的详细信息，您首先要获取所有tweet。</p><p id="2f83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了获得额外的信息，例如<code class="fe nd ne nf ng b">first_names</code>和<code class="fe nd ne nf ng b">last_name</code>，您需要进行如下额外的查询:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="9728" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所示，这会产生9个查询。</p><h2 id="0be5" class="nn lt iq bd lu nt nu dn ly nv nw dp mc lf nx ny me lj nz oa mg ln ob oc mi od bi translated">选择_相关</h2><p id="eed6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">使用<code class="fe nd ne nf ng b">select_related</code>，您可以进行单个查询，为单个实例返回一对多和一对一关系的所有相关对象。select_related是一个在外键关系上使用的查询，用于在执行查询时检索任何附加的相关对象数据。</p><p id="182c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然<a class="ae kv" href="https://docs.djangoproject.com/en/4.0/ref/models/querysets/#select-related" rel="noopener ugc nofollow" target="_blank"> select_related </a>会导致更复杂的查询，但是获得的数据会被缓存；因此，对获得的数据的操作将不需要任何额外的数据库查询。</p><p id="cc12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用<code class="fe nd ne nf ng b">select_related</code>执行同样的查询。</p><pre class="kg kh ki kj gt nj ng nk nl aw nm bi"><span id="3238" class="nn lt iq ng b gy no np l nq nr">queryset = Tweet.objects.select_related('owner').all()</span></pre><p id="76a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码将一次获得所有的tweets和个人数据，只产生一个查询。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="f7c1" class="nn lt iq bd lu nt nu dn ly nv nw dp mc lf nx ny me lj nz oa mg ln ob oc mi od bi translated">预取相关</h2><p id="7aa1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">另一方面，<code class="fe nd ne nf ng b">prefetch_related</code>用于多对多和多对一的关系。它为查询中指定的所有模型和过滤器生成一个单一的查询。</p><p id="9675" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设您有以下模型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="febb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们把所有的电影和相关演员都拿来:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1f56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在上面看到的，每次迭代都会产生一个额外的查询。</p><p id="4c95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们使用预取来运行相同的查询。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2b97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在上面看到的，查询计数现在是2，第一个查询获取数据库中的所有电影，第二个和第三个请求只产生一个查询。</p><h1 id="99a2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.散装法</h1><p id="17d0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">批处理是检索查询的另一种代码性能方式。</p><p id="1afa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当需要向数据库中添加多条记录时，最有效的方法是一次创建所有对象。幸运的是，Django为此提供了<code class="fe nd ne nf ng b">bulk_create()</code>方法。<code class="fe nd ne nf ng b">bulk_create</code>不是一次创建一个实例，然后返回它，这会使数据库过载，而是提交所有实例并执行一个保存查询:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0f7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也可以做<code class="fe nd ne nf ng b"><a class="ae kv" href="https://docs.djangoproject.com/en/4.0/ref/models/querysets/#bulk-update" rel="noopener ugc nofollow" target="_blank">bulk_create</a></code> <a class="ae kv" href="https://docs.djangoproject.com/en/4.0/ref/models/querysets/#bulk-update" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe nd ne nf ng b"><a class="ae kv" href="https://docs.djangoproject.com/en/4.0/ref/models/querysets/#bulk-update" rel="noopener ugc nofollow" target="_blank">bulk_update()</a></code>。例如，假设您需要用一个特定值更新数据库中的一列；最有效的方法是如下使用<code class="fe nd ne nf ng b"><a class="ae kv" href="https://docs.djangoproject.com/en/4.0/ref/models/querysets/#bulk-create" rel="noopener ugc nofollow" target="_blank">bulk_update</a></code>。</p><pre class="kg kh ki kj gt nj ng nk nl aw nm bi"><span id="d70b" class="nn lt iq ng b gy no np l nq nr">Model.objects.filter(name= 'name').update(name='someothername')</span></pre><h1 id="7e08" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.RawSql</h1><p id="f548" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">不推荐使用RawSQL，因为Django提供了一流的查询机制，保证…你能想到的每一个函数。</p><p id="ca0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Django ORM可以处理您的应用程序中几乎所有需要的功能，但有时这是必要的。在数据库而不是Python上执行SQL查询会带来更快的性能。RawSQL应该作为最后的手段使用。</p><h1 id="56d2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">6.外键</h1><p id="8381" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">外键也可以用来获取数据，而不会对数据库造成额外的压力。例如，如果你想获得一条推文的拥有者，推荐且最有效的方法是:</p><pre class="kg kh ki kj gt nj ng nk nl aw nm bi"><span id="b698" class="nn lt iq ng b gy no np l nq nr">tweet = Tweet.objects.get(id=1).owner</span></pre><h1 id="01d4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">监控数据库操作</h1><p id="2b81" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在生产中监控数据库操作是一种很好的做法。它允许您查看针对数据库运行的查询以及出现了什么错误。你可以通过不时查看你的Postgres或Django日志来做到这一点。更简单地说，Sentry是监控数据库操作的一个很好的工具。</p><p id="1fd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Sentry提供了一个仪表板，用于监控Django应用程序中的数据库操作。如果出现与数据库相关的错误，您可以实时查看并在您的用户注意到之前解决它。</p><p id="e195" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生产中的错误很难被发现，因为你没有调试器。Sentry通过允许您查看数据库中的每个错误来解决这个问题。</p><p id="4a90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，在这里创建一个哨兵账户<a class="ae kv" href="https://sentry.io/signup" rel="noopener ugc nofollow" target="_blank">。您将能够选择使用哪种技术。选择Django然后点击<strong class="ky ir">创建项目</strong>。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/e6c17e05e5b12f64694558b049152ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xzxLe0-qMB5uW2AJ.png"/></div></div></figure><p id="26cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，通过pip安装Sentry。</p><pre class="kg kh ki kj gt nj ng nk nl aw nm bi"><span id="f5dd" class="nn lt iq ng b gy no np l nq nr">pip install --upgrade sentry-sdk</span></pre><p id="62ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一步是添加以下代码，它将您的公钥集成到Django应用程序的settings.py文件中。</p><p id="00ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://gist.github.com/essykings/5fb4630de1a789219b27f143d24ddaae" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/essykings/5fb 4630 de 1a 789219 b 27 f 143d 24 ddaae</a></p><p id="847c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Sentry现在准备好监控您的应用程序。</p><p id="1744" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在数据库中创建一个与数据库相关的错误，看看Sentry是否可以向我们显示原因。这是我在本地生产中遇到的一个示例错误，它是由检索数据库中不存在的产品引起的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/6dcf09bca1bd420b6aa73683720decf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*s6KMjwdGA08wcUQS.png"/></div></div></figure><p id="e5cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个错误也将出现在您的哨兵仪表板如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/67deeb1bbc5423bdcfbf9542166d1c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VVeqN2mvUnKWGDqE.png"/></div></div></figure><p id="ec4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Django还提供了像Django Debug toolbar这样的工具，它可以监控您的数据库，您可以实时看到请求和响应过程。它还允许您查看每个响应从数据库获取数据需要多长时间。</p><p id="8f4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装<a class="ae kv" href="https://django-debug-toolbar.readthedocs.io/en/latest/installation.html" rel="noopener ugc nofollow" target="_blank"> Django调试工具栏</a>的推荐方式是使用pip:</p><pre class="kg kh ki kj gt nj ng nk nl aw nm bi"><span id="51da" class="nn lt iq ng b gy no np l nq nr">python -m pip install django-debug-toolbar</span></pre><p id="74fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦你安装了Django调试工具栏，它需要在Django项目中<a class="ae kv" href="https://django-debug-toolbar.readthedocs.io/en/latest/installation.html" rel="noopener ugc nofollow" target="_blank">配置</a>。</p><p id="269c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是显示Django调试工具栏运行的屏幕截图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/834ae164ffd5118aacc3d03e30870b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xKaP_BLPR1PneGIw.png"/></div></div></figure><p id="a7c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Django调试工具栏的缺点是在呈现页面时增加了开销，因此不适合构建。Sentry是首选，因为它可以让您保持对bug的关注，给出关于数据库的详细跟踪轨迹，还可以让您解决问题。</p><h1 id="1227" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="f374" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">本教程介绍了使用Django提高Django应用程序性能的方法，这些方法也很容易实现。给他们一个机会，请继续关注本系列的第2-4部分。</p></div></div>    
</body>
</html>