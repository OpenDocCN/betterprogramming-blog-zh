<html>
<head>
<title>11 JavaScript One-Liners That’ll Make You a Ninja Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让你成为忍者开发者的11个JavaScript一行程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/11-javascript-one-liners-thatll-make-you-a-ninja-developer-4a15ac592669?source=collection_archive---------7-----------------------#2021-08-31">https://betterprogramming.pub/11-javascript-one-liners-thatll-make-you-a-ninja-developer-4a15ac592669?source=collection_archive---------7-----------------------#2021-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6679" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在六分钟内提升你的JavaScript知识</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/15dd7f6cb48c05dfe501ac1a0ada0001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0cdO9m9hUIpnXxJefPrHlw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.pexels.com/photo/light-fashion-man-people-7792259/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae ky" href="https://www.pexels.com/@cottonbro?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> cottonbro </a>摄影</p></figure><blockquote class="kz la lb"><p id="928b" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">比尔·盖茨说:“我选择一个懒惰的人去做一件艰难的工作。因为一个懒惰的人会找到一个简单的方法去做。”</p></blockquote><p id="cf5b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">作为一名开发人员，我们通常会尽量避免写很长的代码。我的意思是，没有人愿意写500行代码，而不是用50行代码写同样的功能。<br/> <br/>成为一名忍者开发者也意味着找到一种简单的方法来完成一项任务——写五十行代码，而不是写五百行代码。忍者开发者也喜欢使用一行程序。他们有一套将长行代码转换成单行代码的技能。<br/> <br/>学会这11个JavaScript一行程序后，最有可能的是，比尔·盖茨可能想雇佣你做开发人员。</p><h1 id="4de5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.找出最短的长度</h1><p id="f5d1" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">使用这个函数，你将找到给定字符串中单词的最短长度。我们可以从<code class="fe mz na nb nc b">split(), sort() and pop()</code>等一些功能中得到帮助。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="461b" class="nh md it nc b gy ni nj l nk nl">const findShort = (s) =&gt; s.split(' ').sort((a, b) =&gt; b.length - a.length).pop().length;</span><span id="2ba3" class="nh md it nc b gy nm nj l nk nl">console.log(findShort("It's an amazing day to code"));<br/>// Result: 2<br/>console.log(findShort("Lorem Ipsum"));<br/>// Result: 5</span></pre><h1 id="7230" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.返回单词的中间字符</h1><p id="e886" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">这个函数返回一个单词的中间字符。如果给这个函数一个奇数长度的单词，它将返回中间的字符。但是，如果给定长度为偶数的单词，它将返回中间的两个字符。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9e5b" class="nh md it nc b gy ni nj l nk nl">const getMiddle = s =&gt; s.substring(Math.ceil(s.length/2)-1, Math.floor(s.length/2)+1);</span><span id="0a20" class="nh md it nc b gy nm nj l nk nl">console.log(getMiddle("Amazing"));<br/>// Result: z</span><span id="985c" class="nh md it nc b gy nm nj l nk nl">console.log(getMiddle("Rubber"));<br/>// Result: bb</span></pre><h1 id="df62" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.将零移动到末尾</h1><p id="0d89" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">函数<code class="fe mz na nb nc b">moveZeros()</code>接受一个数组并将所有的零移动到末尾。在这样做的同时，它还保留了其他元素的顺序。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5745" class="nh md it nc b gy ni nj l nk nl">let moveZeros = (arr) =&gt; arr.filter(i =&gt; i !== 0).concat(arr.filter(i =&gt; i === 0));</span><span id="e79f" class="nh md it nc b gy nm nj l nk nl">console.log(moveZeros([false, 1, 0, true, 1, 2, 5, 0, 1, 3, "Ajax"]));</span><span id="bc12" class="nh md it nc b gy nm nj l nk nl">// Result: [false, 1, true, 1, 2, 5, 1, 3, "Ajax", 0, 0]</span></pre><h1 id="2fc3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.数组差异</h1><p id="2eec" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">如果您想从一个数组中减去另一个数组并返回差值，这是一个非常好的方法。它保留了结果列表中其他元素的顺序。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f0d1" class="nh md it nc b gy ni nj l nk nl">var array_diff = (a, b) =&gt; a.filter(item =&gt; b.indexOf(item) &lt; 0)</span><span id="86d9" class="nh md it nc b gy nm nj l nk nl">console.log(arrayDiff([1, true, "1", "2", 2, 5, 3], [false, "8", 3, 1]));<br/>// Result: [true, "1", "2", 2, 5]</span><span id="3099" class="nh md it nc b gy nm nj l nk nl">console.log(arrayDiff([1, true, "1", "2"], [1, true, "1", "2", 3]));<br/>// Result: []</span></pre><h1 id="400f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.消除字符串中的元音</h1><p id="e09d" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">使用<code class="fe mz na nb nc b">eliminateVowels()</code>功能，你可以删除给定字符串中的元音。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8af8" class="nh md it nc b gy ni nj l nk nl">const eliminateVowels = s =&gt; s.replace(/[aeiou]/gi, '');</span><span id="d0de" class="nh md it nc b gy nm nj l nk nl">console.log(eliminateVowels("The Master Splinter Developer"));<br/>// Result: Th Mstr Splntr Dvlpr</span></pre><h1 id="6f16" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.无线电紧急呼救信号</h1><p id="54f5" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">使用这个函数，您可以检查在给定的字符串中是否有相同数量的“O”和“S”。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a341" class="nh md it nc b gy ni nj l nk nl">const SOS = s =&gt; s.replace(/o/ig, '').length == s.replace(/s/ig, '').length;</span><span id="b1d2" class="nh md it nc b gy nm nj l nk nl">console.log(SOS("SOS"));<br/>// Result: False</span><span id="cbdd" class="nh md it nc b gy nm nj l nk nl">console.log(SOS("So so"));<br/>// Result: True</span><span id="a7bc" class="nh md it nc b gy nm nj l nk nl">console.log(SOS(""));<br/>// Result: True</span></pre><h1 id="4a15" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.降序排列的整数位数</h1><p id="501a" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">您可以使用此函数返回一个数字降序排列的整数。如果你给这个函数一个非负整数会有所帮助。</p><p id="bb97" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">该函数将把数字重新排列到整数中可能的最高数字。在这个函数中，我们会得到一些内置函数的帮助，这些函数就是<code class="fe mz na nb nc b">parseInt(), toString(), split(), sort(), reverse(), and join()</code>。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4a38" class="nh md it nc b gy ni nj l nk nl">const descendingOrder = n =&gt; parseInt(n.toString().split("").sort().reverse().join(""));</span><span id="4472" class="nh md it nc b gy nm nj l nk nl">console.log(descendingOrder(234782)); // Result: 874322<br/>console.log(descendingOrder(10010101010)); // Result: 11111000000<br/>console.log(descendingOrder(123456)); // Result: 654321</span></pre><h1 id="1a46" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">8.找出奇数次出现的整数</h1><p id="5f57" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">这个函数将帮助你找到一个在给定数组中出现奇数次的整数。这个功能有一个不好的地方。如果你给出一个以上奇数次出现的整数，那就不行。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="95c4" class="nh md it nc b gy ni nj l nk nl">const findOdd = (a) =&gt; a.reduce((a, b) =&gt; a ^ b);</span><span id="32b2" class="nh md it nc b gy nm nj l nk nl">console.log(findOdd([1, 2, 2, 1])); // Result: 0<br/>console.log(findOdd([1, 2, 2, 1, 2, 3, 3])); // Result: 2<br/>console.log(findOdd([1, 2, 3, 4])); // Result: 4 -&gt; Not working</span></pre><h1 id="a275" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">9.找出给定数组的最大子数组和</h1><p id="ec73" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">使用这个函数，您可以找到给定数组的最大子数组和。这是一个需要解决的大问题。不容易解决。尤其是如果你想用一行程序实现这个功能，就更有挑战性了。但是，你可以从一个内置函数得到帮助，这个函数就是<code class="fe mz na nb nc b">reduce()</code>。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="52b3" class="nh md it nc b gy ni nj l nk nl">const maxSequence = (a,sum=0) =&gt; a.reduce((max,v) =&gt; Math.max(sum = Math.max(sum + v, 0), max), 0);</span><span id="431e" class="nh md it nc b gy nm nj l nk nl">console.log(maxSequence([1,2,3,4])); // Result: 10<br/>console.log(maxSequence([1,2,3,4,-8])); // Result: 10<br/>console.log(maxSequence([1,-2,3,-2,5,-1,3,-9,1,6])); // Result: 8</span></pre><h1 id="70eb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">10.第二个数组的字符串包含第一个数组的字符串吗？</h1><p id="1933" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">你可以用这个函数来回答上面的问题。这个函数将返回一个按第一个数组中字符串的字典顺序排序的数组，这些字符串是第二个数组中字符串的子字符串。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="7395" class="nh md it nc b gy ni nj l nk nl">const inArray = (arr1, arr2) =&gt; arr1.filter(item =&gt; new RegExp(item).test(arr2)).sort()</span><span id="3124" class="nh md it nc b gy nm nj l nk nl">console.log(inArray(["Donald", "Strong", "The"],["Stronger, "More", "They"]));<br/>// Result: ["Strong", "The"]</span><span id="bfb5" class="nh md it nc b gy nm nj l nk nl">console.log(inArray(["Stronger", "More", "They"],["Donald, "Strong", "The"]));<br/>// Result: []</span><span id="0a87" class="nh md it nc b gy nm nj l nk nl">console.log(inArray(["Novice"],["NOVICE"]));<br/>// Result: []</span></pre><h1 id="57f6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">11.求3的前倍数</h1><p id="b66f" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">该函数删除最后一个数字，直到找到一个是3的倍数的数字。如果给定的参数已经是三的倍数，它将返回它。如果没有不是3的倍数的数字集合，它将返回null。<br/> <br/>自己用一个很好的例子，你可以考虑，如果一个整数的每一位数之和被三整除，那么这个整数就是三整除。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f53f" class="nh md it nc b gy ni nj l nk nl">const f = prevMultOfThree = n =&gt; n ? n % 3 ? f(n/10 |0) : n : null</span><span id="10bb" class="nh md it nc b gy nm nj l nk nl">console.log(prevMultOfThree(3)); // Result: 3<br/>console.log(prevMultOfThree(36)); // Result: 36<br/>console.log(prevMultOfThree(1236)); // Result: 1236<br/>console.log(prevMultOfThree(5245)); // Result: null<br/>console.log(prevMultOfThree(4552)); // Result: 45<br/>console.log(prevMultOfThree(11)); // Result: null</span></pre><h1 id="532b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="243b" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">今天，我向您展示了11个JavaScript一行程序。有些对你来说可能很容易，而有些却让你绞尽脑汁。学习这些一行程序中的内置函数也可以给你一个很好的视野。</p><p id="ce75" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">下一步，你可以找到一些问题，借助我给你看的一些内置函数，试着写成一行。这种实践将帮助你成为一名忍者开发者，比尔·盖茨可能会聘请他作为开发人员。</p></div></div>    
</body>
</html>