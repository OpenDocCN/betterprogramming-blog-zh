<html>
<head>
<title>Best Practices for Building Serverless Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建无服务器微服务的最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/best-practices-for-building-serverless-microservices-a30d5108900a?source=collection_archive---------6-----------------------#2022-08-24">https://betterprogramming.pub/best-practices-for-building-serverless-microservices-a30d5108900a?source=collection_archive---------6-----------------------#2022-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eed3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建微服务的标准化标准提供了任何人都可以使用和维护的强大、一致的软件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/90ab9372e9f2d8d8fce721a79435fcb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hs2VTZF4mzWs0RuJit6BOQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/www.freepik.com"> pch.vector </a>创建的训练向量</p></figure><p id="7e08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">微服务是个搞笑的词。</p><p id="0c93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不是说它听起来有趣或者拼写有趣。但是从某种意义上说，大多数开发者知道它的意思，然而他们不知道它的意思。</p><p id="845f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使你从未听说过这个短语，上下文线索也是相当容易的。这是一项小型服务。但是小是什么意思呢？</p><p id="bbe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尺寸小？要多大才算中等服务？</p><p id="2c99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">微服务不仅仅是规模。您有部署、存储库结构、领域、维护者、编码约定等等。在决定采用微服务架构时，您需要做出大量决策。</p><h1 id="465f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是微服务？</h1><p id="195b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">简单地说，微服务是一个可独立迭代的软件。</p><p id="9947" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们通常是大型应用程序的一部分。它不应该有需要同时部署其他微服务的硬性依赖关系。它需要能够独立部署。</p><p id="4916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，微服务具有依赖性是可以接受的。如果一个微服务触发了另一个微服务事件的工作流，这就是一个松散耦合的依赖关系。部署依赖和功能依赖之间有很大的区别。</p><p id="218a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">功能依赖要求存在其他服务来满足业务问题，而不是进行部署。</p><p id="bc4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何决定哪个微服务产生事件，哪个消费事件？</p><p id="1e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">微服务应该是<a class="ae ky" href="https://www.geeksforgeeks.org/domain-driven-design-ddd/" rel="noopener ugc nofollow" target="_blank">域驱动的</a>，这意味着它们负责一种类型的事情。换句话说，这种类型的架构为您的业务逻辑创建了一个关注点分离。</p><p id="de75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在经典的“购物车”示例中，您有几个微服务，每个微服务都有自己的职责。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/e6c6fe1e5a326d5a09eb5d1f407c374f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/0*SKGjGyRmZJMseacu.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="mt">组成购物车app的四个微服务</em></p></figure><p id="448b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当谈到增强时，上面的微服务每个都是独立可迭代的，并且具有松散耦合来处理<a class="ae ky" href="https://microservices.io/patterns/data/saga.html" rel="noopener ugc nofollow" target="_blank"> saga工作流</a>。但这里要注意的一点是，每个微服务负责一件事。Micro代表少量的责任，而不是少量的代码。</p><h1 id="749d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">无服务器最佳实践</h1><p id="7f95" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当考虑无服务器时，微服务架构非常适合。无服务器非常适合单一责任、专注的工作——这就是微服务的全部。</p><p id="fb85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下最佳实践旨在用作指南。这些对我所在的团队来说效果很好，但是当你把它们应用到你的项目中时，可能需要一些小的调整。</p><h2 id="50f2" class="mu lw it bd lx mv mw dn mb mx my dp mf li mz na mh lm nb nc mj lq nd ne ml nf bi translated">仓库</h2><p id="1f8b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在为应用程序构建存储库时，有两种思路:单一回购与多重回购。</p><p id="e128" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是一个单独的存储库，为不同的服务提供逻辑隔离。换句话说，所有的微服务将存在于同一个repo中，但是被不同的文件夹分开。</p><p id="b58a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单一回购的好处包括更容易被发现和治理。缺点包括应用程序扩展时存储库的大小、主分支中断时的大爆炸半径，以及所有权的模糊性。</p><p id="2d25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，每个微服务拥有一个存储库有其利弊。</p><p id="56ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多重回购的好处包括不同的领域边界、清晰的代码所有权以及简洁和最小的回购规模。缺点包括创建和维护多个存储库以及对所有存储库应用<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/going-serverless-governance-is-everything-c70589c9cee9">一致的治理规则</a>的开销。</p><p id="ccd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在无服务器的情况下，我选择每个微服务一个存储库。它为微服务的职责划分了清晰的界限，并保持代码的轻量级和集中性。AWS无服务器设计原则之一是不共享任何东西，将你的微服务分成单独的存储库可以很容易地避免你不应该意外做的事情。</p><h2 id="4175" class="mu lw it bd lx mv mw dn mb mx my dp mf li mz na mh lm nb nc mj lq nd ne ml nf bi translated">文件夹结构</h2><p id="09de" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">回购中的文件夹结构对于正确组织至关重要。确保你的代码是以一种易于发现和维护的方式构建的。</p><p id="54d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">借助无服务器微服务，按资源类型构建根级文件夹。以<a class="ae ky" href="https://github.com/allenheltondev/gopher-holes-unlimited" rel="noopener ugc nofollow" target="_blank"> Gopher Holes Unlimited </a>参考架构项目为例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/0e7b967e854fe17bfa77054dfbdb0d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gdf1JIePnsDqpR8J.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="mt">无服务器微服务布局</em></p></figure><p id="8fca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的Lambda函数都包含在<code class="fe nh ni nj nk b">functions</code>文件夹中。类似地，步骤功能工作流程包含在<code class="fe nh ni nj nk b">workflows</code>文件夹中。Lambda图层包含在<code class="fe nh ni nj nk b">layers</code>文件夹中，依此类推。</p><p id="d8b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按资源类型组织代码有助于开发人员快速跳转到特定的代码。</p><p id="ed3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些顶级文件夹中是包含单个资源所需的所有内容的子文件夹。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/ad0a1324ba5d4f237c867f25e0160a40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H4dXDvOajpfo4xwg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="mt">包含Lambda函数所需的所有文件的子文件夹</em></p></figure><p id="7b5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上面的<code class="fe nh ni nj nk b">get-gopher</code> Lambda函数的文件夹为例。它包含一个<code class="fe nh ni nj nk b">index.js</code>、<code class="fe nh ni nj nk b">package.json</code>和<code class="fe nh ni nj nk b">package-lock.json</code>。这意味着每个函数可以有完全隔离的依赖关系，允许您减少Lambda包的大小，这最终会减少<a class="ae ky" href="https://aws.amazon.com/blogs/compute/operating-lambda-performance-optimization-part-1/" rel="noopener ugc nofollow" target="_blank">冷启动时间</a>。</p><p id="e379" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分别处理每个函数的依赖关系。如果你的大多数函数使用相同的包，把它们放在一个<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-both-kinds-of-aws-lambda-layers-yes-there-are-two-edb945979f17">依赖Lambda层</a>中，并在你的函数中使用这个层。</p><h2 id="c33e" class="mu lw it bd lx mv mw dn mb mx my dp mf li mz na mh lm nb nc mj lq nd ne ml nf bi translated">云资源</h2><p id="7b19" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">理论上，微服务不应该有任何硬依赖。这意味着它应该在没有先决条件的情况下进行初始部署。</p><p id="908d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到这一点，无服务器微服务应该是完全独立的。它包含所有Lambda函数、DynamoDB表、KMS键、API等的资源。记住，不要分享任何东西。</p><p id="22de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我第一次开始时，我认为在AWS帐户中部署的所有微服务之间共享KMS密钥是一个好主意。我创建了一个<code class="fe nh ni nj nk b">shared-resources</code>微服务，并从堆栈中导出我将在其他微服务中使用的值。</p><p id="22d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很快导致了一些不良行为。我想既然我做过一次，而且没问题，我可以再做一次。在我意识到之前，我已经有了部署依赖地狱、循环引用和需要部署的极其具体的订单服务。</p><p id="f666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要那样做。</p><p id="c4ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每月额外支付1美元，在您的微服务中拥有一个唯一的KMS密钥。安全总是值得的。</p><p id="437f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在定义您的资源时，一切都应被视为代码(IaC)<a class="ae ky" href="https://docs.aws.amazon.com/whitepapers/latest/introduction-devops-aws/infrastructure-as-code.html" rel="noopener ugc nofollow" target="_blank">基础设施。这使您能够一致地将相同的资源部署到任何客户的任何地区。</a></p><p id="3ae2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您使用的是SAM、CDK、Terraform、无服务器框架还是Pulumi，都没有关于IaC类型的最佳实践。只要你以某种对你有意义的方式定义它，那就是最好的方式。在未来，我们甚至可能不需要IaC！</p><h1 id="5e8d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="a38c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">微服务和无服务器齐头并进。它们缩小了职责范围，提供了分离关注点的方法，并提供了保持敏捷和快速部署到生产的简单方法。</p><p id="29a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于软件中的一切，您在微服务实施方面做出的决策都需要权衡。每个微服务都有一个存储库，这提供了对部署的细粒度控制、清晰的领域定义和代码所有权，以及具有低意外“意大利面条代码”风险的简明代码库但是如果使用monorepo，您会失去一些服务可发现性。</p><p id="74ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保持组织性是任何项目长期成功的关键之一。在最初的开发团队离开项目，长期的维护人员加入之后，他们会知道你做了什么以及如何找到代码吗？随着时间的推移，定义良好的文件夹结构可以提高应用程序的可维护性。根据资源类型构建您的微服务，以便维护开发人员在出现问题时准确地知道去哪里找。</p><p id="c4db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建自包含服务。不要构建需要来自其他服务的资源来部署的<a class="ae ky" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html" rel="noopener ugc nofollow" target="_blank">栈</a>。但是，你可以(也应该！)构建依赖他人的微服务，通过API调用或事件的松散耦合来满足业务流程。</p><p id="9148" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想启动微服务，别忘了它们是由领域驱动的。当希望“打破整体结构”时，首先要识别应用程序的离散部分。找到应用程序中具有足够的业务逻辑的区域，这些逻辑独立于其他区域并独立迭代。</p><p id="3246" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你用了几年时间，意识到两个微服务应该合二为一，或者一个服务变得太大，需要拆分，<em class="nm">去做</em>。软件的美妙之处在于，每次你重访T4，它都会变得更好。</p><p id="e704" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用我上面概述的作为指导。对我的团队有效的可能对你和你的团队无效。但是把它作为一个参照点会让你离开地面，开始积累经验。</p><p id="7175" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>