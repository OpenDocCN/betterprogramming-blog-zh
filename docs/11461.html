<html>
<head>
<title>Look-and-say Sequence With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python看一看说一说序列</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/look-and-say-sequence-with-python-f95a76aa080f?source=collection_archive---------10-----------------------#2022-03-22">https://betterprogramming.pub/look-and-say-sequence-with-python-f95a76aa080f?source=collection_archive---------10-----------------------#2022-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="784a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用groupBy方法的力量解决一个小游戏</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8270a82e37c5dd06598883752308f824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2IROzWmTzOUNmcEXG7S4TA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Cyrus Lopes 在<a class="ae kv" href="https://unsplash.com/collections/1388266/vintage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a735" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模式…无处不在，我们的物种已经进化到能够识别它们。上周我在Twitter上看到一个有趣的帖子:</p><p id="b559" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我有一个挑战给你！下面是一个数列:<br/> <code class="fe ls lt lu lv b"> 1–11–21–1211–111221–312211</code> <br/>你能猜出下一个数字吗？</p><p id="5778" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，模式或序列是可视的，但这一个不是。只要看着它，你就能知道这是一个数列，但是顺序是什么呢？</p><p id="03ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个棘手的问题，因为你必须大声说出来才能找到答案！为了破译下一个元素，我们必须计算一个数字在序列的给定状态中出现了多少次。让我们看看进展如何:</p><ol class=""><li id="2363" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">1 —“一”1(成为系列中的下一个数字)。</li><li id="9929" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">11 —“二”一</li><li id="a351" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">21 —“一”二，“一”一</li><li id="0244" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">1211 —“一”一，“一”二，“二”一</li><li id="df24" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">111221 —等等，等等…</li></ol><p id="47e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mk">引号中的数字是一个数字在序列中出现的次数。</em></p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="8f36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在同一条推文中，有一个奖励:</p><p id="9377" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你能写一个程序来计算数列的下一项吗？</p><p id="20da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在多次尝试使用字典、列表理解和NumPy数组之后，我找到了解决这个问题的正确模块:<code class="fe ls lt lu lv b">itertools</code>。前提是:你需要计算一个数字在下一个数字之前在序列中出现了多少次。这可以使用<code class="fe ls lt lu lv b">groupby</code>方法来完成。</p><p id="42a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据<code class="fe ls lt lu lv b">itertools</code>文档，<code class="fe ls lt lu lv b">groupby</code>从一个iterable (list，tuple，dictionary)返回一个带有多个<code class="fe ls lt lu lv b">keys</code>和<code class="fe ls lt lu lv b">groups</code>的迭代器。让我们来看一个<code class="fe ls lt lu lv b">itertools</code>例子:</p><pre class="kg kh ki kj gt ms lv mt mu aw mv bi"><span id="4ede" class="mw mx iq lv b gy my mz l na nb">&gt;&gt;&gt;[key for key, group in groupby('AAAABBBCCDAABBB')]<br/>[A, B, C, D, A, B]</span></pre><p id="c6cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，这些键是组成每组的字母。当<code class="fe ls lt lu lv b">groupby</code>发现一个与上一个字母不同的新字母时，它会创建一个新的密钥。例如，它返回“A”和“B”的两个键，因为即使它们是相同的字母，它们也被其他字母的组分隔开。</p><p id="5ca1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们要去集合了。在这种情况下，<code class="fe ls lt lu lv b">group</code>是分组项目的iterable。因此，我们将把它的元素解包为一个列表。</p><pre class="kg kh ki kj gt ms lv mt mu aw mv bi"><span id="ffba" class="mw mx iq lv b gy my mz l na nb">&gt;&gt;&gt;[list(group) for key, group in groupby('AAAABBBCCDAABBB')]<br/>[['A', 'A', 'A', 'A'], ['B', 'B', 'B'], ['C', 'C'], ['D'], ['A', 'A'], ['B', 'B', 'B']]</span></pre><p id="ab18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步是获取每组的物品数量:</p><pre class="kg kh ki kj gt ms lv mt mu aw mv bi"><span id="79fe" class="mw mx iq lv b gy my mz l na nb">&gt;&gt;&gt;[len(list(group)) for key, group in groupby('AAAABBBCCDAABBB')]<br/>[4, 3, 2, 1, 2, 3]</span></pre><p id="7161" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你能看到我们如何使用<code class="fe ls lt lu lv b">groupby</code>来完成“看和说”序列吗？如果还不清楚，让我们更进一步，将每个组的计数和它的键结合起来:</p><pre class="kg kh ki kj gt ms lv mt mu aw mv bi"><span id="ab2d" class="mw mx iq lv b gy my mz l na nb">&gt;&gt;&gt;[(len(list(group)),key) for key, group in groupby('AAAABBBCCDAABBB')]<br/>[(4, 'A'), (3, 'B'), (2, 'C'), (1, 'D'), (2, 'A'), (3, 'B')]</span></pre><p id="c6a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，我们知道元组包含每个组的计数和代表它的值。我们可以使用上面的逻辑用Python计算外观和说法序列！</p><p id="0e1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将使用递归方法，从序列的第一个元素开始，在本例中是1，计算下一个元素，并将其作为字符串添加到名为<code class="fe ls lt lu lv b">arr</code>的列表中。该方法再次重复，直到迭代次数为0。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="bdf3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">答案<code class="fe ls lt lu lv b">final_sequence</code>，用<code class="fe ls lt lu lv b">iterator = 15</code>，看起来大概是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="efe1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！这是一个微不足道的游戏，但它展示了<code class="fe ls lt lu lv b">groupby</code>方法是多么强大。</p></div></div>    
</body>
</html>