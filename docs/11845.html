<html>
<head>
<title>Modern C++: A Closer Look at Smart Pointers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++:智能指针的近距离观察</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-smart-pointers-in-cpp-6c3854593503?source=collection_archive---------5-----------------------#2022-04-21">https://betterprogramming.pub/understanding-smart-pointers-in-cpp-6c3854593503?source=collection_archive---------5-----------------------#2022-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="3a0e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">有效的C++</h2><div class=""/><div class=""><h2 id="38dd" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">“理解智能指针”的续篇</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/4c306fb441faee36552ca7c9958e9641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d2En64AdaJSg8kMA"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">克里斯·里德在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="d286" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">目录</h1><pre class="ks kt ku kv gt ma mb mc md aw me bi"><span id="0319" class="mf lj it mb b gy mg mh l mi mj">· <a class="ae lh" href="#93ec" rel="noopener ugc nofollow">Recap</a><br/>  ∘ <a class="ae lh" href="#6030" rel="noopener ugc nofollow">C++ Smart Pointers</a><br/>· <a class="ae lh" href="#cb53" rel="noopener ugc nofollow">Toy Class</a><br/>· <a class="ae lh" href="#dd0f" rel="noopener ugc nofollow">In a nutshell</a><br/>  ∘ <a class="ae lh" href="#f45d" rel="noopener ugc nofollow">Why unique pointers</a><br/>  ∘ <a class="ae lh" href="#8ed3" rel="noopener ugc nofollow">Why did auto_ptr not work?</a><br/>  ∘ <a class="ae lh" href="#871d" rel="noopener ugc nofollow">Issues</a><br/>  ∘ <a class="ae lh" href="#e14b" rel="noopener ugc nofollow">Move Semantics</a><br/>  ∘ <a class="ae lh" href="#4370" rel="noopener ugc nofollow">What is std::unique_ptr ?</a><br/>  ∘ <a class="ae lh" href="#2aa4" rel="noopener ugc nofollow">Unique Ownership of unique pointer</a><br/>  ∘ <a class="ae lh" href="#9bdd" rel="noopener ugc nofollow">Creating an empty unique_ptr object</a><br/>  ∘ <a class="ae lh" href="#cdc6" rel="noopener ugc nofollow">Check if a unique_ptr&lt;&gt; is empty</a><br/>  ∘ <a class="ae lh" href="#6c16" rel="noopener ugc nofollow">Creating a unique_ptr object with a raw pointer</a><br/>  ∘ <a class="ae lh" href="#0c7f" rel="noopener ugc nofollow">Resetting a unique_ptr</a><br/>  ∘ <a class="ae lh" href="#90a4" rel="noopener ugc nofollow">Transferring the ownership of the unique_ptr object</a><br/>  ∘ <a class="ae lh" href="#e5a2" rel="noopener ugc nofollow">Releasing the associated raw pointer</a><br/>· <a class="ae lh" href="#c7bd" rel="noopener ugc nofollow">Source Code</a><br/>· <a class="ae lh" href="#3770" rel="noopener ugc nofollow">Source Code II</a><br/>· <a class="ae lh" href="#bb0f" rel="noopener ugc nofollow">References</a></span></pre><h1 id="93ec" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">概述</h1><p id="fa70" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">RAII: <em class="ng">资源获取是初始化</em>，这是一种使用包装类来处理资源管理的C++编程哲学——这一概念体现在<em class="ng">智能指针</em>中。我们将从停止的地方继续探讨这个问题(参见第一部分)。通常，要取得最有效的进步，需要付出后退几步的代价来换取以后前进的许多步。因此，我们接下来的总结不仅总结了之前学到的经验，还通过扩展我们对第一版智能指针的理解提供了更多的见解(例如，<code class="fe nh ni nj mb b">auto_ptr</code>及其缺点，后来通过引入<code class="fe nh ni nj mb b">unique_ptr</code>得到了改进)。让我们开始吧！</p><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/smart-pointers-in-cpp-708486276526"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">理解C++中的智能指针</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">更聪明地工作，而不是更努力</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">better编程. pub</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob lb nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/understanding-smart-pointer-iii-909512a5eb05"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">通过直观的视觉效果解释C++智能指针</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">我的C++指针系列的第3部分</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">better编程. pub</p></div></div><div class="nw l"><div class="oc l ny nz oa nw ob lb nn"/></div></div></a></div><h2 id="6030" class="mf lj it bd lk od oe dn lo of og dp ls mt oh oi lu mx oj ok lw nb ol om ly iz bi translated">C++智能指针</h2><p id="ee20" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">智能指针是一个对象，它存储一个指向堆分配对象的指针。</p><ul class=""><li id="e7c0" class="on oo it mm b mn op mq oq mt or mx os nb ot nf ou ov ow ox bi translated">智能指针的外观和行为类似于普通的C++指针</li><li id="f24d" class="on oo it mm b mn oy mq oz mt pa mx pb nb pc nf ou ov ow ox bi translated">通过超载<code class="fe nh ni nj mb b">*</code>、<code class="fe nh ni nj mb b">-&gt;</code>、<code class="fe nh ni nj mb b">[]</code>等。</li><li id="dea5" class="on oo it mm b mn oy mq oz mt pa mx pb nb pc nf ou ov ow ox bi translated">这些可以帮助你管理记忆。</li><li id="348b" class="on oo it mm b mn oy mq oz mt pa mx pb nb pc nf ou ov ow ox bi translated">智能指针会在适当的时候删除所指向的对象，包括调用对象的析构函数。</li><li id="492e" class="on oo it mm b mn oy mq oz mt pa mx pb nb pc nf ou ov ow ox bi translated">这取决于你使用哪种智能指针</li><li id="de75" class="on oo it mm b mn oy mq oz mt pa mx pb nb pc nf ou ov ow ox bi translated">通过正确使用智能指针，您不再需要记住何时通过<code class="fe nh ni nj mb b">new</code>分配<code class="fe nh ni nj mb b">delete</code>资源！</li></ul><p id="e62f" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated">如前一篇文章所述，作为现代C++标准库的一部分，提供了<em class="ng">智能指针</em>:<code class="fe nh ni nj mb b">unique_ptr</code>、<code class="fe nh ni nj mb b">shared_ptr</code>和<code class="fe nh ni nj mb b">weak_ptr</code>。</p><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/smart-pointers-in-cpp-708486276526"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">理解C++中的智能指针</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">更聪明地工作，而不是更努力</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">better编程. pub</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob lb nn"/></div></div></a></div><p id="943a" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated">接下来我们将仔细观察一个<code class="fe nh ni nj mb b">unique_ptr</code>:对现在已经废弃的<code class="fe nh ni nj mb b">auto_ptr</code>的改进。参见<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/smart-pointers-in-cpp-708486276526">理解C++中的智能指针</a>了解每一个的介绍；继续前进，看看<code class="fe nh ni nj mb b">unique_ptr</code>到底是如何提高<code class="fe nh ni nj mb b">auto_ptr</code>的。</p><h1 id="cb53" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">玩具类</h1><p id="4bee" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">这是整个教程中使用的玩具类。<a class="ae lh" href="#c7bd" rel="noopener ugc nofollow">源代码</a>提供了全程演示的代码。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pg ph l"/></div></figure><h1 id="dd0f" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">简单地</h1><p id="e541" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">使用对象管理资源:</p><ul class=""><li id="d03e" class="on oo it mm b mn op mq oq mt or mx os nb ot nf ou ov ow ox bi translated">防止资源泄漏，使用RAII在其构造函数中获取资源，并在其析构函数中释放它们</li><li id="bc8c" class="on oo it mm b mn oy mq oz mt pa mx pb nb pc nf ou ov ow ox bi translated">复制资源是编码人员必须考虑的挑战之一</li></ul><p id="360f" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated">仔细考虑资源管理类中的复制行为</p><ol class=""><li id="531e" class="on oo it mm b mn op mq oq mt or mx os nb ot nf pi ov ow ox bi translated">禁止复制</li><li id="2ad8" class="on oo it mm b mn oy mq oz mt pa mx pb nb pc nf pi ov ow ox bi translated">引用对基础资源进行计数</li><li id="70cc" class="on oo it mm b mn oy mq oz mt pa mx pb nb pc nf pi ov ow ox bi translated">复制基础资源</li><li id="a80f" class="on oo it mm b mn oy mq oz mt pa mx pb nb pc nf pi ov ow ox bi translated">转移基础资源的所有权</li></ol><ul class=""><li id="7832" class="on oo it mm b mn op mq oq mt or mx os nb ot nf ou ov ow ox bi translated">复制一个<em class="ng"> RAII </em>对象需要复制它所管理的资源，所以资源的复制行为决定了<em class="ng"> RAII </em>对象的复制行为。</li><li id="e72d" class="on oo it mm b mn oy mq oz mt pa mx pb nb pc nf ou ov ow ox bi translated">常见的<em class="ng"> RAII </em>类复制行为不允许复制执行引用计数，但其他行为是可能的。</li></ul><h2 id="f45d" class="mf lj it bd lk od oe dn lo of og dp ls mt oh oi lu mx oj ok lw nb ol om ly iz bi translated">为什么是唯一指针</h2><p id="cdb2" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">程序通常是各种分支和函数调用的构造，这些分支和函数调用被推到<em class="ng">堆栈内存</em>中。因此，一个程序可能有许多潜在的流动甚至退出方式。因此，每次通过<code class="fe nh ni nj mb b">new</code>实例化一个对象时，很容易忘记调用<code class="fe nh ni nj mb b">delete</code>。与JAVA中使用的非确定性垃圾收集器不同，C++通过<em class="ng">智能指针</em>提供了一个更优雅、更可预测的解决方案。C++98引入了<code class="fe nh ni nj mb b">auto_ptr</code>，为c++ 11【2】的<code class="fe nh ni nj mb b">unique_ptr</code>铺平了道路。好处如下:</p><ul class=""><li id="a3a7" class="on oo it mm b mn op mq oq mt or mx os nb ot nf ou ov ow ox bi translated"><code class="fe nh ni nj mb b">unique_ptr</code>当它超出范围时将删除它的指针</li><li id="f4f2" class="on oo it mm b mn oy mq oz mt pa mx pb nb pc nf ou ov ow ox bi translated">因此，unique_ptr也有助于异常安全</li><li id="7e98" class="on oo it mm b mn oy mq oz mt pa mx pb nb pc nf ou ov ow ox bi translated"><code class="fe nh ni nj mb b">unique_ptr</code>已禁用其复制构造函数和赋值运算符</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pg ph l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">不能复制一个'<code class="fe nh ni nj mb b">unique_ptr'</code>来保持唯一性或<em class="pj">所有权</em>。</p></figure><h2 id="8ed3" class="mf lj it bd lk od oe dn lo of og dp ls mt oh oi lu mx oj ok lw nb ol om ly iz bi translated">为什么<code class="fe nh ni nj mb b">auto_ptr</code>不起作用？</h2><p id="fb7a" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">在C++98中引入，在C++17中删除:第一次尝试智能指针，将语义作为赋值和复制构造函数。</p><h2 id="871d" class="mf lj it bd lk od oe dn lo of og dp ls mt oh oi lu mx oj ok lw nb ol om ly iz bi translated">问题</h2><p id="cebe" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">1.通过值传递函数:通过转移所有权，<code class="fe nh ni nj mb b">auto_ptr</code>假设新的指针代替了被分配者，而另一个被设置为null。因此，函数调用范围内的指针在从它被转移到的函数返回时是<code class="fe nh ni nj mb b">null</code>。</p><p id="4490" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated">2.<code class="fe nh ni nj mb b">std::auto_ptr</code>总是使用非数组删除来删除其内容。</p><p id="2828" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated">3.与标准库中的许多其他类不兼容，包括大多数容器和算法。</p><h2 id="e14b" class="mf lj it bd lk od oe dn lo of og dp ls mt oh oi lu mx oj ok lw nb ol om ly iz bi translated">移动语义</h2><p id="8a5c" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">在C++11中，正式定义了“移动”的概念，并在语言中加入了“移动语义”来区分复制和正确移动。</p><p id="b3eb" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated">因此，在C++11中，<code class="fe nh ni nj mb b">std::auto_ptr</code>已经被一堆其他类型的“移动感知”<em class="ng">智能指针</em> : <code class="fe nh ni nj mb b">std::unique_ptr</code>、<code class="fe nh ni nj mb b">std::weak_ptr</code>和<code class="fe nh ni nj mb b">std::shared_ptr</code>所取代。我们还将探索两个最流行的:<code class="fe nh ni nj mb b">unique_ptr</code>(直接替代<code class="fe nh ni nj mb b">auto_ptr</code>)和<code class="fe nh ni nj mb b">shared_ptr</code>。<code class="fe nh ni nj mb b">unique_ptr</code>已在本博客中涵盖，而<code class="fe nh ni nj mb b">share_ptr</code>将是下一个！</p><h2 id="4370" class="mf lj it bd lk od oe dn lo of og dp ls mt oh oi lu mx oj ok lw nb ol om ly iz bi translated">什么是std::unique_ptr？</h2><p id="3e47" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">unique_ptr是c++11提供的防止内存泄漏的智能指针实现之一。unique_ptr对象包装一个原始指针，并负责它的生存期。当这个对象被析构时，在它的析构函数中，它删除相关的原始指针。</p><p id="d641" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated"><code class="fe nh ni nj mb b">unique_ptr</code>的<code class="fe nh ni nj mb b">-&gt;</code>和<code class="fe nh ni nj mb b">*</code>操作符重载，作为普通指针操作。</p><p id="6f85" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated">参见<a class="ae lh" href="#3770" rel="noopener ugc nofollow">源代码二</a>。</p><p id="8484" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated"><code class="fe nh ni nj mb b">unique_ptr&lt;MyClass&gt;</code>对象<code class="fe nh ni nj mb b">myPtr</code>接受一个原始指针作为参数。当函数退出时，这个对象将超出作用域，调用它的析构函数。在析构函数<code class="fe nh ni nj mb b">unique_ptr</code>对象中，<code class="fe nh ni nj mb b">myPtr</code>删除相关的原始指针。</p><p id="5309" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated">无论函数是否正常退出(即由于某种异常)，都会调用<code class="fe nh ni nj mb b">myPtr</code>的析构函数。因此，原始指针将总是被删除，并防止内存泄漏。</p><h2 id="2aa4" class="mf lj it bd lk od oe dn lo of og dp ls mt oh oi lu mx oj ok lw nb ol om ly iz bi translated">唯一指针的唯一所有权</h2><p id="c1ef" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">一个<code class="fe nh ni nj mb b">unique_ptr</code>总是相关原始指针的唯一拥有者。我们不能复制unique_ptr对象；它只是可移动的。</p><p id="7df3" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated">因为每个<code class="fe nh ni nj mb b">unique_ptr</code>都是原始指针的唯一所有者；它直接删除其析构函数中的相关指针。不需要引用计数；所以，很轻。</p><h2 id="9bdd" class="mf lj it bd lk od oe dn lo of og dp ls mt oh oi lu mx oj ok lw nb ol om ly iz bi translated">创建空的unique_ptr对象</h2><p id="18c8" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">让我们创建一个空的unique_ptr <int>对象，即</int></p><pre class="ks kt ku kv gt ma mb mc md aw me bi"><span id="e305" class="mf lj it mb b gy mg mh l mi mj">// Empty unique_ptr object</span><span id="376f" class="mf lj it mb b gy pk mh l mi mj">std::unique_ptr&lt;int&gt; ptr1;</span></pre><p id="e46f" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated"><code class="fe nh ni nj mb b">ptr1</code>没有关联的原始指针。因此它是空的。</p><h2 id="cdc6" class="mf lj it bd lk od oe dn lo of og dp ls mt oh oi lu mx oj ok lw nb ol om ly iz bi translated">检查<code class="fe nh ni nj mb b">unique_ptr&lt;&gt;</code>是否为空</h2><p id="6224" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">有两种方法可以检查一个<code class="fe nh ni nj mb b">unique_ptr&lt;&gt;</code>对象是空的还是有一个原始指针与之相关联。</p><p id="2842" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated"><strong class="mm jd">方法一:</strong></p><pre class="ks kt ku kv gt ma mb mc md aw me bi"><span id="a341" class="mf lj it mb b gy mg mh l mi mj">// Check if unique pointer object is empty</span><span id="65c8" class="mf lj it mb b gy pk mh l mi mj">if(!ptr1)</span><span id="dd2e" class="mf lj it mb b gy pk mh l mi mj">    std::cout&lt;&lt;”ptr1 is empty”&lt;&lt;std::endl;</span></pre><p id="d4b6" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated"><strong class="mm jd">方法二:</strong></p><pre class="ks kt ku kv gt ma mb mc md aw me bi"><span id="8420" class="mf lj it mb b gy mg mh l mi mj">// Check if unique pointer object is empty</span><span id="045e" class="mf lj it mb b gy pk mh l mi mj">if(ptr1 == nullptr)</span><span id="13da" class="mf lj it mb b gy pk mh l mi mj">    std::cout&lt;&lt;”ptr1 is empty”&lt;&lt;std::endl;</span></pre><h2 id="6c16" class="mf lj it bd lk od oe dn lo of og dp ls mt oh oi lu mx oj ok lw nb ol om ly iz bi translated">使用原始指针创建unique_ptr对象</h2><p id="b7bc" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">要创建一个非空的<code class="fe nh ni nj mb b">unique_ptr&lt;&gt;</code>,在创建对象时，在它的构造函数中传递原始指针，即，</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pg ph l"/></div></figure><p id="6aae" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated">我们不能通过赋值来创建一个<code class="fe nh ni nj mb b">unique_ptr&lt;&gt;</code>对象。否则，会导致编译错误。</p><pre class="ks kt ku kv gt ma mb mc md aw me bi"><span id="8b4b" class="mf lj it mb b gy mg mh l mi mj">// std::unique_ptr&lt;MyClass&gt; <!-- -->myPtr2<!-- --> = new MyClass(); // Compile Error</span></pre><h2 id="0c7f" class="mf lj it bd lk od oe dn lo of og dp ls mt oh oi lu mx oj ok lw nb ol om ly iz bi translated">重置唯一指针</h2><p id="b08d" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">在<code class="fe nh ni nj mb b">unique_ptr&lt;&gt;</code>上调用<code class="fe nh ni nj mb b">reset()</code>函数将重置它，即删除相关的原始指针并使<code class="fe nh ni nj mb b">unique_ptr&lt;&gt;</code>对象为空</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pg ph l"/></div></figure><p id="9cb7" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated"><code class="fe nh ni nj mb b">unique_ptr</code>不可复制。</p><p id="4789" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated">由于<code class="fe nh ni nj mb b">unique_ptr&lt;&gt;</code>不可复制，只能移动。因此，我们不能通过复制构造函数或赋值操作符来创建unique_ptr对象的副本。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pg ph l"/></div></figure><p id="c413" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated">复制构造函数和赋值运算符都在<code class="fe nh ni nj mb b">unique_ptr&lt;&gt;</code>类中被删除。</p><h2 id="90a4" class="mf lj it bd lk od oe dn lo of og dp ls mt oh oi lu mx oj ok lw nb ol om ly iz bi translated">转移unique_ptr对象的所有权</h2><p id="6be3" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">我们不能复制一个<code class="fe nh ni nj mb b">unique_ptr</code>对象，但是我们可以移动它们。这意味着一个<code class="fe nh ni nj mb b">unique_ptr</code>可以将相关原始指针的所有权转移给另一个<code class="fe nh ni nj mb b">unique_ptr</code>。让我们通过一个例子来理解，</p><p id="7223" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated">创建一个<code class="fe nh ni nj mb b">unique_ptr</code>对象(参见上面代码示例中的第1–2行):</p><blockquote class="pl pm pn"><p id="65d4" class="mk ml ng mm b mn op kd mp mq oq kg ms po pd mv mw pp pe mz na pq pf nd ne nf im bi translated">myPtr2不为空。</p></blockquote><p id="b8c5" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated">现在将关联指针<code class="fe nh ni nj mb b">MyClass</code>的所有权转移到一个新的<code class="fe nh ni nj mb b">unique_ptr</code>对象，即</p><p id="97c5" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated"><code class="fe nh ni nj mb b">std::move()</code>将<code class="fe nh ni nj mb b">myPtr2</code>转换为右值参考。从而调用<code class="fe nh ni nj mb b">unique_ptr</code>的move构造函数，相关的原始指针可以传递给<code class="fe nh ni nj mb b">myPtr4</code>。</p><p id="c16c" class="pw-post-body-paragraph mk ml it mm b mn op kd mp mq oq kg ms mt pd mv mw mx pe mz na nb pf nd ne nf im bi translated"><code class="fe nh ni nj mb b">myPtr2</code>在其原始指针的所有权转移到<code class="fe nh ni nj mb b">myPtr4</code>后将为空。</p><h2 id="e5a2" class="mf lj it bd lk od oe dn lo of og dp ls mt oh oi lu mx oj ok lw nb ol om ly iz bi translated">释放相关的原始指针</h2><p id="0c69" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">在<code class="fe nh ni nj mb b">unique_ptr</code>对象上调用<code class="fe nh ni nj mb b">release()</code>将从对象中释放相关原始指针的所有权，并返回原始指针。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pg ph l"/></div></figure><h1 id="c7bd" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">源代码</h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pg ph l"/></div></figure><blockquote class="pl pm pn"><p id="eb33" class="mk ml ng mm b mn op kd mp mq oq kg ms po pd mv mw pp pe mz na pq pf nd ne nf im bi translated">ptr1为空<br/> ptr1为空<br/>my class::Constructor<br/>myPtr不为空<br/> 23 <br/>重置myPtr <br/> MyClass::析构函数<br/> myPtr为空<br/> MyClass::构造函数<br/> myPtr3不为空<br/> myPtr2不为空<br/> myPtr4不为空<br/> 55 <br/> MyClass::析构函数<br/> MyClass::构造函数<br/> myPtr5不为空</p></blockquote><h1 id="3770" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">源代码二</h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pg ph l"/></div></figure><h1 id="bb0f" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">参考</h1><p id="b79c" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">[1] S .迈耶斯。"有效的C++: 55种改进程序和设计的具体方法."<em class="ng">艾迪森-卫斯理专业(</em>第三版)，2005年。</p></div><div class="ab cl pr ps hx pt" role="separator"><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw"/></div><div class="im in io ip iq"><pre class="ks kt ku kv gt ma mb mc md aw me bi"><span id="3911" class="mf lj it mb b gy mg mh l mi mj"><strong class="mb jd">Want to Connect?</strong></span><span id="4e81" class="mf lj it mb b gy pk mh l mi mj">Follow Dr. Robinson on <a class="ae lh" href="https://www.linkedin.com/company/superannotate/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>, <a class="ae lh" href="https://twitter.com/jrobvision" rel="noopener ugc nofollow" target="_blank">Twitter</a>, <a class="ae lh" href="https://www.facebook.com/superannotate" rel="noopener ugc nofollow" target="_blank">Facebook</a>, and <a class="ae lh" href="https://www.instagram.com/doctor__jjj/" rel="noopener ugc nofollow" target="_blank">Instagram</a>.</span><span id="9e43" class="mf lj it mb b gy pk mh l mi mj">Visit my homepage for papers, blogs, email signups, and more!</span></pre><div class="nk nl gp gr nm nn"><a href="https://www.jrobs-vision.com/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">人工智能工程师|约瑟夫·p·罗宾逊</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">问候！我是Vicarious Surgical的人工智能工程师，致力于推进下一代外科机器人技术。我的…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">www.jrobs-vision.com</p></div></div><div class="nw l"><div class="py l ny nz oa nw ob lb nn"/></div></div></a></div></div></div>    
</body>
</html>