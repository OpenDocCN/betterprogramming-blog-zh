<html>
<head>
<title>5 Ways for Sorting Full-Text Search Results in MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在MongoDB中对全文搜索结果进行排序的5种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-ways-of-sorting-full-text-search-results-in-mongodb-4863b4eb0ae9?source=collection_archive---------7-----------------------#2022-08-08">https://betterprogramming.pub/5-ways-of-sorting-full-text-search-results-in-mongodb-4863b4eb0ae9?source=collection_archive---------7-----------------------#2022-08-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8b0c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用不同的方法提高你的技能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6984cbb2100d93d591d23bdf5fcd663f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hCzkGF_V-5BwfMtbZVa_cw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1dd7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">MongoDB是当今最流行的NoSQL数据库，它是一个面向文档的数据库，在许多现代web应用程序中使用。MongoDB中的搜索可以通过许多不同的方式完成，包括传统的字符串搜索，它不如现代的索引搜索高效，或者为高级查询提供更丰富选项的全文搜索。我们将使用它来探索不同的排序结果的方法。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="e524" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">准备测试数据和文本索引</h1><p id="bcf9" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">如果您有要测试的数据，那么您可以跳过这一步。如果没有，那么打开MongoDB shell并运行以下命令:</p><p id="8ff3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用测试数据库:</p><p id="595f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe my mz na nb b">use testdb</code></p><p id="9965" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过运行以下命令，导入以下示例电影数据集，该数据集包含名为<code class="fe my mz na nb b">movies</code>的集合中的三个字段<code class="fe my mz na nb b">title</code>、<code class="fe my mz na nb b">plot</code>和<code class="fe my mz na nb b">rating</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="5a63" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了验证插入，您可以运行这个命令<code class="fe my mz na nb b">db.movies.find()</code>，它应该会打印出上面所有的电影。</p><p id="5cf4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在剩下的就是为我们新的<code class="fe my mz na nb b">movies</code>集合创建一个索引，我们将为字段<code class="fe my mz na nb b">title</code>和<code class="fe my mz na nb b">plot</code>创建一个索引，这样我们就可以用一个查询来搜索它们。在MongoDB shell中，运行以下命令:</p><p id="e8d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe my mz na nb b">db.movies.createIndex({ "title": "text", "plot": "text" })</code></p><p id="9733" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要验证索引是否创建成功，运行<code class="fe my mz na nb b">db.movies.getIndexes()</code>，它应该会打印出两个索引，一个是默认的，另一个是我们新创建的。</p><p id="d264" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们测试我们的数据集，并使用我们的新索引运行一个简单的文本搜索，让我们通过运行以下命令来搜索电影<code class="fe my mz na nb b">Doctor Strange</code>:</p><p id="7b8c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe my mz na nb b">db.movies.find({ $text: { $search: "doctor strange" } })</code></p><p id="6ea7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它应该返回以下结果:</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="9827" class="ni mc it nb b gy nj nk l nl nm">{ <br/>  "_id" : ObjectId("62ed3dac947748ca508e093e"),<br/>  "plot" : "After his career is destroyed, a brilliant but arrogant and conceited surgeon gets a new lease on life when a sorcerer takes him under her wing and trains him to defend the world against evil.",<br/>  "title" : "Doctor Strange",<br/>  "rating" : 4.5<br/>}</span></pre><p id="8b3a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们开始探索如何对搜索结果进行排序。</p><h1 id="0bf2" class="mb mc it bd md me nn mg mh mi no mk ml jz np ka mn kc nq kd mp kf nr kg mr ms bi translated">1.按相关性对结果排序</h1><p id="a8dd" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">当我们执行全文搜索时，我们得到一些与我们的文档相关联的元数据，其中包括每个文档的相关性分数<code class="fe my mz na nb b">textScore</code>。默认情况下，结果不按分数排序。为了改变这种情况，让我们先来看看分数。</p><p id="695d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行以下命令来搜索单词<code class="fe my mz na nb b">world</code>并在我们返回的文档中的新字段<code class="fe my mz na nb b">score</code>中投影<code class="fe my mz na nb b">textScore</code>元数据:</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="53e3" class="ni mc it nb b gy nj nk l nl nm">db.movies.find({ $text: { $search: "world" } }, { _id: 0, title: 1, score: { $meta: "textScore" } })</span></pre><p id="a480" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它将返回以下结果:</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="0f88" class="ni mc it nb b gy nj nk l nl nm">{ "title" : "Doctor Strange", "score" : 0.5294117647058824 }<br/>{ "title" : "Avatar", "score" : 0.5333333333333333 }<br/>{ "title" : "Vikings", "score" : 0.5277777777777778 }</span></pre><p id="2012" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些结果标题不包括我们的搜索词，因为我们也在搜索包含该搜索词的绘图字段。</p><p id="0677" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意分数是如何不排序的。为了改变这种情况，让我们使用以下聚合管道对它们进行排序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="f8df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，结果被排序为最相关的第一个:</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="f6b1" class="ni mc it nb b gy nj nk l nl nm">{ "title" : "Avatar", "score" : 0.5333333333333333 }<br/>{ "title" : "Doctor Strange", "score" : 0.5294117647058824 }<br/>{ "title" : "Vikings", "score" : 0.5277777777777778 }</span></pre><p id="2451" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想先对最不相关的进行排序，那么我们可以按升序对分数进行排序，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a87f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果会是这样的:</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="9a80" class="ni mc it nb b gy nj nk l nl nm">{ "title" : "Vikings", "score" : 0.5277777777777778 }<br/>{ "title" : "Doctor Strange", "score" : 0.5294117647058824 }<br/>{ "title" : "Avatar", "score" : 0.5333333333333333 }</span></pre><h1 id="549a" class="mb mc it bd md me nn mg mh mi no mk ml jz np ka mn kc nq kd mp kf nr kg mr ms bi translated">2.按字母顺序排列结果</h1><p id="b944" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">要按字母顺序对搜索结果进行排序，我们需要做的就是按索引字段进行排序。要从上一个搜索词开始对标题进行升序排序，请运行以下聚合管道:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="be9c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它将返回以下结果:</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="0b76" class="ni mc it nb b gy nj nk l nl nm">{ "title" : "Avatar" }<br/>{ "title" : "Doctor Strange" }<br/>{ "title" : "Vikings" }</span></pre><p id="596e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想按降序排序，那么我们可以运行这个聚合管道:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e960" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果会是这样的:</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="46be" class="ni mc it nb b gy nj nk l nl nm">{ "title" : "Vikings" }<br/>{ "title" : "Doctor Strange" }<br/>{ "title" : "Avatar" }</span></pre><h1 id="4ce5" class="mb mc it bd md me nn mg mh mi no mk ml jz np ka mn kc nq kd mp kf nr kg mr ms bi translated">3.通过自定义分数影响结果</h1><p id="26f0" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我们的电影收藏有一个分级字段。比方说，我们希望使用该字段来影响我们的结果，并结合最相关和最评级来对我们的结果进行排序。我们可以将相关性分数与评级相乘，并将结果存储在一个新字段中，我们可以使用该字段对结果进行排序。</p><p id="840c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用前面的搜索词，运行以下聚合管道:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3eb2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你会得到这些结果:</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="7e1e" class="ni mc it nb b gy nj nk l nl nm">{ "title" : "Avatar", "rating" : 5, "score" : 0.5333333333333333, "customScore" : 2.6666666666666665 }<br/>{ "title" : "Vikings", "rating" : 5, "score" : 0.5277777777777778, "customScore" : 2.638888888888889 }<br/>{ "title" : "Doctor Strange", "rating" : 4.5, "score" : 0.5294117647058824, "customScore" : 2.3823529411764706 }</span></pre><p id="241d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在请注意<code class="fe my mz na nb b">Vikings</code>的排名如何高于<code class="fe my mz na nb b">Doctor Strange</code>，因为它有更高的评级，尽管它的相关性分数更小。</p><h1 id="523c" class="mb mc it bd md me nn mg mh mi no mk ml jz np ka mn kc nq kd mp kf nr kg mr ms bi translated">4.首先对赞助结果进行排序</h1><p id="2b43" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">假设我们的一些结果得到了赞助，我们希望在其他结果之前对它们进行排序和显示。我们可以用高于所有其他得分的值来增加这些赞助结果的得分，以便首先对这些结果进行排序，然后是其他结果。</p><p id="b753" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们有一个想要首先播放的电影列表，例如<code class="fe my mz na nb b">["The Avengers", "Vikings", "300"]</code>，使用前面的搜索词，让我们运行以下聚合管道:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="867d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们所做的是检查标题是否是我们的赞助列表的一部分，如果是，则将其分数增加100，如果不是，则保持其分数不变。</p><p id="67d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们得到了这些结果:</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="5da8" class="ni mc it nb b gy nj nk l nl nm">{ "title" : "Vikings", "customScore" : 100.52777777777777 }<br/>{ "title" : "Avatar", "customScore" : 0.5333333333333333 }<br/>{ "title" : "Doctor Strange", "customScore" : 0.5294117647058824 }</span></pre><p id="2041" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于<code class="fe my mz na nb b">Vikings</code>是我们的赞助列表的一部分，它的分数会增加并排名第一，而其他结果使用它们的正常相关性分数排序。</p><h1 id="e4fd" class="mb mc it bd md me nn mg mh mi no mk ml jz np ka mn kc nq kd mp kf nr kg mr ms bi translated">5.基于搜索词位置排序</h1><p id="96b7" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">假设我们有以下列表:</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="bd2d" class="ni mc it nb b gy nj nk l nl nm">Introduction to Computer Science<br/>Computer Science<br/>Advanced Computer Science</span></pre><p id="439b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们搜索单词<code class="fe my mz na nb b">Computer</code>，我们将得到所有这些结果，但是假设我们希望总是根据单词<code class="fe my mz na nb b">Computer</code>的位置对它们进行排序，那么我们将得到这些结果:</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="9672" class="ni mc it nb b gy nj nk l nl nm">Computer Science<br/>Advanced Computer Science<br/>Introduction to Computer Science</span></pre><p id="102a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的电影收藏中，我们有两个复仇者联盟的标题，所以让我们应用到这些标题。我们可以使用标题中搜索词的位置作为自定义分数来影响我们的结果。</p><p id="9dd6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们使用相关性运行一个普通的排序，使用下面的聚合管道:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e27c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们得到这些结果:</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="d0a2" class="ni mc it nb b gy nj nk l nl nm">{ "title" : "The Avengers", "score" : 1 }<br/>{ "title" : "Avengers: Infinity War", "score" : 0.6666666666666666 }</span></pre><p id="0dfd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这不是我们想要的结果，所以让我们运行以下聚合管道:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="bb5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们得到了这些结果:</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="dcfc" class="ni mc it nb b gy nj nk l nl nm">{ "title" : "Avengers: Infinity War", "score" : 0.6666666666666666, "customScore" : 0.6666666666666666 }<br/>{ "title" : "The Avengers", "score" : 1, "customScore" : 5 }</span></pre><p id="a7a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，让我们来分解一下，首先<code class="fe my mz na nb b">indexOfBytes</code>给出了我们的搜索词在标题中的位置，这意味着当我们将索引添加到我们的分数中时，单词越远，分数就越大，然后我们可以按升序排序。</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="805c" class="ni mc it nb b gy nj nk l nl nm">$addFields: {<br/> indexValue: { $indexOfBytes: ["$title", "Avengers"] }<br/>}</span></pre><p id="97d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果没有匹配，则<code class="fe my mz na nb b">indexOfBytes</code>返回<code class="fe my mz na nb b">-1</code>。这意味着最不相关的结果将首先显示，因为在我们的升序排序中<code class="fe my mz na nb b">-1</code>会给它们最小的分数。所以我们能做的是执行一个条件，检查索引是否是<code class="fe my mz na nb b">-1</code>，然后把它转换成一个大值。例如，100保证它被排在具有有效索引的结果之后。</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="6eeb" class="ni mc it nb b gy nj nk l nl nm">$addFields: {<br/> finalIndexValue: {<br/>  $cond: [{ $eq: [ "$indexValue", -1 ] }, 100, "$indexValue"]<br/> }<br/>}</span></pre><p id="2915" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们只需将最终指数添加到分数中。</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="e6cf" class="ni mc it nb b gy nj nk l nl nm">$addFields: {<br/> customScore: {<br/>  $add: ["$score", "$finalIndexValue"]<br/> }<br/>}</span></pre><p id="28ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并按升序排序<code class="fe my mz na nb b">{ $sort: { customScore: 1 } }</code></p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="c6e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这篇文章是有帮助的。感谢阅读。</p></div></div>    
</body>
</html>