<html>
<head>
<title>How To Easily Persist Data Within Cloudflare Workers Using KV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用KV在Cloudflare Workers中轻松持久化数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-easily-persist-data-within-cloudflare-workers-using-kv-5a29f1142da6?source=collection_archive---------10-----------------------#2022-11-08">https://betterprogramming.pub/how-to-easily-persist-data-within-cloudflare-workers-using-kv-5a29f1142da6?source=collection_archive---------10-----------------------#2022-11-08</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="f7b9" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">学习在您的员工中使用Cloudflare的Redis式存储，免费帐户的使用限制非常宽松</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/34f681d850320ac1fb307dfafe8753fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dIhNduNFeBvxwaqg"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">马修·施瓦茨在<a class="ae la" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><blockquote class="lb lc ld"><p id="f937" class="le lf lg lh b li lj jw lk ll lm jz ln lo lp lq lr ls lt lu lv lw lx ly lz ma io bi translated">这是关于Cloudflare workers的系列文章的第2部分，请在此处查看其他文章:</p><p id="b68b" class="le lf lg lh b li lj jw lk ll lm jz ln lo lp lq lr ls lt lu lv lw lx ly lz ma io bi translated">步骤1: <a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/create-and-host-apis-for-free-using-cloudflare-workers-808830a4e5f5">使用Cloudflare Workers </a> <br/>免费创建和托管API步骤2:如何使用KV在Cloudflare Workers中轻松持久化数据</p></blockquote><p id="62d9" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">在上一篇文章中，我们使用Cloudflare workers创建了一个简单的API来检索动物。尽管API本身目前使用的是虚拟数据，这对于演示功能来说很好，但是对于真正的API来说没有用。</p><p id="1bc0" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">这就是KV来自Cloudflare的原因。这是一个简单、低延迟、键值存储。如果您曾经使用过Redis，您会立即意识到它本质上提供了与Cloudflare自己的实施相同的功能。</p><p id="352d" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">在本文中，我将更详细地解释KV是什么，以及如何在您的Cloudflare workers中使用它。</p><h1 id="9240" class="me mf iv bd mg mh mi mj mk ml mm mn mo kb mp kc mq ke mr kf ms kh mt ki mu mv bi translated">KV是什么？</h1><p id="2207" class="pw-post-body-paragraph le lf iv lh b li mw jw lk ll mx jz ln mb my lq lr mc mz lu lv md na ly lz ma io bi translated">对于不熟悉Redis的人来说，KV提供了一个简单的<a class="ae la" href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" rel="noopener ugc nofollow" target="_blank"> CRUD </a>接口来读写数据。因为它是一个键值存储，所以可以使用给定的键进行读写，并且可以在该键下存储任何数据，从简单的字符串到JSON。</p><p id="32ab" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">最重要的是，作为一个免费用户，你可以得到一个相当慷慨的使用计划。您最多可以发送100，000个读取请求和1，000个写入、列出和删除请求(每种类型1，000个)。存储方面，最多可以存储1GB。</p><p id="996c" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">如果你的API开始流行，他们的价格会比免费层更合理。对于其他类型，每1000万次读取只有0.50美元，每100万次请求只有5美元。</p><p id="4967" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">KV最终是一致的，这意味着在您的数据被写入到可供您的工作人员的每个调用者使用之间可能会有延迟。这意味着，如果两个API调用几乎同时写入同一个键，您可能会遇到竞争情况。</p><p id="5fa8" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">当使用KV时，这是需要记住的事情，尤其是如果您的API是写密集型的，因为KV最适合读密集型的应用程序或用例。它作为一个缓存运行，但是它作为简单API的存储选项工作得非常好。</p><p id="e609" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">准备好为您的API添加持久性了吗？我们来看看如何！</p><h1 id="6554" class="me mf iv bd mg mh mi mj mk ml mm mn mo kb mp kc mq ke mr kf ms kh mt ki mu mv bi translated">创建一个KV名称空间</h1><p id="1013" class="pw-post-body-paragraph le lf iv lh b li mw jw lk ll mx jz ln mb my lq lr mc mz lu lv md na ly lz ma io bi translated">在您的worker中使用KV之前，我们必须首先创建一个KV名称空间。这只是一个名字的别称。</p><p id="8d3c" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">要创建新的KV名称空间，请执行以下步骤:</p><ol class=""><li id="9f1c" class="nb nc iv lh b li lj ll lm mb nd mc ne md nf ma ng nh ni nj bi translated">前往<a class="ae la" href="https://dash.cloudflare.com/" rel="noopener ugc nofollow" target="_blank">https://dash.cloudflare.com/</a>并登录您的账户。</li><li id="c1de" class="nb nc iv lh b li nk ll nl mb nm mc nn md no ma ng nh ni nj bi translated">单击左侧菜单上的工人旁边的小箭头，然后单击KV。</li><li id="a885" class="nb nc iv lh b li nk ll nl mb nm mc nn md no ma ng nh ni nj bi translated">将有一个标记为“创建名称空间”的按钮。点击它。</li><li id="267f" class="nb nc iv lh b li nk ll nl mb nm mc nn md no ma ng nh ni nj bi translated">为您的名称空间键入一个描述性名称，然后单击添加。</li></ol><p id="0249" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">这就是全部了。现在，您已经创建了一个KV名称空间来存储您喜欢的任何数据。记下ID(它旁边有一个方便的复制按钮)，因为我们在下一步中需要它。</p><p id="957a" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">我们需要让您的工作人员能够访问KV名称空间，然后才能使用它，所以接下来让我们这样做。</p><h1 id="4ebf" class="me mf iv bd mg mh mi mj mk ml mm mn mo kb mp kc mq ke mr kf ms kh mt ki mu mv bi translated">将您的KV名称空间绑定到一个Worker</h1><p id="3f24" class="pw-post-body-paragraph le lf iv lh b li mw jw lk ll mx jz ln mb my lq lr mc mz lu lv md na ly lz ma io bi translated">现在我们已经创建了一个KV名称空间，我们可以将这个KV名称空间绑定到任意数量的workers。我们只将它绑定到一个，但是没有理由不能将同一个名称空间绑定到多个workers。</p><p id="785d" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">因为Cloudflare worker在无服务器的运行时中运行，所以每当调用它时，绑定会有效地将KV名称空间注入到cloud flare worker中。很酷，对吧？</p><p id="625d" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">将worker绑定到名称空间很简单，打开<code class="fe np nq nr ns b">wrangler.toml</code>并在底部添加以下几行:</p><pre class="kl km kn ko gt nt ns nu nv aw nw bi"><span id="c7fb" class="nx mf iv ns b gy ny nz l oa ob">kv_namespaces = [<br/>  { binding = "ANIMALS", id = "your-id-here" }<br/>]</span></pre><p id="677b" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">您需要将<code class="fe np nq nr ns b">your-id-here</code>替换为创建名称空间时给出的ID，该ID始终可以在您的Cloudflare仪表板中的KV页面上看到。</p><p id="f0cf" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">至于<code class="fe np nq nr ns b">binding</code>，您可以给它起任何您喜欢的描述性名称，但是它将是您在代码中用来访问您的KV名称空间的名称。</p><p id="2f25" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">我们目前只绑定一个KV名称空间，但是如果您想要多个名称空间，<code class="fe np nq nr ns b">kv_namespaces</code>接受一个对象数组。</p><h2 id="7ef1" class="nx mf iv bd mg oc od dn mk oe of dp mo mb og oh mq mc oi oj ms md ok ol mu om bi translated">处理开发和生产数据存储</h2><p id="b466" class="pw-post-body-paragraph le lf iv lh b li mw jw lk ll mx jz ln mb my lq lr mc mz lu lv md na ly lz ma io bi translated">您可能想知道我们如何在开发和生产中使用不同的数据存储来测试我们的员工，这将是一个很好的问题。</p><p id="ff50" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">Cloudflare的工具非常好，所以如果您现在使用<code class="fe np nq nr ns b">npm run deploy</code>部署您的员工，一切都会很好。然而，如果您运行<code class="fe np nq nr ns b">npm start</code>以开发模式启动您的worker，将会出现如下错误:</p><pre class="kl km kn ko gt nt ns nu nv aw nw bi"><span id="a1f2" class="nx mf iv ns b gy ny nz l oa ob">✘ [ERROR] In development, you should use a separate kv namespace than the one you'd use in production. Please create a new kv namespace with "wrangler kv:namespace create &lt;name&gt; --preview" and add its id as preview_id to the kv_namespace "ANIMALS" in your wrangler.toml</span></pre><p id="583b" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">有益的是，它甚至为我们提供了问题的解决方案，并让我们有机会尝试使用Wrangler CLI创建KV名称空间的替代方法。</p><p id="32d9" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">让我们按照错误消息所描述的那样，运行以下命令:</p><pre class="kl km kn ko gt nt ns nu nv aw nw bi"><span id="51a7" class="nx mf iv ns b gy ny nz l oa ob">wrangler kv:namespace create &lt;name&gt; --preview</span></pre><p id="7eff" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">与之前类似，您需要给它一个描述性的名称。<code class="fe np nq nr ns b">--preview</code>选项告知牧马人它仅用于预览，本质上是开发模式。一旦完成，它将输出您的新预览KV名称空间及其ID。我们现在可以像这样更新<code class="fe np nq nr ns b">wrangler.toml</code>:</p><pre class="kl km kn ko gt nt ns nu nv aw nw bi"><span id="9cf8" class="nx mf iv ns b gy ny nz l oa ob">kv_namespaces <em class="lg">= </em>[<br/>  { binding <em class="lg">= </em>"ANIMALS", id <em class="lg">= </em>"production-id", <strong class="ns iw">preview_id <em class="lg">= "</em>preview-id"</strong> }<br/>]</span></pre><p id="5aa4" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">我加粗了前一行代码的变化，本质上，我们提供了一个额外的参数，它是预览KV名称空间的ID。当您的worker启动时，将根据它运行的环境使用正确的KV名称空间，因此无需担心开发与生产的冲突！</p><p id="3aef" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">我们现在可以在代码中使用KV名称空间。让我们来看看是如何做到的。</p><h1 id="d886" class="me mf iv bd mg mh mi mj mk ml mm mn mo kb mp kc mq ke mr kf ms kh mt ki mu mv bi translated">如何在代码中访问KV名称空间</h1><p id="d68a" class="pw-post-body-paragraph le lf iv lh b li mw jw lk ll mx jz ln mb my lq lr mc mz lu lv md na ly lz ma io bi translated">既然我们的工人可以访问我们在运行时创建的KV名称空间，那么我们如何访问这个名称空间呢？</p><p id="8883" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">如果您习惯于更传统的工作流，这可能是您希望必须配置用户名和密码连接的地方，但Cloudflare workers并非如此。</p><p id="c678" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">所有这些工作都由Cloudflare为我们完成，因此我们可以专注于有趣的事情，例如构建更多的API！</p><p id="73f1" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">让我们看一下使我们的工作人员能够访问KV名称空间的代码更改:</p><p id="75b6" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated"><code class="fe np nq nr ns b">src/index.ts</code></p><pre class="kl km kn ko gt nt ns nu nv aw nw bi"><span id="2186" class="nx mf iv ns b gy ny nz l oa ob">export interface Env {<br/>   //This will be auto-populated with the KV Namespace that is bound in the wrangler.toml<br/>   //and exposes all the methods you'll need (get, put, list etc.)<br/>   <strong class="ns iw">ANIMALS: KVNamespace;</strong><br/>}</span><span id="69ed" class="nx mf iv ns b gy on nz l oa ob">export default {<br/>   async fetch(<br/>      request: Request,<br/>      <strong class="ns iw">env: Env,</strong><br/>      ctx: ExecutionContext<br/>   ): Promise&lt;Response&gt; {<br/>      return await router.handle(request, env)<br/>   }<br/>};</span></pre><p id="1f96" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">我把重要的线加粗了，但是只有一条是新的。首先，在fetch函数中，它是我们的worker的入口点，我们接收一个名为<code class="fe np nq nr ns b">env</code>的参数。此参数包含环境变量，在许多情况下，Cloudflare会为我们自动填充这些变量。</p><p id="a6e2" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">KV名称空间就是这种情况，因为Cloudflare将用您的绑定中使用的名称填充<code class="fe np nq nr ns b">env</code>。在我上面的例子中，那是<code class="fe np nq nr ns b">ANIMALS</code>，所以我可以使用<code class="fe np nq nr ns b">env.ANIMALS</code>访问KV名称空间。</p><p id="e10e" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">因为这是TypeScript，所以我们要描述一下<code class="fe np nq nr ns b">env</code>里面有什么(里面有一个<code class="fe np nq nr ns b">Env</code>的类型，上面可以看到)。同样，Cloudflare提供了与其工具交互所需的类型。</p><p id="75fd" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">因此，在我们定义的<code class="fe np nq nr ns b">Env</code>接口中，我添加了<code class="fe np nq nr ns b">ANIMALS</code>作为属性，其类型为<code class="fe np nq nr ns b">KVNamespace</code>。</p><p id="6a58" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">有了这个改变，我们将能够使用<code class="fe np nq nr ns b">env.ANIMALS</code>访问KV名称空间，并在其上调用方法来读取和写入数据。现在，我们可以更新API的代码来使用KV名称空间。</p><h1 id="ffbd" class="me mf iv bd mg mh mi mj mk ml mm mn mo kb mp kc mq ke mr kf ms kh mt ki mu mv bi translated">更新API以从您的KV名称空间读取和写入数据</h1><p id="643c" class="pw-post-body-paragraph le lf iv lh b li mw jw lk ll mx jz ln mb my lq lr mc mz lu lv md na ly lz ma io bi translated">我们现在已经创建了一个KV名称空间，允许我们的worker访问，并通知我们的代码KV名称空间已经存在。与在常规应用程序中设置数据库连接的痛苦相比，这相当简单，尤其是考虑到它自动为我们处理不同的环境！</p><p id="b6a5" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">继续围绕动物构建API的例子，让我们更新API的实现，以便能够从KV名称空间返回动物，以及创建新的动物并将其存储在KV名称空间中。</p><h2 id="ca86" class="nx mf iv bd mg oc od dn mk oe of dp mo mb og oh mq mc oi oj ms md ok ol mu om bi translated">添加读写数据的函数</h2><p id="3548" class="pw-post-body-paragraph le lf iv lh b li mw jw lk ll mx jz ln mb my lq lr mc mz lu lv md na ly lz ma io bi translated">为了简单起见，我将所有代码都添加到了<code class="fe np nq nr ns b">src/index.ts</code>中，但是您可能希望将它拆分到其他文件中，以使其更加整洁。首先，让我们添加一些函数来帮助我们与KV名称空间进行交互:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="b369" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">这些是围绕KV名称空间的简单包装器，允许我们的代码检索所有动物，更新动物，并添加单个动物。</p><p id="c46c" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">我们不能在KV中存储原生类型，比如对象，所以在存储数据时必须序列化到JSON，或者在读取数据时从JSON反序列化。如果存储的是简单的字符串，可以直接使用KV以外的值。</p><p id="fdf6" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">我选择将所有数据作为JSON中的一个对象数组存储在一个键下，但是如何安排数据取决于您。例如，我可以选择将每个动物存储为自己的键。</p><p id="3b13" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">如您所见，KV有一个简单的接口，它公开了<code class="fe np nq nr ns b">put</code>来存储数据，公开了<code class="fe np nq nr ns b">get</code>来读取数据。这里我不需要它们，但是您也可以使用<code class="fe np nq nr ns b">delete</code>删除数据，并使用<code class="fe np nq nr ns b">list</code>列出存储在名称空间中的所有键。</p><p id="0f7f" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">如果我将每种动物存储为自己的键，那么后者对于显示动物列表会特别有帮助。如果我们只允许同一个动物被创造一次而不被更新，这也是避免竞争条件的更好选择。不过，这确实使代码变得更加复杂，所以我想在这个演示中尽可能保持简单。</p><h2 id="cfc3" class="nx mf iv bd mg oc od dn mk oe of dp mo mb og oh mq mc oi oj ms md ok ol mu om bi translated">更新API路线</h2><p id="486f" class="pw-post-body-paragraph le lf iv lh b li mw jw lk ll mx jz ln mb my lq lr mc mz lu lv md na ly lz ma io bi translated">最后一步是更新我们的API路由，以使用新定义的方法。这段代码仍在<code class="fe np nq nr ns b">src/index.ts</code>中，非常简单:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="9b84" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">前两个端点之前已经存在；我刚刚更新了它们来读取KV的数据。最后一个端点POST是新的。它允许我们用JSON主体向<code class="fe np nq nr ns b">POST /animals</code>发送请求，如下所示:</p><pre class="kl km kn ko gt nt ns nu nv aw nw bi"><span id="1607" class="nx mf iv ns b gy ny nz l oa ob">{<br/> "name": "chicken",<br/> "type": "bird"<br/>}</span></pre><p id="e4b6" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">一旦请求被设置，一个新的动物将在KV中被创建。然后，您可以通过点击<code class="fe np nq nr ns b">GET /animals</code>来查看所有动物，并通过点击<code class="fe np nq nr ns b">GET /animals/:id</code>使用响应中返回的任何ID来检索单个动物。</p><p id="d944" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">如果你正在寻找一个方便的桌面应用程序来与你的API进行交互，我建议试试Postman。</p><p id="b146" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">这就是全部了。您现在可以使用<code class="fe np nq nr ns b">npm start</code>运行我们的worker(或者使用<code class="fe np nq nr ns b">npm run deploy</code>将其部署到生产环境中)并查看您的API的运行情况，包括数据存储！</p><h1 id="38b1" class="me mf iv bd mg mh mi mj mk ml mm mn mo kb mp kc mq ke mr kf ms kh mt ki mu mv bi translated">摘要</h1><p id="ecc6" class="pw-post-body-paragraph le lf iv lh b li mw jw lk ll mx jz ln mb my lq lr mc mz lu lv md na ly lz ma io bi translated">如果您一直坚持下去，希望您现在已经有了一个具有工作数据存储的API，并且仍然可以免费使用Cloudflare(除非您的API变得非常受欢迎，但是这是一个好问题！).</p><p id="9d3e" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">当使用KV时，您可能会看到不同的延迟时间，因为您的数据存储在中央数据中心，并且更多地在本地缓存。因此，根据它重试信息的位置，响应时间可能会有所不同，但根据我的经验，在生产中仍然总是在150毫秒以内。此外，您的数据被访问得越频繁，从缓存中返回的可能性就越大。</p><p id="cda7" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">如果你需要KV提供的更强的一致性保证，我推荐你看看他们的<a class="ae la" href="https://developers.cloudflare.com/workers/learning/using-durable-objects/" rel="noopener ugc nofollow" target="_blank">持久对象</a>。它不会以最终一致的方式运行，因为在同一时间只有一个对象存在。然而，有一个小成本。</p><p id="7f2b" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">我现在使用Cloudflare作为我所有小型辅助项目的首选，快速、廉价地开发API和网站原型。我认为他们的工具非常容易使用，他们在免费层的使用率非常高。</p><p id="f776" class="pw-post-body-paragraph le lf iv lh b li lj jw lk ll lm jz ln mb lp lq lr mc lt lu lv md lx ly lz ma io bi translated">关于更多的阅读，我推荐阅读<a class="ae la" href="https://developers.cloudflare.com/workers/runtime-apis/kv/" rel="noopener ugc nofollow" target="_blank"> KV文档</a>或者更深入地阅读<a class="ae la" href="https://developers.cloudflare.com/workers/learning/how-kv-works/" rel="noopener ugc nofollow" target="_blank"> KV如何工作</a>。你可以在这里看到完整的源代码<a class="ae la" href="https://github.com/apeacock1991/cloudflare_worker_api/tree/with_persistence" rel="noopener ugc nofollow" target="_blank">，在这里</a>看到这个API版本和之前版本<a class="ae la" href="https://github.com/apeacock1991/cloudflare_worker_api/compare/with_persistence" rel="noopener ugc nofollow" target="_blank">之间的变化。</a></p><pre class="kl km kn ko gt nt ns nu nv aw nw bi"><span id="632b" class="nx mf iv ns b gy ny nz l oa ob"><strong class="ns iw">My book, Creating Software with Modern Diagramming Techniques, is out now!</strong></span><span id="cb73" class="nx mf iv ns b gy on nz l oa ob"><a class="ae la" href="https://pragprog.com/titles/apdiag/creating-software-with-modern-diagramming-techniques/" rel="noopener ugc nofollow" target="_blank">Click here</a> to learn how to create diagrams to communicate information more directly and clearly than words ever can. Using only text-based markup, powered by Mermaid, create meaningful and attractive diagrams to document your domain, visualize user flows, reveal system architecture at any desired level, and much more!</span></pre></div></div>    
</body>
</html>