<html>
<head>
<title>3 Ways to Observe App’s Lifecycle in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中观察应用生命周期的3种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-3-ways-to-observe-apps-life-cycle-in-swiftui-e9be79e75fef?source=collection_archive---------3-----------------------#2022-05-26">https://betterprogramming.pub/swiftui-3-ways-to-observe-apps-life-cycle-in-swiftui-e9be79e75fef?source=collection_archive---------3-----------------------#2022-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/210a35c0f23c115b9a138b33c6583d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aYlxlmpTTA1MC3VK"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">马克西姆·霍普曼在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5299" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在UIKit中有些事情并不困难，但是在SwiftUI中。跟踪应用的生命周期就是其中之一。我们不得不编写额外的代码来跟踪状态，如<code class="fe lb lc ld le b">AppDelegate</code>(或<code class="fe lb lc ld le b">SceneDelegate</code>)中提供的<a class="ae kc" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623076-applicationwillenterforeground" rel="noopener ugc nofollow" target="_blank">应用程序将进入前台</a>或<a class="ae kc" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622997-applicationdidenterbackground" rel="noopener ugc nofollow" target="_blank">应用程序将进入后台</a>。</p><p id="7719" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实上，除了将应用程序转回过去的版本，还有一些可能的解决方案可以让SwiftUI变得更加简单。我想在这篇文章中介绍一下我是如何处理这个问题的，并向你展示一些例子。</p><h1 id="ec40" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">摘要</h1><ol class=""><li id="4551" class="md me iq kf b kg mf kk mg ko mh ks mi kw mj la mk ml mm mn bi translated">把<code class="fe lb lc ld le b">AppDelegate</code>和<code class="fe lb lc ld le b">SceneDelegate</code>带回来(iOS 13+)</li><li id="0c78" class="md me iq kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated"><code class="fe lb lc ld le b">scenePhase</code>、<code class="fe lb lc ld le b">.onChange</code>和<code class="fe lb lc ld le b">.onOpenUrl</code> (iOS 14+)</li><li id="88c3" class="md me iq kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated"><code class="fe lb lc ld le b">NotificationCenter</code> (iOS 4+)和<code class="fe lb lc ld le b">Combine</code> (iOS 13+)</li></ol><h1 id="be26" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">参考</h1><div class="mt mu gp gr mv mw"><a href="https://developer.apple.com/documentation/uikit/app_and_environment/managing_your_app_s_life_cycle" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd ir gy z fp nb fr fs nc fu fw ip bi translated">管理应用的生命周期</h2><div class="nd l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">苹果开发者文档—developer.apple.com</p></div></div></div></a></div></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="78a4" class="lf lg iq bd lh li nl lk ll lm nm lo lp lq nn ls lt lu no lw lx ly np ma mb mc bi translated">1.将AppDelegate和SceneDelegate带回来(iOS 13+)</h1><p id="6aae" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">一种方法是将<code class="fe lb lc ld le b">AppDelegate</code>和<code class="fe lb lc ld le b">SceneDelegate</code>带回来。对于那些在SwiftUI推出之前一直在开发iOS应用的人来说，这可能是最熟悉的方式。这里有一个例子:</p><figure class="nt nu nv nw gt jr"><div class="bz fp l di"><div class="nx ny l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">你可以这样使用<code class="fe lb lc ld le b">AppDelegate</code></p></figure><p id="f251" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也可以跳过<code class="fe lb lc ld le b">SceneDelegate</code>。然后，你会回到甚至更老式的方法，只使用<code class="fe lb lc ld le b">AppDelegate</code>来管理事件。</p><p id="aed7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不确定这些代表还能支持多久，但目前来看，这似乎不是什么大事。</p><h1 id="fc85" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">2.配合使用scenePhase。onChange (iOS 14+)</h1><p id="f204" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">在iOS 13中从UIKit过渡到SwiftUI真是让人头疼。与UIKit相比，很多特性没有实现，构建视图组件真的很烦人。</p><p id="b808" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论如何，在iOS 14中，苹果对SwiftUI进行了几项改进。<code class="fe lb lc ld le b">scenePhase</code>和<code class="fe lb lc ld le b">.onChange</code>就是那些东西的零件。让我给你看一个例子。</p><figure class="nt nu nv nw gt jr"><div class="bz fp l di"><div class="nx ny l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">你可以在<a class="ae kc" href="https://developer.apple.com/documentation/swiftui/scenephase" rel="noopener ugc nofollow" target="_blank">官方文件</a>中查看关于<code class="fe lb lc ld le b">scenePhase</code>的更多细节。</p></figure><p id="acfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，它非常容易使用。然而，有一个关键的缺点是<code class="fe lb lc ld le b">scenePhase</code>只提供三种状态:<code class="fe lb lc ld le b">active</code>、<code class="fe lb lc ld le b">inactive</code>、<code class="fe lb lc ld le b">background</code>。</p><p id="8424" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于那些想象出完美替代<code class="fe lb lc ld le b">AppDelegate</code>的人来说，这将是一个很大的失望。除此之外，可用性(iOS 14 +)是另一个让开发者不愿使用的壁垒。</p><h2 id="6a5e" class="nz lg iq bd lh oa ob dn ll oc od dp lp ko oe of lt ks og oh lx kw oi oj mb ok bi translated">+ <code class="fe lb lc ld le b">onOpenURL</code> (iOS 14+)</h2><p id="b8dd" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">自从<strong class="kf ir">通用链接</strong>推出以来，它已经成为打开应用程序的常用方式。您可能知道，<code class="fe lb lc ld le b">SceneDelegate</code>或<code class="fe lb lc ld le b">AppDelegate</code>一直在处理由url 事件打开的<em class="ol">。这也意味着，在SwiftUI中，我们应该找到其他方法来获得这个事件。</em></p><p id="8a1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，苹果从iOS 14中提供了方法<code class="fe lb lc ld le b">onOpenURL</code>，使我们能够在项目中的任何地方获得opened by url事件。</p><figure class="nt nu nv nw gt jr"><div class="bz fp l di"><div class="nx ny l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">想要更多细节，查看<a class="ae kc" href="https://developer.apple.com/documentation/SwiftUI/View/onOpenURL(perform:)" rel="noopener ugc nofollow" target="_blank">官方文件</a></p></figure><p id="4082" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有兴趣可以看看<a class="ae kc" href="https://developer.apple.com/ios/universal-links/" rel="noopener ugc nofollow" target="_blank">通用链接</a>和<a class="ae kc" href="https://developer.apple.com/documentation/xcode/defining-a-custom-url-scheme-for-your-app" rel="noopener ugc nofollow" target="_blank">自定义方案链接</a>。</p><h1 id="8825" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">3.通知中心(iOS 4+)</h1><p id="fd2e" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">这是用Swift观察生命周期事件的另一种传统方式。在类<code class="fe lb lc ld le b">UIApplication</code>中，iOS提供了几个通知(<a class="ae kc" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate" rel="noopener ugc nofollow" target="_blank">UIApplicationDelegate | Apple Developer Documentation</a>)。</p><p id="9b45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">特别地，在该文档中，类别<strong class="kf ir">处响应App生命周期事件</strong>的通知与生命周期事件相关。你所要做的就是为你的目的选择一个合适的通知。</p><p id="9030" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将向您展示两个例子，在应用程序进入或确实进入每种状态时得到通知。</p><h2 id="a9c6" class="nz lg iq bd lh oa ob dn ll oc od dp lp ko oe of lt ks og oh lx kw oi oj mb ok bi translated">A.notification center+add observer(iOS 4+)</h2><figure class="nt nu nv nw gt jr"><div class="bz fp l di"><div class="nx ny l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><code class="fe lb lc ld le b">Using #selector</code>和<code class="fe lb lc ld le b">@objc func</code>接收通知</p></figure><figure class="nt nu nv nw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/cca3f13cb915b4fefc11ae6a793339c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/1*_ti4fQzsZJ0VkD8GPrM62g.gif"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">为了展示它是如何工作的，我给出了3秒钟的延迟来改变文本</p></figure><p id="ccfb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很容易理解。在给定的选项中选择合适的<code class="fe lb lc ld le b">Notification</code>，并使用<code class="fe lb lc ld le b">addObserver</code>将其添加到<code class="fe lb lc ld le b">NotificationCenter</code>中。如你所见，它工作得很好。</p><h2 id="f106" class="nz lg iq bd lh oa ob dn ll oc od dp lp ko oe of lt ks og oh lx kw oi oj mb ok bi translated">B.通知中心+联合收割机(iOS 13+)</h2><figure class="nt nu nv nw gt jr"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="2fb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你在<a class="ae kc" href="https://developer.apple.com/documentation/combine/routing-notifications-to-combine-subscribers" rel="noopener ugc nofollow" target="_blank"> her </a> e中看到的，苹果提供了一种从iOS 13将<code class="fe lb lc ld le b">Notifications</code>路由到<code class="fe lb lc ld le b">Combine</code>用户的方式。</p><p id="c9e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来使用<code class="fe lb lc ld le b">addObserver</code>并没有什么优势，但实际上它拥有非常强大的功能。有了这个，你就可以写一个像下面这样的<code class="fe lb lc ld le b">Publisher</code>函数了。</p><figure class="nt nu nv nw gt jr"><div class="bz fp l di"><div class="nx ny l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">发布者将进入前台事件</p></figure><p id="0291" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过用<code class="fe lb lc ld le b">enum</code>对事件进行分类，并将其作为参数提供给函数，可以使它更有用。</p><figure class="nt nu nv nw gt jr"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="9df2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过包装该方法，您还可以以多种方式利用它。</p><figure class="nt nu nv nw gt jr"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="nt nu nv nw gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/859b23d03efc1b354aab27fe9d8ce141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*jP554idgH9hXOgLjXeluAA.gif"/></div></figure><p id="a696" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了一个非常有用的生命周期观察器，你可以根据自己的需要添加更多的特性。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="574f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以根据自己的需要选择其中之一，但我个人更喜欢最后一种使用<code class="fe lb lc ld le b">Combine</code>的方法。<code class="fe lb lc ld le b">Publisher</code>肯定比其他的更有优势，因为它与SwiftUI配合得很好，而且苹果一直在试图扩展对<code class="fe lb lc ld le b">Combine</code>的支持。</p><p id="0165" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>