<html>
<head>
<title>How To Test Reference Cycles in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在iOS中测试参考周期</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-test-reference-cycles-in-ios-940eb2af9997?source=collection_archive---------4-----------------------#2021-08-23">https://betterprogramming.pub/how-to-test-reference-cycles-in-ios-940eb2af9997?source=collection_archive---------4-----------------------#2021-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b8ed" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何在Swift应用程序或库中测试参考周期的建议</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/07ab889cdf50831cb690397a157d8ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A98xjGsXKnnuc1-g"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">本杰明·索乌在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9520" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">受Vincent Pradeilles<a class="lv lw ep" href="https://medium.com/u/341500d28721?source=post_page-----940eb2af9997--------------------------------" rel="noopener" target="_blank">的</a>这篇文章的启发，我开始思考如何创建单元测试来检查我们的类是否被正确地释放。</p><h1 id="7559" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">问题是</h1><p id="f7ae" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在Swift中，类通常不能被正确释放的主要原因是因为<strong class="lb iu">引用周期。</strong></p><p id="232d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在它们最简单的形式中，我们有一个类<code class="fe mu mv mw mx b">A</code>的实例，它拥有另一个类<code class="fe mu mv mw mx b">B</code>实例的强引用，后者拥有对第一个<code class="fe mu mv mw mx b">A</code>实例的强引用。因此，<code class="fe mu mv mw mx b">A</code>的引用是<code class="fe mu mv mw mx b">B</code>，而【】的引用是<code class="fe mu mv mw mx b">A</code>。在代码中，它看起来如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d4eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个问题，因为一个引用使另一个保持活动。通常，当一个变量超出它的作用域时，系统会释放它，释放内存。只有当它可以释放它包含的所有变量时，才能做到这一点。在上述情况下，那是不可能的。最重要的是，在代码中也很难发现这种设置。</p><p id="6796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想要解决的问题是，我们如何以一种可靠的方式测试这种情况的发生？这个问题也远不简单。我们需要考虑很多微妙之处。</p><p id="18dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在理想情况下，当我们将类<code class="fe mu mv mw mx b">A</code>设置为<code class="fe mu mv mw mx b">nil</code>时，我们希望看到包含在<code class="fe mu mv mw mx b">A</code>中的类<code class="fe mu mv mw mx b">B</code>也被释放。如果发生这种情况，问题就解决了，内存已经被释放。但是我们没有对<code class="fe mu mv mw mx b">A</code>的引用来检查它的属性了。</p><p id="65e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在类<code class="fe mu mv mw mx b">A</code>之外创建类<code class="fe mu mv mw mx b">B</code>并传递它，我们仍然不会看到<code class="fe mu mv mw mx b">B</code>被释放，因为创建<code class="fe mu mv mw mx b">B</code>的上下文仍然持有对它的引用，因此<code class="fe mu mv mw mx b">B</code>不会被释放。</p><h1 id="6d83" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">一个可能的解决方案:包装器</h1><p id="fbc3" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">一种解决方案是将我们想要检查的类放在一个包装器中。希望当包装器被释放时，它包含的实例也被释放。</p><p id="a2f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还是不行。引用周期保持<code class="fe mu mv mw mx b">A</code>和<code class="fe mu mv mw mx b">B</code>活动，即使包装器的<code class="fe mu mv mw mx b">deinit</code>被实际调用。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="dd73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们正在创建可以相互引用的类<code class="fe mu mv mw mx b">A</code>和<code class="fe mu mv mw mx b">B</code>，以便创建一个引用循环。</p><p id="2b80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们创建一个<code class="fe mu mv mw mx b">DeinitObserver</code>类，它是任何类型的泛型。此类型要求它必须是引用类型。包装器接受一个<code class="fe mu mv mw mx b">XCTestExpectation</code>，我们可以在<code class="fe mu mv mw mx b">deinit</code>中实现它，并接受一个工厂函数来创建被包装的元素。工厂函数是必需的，因此外部上下文不能保持对包装对象的强引用。现在，只有包装器保留了对<code class="fe mu mv mw mx b">Wrapped</code>变量的强引用。这个想法是，如果有一个引用周期，它不会被释放，测试将失败。</p><p id="9cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们编写测试。我们创建期望(第32行)，包装器，并初始化闭包中的引用循环。注意，当闭包结束时，<code class="fe mu mv mw mx b">a</code>和<code class="fe mu mv mw mx b">b</code>超出了闭包的作用域，所以闭包不会保持对它们的强引用。</p><p id="d2c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们对测试采取行动:我们将包装器设置为<code class="fe mu mv mw mx b">nil</code>，然后等待。我们的假设是测试会失败。要释放包装器，它必须释放被包装的对象，但是有一个引用循环，它们不能被释放。测试应该挂起，直到超时。</p><p id="f432" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，这是测试输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/199c73f2ac2af21b766fd8cec561bbb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eiUya_aSp3P9UHOrMP093A.png"/></div></div></figure><p id="a0d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试通过了！但是<code class="fe mu mv mw mx b">A</code>的<code class="fe mu mv mw mx b">deinit</code>和<code class="fe mu mv mw mx b">B</code>的<code class="fe mu mv mw mx b">deinit</code>都没有被调用。这里发生的事情是，<code class="fe mu mv mw mx b">Wrapper</code>可以被安全地解除分配:还有一个东西让<code class="fe mu mv mw mx b">A</code>活着，那就是<code class="fe mu mv mw mx b">B</code>，还有一个东西让<code class="fe mu mv mw mx b">B</code>活着，那就是<code class="fe mu mv mw mx b">A</code>。因此Swift释放了<code class="fe mu mv mw mx b">Wrapper</code>,但是<code class="fe mu mv mw mx b">A</code>和<code class="fe mu mv mw mx b">B</code>留在堆中，保持彼此存活。</p><p id="944b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">有趣的事实:</strong>即使将<code class="fe mu mv mw mx b">var wrapped: Wrapped</code>变量变成<code class="fe mu mv mw mx b">weak</code>变量也不能解决问题。测试仍然通过，并且没有调用<code class="fe mu mv mw mx b">deinit</code>。您可以通过更改代码片段中的代码来亲自尝试。</p><p id="5155" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最糟糕的是，我们无法以任何方式观察到被包裹的<code class="fe mu mv mw mx b">deinit</code> s。它们隐藏在包装器中，在没有引用周期的情况下，没有办法检查内存是否已经被释放。</p><p id="7973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包装方法虽然很有前途，但不能解决这个问题。</p><h1 id="2542" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">真正的解决方案:依赖注入</h1><p id="8d82" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">解决方案来自我们之前看到的相同的包装器。我们可以在类中注入一个小闭包来监视<code class="fe mu mv mw mx b">deinit</code>调用。</p><p id="9b0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在测试中，我们通过调用<code class="fe mu mv mw mx b">expectation.fulfill() </code>方法来实现闭包，同时等待期望完成。</p><p id="2130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看几个例子，以及它们是如何表现的。</p><h2 id="f29a" class="nb ly it bd lz nc nd dn md ne nf dp mh li ng nh mj lm ni nj ml lq nk nl mn nm bi translated">试验0-基本情况:无参考循环</h2><p id="208b" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">第一个例子是最简单的，目的是验证我们的想法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3d4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的类<code class="fe mu mv mw mx b">A</code>没有任何参考周期。它有一个我们在<code class="fe mu mv mw mx b">deinit</code>中调用的闭包。</p><p id="30aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在测试中，我们简单地:</p><ul class=""><li id="595b" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">创造期望</li><li id="b8f1" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">创建的实例</li><li id="eb5f" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">将其设置为零</li><li id="aa30" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">等待期望完成</li></ul><p id="9b5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>为什么我们需要一个闭包？我们不能在课堂上直接传递一个期望吗？不幸的是，没有。我们不能在我们的类<code class="fe mu mv mw mx b">A</code>中有一个可选的<code class="fe mu mv mw mx b"><em class="ob">XCTestExpectation</em></code>来代替闭包，因为我们不能在测试目标之外使用<code class="fe mu mv mw mx b">XCTest</code>框架。</p><p id="d0af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出证实一切正常，我们的方法有效。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/711cabe7c851d1e2e93602deeab8d771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rLoAjKeRFla9e8ay2naF5g.png"/></div></div></figure><h2 id="90c7" class="nb ly it bd lz nc nd dn md ne nf dp mh li ng nh mj lm ni nj ml lq nk nl mn nm bi translated">试验1 —参考循环</h2><p id="547c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在这个测试中，我们使用另外两个类，<code class="fe mu mv mw mx b">B</code>和<code class="fe mu mv mw mx b">C</code>。这两个类都有很强的相互参照性。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="a6bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">班级结构是一样的。唯一的区别是<code class="fe mu mv mw mx b">B</code>持有一个对<code class="fe mu mv mw mx b">C</code>类型变量的引用，反之亦然。变量被打上了标记(<code class="fe mu mv mw mx b">!</code>)，这样我们就不必在创建它们时传递引用。这是告诉编译器的一种方式:<em class="ob">“不要担心这个变量的创建。我会处理的。”</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3fe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">甚至测试也遵循与前一个相同的模式。</p><ul class=""><li id="b004" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">我们创造期望。</li><li id="c7e0" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">我们创造物品。</li><li id="79b6" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">我们创建参考循环。</strong></li><li id="be1c" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">然后我们将两个变量都设置为<code class="fe mu mv mw mx b">nil</code>。</li><li id="5845" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">我们等着。</li></ul><p id="33c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试本身包含对这两个变量的引用，我们必须将它们都设置为<code class="fe mu mv mw mx b">nil</code>来尝试释放它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/cd3bebd6a6f7123e2aa41cbf85245181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zx4HM8uj7Qn8TPIvsukxgA.png"/></div></div></figure><p id="3757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们将它们都设置为<code class="fe mu mv mw mx b">nil</code>，但是测试没有通过。没有调用<code class="fe mu mv mw mx b">deinit</code>,因为<code class="fe mu mv mw mx b">b</code>保留了对<code class="fe mu mv mw mx b">c</code>的强引用，反之亦然。</p><h2 id="acbe" class="nb ly it bd lz nc nd dn md ne nf dp mh li ng nh mj lm ni nj ml lq nk nl mn nm bi translated">测试3 —弱变量</h2><p id="3f53" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在这个测试中，我们创建了两个新的类<code class="fe mu mv mw mx b">D</code>和<code class="fe mu mv mw mx b">E</code>。<code class="fe mu mv mw mx b">D</code>拥有对<code class="fe mu mv mw mx b">E</code>的强引用，而<code class="fe mu mv mw mx b">E</code>拥有对<code class="fe mu mv mw mx b">D</code>的弱引用。让我们看看会发生什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="a4a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里也有同样的结构。注意第14行中的关键字<code class="fe mu mv mw mx b">weak</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/d246beacfce1e44c2ddfd1f4eb511bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zHsZUgi9DrOyGF8nRI2CJQ.png"/></div></div></figure><p id="95b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试通过，并且<code class="fe mu mv mw mx b">deinit</code>被正确调用。在这个测试中，我们仍然必须将两个实例都设置为nil才能看到测试通过，因为测试本身保留了对两个变量的强引用。理论上，我们希望<code class="fe mu mv mw mx b">deinit</code>只是<code class="fe mu mv mw mx b">D</code>，并且看到<code class="fe mu mv mw mx b">E</code>也是<code class="fe mu mv mw mx b">deinit</code>。</p><p id="d863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以这样做，并将测试修改如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="fecd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第5行，我们<strong class="lb iu">创建对象<code class="fe mu mv mw mx b">E</code>并将其直接赋值给变量<code class="fe mu mv mw mx b">d</code>。这防止测试保存对变量<code class="fe mu mv mw mx b">e</code>的引用。然后，在第6行，我们创建了<code class="fe mu mv mw mx b">d</code>和<code class="fe mu mv mw mx b">e</code>之间的循环。幸运的是，由于类别<code class="fe mu mv mw mx b">E</code>中的<code class="fe mu mv mw mx b">weak</code>关键字，这个循环是一个弱循环。</strong></p><p id="3803" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试现在通过了，这是我们获得的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/9d27ec811616a445b109bbd5e40b82a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRlkdZm2M_kVsJBpCygnUA.png"/></div></div></figure><p id="a127" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在视图控制器中应用<a class="ae ky" href="https://www.swiftbysundell.com/articles/delegation-in-swift/" rel="noopener ugc nofollow" target="_blank">委托模式</a>(归功于<a class="lv lw ep" href="https://medium.com/u/5486d7313999?source=post_page-----940eb2af9997--------------------------------" rel="noopener" target="_blank"> John Sundell </a>)时，情况完全相同:主视图控制器持有对一个对象的强引用。对象以委托的形式保存视图控制器的弱引用。当我们取消视图控制器的初始化时，它也可以取消其他对象的初始化，因为没有人持有对它的强引用。</p><h2 id="7c36" class="nb ly it bd lz nc nd dn md ne nf dp mh li ng nh mj lm ni nj ml lq nk nl mn nm bi translated">测试4 —一个真实的例子</h2><p id="4a80" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">现在，回到我的灵感来源，让我们尝试将我们所学的应用到现实世界的用例中。</p><p id="6e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将重用<a class="lv lw ep" href="https://medium.com/u/341500d28721?source=post_page-----940eb2af9997--------------------------------" rel="noopener" target="_blank"> Vincent Pradeilles </a>在他的视频中创建的代码，稍作修改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="38ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码片段包含与视频完全相同的失败代码。我们只是添加了我们的小观察者来窥探它的<code class="fe mu mv mw mx b">deinit</code>。</p><p id="b76d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以编写一个简单的测试，类似于本文中的其他测试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="4dfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再次:</p><ul class=""><li id="7346" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">创造期望</li><li id="e449" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">创建对象</li><li id="5154" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">将其设置为<code class="fe mu mv mw mx b">nil</code></li><li id="256f" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">等待</li></ul><p id="1f4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从视频中我们知道这里有一个参考循环，测试失败。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/1ebed4a32b1e60b33c477625c68a62ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctlTwQMn2eYgkptxh_RrRg.png"/></div></div></figure><p id="85d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们完成了测试驱动开发方法的前两步:</p><ol class=""><li id="4669" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu og nt nu nv bi translated">我们的代码中有一个错误。</li><li id="e2ec" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu og nt nu nv bi translated">我们创建了一个测试来捕捉它的失败。</li></ol><p id="9943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，是时候修复这个错误了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="77a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的不同是在第8行，在那里我们做了<code class="fe mu mv mw mx b">self</code>的引用<code class="fe mu mv mw mx b">weak</code>。我们再次运行测试，它通过了。测试驱动开发的第三步:完成了！</p><p id="795b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这种方法，我们就不能在这个问题上倒退:我们有一个测试来捕捉它。</p><h1 id="e900" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">结论</h1><p id="885c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">今天的文章深入探讨了参考周期和单元测试。这件事很棘手，我尽量简化了。</p><p id="207e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是在任何可能的时候都更喜欢值语义的另一个原因。对于值类型，我们不能有引用周期和内存泄漏。</p><p id="edff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们学习了如何测试我们的类是否被释放以及何时释放。我们探索了一个解决方案，如果我们对它们的生命周期有疑问，我们可以将它应用于我们的任何类。</p><p id="8a6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将这种技术应用到现实世界的例子中，利用测试驱动的开发方法，这种方法也将防止主题上的倒退。</p><p id="daf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法有一个缺点:它稍微污染了我们的类型。我们需要添加观察者闭包、<code class="fe mu mv mw mx b">deinit</code>代码，以及在<code class="fe mu mv mw mx b">init</code>中添加一个额外的参数来注入闭包。这最后一部分可能尤其令人担忧。我们不想公开一个让我们的用户在<code class="fe mu mv mw mx b">deinit</code>中注入闭包的API。</p><p id="d7e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我们可以解决这个小问题:我们可以有两个初始化器，一个带参数，一个不带参数。然后，我们可以将带有参数的<code class="fe mu mv mw mx b">init</code>包装成一个<code class="fe mu mv mw mx b">#if DEBUG</code>条件。这样，如果有人试图在生产中使用它，该应用程序根本不会编译。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="236e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种方法，危险的<code class="fe mu mv mw mx b">init</code>甚至不会包含在我们的框架或应用程序的发布版本中。<code class="fe mu mv mw mx b">deinitObserver</code>闭合将始终为<code class="fe mu mv mw mx b">nil</code>并像<code class="fe mu mv mw mx b">noop</code>一样工作！</p></div></div>    
</body>
</html>