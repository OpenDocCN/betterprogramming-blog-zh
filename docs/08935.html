<html>
<head>
<title>A Complete Guide to API Testing With Postman</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Postman测试完全指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-complete-guide-to-api-testing-with-postman-bf8d8f9cb110?source=collection_archive---------6-----------------------#2021-06-28">https://betterprogramming.pub/a-complete-guide-to-api-testing-with-postman-bf8d8f9cb110?source=collection_archive---------6-----------------------#2021-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2dda" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">减少担心破坏现有功能的时间</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0db03ba682ac385d000a3d37661c8b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vzf1PfrzQlAA_Kx9nbn_ug.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@sigmund?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Sigmund </a>在<a class="ae kv" href="https://unsplash.com/s/photos/testing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="4c97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名软件开发人员，在为客户发布下一个特性之前，你总是正确的。但是你的团队越快，无意中破坏先前发布的特性的可能性就越大。这就是为什么你应该仔细地回归测试你的API。</p><p id="9fb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank">邮递员</a>是这项工作的绝佳工具。它使您能够轻松地针对API执行请求，运行请求前和请求后脚本，对响应进行断言，并在旅程和场景中将请求聚集在一起。</p><p id="07aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章将指导你从开始使用Postman到将你的旅程作为一个自动化的质量关步骤集成到你的发布管道中。</p><p id="ff19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">主题概述:</p><ul class=""><li id="42af" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">入门—简介和基本概念。</li><li id="ce4c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用集合和场景—将请求聚集在一起。</li><li id="af40" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">环境和变量-阶段的局部和全局范围的变量。</li><li id="995f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">请求前和请求后脚本—在请求前后执行脚本。</li><li id="c037" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">断言—验证响应。</li><li id="edb2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">从CLI运行Postman使用newman进行终端执行。</li><li id="c93a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">还有呢！—简短总结并讨论其他邮递员功能。</li><li id="9846" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">关键要点</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="79a1" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">入门指南</h1><p id="2f2d" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">下载安装Postman后，我们可以直接跳转到基础。为了简单起见，我将使用由<a class="ae kv" href="https://mockapi.io" rel="noopener ugc nofollow" target="_blank"> mockAPI.io </a>提供的模拟API。如果您想继续阅读本文，您可以创建自己的资源或者重用我提供的URL。</p><p id="966f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们定义我们的第一个目标:</p><ol class=""><li id="df71" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nk ly lz ma bi translated">为我们的模拟API创建一个<code class="fe nl nm nn no b">POST</code>、<code class="fe nl nm nn no b">GET</code>、<code class="fe nl nm nn no b">PUT</code>和<code class="fe nl nm nn no b">DELETE</code>请求。</li><li id="278d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nk ly lz ma bi translated">将我们的请求打包成一个集合。</li><li id="7a64" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nk ly lz ma bi translated">利用环境变量。</li><li id="130a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nk ly lz ma bi translated">设置用于生成随机测试数据的预请求脚本。</li><li id="8093" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nk ly lz ma bi translated">通过请求后脚本验证我们的响应并提取数据。</li></ol><p id="5e0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们简单的API的样子:</p><ul class=""><li id="986a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nl nm nn no b">POST /api/users</code> —用于注册用户</li><li id="b262" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nl nm nn no b">GET /api/users/{id}</code> —用于检索/更新/删除用户</li></ul><p id="8d24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始吧。</p><p id="c69e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过点击便签簿旁边的<code class="fe nl nm nn no b">+</code>，您可以创建您的第一个请求。Postman的接口非常简单明了，所以你可以直接添加目标URL ( <code class="fe nl nm nn no b">https://60ccaa8b71b73400171f8430.mockapi.io/api/users</code>或者你自己的)并选择<code class="fe nl nm nn no b">POST</code>作为HTTP方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/4362dfb363c50052c8599fe8d3172230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kn30DqrfHv13njsF9qdfGA.png"/></div></div></figure><p id="aabc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们的模拟API将创建第一个用户并返回其标识符。由于API是REST兼容的，我们可以用<code class="fe nl nm nn no b">GET /api/users/{id}</code>检索我们的用户，这将是我们的第二个请求。接下来，我们可以用<code class="fe nl nm nn no b">PUT</code>推送一个更新，在主体内部提供一些随机值(Postman会负责为我们设置正确的<code class="fe nl nm nn no b">Content-Type</code>头)。最后，我们将移除用户，通过在<code class="fe nl nm nn no b">/api/users/{id}</code>上执行<code class="fe nl nm nn no b">DELETE</code> <strong class="ky ir"> </strong>来完成旅程。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="7f24" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">创建集合和方案</h1><p id="0ba6" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">让我们在便签簿上选择<code class="fe nl nm nn no b">New &gt; Collection</code>，为我们的旅程打造一个专属系列。创建集合后，您可以将之前创建的请求保存到其中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/92f49edd35283993a2fc4f9c24185e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N5S7d6uH5rZ69eHiXpmghg.png"/></div></div></figure><p id="a3e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">集合允许你将你的旅程分成不同的项目或不同的商业案例。另一个很棒的特性是将文件夹添加到我们的集合中，对请求进行另一个细粒度的聚类，使之成为专用场景。当我们稍后通过命令行运行我们的旅程时，如果断言失败，拥有清晰分离的场景将有助于我们精确地指出有缺陷的过程。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="eedc" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">环境和变量</h1><p id="ad0a" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">很可能您想要测试的不仅仅是一个阶段。大多数项目至少有一个预览和一个生产环境，在这两个阶段运行您的测试是非常有价值的。不仅目标主机是一个变量，而且通过请求传递的参数也可能不同。</p><p id="fc15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是环境发挥作用的地方。环境使您能够定义可以在您的请求以及请求前和请求后脚本中使用的变量。</p><p id="ae55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建一个新环境，方法是在我们的便笺簿上单击名为<code class="fe nl nm nn no b">crud-user-journey-staging</code>的<code class="fe nl nm nn no b">New &gt; Environment</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/73444d8cdd9c502a1ef463e5f4cac42e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wbaHpZzw1Qv-JIpRmNEzQ.png"/></div></div></figure><p id="912b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经为我们的API添加了主机作为初始值<code class="fe nl nm nn no b">host</code>。这也会自动复制到当前值。</p><p id="9c71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">初始值和当前值有不同的用途:</p><ul class=""><li id="466e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nl nm nn no b">initial value</code> —保存到集合。</li><li id="8688" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nl nm nn no b">current value</code> —仅临时用于会话，但不保存到集合中。这些值仅在本地可用。您可以粘贴您的秘密，而不用担心意外地将它们导出到您的环境中。</li></ul><p id="552e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过经由<code class="fe nl nm nn no b">{{host}}</code>用我们的<code class="fe nl nm nn no b">host</code>变量替换硬编码的域来修改我们的请求。您还可以通过<code class="fe nl nm nn no b">pm.environment.get('$NAME')</code>访问您的环境变量，或者在您的请求前或请求后脚本中用<code class="fe nl nm nn no b">pm.environment.set('$NAME', $VALUE)</code>设置它们。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="0500" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">请求前和请求后脚本</h1><p id="d234" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">Postman使您能够在请求执行前后运行JavaScript代码。这对各种测试需求真的很有帮助:生成随机测试数据、收集秘密、添加一些超时来延迟请求执行，等等。</p><p id="84a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们的例子，让我们定义一个脚本来生成一个随机的用户名和电子邮件地址。我们将利用邮递员的<a class="ae kv" href="https://learning.postman.com/docs/writing-scripts/script-references/variables-list/" rel="noopener ugc nofollow" target="_blank">动态变量</a> <code class="fe nl nm nn no b">randomFirstName</code>和<code class="fe nl nm nn no b">randomLastName</code>。通过用<code class="fe nl nm nn no b">pm.environment.set</code>设置我们的值，我们使那些变量在我们当前的会话中可用，但是不把它们作为可导出的值添加到我们的集合中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2022" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">脚本现在将在发送请求之前生成我们的测试数据，使我们能够在请求体中提供<code class="fe nl nm nn no b">name</code>和<code class="fe nl nm nn no b">email</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/891e961220cd6ce4ffcdcbe3d8551f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lbUGrZQcUBoRNm88P4vNQA.png"/></div></div></figure><p id="5f80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以通过使用<code class="fe nl nm nn no b">Tests</code>选项卡来添加预请求脚本，该选项卡也是为通过添加断言来编写测试执行的验收标准而设计的。我们将在下一节中解决这个问题。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="6387" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">断言</h1><p id="6562" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">现在到了有趣的部分:测试我们的API做了它应该做的事情。让我们为修改后的<code class="fe nl nm nn no b">POST</code> <strong class="ky ir"> </strong>请求添加一些验证规则，并提取所创建的用户标识符，以便我们可以在以后的请求中重用它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="3e5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在测试响应代码是否为<code class="fe nl nm nn no b">HTTP 201</code>，以及响应是否包含我们期望的字段<code class="fe nl nm nn no b">name</code>和<code class="fe nl nm nn no b">email</code>以及我们的值。我们还将<code class="fe nl nm nn no b">id</code>导出到我们的环境变量中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/36ceed34003368e5f4c1e99bd211d5f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7uGGee70mTL2aK0JXA2ImA.png"/></div></div></figure><p id="3f13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一切按预期进行，这就是它的样子。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="7643" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">从CLI运行Postman</h1><p id="250b" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们创建了集合、环境，并定义了包含断言的请求前和请求后脚本。现在，我们想轻松地从CLI执行一切，而不需要安装Postman和使用它的接口。</p><h2 id="9e94" class="nw mo iq bd mp nx ny dn mt nz oa dp mx lf ob oc mz lj od oe nb ln of og nd oh bi translated">导出收藏</h2><p id="17ab" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">第一步，出口我们的环境和产品系列。通过选择右上角的dots菜单来完成此操作，同时选择您的收藏/环境。Postman会将所有内容导出为JSON文件。</p><h2 id="cf4e" class="nw mo iq bd mp nx ny dn mt nz oa dp mx lf ob oc mz lj od oe nb ln of og nd oh bi translated">利用纽曼</h2><p id="d46f" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">为了从我们的终端或构建作业运行我们的集合，我们将使用<a class="ae kv" href="https://github.com/postmanlabs/newman" rel="noopener ugc nofollow" target="_blank"> newman </a>。您可以使用npm或homebrew在全局范围内安装它，但是我更喜欢在Node.js脚本中将它用作一个库。</p><p id="3ad0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建一个<code class="fe nl nm nn no b">runner.ts</code>，它执行我们名为<code class="fe nl nm nn no b">crud-journey</code>的集合，并允许我们传递环境名。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8aa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的环境应该是旅程名称和实际环境标识符的组合(在我们的例子中，我们使用了<code class="fe nl nm nn no b">staging</code>)。</p><p id="9ef7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以通过<code class="fe nl nm nn no b">./runner.ts staging</code>执行邮递员集合。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/b7e64df6c9770e942092d4bf5e42b87a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GXgUBsei91aT13kU9UUEJw.png"/></div></div></figure><p id="95d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">CLI reporter向我们展示了我们的测试结果以及所有的测试断言和控制台输出。</p><p id="518f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这现在可以集成到我们的发布管道中，验证我们的新部署。</p><h2 id="d5a4" class="nw mo iq bd mp nx ny dn mt nz oa dp mx lf ob oc mz lj od oe nb ln of og nd oh bi translated">处理秘密</h2><p id="3902" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">在很多情况下，你需要在旅途中使用秘密。当然，您不希望通过<code class="fe nl nm nn no b">environments</code>文件将它们提交到您的存储库中。</p><p id="e695" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的例子中，所有的应用程序都运行在AWS上，相应的构建工作也是如此。我还使用Secrets Manager来存储秘密，这使得通过aws-sdk很容易检索到它们。</p><p id="3db7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论您如何检索您的秘密，您都可以在执行旅程之前通过Node.js runner脚本轻松地插入它们，因为所有变量都存储在<code class="fe nl nm nn no b">environment</code> JSON文件的<code class="fe nl nm nn no b">values</code>列表中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="69dd" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">还有呢！</h1><p id="5e74" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">当然，这还不是全部。</p><ul class=""><li id="c404" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">还有很多动态变量——Postman提供了许多<a class="ae kv" href="https://learning.postman.com/docs/writing-scripts/script-references/variables-list/" rel="noopener ugc nofollow" target="_blank">变量</a>(例如，用于生成测试数据，比如带有<code class="fe nl nm nn no b">$guid</code>或<code class="fe nl nm nn no b">$timestamp</code>的随机UUIDs，用于当前UNIX时间戳)。</li><li id="2e33" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">为相互TLS配置证书——如果您的后端需要证书，Postman也会为您提供。通过<code class="fe nl nm nn no b">Settings &gt; Certificates</code>，您可以配置不同的证书，每个证书都绑定到某个主机。纽曼也通过<code class="fe nl nm nn no b">--ssl-client-key</code>和<code class="fe nl nm nn no b">--ssl-client-cert</code>来支持这一点。</li><li id="7dcf" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">导出到代码——您可以为您喜欢的语言和HTTP客户端自动生成代码——无论您喜欢使用cURL的bash、使用Axios的Node.js还是其他。Postman提供了很多导出选项。</li><li id="64a8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">控制台<em class="oj"> </em> —有一个控制台向您显示所有请求的详细信息、请求前或请求后脚本中的错误，以及您正在记录到<code class="fe nl nm nn no b">stdout</code>的所有输出。</li><li id="54bf" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">导入OpenAPI JSON定义——如果您正在使用<a class="ae kv" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank"> Swagger </a>(或另一个基于OpenAPI的API文档工具)，您可以将您的API导入Postman。</li><li id="5986" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">跑步者<em class="oj"/>——我们已经了解了如何通过CLI来运行我们的旅程，但是你也可以通过点击<code class="fe nl nm nn no b">Run</code>通过Postman来这样做。您可以选择迭代次数以及每次迭代之间的延迟时间。这对于在将测试作为自动化质量关步骤集成到您的发布管道中之前，确保您的测试的稳定性是非常好的。</li></ul><p id="bc86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Postman正在积极开发中，这是一个非详尽的列表。所以还有更多有待发现。只需查看一下邮递员的<a class="ae kv" href="https://learning.postman.com/docs/getting-started/introduction/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="098a" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">关键要点</h1><p id="710b" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">Postman是测试你的API的很好的第一步，而且门槛很低。特别是对于我想尽早发布的新项目，我依赖于单元测试和基于Postman的API测试的组合。这在过去效果很好。</p><p id="a5fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你自己试试吧。</p><p id="29a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>