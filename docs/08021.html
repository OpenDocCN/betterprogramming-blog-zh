<html>
<head>
<title>5 Powerful Kotlin Extensions From KTX libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">来自KTX库的5个强大的Kotlin扩展</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-powerful-kotlin-extensions-from-ktx-libraries-b10c50504df6?source=collection_archive---------9-----------------------#2021-03-16">https://betterprogramming.pub/5-powerful-kotlin-extensions-from-ktx-libraries-b10c50504df6?source=collection_archive---------9-----------------------#2021-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b933" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您应该知道的扩展</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9386d73afb0b19ec3b749a8898088f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5Qu_Y7TheLlfev3h"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="e235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://developer.android.com/kotlin/ktx" rel="noopener ugc nofollow" target="_blank"> Android KTX </a>是一组带有Kotlin扩展的Android库，用于在使用Jetpack和其他Android库时简化编码。KTX扩展利用Kotlin的特性，为开发人员提供了一种使用Jetpack和其他API的简洁方法。</p><p id="01f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个库或API都有一个单独的Kotlin KTX库，其中包含与该段相关的Kotlin扩展。在本文中，我们将重点关注五个扩展，它们将使Android开发在使用MVVM、LiveData、Firebase和房间数据库时更加容易。</p><p id="5f0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有兴趣编写自己的Kotlin扩展并寻找灵感，我强烈推荐您阅读以下文章:</p><ul class=""><li id="d4a2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/5-kotlin-extensions-to-make-your-android-code-more-expressive-4c9243cb9466"> 5个Kotlin扩展让你的Android代码更有表现力</a></li><li id="3ced" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/5-more-kotlin-extensions-for-android-developers-3857b1f16407">面向Android开发者的5款Kotlin扩展</a></li></ul><p id="96eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">话虽如此，让我们开始扩展。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0220" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">1.生命周期范围的视图模型</h1><p id="7b86" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当您使用<code class="fe nn no np nq b">ViewModels</code>和Kotlin协同程序时，保持范围并在范围内启动长期运行的后台任务是至关重要的，这样我们就可以在必要时取消那些任务。如果您想将任务限制在组件的生命周期内，这种方法也很方便。</p><p id="28db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设用户在一个小狗列表屏幕上，您必须从服务器获取小狗列表。如果用户在执行请求之前就离开了屏幕，让他们保持活动状态就是浪费资源。在这种情况下，根据组件的生命周期来确定任务的范围是很方便的。</p><h2 id="0071" class="nr mr it bd ms ns nt dn mw nu nv dp na li nw nx nc lm ny nz ne lq oa ob ng oc bi translated">视图模型范围</h2><p id="404b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe nn no np nq b">viewModelScope</code>函数是ViewModel KTX库的一部分。它将为项目中的每个模型创建范围，使启动协程变得容易。当<code class="fe nn no np nq b">onCleared</code>函数被触发时，在这个作用域下启动的所有协程将在视图模型上自动取消。</p><p id="7e8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要集成ViewModel KTX库，请将以下内容添加到您的应用程序级<code class="fe nn no np nq b">build.gradle</code>文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="15e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一下用法:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="f155" class="nr mr it nq b gy oj ok l ol om"><strong class="nq iu">viewModelScope.launch</strong>  {<br/>    sampleApi.fetchPuppies() // <strong class="nq iu">suspend fucntion</strong><br/>    ...<br/>}</span></pre><h2 id="5e3d" class="nr mr it bd ms ns nt dn mw nu nv dp na li nw nx nc lm ny nz ne lq oa ob ng oc bi translated">生命周期范围</h2><p id="88a5" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">与<code class="fe nn no np nq b">viewModelScope</code>类似，<code class="fe nn no np nq b">lifecycleScope</code>也为Android中的每个生命周期对象提供了一个作用域。它是<code class="fe nn no np nq b">lifecycle-runtime-ktx</code>图书馆的一部分。您可以通过<code class="fe nn no np nq b">lifecycle.coroutineScope</code>或<code class="fe nn no np nq b">lifecycleOwner.lifecycleScope</code>进入示波器。</p><p id="1bc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要集成<code class="fe nn no np nq b">lifecycle-runtime-ktx</code>库，请将以下内容添加到您的应用程序级<code class="fe nn no np nq b">gradle</code>文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="9b00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一下用法:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="57a1" class="nr mr it nq b gy oj ok l ol om"><strong class="nq iu">viewLifecycleOwner.lifecycleScope</strong>.launch {<br/>     startOtpTimer()<br/>}</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6d15" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">2.视图模型创建</h1><p id="75b1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">作为现代Android开发的一部分，我们正迅速从活动转向片段。在一年左右的时间里，我们将从片段转移到Jetpack可组合函数。</p><p id="67c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论是Fragment还是Jetpack composable表示一个屏幕，我们都必须创建或使用关联的<code class="fe nn no np nq b">ViewModel</code>的现有实例。</p><p id="dcc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">片段KTX库提供了一种简单的方法，使用Kotlin delegates特性在片段中创建<code class="fe nn no np nq b">ViewModel</code>实例。我们可以在片段中创建一个新的<code class="fe nn no np nq b">ViewModel</code>实例，或者从它的父activity中获得<code class="fe nn no np nq b">ViewModel</code>实例。</p><p id="04b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要集成片段KTX库，请将以下内容添加到您的应用程序级<code class="fe nn no np nq b">gradle</code>文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="4c63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一下用法:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="53b5" class="nr mr it nq b gy oj ok l ol om">// Get a reference to the ViewModel scoped to this Fragment<br/><strong class="nq iu">val viewModel by viewModels&lt;MyViewModel&gt;()</strong><br/><br/>// Get a reference to the ViewModel scoped to its Activity<br/><strong class="nq iu">val viewModel by activityViewModels&lt;MyViewModel&gt;()</strong></span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="43d7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">3.LiveData Lambdas</h1><p id="19e1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">简单来说，<code class="fe nn no np nq b">LiveData</code>是一个可观察的数据持有者类，这意味着<code class="fe nn no np nq b">LiveData</code>可以保存一组数据，这些数据可以从其他Android组件(如活动、片段和服务)中观察到。</p><p id="a57c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">LiveData</code>的常见用例是从<code class="fe nn no np nq b">ViewModel</code>到视图的通信。通常，在<code class="fe nn no np nq b">ViewModel</code>中执行的任务是后台任务，如网络请求、数据库操作等。这些事情应该在后台线程中完成，所以我们要么需要一个<code class="fe nn no np nq b">suspend</code>函数，要么启动一个协程作用域。</p><p id="4878" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于像从数据库或首选项中读取数据这样的简单任务，创建一个单独的函数太麻烦了。这就是LiveData KTX派上用场的时候。LiveData KTX提供了一个<code class="fe nn no np nq b">liveData</code>构建器函数，它调用一个<code class="fe nn no np nq b">suspend</code>函数并将结果作为一个<code class="fe nn no np nq b">LiveData</code>对象。</p><p id="af41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要集成LiveData KTX库，请将以下内容添加到您的应用程序级<code class="fe nn no np nq b">gradle</code>文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="7b12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一下用法:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="9aff" class="nr mr it nq b gy oj ok l ol om">val user: LiveData&lt;User&gt; = <strong class="nq iu">liveData {</strong></span><span id="bf90" class="nr mr it nq b gy on ok l ol om">    val serverData = sampleApi.getPuppies() //suspend function<br/>    database.savedData(serverData) //suspend function<br/>    emit(serverData)</span><span id="6e98" class="nr mr it nq b gy on ok l ol om"><strong class="nq iu">}</strong></span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6c10" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">4.KTX房间</h1><p id="d55e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Room是SQLite上的一个抽象层，用于提供简化的编码。Room KTX提供了一种通过Kotlin协程处理房间数据库的方法。使用Room KTX，我们现在可以使用Room Dao中的<code class="fe nn no np nq b">suspend</code>函数和Flow API来观察数据库中每次更新的数据。</p><p id="e81c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个Jetpack库，Room已经带来了一系列好处。向其中添加协程使得实现数据库操作变得简单明了。像Flow这样的特性用最少的代码提供了丰富而昂贵的功能。</p><p id="4b27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要集成Room KTX库，请将以下内容添加到您的应用程序级<code class="fe nn no np nq b">gradle</code>文件中:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="5c5c" class="nr mr it nq b gy oj ok l ol om">dependencies {<br/>    implementation <strong class="nq iu">"androidx.room:room-ktx:2.2.6"</strong><br/>}</span></pre><p id="7b46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一下用法:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="a4e2" class="nr mr it nq b gy oj ok l ol om">@Query("SELECT * FROM Puppies")<br/><strong class="nq iu">suspend </strong>fun getPuppies(): List&lt;Puppie&gt;<br/><br/>@Query("SELECT * FROM Puppies")<br/>fun getPuppies(): <strong class="nq iu">Flow&lt;List&lt;</strong>Puppie<strong class="nq iu">&gt;&gt;</strong></span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4fe0" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">5.带await的Firebase任务</h1><p id="b1d1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Firebase自带了自己的监听器，比如<code class="fe nn no np nq b">addOnSuccessListener</code>、<code class="fe nn no np nq b">addOnCanceledListener</code>、<code class="fe nn no np nq b">addOnCompleteListener</code>等等。我是一个喜欢Kotlin协程而讨厌回调模式的Android开发者。</p><p id="6040" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协程提供了顺序执行异步操作的能力，这使得代码更加简洁。说到Firebase，回调模式令人疲惫不堪，所以我开始寻找一种用协程实现Firebase任务的方法。</p><p id="0b7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这时我发现了为<code class="fe nn no np nq b">Task</code>提供了一个<code class="fe nn no np nq b">await</code>扩展的<code class="fe nn no np nq b">kotlinx-coroutines-play-services</code>库。大多数Firebase操作都是基于<code class="fe nn no np nq b">Task</code>的。这个库提供了一个名为<code class="fe nn no np nq b">await</code>的扩展函数，它在内部执行<code class="fe nn no np nq b">suspend</code>函数中的任务。这意味着我们不再需要那些恼人的Firebase回调。</p><p id="6e39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它并不完全来自KTX家族，但它是那些从事Firebase工作的人的救命稻草。要集成<code class="fe nn no np nq b">kotlinx-coroutines-play-services</code>库，请将以下内容添加到您的应用程序级<code class="fe nn no np nq b">gradle</code>文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="df8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一下用法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="52dc" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">奖金</h1><p id="29e7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">要了解更多关于Kotlin协同例程和Kotlin的其他高级特性，请阅读以下文章:</p><ul class=""><li id="84b5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/advanced-android-programming-with-kotlin-5e40b1be22bb" rel="noopener">“使用Kotlin进行高级编程</a></li><li id="d6aa" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/kotlin-coroutines-from-basics-to-advanced-ad3eb1421006" rel="noopener">“科特林协程，从基础到高级</a></li><li id="4bc5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/how-to-use-kotlin-sealed-classes-for-state-management-c1cfb81abc6a" rel="noopener">“如何使用Kotlin密封类进行状态管理”</a></li><li id="ad41" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/asynchronous-data-loading-with-new-kotlin-flow-233f85ae1d8b" rel="noopener">“使用新Kotlin流进行异步数据加载</a>”</li></ul><p id="46ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://developer.android.com/kotlin/ktx" rel="noopener ugc nofollow" target="_blank"> Android开发者</a>上找到更多关于KTX库的信息。</p><p id="62b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>