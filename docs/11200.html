<html>
<head>
<title>The Fundamentals of Pointers in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋指针的基本原理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pointers-in-go-9aa5c0682a?source=collection_archive---------3-----------------------#2022-02-25">https://betterprogramming.pub/pointers-in-go-9aa5c0682a?source=collection_archive---------3-----------------------#2022-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ccb8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解指针类型以及如何在数据结构中使用它们</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/72829283d331ab25c746cc19546e3d4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kIk6j7tyMSzHtwYrnagULA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@mparzuchowski" rel="noopener ugc nofollow" target="_blank">迈克尔·帕尔祖乔斯克</a>本人在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的“市场广场咖啡馆”</p></figure><p id="93f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设，你和你的朋友计划在每个人都喜欢的咖啡馆聚会。你们都到了那个地方，在咖啡馆门口。但是上面写着:“抱歉，我们已经搬到了XYZ的这个地方”。所以，因为这是你最喜欢的咖啡馆，你会去新的地址。指针就是这样。有点像咖啡馆门上的标志，指引你去不同的地址/位置。</p><h2 id="c710" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">那么，什么是指针，为什么我们需要使用它们？</h2><p id="4d23" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">指针是存储内存地址的变量。简单地说，它将值存储在计算机内存中。虽然以后我们可以使用指针地址来访问它。</p><p id="590d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们想通过引用某个函数来传递一个变量时，或者指出数组、结构、接口、函数等时，我们使用指针。</p><p id="983c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像C这样的语言在使用指针时经常会面临一些崩溃和安全漏洞。Go使用指针，但具有内存安全性。所以我们现在很安全。</p><p id="09f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，这是一个关于指针的简介。所以我们来多了解一下围棋中的指针。</p><h1 id="5aad" class="mq lt iq bd lu mr ms mt lx mu mv mw ma jw mx jx md jz my ka mg kc mz kd mj na bi translated">与号(&amp;)和星号(*)</h1><p id="e900" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">地址操作符(&amp;)只是决定一个变量在内存中的地址。假设你给一个变量赋值。你的计算机将把这个值以十六进制数的形式存储在内存地址(RAM)中。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="d552" class="ls lt iq nc b gy ng nh l ni nj">value := 901<br/>fmt.Println(&amp;value)<br/>//Prints -&gt; 0xc000018030</span></pre><p id="4d81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们需要解引用指针的值时，我们可以使用(*)操作符来解引用指针变量并检索它的值。好了，让我们更熟悉一个好例子:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="300f" class="ls lt iq nc b gy ng nh l ni nj">value := 65<br/>memoryAdd := &amp;value<br/>fmt.Println("Value:", value) // 65<br/>fmt.Println("Memory address:", &amp;memoryAdd) // 0xc000100018 <br/>fmt.Println("Dereferencing using pointer:", *memoryAdd) // 65</span></pre><p id="68d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还可以使用指针操作符通过解引用来更新原始值。下面是一个例子:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="d687" class="ls lt iq nc b gy ng nh l ni nj">var name string = "John"<br/>var pointer *string = &amp;name</span><span id="7ff7" class="ls lt iq nc b gy nk nh l ni nj">fmt.Println("Name =", name) //John<br/>fmt.Println("pointer =", pointer) //0xc000010230<br/>fmt.Println("*pointer =", *pointer) //John</span><span id="e27d" class="ls lt iq nc b gy nk nh l ni nj">*pointer = "Robert Downy Junior"</span><span id="e234" class="ls lt iq nc b gy nk nh l ni nj">fmt.Println("*pointer =", *pointer) //Robert Downy Jr<br/>fmt.Println("name =", name) //Robert Downy Jr</span></pre><p id="adfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，定义为名称的变量有一个值<code class="fe nl nm nn nc b">John</code>,我们希望在变量前使用(*)用指针变量来取消对它的引用。</p><p id="99cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在我们的例子中，分配给新值<code class="fe nl nm nn nc b">Robert Downy Jr</code>的指针变量可以改变指向内存地址的指针的值。你猜怎么着？它还会更改变量名本身的值。这就是解引用的美妙之处——它可能令人困惑，但同时又非常容易重用。</p><h1 id="1a84" class="mq lt iq bd lu mr ms mt lx mu mv mw ma jw mx jx md jz my ka mg kc mz kd mj na bi translated">指针类型</h1><p id="5078" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">简单来说，指针类型是在数据类型之前初始化的指针变量。这里有一个例子:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="0bad" class="ls lt iq nc b gy ng nh l ni nj">types := 881<br/>address := &amp;types<br/>fmt.Printf("Address is a %T\n", address) // Address is a *int</span></pre><p id="0de6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn nc b">*int</code>表示类型是指针。如果指针类型是<code class="fe nl nm nn nc b">*int</code>，它可以指向同类型的任何其他变量。</p><p id="980f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的解引用示例中，我们可以看到，首先，我们定义了一个值为<code class="fe nl nm nn nc b">*string</code>的变量<code class="fe nl nm nn nc b">name</code>，我们用另一个字符串值解引用了指针值——它还用另一个字符串值更新了原始变量名。</p><p id="4155" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Go中使用指针类型的主要优点是它避免了不安全的操作，比如更新或操作任何值。因此，Go也是一种严格类型化的语言。</p><blockquote class="no np nq"><p id="f4b1" class="kw kx nr ky b kz la jr lb lc ld ju le ns lg lh li nt lk ll lm nu lo lp lq lr ij bi translated"><em class="iq">注意:在C语言类型中，一个内存地址可以保存不同的指针类型，而在Go中，它会抛出一个错误。查看此链接以供参考:【https://go.dev/play/p/PFBD3_5BnLP】T5</em></p></blockquote><p id="9348" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们在go中使用数组、切片、映射等数据结构来定义指针会怎么样？，而那个时候go编译器会返回什么呢？所以，让我们更深入地了解一下指针。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="b1fb" class="mq lt iq bd lu mr oc mt lx mu od mw ma jw oe jx md jz of ka mg kc og kd mj na bi translated">指针在数据结构中的本质</h1><p id="8e3a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">首先，让我们通过在Go中使用数据结构来进一步熟悉指针</p><h2 id="33f1" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">在结构中使用指针</h2><p id="716c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这个指针指向在结构中存储数据的内存块的地址。这里有一个例子:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="8bab" class="ls lt iq nc b gy ng nh l ni nj">type Person struct {<br/> name    string<br/> age     int<br/> canSing bool<br/>}</span><span id="1fb1" class="ls lt iq nc b gy nk nh l ni nj">func main() {<br/> john := &amp;Person{<br/>  name:    "John",<br/>  age:     22,<br/>  canSing: false,<br/> }</span><span id="6b4a" class="ls lt iq nc b gy nk nh l ni nj">fmt.Printf("%+v\n", john) // &amp;{name:John age:22 canSing:false}<br/>}</span></pre><p id="fa6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你在这里看到的，我们定义了一个名为<code class="fe nl nm nn nc b">Person</code> <em class="nr"> </em>的结构，之后，我们通过在结构前使用地址操作符初始化一个名为john的变量来定义值。</p><p id="8d62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述示例的输出将返回前面带有地址运算符的已定义变量的值。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="2c29" class="ls lt iq nc b gy ng nh l ni nj">fmt.Printf("%+v\n", *john) // {name:John age:22 canSing:false}<br/>john.canSing = true<br/>fmt.Printf("%+v\n", *john) // {name:John age:22 canSing:true}</span></pre><p id="e9fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们可以使用指针操作符取消对变量的引用，并在struct中定义值。</p><h2 id="aaad" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">在数组中使用指针</h2><p id="866e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">数组可以以地址操作符为前缀，创建一个指向数组的新指针。数组还提供自动解引用。这里有一个例子:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="c98e" class="ls lt iq nc b gy ng nh l ni nj">person := &amp;[3]string{"John", "22", "12-12-2021"}<br/>fmt.Println(person[0]) // John<br/>fmt.Println(person[:2]) // [John 22]</span></pre><p id="f37d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们在这里看到的，即使在索引或者切片中，它也会自动取消对返回值的引用。</p><h2 id="a241" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">在地图中使用指针</h2><p id="45d2" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在地图中使用指针理论上不是一个好的尝试，因为go在后台为一些内置的集合使用指针。如果映射中的键或值可以是指针类型，这没问题，但对于整个映射来说不是这样。它会在自然界中冗余地活动。</p><h1 id="5946" class="mq lt iq bd lu mr ms mt lx mu mv mw ma jw mx jx md jz my ka mg kc mz kd mj na bi translated">函数中的指针</h1><p id="3ed3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一般来说，函数是一种将输入作为参数并以解决任何问题的方式给出期望输出的方法。所以，在编写函数时，我们可以将参数定义为按值传递和按引用传递。下面是对同一篇的<a class="ae kv" href="https://www.educative.io/edpresso/pass-by-value-vs-pass-by-reference" rel="noopener ugc nofollow" target="_blank">精彩解读:</a></p><blockquote class="no np nq"><p id="411e" class="kw kx nr ky b kz la jr lb lc ld ju le ns lg lh li nt lk ll lm nu lo lp lq lr ij bi translated">在按值传递中，它创建值的副本，该副本作为形式参数发送给函数，对函数的任何更改只会影响函数的变量，不会更新函数范围之外的值。</p></blockquote><p id="ea34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地理解，这里有一个例子:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="8be7" class="ls lt iq nc b gy ng nh l ni nj">func main() {<br/> var name string = "Nikhil"<br/> fmt.Println("Name = ", name) // Nikhil<br/> changeName(name)<br/> fmt.Println("Name = ", name) // Nikhil<br/>}</span><span id="61e2" class="ls lt iq nc b gy nk nh l ni nj">func changeName(name string) {<br/> name = "John"<br/> fmt.Println("Updated name = ", name) // John<br/>}</span></pre><p id="b4ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们可以看到，name的值只有在<code class="fe nl nm nn nc b">changeName</code> <em class="nr"> </em>函数中被更新时才会被更新，所以name的值现在只对这个函数有所不同，因为这些值是在函数范围内的。</p><p id="3467" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在全局和外部函数作用域中，它将按照最初定义的方式运行。但是，如果我们想更新函数的值，而它也应该更新或改变原始值呢？在这种情况下，我们可以使用按引用传递。</p><blockquote class="no np nq"><p id="2ec7" class="kw kx nr ky b kz la jr lb lc ld ju le ns lg lh li nt lk ll lm nu lo lp lq lr ij bi translated">在按引用传递中，当值在函数调用中被更新时，它更新原始值。因此，在这种情况下，它在实际参数前使用指针并通过引用将参数传递给函数调用，同时更新值。这里有一个例子:</p></blockquote><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="10bd" class="ls lt iq nc b gy ng nh l ni nj">func main() {<br/> var name string = "Nikhil"<br/> fmt.Println("Original name =", name) // Nikhil<br/> changeName(&amp;name)<br/> fmt.Println("Original name is now changed to =", name) // John<br/>}</span><span id="42f5" class="ls lt iq nc b gy nk nh l ni nj">func changeName(name *string) {<br/> *name = "John"<br/> fmt.Println("Updated name =", *name) //John<br/>}</span></pre></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="4401" class="mq lt iq bd lu mr oc mt lx mu od mw ma jw oe jx md jz of ka mg kc og kd mj na bi translated">方法中的指针</h1><p id="5ce3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在方法中，与函数有一点不同，在这点上，我们在方法声明中有一个接收器作为参数。</p><p id="d39d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像函数一样，无论是否将值作为参数作为指针发送，方法的行为都是一样的。</p><p id="7507" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在方法的情况下，如果我们想作为接收者发送值，它不会影响原始值。例如:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="f3a1" class="ls lt iq nc b gy ng nh l ni nj">type About struct {<br/> name string<br/> age  int<br/>}</span><span id="24c9" class="ls lt iq nc b gy nk nh l ni nj">func main() {<br/> var details About = About{name: "Nikhil", age: 25}<br/> fmt.Printf("%+v\n", details) // {name:Nikhil age:25}<br/> details.UpdateDetails()<br/> fmt.Printf("%+v\n", details) // {name:Nikhil age:25}<br/>}</span><span id="e960" class="ls lt iq nc b gy nk nh l ni nj">func (a About) UpdateDetails() {<br/> a.age = 35<br/> a.name = "Antman"<br/> fmt.Printf("%+v\n", a) // {name:Antman age:35}<br/>}</span></pre><p id="6ca1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我使用了structs，因为它是Go中用户定义的类型。它还支持结构类型上的方法。因此，接收方可以是结构或非结构类型。</p><p id="3fb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到我们的代码，这里我们定义了一组数据，其中有两个字段:<code class="fe nl nm nn nc b">name</code>和<code class="fe nl nm nn nc b">age</code> <em class="nr">。</em>我们还定义并调用了一个名为<code class="fe nl nm nn nc b">UpdateDetails</code> <em class="nr"> </em>的方法，该方法实际上只是在使用函数receiver作为来自结构类型为<code class="fe nl nm nn nc b">About</code> <em class="nr">的形参的参数时更新值。</em></p><p id="5734" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们也定义了结构类型为<code class="fe nl nm nn nc b">About</code> <em class="nr"> </em>的<code class="fe nl nm nn nc b">details</code>变量来初始定义值。在这里，我们可以看到与我们在函数调用中使用<em class="nr">传值</em>时看到的相同的预期结果。</p><p id="26cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想要更新值，就像我们在<em class="nr">按引用传递中所做的一样，</em>我们只需要在结构类型前添加一个指针来更新方法范围之外的原始值，不管它是否也在主函数之外声明。这里也有一个例子:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="e7bc" class="ls lt iq nc b gy ng nh l ni nj">type About struct {<br/> name string<br/> age  int<br/>}</span><span id="7fef" class="ls lt iq nc b gy nk nh l ni nj">func main() {<br/> var details About = About{name: "Nikhil", age: 25}<br/> fmt.Printf("%+v\n", details)<br/> details.UpdateDetails()<br/> fmt.Printf("%+v\n", details)<br/>}</span><span id="5692" class="ls lt iq nc b gy nk nh l ni nj">func (a *About) UpdateDetails() {<br/> a.age = 22<br/> a.name = "John"<br/> fmt.Printf("%+v\n", *a)<br/>}</span></pre><p id="7cf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是指针在方法中的工作方式，很简单。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="1bb5" class="mq lt iq bd lu mr oc mt lx mu od mw ma jw oe jx md jz of ka mg kc og kd mj na bi translated">指针中的Nils</h1><p id="c703" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">假设有这样一种情况，你已经初始化了一个指针，但你还没有定义或分配它。所以，在围棋中发生的是所有的变量都有零值。所以，如果只是初始化一个数组，切片，指针，它将有零值，所以Go把这个零值当作nil，意思是“什么都不初始化”。</p><p id="07ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们举一个例子来检查它实际上是如何发生的。因此，我将举一个我在上面的函数使用指针中解释过的例子</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="e7ca" class="ls lt iq nc b gy ng nh l ni nj">type Person struct {<br/> name string<br/>}</span><span id="807b" class="ls lt iq nc b gy nk nh l ni nj">func main() {<br/> var name *Person<br/> fmt.Printf("%+v\n", name)<br/> changeName(name)<br/> fmt.Printf("%+v\n", name)<br/>}</span><span id="84a4" class="ls lt iq nc b gy nk nh l ni nj">func changeName(name *Person) {<br/> name = &amp;Person{name: "Nikhil"}<br/> if name == nil {<br/>  fmt.Println("Name is nil")<br/>  return<br/> }<br/> fmt.Printf("%+v\n", name)<br/>}</span></pre><p id="26f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我没有给变量<code class="fe nl nm nn nc b">name</code> <em class="nr">，</em>赋值，而是对它进行了初始化，只是为了检查实际发生了什么，所以在运行它的时候，我得到了这个错误:【https://go.dev/play/p/1MFlmIqSGwM】</p><p id="ede0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">错误说<strong class="ky ir">运行时错误:内存地址无效。</strong>所以它证明了一点，如果我们只是初始化了一个指针变量，Go就把它当作零值，零值本质上是nil。不过，我们可以为nil指针添加一个错误处理检查。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="96cb" class="ls lt iq nc b gy ng nh l ni nj">func changeName(name *string) {<br/> if name == nil {<br/>  fmt.Println("Name is nil")<br/>  return<br/> }<br/> fmt.Printf("%+v\n", name)<br/>}</span></pre><p id="d70e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们想通过将指针的值赋给一个<code class="fe nl nm nn nc b">name</code> <em class="nr"> </em>变量来更新指针的值，我们可以这样做:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="7817" class="ls lt iq nc b gy ng nh l ni nj">func main() {<br/> var name *Person<br/> fmt.Printf("%+v\n", name) // &lt;nil&gt;<br/> changeName(name)<br/> fmt.Printf("%+v\n", name) // &lt;nil&gt;<br/>}</span><span id="6e21" class="ls lt iq nc b gy nk nh l ni nj">func changeName(name *Person) {<br/> name = &amp;Person{name: "Nikhil"}<br/> if name == nil {<br/>  fmt.Println("Name is nil")<br/>  return<br/> }<br/> fmt.Printf("%+v\n", *name) // {name:Nikhil}<br/>}</span></pre><p id="a874" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当我们使用指针时，我们都应该非常小心，因为它会使程序惊慌。为了避免恐慌，我们需要检查指针本质上是否不为零。</p><p id="44c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>