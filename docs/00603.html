<html>
<head>
<title>Using Breadth-First Search for LeetCode Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用广度优先搜索解决LeetCode问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-using-bfs-for-leetcode-problems-82696faf58d8?source=collection_archive---------9-----------------------#2019-06-17">https://betterprogramming.pub/swift-using-bfs-for-leetcode-problems-82696faf58d8?source=collection_archive---------9-----------------------#2019-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f0f4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Swift中的算法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f42d9843997116e4e488c81daffa81dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KhR2wa-cyxjc9IgXvWScPA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这棵树的BFS输出是10 5 20 3 15</p></figure><h1 id="9b58" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">开始之前</h1><h2 id="0fbb" class="lq kz it bd la lr ls dn le lt lu dp li lv lw lx lk ly lz ma lm mb mc md lo me bi translated"><strong class="ak">为什么？</strong></h2><p id="ba48" class="pw-post-body-paragraph mf mg it mh b mi mj ju mk ml mm jx mn lv mo mp mq ly mr ms mt mb mu mv mw mx im bi translated">广度优先搜索树可能看起来很容易，但它们可以扩展到简单矩阵中使用，这通常用于评级为中等或以上的LeetCode挑战。</p><h2 id="5b82" class="lq kz it bd la lr ls dn le lt lu dp li lv lw lx lk ly lz ma lm mb mc md lo me bi translated"><strong class="ak">先决条件</strong></h2><p id="e815" class="pw-post-body-paragraph mf mg it mh b mi mj ju mk ml mm jx mn lv mo mp mq ly mr ms mt mb mu mv mw mx im bi translated">按照本文，您应该能够使用插入创建一个二叉树(尽管下面显示了一个简单的实现)。</p><h2 id="ebfa" class="lq kz it bd la lr ls dn le lt lu dp li lv lw lx lk ly lz ma lm mb mc md lo me bi translated"><strong class="ak">关键词和术语</strong></h2><ul class=""><li id="d61d" class="my mz it mh b mi mj ml mm lv na ly nb mb nc mx nd ne nf ng bi translated">树:具有根值和左右子树的数据结构</li><li id="bb8d" class="my mz it mh b mi nh ml ni lv nj ly nk mb nl mx nd ne nf ng bi translated">矩阵:存储数据的网格</li><li id="8198" class="my mz it mh b mi nh ml ni lv nj ly nk mb nl mx nd ne nf ng bi translated">单元:矩阵的元素之一</li></ul></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="588b" class="ky kz it bd la lb nt ld le lf nu lh li jz nv ka lk kc nw kd lm kf nx kg lo lp bi translated"><strong class="ak">树形版本</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/927fb1df0e748d3e87cf4318d507804e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bcg5TWI64LejAgyZfiMWpw.png"/></div></div></figure><p id="a242" class="pw-post-body-paragraph mf mg it mh b mi nz ju mk ml oa jx mn lv ob mp mq ly oc ms mt mb od mv mw mx im bi translated">遍历上面的树包括依次通过三个级别。虽然任何顺序都是可以接受的，但是该级别中节点的顺序并不重要，节点从左到右显示。</p><ul class=""><li id="7505" class="my mz it mh b mi nz ml oa lv oe ly of mb og mx nd ne nf ng bi translated">等级0: 10</li><li id="af3b" class="my mz it mh b mi nh ml ni lv nj ly nk mb nl mx nd ne nf ng bi translated">级别1: 5，20</li><li id="d0b5" class="my mz it mh b mi nh ml ni lv nj ly nk mb nl mx nd ne nf ng bi translated">级别2: 3，15</li></ul><p id="cd87" class="pw-post-body-paragraph mf mg it mh b mi nz ju mk ml oa jx mn lv ob mp mq ly oc ms mt mb od mv mw mx im bi translated">下面是一个示例实现(和测试)的要点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="5e7d" class="pw-post-body-paragraph mf mg it mh b mi nz ju mk ml oa jx mn lv ob mp mq ly oc ms mt mb od mv mw mx im bi translated">这里的实现围绕着创建一个队列，如果有左边或右边的子树，就附加到这个队列。</p><p id="fc9e" class="pw-post-body-paragraph mf mg it mh b mi nz ju mk ml oa jx mn lv ob mp mq ly oc ms mt mb od mv mw mx im bi translated">将其转换为路径长度是很简单的。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="7f5d" class="ky kz it bd la lb nt ld le lf nu lh li jz nv ka lk kc nw kd lm kf nx kg lo lp bi translated"><strong class="ak">矩阵版本</strong></h1><p id="119d" class="pw-post-body-paragraph mf mg it mh b mi mj ju mk ml mm jx mn lv mo mp mq ly mr ms mt mb mu mv mw mx im bi translated">LeetCode 1091。在二进制矩阵中求最短路径需要我们求出一个矩阵(Swift中用[[Int]]表示)的最短路径(从右上角到右下角)。网格中的单元可以是可用的(0)或被阻止的(1)。</p><p id="b2dc" class="pw-post-body-paragraph mf mg it mh b mi nz ju mk ml oa jx mn lv ob mp mq ly oc ms mt mb od mv mw mx im bi translated">我们可以选择深度优先搜索，但这需要首先遍历所有的可能性，然后选择最短的一个。</p><p id="39e4" class="pw-post-body-paragraph mf mg it mh b mi nz ju mk ml oa jx mn lv ob mp mq ly oc ms mt mb od mv mw mx im bi translated">矩阵版本增加的复杂性包括:</p><ul class=""><li id="283d" class="my mz it mh b mi nz ml oa lv oe ly of mb og mx nd ne nf ng bi translated">在矩阵中有八个方向可以移动，我们需要确保我们不会越过网格的边界</li><li id="0bc8" class="my mz it mh b mi nh ml ni lv nj ly nk mb nl mx nd ne nf ng bi translated">我们需要确认每个单元格是否可以访问(已经被阻止(1)，或者标记为已访问(也是1)</li><li id="126d" class="my mz it mh b mi nh ml ni lv nj ly nk mb nl mx nd ne nf ng bi translated">通过将单元格与网格的大小(head coordinate . 0 = = grd . count-1 &amp; &amp; head coordinate . 1 = = grd . count-1)进行比较，我们将知道我们是否已经达到了目标(右下角的单元格)</li><li id="b229" class="my mz it mh b mi nh ml ni lv nj ly nk mb nl mx nd ne nf ng bi translated">由于每个单元格最多可以有八条路径，我们需要确保每次迭代都从当前单元格中提取每条路径——这可能是整个实现中最复杂的部分</li></ul></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="5d87" class="ky kz it bd la lb nt ld le lf nu lh li jz nv ka lk kc nw kd lm kf nx kg lo lp bi translated"><strong class="ak">简化代码</strong></h1><p id="c45d" class="pw-post-body-paragraph mf mg it mh b mi mj ju mk ml mm jx mn lv mo mp mq ly mr ms mt mb mu mv mw mx im bi translated">通过从剩余的代码中分离出可能的方向，我们可以将它分解成一个变量:</p><blockquote class="ok ol om"><p id="bc4a" class="mf mg oj mh b mi nz ju mk ml oa jx mn on ob mp mq oo oc ms mt op od mv mw mx im bi translated"><strong class="mh iu">设</strong> dir:[[Int]] = [[0，1]，[0，-1]，[1，0]，[-1，0]，[1，-1]，[-1，1]，[-1，-1]，[1，1]]</p></blockquote><p id="44c6" class="pw-post-body-paragraph mf mg it mh b mi nz ju mk ml oa jx mn lv ob mp mq ly oc ms mt mb od mv mw mx im bi translated">所以我们可以通过把这些加到当前坐标上来计算下一个候选坐标。一种方法是:</p><blockquote class="ok ol om"><p id="8e60" class="mf mg oj mh b mi nz ju mk ml oa jx mn on ob mp mq oo oc ms mt op od mv mw mx im bi translated"><strong class="mh iu">设</strong> nextCoordinate =(当前坐标. 0 +方向[0]，当前坐标. 1 +方向[1])</p></blockquote></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="b2cf" class="ky kz it bd la lb nt ld le lf nu lh li jz nv ka lk kc nw kd lm kf nx kg lo lp bi translated"><strong class="ak">算法</strong></h1><p id="1500" class="pw-post-body-paragraph mf mg it mh b mi mj ju mk ml mm jx mn lv mo mp mq ly mr ms mt mb mu mv mw mx im bi translated">所以基本的想法是这样的:</p><ol class=""><li id="150a" class="my mz it mh b mi nz ml oa lv oe ly of mb og mx oq ne nf ng bi translated">我们将初始单元格设置为开始(左上角；0,0)</li><li id="6977" class="my mz it mh b mi nh ml ni lv nj ly nk mb nl mx oq ne nf ng bi translated">将路径计数设置为1。</li><li id="38d9" class="my mz it mh b mi nh ml ni lv nj ly nk mb nl mx oq ne nf ng bi translated">我们获取队列中的元素，对于每个当前单元格:</li></ol><ul class=""><li id="f349" class="my mz it mh b mi nz ml oa lv oe ly of mb og mx nd ne nf ng bi translated">检查是否可以遍历到该单元格(检查它是否为0)，如果不能，则移动到下一个元素</li><li id="4cbd" class="my mz it mh b mi nh ml ni lv nj ly nk mb nl mx nd ne nf ng bi translated">检查我们在目的地。如果是，则返回路径计数</li><li id="b23f" class="my mz it mh b mi nh ml ni lv nj ly nk mb nl mx nd ne nf ng bi translated">将当前单元格标记为1</li><li id="ea4e" class="my mz it mh b mi nh ml ni lv nj ly nk mb nl mx nd ne nf ng bi translated">然后对于每个可能的方向，计算下一个坐标。如果在界限内，则添加到队列中</li><li id="8f1e" class="my mz it mh b mi nh ml ni lv nj ly nk mb nl mx nd ne nf ng bi translated">当前迭代完成后，增加路径计数</li></ul><p id="1f72" class="pw-post-body-paragraph mf mg it mh b mi nz ju mk ml oa jx mn lv ob mp mq ly oc ms mt mb od mv mw mx im bi translated">4.在我们完成所有可能的单元格后，没有解，所以我们返回-1</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="20bc" class="ky kz it bd la lb nt ld le lf nu lh li jz nv ka lk kc nw kd lm kf nx kg lo lp bi translated">结论</h1><p id="30a8" class="pw-post-body-paragraph mf mg it mh b mi mj ju mk ml mm jx mn lv mo mp mq ly mr ms mt mb mu mv mw mx im bi translated">我希望你喜欢这个教程。你可以在下面找到代码和回购。感谢阅读！</p><h2 id="f7fb" class="lq kz it bd la lr ls dn le lt lu dp li lv lw lx lk ly lz ma lm mb mc md lo me bi translated">代码片段:</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h2 id="7e59" class="lq kz it bd la lr ls dn le lt lu dp li lv lw lx lk ly lz ma lm mb mc md lo me bi translated">回购:</h2><p id="1a6d" class="pw-post-body-paragraph mf mg it mh b mi mj ju mk ml mm jx mn lv mo mp mq ly mr ms mt mb mu mv mw mx im bi translated"><a class="ae or" href="https://github.com/stevencurtis/SwiftCoding/tree/master/LeetCode/SwiftUsingBFSforLeetCodeProblems" rel="noopener ugc nofollow" target="_blank">https://github . com/stevencurtis/swift coding/tree/master/leet code/swiftusingbfsforleecodeproblems</a></p><p id="4982" class="pw-post-body-paragraph mf mg it mh b mi nz ju mk ml oa jx mn lv ob mp mq ly oc ms mt mb od mv mw mx im bi translated"><strong class="mh iu">想取得联系？在Twitter上取得联系:</strong></p><div class="os ot gp gr ou ov"><a href="https://twitter.com/stevenpcurtis" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">史蒂文·柯蒂斯(@stevenpcurtis) |推特</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">史蒂文·柯蒂斯的最新推文(@stevenpcurtis)。一边学习计算硕士，一边开发iOS应用程序…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">twitter.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj ks ov"/></div></div></a></div></div></div>    
</body>
</html>