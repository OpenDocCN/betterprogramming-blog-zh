<html>
<head>
<title>5 Essential Macros to Build a Test Framework in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C++构建测试框架的5个基本宏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-essential-macros-to-build-a-test-framework-in-c-a85ee80042f?source=collection_archive---------7-----------------------#2022-04-26">https://betterprogramming.pub/5-essential-macros-to-build-a-test-framework-in-c-a85ee80042f?source=collection_archive---------7-----------------------#2022-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="43e3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用C++编写一个最小单元测试框架</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8ad225371c9e51062d4e1bd3f0b59e52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*11h97cp0wLVeJImG.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="b912" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">作为一名软件开发人员，编写测试来检查您的代码是否完全符合预期是非常重要的。您不希望将有问题的代码推向生产，尤其是在您没有考虑边界条件的情况下，对吗？</p><p id="014e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在测试c++项目的过程中，您可能会遇到流行的框架，如<em class="lr"> GTest </em>、<em class="lr"> Catch </em>或<em class="lr"> BoostTest </em>。它们复杂而健壮，允许你以任何你想要的方式测试代码。</p><p id="2d08" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不管这些框架有多复杂，为测试而实现的核心原则是非常相似的。在这篇文章中，我们将通过自己编写一个简单的框架来学习基础知识。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="a95d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">测试框架使用<em class="lr">宏</em>来避免源文件与大量样板代码混淆。对于我们的框架，我们将只使用其中的五个。一个用于声明、定义、注册和运行测试用例的宏，当然，还有一个用于将结果与期望值进行比较的宏。</p><h1 id="6fd3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">编写测试用例</h1><p id="fcdc" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">宏是创建对每个测试用例都是唯一的测试类的聪明方法。这项工作我们需要两个宏指令。一个<code class="fe mw mx my mz b">DeclareTest</code>，和<code class="fe mw mx my mz b">DefineTest</code>。而且，由于我们正在进行面向对象编程，我们也将利用一些<em class="lr">继承</em>和<em class="lr">设计模式</em>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于声明和定义测试用例的宏</p></figure><p id="ad5f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码片段中有三点需要指出:</p><ol class=""><li id="324c" class="nc nd iq kx b ky kz lb lc le ne li nf lm ng lq nh ni nj nk bi translated">令牌粘贴操作符<code class="fe mw mx my mz b">##</code>为每个唯一的<code class="fe mw mx my mz b">Module</code>或<code class="fe mw mx my mz b">TestName</code>创建一个唯一的测试类。</li><li id="9814" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated"><em class="lr"> Singleton </em>模式确保每个案例只有一个实例。</li><li id="22a9" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">并且，为了定义测试，我们覆盖了从其父方法<code class="fe mw mx my mz b">UnitTest</code>继承的<code class="fe mw mx my mz b">runFunc()</code>方法(接下来讨论)。</li></ol><p id="74ae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下示例显示了这些宏的测试声明和定义。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试用例声明</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试用例定义</p></figure><h1 id="802b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">测试引擎</h1><p id="4eb1" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">类<code class="fe mw mx my mz b">UnitTest</code>是这个框架的核心。它管理所有实例化的测试类。为了避免创建多个管理器，我们将它设为单例。它还提供了一个虚拟的<code class="fe mw mx my mz b">runFunc()</code>方法，继承类可以覆盖它来定义测试用例。</p><p id="6142" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看看下面的片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="ak">单元测试</strong>类声明</p></figure><ol class=""><li id="5c8f" class="nc nd iq kx b ky kz lb lc le ne li nf lm ng lq nh ni nj nk bi translated"><code class="fe mw mx my mz b">getInstance()</code>方法返回一个singleton。</li><li id="d08c" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">变量<code class="fe mw mx my mz b">isTrue</code>存储测试结果。或真或假。</li><li id="e3ce" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated"><code class="fe mw mx my mz b">testList</code>存储指向该类注册的所有案例的指针。</li><li id="d510" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated"><code class="fe mw mx my mz b">expectEQ()</code>方法评估期望值是否与被测单元的返回值相同。因为它是一个模板方法，所以已经为您完成了类型检查。你不会拿苹果和橘子做比较。</li><li id="efd3" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">最后，<code class="fe mw mx my mz b">runTests()</code>方法执行存储在<code class="fe mw mx my mz b">testList</code>中的所有测试。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="ak"> runTests() </strong>定义</p></figure><p id="c616" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">静态变量<code class="fe mw mx my mz b">passed</code>和<code class="fe mw mx my mz b">failed</code>跟踪每个测试用例执行的结果。有了指向测试用例的指针的<code class="fe mw mx my mz b">testList</code>，我们可以直接从<code class="fe mw mx my mz b">UnitTest</code>类中访问并执行<code class="fe mw mx my mz b">runFunc</code>方法。</p><h1 id="2a20" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">注册、运行和评估测试用例</h1><p id="c087" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">现在，一旦我们定义并实例化了测试，我们需要将它们添加到<code class="fe mw mx my mz b">testList</code>中。我们用<code class="fe mw mx my mz b">RegisterTest</code>宏来做这件事。</p><p id="0d72" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，为了方便起见，我们将定义宏来运行和比较测试结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于注册、运行和比较测试的宏</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="133a" class="lz ma iq bd mb mc nq me mf mg nr mi mj jw ns jx ml jz nt ka mn kc nu kd mp mq bi translated">在单独的进程中运行测试</h1><p id="9b6d" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">在单独的进程中运行测试用例允许你的程序运行到最后。即使其中一个抛出异常并中止。隔离的测试用例包含了损害并防止你的程序崩溃。</p><p id="1cce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Windows和Linux系统都允许创建单独的进程。Windows称之为<code class="fe mw mx my mz b">CreateProcess</code>，而在Linux世界中，我们称之为<code class="fe mw mx my mz b">fork</code>。</p><p id="f73c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是在Linux/Unix系统上派生出<code class="fe mw mx my mz b">runTests</code>方法的代码片段。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d502" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mw mx my mz b">testList</code>中的每个案例都在一个由<code class="fe mw mx my mz b">vfork()</code>系统调用创建的新进程中运行。它返回一个正数作为分叉进程的ID，并将ID <code class="fe mw mx my mz b">0</code>分配给子进程。然后我们的<code class="fe mw mx my mz b">runFunc</code>方法在分叉的进程中被调用，将它与程序的其余部分隔离开来。</p><p id="1f41" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，你可以争论是否用<code class="fe mw mx my mz b">fork()</code>代替<code class="fe mw mx my mz b">vfork()</code>。但是，我更喜欢后者，因为它可以处理静态变量，并以正确的顺序打印控制台日志。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="423b" class="lz ma iq bd mb mc nq me mf mg nr mi mj jw ns jx ml jz nt ka mn kc nu kd mp mq bi translated">把它放在一起</h1><p id="94f9" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">我们已经创建了一个简单易用的测试框架。只需五个宏，您就可以编写测试，而无需涉及框架的细节。不能再简单了！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">样本测试程序</p></figure><p id="9246" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望这是有用的，对你有帮助。在我的<a class="ae nv" href="https://gitlab.com/AvinashRavishankar/unittest" rel="noopener ugc nofollow" target="_blank"> GitLab </a>账户上查看完整的源代码。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt nw mz nx ny aw nz bi"><span id="3c6d" class="oa ma iq mz b gy ob oc l od oe"><strong class="mz ir">Want to Connect?</strong></span><span id="4520" class="oa ma iq mz b gy of oc l od oe">Connect with me on <a class="ae nv" href="https://twitter.com/TheBarbellCoder" rel="noopener ugc nofollow" target="_blank">Twitter</a> for all the latest updates!</span></pre></div></div>    
</body>
</html>