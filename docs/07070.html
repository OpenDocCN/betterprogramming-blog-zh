<html>
<head>
<title>A Practical Guide to First-Class Functions Using TypeScript With Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript和Node.js的一级函数实用指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-practical-guide-to-first-class-functions-using-typescript-with-node-js-67afe2da639?source=collection_archive---------8-----------------------#2020-12-03">https://betterprogramming.pub/a-practical-guide-to-first-class-functions-using-typescript-with-node-js-67afe2da639?source=collection_archive---------8-----------------------#2020-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2f59" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">使用TypeScript </em>学习并实现函数式编程的核心概念</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/3d6d41055dab1cee1273da6411282084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6pT7-Y8n2BimS_-iKEaIw.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@antoine1003?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Antoine Dautry </a>在<a class="ae kz" href="https://unsplash.com/s/photos/math-function?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="9d36" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated"><em class="ki">为什么是一流的功能？</em></h1><p id="f1ac" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">函数式编程作为一种编程范式越来越受欢迎。LISP和Haskell领先。然而，我们这些全栈开发者很幸运，JavaScript原生支持它的特性。</p><p id="c5fd" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">函数式编程的核心概念之一是<em class="na">一级函数。</em>意思是，我们将职能部门视为一等公民。它通过像对待任何其他值(对象、字符串和数字)一样对待它们，将它们作为参数传递，或者从代码中的其他函数返回它们，为我们实现函数提供了灵活性。理解一流的函数是学习和实现函数式编程范例的重要基础。最终目标是让我们编写可维护的、灵活的和可伸缩的代码。</p><p id="ab30" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">在本文中，我将带您了解一个一级函数的不同特性。我会分享一些例子，样本问题，以及解决方案。注意:我用TypeScript编写了我所有的例子，并用Node 10进行了测试。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="4201" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">箭头功能—速记</h1><p id="c27d" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">在本文的其余部分，我将默认使用在ES6中表达函数的简写方式。为了使我们的代码更加简洁，让我们通过回顾和理解如何在ES6中编写箭头函数来确定基调。如果您已经熟悉箭头功能，可以跳过这一部分。</p><p id="bb1b" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">当我们在ES6之前编写函数时，我们通常会使用<code class="fe nb nc nd ne b">function</code>关键字，例如，如果我们想编写一个返回胜率的函数。我们编写函数并给它命名，或者通过使用<code class="fe nb nc nd ne b">const</code>、<code class="fe nb nc nd ne b">var</code>或<code class="fe nb nc nd ne b">let</code>将它赋给一个变量。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">TypeScript中的命名函数</p></figure><p id="8d88" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">从ES6开始，我们可以将函数重写为箭头函数，如下例所示。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">ES6中引入的箭头功能</p></figure><p id="7483" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">我们不需要写<code class="fe nb nc nd ne b">function</code>关键字。箭头<code class="fe nb nc nd ne b">=&gt;</code>指向我们函数中用花括号括起来的指令集。在TypeScript中，如果我们愿意，我们也可以指定一个变量是一个<code class="fe nb nc nd ne b">Function</code>类型。</p><p id="6dd3" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">下面的例子直接返回结果，而没有保存在变量中。这进一步缩短了我们的代码。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">带有箭头功能的一行程序</p></figure><p id="249a" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">注意上面的箭头<code class="fe nb nc nd ne b">=&gt;</code>是如何告诉解释器我们想要返回它所指向的语句的值的，这是我们用<code class="fe nb nc nd ne b">matches</code>除以<code class="fe nb nc nd ne b">wins</code>的结果，只要我们没有用花括号将语句括起来。</p><p id="b240" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">如果指定类型，我们需要在TypeScript中将参数括在括号中，这与使用JavaScript箭头函数不同。如果我们只需要传递一个参数，我们可以省略括号。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">带有一个类型化参数的箭头函数</p></figure><p id="6cfb" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">如果没有传递参数，请使用空括号。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">不带参数的箭头函数</p></figure><p id="7e07" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">如果我们想返回一个对象，用括号把它括起来。如果我们没有用括号把它括起来，我们就告诉解释器我们在用括号来定义函数体。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">如果要返回一个对象，请用括号将对象括起来。</p></figure><p id="b497" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">以这种速记形式编写函数允许我们“压缩”我们的代码，节省我们打字时的额外击键和阅读时的额外字符。以速记形式编写函数在开始时可能会有点混乱；然而，从长远来看，这里有复利可得。除了让我们免于额外的击键和对单词<em class="na"> function </em>的多余使用之外，它还方便了我们以函数式编程风格编写我们的类型代码。怎么会？箭头函数类似于数学方程的组成部分，这使得我们的代码简洁明了。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="f233" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">将函数视为数据</h1><p id="9bc6" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">我们可以像对待其他类型脚本数据类型一样对待函数，比如数字、字符串、数组和对象。我们可以将函数存储在变量中，并像对待任何其他TypeScript数据类型一样对待它，这为我们提供了一些有用的选项来处理我们的函数。</p><p id="bad0" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">这是一个将函数赋给另一个变量的例子。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">创建一个函数，并将其赋给另一个变量。</p></figure><p id="e3fb" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">像对待其他数据类型一样对待函数也允许我们动态地改变函数的行为。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">使用三元运算符动态更改函数行为。</p></figure><p id="aa8e" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">下面是该功能的一些典型的实际应用。</p><h2 id="7172" class="nh li it bd lj ni nj dn ln nk nl dp lr mi nm nn lt mm no np lv mq nq nr lx ns bi translated">示例用法1。单元测试中的模仿</h2><p id="c144" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">该特性的一个常见应用是模拟我们的异步函数在本地运行单元测试时返回的内容。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="00f6" class="nh li it bd lj ni nj dn ln nk nl dp lr mi nm nn lt mm no np lv mq nq nr lx ns bi translated">示例用法2。A/B测试或实验</h2><p id="1c09" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">我们还可以将我们的函数分配给一个对象，以形成一个哈希映射或函数字典，我们可以用它来进行A/B测试。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="352f" class="nh li it bd lj ni nj dn ln nk nl dp lr mi nm nn lt mm no np lv mq nq nr lx ns bi translated">示例用法3。对一个数据执行一系列功能</h2><p id="38fa" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">这是另一个有趣的应用。我们有许多函数接受一个对象，对该对象执行一系列更新，然后返回一个更新后的对象。</p><pre class="kk kl km kn gt nt ne nu nv aw nw bi"><span id="4ff5" class="nh li it ne b gy nx ny l nz oa">const addName = (person: object): object =&gt; (<br/>    {...person, name: 'John Doe'})<br/>const addGender = (person: object): object =&gt; (<br/>    {...person, gender: 'Male'})<br/>const addJobTitle = (person: object): object =&gt; (<br/>    {...person, title: 'Software Engineer'})<br/>const addMonthlySalary = (person: object): object =&gt; (<br/>    {...person, monthlySalary: 1000})<br/>const addAnnualSalary = (person: object): object =&gt; (<br/>    {...person, annualSalary: person['monthlySalary'] * 12})</span></pre><p id="7643" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">程序性的方法是逐行应用函数。例如，我们有一个用<code class="fe nb nc nd ne b">id</code>初始化的<code class="fe nb nc nd ne b">employee</code>对象。然后一系列函数将更新<code class="fe nb nc nd ne b">employee</code>对象并返回更新后的<code class="fe nb nc nd ne b">employee</code>对象。请参见下面的示例代码。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">获取person对象并更新它。</p></figure><p id="7db5" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">上面的代码完成了这项工作。我们一行一行地将每个函数应用到变异的<code class="fe nb nc nd ne b">employee</code>对象上。想象一下，如果我们需要添加一个新函数:添加一个新行来调用函数，并将<code class="fe nb nc nd ne b">employee</code>对象作为参数传递。不错，但我们可以做得更好。</p><p id="5149" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">函数方式是在一个数组中分配函数，使用<code class="fe nb nc nd ne b">forEach</code>遍历该数组，并将每个函数应用于参数。注意在应用数组中的第一个函数后要传递的<code class="fe nb nc nd ne b">employee</code>参数将是前一个函数的返回值。我们按照函数在数组中的排列顺序来使用它们。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">获取person对象，并使用一组函数更新它。</p></figure><p id="153c" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">如果我们需要添加另一个函数来执行，我们只需要在数组中添加另一个条目。我们不需要将返回值重新分配给<code class="fe nb nc nd ne b">employee</code>，并将其作为参数传递给下一个函数。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="846c" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">作为参数的函数</h1><p id="d8ee" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">回到动态改变函数行为的主题，让我们看看如何通过传递函数作为参数来实现。</p><p id="811c" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">例如，我们想实现一个接受两个数字的简单计算器。面向对象的方法是创建一个包含计算操作的<code class="fe nb nc nd ne b">Calculator</code>类作为该类中的方法，即<code class="fe nb nc nd ne b">add</code>和<code class="fe nb nc nd ne b">subtract</code>。如果我们需要添加更多的操作，我们将更新类来添加每个操作的相应方法。另一种方法是为每个操作编写单独的函数。例如，实现<code class="fe nb nc nd ne b">calculateSum()</code>和<code class="fe nb nc nd ne b">calculateDifference()</code>功能。</p><p id="4660" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">这里实现计算器的“一级函数”或“函数式”方法是创建一个接受运算函数的<code class="fe nb nc nd ne b">calculate()</code>函数，例如<code class="fe nb nc nd ne b">add()</code>，作为执行我们想要的计算的参数。计算的函数也是独立的，我们可以使用它们，而不用将它们作为参数传递。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">将运算函数作为参数传递给calculate函数。</p></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="08b1" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">用作返回值</h1><p id="4fc2" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">一开始，看到从一个函数返回另一个函数的代码可能会感到困惑。把它想象成一个功能工厂会有所帮助。</p><p id="3ed6" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">理解这个概念的一个更简单的方法是从返回另一个将文本打印到控制台的函数开始。下面的函数返回一个将“hello”打印到控制台的函数。</p><pre class="kk kl km kn gt nt ne nu nv aw nw bi"><span id="fa61" class="nh li it ne b gy nx ny l nz oa">const createGreeting = () =&gt; () =&gt; console.log('hello')</span></pre><p id="3851" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">如果您是新手，可能需要一些时间来习惯阅读这种类型的函数。请记住，这个函数相当于下面的函数。</p><pre class="kk kl km kn gt nt ne nu nv aw nw bi"><span id="f370" class="nh li it ne b gy nx ny l nz oa">const createGreeting = function() {<br/>    return function() {<br/>        console.log('hello')<br/>    }<br/>}</span></pre><p id="02d9" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">让我们看一个例子。我们有一个带有转换功能的程序，可以将<code class="fe nb nc nd ne b">meter</code>转换成英制单位<code class="fe nb nc nd ne b">mile</code>、<code class="fe nb nc nd ne b">yard</code>、<code class="fe nb nc nd ne b">foot</code>和<code class="fe nb nc nd ne b">inch</code>。这些单位转换函数采用以米为单位的值<code class="fe nb nc nd ne b">x</code>，并返回以相应符号格式化的英制单位转换后的值。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">具有重复代码的转换函数</p></figure><p id="8e40" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">在上面的例子中，我们的转换函数中的重复代码非常明显。每个函数中的乘法和字符串格式化都是重复的。</p><p id="5469" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">让我们尝试通过创建一个函数来解决这个问题，该函数将为我们处理不同的转换，同时最大化行为略有不同的函数之间的代码重用。</p><p id="88c0" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">下面的<code class="fe nb nc nd ne b">createConverter()</code>函数接受转换值<code class="fe nb nc nd ne b">v</code>和符号<code class="fe nb nc nd ne b">s</code>参数。它返回一个带有<code class="fe nb nc nd ne b">x</code>参数的函数，这是我们想要转换的值。</p><pre class="kk kl km kn gt nt ne nu nv aw nw bi"><span id="6289" class="nh li it ne b gy nx ny l nz oa">const createConverter = (v: number, s: string) =&gt; <br/>    (x: number) =&gt; `${x * v} ${s}`</span></pre><p id="48f1" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">然后我们将重用上面的<code class="fe nb nc nd ne b">createConverter</code>函数来构成我们的转换函数。</p><pre class="kk kl km kn gt nt ne nu nv aw nw bi"><span id="e147" class="nh li it ne b gy nx ny l nz oa">const meterToMile = createConverter(0.0006213689, 'mi')<br/>console.log(meterToMile(1000))</span></pre><p id="9525" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">下面是我们的完整解决方案。我们在保持代码可维护性的同时最大化重用。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">具有可重用代码的转换函数。我们利用函数作为返回值。</p></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="bb74" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">关闭</h1><p id="23b7" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">既然我们已经讨论了从另一个函数返回一个函数，我们应该理解返回一个函数的函数中变量的作用域。返回函数的变量可以在返回函数中访问。</p><p id="1eb9" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">下面<code class="fe nb nc nd ne b">createGreeting()</code>函数中的变量<code class="fe nb nc nd ne b">_name</code>可从打印到控制台的返回函数中访问。当我们运行它时，它会打印出<code class="fe nb nc nd ne b">Hello John Doe</code>。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">带闭包的函数</p></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="c748" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">私有变量</h1><p id="7069" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">这一节将结合我们在前面几节中学到的关于返回函数和闭包的知识。通常，在JavaScript中，我们会在私有变量后添加一个下划线，以表明我们不应该在类之外的任何地方使用该变量。有时这可能被忽略或误用。我们可以通过使用函数方法来强制执行面向对象编程中的类如何处理私有变量。我们将把它实现为一个函数，而不是在我们的例子中使用<code class="fe nb nc nd ne b">class</code>。</p><p id="93cc" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">看看下面的例子。我们有一个接受<code class="fe nb nc nd ne b">name</code>、<code class="fe nb nc nd ne b">jobTitle</code>和<code class="fe nb nc nd ne b">monthlySalary</code>参数的<code class="fe nb nc nd ne b">Employee</code>函数。该函数将这些参数赋给私有变量，并附加一个下划线以表示它们是私有的。我们只能通过getters来访问这些变量:<code class="fe nb nc nd ne b">getName()</code>、<code class="fe nb nc nd ne b">getJobTitle()</code>和<code class="fe nb nc nd ne b">getEmployee()</code>。如果我们试图直接检索私有变量<code class="fe nb nc nd ne b">employeeA._name</code>，我们将得到一个<code class="fe nb nc nd ne b">Property ‘_name’ does not exist</code>错误。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">带有私有变量和getters的雇员函数</p></figure><p id="f28d" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">我们还可以扩展我们的<code class="fe nb nc nd ne b">Employee</code>函数来使用setters。我们在下面的例子中添加了setters。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">带有设置器的私有变量</p></figure><p id="51d2" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">上面代码中的最后两行将输出我们员工更新后的职位和工资。</p><p id="e605" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">请注意:您并不总是需要像这样在TypeScript中编写您的“类”,因为TypeScript已经支持在类中实现私有变量。很高兴知道您可以选择以这种方式实现私有变量。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="e09b" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">高阶函数</h1><p id="4fae" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">高阶函数是通过将任何函数作为参数或通过返回它们来对其他函数进行操作的函数。让我们来看一个例子，看看如何使用高阶函数来给我们的代码带来灵活性和可重用性。</p><p id="4806" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">为了用一个例子来说明这一点，让我们来看看我们作为程序员解决的一个常见问题:验证我们的函数参数。</p><p id="6ce3" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">我们有一个执行减法运算的函数，给定一个<code class="fe nb nc nd ne b">minuend</code>和一个<code class="fe nb nc nd ne b">subtrahend</code>作为它的参数，并返回<code class="fe nb nc nd ne b">difference</code>。</p><pre class="kk kl km kn gt nt ne nu nv aw nw bi"><span id="0adc" class="nh li it ne b gy nx ny l nz oa">const minus = (minuend: number, subtrahend: number): number =&gt; <br/>    minuend - subtrahend</span></pre><blockquote class="ob oc od"><p id="772e" class="lz ma na mb b mc mv ju me mf mw jx mh oe mx mk ml of my mo mp og mz ms mt mu im bi translated">被减数——这是一个最大的数，或者说是整个数，其中的一个<strong class="mb iu">部分</strong>将被去掉。</p><p id="edf9" class="lz ma na mb b mc mv ju me mf mw jx mh oe mx mk ml of my mo mp og mz ms mt mu im bi translated">减数——这是从被减数中去掉的<strong class="mb iu">部分</strong>。</p><p id="7c40" class="lz ma na mb b mc mv ju me mf mw jx mh oe mx mk ml of my mo mp og mz ms mt mu im bi translated">差异—这是<strong class="mb iu">减去</strong>后剩余的<strong class="mb iu">部分</strong>。[ <a class="ae kz" href="#36b0" rel="noopener ugc nofollow"> 1 </a></p></blockquote><p id="1670" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">让我们试着限制它只返回非负数。因此，我们将需要我们的论点，使<code class="fe nb nc nd ne b">minuend</code>应该总是大于或等于<code class="fe nb nc nd ne b">subtrahend</code> : <code class="fe nb nc nd ne b">minuend &gt;= subtrahend</code>。</p><p id="6bba" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">验证参数的典型方法是在函数的顶部添加一个早期返回或退出。</p><pre class="kk kl km kn gt nt ne nu nv aw nw bi"><span id="faef" class="nh li it ne b gy nx ny l nz oa">const minus = (minuend: number, subtrahend: number): number =&gt; {<br/>    if (minuend &lt; subtrahend) {<br/>        console.log('minuend should be greater than the subtrahend')<br/>        return null<br/>    }<br/>    return minuend - subtrahend<br/>}</span></pre><p id="0c82" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">上面的代码是有效的。然而，这个函数做的不止一件事。它不仅返回差异，还验证参数。这违反了S.O.L.I.D.[ <a class="ae kz" href="#c5e0" rel="noopener ugc nofollow"> 2 </a> ]中的单一责任原则</p><p id="f480" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">让我们用高阶函数来解决这个问题。</p><p id="f1da" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">首先，我们将创建一个单独的函数来验证参数。</p><pre class="kk kl km kn gt nt ne nu nv aw nw bi"><span id="dc78" class="nh li it ne b gy nx ny l nz oa">const minuendGreaterThanSubtrahend = (func: Function) =&gt; <br/>    (...args) =&gt; {        <br/>        const [num1, num2] = args<br/>        if (num1 &lt; num2) {<br/>            console.log('minuend should be greater than the subtrahend')<br/>            return null<br/>        }<br/>        return func(...args)<br/>    }</span></pre><p id="e15b" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">函数<code class="fe nb nc nd ne b">minuendGreaterThanSubtrahend()</code>接受作为参数传递的函数。然后，它验证将从传递的函数中调用的参数。</p><p id="2dd2" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">让我们删除我们的<code class="fe nb nc nd ne b">minus()</code>函数中的验证，让它回到符合单一责任原则的原始形式。</p><pre class="kk kl km kn gt nt ne nu nv aw nw bi"><span id="01c5" class="nh li it ne b gy nx ny l nz oa">const minus = (minuend: number, subtrahend: number): number =&gt; <br/>    minuend - subtrahend</span></pre><p id="9924" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">然后，我们将创建调用<code class="fe nb nc nd ne b">minuendGreaterThanSubtrahend()</code>验证函数的<code class="fe nb nc nd ne b">minusPositiveDifference()</code>函数，并将<code class="fe nb nc nd ne b">minus()</code>函数作为其参数。然后将调用这个<code class="fe nb nc nd ne b">minusPositiveDifference()</code>来确保在执行减法之前首先验证我们的参数。</p><pre class="kk kl km kn gt nt ne nu nv aw nw bi"><span id="605a" class="nh li it ne b gy nx ny l nz oa">const minusPositiveDifference = minuendGreaterThanSubtrahend(minus)</span></pre><p id="5589" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">查看下面我们的完整解决方案。每个函数都在做一件事，同时仍然实现我们想要的参数验证。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">一种函数式的方法来验证参数，同时保持我们的代码符合单一责任原则</p></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="a7de" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">结论</h1><p id="c796" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">理解JavaScript (TypeScript)中的一级函数对您的函数式编程之旅至关重要。它帮助我们在利用一流功能的强大功能和灵活性的同时，以令人兴奋的方式处理问题。您将会遇到与本文中的例子类似的模式问题。您在项目中使用这些一流的功能特性越多，您就越能掌握它们。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="1611" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">参考</h1><ol class=""><li id="36b0" class="oh oi it mb b mc md mf mg mi oj mm ok mq ol mu om on oo op bi translated"><a class="ae kz" href="https://classace.io/learn/math/3rdgrade/completing-three-digit-subtraction-equations" rel="noopener ugc nofollow" target="_blank">减法方程式</a><a class="ae kz" href="#7c40" rel="noopener ugc nofollow">回文</a></li><li id="c5e0" class="oh oi it mb b mc oq mf or mi os mm ot mq ou mu om on oo op bi translated"><a class="ae kz" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">神盾局原则。</a><a class="ae kz" href="#0c82" rel="noopener ugc nofollow">回文</a></li></ol><p id="90ca" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">如果您想运行本文中的示例代码，也可以在<a class="ae kz" href="https://github.com/ardydedase/fp-node-ts" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div></div>    
</body>
</html>