<html>
<head>
<title>New TypeScript Features You Should Check Out</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您应该了解的新TypeScript特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/new-typescript-features-you-should-check-out-f31d2fbf4bc9?source=collection_archive---------4-----------------------#2019-11-13">https://betterprogramming.pub/new-typescript-features-you-should-check-out-f31d2fbf4bc9?source=collection_archive---------4-----------------------#2019-11-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fd76" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">TypeScript 3.7.2中的新增功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f26498513f665f10bbe77feb5ae8191c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P-shl2B87L7JPK5B"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@yulokchan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Joseph Chan </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7cd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜你！<a class="ae ky" href="https://www.npmjs.com/package/typescript" rel="noopener ugc nofollow" target="_blank"> TypeScript发布了新版本，3.7.2 </a>。近几年来，TypeScript已经成为开发人员最流行的语言之一。TypeScript获得了超过50K颗星，并且总是关注用户可能面临的问题。我一直是等待新版本的TypeScript的忠实粉丝之一。</p><p id="4d0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧抱歉。我太多嘴了。让我们看看有什么新功能出来了！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8b82" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">阅读前</h1><p id="556f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我写了一篇关于<em class="mz"/><a class="ae ky" href="https://medium.com/javascript-in-plain-english/upcoming-new-javascript-features-you-should-know-if-you-use-javascript-everyday-8208b477b7a2" rel="noopener">即将推出的新JavaScript特性</a>的文章，你可能想和这篇文章一起看看，以获得更多乐趣。因为TypeScript团队参与了TC39，所以这次更新中的特性与新的潜在JavaScript特性高度相关。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6f4f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">可选链接</h1><p id="784d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">该死的。TypeScript比ECMAScript早发布了这个特性！可选链接是一个非常方便的特性，可以减少代码行数，使代码更加整洁。</p><blockquote class="na nb nc"><p id="3508" class="kz la mz lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">“可选链接允许我们编写代码，如果遇到<code class="fe ng nh ni nj b"><em class="it">null</em></code>或<code class="fe ng nh ni nj b"><em class="it">undefined</em></code>，我们可以立即停止运行一些表达式。”—类型脚本发行说明</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="de0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个看起来不是很有用吗？但是有些事情你需要记住。可选链条并不是酒店每个房间的万能钥匙。这并不总是取代<code class="fe ng nh ni nj b">&amp;&amp;</code>操作符。例外情况如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="28b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意在上面的例子中<code class="fe ng nh ni nj b">city?.popularity</code>和<code class="fe ng nh ni nj b">city &amp;&amp; city.popularity</code>的工作方式不同。因为可选链接只检查<code class="fe ng nh ni nj b">null</code>和<code class="fe ng nh ni nj b">undefined</code>，而<code class="fe ng nh ni nj b">&amp;&amp;</code>操作符检查<code class="fe ng nh ni nj b">falsy</code>。因此，您应该小心不要滥用可选链接。</p><p id="ebaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> ~~编辑~~ <br/> </strong>这也是一个比较<code class="fe ng nh ni nj b">&amp;&amp;</code>和<code class="fe ng nh ni nj b">?.</code>区别的好例子</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要点源代码来自<a class="nm nn ep" href="https://medium.com/u/777e34597fe0?source=post_page-----f31d2fbf4bc9--------------------------------" rel="noopener" target="_blank">波格丹一世波伦斯基</a>，谢谢！</p></figure><p id="172b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个<code class="fe ng nh ni nj b">if</code>语句将起作用，因为<code class="fe ng nh ni nj b">str</code>不是<code class="fe ng nh ni nj b">null</code>或<code class="fe ng nh ni nj b">undefined</code>。<code class="fe ng nh ni nj b">str?.indexOf()</code>等于<code class="fe ng nh ni nj b">(str !== null &amp;&amp; str !== undefined) &amp;&amp; str.indexOf()</code>。然而，第二个<code class="fe ng nh ni nj b">if</code>不会被执行，因为空字符串<code class="fe ng nh ni nj b">''</code>是假的。所以，<code class="fe ng nh ni nj b">str &amp;&amp; str.indexOf()</code>不会向<code class="fe ng nh ni nj b">if</code>语句返回true。</p><p id="e6de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一件要注意的事情是，可选链接仅限于属性访问、调用和元素访问。</p><blockquote class="na nb nc"><p id="2bb5" class="kz la mz lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">“可选链的‘短路’行为仅限于‘普通’和可选的属性访问、调用、元素访问——它不会从这些表达式中进一步扩展。—类型脚本发行说明</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8664" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe ng nh ni nj b">math</code>是可选值，所以它可能是<code class="fe ng nh ni nj b">undefined</code>。TypeScript总是抱怨<code class="fe ng nh ni nj b">undefined</code>。</p><blockquote class="na nb nc"><p id="d0ea" class="kz la mz lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated"><em class="it"/><code class="fe ng nh ni nj b"><em class="it">undefined</em></code>是万恶之源。”—类型脚本strictNullChecks文档</p></blockquote><p id="c6b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方法是<code class="fe ng nh ni nj b">math?.score!</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bf9b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">无效合并</h1><p id="5de0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果可选链接是关于检查<code class="fe ng nh ni nj b">null</code>和<code class="fe ng nh ni nj b">undefined</code>的，那么无效链接<em class="mz"> g </em>是关于默认值的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7d64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">??</code>操作符作为<code class="fe ng nh ni nj b">||</code>分配默认值，避免使用<code class="fe ng nh ni nj b">0</code>、<code class="fe ng nh ni nj b">NaN</code>和<code class="fe ng nh ni nj b">“”</code>等虚假值。</p><p id="ff42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Nullish合并非常简单，但是当您将它与<em class="mz"> </em>可选链接一起使用时，它会使您的代码看起来更优雅，因为TypeScript希望这个特性与可选链接一起发布。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0f60" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">断言函数</h1><p id="1bfa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设有一个函数检查参数是否是数字类型。如果参数不是Number，函数会抛出一个错误。另一个函数<code class="fe ng nh ni nj b">yell</code>调用<code class="fe ng nh ni nj b">assert</code>来检查变量的类型，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e148" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，TypeScript是宽松的，因此很容易出现人为错误。</p><blockquote class="na nb nc"><p id="c22c" class="kz la mz lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">不幸的是，在TypeScript中，这些检查永远无法正确编码。对于松散类型的代码，这意味着TypeScript检查得更少，而对于稍微保守的代码，这通常会迫使用户使用类型断言。”—类型脚本发行说明</p></blockquote><p id="f1cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这种情况，发布的版本为我们提供了几个选项。</p><ol class=""><li id="8bd4" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><code class="fe ng nh ni nj b">asserts {{parameter}}</code></li><li id="c89a" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><code class="fe ng nh ni nj b">asserts {{parameter}} is {{Type}}</code></li></ol><p id="828f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个选项的概念是相同的。这个想法来自Node.js中的assert function。如果<code class="fe ng nh ni nj b">assert</code>返回，那么传递给函数中的<code class="fe ng nh ni nj b">{{parameter}}</code>参数的任何内容都必须为真。一旦它返回true，就意味着<code class="fe ng nh ni nj b">{{parameter}}</code>在其范围内将永远是true。</p><p id="aa66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要让TypeScript更努力，可以像下面这样使用<code class="fe ng nh ni nj b">asserts</code>作为返回类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/b732b81456b62fa42bb4823bd02e0079.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/1*CJMM5GZy1qS6xhnQ5nhm5Q.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe ng nh ni nj b">"asserts val is Number”</code>工作原理如下</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/85496e55e23ce8145aa25e9178097172.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/1*6ACQcvfowwVz0uzMc6iLXA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“断言类型化”是这样工作的</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3e07" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">未调用的函数检查</h1><p id="e3c3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个功能不是我们可以手动使用的。不过，这是TypeScript的内部改进，意义重大。有时错误是由人的手指造成的。例如，我们错误地忘记调用一个函数。在这个新发布的TypeScript中，它可以检查没有被调用的函数，如果有错误，就抛出一个错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/c0deaa60d7d1a5c8e521c3c23ef671d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/1*Ek81sk6fIDUQwSV4O-pUMA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">现在，TypeScript可以检查未被调用的函数</p></figure><p id="9b57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，这是很有条件的。</p><ol class=""><li id="876f" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">选项<code class="fe ng nh ni nj b">strickNullChecks</code>必须是<code class="fe ng nh ni nj b">checked</code>才能检查<code class="fe ng nh ni nj b">required</code>类型的非调用函数。</li><li id="6be6" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">如果函数是<code class="fe ng nh ni nj b">optional</code>类型，TypeScript不认为是错误。</li><li id="1ca3" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">如果这个函数后来在<code class="fe ng nh ni nj b">if</code>语句的主体中被调用，TypeScript不会认为这是一个错误。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/1c4475351227a03b12b43a558cd60d1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:350/format:webp/1*3FklZBHJ9BWv9q6ypvtHGg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对于未调用的函数检查，strickNullChecks必须为on</p></figure><p id="ead4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一点非常重要。您必须确保分配<code class="fe ng nh ni nj b">strictNullChecks</code>选项<code class="fe ng nh ni nj b">true</code>来打开未调用功能检查功能。而且更糟糕的是这个特性只检查<code class="fe ng nh ni nj b">required</code>类型属性。下面的代码不会显示任何错误。或者如果函数稍后在<code class="fe ng nh ni nj b">if</code>语句的主体中被调用，也不会被发出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8f91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这个特性并不完美，TypeScript建议开发人员用不同的方法来检查它是函数还是值。</p><blockquote class="na nb nc"><p id="7852" class="kz la mz lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">如果您打算在不调用函数的情况下测试它，您可以更正它的定义以包含<code class="fe ng nh ni nj b">undefined</code> / <code class="fe ng nh ni nj b">null</code>，或者使用<code class="fe ng nh ni nj b">!!</code>编写类似于<code class="fe ng nh ni nj b">if (!!user.isAdministrator)</code>的代码以表明强制是有意的—类型脚本发行说明</p></blockquote><h1 id="d871" class="mc md it bd me mf of mh mi mj og ml mm jz oh ka mo kc oi kd mq kf oj kg ms mt bi translated">结论</h1><p id="5b16" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我已经给你介绍了四个特性，但还有更多。就我个人而言，我认为这次更新对TypeScript来说是有意义的，因为他们深入参与了TC39，每年都会确定JavaScript的新特性并将其添加到ECMAScript的下一版本中。</p><p id="73f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些功能看起来很酷，有些看起来很复杂。然而，我们不应该认为这次更新的新功能可以完全取代现有的功能。正如微软TypeScript项目经理Daniel Rosenwasser 提到的注意事项，我希望你在<code class="fe ng nh ni nj b">npm install</code>之前查看发布说明。</p><p id="ecf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！我真的很喜欢写这篇文章，因为我是等待更新的书呆子之一！如果你愿意，<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html" rel="noopener ugc nofollow" target="_blank">点击这个TypeScript 3.7的文档</a>获取完整的信息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f7a8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="4860" class="no np it lb b lc mu lf mv li ok lm ol lq om lu on nu nv nw bi translated"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html" rel="noopener ugc nofollow" target="_blank">打字稿3.7 </a></li><li id="0894" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu on nu nv nw bi translated"><a class="ae ky" href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-7-beta/" rel="noopener ugc nofollow" target="_blank">打字稿发布说明</a></li><li id="04a7" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu on nu nv nw bi translated"><a class="ae ky" href="https://basarat.gitbooks.io/typescript/docs/options/strictNullChecks.html" rel="noopener ugc nofollow" target="_blank">TypeScript中的strictNullChecks</a></li></ul></div></div>    
</body>
</html>