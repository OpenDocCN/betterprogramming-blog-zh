<html>
<head>
<title>Over-Engineering the “Hello World” in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中过度设计“Hello World”</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/over-engineering-the-hello-world-in-python-352844417d37?source=collection_archive---------11-----------------------#2022-08-15">https://betterprogramming.pub/over-engineering-the-hello-world-in-python-352844417d37?source=collection_archive---------11-----------------------#2022-08-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="37b0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不使用print()打印到控制台的7种方式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/355607b8cc3654b89cc296436897edf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1S4yCSHxmr5JofqRPUhTow.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用<a class="ae ky" href="https://openai.com/dall-e-2/" rel="noopener ugc nofollow" target="_blank"> DALL-E 2 </a>生成的图像</p></figure><p id="4ece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python编程语言以对初学者非常友好和高度灵活而闻名。然而，正因为如此，它允许多种方法来实现相同的最终目标——有些方法比其他方法更有效。</p><p id="c8f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将向您展示用Python将字符串打印到控制台的七种方法，从标准的Python方法开始，逐渐过渡到更奇特的打印技术。</p><h1 id="e5ef" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">传统的内置打印功能</h1><p id="7202" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是将字符串打印到控制台的最Pythonic化的方式，没有比老式的<code class="fe ms mt mu mv b">print()</code>语句更简单的了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="eb16" class="nc lw it mv b gy nd ne l nf ng">Hello World</span></pre><p id="7ffd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，你会变得偏执，认为自己只是众多普通程序员中的一员，并开始寻找更具创造性的技术来证明自己并不平庸。</p><h1 id="d147" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用Sys模块写入Stdout</h1><p id="0727" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你曾经用Java编程过，你会同意仅仅为了打印一个值到控制台而输入<code class="fe ms mt mu mv b">System.out.println()</code>有点夸张，这也是你迁移到Python的原因。</p><p id="4c06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是内置<code class="fe ms mt mu mv b">TextIO</code>对象带回Java噩梦的地方:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="9039" class="nc lw it mv b gy nd ne l nf ng">Hello World</span></pre><p id="305f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您需要手动添加换行符。今年是哪一年，1972年？而且，说到70年代，UNIX也是在这个时期发布的。那么，为什么不从Python调用UNIX命令来打印字符串呢？</p><h1 id="6410" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">调用Echo命令</h1><p id="83fe" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在现代操作系统中，您可以使用<code class="fe ms mt mu mv b">echo</code>命令将字符串打印到控制台。您可以使用<code class="fe ms mt mu mv b">os</code>模块从Python调用系统shell命令。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="8898" class="nc lw it mv b gy nd ne l nf ng">Hello World</span></pre><p id="2c62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这根本不是Pythonic的风格，但它仍然有效。</p><h1 id="36df" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">写入一个文件，并对其进行编目</h1><p id="c89f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">既然我们触及了系统shell命令主题，为什么不使用<code class="fe ms mt mu mv b">cat</code>将文件内容输出到控制台呢？顺便说一句，“猫”这个名字并不是来自那些可爱的宠物，而是来自“连接”这个词。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="596e" class="nc lw it mv b gy nd ne l nf ng">Hello World</span></pre><p id="32c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种技术有点像你在<a class="ae ky" href="https://en.wikipedia.org/wiki/Capture_the_flag_(cybersecurity)" rel="noopener ugc nofollow" target="_blank">捕获旗帜安全挑战</a>中使用的黑客技术。顺便说一下，这些年来，黑客变得越来越流行。那么，为什么不黑一个内置的Python特性来实现我们的目标呢？</p><h1 id="d5cc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">破解Python异常</h1><p id="0f45" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">黑客是一种通过非标准手段实现目标的艺术，例如，通过制作东西(软件、对象等)。)以不希望的方式行事。记住这一点，让我们破解异常特性，让它将内容打印到控制台。</p><p id="9f1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">黑客攻击的第一步是了解目标，在本例中是<code class="fe ms mt mu mv b">raise</code>关键字。<code class="fe ms mt mu mv b">raise</code>接受一个<code class="fe ms mt mu mv b">Exception</code>对象并抛出一个错误，打印堆栈跟踪和最终的错误消息。Python允许我们通过输入任意字符串来处理错误消息。这就是我们想要打印到控制台的内容。</p><p id="b28a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以像这样抛出一个异常:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="106a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，输出结果一点也不好，如下所示:</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="08af" class="nc lw it mv b gy nd ne l nf ng">Traceback (most recent call last):<br/>  File "/home/nic/Desktop/prints.py", line 42, in &lt;module&gt;<br/>    raise(e)<br/>Exception: Hello World</span></pre><p id="2c43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们绝对不希望每次打印消息时都有堆栈跟踪。这就是<code class="fe ms mt mu mv b">sys</code>模块的用处:我们可以将Python的回溯限制设置为<code class="fe ms mt mu mv b">0</code>来完全抑制它；</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="0ec3" class="nc lw it mv b gy nd ne l nf ng">Exception: Hello World</span></pre><p id="7a31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这更好，但仍然有“例外:”伤害眼睛的部分。幸运的是，我们可以利用shell <a class="ae ky" href="https://en.wikipedia.org/wiki/Carriage_return" rel="noopener ugc nofollow" target="_blank">回车</a>特性，该特性允许我们将文本光标位置重置到行首。在Python中，回车符表示为<code class="fe ms mt mu mv b">"\r"</code>或者在ASCII中表示为数字<code class="fe ms mt mu mv b">13</code>。</p><p id="11d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住这一点，我们可以重写我们不想要的“异常:”部分，方法是将光标重置到行首，然后在它上面写一条消息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4bba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码产生了预期的结果:</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="2483" class="nc lw it mv b gy nd ne l nf ng">Hello World</span></pre><p id="496b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果消息短于字符串“Exception:”，例如“Hello”，则它们会像这样重叠:</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="9047" class="nc lw it mv b gy nd ne l nf ng">Hellotion:</span></pre><p id="6f52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，让我们根据我们的消息长度和“异常”之间的差异，在行尾添加一些填充:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7705" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码运行完美。</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="404c" class="nc lw it mv b gy nd ne l nf ng">Hello</span></pre><h1 id="b5a1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">作为文件写入标准输出</h1><p id="e021" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">到目前为止，我们已经看到一些不受欢迎的方法效果很好。现在让我们来探索一种技术，一旦写入stdout，它就会失效，并且不允许从中打印任何内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="4ca5" class="nc lw it mv b gy nd ne l nf ng">Hello World</span></pre><p id="3c27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将使用内置的<code class="fe ms mt mu mv b">open()</code>函数打开stdout，然后关闭它，这样您就不能再打印了。如果您之后试图打印任何内容，将会显示以下错误消息:</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="7b78" class="nc lw it mv b gy nd ne l nf ng">Traceback (most recent call last):<br/>  File "/home/nic/Desktop/prints.py", line 38, in &lt;module&gt;<br/>    print("New message")<br/>OSError: [Errno 9] Bad file descriptor<br/>Exception ignored in: &lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='utf-8'&gt;<br/>OSError: [Errno 9] Bad file descriptor</span></pre><h1 id="f9f1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">编写自己的Print()函数</h1><p id="2dcc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Python中打印的下一个层次是不使用Python，而是用c编写一个定制的<code class="fe ms mt mu mv b">print()</code>函数。</p><p id="368c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这项技术，我们将编写一个C扩展来代表我们处理控制台的打印。为了保持文章简洁，我不打算解释为Python创建C扩展的完整过程。如果你有兴趣了解关于这个话题的更多信息，请查看本指南。</p><p id="dff8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建C库。如果你不懂C，可以直接看评论。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e1ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后创建<code class="fe ms mt mu mv b">setup.py</code>脚本来构建扩展:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7dd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，构建并安装C扩展:</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="c60f" class="nc lw it mv b gy nd ne l nf ng">python3 setup.py build<br/>python3 setup.py install --user</span></pre><p id="7fa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以轻松地在Python脚本中导入新的C模块，因为它是一个普通的库，并调用自定义的<code class="fe ms mt mu mv b">print()</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="bcad" class="nc lw it mv b gy nd ne l nf ng">Hello World</span></pre><p id="2b47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜你，你刚刚在C中创建了你自己的完全可用的<code class="fe ms mt mu mv b">print()</code>函数！而且都没有任何分段错误。毕竟c也没那么难。</p><h1 id="b32d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="1501" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在Python中，有无数种方法可以将消息打印到控制台。虽然有些是有意义的，但其他只是过度设计的外来技术，旨在作为概念验证或加深语言知识的编码练习。</p><p id="eeb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章。如果你知道任何其他有趣的用Python将字符串打印到控制台的技术，请在评论中分享。</p><p id="73c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p><p id="9a35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个系列的第三篇文章，在这个系列中，我探索了用Python实现简单任务的各种有趣和过度设计的方法。如果你错过了最后一个故事，你可以在下面找到它:</p><div class="nh ni gp gr nj nk"><a rel="noopener  ugc nofollow" target="_blank" href="/10-ways-of-iterating-over-a-list-in-python-f068da25875f"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">Python中遍历列表的10种方法</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">可以不使用for关键字循环吗？</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">better编程. pub</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ks nk"/></div></div></a></div></div></div>    
</body>
</html>