<html>
<head>
<title>Using View Model Protocols in SwiftUI? You’re Doing it Wrong.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中使用视图模型协议？你做错了。</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-view-models-are-not-protocols-8c415c0325b1?source=collection_archive---------0-----------------------#2021-11-01">https://betterprogramming.pub/swiftui-view-models-are-not-protocols-8c415c0325b1?source=collection_archive---------0-----------------------#2021-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="de97" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">SwiftUI、MVVM和面向协议的编程是一个完美的组合…如果做得正确的话。找出方法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1069ff15b40dd22f8717aee8920f6a7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VBWjiCzlHFBNOuN9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@xc_teer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">提尔·XC</a>的照片</p></figure><p id="b51e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最常用的iOS应用架构之一是MVVM:模型视图视图-模型。</p><p id="4c42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毫无疑问，正如你所知，在UIKit中进行经典的MVC(模型视图控制器)开发时，MVVM被提议对抗“大规模”视图控制器的趋势。基本思想是将业务逻辑——视图模型——从视图出口和视图和视图控制器中的其他“连接”中分离出来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/ab699404aa913e764b0d4c2df62b2302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*weWEWt9N4Sb1Dm3bWRW1Ow.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/swiftui-microservices-c7002228710"> SwiftUI微服务</a></p></figure><p id="77e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此之前，开发人员倾向于将所有的逻辑和用户事件处理，甚至大量的API请求代码转储到负责给定屏幕的唯一视图控制器中。在视图控制器和视图模型之间划分职责，至少可以将各自的规模缩小一半。</p><p id="d3eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这不是一个无关紧要的好处，但是将业务逻辑移动到它自己的实体中意味着我们现在可以<em class="lw">模仿</em>并且<em class="lw">测试</em>那个逻辑。进入视图控制器并试图弄清楚该控制器的标签和字段以及其他用户界面元素的当前状态是一件非常、非常、非常麻烦的事情。</p><p id="a578" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是相比之下，测试一个视图模型的值要容易得多。</p><h1 id="a0dc" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">SwiftUI和可观察对象</h1><p id="8a14" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">SwiftUI在创建<code class="fe mu mv mw mx b">ObservableObject</code>的概念时鼓励了类似的架构模型。</p><p id="7f13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe mu mv mw mx b">ObservableObject</code>是一个实体，它存在于——并且持久存在于——视图之外，并且跨越视图更新，以便为那个视图(或者多个视图)维护某种类型的状态。</p><p id="f497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当该状态改变或被更新时，依赖于该状态的任何视图都被重建并检查改变，这又会导致UI的某个部分(或全部)被刷新。</p><p id="5333" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe mu mv mw mx b">ObservableObject</code>在用作<code class="fe mu mv mw mx b">EnvironmentObject</code>时可能跨越多个视图，在这种情况下，我们可能会认为它更像是某种服务。(<em class="lw">详见</em> <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/swiftui-microservices-c7002228710"> <em class="lw"> SwiftUI微服务</em> </a> <em class="lw">)关于这个</em>。)</p><p id="0e6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是当它的存在主要是为了驱动一个<em class="lw">单一</em>视图的状态和行为时，那么我们又回到了把它看作一个视图模型(大写)，而架构又一次成为了MVVM。</p><p id="753d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lw">注意，根据定义，视图模型将紧密耦合到它所驱动的视图。它们基本上是同一枚硬币的两面。</em></p><h1 id="94c4" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">账户列表</h1><p id="52c4" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">考虑以下SwiftUI视图模型，该模型用于显示简单的帐户列表:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="25fa" class="nc ly it mx b gy nd ne l nf ng">class AccountListViewModel: ObservableObject {</span><span id="b98c" class="nc ly it mx b gy nh ne l nf ng">    @Published var accounts: [AccountListModel]?<br/>    @Published var footnote: String?<br/>    @Published var empty: String?<br/>    @Published var error: String?</span><span id="6eca" class="nc ly it mx b gy nh ne l nf ng">    func load() {<br/>      // something happens here<br/>    }<br/>}</span></pre><p id="e78b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的帐户列表屏幕可以显示帐户列表和相应的脚注，或者如果没有可用的帐户，它可以显示一条消息，或者如果尝试加载帐户列表失败，它可以显示一条错误消息。</p><p id="9613" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以想想吧。调用<code class="fe mu mv mw mx b">load()</code>可以触发一组变量变化，其中大多数是互斥的。</p><p id="a9bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lw">这里只需注意，我可能会在现实生活中使用稍微不同的方法，但这个例子很好地说明了我们的一些问题，所以让我们开始吧。</em></p><h1 id="266e" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">装，装，装…</h1><p id="0034" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">让我们更深入一点，看看我们的load函数的一个简单实现。现在，我们还将忽略这个函数本质上可能是异步的这一事实，只关注内部逻辑流。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="ed9b" class="nc ly it mx b gy nd ne l nf ng">func load() {<br/>    if let (accounts, footnote) = API.shared.loadAccounts() {<br/>        if accounts.isEmpty {<br/>            empty = "No accounts"<br/>        } else {<br/>            self.accounts = accounts.map {<br/>                AccountListModel($0)<br/>            }<br/>            self.footnote = footnote<br/>        }<br/>    } else {<br/>        error = "Unable to load accounts"<br/>    }<br/>}</span></pre><p id="914d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们调用API来加载我们的帐户和相关的脚注。如果这个函数返回零，我们就有一个错误。如果我们的帐户列表是空的，我们希望我们的用户也知道。否则，我们保存我们的列表，将每个帐户转换成一个<code class="fe mu mv mw mx b">AccountListModel</code>，我们也保存我们的脚注。</p><p id="cc19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，即使构建一个相对简单的状态集也会开始涉及一些半复杂的逻辑。</p><p id="c5f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们如何确保逻辑是正确的呢？做些测试！</p><h1 id="f5c5" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">测试</h1><p id="67f2" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">这里有一个成功加载几个账户的快乐路径的基本测试。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="f04e" class="nc ly it mx b gy nd ne l nf ng">private let vm = AccountListViewModel()</span><span id="224b" class="nc ly it mx b gy nh ne l nf ng">class MVVM_POPTests: XCTestCase {<br/>    func testAccountsLoaded() throws {<br/>        vm.load()     <br/>        XCTAssert(vm.accounts?.count == 2)<br/>        XCTAssertNotNil(vm.footnote)<br/>        XCTAssertNil(vm.empty)<br/>        XCTAssertNil(vm.error)<br/>    }<br/>}</span></pre><p id="92dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们检查是否有账户，是否有脚注，是否没有空的或错误的信息。酷毙了。</p><p id="efcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但问题来了。通过使用一个共享的singleton作为我们的API，我们的load函数也与那个API紧密耦合。</p><p id="7804" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们如何给它一组不同的数据来玩呢？就此而言，它是在与我们实际的、实时的API对话，所以我们怎么知道我们在现实生活中会有多少个帐户呢？事实上，每次我们增加或减少帐户时，这个测试都会失败。</p><p id="b0d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，我们需要将视图模型从API中分离出来，但是如何分离呢？</p><h1 id="8da9" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">帐户加载协议</h1><p id="122d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">嗯，这是Swift，这篇文章是关于如何使用MVVM协议…所以让我们定义一个加载帐户数据的协议，并使我们现有的API符合该协议。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="b256" class="nc ly it mx b gy nd ne l nf ng">protocol AccountLoading {<br/>    func loadAccounts() -&gt; ([Account], String)?<br/>}</span><span id="f3f4" class="nc ly it mx b gy nh ne l nf ng">extension API: AccountLoading {}</span></pre><p id="639b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们将修改我们的视图模型，如下所示。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="b130" class="nc ly it mx b gy nd ne l nf ng">class AccountListViewModel {<br/>    ...<br/>    var loader: AccountLoading = API.shared<br/>    func load() {<br/>        if let (accounts, footnote) = loader.loadAccounts() {<br/>            ...<br/>        } else {<br/>            ...<br/>        }<br/>    }<br/>}</span></pre><p id="311e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们添加了一个<code class="fe mu mv mw mx b">loader</code>变量，它期望一个<code class="fe mu mv mw mx b">AccountLoading</code>的实例，但是默认为我们的标准共享API。</p><p id="be6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现实生活中，我可能会使用依赖注入和<a class="ae ky" href="https://github.com/hmlongco/Resolver" rel="noopener ugc nofollow" target="_blank">解析器</a>并使其成为私有属性，但在这里，我们将使其成为普通的公共属性，这样我们就可以从我们的测试套件中访问它。</p><p id="7b1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，请注意我们的load函数现在是如何调用协议的某个实例来获取数据的。</p><p id="5e94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了我们的协议，让我们用它来修复我们的第一个测试。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="fa2e" class="nc ly it mx b gy nd ne l nf ng">private let vm = AccountListViewModel()</span><span id="f4a0" class="nc ly it mx b gy nh ne l nf ng">struct MockTwoAccounts: AccountLoading {<br/>    func loadAccounts() -&gt; ([Account], String)? {<br/>        return ([Account(), Account()], "A footnote")<br/>    }<br/>}</span><span id="ecae" class="nc ly it mx b gy nh ne l nf ng">class MVVM_POPTests: XCTestCase {<br/>    func testAccountsLoaded() throws {<br/>        vm.loader = MockTwoAccounts()<br/>        vm.load()<br/>        XCTAssert(vm.accounts?.count == 2)<br/>        XCTAssertNotNil(vm.footnote)<br/>        XCTAssertNil(vm.empty)<br/>        XCTAssertNil(vm.error)<br/>    }<br/>}</span></pre><p id="9113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用一个协议处理程序的实例替换我们的API调用，该实例实际上返回两个模拟帐户。运行它和BING！有用！我们有我们的模拟账户和相关的脚注。</p><p id="0392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再加一个吧。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="ec00" class="nc ly it mx b gy nd ne l nf ng">struct MockNoAccounts: AccountLoading {<br/>    func loadAccounts() -&gt; ([Account], String)? {<br/>        return ([], "A footnote")<br/>    }<br/>}<br/>    </span><span id="8828" class="nc ly it mx b gy nh ne l nf ng">class MVVM_POPTests: XCTestCase {<br/>    ...<br/>    func testNoAccountsLoaded() throws {<br/>        vm.loader = MockNoAccounts()<br/>        vm.load()<br/>        XCTAssertNil(vm.accounts)<br/>        XCTAssertNil(vm.footnote)<br/>        XCTAssertNotNil(vm.empty)<br/>        XCTAssertNil(vm.error)<br/>    }<br/>    ...<br/>}</span></pre><p id="3ecc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们的模拟只是返回一个空的帐户列表。现在，当我们调用load时，我们可以检查以确保我们的逻辑部分是正确的，并且我们的模型现在准确地反映了我们的空状态。</p><p id="a5b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们最后的测试，我们可以制作一个<code class="fe mu mv mw mx b">MockAccountError</code>版本，其中<code class="fe mu mv mw mx b">loadAccounts()</code>只返回nil，并使用它来确保我们为错误处理状态生成正确的结果。</p><h1 id="e48e" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">我们在测试，我们在测试…</h1><p id="4c5f" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">一切都很好。因此，当我们满怀期望地运行我们完整的<code class="fe mu mv mw mx b">AccountListViewModel</code>测试套件时，我们发现……<strong class="lb iu">一个错误</strong>。发生了什么事？</p><p id="9871" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，当我们运行所有的测试并调试结果时，我们会发现我们的加载函数没有正确地清除之前的状态。</p><p id="6da7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我加载一个零账户列表时，我得到了预期的空消息。</p><p id="e8ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我在那之后加载了我的账户，我得到了账户和一个脚注…而我仍然有我之前的空消息。如果我之前犯了错误，同样的事情也会发生。旧的值会一直存在，无法通过我的帐户加载或空测试。</p><p id="fcdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这正好表明，即使在相对简单的代码中，也可能隐藏着非常严重的错误。我要补充的是，如果没有这些测试，我们可能直到很久以后才发现这个错误。</p><p id="0f7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，我们需要一些函数来重置我们的状态。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="625f" class="nc ly it mx b gy nd ne l nf ng">class AccountListViewModel: ObservableObject {</span><span id="02ec" class="nc ly it mx b gy nh ne l nf ng">    ...    </span><span id="4547" class="nc ly it mx b gy nh ne l nf ng">    func load() {<br/>        reset()<br/>        if let accounts = loader.loadAccounts() {<br/>            ...<br/>        } else {<br/>            ...<br/>        }<br/>    }<br/>    <br/>    func reset() {<br/>        accounts = nil<br/>        footnote = nil<br/>        empty = nil<br/>        error = nil<br/>    }<br/>}</span></pre><p id="4304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lw">请注意，这是让Xcode以随机顺序运行测试的一个非常好的理由，因为在一个序列中没有错误的运行可能会在另一个序列中触发错误。</em></p><h1 id="6e60" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">SwiftUI和模拟数据</h1><p id="ea8a" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们可以(也应该)在应用程序中定义这些模拟，并在我们想要在SwiftUI中进行预览时使用它们。为了说明这一点，现在让我们制作一个简单的占位符<code class="fe mu mv mw mx b">AccountListView</code>。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="0539" class="nc ly it mx b gy nd ne l nf ng">struct AccountListView: View {</span><span id="e030" class="nc ly it mx b gy nh ne l nf ng">    @StateObject var viewModel = AccountListViewModel()</span><span id="460a" class="nc ly it mx b gy nh ne l nf ng">    var body: some View {<br/>        Text("Will show accounts here...")<br/>    }<br/>}</span></pre><p id="8f13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们的产品<code class="fe mu mv mw mx b">AccountListView</code>使用了一个默认为我们的标准<code class="fe mu mv mw mx b">AccountListViewModel</code>的状态对象，这反过来默认使用我们的标准，产品API。</p><p id="1058" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是有了这些，我们现在可以创建一组覆盖<code class="fe mu mv mw mx b">AccountListView.viewModel</code>的预览，并使用它们来查看我们的视图如何显示来自我们的快乐路径的数据，当它为空时，以及当我们有错误时。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="d44a" class="nc ly it mx b gy nd ne l nf ng">struct AccountListView_Previews: PreviewProvider {<br/>  static var previews: some View {<br/>    Group {<br/>      let vm2 = AccountListViewModel(loader: MockTwoAccounts())<br/>      AccountListView(viewModel: vm2)<br/>            <br/>      let vm0 = AccountListViewModel(loader: MockNoAccounts())<br/>      AccountListView(viewModel: vm0)<br/>            <br/>      let vme = AccountListViewModel(loader: MockAccountsError())<br/>      AccountListView(viewModel: vme)<br/>    }<br/>  }<br/>}</span></pre><p id="f30f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了我们的预览，我们就可以确保每个状态在我们编写代码的时候都像它应该的那样出现。</p><h1 id="0c22" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">愚蠢的观点</h1><p id="6d3e" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">视图模型应该包含视图的所有业务逻辑、计算、数据操作和数据格式的<em class="lw">。为什么？因为一旦有了它，所有这些东西都可以被彻底测试和验证。</em></p><p id="465c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道我在这里重复我自己，但是我有一个观点。你看，上面不太明显的推论是，我们希望相关的视图尽可能的<em class="lw">愚蠢</em>。</p><p id="df8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有这样，我们才能有相对较高的信心，如果我们的视图模型是正确的，那么我们的视图就是正确的。</p><p id="6e73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个实际的视图。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="6536" class="nc ly it mx b gy nd ne l nf ng">struct AccountListView: View {</span><span id="4567" class="nc ly it mx b gy nh ne l nf ng">    @StateObject var viewModel = AccountListViewModel()</span><span id="16d0" class="nc ly it mx b gy nh ne l nf ng">    var body: some View {<br/>        if let accounts = viewModel.showAccounts {<br/>            List {<br/>                ForEach(accounts, id: \.id) { account in<br/>                    AccountListCellView(account: account)<br/>                }<br/>                if let footnote = viewModel.footnote {<br/>                    Text(footnote)<br/>                        .font(.footnote)<br/>                }<br/>            }<br/>        } else if let empty = viewModel.empty {<br/>            Text(empty)<br/>                .foregroundColor(.gray)<br/>        } else if let error = viewModel.error {<br/>            Text(error)<br/>                .foregroundColor(.red)<br/>        } else {<br/>            ProgressView()<br/>                .onAppear {<br/>                    viewModel.load()<br/>                }<br/>        }<br/>    }<br/>}</span></pre><p id="dd7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然看起来这个视图有很多逻辑，但是仔细观察你会发现这个视图只是简单地做了视图模型告诉它做的事情。</p><p id="13a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有客户，给他们看看。如果我们有空账户信息，显示出来；否则显示错误消息(如果有)。如果我们还没有任何这些东西，展示一个spinner，调用load，然后去获取它们。</p><p id="98c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该视图的行为完全由视图模型驱动。</p><p id="1358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是在做MVVM时要正确对待的最重要的概念之一，所以我要再重复一次:在MVVM，视图或视图控制器希望尽可能的愚蠢。</p><p id="eb4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为在视图模型中<em class="lw">而不是</em>的视图或视图控制器中做出的每一个决定或计算或操作都是你只能<em class="lw">假设</em>是正确的。你知道他们怎么说那些自以为是的人。</p><p id="faf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要记住，如果你不能测试它，你就不能证明它。</p><h1 id="1c9a" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">UIKit</h1><p id="c07f" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在UIKit中使用<code class="fe mu mv mw mx b">UIViewControllers</code>也是一样。与视图控制器管理的视图相似的视图模型中的一部分代码绑定数据可能看起来像…</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="ef99" class="nc ly it mx b gy nd ne l nf ng">...<br/>messageLabel.text = viewModel.emptyMessage<br/>messageLabel.hidden = viewModel.emptyMessage == nil<br/>...</span></pre><p id="96f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在MVVM中，视图控制器的角色是将数据从视图模型传递到视图，如果需要，当用户点击按钮或在文本字段中键入内容时，通过调用适当的方法来触发视图模型的变化。</p><p id="1b49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图模型更新状态并触发刷新，这再次导致视图控制器从视图模型复制该状态并将其应用到用户界面。</p><p id="581b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，视图控制器的存在只是为了将东西从A点传递到b点。</p><p id="f9c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lw">必须编写我们自己的视图绑定代码是SwiftUI代码比UIKit代码更干净、更精简(更不容易出错)的原因之一。</em></p><h1 id="e657" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">视图模型不是协议</h1><p id="3bc6" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在经典的面向对象编程中，通常会区分<em class="lw">是</em>的对象和<em class="lw">包含</em>的对象。(是A对有A)。</p><p id="7a29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们的视图模型有一个实现帐户提供者协议的对象实例。</p><p id="21e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过交换我们的数据提供者，我们可以为我们的视图模型提供不同的数据，并观察它如何响应。这反过来又让我们练习和测试更多我们将在生产中实际使用的代码。</p><p id="8d5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果视图模型本身实现了某种协议，允许它被换出(是A)，那么我们就失去了这些好处。考虑:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="dc81" class="nc ly it mx b gy nd ne l nf ng">protocol AccountListViewModeling: ObservableObject {</span><span id="0b70" class="nc ly it mx b gy nh ne l nf ng">    var accounts: [AccountListModel]? { get }<br/>    var footnote: String? { get }<br/>    var empty: String? { get }<br/>    var error: String? { get }</span><span id="9a7f" class="nc ly it mx b gy nh ne l nf ng">    func load()<br/>}</span></pre><p id="170f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该协议基于我们更新的视图模型。现在让我们做一个模拟。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="2409" class="nc ly it mx b gy nd ne l nf ng">class FakeEmptyAccountListViewModel: AccountListViewModeling {</span><span id="763b" class="nc ly it mx b gy nh ne l nf ng">    var accounts: [AccountListModel]?<br/>    var footnote: String?<br/>    var empty: String?<br/>    var error: String?</span><span id="235f" class="nc ly it mx b gy nh ne l nf ng">    func load() {<br/>        empty = "Nothing to see here."<br/>    }<br/>}</span></pre><p id="53f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个版本只是在调用load时设置空变量。所以，是的，我可以设置一个预览，我给我的帐户列表视图的实例上面的假视图模型…但目的是什么？</p><p id="ccad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，我可以这样做…但这不会告诉我一件单独的事情，当<em class="lw"> it </em>看到一组空的帐户时，我的<em class="lw">生产</em> <em class="lw">视图模型</em>将如何表现。或者是个错误。甚至是账户列表。</p><p id="9fb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的模拟预览在Xcode中看起来是正确的，但是我们无法知道当它实际上使用我们跳过的代码运行时，我们的视图会如何表现。</p><p id="2837" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要交换您的视图模型。交换出它们所依赖的数据(或数据提供者)。</p><h1 id="22d0" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">查看合成</h1><p id="2a03" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">SwiftUI强烈鼓励的一件事是视图组合——由其他视图组成的视图组成的视图。我们上面的表现很好，但我认为我们可以做得更好。</p><p id="4170" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们当前的视图处理帐户列表本身的加载、错误状态和显示。如果我们打破它呢？考虑一下。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="568b" class="nc ly it mx b gy nd ne l nf ng">struct AccountListLoadingView: View {</span><span id="3ae5" class="nc ly it mx b gy nh ne l nf ng">    @StateObject var viewModel = AccountListLoadingViewModel()</span><span id="43f9" class="nc ly it mx b gy nh ne l nf ng">    var body: some View {<br/>        if let accounts = viewModel.accounts,<br/>           let footnote = viewModel.footnote {<br/>            AccountListView(accounts: accounts, footnote: footnote)<br/>        } else if let empty = viewModel.empty {<br/>            MessageView(message: empty, color: .gray)<br/>        } else if let error = viewModel.error {<br/>            MessageView(message: error, color: .red)<br/>        } else {<br/>            ProgressView()<br/>                .onAppear {<br/>                    viewModel.load()<br/>                }<br/>        }<br/>    }<br/>}</span></pre><p id="87dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们的<code class="fe mu mv mw mx b">AccountListLoadingView</code>处理分支逻辑…就这样。这使得我们的列表视图变得非常简单。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="80d7" class="nc ly it mx b gy nd ne l nf ng">struct AccountListView: View {<br/>    let accounts: [AccountListModel]<br/>    let footnote: String<br/>    var body: some View {<br/>        List {<br/>            ForEach(accounts, id: \.id) { account in<br/>                AccountListCellView(account: account)<br/>            }<br/>            Text(footnote)<br/>                .font(.footnote)<br/>        }<br/>    }<br/>}</span></pre><p id="a7c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将我们的视图分割成更小的视图，让每个视图专注于自己的职责范围，这反过来使每个视图更容易理解和推理。我们的新装载视图现在更容易浏览，我们的新<code class="fe mu mv mw mx b">AccountListView</code>非常干净，甚至<em class="lw">都不需要</em>视图模型。</p><p id="607e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这完全没问题。如果需要的话，MVVM是一个可以使用的工具。</p><h1 id="25f3" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">重组</h1><p id="13d4" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我之前提到过，在现实世界中，我可能会以不同的方式处理这个问题，所以让我们来看看这个问题。</p><p id="3a87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们新的装载视图:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="bed0" class="nc ly it mx b gy nd ne l nf ng">struct AccountListLoadingView: View {</span><span id="adca" class="nc ly it mx b gy nh ne l nf ng">    @StateObject var viewModel = AccountListLoadingViewModel()</span><span id="71df" class="nc ly it mx b gy nh ne l nf ng">    var body: some View {<br/>        switch viewModel.state {</span><span id="d129" class="nc ly it mx b gy nh ne l nf ng">        case .loaded(let accounts, let footnote):<br/>            AccountListView(accounts: accounts, footnote: footnote)</span><span id="6fde" class="nc ly it mx b gy nh ne l nf ng">        case .empty(let message):<br/>            MessageView(message: message, color: .gray)</span><span id="0f9c" class="nc ly it mx b gy nh ne l nf ng">        case .error(let message):<br/>            MessageView(message: message, color: .red)</span><span id="6fd6" class="nc ly it mx b gy nh ne l nf ng">        case .loading:<br/>            ProgressView()<br/>                .onAppear {<br/>                    viewModel.load()<br/>                }<br/>        }<br/>    }<br/>}</span></pre><p id="bed2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的视图模型的整个输出现在是一个枚举的状态，从每个状态获得的相关值被传递给它自己的视图。</p><p id="7a72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们早期的许多测试只是为了确保我们的视图模型中没有冲突的值(状态)。现在我们已经完全消除了这个问题。视图模型<em class="lw">让</em>处于这些可能状态中的一种——且只有一种。</p><p id="3f68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着视图本身只能处于其中一种状态。</p><p id="14e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是新的视图模型。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="5687" class="nc ly it mx b gy nd ne l nf ng">class AccountListLoadingViewModel: ObservableObject {<br/>    <br/>    enum State {<br/>        case loading<br/>        case loaded([Account], String)<br/>        case empty(String)<br/>        case error(String)<br/>    }<br/>    <br/>    @Published var state: State = .loading<br/>    <br/>    var loader: AccountLoading<br/>    <br/>    init(loader: AccountLoading = API.shared) {<br/>        self.loader = loader<br/>    }<br/>    <br/>    func load() {<br/>        if let (accounts, footnote) = loader.loadAccounts() {<br/>            if accounts.isEmpty {<br/>                state = .empty("No accounts")<br/>            } else {<br/>                state = .loaded(accounts, footnote)<br/>            }<br/>        } else {<br/>            state = .error("Unable to load accounts")<br/>        }<br/>    }<br/>}</span></pre><p id="8c9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们不再需要将所有内容重置为零，因为我们的模型只有一个定义好的状态。事实上，一个架构上的改变<em class="lw">消除了一整类潜在的错误</em>。</p><p id="fb52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就此而言，它还消除了对大量<em class="lw">测试</em>的需要，因为许多测试只是为了确保我们没有冲突的内部状态值。</p><p id="ff7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可能会编写一些测试，只是为了确保我们看到预期的空状态和错误状态，但仅此而已。我们变革的又一次胜利。</p><p id="35a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，作为加载过程的一部分，我们还消除了将每个帐户映射到一个<code class="fe mu mv mw mx b">AccountListModel</code>的做法。如果需要，可以在单个细胞水平上进行处理。</p><p id="7061" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，<em class="lw">可能会对大型列表的性能产生重大影响，最好在其他地方处理。</em></p><h1 id="19a1" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">完成块</h1><p id="bbce" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">人们可以写一整本关于MVVM的书，但是在这里我只想演示为什么视图模型应该<em class="lw">而不是</em>作为协议来实现。</p><p id="36d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，基于协议的视图模型可以使预览更容易使用，但是我们需要记住我们的目标不是创建<em class="lw">预览</em>，而是创建在任何和所有条件下都能正确运行的工作、功能<em class="lw">应用</em>。</p><p id="ec45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们要尽可能多地测试和使用我们的产品代码，即使是做一些简单的预览。</p><p id="10aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，从某种角度来看，人们甚至可以认为我们编写的每一个预览都是另一种类型的单元测试。</p><p id="38da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试的最终结果本质上是简单直观的，我们可以<em class="lw">看到</em>是正确的。</p><p id="8ee8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次见。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="0938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，这是我继续<a class="ae ky" href="https://michaellong.medium.com/the-swiftui-series-abc180690a9d" rel="noopener"> SwiftUI系列</a>的另一篇文章。请随意查看。</p></div></div>    
</body>
</html>