<html>
<head>
<title>Getting Strict With TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对类型脚本越来越严格</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-strict-with-typescript-2e906b48c0a?source=collection_archive---------4-----------------------#2021-01-05">https://betterprogramming.pub/getting-strict-with-typescript-2e906b48c0a?source=collection_archive---------4-----------------------#2021-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8fed" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使您的类型脚本代码更具可读性和类型安全</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ab799de3727cc3445eb7f464c5b30aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xm8g1hbpmErMYoaC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pankaj Patel </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="57d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如大多数人所知，TypeScript是微软在2012年构建的一种语言，尽管我们直到2016年随着期待已久的Angular 2和mapped types的发布才看到它的腾飞。如果你想了解更多关于映射类型的知识，可以看看我写的主题为的文章。</p><p id="58fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多人反对让TypeScript成为他们生态系统的一部分，因为他们说这违背了JavaScript的精神。我不确定这些人是否知道它可以配置得更严格。</p><p id="a150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们经常给出这些不使用TypeScript的理由:</p><ul class=""><li id="bc5d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">这并不能解决问题。</li><li id="2313" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它不是超集，而是子集。</li><li id="b02f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它是开源的，但仅此而已。</li><li id="f82c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">只是炒作而已。</li></ul><p id="221a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些理由对我来说都没有多少说服力，但是一旦我们进入TypeScript的<code class="fe mj mk ml mm b">strict</code>模式，它们将看起来更加牵强。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="6260" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">什么是Typescript的严格模式？</h1><p id="969f" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">通过使用一个<code class="fe mj mk ml mm b">tsconfig.json</code>文件来配置TypeScript。启用<code class="fe mj mk ml mm b">strict</code>模式非常简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2edc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是为了启用引擎盖下的<code class="fe mj mk ml mm b">noImplicitAny</code>、<code class="fe mj mk ml mm b">noImplicitThis</code>、<code class="fe mj mk ml mm b">alwaysStrict,</code>、<code class="fe mj mk ml mm b">strictBindCallApply</code>、<code class="fe mj mk ml mm b">strictNullChecks</code>、<code class="fe mj mk ml mm b">strictFunctionTypes</code>和<code class="fe mj mk ml mm b">strictPropertyInitialization</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这真是个好消息。这意味着我们可以逐步朝着<code class="fe mj mk ml mm b">strict</code>前进，所以你不需要马上赶去你的项目并改变<code class="fe mj mk ml mm b">"strict": true</code>。您可能永远不想将这些属性切换到<code class="fe mj mk ml mm b">on</code>。这取决于你。</p><p id="7026" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将一起查看每处房产，看看为什么拥有它会有意思<code class="fe mj mk ml mm b">on/off</code>。</p><p id="261e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些地方，您可能希望例外地忽略一些类型脚本错误，您可以通过使用下面的批注来做到这一点:</p><pre class="kj kk kl km gt nt mm nu nv aw nw bi"><span id="104f" class="nx mv it mm b gy ny nz l oa ob">// @ts-ignore<br/>code throwing error here</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="30ce" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">1.无ImplicitAny</h1><p id="f555" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">该标志防止您公开带有推断的<code class="fe mj mk ml mm b">any</code>的合同。如果不指定类型，无法推断，则默认为<code class="fe mj mk ml mm b">any</code>。</p><p id="01fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对TypeScript的推断系统的工作方式有任何疑问，可以查看下面的内容:</p><div class="oc od gp gr oe of"><a href="https://www.typescriptlang.org/docs/handbook/type-inference.html" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">文档型推理</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">在TypeScript中，有几个地方在没有…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">www.typescriptlang.org</p></div></div></div></a></div><p id="3088" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可能会写一篇文章来详细讨论这个问题。敬请关注。</p><p id="5afc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来看一些<code class="fe mj mk ml mm b">noImplicitAny</code>转<code class="fe mj mk ml mm b">on</code>的代码:</p><pre class="kj kk kl km gt nt mm nu nv aw nw bi"><span id="fa9f" class="nx mv it mm b gy ny nz l oa ob">const add10 = (number) =&gt; number + 10; <br/>// error: Parameter 'number' implicitly has an 'any'</span></pre><p id="24b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修复非常简单:</p><pre class="kj kk kl km gt nt mm nu nv aw nw bi"><span id="84c3" class="nx mv it mm b gy ny nz l oa ob">const add10 = (number: number) =&gt; number + 10;</span></pre><p id="d66f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以<code class="fe mj mk ml mm b">noImplicitAny</code>标志确保你公开了你的代码可以遵守的可读契约。否则，<code class="fe mj mk ml mm b">add10</code>调用者需要推导出参数是数字，那么使用TypeScript又有什么意义呢？</p><p id="990a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你希望你的代码可读性更强，防错吗？那么这个标志绝对应该打开。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="38f5" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">2.不影响这个</h1><p id="2dd9" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe mj mk ml mm b">this</code>关键字将基本上防止不必要的行为。它可以让您摆脱一些调试难题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道这个实现很糟糕，但这只是为了说明一点。让我们面对它:如果你没有使用Angular，你就不会有这个问题，因为你不应该使用类。即使您正在使用类，您也应该使用<code class="fe mj mk ml mm b">lambda</code>操作符，这将为您解决这个问题，因为它从函数创建者返回相同的<code class="fe mj mk ml mm b">this</code>上下文。</p><p id="bc3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我看不出你有什么理由不喜欢这个<code class="fe mj mk ml mm b">on</code>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="3c3d" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">3.总是严格</h1><p id="64f4" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">对于这一个，只要确保<code class="fe mj mk ml mm b">use strict</code>在所有转换的JavaScript文件中发出，除了编译器。</p><p id="9741" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">ECMAScript strict</code>模式是在<code class="fe mj mk ml mm b">ES5</code>中引入的，它只是提示编译器代码应该在<code class="fe mj mk ml mm b">strict mode</code>中执行，这可以防止你使用未声明的变量。</p><p id="9714" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码以更安全/更高效的方式运行？绝对值得拥有<code class="fe mj mk ml mm b">on</code>。</p><p id="d7b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想深入了解ECMAScript <code class="fe mj mk ml mm b">strict mode</code>，请查看下面的MDN参考资料:</p><div class="oc od gp gr oe of"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">严格模式</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">ECMAScript 5中引入的JavaScript的严格模式是一种选择JavaScript的受限变体的方式，因此…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">developer.mozilla.org</p></div></div><div class="oo l"><div class="op l oq or os oo ot ks of"/></div></div></a></div></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="e57a" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">4.strictBindCallApply</h1><p id="dcd9" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">启用它将确保您使用正确的参数调用<code class="fe mj mk ml mm b">call</code>、<code class="fe mj mk ml mm b">bind</code>和<code class="fe mj mk ml mm b">apply</code>函数。我不知道你，但我在那里犯了错误，所以它肯定有帮助。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8c90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个显而易见的问题，应该转向<code class="fe mj mk ml mm b">on</code>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="1969" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">5.strictNullChecks</h1><p id="f2e5" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">对我来说，这是最重要的一个。这将产生巨大的影响，而且可能是最耗时的。如果该标志为<code class="fe mj mk ml mm b">off</code>，任何类型都可以分配给<code class="fe mj mk ml mm b">null</code>或<code class="fe mj mk ml mm b">undefined</code>。这种<code class="fe mj mk ml mm b">lax</code>类型的问题是，你不会捕捉到<code class="fe mj mk ml mm b">null</code>指针异常，你的契约也不会那么具体。</p><p id="884b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">禁用<code class="fe mj mk ml mm b">strictNullChecks</code>后，即使<code class="fe mj mk ml mm b">book.name</code>可能是<code class="fe mj mk ml mm b">undefined</code>，这段代码也会编译。您将错过TypeScript的<code class="fe mj mk ml mm b">null</code>检查警告。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d74f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当将<code class="fe mj mk ml mm b">strictNullChecks</code>设置为<code class="fe mj mk ml mm b">true</code>时，您将在第12行得到一个错误:</p><pre class="kj kk kl km gt nt mm nu nv aw nw bi"><span id="8233" class="nx mv it mm b gy ny nz l oa ob">console.log(book.name) // Object is possibly 'undefined'.</span></pre><p id="ce2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，您必须为要编译的代码添加空检查:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="953d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数和契约也会发生类似的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8ceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您有两种可能的解决方案，请选择更符合您需求的一种:</p><ul class=""><li id="cf94" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使<code class="fe mj mk ml mm b">logBookName</code>方法接受<code class="fe mj mk ml mm b">book | undefined</code>。</li><li id="83bc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一个<code class="fe mj mk ml mm b">null</code>检查条件调用。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7cbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，启用这个标志会迫使您编写具有更好类型描述的代码。您将会发现许多<code class="fe mj mk ml mm b">null</code>错误。通常，这些问题会在单元测试期间被缓存，但是使用TypeScript，您可以免费获得这些问题。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c7e1" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">6。strictFunctionTypes </h1><p id="c643" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">具有该标志<code class="fe mj mk ml mm b">on</code>可确保更彻底地检查功能参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2760" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果该标志没有启用，第13行的赋值将正常工作。由于某种原因，TypeScript的编译器忽略了函数中的类型。最好启用这个来防止这种行为。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="229a" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">7.<code class="fe mj mk ml mm b">strictPropertyInitialization</code></h1><p id="2717" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">当设置为<code class="fe mj mk ml mm b">true</code>时，这将强制您设置构造函数中的所有属性值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="cd26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ou">注意:只有当您启用了</em> <code class="fe mj mk ml mm b"><em class="ou">strictNullChecks</em></code> <em class="ou">时，才会显示此错误。那是因为如果</em> <code class="fe mj mk ml mm b"><em class="ou">strictNullChecks</em></code> <em class="ou">被禁用，那么</em> <code class="fe mj mk ml mm b"><em class="ou">author</em></code> <em class="ou">为</em> <code class="fe mj mk ml mm b"><em class="ou">undefined</em></code> <em class="ou">是可以接受的。</em></p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0ec6" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">包扎</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/623cef70cff8f602c6dfa7c4eb6b078f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ncZxUytyIYJ6Tuyx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@rmonterola?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗伯特·蒙特罗拉(roberto monterola jr. </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="a8cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这七个简单的步骤，我们让TypeScript为我们捕捉更多的错误，并在键入合同时更加具体。</p><p id="bb39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是TypeScript所能达到的最严格的要求吗？不完全是。这是开箱后最严格的要求了！您可以向它抛出<code class="fe mj mk ml mm b">eslint</code>规则来进一步定制它。我的建议是简单一点，用<code class="fe mj mk ml mm b">@typescript-eslint/recommended</code>。我将很快写一篇文章列举使用这个插件的好处。敬请关注。</p><p id="80ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想在一个有大量代码的项目上启用<code class="fe mj mk ml mm b">strict</code>模式特性，并且你觉得你不能一次修复所有的问题，你可以使用一个工具逐步实现。</p><p id="9c0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的工具将帮助你学会<code class="fe mj mk ml mm b">strict</code>打字。通过转换大型代码库，您肯定会学到很多东西。当您的<code class="fe mj mk ml mm b">strict</code>之旅结束后，您可以永久删除该工具。</p><div class="oc od gp gr oe of"><a href="https://github.com/cschroeter/ts-strictify" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">cschroeter/ts-strictify</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">在严格模式下对已更改的文件运行TypeScript。TBD:当你开始开发一个新功能或修复一个错误时，你…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="ow l oq or os oo ot ks of"/></div></div></a></div><p id="342e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干杯！</p></div></div>    
</body>
</html>