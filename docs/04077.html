<html>
<head>
<title>Create a Proximity Graph Animation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建邻近图动画</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-a-proximity-graph-animation-an-introduction-to-html5-canvas-and-the-animation-loop-45719d82d1a3?source=collection_archive---------6-----------------------#2020-03-22">https://betterprogramming.pub/creating-a-proximity-graph-animation-an-introduction-to-html5-canvas-and-the-animation-loop-45719d82d1a3?source=collection_archive---------6-----------------------#2020-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="418c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">2D HTML5画布和动画循环介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bb7117c525860b89b7978b50b2e0a0ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a4tiXdRcOxYEQn-SyV6Jcw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="bf7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我正努力充分利用这些隔离的日子，学习新东西成了我最喜欢的消遣。几天前，我在浏览<a class="ae lu" href="https://www.gatsbyjs.org/" rel="noopener ugc nofollow" target="_blank">盖茨比</a>教程时偶然发现了<a class="ae lu" href="https://www.howtographql.com/" rel="noopener ugc nofollow" target="_blank">如何绘制QL </a>。我真的很喜欢这个背景动画，我决定用HTML5画布复制它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/b02e21546cb0e755ced859f1b853ca4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*tNQmBoNt0q_Ph8BT9GWhYA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lu" href="https://www.howtographql.com/" rel="noopener ugc nofollow" target="_blank">如何绘制背景动画</a></p></figure><p id="47fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你好奇想看看最终的结果，我已经在<a class="ae lu" href="https://github.com/vdeantoni/proximity-graph-animation" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和<a class="ae lu" href="https://codepen.io/vdeantoni/pen/wvaEoxE" rel="noopener ugc nofollow" target="_blank"> CodePen </a>上发布了一个<a class="ae lu" href="https://proximity-graph-animation.netlify.app/" rel="noopener ugc nofollow" target="_blank">演示</a>和源代码。</p><p id="d0fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事不宜迟，我们开始吧。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="efc4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">目录</h1><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="db16" class="na me it mw b gy nb nc l nd ne">· <a class="ae lu" href="#f593" rel="noopener ugc nofollow">Let’s Define the Work</a><br/>· <a class="ae lu" href="#2c67" rel="noopener ugc nofollow">Set Up the HTML and Canvas</a><br/>· <a class="ae lu" href="#5447" rel="noopener ugc nofollow">Draw the Points</a><br/>· <a class="ae lu" href="#1b35" rel="noopener ugc nofollow">Implement the Animation Loop</a><br/>· <a class="ae lu" href="#cc7a" rel="noopener ugc nofollow">Move the Points</a><br/>· <a class="ae lu" href="#fe87" rel="noopener ugc nofollow">Draw the Lines</a><br/>· <a class="ae lu" href="#df84" rel="noopener ugc nofollow">Polish</a></span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f593" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">让我们来定义这项工作</h1><p id="f100" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">动画的工作原理是以恒定速度在固定方向上移动点，并在任何两个彼此靠近的点之间绘制直线。</p><p id="2d02" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在此基础上，我们将工作分解为以下任务:</p><ul class=""><li id="3335" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated">设置HTML和画布</li><li id="9876" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">画出要点</li><li id="f7e7" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">实现动画循环</li><li id="ddb2" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">移动点</li><li id="798b" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">画线</li><li id="8f25" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">抛光剂</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2c67" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">设置HTML和画布</h1><p id="16b2" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们将从创建一个带有<code class="fe ny nz oa mw b">&lt;canvas&gt;</code>元素的基本HTML布局开始。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="1f3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经给了<code class="fe ny nz oa mw b">&lt;canvas&gt;</code>元素一个ID，我们将使用它通过JavaScript访问元素及其<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank"> API </a>，以及像素中的<code class="fe ny nz oa mw b">width</code>和<code class="fe ny nz oa mw b">height</code>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5447" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">画出要点</h1><p id="c56e" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">有了<code class="fe ny nz oa mw b">&lt;canvas&gt;</code>元素，我们可以开始使用JavaScript和2D渲染上下文<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D" rel="noopener ugc nofollow" target="_blank"> API </a>在上面绘制东西。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="a64a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的代码在画布中间画了一个半径为1像素的黑色圆圈。</p><p id="ecc1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你跟不上，你可以使用下面的代码笔:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oc l"/></div></figure><p id="2688" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在将生成固定数量的20个点，随机放置在画布上。对于每个点，我们将创建一个对象，该对象最初包含该点的x和y位置。创建完成后，对象将被添加到一个列表中，我们稍后将使用该列表迭代并绘制每个点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d60f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还创建了一个辅助函数，它依赖于<code class="fe ny nz oa mw b">Math.random()</code>来生成一个给定范围内的随机数。当创建一个点时使用这个函数，允许我们在画布的边界内随机定位它。</p><p id="4d76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是时候画点了。我们将对绘制点的代码做一些修改，并在迭代点列表时使用它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="1287" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">把这些放在一起，我们就可以在画布上画出所有的随机点。</p><p id="e027" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以用下面的代码笔看到它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oc l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1b35" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">实现动画循环</h1><p id="08c6" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们知道这些点必须四处移动。为了实现这一点，它们需要被动画化。我喜欢引用的一个动画定义是:</p><blockquote class="oe of og"><p id="95c8" class="ky kz oh la b lb lc ju ld le lf jx lg oi li lj lk oj lm ln lo ok lq lr ls lt im bi translated"><em class="it">“一部动画只不过是变化的可视化——一段时间内发生的变化。”—</em><a class="ae lu" href="https://www.oreilly.com/library/view/creating-web-animations/9781491957509/ch01.html" rel="noopener ugc nofollow" target="_blank"><em class="it"/></a></p></blockquote><p id="eed4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，现代浏览器提供了一个非常方便的方法叫做<code class="fe ny nz oa mw b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank">requestAnimationFrame</a></code>，我们可以用它来动画显示画布上的点。该方法将回调作为参数，供浏览器在重绘屏幕时调用。</p><p id="0abe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回调是我们提供的一个函数，我们将使用它来处理点的位置，并确定两个点是否应该连接。回调通常每秒调用60次，或者每1/60秒调用一次(大约16ms)。</p><p id="845c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们完成处理，浏览器将呈现一个新的框架，在新的位置上显示点和它们的连接。有了足够的帧数，我们的动画就会栩栩如生！</p><p id="d348" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在将创建动画循环。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="5958" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样。多亏了<code class="fe ny nz oa mw b">requestAnimationFrame</code>，我们只需要四行代码，每当浏览器准备好渲染另一帧时，我们的<code class="fe ny nz oa mw b">loop</code>函数就会被调用，同样，以每秒60帧的速度，每16毫秒渲染一帧。</p><p id="5503" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用JavaScript实现动画循环时，需要考虑更多的事情。我推荐阅读关于<a class="ae lu" href="https://hacks.mozilla.org/2011/08/animating-with-javascript-from-setinterval-to-requestanimationframe/" rel="noopener ugc nofollow" target="_blank">处理非活动标签</a>和关于<a class="ae lu" href="https://muffinman.io/javascript-animation-loop/" rel="noopener ugc nofollow" target="_blank">计时问题</a>的内容，因为我不会在本文中讨论这些内容。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="cc7a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">移动点</h1><p id="8da3" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">当我们定义我们正在创建的动画时，我们说点以恒定的速度在固定的方向上移动。我们可以用一个<a class="ae lu" href="https://www.intmath.com/vectors/3-vectors-2-dimensions.php" rel="noopener ugc nofollow" target="_blank"> 2D向量</a>来表示一个点的方向和速度。</p><p id="ad22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">向量有水平(x)和垂直(y)分量，还有一个大小。这两个分量决定了指向的方向。通常用角度(度或弧度)来描述。幅度是向量的长度，或者在我们的情况下是点的速度，它决定了点在特定时间点在它“面对”的方向上移动的速度。</p><p id="c170" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们知道我们可以用角度和弧度来表示方向，但是我们用什么来表示速度呢？举个例子，我们可以说一辆汽车以每小时60英里的速度行驶，一个人以每秒1.4米的速度行走。我们在学校都学过一个简单的公式，定义速度等于距离除以时间。我们工作的距离和时间是多少？</p><p id="2ff8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你现在看到的屏幕是由像素组成的，我们可以用像素的数量来决定它的逻辑显示尺寸。这也是我们在定义<code class="fe ny nz oa mw b">&lt;canvas&gt;</code>的宽度和高度时使用的单位:我们都设置为400px。因为点会在画布和屏幕上移动，我们可以用像素作为距离的单位。</p><p id="7eb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而且，正如我们上面提到的，浏览器会让我们每隔16毫秒处理一次动画。我们称之为帧持续时间，这是我们的时间单位。这样，速度就是每帧持续时间的像素。</p><p id="2527" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际值可以是我们想要的任何数字。我们可以尝试不同的值来确定什么是最好的。</p><p id="fc95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，回到移动点。在基本三角学的帮助下，我们可以用两个方程计算已知方向和速度的点的位移:</p><p id="5a21" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">x =速度* cos(方向)<br/> y =速度* sin(方向)</p><p id="6ba4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们将位移加到当前位置，我们将得到该点的下一个位置。</p><p id="513d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数学够了，我们来编码吧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3292" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们创建了一个名为<code class="fe ny nz oa mw b">movePoint</code>的函数，给定一个点对象，现在有了两个新属性<code class="fe ny nz oa mw b">s</code>和<code class="fe ny nz oa mw b">d</code>，更新点的位置。这个函数将作为动画循环的一部分被调用。</p><p id="eaab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还需要改变点的创建来设置两个新的属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="47ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们设置<code class="fe ny nz oa mw b">d</code>为0到360度之间的一个随机数，所以点会向随机方向移动，<code class="fe ny nz oa mw b">s</code>为1 px/fd。</p><p id="d000" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">把我们到目前为止所有的放在一起，我们应该有移动点！</p><p id="70da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请看下面的直播:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oc l"/></div></figure><p id="b51f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">等等，为什么这些点会留下痕迹？这就是画布的工作原理。这是一个限制，一旦一个形状被画出来，它就保持不变。幸运的是，有一个简单的方法可以解决这个问题。我们所需要做的就是在动画循环开始时调用<code class="fe ny nz oa mw b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/clearRect" rel="noopener ugc nofollow" target="_blank">clearRect</a>(0, 0, canvas.width, canvas.height)</code>，它将清除画布上之前已经绘制的任何形状。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="fe87" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">画线</h1><p id="d538" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们现在将画出连接任意两个足够近的点的线。当两点之间的距离小于100像素时，我们会说这两点足够近。</p><p id="4e45" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们如何找到所有两点之间的距离小于或等于100px的点对？出于本文的考虑，我们将选择一种非最优但简单的方法。</p><p id="0675" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于每个点，我们将查看所有其他点，计算距离，并决定是否需要绘制一条线。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d070" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以对这段代码进行一些性能改进，例如:</p><ul class=""><li id="1447" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated">通过检查<code class="fe ny nz oa mw b">other.x &gt; point.x + CONNECT_DISTANCE</code>或<code class="fe ny nz oa mw b">other.x &lt; point.x — CONNECT_DISTANCE</code>或<code class="fe ny nz oa mw b">other.y &gt; point.y + CONNECT_DISTANCE</code>或<code class="fe ny nz oa mw b">other.y &lt; point.y — CONNECT_DISTANCE</code>来消除明显的点</li><li id="c96c" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">记录连接，这样就不会画两次线，<code class="fe ny nz oa mw b">point — other</code>和<code class="fe ny nz oa mw b">other — point</code></li></ul><p id="306c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不考虑改进，只要我们有两个嵌套循环，时间复杂度仍然是O(n ) <em class="oh">。</em>如果你有兴趣了解这个问题的更好、更复杂的解决方案，我推荐你阅读Q<a class="ae lu" href="https://en.wikipedia.org/wiki/Quadtree" rel="noopener ugc nofollow" target="_blank">uad tree</a>、<a class="ae lu" href="https://en.wikipedia.org/wiki/K-d_tree" rel="noopener ugc nofollow" target="_blank">T12】k-d tree</a>和<a class="ae lu" href="https://en.wikipedia.org/wiki/Range_searching" rel="noopener ugc nofollow" target="_blank">范围搜索</a>。</p><p id="fb1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看我们在哪里:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oc l"/></div></figure><p id="77cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不错！我们快到了。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="df84" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">抛光剂</h1><p id="37e6" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们已经走了很长一段路。我们从一个空白的画布开始，现在我们有了四处移动的点，当它们足够接近时就可以画线了。</p><p id="14aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们还想做两件事:在点移出画布时恢复它们，并添加线条拉伸效果。</p><p id="c205" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有几种方法可以实现前者。一旦点移出画布，我们就可以从列表中删除它们。然后，对于我们移除的每个点，我们在随机位置添加一个新的点。我们也可以在他们一到达边境就把他们反弹回来，或者我们可以“传送”到对面的地方<em class="oh"> à la </em> PacMan。</p><p id="d1af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于本文，我们将实现第一种方法，因为我们已经有了它的大部分代码。</p><p id="636b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们处理完动画循环中的下一个位置后，我们将删除出界的点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3542" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了将点创建循环移动到动画循环中做一些小的改动，我们还必须将<code class="fe ny nz oa mw b">points</code>从<code class="fe ny nz oa mw b">const</code>改为<code class="fe ny nz oa mw b">let</code>。我们也将用<code class="fe ny nz oa mw b">points.length</code>而不是<code class="fe ny nz oa mw b">0</code>来初始化<code class="fe ny nz oa mw b">i</code>。这样，我们总是会在删除一些点后立即添加新的点。</p><p id="07fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于线条拉伸效果，如果你密切关注<a class="ae lu" href="https://www.howtographql.com/" rel="noopener ugc nofollow" target="_blank"> How To GraphQL </a>背景动画，线条实际上会随着点彼此远离而拉伸变细。我们将尝试通过根据距离改变线条的不透明度来复制这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="ac72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完整的JavaScript代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="b13b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个现场演示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oc l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="d2b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读，我希望你今天学到了一些新东西。</p><p id="6f64" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">保重，我们下次再见！</p></div></div>    
</body>
</html>