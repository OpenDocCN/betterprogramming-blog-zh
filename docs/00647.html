<html>
<head>
<title>My Experience Migrating From Ionic 3 to Ionic 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我从Ionic 3迁移到Ionic 4的经历</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ionic-3-to-ionic-4-migration-gotchas-928174b5eb12?source=collection_archive---------2-----------------------#2019-06-25">https://betterprogramming.pub/ionic-3-to-ionic-4-migration-gotchas-928174b5eb12?source=collection_archive---------2-----------------------#2019-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9cf4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Angular 7中一个有用的学习过程</p><h1 id="12a8" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">我为什么决定迁移？</h1><p id="9fca" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">不久前，作为学习Angular的一部分，我使用Ionic 3 / Angular 5开发了一个web应用程序(Progressive Web App)。应用程序被称为<strong class="js iu"> Morphistic </strong>，它是一个相当复杂的(对于网络应用程序来说)社交应用程序，可以从基本的贝塞尔曲线形状创建基于矢量的构图。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/d887e8f221968f13a75901a3962d652b.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*10p56dCPKBmpt3VD_CSFew.png"/></div></figure><p id="f8ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想长期支持这个应用程序，因为应用程序中的一些错误与过时的依赖关系(rxjs，firebase)有关，我觉得将它更新到Ionic 4 / Angular 7框架是一个好主意。我还希望在这个过程中了解更多关于Angular 7的功能。</p><p id="b0ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我更新的主要原因是:</p><ul class=""><li id="1966" class="ma mb it js b jt ju jx jy kb mc kf md kj me kn mf mg mh mi bi translated">转向获得长期支持的框架(LTS)</li><li id="d763" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">解决一些由于依赖不匹配而导致的讨厌的错误</li><li id="5d51" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">获得更多开箱即用的东西，而不是拥有自己的定制代码(服务人员、环境配置等)</li><li id="714c" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">采用和学习更多Angular(路由器等)</li></ul><p id="f494" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的期望是在一周内完成这个迁移项目(与许多指南建议的一致)</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="b2c6" class="ko kp it bd kq kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh mz lj lk ll bi translated">准备步骤</h1><p id="37af" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">为了简化迁移过程，我采取了三重策略:</p><h2 id="f90b" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated"><strong class="ak">第一步:迁移前学习离子4 /角度7</strong></h2><ul class=""><li id="f6d2" class="ma mb it js b jt lm jx ln kb nm kf nn kj no kn mf mg mh mi bi translated">深入研究Ionic团队的<a class="ae lr" href="https://ionicframework.com/docs/building/migration" rel="noopener ugc nofollow" target="_blank">迁移指南</a></li><li id="e3a5" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">通读Josh Morony的所有教程(所有与Ionic 4相关的内容)</li><li id="fca8" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">通读相关<a class="ae lr" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular.io </a>文章(如路由器)</li><li id="2002" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">用开源代码研究Ionic 4 apps的实际代码:<a class="ae lr" href="https://github.com/ionic-team/ionic-conference-app" rel="noopener ugc nofollow" target="_blank"> Ionic Conference app </a>(框架参考App)和<a class="ae lr" href="https://github.com/fluster/fluster-app" rel="noopener ugc nofollow" target="_blank"> Fluster app源码</a>(感谢<a class="np nq ep" href="https://medium.com/u/94f0c8061324?source=post_page-----928174b5eb12--------------------------------" rel="noopener" target="_blank"> David Dal Busco </a>让他的App开源！)</li></ul><h2 id="9fdc" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated"><strong class="ak">第二步:准备用于迁移的v.3代码</strong></h2><ul class=""><li id="61dc" class="ma mb it js b jt lm jx ln kb nm kf nn kj no kn mf mg mh mi bi translated">在仍然使用v.3代码的情况下实现任何和所有的更改，以便更容易迁移到v.4(重写模式以期望承诺等)</li><li id="72a3" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">创建新代码，并将其注释掉，直到迁移(styleUrls、providedIn等类似的语法变化)</li><li id="4e2c" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">将所有项目依赖项(package.json)更新到最新版本，并验证构建过程仍然适用于v.3</li></ul><h2 id="a012" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated"><strong class="ak">步骤3:执行迁移</strong></h2><ul class=""><li id="49b8" class="ma mb it js b jt lm jx ln kb nm kf nn kj no kn mf mg mh mi bi translated">为最大规模的工作寻找三到四个小时的安静时间:更新框架版本，启动新的“sidemenu app”(对我来说)，开始创建项目结构，一个接一个地添加页面和服务，修复导入等，旨在创建“可构建”的应用版本。</li><li id="85c4" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">然后，在几周的时间里，偷偷抽出一到两个小时的时间来工作(因为我没有每天都在我的应用上工作的奢侈)，专注于具体的工作。返工所有页面的模板代码，组件也一样，返工服务人员注册代码，重新添加预构建脚本(例如自动版本碰撞)。</li><li id="ca33" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">一旦应用程序接近完成，就要专注于完善和错误修复。</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="6881" class="ko kp it bd kq kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh mz lj lk ll bi translated">结果</h1><h2 id="5642" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated"><strong class="ak">迁移时间</strong></h2><p id="c11b" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">总的来说，我的计划还不错。我花了大约30-40个小时来完成整个项目(15个页面，15个以上的组件，10个以上的服务)，但实际上并不像我预期的那么容易(尽管做了准备),因为你会在下面发现许多“陷阱”。事实上，大部分意想不到的时间都花在了模板代码(HTML/CSS)上，因为我大量修改了v.3中的一些组件(使用CSS选择器来修改组件的内部HTML ),并且我对v.4组件的属性更改数量感到措手不及。然而，总的来说<em class="nr">在我的例子</em>中重构很多代码还是不错的。</p><h2 id="0530" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated"><strong class="ak">性能</strong></h2><p id="df1c" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">当我使用lighthouse工具以非节流方式测量性能时，没有发生什么大的变化。我看到的大多数改进都是针对3G / 4X CPU减速模式的:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ns"><img src="../Images/98e1391a20025ee9a8fbbd42f56a26f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GJ8ntEShDVy4HNu0SCo46A.png"/></div></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">Ionic v3 PWA性能:3G / 4X CPU减速灯塔(匿名)</p></figure><p id="eb5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相对</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ob"><img src="../Images/f3ba9a037a067059fc008db0dbed654a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ea1VQV2bRxhpEU5_H0MIZQ.png"/></div></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">Ionic v4 PWA性能:3G / 4X CPU减速灯塔(匿名)</p></figure><p id="b3cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，应用程序在较慢的连接和较慢的CPU上看到了更好的性能(第一次有意义的绘制时间快了300%+300%！希望移动用户能从中受益)。我的Ionic v.3应用程序版本在过去实际上优化得相当好(因为我试图按照最佳实践达到100 PWA分数)，但在v.4中，我很高兴获得更好的性能和更小的包大小，而没有我在v.3中应用的任何优化(删除未使用的材料设计CSS、未使用的组件、减少Ionic CSS颜色等)。)</p><h2 id="682b" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated"><strong class="ak">获得利益</strong></h2><p id="3ae8" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">这当然是主观的，但从高层次来说，这些是我真正欣赏的东西(也是为什么我很高兴进行这次迁移):</p><ul class=""><li id="8560" class="ma mb it js b jt ju jx jy kb mc kf md kj me kn mf mg mh mi bi translated">将依赖项更新到最新的稳定版本，主要问题和错误都已解决—成功！</li><li id="0b0a" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">整个应用程序的导航逻辑更清晰(路由器首先让人感到困惑，但现在我认为这是正确的选择！)</li><li id="78b3" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">现成可用的性能优势和其他功能(服务工作者、web工作者、环境配置、构建配置、自定义配置挂钩等，angular CLI的强大功能—所有这些)。</li><li id="7034" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">更多的棱角，更少的离子遗产“雪花”(例如，旧的navController，笨拙的懒惰加载组件假装它们是页面，等等)更多的棱角也意味着我可以获得更大的社区和支持。我认为这(提高代码可维护性)是目前为止最大的好处。</li><li id="01b4" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">一旦我明白了它们是什么，我真的很喜欢模板中的整个“槽”的变化。阅读更多<a class="ae lr" href="https://www.joshmorony.com/understanding-how-slots-are-used-in-ionic-4/" rel="noopener ugc nofollow" target="_blank">此处</a>来自<a class="np nq ep" href="https://medium.com/u/bb8eea5f6816?source=post_page-----928174b5eb12--------------------------------" rel="noopener" target="_blank">约书亚莫罗尼</a>。</li><li id="9908" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">我的应用程序特有的一些愚蠢的小收获:支持自定义SVG图像的离子图标(事实上，我可以使用自己的应用程序创建)</li><li id="51d8" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">希望不久我能在正式发布时更新到<a class="ae lr" href="https://angular.io/guide/ivy" rel="noopener ugc nofollow" target="_blank"> Ivy renderer </a></li></ul><p id="4336" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">底线——这是一个比预期更长的旅程，但绝对值得！</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="d171" class="ko kp it bd kq kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh mz lj lk ll bi translated"><strong class="ak">我学到的一些“窍门”</strong></h1><p id="0029" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">最后，我想列出我在整个迁移过程中在笔记中记录的事情，这些事情对于任何愿意迁移的人都是值得一读的:</p><h2 id="cafc" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated"><strong class="ak">阴影DOM &amp; CSS定制</strong></h2><p id="e395" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">如果您在v.3中通过css修改了HTML模板(比如我使用<code class="fe oc od oe of b">::after</code> css选择器等设计了ion-range旋钮),您可能需要花更多的时间来调整您的模板(或者简化它们，或者如果可能的话去掉这样的定制),因为v.4 Ionic组件被重写为利用shadow DOM和CSS的纯web组件，现在定制只能通过CSS定制属性来实现。阅读Josh撰写的本教程中的更多内容。(更新:如果您迁移到Ionic 5.2+,您可以利用影子部件对许多组件进行这样的定制。了解更多:<a class="ae lr" href="https://ionicframework.com/blog/customize-your-ionic-framework-app-with-css-shadow-parts/" rel="noopener ugc nofollow" target="_blank">https://ionicframework . com/blog/customize-your-ionic-framework-app-with-CSS-shadow-parts/</a>)</p><h2 id="0701" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated"><strong class="ak">生命周期挂钩变化</strong></h2><p id="4d8b" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">有些变化，比如使用<code class="fe oc od oe of b">ionViewDidLoad </code>钩子，很容易实现(很容易转向<code class="fe oc od oe of b">ngAfterViewInit</code>)，而有些变化，比如<code class="fe oc od oe of b">ionViewCanEnter</code>——现在需要理解和实现应用路由器中的角度防护(<code class="fe oc od oe of b">canLoad</code>、<code class="fe oc od oe of b">canActivate</code>)。这里还有一个来自Josh的<a class="ae lr" href="https://www.joshmorony.com/prevent-access-to-pages-in-ionic-with-angular-route-guards/" rel="noopener ugc nofollow" target="_blank">好指南</a>。</p><h2 id="b1b7" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated"><strong class="ak">组件的新属性</strong></h2><p id="d129" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">不知何故，我错过了理解许多组件属性变化有多大的机会。我在应用程序中大量使用离子范围、离子幻灯片等东西，作为v.4重写的一部分，许多这样的组件重新调整了它们的属性。因此，花一些时间阅读Ionic v.4组件的文档并彻底研究什么发生了变化是值得的——尤其是按钮、后退按钮、ion-slides等。</p><h2 id="3be3" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated"><strong class="ak">路由器变更</strong></h2><p id="440c" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在我阅读了Josh的<a class="ae lr" href="https://www.joshmorony.com/using-angular-routing-with-ionic-4/" rel="noopener ugc nofollow" target="_blank">教程后，我认为在v.3代码库中我做了正确的事情——我放弃了NavParams方法并重写了代码，以利用共享服务在页面间传递数据。因此，在实际迁移过程中，我所要做的就是编写我的路由器并从:<code class="fe oc od oe of b">this.navCtrl.push(“home”)</code>切换到<code class="fe oc od oe of b">this.navCtrl.navigateForward(“/home”)</code>。我认为这为我节省了很多时间，并且使用共享服务的页面到页面导航可以在迁移争论之前在v.3中实现，这很好。</a></p><h2 id="16b6" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated"><strong class="ak">服务人员变更</strong></h2><p id="c54c" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">好消息是——我们现在可以利用Angular为我们提供的服务人员。对我来说，坏消息是我还使用了firebase相关的服务工作者，在v.3中，我只是将它们组合在一起作为Ionic 3 / Angular 5，而不像Angular 7没有隐藏应用程序的服务工作者(Angular 6+在构建时从JSON配置中生成服务工作者。)现在有了v.4，我不得不挖一点，找到一种方法来结合服务工作者。谢天谢地，这篇文章中有一个方法(见题为“休斯顿，我们有一个问题”的部分)。</p><h2 id="6bfa" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated"><strong class="ak">迁移皮棉工具</strong></h2><p id="3e2a" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">有离子的指南推荐的<a class="ae lr" href="https://github.com/ionic-team/v4-migration-tslint" rel="noopener ugc nofollow" target="_blank"> lint工具</a>。我用过它，但是老实说(也许只是我)它并不值得。在我自己修复了一些模板之后，我已经知道我需要处理什么问题了。但是在迁移后运行一次可能是个好主意。</p><h2 id="2664" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated"><strong class="ak">“离子发球”现为“伽发球”</strong></h2><p id="f017" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">由于我想使用我的iOS设备测试Ionic 4代码，我自然希望通过访问192.168.0.9:8100(我的本地PC地址)来查看我的PWA，这是我在v.3中习惯做的事情(因为Ionic 3运行一个简单的web服务器作为ionic serve的一部分)。有了ng serve，就不再有这么简单的网络服务器了，你需要自己安排。我发现“firebase serve”(firebase toolkit CLI)如果指向你的项目中的“www”库，对我来说正好可以。</p><h2 id="d0c4" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated"><strong class="ak">自定义脚本</strong></h2><p id="1441" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我曾经在每个产品标志构建之前运行定制脚本，这会使应用程序版本跨越多个文件，所以我担心会对我的旧流程进行额外的返工。但实际上，这里有nice，而且在我看来更干净的<a class="ae lr" href="https://ionicframework.com/docs/cli/configuration" rel="noopener ugc nofollow" target="_blank">配置方法</a>。我用它复制粘贴了我的脚本——它们没有问题，所以我跳过了安装web-pack。</p><h2 id="6af8" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated"><strong class="ak">角度展开模式和变化检测</strong></h2><p id="ebe7" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">作为一个业余开发人员，我意识到太晚了(更新到Angular v.7之后)我没有使用Angular开发模式(使用了<code class="fe oc od oe of b">prodMode</code>)并且发现了相当多的类似<em class="nr">表达式改变之后的错误点。</em>我不得不花一些时间阅读<a class="ae lr" href="https://blog.angularindepth.com/everything-you-need-to-know-about-the-expressionchangedafterithasbeencheckederror-error-e3fd9ce7dbb4" rel="noopener ugc nofollow" target="_blank">这篇文章</a>(总之是一次有益的学习经历)来最终解决这些问题。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="5714" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，我想这就是我想为这项事业所做的一切。总的来说，我对这次迁移的结果非常满意。我明确建议更新宜早不宜迟，因为一旦更多的变化(在Angular中，像rxjs这样的依赖关系)堆积起来，它实际上可能会变得更加痛苦。</p><p id="5c49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">干杯，感谢阅读！</p></div></div>    
</body>
</html>