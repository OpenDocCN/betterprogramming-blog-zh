<html>
<head>
<title>Closures, Currying, and Cool Abstractions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">闭包、奉承和酷的抽象</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/closures-currying-and-cool-abstractions-89221e565eb0?source=collection_archive---------19-----------------------#2020-03-30">https://betterprogramming.pub/closures-currying-and-cool-abstractions-89221e565eb0?source=collection_archive---------19-----------------------#2020-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1349" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JavaScript中的函数式编程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d3caa500e07ced68b936b4a27fbb3350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B8-hVJ2pvzRLm3_t"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丘特尔斯纳</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="0f99" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这篇文章最初发表在<a class="ae ky" href="https://leandrotk.github.io/tk/2020/03/closure-currying-and-cool-abstractions/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="mc"> TK的博客</em> </a>。</p><p id="def6" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在本文中，我们将讨论闭包、curried函数，并利用这些概念来构建很酷的抽象。我想展示每个概念背后的想法，但也想通过例子和重构代码使它变得非常实用，从而使它更有趣。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3cab" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">关闭</h1><p id="07f5" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">闭包是JavaScript中的一个常见话题，我们将从它们开始。正如MDN web文档所定义的:</p><blockquote class="na"><p id="978d" class="nb nc it bd nd ne nf ng nh ni nj mb dk translated">一个闭包是一个函数的组合，这个函数被捆绑(封装)在一起，并引用它周围的状态(词法环境)</p></blockquote><p id="9bfd" class="pw-post-body-paragraph lg lh it li b lj nl ju ll lm nm jx lo lp nn lr ls lt no lv lw lx np lz ma mb im bi translated">基本上，每次创建一个函数，都会创建一个闭包。它提供对所有状态(变量、常数、函数等)的访问。)并被称为<code class="fe nq nr ns nt b">lexical environment</code>。</p><p id="fe6b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们看一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="429c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这是什么？</p><ul class=""><li id="5d5f" class="nw nx it li b lj lk lm ln lp ny lt nz lx oa mb ob oc od oe bi translated">我们的主要功能叫做<code class="fe nq nr ns nt b">makeFunction</code>。</li><li id="9d6c" class="nw nx it li b lj of lm og lp oh lt oi lx oj mb ob oc od oe bi translated">一个名为<code class="fe nq nr ns nt b">name</code>的常量被赋予一个字符串<code class="fe nq nr ns nt b">'TK'</code>。</li><li id="ae72" class="nw nx it li b lj of lm og lp oh lt oi lx oj mb ob oc od oe bi translated"><code class="fe nq nr ns nt b">displayName</code>函数的定义(它只记录了<code class="fe nq nr ns nt b">name</code>常数)。</li><li id="8775" class="nw nx it li b lj of lm og lp oh lt oi lx oj mb ob oc od oe bi translated">最后<code class="fe nq nr ns nt b">makeFunction</code>返回<code class="fe nq nr ns nt b">displayName</code>函数。</li></ul><p id="6715" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这只是一个函数的定义。当我们调用<code class="fe nq nr ns nt b">makeFunction</code>时，它将在其中创建所有东西:在本例中是常量和函数。</p><p id="096d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">正如我们所知，当<code class="fe nq nr ns nt b">displayName</code>函数被创建时，闭包也被创建，它使函数意识到环境——在本例中是<code class="fe nq nr ns nt b">name</code>常量。这就是为什么我们可以不破坏任何东西。该函数知道词法环境。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="f5dd" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">太好了！果然有效！<code class="fe nq nr ns nt b">makeFunction</code>的返回是我们存储在<code class="fe nq nr ns nt b">myFunction</code>常量中的一个函数，稍后调用，它显示<code class="fe nq nr ns nt b">TK</code>。</p><p id="8ccd" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们也可以让它像箭头一样工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="6d92" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">但是如果我们想传递名称并显示它呢？一个参数！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="5b6a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在我们可以玩这个名字了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="3d54" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">创建的函数不仅知道常量/变量，还知道其他函数。</p><p id="fd48" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这也是可行的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ec6f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">返回的函数知道<code class="fe nq nr ns nt b">display</code>函数，并且能够调用它。</p><p id="1513" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">一种强大的技术是使用闭包来构建“私有”函数和变量。</p><p id="7374" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">几个月前，我正在学习数据结构(再次！)并想实现每一个。但是我总是使用面向对象的方法。作为一个函数式编程爱好者，我希望按照FP原则(纯函数、不变性、引用透明性等)构建所有的数据结构。).</p><p id="f6c3" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我学习的第一个数据结构是堆栈。这很简单。主要的API是:</p><ul class=""><li id="a558" class="nw nx it li b lj lk lm ln lp ny lt nz lx oa mb ob oc od oe bi translated"><code class="fe nq nr ns nt b">push</code>:将一个项目添加到堆栈的第一个位置。</li><li id="9880" class="nw nx it li b lj of lm og lp oh lt oi lx oj mb ob oc od oe bi translated"><code class="fe nq nr ns nt b">pop</code>:从堆栈中移除第一个项目。</li><li id="f576" class="nw nx it li b lj of lm og lp oh lt oi lx oj mb ob oc od oe bi translated"><code class="fe nq nr ns nt b">peek</code>:从堆栈中获取第一个项目。</li><li id="4513" class="nw nx it li b lj of lm og lp oh lt oi lx oj mb ob oc od oe bi translated"><code class="fe nq nr ns nt b">isEmpty</code>:验证堆栈是否为空。</li><li id="6ddc" class="nw nx it li b lj of lm og lp oh lt oi lx oj mb ob oc od oe bi translated"><code class="fe nq nr ns nt b">size</code>:获取堆叠的物品数量。</li></ul><p id="48cb" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们可以清楚地为每个“方法”创建一个简单的函数，并将堆栈数据传递给它。它使用/转换数据并返回数据。</p><p id="a4c1" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">但是我们也可以创建只公开API方法的私有堆栈数据。我们开始吧！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="1c83" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">因为我们在<code class="fe nq nr ns nt b">buildStack</code>函数中创建了<code class="fe nq nr ns nt b">items</code>堆栈数据，所以它是“私有的”它只能在函数中访问。在这种情况下，只有<code class="fe nq nr ns nt b">push</code>、<code class="fe nq nr ns nt b">pop</code>等。可能接触到数据。这就是我们要找的。</p><p id="ed94" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们如何使用它？像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="36fa" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">所以当栈被创建时，所有的函数都知道<code class="fe nq nr ns nt b">items</code>数据。但是在函数之外，我们无法访问这些数据。这是隐私。我们只是通过使用堆栈内置API来修改数据。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ee78" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Currying</h1><p id="b8be" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank"> Currying是将一个有多个参数的函数转换成一系列只有一个参数的函数的过程</a>。</p><p id="77cf" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">假设你有一个有多个参数的函数:<code class="fe nq nr ns nt b">f(a, b, c)</code>。使用currying，我们实现了返回函数<code class="fe nq nr ns nt b">h(c)</code>的函数<code class="fe nq nr ns nt b">f(a)</code>。</p><p id="d4dc" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">基本上，<code class="fe nq nr ns nt b">f(a, b, c)</code>——&gt;——T16。</p><p id="7943" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们建立一个简单的例子:将两个数相加。但首先，不要阿谀奉承！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="4969" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">太好了！超级简单！这里我们有一个带有两个参数的函数。要将它转换成一个curried函数，我们需要一个接收<code class="fe nq nr ns nt b">x</code>并返回一个接收<code class="fe nq nr ns nt b">y</code>并返回两个值之和的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="b113" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们可以将这个<code class="fe nq nr ns nt b">addY</code>重构为一个匿名箭头函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="c044" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">或者通过构建一行箭头函数来简化它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="e707" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这三个不同的curried函数具有相同的行为:它们构建了一个只有一个参数的函数序列。</p><p id="747b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们如何使用它？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="638b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">起初，它可能看起来有点奇怪，但它背后有一个逻辑。<code class="fe nq nr ns nt b">add(10)</code>返回函数。我们用<code class="fe nq nr ns nt b">20</code>值调用这个函数。</p><p id="10f4" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这与以下内容相同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="0f1a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这很有趣。我们可以通过调用第一个函数来生成专门的函数。假设我们想要一个<code class="fe nq nr ns nt b">increment</code>函数。我们可以通过将<code class="fe nq nr ns nt b">1</code>作为值传递来从我们的<code class="fe nq nr ns nt b">add</code>函数中生成它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="4950" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当我实现<a class="ae ky" href="https://github.com/leandrotk/lazy-cypress" rel="noopener ugc nofollow" target="_blank"> Lazy Cypress </a>时，一个npm库记录表单页面中的用户行为并生成Cypress测试代码，我想构建一个函数来生成字符串<code class="fe nq nr ns nt b">input[data-testid="123"]</code>。所以这里我们有元素(<code class="fe nq nr ns nt b">input</code>)、属性(<code class="fe nq nr ns nt b">data-testid</code>)和值(<code class="fe nq nr ns nt b">123</code>)。在JavaScript中插入这个字符串将会是这样的:<code class="fe nq nr ns nt b">${element}[${attribute}="${value}"]</code>。</p><p id="1525" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">想到的第一个实现是接收这三个值作为参数，并返回上面的插值字符串。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="779e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这很棒。我实现了我所期待的。但同时，我想构建一个更习惯的函数。我可以写类似于"<em class="mc">得到一个属性为Y，值为z的元素X .</em>"那么如果我们把这个短语分成三个步骤呢？</p><ul class=""><li id="4fde" class="nw nx it li b lj lk lm ln lp ny lt nz lx oa mb ob oc od oe bi translated"><em class="mc">“获取一个元素X</em>”:<code class="fe nq nr ns nt b">get(x)</code></li><li id="5d1f" class="nw nx it li b lj of lm og lp oh lt oi lx oj mb ob oc od oe bi translated"><em class="mc">“带属性Y</em>”:<code class="fe nq nr ns nt b">withAttribute(y)</code></li><li id="78bf" class="nw nx it li b lj of lm og lp oh lt oi lx oj mb ob oc od oe bi translated"><em class="mc">和Z值</em>:<code class="fe nq nr ns nt b">andValue(z)</code></li></ul><p id="4d49" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们可以利用currying概念将<code class="fe nq nr ns nt b">buildSelector(x, y, z)</code>转化为<code class="fe nq nr ns nt b">get(x)</code><code class="fe nq nr ns nt b">withAttribute(y)</code><code class="fe nq nr ns nt b">andValue(z)</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="afca" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这里我们使用一个不同的想法:用一个函数作为键值返回一个对象。这样就可以实现这个语法:<code class="fe nq nr ns nt b">get(x).withAttribute(y).andValue(z)</code>。</p><p id="cb23" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">对于每个返回的对象，我们有下一个函数和参数。</p><p id="a1b6" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">重构时间！删除<code class="fe nq nr ns nt b">return</code>语句:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="34f6" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我觉得它看起来更漂亮。我们是这样使用它的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="c631" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><code class="fe nq nr ns nt b">andValue</code>函数知道<code class="fe nq nr ns nt b">element</code>和<code class="fe nq nr ns nt b">attribute</code>的值，因为它知道词法环境，就像我们之前讨论闭包一样。</p><p id="3b2f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们也可以使用“部分currying”来实现函数仅将第一个参数与其余参数分开作为示例。</p><p id="bb6e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">做了很长时间的web开发，我通常使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" rel="noopener ugc nofollow" target="_blank">事件监听器web API </a>。它是这样使用的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8b9d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我想创建一个抽象来构建专门的事件侦听器，并通过传递元素和回调处理程序来使用它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="addc" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这样，我可以创建不同的专用事件侦听器，并将它们用作函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="2a0c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">有了这些概念，我可以使用JavaScript语法创建一个SQL查询。我想用SQL查询JSON数据，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="d14c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">所以我构建了一个简单的引擎来处理这个实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="81d5" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">有了这个实现，我们可以用JSON数据启动引擎:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="4155" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">并将其用作SQL查询:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7482" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="a80f" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">今天到此为止。我们可以继续展示很多不同的抽象的例子，但是我会让你玩这些概念。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="40c4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">资源</h1><ul class=""><li id="9bff" class="nw nx it li b lj mv lm mw lp ok lt ol lx om mb ob oc od oe bi translated"><a class="ae ky" href="https://github.com/tk-notes/blog/tree/master/closures-currying-and-cool-abstractions" rel="noopener ugc nofollow" target="_blank">文章的源代码</a></li><li id="5c0b" class="nw nx it li b lj of lm og lp oh lt oi lx oj mb ob oc od oe bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">闭包| MDN Web文档</a></li><li id="64d2" class="nw nx it li b lj of lm og lp oh lt oi lx oj mb ob oc od oe bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=iZLP4qOwY8I" rel="noopener ugc nofollow" target="_blank"> Currying | Fun Fun函数</a></li></ul></div></div>    
</body>
</html>