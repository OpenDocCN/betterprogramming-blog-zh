<html>
<head>
<title>Using in-memory-db With NestJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过NestJS使用内存数据库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-in-memory-db-with-nestjs-803a91a8eb11?source=collection_archive---------8-----------------------#2020-01-13">https://betterprogramming.pub/using-in-memory-db-with-nestjs-803a91a8eb11?source=collection_archive---------8-----------------------#2020-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1bb2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在这篇文章中，我们将看到如何使用<code class="fe kf kg kh ki b">in-memory-db</code>来执行CRUD操作</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/7cf9e0edba27d336d9bcbce2e39b71bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oTbTuBA4_RtKoXCsZ-ybKQ.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">NestJS标志</p></figure><p id="767b" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们看看为什么我们应该以及如何使用内存数据库，你可以在GitHub 上访问源代码<a class="ae lv" href="https://github.com/nestjs-addons/in-memory-db" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="192b" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">为什么</h1><p id="372d" class="pw-post-body-paragraph kz la iq lb b lc mv jr le lf mw ju lh li mx lk ll lm my lo lp lq mz ls lt lu ij bi translated">下面是两个可能需要内存数据库的场景。</p><ul class=""><li id="d251" class="na nb iq lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">POC(概念验证):当你需要为一个即将到来的项目创建一个快速的POC，并且你想用<a class="ae lv" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>创建一个API，以便与UI集成。</li><li id="bbd7" class="na nb iq lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">模拟:您需要编写测试用例，并且想要模拟数据库操作。这是使用内存数据库的完美用例。</li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="1432" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated"><strong class="ak">如何</strong></h1><p id="1a82" class="pw-post-body-paragraph kz la iq lb b lc mv jr le lf mw ju lh li mx lk ll lm my lo lp lq mz ls lt lu ij bi translated">按照下面的步骤创建一个带有内存数据库的API。</p><ul class=""><li id="6650" class="na nb iq lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">运行下面的命令来创建一个NestJS项目。</li></ul><pre class="kk kl km kn gt no ki np nq aw nr bi"><span id="4942" class="ns me iq ki b gy nt nu l nv nw">nest new in-memory-demo</span></pre><ul class=""><li id="c899" class="na nb iq lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">一旦应用程序准备就绪，运行下面的命令来安装<code class="fe kf kg kh ki b">in-memory-db</code>支持。</li></ul><pre class="kk kl km kn gt no ki np nq aw nr bi"><span id="58d7" class="ns me iq ki b gy nt nu l nv nw">nest add @nestjs-addons/in-memory-db</span></pre><ul class=""><li id="18c5" class="na nb iq lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">我们将创建一个具有CRUD操作的<code class="fe kf kg kh ki b">ProductController</code>,因此我们将为其添加一个模块和控制器。</li></ul><pre class="kk kl km kn gt no ki np nq aw nr bi"><span id="7f86" class="ns me iq ki b gy nt nu l nv nw">nest generate module product<br/>nest generate controller product</span></pre><ul class=""><li id="d8f0" class="na nb iq lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">接下来，我们需要一个实体。在<code class="fe kf kg kh ki b">product</code>文件夹中创建一个新文件夹<code class="fe kf kg kh ki b">entities</code>。</li><li id="94a2" class="na nb iq lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">创建一个新文件<code class="fe kf kg kh ki b">product.entity.ts</code>并添加下面的代码。</li></ul><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">产品.实体. ts</p></figure><ul class=""><li id="33d1" class="na nb iq lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">在上面的代码中，<code class="fe kf kg kh ki b">InMemoryDBEntity</code>向任何扩展该接口的接口添加了一个<code class="fe kf kg kh ki b">id</code>属性。</li><li id="31b3" class="na nb iq lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">接下来，我们需要向控制器和模块添加一些代码。有两种方法可以执行CRUD操作，通过提供自己的实现或使用内置的<code class="fe kf kg kh ki b">InMemoryDBEntityAsyncController</code>或<code class="fe kf kg kh ki b">InMemoryDBEntityController</code>。</li></ul><p id="f834" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们将看到这两种方法，让我们看看如何实现我们自己的方法。</p><ul class=""><li id="a362" class="na nb iq lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">打开<code class="fe kf kg kh ki b">app.controller.ts</code>并添加下面的代码，这个文件已经存在。</li></ul><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">应用程序控制器. ts</p></figure><p id="60b4" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">您可以在上面的代码中看到，我们添加了下面的代码来提供<code class="fe kf kg kh ki b">Post</code>方法。</p><pre class="kk kl km kn gt no ki np nq aw nr bi"><span id="5e47" class="ns me iq ki b gy nt nu l nv nw">@Post()<br/>AddProduct(@Body() product: ProductEntity): ProductEntity {<br/>    return this.productService.create(product);<br/>}</span></pre><ul class=""><li id="fd31" class="na nb iq lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><code class="fe kf kg kh ki b">ProductService</code>由<code class="fe kf kg kh ki b">InMemoryDBService</code>实例化而来。它附带了许多执行CRUD操作的内置方法，无需编写一行代码。该服务包含两种类型的方法，<code class="fe kf kg kh ki b">sync</code>和<code class="fe kf kg kh ki b">async</code>，它们返回一个<code class="fe kf kg kh ki b">observable</code>。</li><li id="308a" class="na nb iq lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">在上面的代码中，需要下面突出显示的代码来创建一个服务实例，该实例接受实体<code class="fe kf kg kh ki b">ProductEntity</code>并提供所有方法。</li></ul><pre class="kk kl km kn gt no ki np nq aw nr bi"><span id="e009" class="ns me iq ki b gy nt nu l nv nw">constructor(private readonly appService: AppService,                           <strong class="ki ir">private productService: InMemoryDBService&lt;ProductEntity&gt;</strong>) {}</span></pre><p id="b6d0" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们将要实施的方法是:</p><ul class=""><li id="e16a" class="na nb iq lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><code class="fe kf kg kh ki b">getAll()</code>:检索所有记录。</li><li id="64aa" class="na nb iq lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe kf kg kh ki b">create()</code>:插入新记录。使用<code class="fe kf kg kh ki b">createMany</code>插入多条记录。</li><li id="7ae3" class="na nb iq lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe kf kg kh ki b">update()</code>:更新请求体中提供的<code class="fe kf kg kh ki b">id</code>的记录。</li><li id="311d" class="na nb iq lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe kf kg kh ki b">delete()</code>:删除提供的<code class="fe kf kg kh ki b">id</code>的记录。</li><li id="82ea" class="na nb iq lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe kf kg kh ki b">query()</code>:从增加的记录中查询数据。</li></ul><p id="7f47" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">下面是完整的代码:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">应用程序模块</p></figure><p id="b890" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在，在大多数情况下，你只是想提供CRUD操作，如果我们一直添加相同的代码，这将导致代码重复，软件包会记住这一点。</p><p id="3667" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">它有<code class="fe kf kg kh ki b">InMemoryDBEntityAsyncController</code>或<code class="fe kf kg kh ki b">InMemoryDBEntityController</code>来实现同样的功能。</p><ul class=""><li id="f41e" class="na nb iq lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">要使用上面的接口实现CRUD操作，只需添加下面几行代码。</li></ul><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">产品.控制器. ts</p></figure><p id="6655" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">默认情况下，<code class="fe kf kg kh ki b">InMemoryDBEntityAsyncController</code>提供了以下方法的实现。</p><ul class=""><li id="bf23" class="na nb iq lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><code class="fe kf kg kh ki b">create</code></li><li id="1c4b" class="na nb iq lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe kf kg kh ki b">update</code></li><li id="d8fc" class="na nb iq lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe kf kg kh ki b">updateMany</code></li><li id="afb4" class="na nb iq lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe kf kg kh ki b">delete</code></li><li id="2e2f" class="na nb iq lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe kf kg kh ki b">deleteMany</code></li><li id="5be3" class="na nb iq lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe kf kg kh ki b">get</code></li><li id="7c8e" class="na nb iq lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe kf kg kh ki b">getMany</code></li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="2260" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">对于功能模块</h1><p id="31f1" class="pw-post-body-paragraph kz la iq lb b lc mv jr le lf mw ju lh li mx lk ll lm my lo lp lq mz ls lt lu ij bi translated">如果您有不同的功能模块，您需要使用<code class="fe kf kg kh ki b">forFeature</code>方法注册<code class="fe kf kg kh ki b">InMemoryDBModule</code>。下面的代码举例说明了如何在<code class="fe kf kg kh ki b">ProductModule</code>中使用它。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">产品.模块. ts</p></figure><p id="b7e1" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">您也可以使用<code class="fe kf kg kh ki b">InMemoryDBService</code>的特定功能实例。您需要在构造函数中使用下面的代码。</p><pre class="kk kl km kn gt no ki np nq aw nr bi"><span id="ad54" class="ns me iq ki b gy nt nu l nv nw">constructor(@InjectInMemoryDBService('product') private productService: InMemoryDBService&lt;ProductEntity&gt;)</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="111d" class="ns me iq bd mf nz oa dn mj ob oc dp mn li od oe mp lm of og mr lq oh oi mt oj bi translated">播种试验数据</h2><p id="94b3" class="pw-post-body-paragraph kz la iq lb b lc mv jr le lf mw ju lh li mx lk ll lm my lo lp lq mz ls lt lu ij bi translated">对于测试，您可能需要创建一些虚拟数据，我们不希望您手动创建所有记录，这是您可以使用<code class="fe kf kg kh ki b">seed</code>方法创建虚拟数据的地方。</p><ul class=""><li id="ee6e" class="na nb iq lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">使用下面的命令创建一个新的模块、控制器和实体。</li></ul><pre class="kk kl km kn gt no ki np nq aw nr bi"><span id="4d54" class="ns me iq ki b gy nt nu l nv nw">nest generate module employee<br/>nest generate controller employee</span></pre><ul class=""><li id="f867" class="na nb iq lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">接下来，在employee文件夹中添加一个新的<code class="fe kf kg kh ki b">entities</code>文件夹，添加一个新的文件<code class="fe kf kg kh ki b">employee.ts</code>并添加下面的代码。</li></ul><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">员工. ts</p></figure><ul class=""><li id="7562" class="na nb iq lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">接下来，为员工模块注册<code class="fe kf kg kh ki b">InMemoryDBModule</code>，在<code class="fe kf kg kh ki b">employee.module.ts</code>中添加以下代码</li></ul><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">雇员.模块. ts</p></figure><ul class=""><li id="ace7" class="na nb iq lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">最后一步是使用<code class="fe kf kg kh ki b">seed</code>方法创建10个虚拟记录。</li></ul><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">员工.控制者. ts</p></figure><p id="b98a" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">接下来，通过访问<a class="ae lv" href="http://localhost:3000/employee/seed" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/employee/seed</a>来触发seed方法，这将创建10条记录。</p><p id="d650" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">你可以更新计数，在下面的方法中创建更多的记录。</p><pre class="kk kl km kn gt no ki np nq aw nr bi"><span id="4669" class="ns me iq ki b gy nt nu l nv nw">this.employeeService.seed(recordFactory, <strong class="ki ir">10</strong>);</span></pre><p id="14fb" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">您可以使用<code class="fe kf kg kh ki b">postman</code>来测试API。在下一篇文章中，我们将看到如何添加swagger功能来创建用于测试的测试页面。</p><p id="9edd" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">您可以在以下位置参考本演示的代码:</p><div class="ok ol gp gr om on"><a href="https://github.com/santoshyadav198613/nest-in-memory-demo" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd ir gy z fp os fr fs ot fu fw ip bi translated">santoshyadav 198613/内存嵌套演示</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">一个渐进式Node.js框架，用于构建高效且可伸缩的服务器端应用程序，其灵感主要来自…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">github.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb kt on"/></div></div></a></div><h1 id="5514" class="md me iq bd mf mg pc mi mj mk pd mm mn jw pe jx mp jz pf ka mr kc pg kd mt mu bi translated">结论</h1><p id="3436" class="pw-post-body-paragraph kz la iq lb b lc mv jr le lf mw ju lh li mx lk ll lm my lo lp lq mz ls lt lu ij bi translated"><code class="fe kf kg kh ki b">in-memory-db</code>在其他框架中广泛使用，如。Net、Java和Angular来创建POC或创建模拟后端。</p><p id="f250" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这个包为NestJS生态系统带来了相同的功能，并且您可以轻松地将它与现有的NestJS项目相结合来创建POC。</p><p id="8f3e" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">感谢<a class="ph pi ep" href="https://medium.com/u/9af1d23366c8?source=post_page-----803a91a8eb11--------------------------------" rel="noopener" target="_blank">韦斯·格里姆斯</a>和团队创造了这个包。</p></div></div>    
</body>
</html>