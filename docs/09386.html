<html>
<head>
<title>Automatic Keyboard Handling With UIKit And Combine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过UIKit和联合收割机自动处理键盘</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/automatic-keyboard-handling-with-uikit-and-combine-28999095f9e2?source=collection_archive---------1-----------------------#2021-08-18">https://betterprogramming.pub/automatic-keyboard-handling-with-uikit-and-combine-28999095f9e2?source=collection_archive---------1-----------------------#2021-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="82eb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用“自动布局”和“合并”在任何视图中自动处理键盘事件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9bc21e3520d2a64d697f494463603aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XOUnxN9zzOVjgGCb"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@willianjusten?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">威利安·贾斯滕·德·瓦斯康塞勒斯</a>拍摄</p></figure><p id="ea1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次屏幕上出现输入信息时，操作键盘都是iOS开发者必须完成的一项烦人任务。这也是一个平台应该免费提供给我们的东西。</p><p id="6c04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一天结束时，系统显示并隐藏键盘，并且窗口和键盘的尺寸和框架是系统已知的。</p><p id="4094" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们仍然需要手动聆听这些事件并做出相应的反应。</p><p id="3ca8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我想展示一个解决方案，它将为您要实现的每个视图提供开箱即用的解决方案，扩展一个与<code class="fe lv lw lx ly b">UIView</code>不同的基类会增加一个成本。</p><p id="f1f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>凭借swift 5.5和iOS 15，苹果推出了能够自动操作键盘的工具。从这些版本开始，每个视图都有一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uiview/3752221-keyboardlayoutguide/" rel="noopener ugc nofollow" target="_blank">keyboardLayoutGuide</a></code>，它会随着键盘的改变而更新。在不久的将来，我们不太可能编写针对iOS 15+的应用程序，所以这篇文章仍然可以在一段时间内提供帮助。</p><h1 id="cffd" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">理念</h1><p id="fba5" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们希望实现一个基类，为将来的所有子类提供一个新的<strong class="lb iu">布局指南</strong>。当键盘出现或关闭时，本布局指南会自动更新。</p><p id="0b85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望将这些更改设置为动画，以便为我们类的用户提供良好的外观和感觉。</p><p id="af31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拥有superview后，我们应该使用此新视图更改所有具有输入的视图的父视图，以使用新的布局指南。</p><p id="857c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望实现的最终结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/afb5cd4ab45542861cd34bec97c3d369.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/1*NYK4D48dum7vpuFjfVZDQg.gif"/></div></figure><h1 id="e021" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">监管</h1><p id="9516" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们在监管中需要的关键要素如下:</p><ol class=""><li id="979a" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">新的布局指南，可由子类使用</li><li id="5d8b" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">物件，可包含动画资讯</li><li id="e4f8" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">keyboardWillHide</code> / <code class="fe lv lw lx ly b">keyboardWillShow</code>事件的倾听者</li></ol><p id="30c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们就可以出发了。</p><h2 id="5b85" class="nl ma it bd mb nm nn dn mf no np dp mj li nq nr ml lm ns nt mn lq nu nv mp nw bi translated">布局指南</h2><p id="5599" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">让我们从创建<strong class="lb iu">布局指南</strong>开始，我们需要将其公开给子类。</p><p id="5e4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要做的第一件事就是定义基类并添加<code class="fe lv lw lx ly b">LayoutGuide</code>。我们可以将<strong class="lb iu">布局参考线</strong>视为占位符视图。来自<a class="ae ky" href="https://developer.apple.com/documentation/uikit/uilayoutguide" rel="noopener ugc nofollow" target="_blank">文件</a>:</p><blockquote class="nx ny nz"><p id="ae91" class="kz la oa lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">"使用版式参考线替换您可能创建的占位符视图，以表示用户界面中的视图间空间或封装。传统上，有许多需要占位符视图的自动布局技术。占位符视图是一个空视图，它本身没有任何可视元素，仅用于在视图层次结构中定义一个矩形区域。</p></blockquote><p id="7cfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这表明我们还需要将一些<strong class="lb iu"> AutoLayout </strong>约束应用到我们的新指南Layout中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="bb5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个代码片段中，我们定义了一个新的<code class="fe lv lw lx ly b">open</code>类，其他视图可以继承它。这个类定义了一个新的<strong class="lb iu">布局指南</strong>(在第4行)，并且在<code class="fe lv lw lx ly b">init</code>中，它将<strong class="lb iu">布局指南</strong>添加到视图中。你可以把这个步骤看作是我们每次想要在视图中添加子视图时使用的<code class="fe lv lw lx ly b">addSubview</code>方法的等价物。</p><p id="b0a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们使用<strong class="lb iu">自动布局</strong>约束对导轨进行布局。创建视图时会添加引导线，因此键盘应该关闭:引导线的高度为零。</p><h2 id="d821" class="nl ma it bd mb nm nn dn mf no np dp mj li nq nr ml lm ns nt mn lq nu nv mp nw bi translated">AnimationInfo对象</h2><p id="8ea7" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">当系统触发与键盘相关的通知时，它还会在它们的<code class="fe lv lw lx ly b">UseInfo</code>属性中添加一些其他信息。添加的信息可用于创建平滑的动画，该动画在键盘出现和消失时跟随键盘的移动。</p><p id="086e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用它们，我们需要在触发通知时提取一些信息。我们希望只提取一次该信息，并且希望对两个事件重用相同的对象结构:当键盘显示时和当它隐藏时。</p><p id="b791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">信息容器具有以下形状:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="edf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们添加了<code class="fe lv lw lx ly b">NotificationKind</code>枚举来跟踪我们正在捕获的通知类型。属性包含键盘的最后一帧。<code class="fe lv lw lx ly b">duration</code>表示隐藏/显示键盘需要多长时间，而<code class="fe lv lw lx ly b">curve</code>属性定义了我们需要使用的动画类型。</p><p id="9c00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简化对象的创建，我们想要添加一个定制的初始化器，它能够从<code class="fe lv lw lx ly b">UserInfo</code>字典中提取信息。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="58b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个失败的初始化器:如果没有<code class="fe lv lw lx ly b">frame</code>，我们就失败了，我们不能使用动画信息。否则，我们会尝试从通知中提取所有其他数据。如果这是不可能的，我们使用一些明智的默认值。</p><p id="db39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们添加一些属性来提取数据并将其转换为正确的类型，以简化后续步骤:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="3d84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最有趣的属性是第一个:<code class="fe lv lw lx ly b">keyboardHeight</code>是在键盘出现时从<code class="fe lv lw lx ly b">frame</code>中提取出来的，但是当键盘消失时我们将其设置为零。对于那个事件，<code class="fe lv lw lx ly b">UserInfo</code>字典中的<code class="fe lv lw lx ly b">keyboardFrame</code>属性假设了一些不可思议的值，这些值没有提供预期的结果。</p><p id="f35c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他属性将动画曲线从一个域(T4)映射到另一个域(T5)</p><h2 id="45e9" class="nl ma it bd mb nm nn dn mf no np dp mj li nq nr ml lm ns nt mn lq nu nv mp nw bi translated">倾听这些事件</h2><p id="6fc7" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">最后，我们需要监听键盘事件。<code class="fe lv lw lx ly b">NotificationCenter</code>是触发事件的对象，我们需要为这些事件添加一些订阅者。</p><p id="a2f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想用<strong class="lb iu">结合</strong>来监听那些事件。为此，我们需要:</p><ol class=""><li id="5325" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">给我们的视图添加一组<code class="fe lv lw lx ly b">AnyCancellable</code></li><li id="3a38" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">将订阅添加到对象中</li><li id="839b" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">处理订阅</li></ol><p id="07a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第1步和第2步可以放在一起看，代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="6fb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个相当标准的combine代码:我们定义了可取消集合(第3行)。然后，在init结束时，我们调用一个方法来设置订阅:在<code class="fe lv lw lx ly b">setupKeyboardBinding</code>方法中，我们实际上订阅了发布者。</p><p id="a031" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个订阅都调用相同的<code class="fe lv lw lx ly b">handleKeyboardUpdate</code>方法:它们传入通知和我们正在观察的事件类型。</p><p id="426c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:通过将<code class="fe lv lw lx ly b">notification.name</code>与我们感兴趣的两个通知进行比较，我们可以从通知本身中提取出<code class="fe lv lw lx ly b">notificationKind</code>。然而，我们已经知道了通知的种类，所以没有必要执行这个额外的计算。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="22bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在处理键盘通知时，我们首先尝试创建<code class="fe lv lw lx ly b">AnimationInfo</code>值。如果我们失败了，我们就什么都不做。如果我们成功了，我们必须做两件事:</p><ol class=""><li id="d8ef" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">更新定义键盘高度的约束。</li><li id="5de1" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">将变化动画化。</li></ol><p id="0bf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要执行步骤1，我们需要访问<code class="fe lv lw lx ly b">layoutGuide</code>并搜索影响高度的约束(第12行到第16行)。然后，我们将从<code class="fe lv lw lx ly b">AnimationInfo</code>值中提取的<code class="fe lv lw lx ly b">constant</code>值更改为新的高度。</p><p id="91f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了动画化这些变化，我们需要首先展示当前的状态(使用<code class="fe lv lw lx ly b">self.setNeedsLayout</code>方法)。然后我们使用从<code class="fe lv lw lx ly b">AnimationInfo</code>值中提取的<code class="fe lv lw lx ly b">duration</code>和<code class="fe lv lw lx ly b">animationOptions</code>调用<code class="fe lv lw lx ly b">UIView.animate</code>方法。动画闭包是对<code class="fe lv lw lx ly b">self.layoutIfNeeded</code>方法的一次调用。</p><h1 id="bd9d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">如何使用它</h1><p id="f053" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们的全新组件提供了新的<strong class="lb iu">布局指南。</strong>当键盘框架改变时，本指南会自动更新。</p><p id="d87e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用方法非常简单:</p><ol class=""><li id="2a2f" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">让你的视图成为<code class="fe lv lw lx ly b">ViewWithKeyboard</code>的子类。</li><li id="f6e4" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">将<code class="fe lv lw lx ly b">keyboardLayoutGuide</code>用作任何其他布局导轨。</li></ol><p id="17e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了举例说明，下面是我在上面的视频中展示的视图的布局代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="f8e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个代码片段中，我们创建了一个新的<code class="fe lv lw lx ly b">View</code>，扩展了<code class="fe lv lw lx ly b">ViewWithKeyboard</code>基类。</p><p id="47ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们添加了几个子视图，并将按钮与取消键盘的动作联系起来。</p><p id="eec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">setupConstraints</code>中，我们使用<strong class="lb iu">自动布局</strong>来布局视图。这里有两条有趣的线:</p><ol class=""><li id="db45" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated"><code class="fe lv lw lx ly b">enableAutolayout</code>函数(见下面的代码)是为当前视图的所有子视图设置<code class="fe lv lw lx ly b">translatesAutoresizingMaskIntoConstraints</code>为假的函数。</li><li id="8fe1" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">在第25行，我们使用新的<code class="fe lv lw lx ly b">keyboardLayoutGuide</code>。这是如此自然，看起来像任何其他约束！</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="dde6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">enableAutoLayout</code>函数使用Swift反射来检查当前视图的子视图，并关闭所有子视图的<code class="fe lv lw lx ly b">translatesAutoresizingMaskIntoConstraints</code>属性。注意这个函数不是递归的！如果您还需要将子视图的掩码设置为<code class="fe lv lw lx ly b">false</code>，那么更新该方法应该相当容易。</p><p id="0481" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:如果键盘在模拟器中表现怪异，请确保mac的硬件键盘与模拟器断开连接。要断开它，您可以使用工具栏中的模拟器<strong class="lb iu"> I/O </strong>菜单，或者您可以使用<code class="fe lv lw lx ly b"><strong class="lb iu"><em class="oa">⇧</em></strong><em class="oa">+⌘+K</em></code>快捷方式。</p><h1 id="da59" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="a581" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在今天的文章中，我们探讨了如何实现一个新的布局指南，以及如何在子类中使用它。</p><p id="244c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还探讨了如何使用Combine观察通知以及如何处理它们。</p><p id="35bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们看到了如何为特定视图的所有子视图自动启用AutoLayout约束。</p><p id="0105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该项目的完整代码可在以下链接中找到:</p><ul class=""><li id="e845" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu og nd ne nf bi translated"><a class="ae ky" href="https://gist.github.com/cipolleschi/2d9ef7c5aff6e174576d19e0e7866a76" rel="noopener ugc nofollow" target="_blank">带键盘视图</a></li><li id="986a" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu og nd ne nf bi translated"><a class="ae ky" href="https://gist.github.com/cipolleschi/d94c4e896f7fc5138c263b81ea9de11d" rel="noopener ugc nofollow" target="_blank">使用键盘查看</a></li></ul><p id="59f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想知道当我们需要更新对iOS 15的最低支持时，代码将如何变化，这相当容易。我们只需从代码库中移除<code class="fe lv lw lx ly b">ViewWithKeyboard</code>类，并将继承从<code class="fe lv lw lx ly b">ViewWithKeyboard</code>改回<code class="fe lv lw lx ly b">UIView</code>。</p><p id="6516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果应用程序有大量的用户输入，这最后一步可能会变得很麻烦。另一种方法是保留<code class="fe lv lw lx ly b">ViewWithKeyboard</code>超类，删除类体中的所有代码。我们最终将拥有一个空的<code class="fe lv lw lx ly b">ViewWithKeyboard</code>类，但我们不必改变代码库中的许多继承条款。</p></div></div>    
</body>
</html>