<html>
<head>
<title>How to Manage Anomalies in Saga Pattern for Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何管理微服务Saga模式中的异常</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-manage-anomalies-in-saga-pattern-for-microservices-b3bc893cbe3a?source=collection_archive---------9-----------------------#2022-05-25">https://betterprogramming.pub/how-to-manage-anomalies-in-saga-pattern-for-microservices-b3bc893cbe3a?source=collection_archive---------9-----------------------#2022-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ac1b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">跨不同平台提供一致性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0482d9858d06c8355c6b339cb7a5cbaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A8MWMsQ1-Dx3kYOM"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@euwars?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法尔扎德·纳兹菲</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="66da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Saga是确保跨服务数据一致性的最常见模式。它将一个全局事务分成多个子事务。如果所有子事务操作都成功，则全局事务成功，如果重试后仍有一个子事务失败，则所有执行的子事务都会得到补偿。</p><p id="0256" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的过程简单明了，但是在分布式环境中，可能会出现一些异常。确保Saga交易正常运行并保持数据不一致并不是一件容易的事情。我们将讨论这里可能出现的各种异常以及如何管理它们。</p><p id="d9d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于讨论的目的，我们将Saga中的分支交易的远期交易称为<code class="fe ls lt lu lv b">Action</code>，补偿交易称为<code class="fe ls lt lu lv b">Compensation</code>。</p><h1 id="a177" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">三种异常情况</h1><p id="7abb" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">通常情况下，如果发生回滚，Saga事务中的<code class="fe ls lt lu lv b">Action</code>会在<code class="fe ls lt lu lv b">Compensation</code>之前执行。但是由于网络延迟或进程暂停，可能会先执行<code class="fe ls lt lu lv b">Compensation</code>，然后再执行<code class="fe ls lt lu lv b">Action</code>，或者根本不执行。</p><p id="20ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个场景在分布式事务中引入了两个异常:</p><ol class=""><li id="df1b" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">空补偿:当<code class="fe ls lt lu lv b">Compensation</code>正在执行时，对应的<code class="fe ls lt lu lv b">Action</code>还没有执行，所以<code class="fe ls lt lu lv b">Compensation</code>需要确定<code class="fe ls lt lu lv b">Action</code>还没有执行，忽略业务数据更新，直接返回。</li><li id="ff89" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">挂起动作:当<code class="fe ls lt lu lv b">Action</code>正在执行时，<code class="fe ls lt lu lv b">Compensation</code>已经执行，所以<code class="fe ls lt lu lv b">Action</code>需要确定<code class="fe ls lt lu lv b">Compensation</code>已经执行，忽略业务数据更新，直接返回</li></ol><p id="678f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分布式事务中需要处理的另一个常见异常是<code class="fe ls lt lu lv b">Duplicated Requests</code>。当进程崩溃并且Saga重试服务时，服务可能被多次调用，因此需要幂等处理。</p><p id="70de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这三种类型的异常需要小心管理；否则，可能会出现数据不一致并中断业务。</p><h1 id="0409" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">解决办法</h1><p id="4a1f" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">https://github.com/dtm-labs/dtm开创了一种同时管理这三种异常的技术，名为T0。对于Saga模式，原则如下:</p><ol class=""><li id="335f" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">在本地数据库中创建一个表<code class="fe ls lt lu lv b">dtm_barrier.barrier</code>，其惟一索引为<code class="fe ls lt lu lv b">gid-branchid-branchop</code></li><li id="6e26" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">开始本地事务</li><li id="d9f2" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">在<code class="fe ls lt lu lv b">Action</code>和<code class="fe ls lt lu lv b">Compensation</code>中，插入忽略一行<code class="fe ls lt lu lv b">gid-branchid-action|compensation</code>，如果受影响的行数为0(如果是重复请求，挂起动作)，直接提交并返回</li><li id="96d5" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">在<code class="fe ls lt lu lv b">Compensation</code>中，插入忽略一个额外的行<code class="fe ls lt lu lv b">gid-branchid-action</code>，如果受影响的行数为1(在空补偿的情况下)，直接提交并返回</li><li id="954f" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">执行业务逻辑并提交，或者在出现错误时回滚</li></ol><h1 id="a106" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">重复的请求</h1><p id="1c83" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">由于上面的惟一索引，重复请求中的插入肯定会被忽略，业务处理会被跳过。</p><h1 id="f034" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">零补偿</h1><p id="b0f2" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">当出现空补偿时，步骤3的成功插入和步骤4的忽略插入将直接提交并返回，跳过业务逻辑。</p><h1 id="3295" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">悬挂动作</h1><p id="0ad9" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">当<code class="fe ls lt lu lv b">Hanging Action</code>发生时，已经执行了补偿，已经插入了一行<code class="fe ls lt lu lv b">gid-branchid-action</code>，所以在<code class="fe ls lt lu lv b">Action</code>中，它会发现第3步的插入被忽略，然后直接返回，跳过了业务逻辑。</p><h1 id="77fc" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">行动和补偿重叠</h1><p id="4023" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">如果<code class="fe ls lt lu lv b">Action</code>和<code class="fe ls lt lu lv b">Compensation</code>执行时间重叠，<code class="fe ls lt lu lv b">Compensation</code>和<code class="fe ls lt lu lv b">Action</code>都会插入同一行<code class="fe ls lt lu lv b">gid-branchid-action</code>。由于唯一索引冲突，两个操作中只有一个会成功，而另一个将等待持有锁的事务完成，然后返回。</p><ul class=""><li id="1677" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr nh mz na nb bi translated">场景一:<code class="fe ls lt lu lv b">Action</code>失败，<code class="fe ls lt lu lv b">Compensation</code>成功插入<code class="fe ls lt lu lv b">gid-branchid-action</code>。这是典型的<code class="fe ls lt lu lv b">Null Compensation</code>和<code class="fe ls lt lu lv b">Hanging Action</code>场景，<code class="fe ls lt lu lv b">Action</code>和<code class="fe ls lt lu lv b">Compensation</code>都将忽略业务逻辑，直接根据上述算法返回</li><li id="0602" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr nh mz na nb bi translated">场景二:<code class="fe ls lt lu lv b">Action</code>成功，<code class="fe ls lt lu lv b">Compensation</code>插入<code class="fe ls lt lu lv b">gid-branchid-action</code>失败。交易执行顺序为<code class="fe ls lt lu lv b">Action</code>在<code class="fe ls lt lu lv b">Compensation</code>之前，无异常发生。根据上述算法，<code class="fe ls lt lu lv b">Action</code>和<code class="fe ls lt lu lv b">Compensation</code>中的业务将依次执行</li><li id="5c8f" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr nh mz na nb bi translated">场景3，如果数据库在重叠期间关闭，将重试操作，并最终转到场景1或2。</li></ul><p id="567c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">综上所述，<code class="fe ls lt lu lv b">Sub-transaction Barrier</code>能够管理异常并确保数据一致性。</p><p id="4bdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述算法也适用于TCC分布式事务。即使您使用工作流引擎(如Candence或Camunda)来处理Saga事务，该算法也同样适用。</p><h1 id="63ff" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">密码</h1><p id="f7cb" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">上述<code class="fe ls lt lu lv b">Sub-transaction Barrier</code>技术，当与分布式事务框架<a class="ae kv" href="https://github.com/dtm-labs/dtm" rel="noopener ugc nofollow" target="_blank">https://github.com/dtm-labs/dtm</a>结合使用时，已经可以在几种语言<a class="ae kv" href="https://en.dtm.pub/ref/sdk" rel="noopener ugc nofollow" target="_blank">SDK</a>中使用，下面是Go中的示例代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9749" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">TransOut</code>服务中，第一行是从HTTP请求创建一个屏障，后面几行调用屏障内部的业务。</p><p id="da2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们把业务处理放在一个subtransaction barrier里面，前面描述的各种异常都被过滤掉了，开发者只需要考虑正常流程下的业务处理。</p><p id="1e04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的例子可以在这里找到:<a class="ae kv" href="https://github.com/dtm-labs/dtm-examples" rel="noopener ugc nofollow" target="_blank">https://github.com/dtm-labs/dtm-examples</a>。在<code class="fe ls lt lu lv b">dtm</code>设置之后，您可以通过以下命令运行一个完整的示例:<br/> <code class="fe ls lt lu lv b">go run main.go http_saga_barrier</code></p><h1 id="49e3" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="e5bc" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">本文提出了一种算法来处理微服务的Saga模式中的异常。它优雅而高效，可以应用于TCC模式和许多其他工作流。</p><p id="f271" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎你来参观https://github.com/dtm-labs/dtm。这是一个开源项目，致力于简化分布式事务的开发。</p></div></div>    
</body>
</html>