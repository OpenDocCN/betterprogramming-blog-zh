<html>
<head>
<title>Using the SceneDelegate Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SceneDelegate方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-the-scenedelegate-21631ccaa137?source=collection_archive---------13-----------------------#2019-11-19">https://betterprogramming.pub/using-the-scenedelegate-21631ccaa137?source=collection_archive---------13-----------------------#2019-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6440" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解SceneDelegate到旧的AppDelegate方法的1:1映射</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/986110f9921cc6dacc86cf13dbb55d3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nnq_JnzL_KIkEfP9kVNF_w.png"/></div></div></figure><p id="9953" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在iOS 13中，如果你的应用采用了新的场景生命周期，UIKit将停止调用旧的与UI状态相关的<code class="fe lq lr ls lt b">ApplicationDelegate</code>方法。</p><p id="9b10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，我们将调用新的<code class="fe lq lr ls lt b">SceneDelegate</code>方法，这非常简单，因为大多数方法都有一对一的映射。</p><p id="a4ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是不要担心——如果你想在iOS 13上采用多窗口支持，这并不意味着你需要放弃对12和更早版本的支持。</p><p id="b90d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您正在重新部署，您可以简单地保留这两组方法，UIKit将在运行时调用正确的方法。</p><h1 id="2aec" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">委托方法</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/20fe73b33c180d7adfc1ca01a35ed970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WPi3N0jRIcj59pejv2mruA@2x.png"/></div></div></figure><p id="4d30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，在我们深入研究确切的委托方法之前，应用程序委托还有一个额外的责任，那就是当创建新的场景会话或放弃现有的场景会话时，系统会通知您的应用程序委托。</p><p id="b481" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是一个概述:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/21b9d75c7b1e57c29b3327b041d0b28b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qUbJeeGWg9X1Mo5f5T9IoQ@2x.png"/></div></div></figure><p id="f86e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">重要的是不要使用<code class="fe lq lr ls lt b">didDisconnect</code>来永久删除任何用户数据或状态，因为场景可能会重新连接并在稍后返回。</p><p id="7949" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也有可能是你的一个用户在你的实际应用程序进程没有运行的时候，通过向上滑动从切换器中移除了一个或多个UI场景。如果您的进程没有运行，系统将跟踪被丢弃的会话，并在您的应用程序下次启动后不久调用它。</p><p id="41b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">查看我之前的文章<a class="ae mo" href="https://medium.com/@yodagamaheshan/where-does-this-scenedelegate-come-from-fb93ed5cb49d" rel="noopener">“scene delegate来自哪里？”</a></p></div></div>    
</body>
</html>