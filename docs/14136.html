<html>
<head>
<title>Find a Bug in Python Code: A Little Thing Does So Much</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python代码中找到一个Bug:一件小事做了这么多</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/find-a-bug-in-python-code-a-little-thing-does-so-much-89d0abd0300c?source=collection_archive---------9-----------------------#2022-11-09">https://betterprogramming.pub/find-a-bug-in-python-code-a-little-thing-does-so-much-89d0abd0300c?source=collection_archive---------9-----------------------#2022-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c04a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">即使是最小的字符也会带来大问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6b7cf71faddeee65a5809d1d9159ef50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t5QR7PaW2d6TpNC9SXwMhg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用放大镜找窃听器。来源:图片由作者的妻子Justyna提供。</p></figure><p id="73fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将向您展示Python中的一个小bug。这很常见，因为我经常犯这种错误。也许十几次，也许甚至二十次——远远超过我认为可以接受的次数。但是因为我经常犯这个错误，所以我通常很容易发现它。</p><p id="c800" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面，我将解释一个策略，你可以用它来找到这个和其他的bug。虽然这看起来像是我们的小游戏，但这实际上是您可以进行调试的方式。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="c2e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你的任务是找出代码中的一个或多个错误。怎么做？这是你的决定，所以选择你的方法。例如，您可以:</p><ol class=""><li id="e58d" class="mb mc it la b lb lc le lf lh md ll me lp mf lt mg mh mi mj bi translated">只要阅读代码和回溯，并尝试找到错误。这对于某些代码片段来说比其他代码片段更容易。</li><li id="1dda" class="mb mc it la b lb mk le ml lh mm ll mn lp mo lt mg mh mi mj bi translated">将代码复制并粘贴到您的IDE、文本编辑器或您使用的任何工具中。然后运行应用程序，并尝试使用回溯来找到错误。您还可以使用最简单的非交互式工具来帮助调试，比如<code class="fe mp mq mr ms b">print()</code>、<code class="fe mp mq mr ms b">logging</code>模块等等。</li><li id="0501" class="mb mc it la b lb mk le ml lh mm ll mn lp mo lt mg mh mi mj bi translated">如上所述，将代码复制并粘贴到您的编辑器/IDE中，然后使用您选择的调试器来查找bug。这是交互式调试。</li></ol><p id="7652" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些方法都不比其他方法好。每一种都教授不同的技能，所以你应该全部尝试。也许一个好的方法是从方法(1)开始，然后，如果那不起作用，尝试方法(2)，如果你仍然不能找到bug，尝试方法(3)。</p><p id="ca0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，你就从最简单快捷的方法变成了最先进的方法。这部分反映了现实生活中的编码实践，我通常就是这样进行的。老实说，当我第一眼看不到bug时，也就是说，当使用第一种方法时，我通常会立即转向第三种方法。</p><p id="b1a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，不要低估第二种方法。这很重要，并且教导了一些非常重要的东西:阅读和理解追溯。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="6fb2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，让我们直接进入代码。试着找到错误。好消息是这个很容易修复。但要修复它，你必须找到它。当你成功地找到它，修复它是几秒钟的事情。</p><h1 id="2297" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">代码</h1><p id="1aa9" class="pw-post-body-paragraph ky kz it la b lb nl ju ld le nm jx lg lh nn lj lk ll no ln lo lp np lr ls lt im bi translated">假设您有一个包含数字(整数和/或浮点数)的列表，您希望将每个元素都称为一个数学函数。在我们的例子中，它将乘以3，我们将在函数<code class="fe mp mq mr ms b">multiply(x, by)</code>中实现，然后求平方根:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6e5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">显然，<code class="fe mp mq mr ms b">x_squared</code>应该是<code class="fe mp mq mr ms b">[1, 9, 49]</code>。相反，我们得到以下错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="da25" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">什么？刚刚发生了什么事？</p><p id="e207" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是你采取行动的时候了。花些时间，试着找出问题所在。回到上面关于如何查找bug的描述。</p><p id="8e46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是有趣的部分，因为你不必担心任何事情。不是你的错误，不是你的问题——但是你的技能会提高！</p><h1 id="a7af" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">虫子</h1><p id="8f2c" class="pw-post-body-paragraph ky kz it la b lb nl ju ld le nm jx lg lh nn lj lk ll no ln lo lp np lr ls lt im bi translated">如果你找到了bug，恭喜你。很小，很小，几乎可以忽略不计。但它有所不同，它打破了密码。问题是很难捕捉到，因为异常并不是在引入bug的地方引发的。因此，这一次，追溯并不是很有帮助。</p><p id="24c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有用的是信息。让我们再看一遍上面写的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0c55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">显然，我们对列表使用了<code class="fe mp mq mr ms b">**</code>操作数(或者，等价地，使用了<code class="fe mp mq mr ms b">pow()</code>函数)。当然，这不是我们想要做的，但它应该有助于我们找到问题发生的地方。是吗？</p><p id="c5eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不是一开始。我们在<code class="fe mp mq mr ms b">square_root()</code>函数中使用了<code class="fe mp mq mr ms b">**</code>，但是看起来这个函数工作得很好。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2ccb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们再一次回到追溯。它提到了<code class="fe mp mq mr ms b">'list'</code>，但是为什么呢？我们肯定不想要一个列表的平方根，是吗？我们只有一份名单。<code class="fe mp mq mr ms b">x</code>中定义的那个。让我们仔细检查一下它的定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="35ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">乍一看，这个定义似乎不错。但是仔细看:在右方括号后面有一个奇怪的逗号(通常称为“尾随逗号”)。为什么会在那里？还有Python为什么不养个<code class="fe mp mq mr ms b">SyntaxError</code>？如果是的话，我们就能毫不费力地找到漏洞。但事实并非如此，这就是为什么回溯没有直接把我们带到错误发生的地方。</p><p id="1349" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有趣的是，用分号(<code class="fe mp mq mr ms b">;</code>)代替逗号没有任何意义，因为在Python中，可以在行尾添加分号。任何其他字符(不包括空白字符)都意味着一个<code class="fe mp mq mr ms b">SyntaxError</code>。但是除了<code class="fe mp mq mr ms b">,</code>、<code class="fe mp mq mr ms b">;</code>和空白字符之外，所有其他字符都意味着打字错误和由此产生的<code class="fe mp mq mr ms b">SyntaxError</code>。</p><p id="9303" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，行尾的逗号变化很大。它使<code class="fe mp mq mr ms b">x</code>成为一个元组，而不是一个列表！而且搞笑的是，这个元组的第一个元素是list <code class="fe mp mq mr ms b">[1, 3, 7]</code>。看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="25dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是因为在创建元组时不必使用括号。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2868" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">包括我在内的许多开发人员在从一个函数中返回两个(有时是三个)元素时使用这种结构。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2dc4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，在<code class="fe mp mq mr ms b">return</code>语句中没有括号。对我来说，这个版本的<code class="fe mp mq mr ms b">return</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b8af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看起来比这个更自然更好:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f0cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">定义不带括号的元组时，可以用逗号结束。因此，我们得到以下结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1188" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是要小心！看下面一行，这与我们在示例中得到的情况非常相似:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2c7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是我们代码片段中bug背后的原因。当您在要指定名称的对象后添加逗号时，该名称不是指该对象，而是指新创建的元组。看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="57f9" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">结论</h1><p id="20b0" class="pw-post-body-paragraph ky kz it la b lb nl ju ld le nm jx lg lh nn lj lk ll no ln lo lp np lr ls lt im bi translated">像这样的错误可以通过添加一个逗号来避免。这种情况对您来说可能并不常见，但它发生的频率比您想象的要高，或者至少我在编码实践中制造了太多类似的错误。我认为在大多数情况下——如果不是全部的话——它发生在我修改代码的时候。这听起来奇怪吗？</p><p id="f051" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不是的。例如，您可以在以下情况下引入这样一个bug假设您有一个包含几个值的字典:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="88a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，省略号表示字典中更多的键值对。您决定将密钥直接移动到代码中。看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="92f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当这样做时，很容易出现我们在本文中讨论的错误。你注意到我确实做到了吗？就在<code class="fe mp mq mr ms b">end_date</code>的定义里。至少在这种情况下，这个小而重要的错误背后的主要原因是，对代码的这种修改需要您对每一行做一些不同的事情。</p><p id="501c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，你需要先删除<code class="fe mp mq mr ms b">settings</code>字典的定义。然后，您必须删除每行中的前导空格和尾随逗号。当你不小心的时候——至少对我来说，当我不得不一件接一件地做这些无聊的事情时，这是一种很难达到的精神状态——你可能会忘记移走留在线末端的几个小东西中的一个。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="1694" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！我希望你喜欢阅读这篇文章和做练习。这是最基本的，但是我会在以后给你提供一个有更多困难问题的查找bug游戏。最重要的是，我希望如果你犯了这样的错误，或者在别人写的代码中遇到了这样的错误，你能毫无问题地发现它。</p><p id="2285" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我上面写的，我已经犯过几次这样的错误了。你做过这样的虫子吗？如果是，你发现它没有问题吗？</p><p id="36a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请在评论中分享你的想法和经历。</p></div></div>    
</body>
</html>