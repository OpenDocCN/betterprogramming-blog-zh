<html>
<head>
<title>Algorithms: Find the First Not-Repeating Character</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法:查找第一个不重复的字符</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/algorithms-find-the-first-non-repeating-character-eb77da094d84?source=collection_archive---------3-----------------------#2020-03-17">https://betterprogramming.pub/algorithms-find-the-first-non-repeating-character-eb77da094d84?source=collection_archive---------3-----------------------#2020-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0971" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在字符串中搜索第一个唯一字符</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7250760fdf3038a024f8fa170b445541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NJmH1VVDye_e52V6"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@roman_lazygeek?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗马法师</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="039e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将提出一个算法挑战，然后提供两个解决方案:亚军和最佳算法。算法是用Python写的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d9a5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">挑战</h1><p id="ec84" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在一串小写字母中查找第一个不重复的字符。非重复字符被定义为在字符串中只出现一次的字符。如果所有字符都重复，则返回一个下划线。</p><p id="f970" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一些示例字符串和每个字符串的答案:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e8c2" class="ne md it na b gy nf ng l nh ni">"aabcdb" # c<br/>"abcddc" # a<br/>"aabbcc" # _<br/>"abbcda" # c</span></pre><p id="6b4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们理解了挑战，我鼓励你自己去尝试。</p><p id="c40b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您已经尝试过，或者您想跳过前面的步骤，那么让我们来看看解决方案吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="45d0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">亚军</h1><p id="a874" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用一对for循环，我们可以以嵌套方式迭代字符串，以确定某个字符是否重复:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3248" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于此解决方案的几点说明:</p><ul class=""><li id="26be" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">嵌套for循环算法的多项式时间复杂度为<em class="nu"> O(n^2) </em>。</li><li id="aabe" class="nl nm it lb b lc nv lf nw li nx lm ny lq nz lu nq nr ns nt bi translated">通过将算法简化为单个循环来优化嵌套循环解决方案。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1e91" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最优解</h1><p id="e6c0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了避免嵌套循环，我们可以使用字典跟踪每个值在字符串中出现的次数——其中字符是术语，计数是定义。</p><p id="d187" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们有了计数，字典就成为我们检查第一个只出现一次的字符的参考:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a737" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于此解决方案的一些注意事项:</p><ul class=""><li id="ad6c" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">由于字典的定义是无序的，所以我们应该再循环一次，以确保我们保持了字符串的顺序。</li><li id="5963" class="nl nm it lb b lc nv lf nw li nx lm ny lq nz lu nq nr ns nt bi translated">从3.7版本开始，Python字典将保留条目顺序。这将消除遍历字符串的需要，并允许我们直接遍历字典。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7311" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">奖金解决方案</h1><p id="2639" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">幸运的是，对于我们Pythonistas来说，有一些原生的字符串函数使得这个算法变得轻而易举。</p><p id="bae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用<code class="fe oa ob oc na b">.find()</code>和<code class="fe oa ob oc na b">.rfind()</code>，我们可以确定一个字符左右的索引。如果左搜索和右搜索返回相同的索引，那么我们可以断定该字符只出现一次。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5aef" class="ne md it na b gy nf ng l nh ni">def firstNotRepeatingCharacter(my_string):<br/>  for c in my_string:<br/>    if my_string.index(c) == my_string.rindex(c):<br/>      return c<br/>  return "_"</span></pre><p id="40d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于此解决方案的一些注意事项:</p><ul class=""><li id="d5ee" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">由于该算法依赖于特定于语言的方法，因此它不是语言不可知的。</li><li id="e3d5" class="nl nm it lb b lc nv lf nw li nx lm ny lq nz lu nq nr ns nt bi translated">虽然该算法在语法上比我们的最优解迭代次数少，但两者的时间复杂度相同。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d9d1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="da16" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你过得怎么样？你最初的解决方案是什么？下面分享一下你的经历吧！</p><p id="71b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特别感谢尼克·怀特对这个算法的解释！</p></div></div>    
</body>
</html>