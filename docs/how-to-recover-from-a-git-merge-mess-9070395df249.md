# 如何从 Git 合并混乱中恢复

> 原文：<https://betterprogramming.pub/how-to-recover-from-a-git-merge-mess-9070395df249>

## 关于 git 引用、提交和分支的深入讨论

![](img/651d4ae0651f6058ed05c3a13c24fddf.png)

[Wonderlane](https://unsplash.com/@wonderlane?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照

你的项目使用过 [Git 版本控制系统](https://git-scm.com/)吗？

如果你是一名软件开发人员，答案可能是“是的，每天都有”。

Git 是世界上使用最广泛的现代版本控制系统。自从它由 Linus Torvalds 在 2005 年创建以来，它在协调程序员之间的工作方面发挥了重要作用，这些程序员在软件开发期间协作开发源代码。

Git 提供了速度、数据完整性和对分布式非线性工作流的支持。也带来了痛苦和乱七八糟的操作。

有官方的 Git 文档，也有很多博客和指南。但是要掌握 Git 版本控制系统还是比较难的。`git <command> --help`是一本很长的手册，有许多选项。讽刺的是，科学的描述在你知道命令之后更有意义。

我们不需要知道每个 Git 命令，更不用说每个选项。从 Git 引用开始，仔细看看 Git 提交和 Git 分支。希望这些概念能够帮助您有效地管理 Git，并在出现问题时能够解决问题。

# Git 储存库

Git 存储库是一个版本控制系统，它跟踪文件的变化。这些更改由提交进行跟踪。每台计算机上的每个 Git 目录都是一个完全成熟的存储库，具有完整的历史和完整的版本跟踪功能，独立于网络访问或中央服务器。

## 工作树/工作目录

工作树或工作目录由当前正在处理的文件组成。它包含自上次提交以来未更改的文件、新添加的文件和/或修改的文件。`git status`命令显示工作树状态。

## 索引/暂存区

索引或临时区域是准备提交的地方。它包括由`git add`策划的文件。

## 提交/合并

在`git commit`之后，暂存文件被移动到提交，作为本地存储库中的记录。本地提交可以`git push`到远程存储库进行共享，并且可能与其他特性开发合并。

# Git 提交

Git 通过提交来跟踪代码变更，提交是某个时间点上所有文件的快照。在提交中有两件事很重要:

*   自上次提交以来的更改列表。
*   一些属性，包括在存储库中唯一标识提交的提交 ID。

## 长哈希

当提交文件时，Git 生成一个提交 ID，这是一个 40 个字符的 SHA-1 散列。该值是根据提交日期、其以前的提交 ID、作者姓名等计算的。这个提交 ID 是一个 Git 引用。40 个字符的完整哈希也称为长哈希。

## 主要分支

让我们克隆我们的示例存储库来了解更多信息:

```
$ git clone [https://github.com/JenniferFuBook/git-fun.git](https://github.com/JenniferFuBook/git-fun.git)
```

从 2020 年 10 月 1 日开始，GitHub 上所有新的 Git 库都将默认分支命名为`main`，而不是`master`。默认情况下，我们在`main`分支上:

## 提交详细信息

`git log`是访问提交历史的命令。在`main`分支，`git log`列出所有提交:

`263230cf1cdfcd2b1bba5653a12a7bb3599b1385`(第 58 行)是第一次提交的引用指针。

给定提交 ID，`git show`显示提交属性和实际更改:

第`8`行显示了索引范围，它由内部元数据(不是散列)组成。

我们可以添加选项来仅显示更改的文件名。

我们也可以使用`git log`只显示提交属性:

`git log`有压缩格式:

## 短哈希

长哈希可以缩写为短哈希，只要该值在存储库中唯一标识提交，就可以使用前 n 个字符:

反之亦然，可以从短哈希中检索长哈希:

## 标签

因为散列很难记住，所以我们可以创建一个标签来方便地引用它。通常，标签应用于特殊修订，如发布版本。在我们的示例存储库中，我们已经标记了第一个提交:`git tag -a starting-point 263230cf1cdfcd2b1bba5653a12a7bb3599b1385`。标签`starting-point`可以方便地用来标识提交。

## 提交差异

我们可以使用以下命令将提交`f68d41c`中的`file.text`与工作树上的当前命令进行比较:

或者我们可以比较两次提交之间的`file.text`:

## 本地提交

转到`branch2`并提交:

我们可以使用`git cherry`来检查没有被推送到远程的本地提交:

`git log`也可以显示本地提交:

行`5`指定这是一个本地提交。

# Git 分支

Git 分支是一个独立的工作环境，允许独立开发不同的特性。

每个分支都有一个名字。下面的命令显示了我们的示例存储库，它有远程分支、`branch1`、`branch2`、`branch2`、`branch4`和`main`。目前只检出了`main`有本地工作树。`*`标记当前分支。

## 图示

分支没有严格的父分支。相反，它有一个特定的提交路径。`git log —-graph`在输出的左侧绘制基于文本的提交历史图形。每个`*`代表一个提交，`*`下面的输入行代表父提交。多个传入行表示合并，而传出行标记一个共同的祖先。

这种图形表示也有一种压缩格式:

Git 日志图是帮助我们阅读 Git 结构和解决问题的基础。编写有意义且唯一的提交消息对于快速发现提交非常重要。

如果您对最后一条提交消息不满意，可以用新的描述重写它:

```
git commit --amend -m "<new-message>"
```

修改本地提交是可以的。对于推式提交，改变历史不是一个好主意，但是`git push --force`适用于重命名的提交。

## 头部

分支是一系列提交的末端，由路径的最后一个提交 id 标识。`HEAD`是指向当前分支顶端的引用指针。它仅仅是当前的提交 ID。

我们可以检查`branch2`并列出所有本地和远程分支:

`HEAD`是记忆 tip 提交 ID 的简单语法。`HEAD^`指向`HEAD`的第一个父节点。`HEAD~n`是`HEAD`的`nth`代祖先。`HEAD`可简称为`@`。

下面是`branch3`上的提交日志:

我们可以使用`HEAD`语法来过滤输出:

## 新分支

通过将分支名称连接到提交 ID 来创建分支。它可以通过以下命令创建:

```
$ git branch <branchname> [<reference>]
```

这创建了一个新的分支，它的头指向`reference`，可以用提交 ID、分支名称、标签或任何链接到提交 ID 的方法来指定。如果省略`reference`，将使用当前的`HEAD`。

如果我们当前不在某个分支上，我们可以强制将该分支重新分配给任何引用:

```
$ git branch -f <branchname> [<reference>]
```

## 分支差异

我们可以在 Git 存储库中区分不同分支。以下两点语法比较了分支并显示了`origin/main`和`origin/branch4`之间的变化:

三点语法将两个分支的共同祖先的变化与点之后的分支进行比较。

`origin/main`和`origin/branch4`的共同祖先是什么？可以通过`git merge-base`命令查询:

检查`git log --graph`之前的输出，我们可以确认`36eda0253bd17e8bbe240b151b408b194042056a`是`main`从`branch4`拉取的提交。

`git diff origin/main…origin/branch4`返回 nothing。因此，自最后一个共同祖先以来没有任何变化。

# 如何从合并的混乱中恢复？

Git 分支允许我们在多个分支上独立工作。当两个分支合并时，我们很可能会面临合并冲突。在另一篇文章的[中，我们讨论了如何使用 Git merge、squash、rebase 或 pull 来解决合并冲突。最好的方法是避免合并混乱。](/git-merge-squash-rebase-or-pull-what-to-choose-50b331d3e7c1)

然而，工作目录可能处于混乱的状态。例如，您的更改丢失了，或者其他开发人员的更改出现在您的 pull 请求中。重要的是知道如何从合并混乱中恢复，不管它是由`git merge`、`git rebase`还是`git pull`引起的。

恢复意味着我们不会丢失任何工作:

*   已经隐藏的文件可以被检索/取消隐藏。
*   已经提交的文件可以被检索/精选。
*   可以将分支重置为首选参考。

## 贮藏

提交更改是安全的，因为提交的所有内容都成为 Git 历史的一部分。从这个意义上说，这项工作不会丢失。

但是，在某些情况下，提交可能没有准备好。对于这些情况，我们可以将更改隐藏在一个脏的工作目录中。

在`branch4`上进行更改:

输入`git stash save "Changing sixth line"`后，工作目录干净。

然后，做另一个改变:

输入`git stash save "Thinking…"`后，工作目录又干净了。

这是藏匿清单:

这显示了隐藏描述的优势。稍后，描述有助于我们挑选要取消的隐藏内容:

*   要应用存储并将其从存储堆栈中移除，请键入`git stash pop stash@{n}`。
*   要应用存储并将其保留在存储堆栈中，请键入`git stash apply stash@{n}`。

## 樱桃采摘

对于任何现有的提交，我们可以使用`git cherry-pick`命令将更改应用到当前分支`HEAD`。

```
git cherry-pick <reference>
```

它可以选择对当前分支`HEAD`的特定提交，或者一系列提交。

## 重置分支

在一个分支上，我们可以使用`git reset`将电流`HEAD`重置为`reference`。

```
$ git reset [<mode>] [<reference>]
```

`git reset --hard <reference>`将删除工作目录中的更改，并将分支指向特定的`reference`。

`git reset --soft <reference>`将在工作目录中保存更改，并将分支指向特定的`reference`。当存在冲突时，您可能无法使用软复位。

以下是常用的命令:

*   `git reset —-hard origin/<branch-name>`:删除所有本地更改/提交。
*   `git reset --soft HEAD~1`:撤消上一次提交，但保留更改。

有时候，如果一个分支真的搞砸了，我们可能想开一个新的:

## Git 参考日志

`git log`显示当前的`HEAD`及其祖先。它是包含在推送、拉入、获取或克隆中的远程和本地历史。

`git reflog`显示了`HEAD`指向的提交的有序列表。历史只存在于本地存储库中。在一些回退操作之后，引用可能变得不可访问。`git reflog`将历史记录保留一段时间(垃圾收集运行前两周)。参考日志提供了一个恢复窗口，但是无法完成的提交最终会被删除。

这是我们修改示例存储库后的`git reflog`的快照:

# 结论

Git 版本控制系统使团队能够同时处理大型项目。当存储库被搞乱时，我们不应该惊慌——只要工作得到了隐藏或提交的支持，我们总是可以将它们恢复/重新应用到代码库中。

以下是 Git 的总体帮助:

你现在觉得简单了吗？

感谢乌里扬·张、戈塔姆·穆塔和悉达多·钦塔帕利与我一起修复了一个 Git 合并的烂摊子！

感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物。