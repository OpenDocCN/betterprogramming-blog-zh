<html>
<head>
<title>Organize NodeJS Code in Custom Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在自定义模块中组织节点代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/organize-nodejs-code-using-custom-modules-caf5081c691e?source=collection_archive---------5-----------------------#2019-07-30">https://betterprogramming.pub/organize-nodejs-code-using-custom-modules-caf5081c691e?source=collection_archive---------5-----------------------#2019-07-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3814" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用NodeJS模块，一切看起来都很干净</h2></div><p id="4786" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您开始开发节点应用程序时，一切看起来都很简单、明了且编码良好。直到您开始实现ExpressJS路线、一般特性和常见任务，在这一点上，一切都开始变得一团糟。JavaScript一直受到代码组织和上下文分离问题的困扰，但有了NodeJS模块，它看起来很干净，编码也很好。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/ae80df415877f76b80affcf2c6563f36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i0PXOt2psqa7EMEm"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">由<a class="ae lu" href="https://unsplash.com/@kaleidico?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">万花筒</a>在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="3621" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">节点模块</h1><p id="eaf8" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">NodeJS模块是代码、方法、模型等等的包装器。NodeJS模块只是逻辑上独立的例程或代码部分的容器。使用模块分割代码的方式严格取决于您希望如何组织代码。NodeJS模块构成了关注点、上下文分离和代码重用的原则。一旦你能以正确的方式分割代码，你就基本上设计了你能随时简单重用的NodeJS模块。通过延迟加载，您可以扩展这种实现和概念，并最大化NodeJS模块的好处。</p><p id="8b7c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ms">由于NodeJS模块能够将几乎任何行为封装在单独的代码部分中，因此您可以决定是否加载资源等。这取决于你。</em></p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="86a3" class="lv lw it bd lx ly na ma mb mc nb me mf jz nc ka mh kc nd kd mj kf ne kg ml mm bi translated">神奇的词:模块.导出</h1><p id="aca9" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">NodeJS模块中的一切本质上都是私有的。每当你声明一个新的变量或者一个新的方法，NodeJS认为这在模块内部是有用的——没有任何东西暴露给外部。这就是为什么在NodeJS中，我们可以通过使用<code class="fe nf ng nh ni b">module.exports</code>来决定应该向外界公开什么。</p><p id="c60a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个模块可以导出几乎所有的东西:变量、常量、函数，甚至对象。我们知道JavaScript是多才多艺且易于操作的，所以很容易让<code class="fe nf ng nh ni b">module.exports</code>甚至用其定义中的方法来公开对象。</p><p id="6d2f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接近自定义NodeJS模块的第一步通常很简单，就像这样:</p><pre class="lf lg lh li gt nj ni nk nl aw nm bi"><span id="5d69" class="nn lw it ni b gy no np l nq nr">module.exports = “hello from a module”;</span></pre><p id="f6c5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这使得NodeJS模块由一个字符串组成。如果您导入这个模块，您所拥有的只是一个字符串:</p><pre class="lf lg lh li gt nj ni nk nl aw nm bi"><span id="3948" class="nn lw it ni b gy no np l nq nr">// main.js</span><span id="9798" class="nn lw it ni b gy ns np l nq nr">var message = require(“./hello.js”);</span></pre><p id="a302" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以通过公开函数而不是字符串来扩展相同的模式:</p><pre class="lf lg lh li gt nj ni nk nl aw nm bi"><span id="a689" class="nn lw it ni b gy no np l nq nr">// functions.js</span><span id="ebb7" class="nn lw it ni b gy ns np l nq nr">module.exports = function(name){</span><span id="1597" class="nn lw it ni b gy ns np l nq nr">     return “Hello “ + name;</span><span id="fa94" class="nn lw it ni b gy ns np l nq nr">}</span></pre><p id="3895" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，无论何时导入模块，都会得到一个看起来像方法的函数:</p><pre class="lf lg lh li gt nj ni nk nl aw nm bi"><span id="7c57" class="nn lw it ni b gy no np l nq nr">// main.js</span><span id="8220" class="nn lw it ni b gy ns np l nq nr">var hello = require(“./functions.js”);</span><span id="5313" class="nn lw it ni b gy ns np l nq nr">console.log(hello("Ivano"));</span></pre></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="4ede" class="lv lw it bd lx ly na ma mb mc nb me mf jz nc ka mh kc nd kd mj kf ne kg ml mm bi translated">导出对象</h1><p id="4a65" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">您可以导出和导入自定义NodeJS模块的方式很容易编码。在一个定制模块中需要公开几个方法和多个变量是很常见的——我们如何做呢？</p><p id="905b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很简单。通过导出一个对象，而不是一个单独的变量或方法，来扩展相同的概念和相同的语法。通过使用标准的JSON符号，您可以动态地创建一个对象，并向外界公开您想要的任何内容:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="a4f2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论:超出一般用途</h1><p id="40f4" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">使用NodeJS模块非常有趣而且非常简单。练习一些导出，你很快就会掌握编写NodeJS定制模块。</p><p id="74ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能应该做一些“私有”配置，然后只导出模块内部的部分登录。这很常见，这使得NodeJS模块更加强大，适应性更强。编写代码的私有和公共部分是编写定制NodeJS模块的主要目标。 例如，在mongose中，您可以在模块内部定义模式，然后只将mongose模块导出到main。</p><p id="0045" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个很好的例子是编写一个NodeJS模块来共享MongoDB连接的实例。这比通过将连接放入ExpressJS请求(这是普遍实现的)来全球化或共享连接要好得多。</p><p id="701b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于ExpressJS路由，我建议在不同的文件中使用ExpressJS路由器实例:只需查看官方文档。</p><p id="0eff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">定义许多ExpressJS路由对于大中型应用程序来说几乎是强制性的，你不能假装把它们都放在同一个Javascript文件中！</p></div></div>    
</body>
</html>