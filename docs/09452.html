<html>
<head>
<title>Making Network Requests With Async/Await in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中使用Async/Await发出网络请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/making-network-requests-with-async-await-in-swift-6b5880c9df6a?source=collection_archive---------6-----------------------#2021-08-26">https://betterprogramming.pub/making-network-requests-with-async-await-in-swift-6b5880c9df6a?source=collection_archive---------6-----------------------#2021-08-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="725c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">借助快速并发为您的iOS应用提供动力</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/196681f1055a86bb75b9783803f9f4e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NI8wJN_mkKJhSi7N"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@federize?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">费德里科·贝卡里</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="7528" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传统上，当我们想要发出网络请求时，我们必须使用基于闭包的<code class="fe lv lw lx ly b">URLSession</code>API来异步执行请求，这样我们的应用程序就可以在等待请求完成时做出响应。随着Swift 5.5的发布，这种情况不再存在，我们现在有了另一种选择，即使用async/await。</p><p id="54ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将向您展示如何使用async/await关键字发出网络请求。除此之外，我还将对async/await和基于闭包的API进行一个快速的比较，以便您能够更好地理解使用async/await的好处。</p><p id="f5bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文要求您对async/await有一个基本的了解。因此，如果您不熟悉Swift并发，我强烈建议您首先阅读我的博客文章“<a class="ae ky" href="https://swiftsenpai.com/swift/swift-concurrency-get-started/" rel="noopener ugc nofollow" target="_blank">Swift并发入门</a>”</p><p id="712c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说了这么多，让我们开始吧！</p><h1 id="329a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">先决条件</h1><p id="aebb" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在整篇文章中，我们将使用Apple iTunes API从Taylor Swift获取一系列专辑。以下是API的URL:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="9212" class="na ma it ly b gy nb nc l nd ne"><a class="ae ky" href="https://itunes.apple.com/search?term=taylor+swift&amp;entity=album" rel="noopener ugc nofollow" target="_blank">https://itunes.apple.com/search?term=taylor+swift&amp;entity=album</a></span></pre><p id="fd86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个API端点将为我们提供以下JSON响应:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/23fa356cfc032080a3895a9fc6ac38c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NyMWRIbLp0-1KTzA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自苹果iTunes API的JSON响应</p></figure><p id="24a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于演示目的，我们将获取专辑的名称和价格，并<a class="ae ky" href="https://swiftsenpai.com/development/uicollectionview-list-basic/" rel="noopener ugc nofollow" target="_blank">在收藏视图列表</a>中显示它们。以下是我们进行JSON解码所需的模型对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4ad5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们将<code class="fe lv lw lx ly b">Album</code>结构与<code class="fe lv lw lx ly b">Hashable</code>协议相一致，这样我们就可以将它用作集合视图差异数据源的项目标识符类型。</p><p id="f079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说完这些，让我们进入网络请求代码。</p><h1 id="8f41" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">传统的方式</h1><p id="9ebc" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在Swift 5.5之前，为了发出网络请求，我们必须使用基于闭包的<code class="fe lv lw lx ly b">URLSession</code>的<code class="fe lv lw lx ly b">dataTask(with:completionHandler:)</code>方法来触发后台异步运行的请求。一旦网络请求完成，完成处理程序将把网络请求的结果返回给我们。</p><p id="470f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，让我们为此定义一个<code class="fe lv lw lx ly b">AlbumsFetcher</code>结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1fd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您以前处理过发出网络请求的代码，那么您应该对上面的<code class="fe lv lw lx ly b">fetchAlbums(completion:)</code>函数很熟悉。我们首先启动一个数据任务来发出网络请求。一旦请求完成，我们检查错误并解析响应JSON。</p><p id="59b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe lv lw lx ly b">fetchAlbums(completion:)</code>函数也非常简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8e4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的一点是，<code class="fe lv lw lx ly b">updateCollectionViewSnapshot(_:)</code>函数是一个助手函数，它基于<code class="fe lv lw lx ly b">albums</code>数组更新我们的列表。因此，我们需要在调用它之前调度回主线程。</p><p id="8f7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传统的方法已经过时，在下一节中，让我们看看如何使用新的async/await关键字实现同样的事情。</p><h1 id="36c7" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">快速并发方式</h1><p id="4746" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">为了将基于闭包的<code class="fe lv lw lx ly b">fetchAlbums(completion:)</code>函数转换成新的async/await风格，我们可以采用两种完全不同的方法。</p><p id="8549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一种方法是使用<code class="fe lv lw lx ly b">CheckedContinuation</code>(在Swift 5.5中引入)将<code class="fe lv lw lx ly b">fetchAlbums(completion:)</code>函数与异步上下文联系起来，而第二种方法是用<code class="fe lv lw lx ly b">URLSession</code>的异步变体替换基于闭包的<code class="fe lv lw lx ly b">URLSession</code>。</p><p id="4516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们首先关注一下<code class="fe lv lw lx ly b">CheckedContinuation</code>方法。</p><h2 id="7d79" class="na ma it bd mb ni nj dn mf nk nl dp mj li nm nn ml lm no np mn lq nq nr mp ns bi translated">检查延续</h2><p id="b3bc" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">CheckedContinuation</code>是Swift 5.5中的新机制，帮助开发人员在同步和异步代码之间架起桥梁。我们可以使用<code class="fe lv lw lx ly b">withCheckedThrowingContinuation(function:_:)</code>或<code class="fe lv lw lx ly b">withCheckedContinuation(function:_:)</code>方法创建一个<code class="fe lv lw lx ly b">CheckedContinuation</code>。</p><p id="fd95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，由于<code class="fe lv lw lx ly b">fetchAlbums(completion:)</code>函数的完成处理程序将返回一个错误，我们将使用该方法的“<em class="nt"> throwing </em>”变体来创建一个延续。下面是如何做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6c47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，<code class="fe lv lw lx ly b">withCheckedThrowingContinuation(function:_:)</code>方法接受一个带有延续参数的闭包。它创建一个异步任务，执行<code class="fe lv lw lx ly b">fetchAlbums(completion:)</code>函数来异步触发网络请求。</p><p id="c687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，有几个重要的方面您应该知道:</p><ol class=""><li id="b288" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated"><code class="fe lv lw lx ly b">withCheckedThrowingContinuation(function:_:)</code>方法被标记为<code class="fe lv lw lx ly b">async</code>，因此我们必须使用<code class="fe lv lw lx ly b">await</code>关键字来调用它。最重要的是，因为我们使用了它的“throwing”变体，所以我们也需要使用<code class="fe lv lw lx ly b">try</code>关键字(就像调用一个普通的抛出函数一样)。</li><li id="f55d" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">在整个异步任务中，我们必须在每个执行路径上调用一次resume方法。多次从延续中恢复是未定义的行为。鉴于从不继续会使异步任务无限期地处于挂起状态，我们称这种继续泄漏。</li><li id="2344" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><code class="fe lv lw lx ly b">withCheckedThrowingContinuation(function:_:)</code>方法的返回类型必须与<code class="fe lv lw lx ly b">resume(returning:)</code>方法的参数数据类型相匹配，参数数据类型为<code class="fe lv lw lx ly b">[Album]</code>。</li></ol><p id="66f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们把注意力转移到呼叫站点。假设我们正在视图控制器中调用<code class="fe lv lw lx ly b">fetchAlbumWithContinuation()</code>函数，我们可以这样调用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="428b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，我们必须创建一个异步任务，这样我们就可以在异步上下文中等待并执行<code class="fe lv lw lx ly b">fetchAlbumWithContinuation()</code>函数。由于我们不再使用完成处理程序，我们现在可以使用<code class="fe lv lw lx ly b">do</code>–<code class="fe lv lw lx ly b">catch</code>语句来处理函数抛出的错误。</p><p id="5c86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，请注意，在调用<code class="fe lv lw lx ly b">updateCollectionViewSnapshot()</code>之前分派到主线程不再是必要的，因为我们正在视图控制器中调用<code class="fe lv lw lx ly b">fetchAlbumWithContinuation()</code>函数，它是一个<code class="fe lv lw lx ly b">MainActor</code>。</p><h2 id="d81c" class="na ma it bd mb ni nj dn mf nk nl dp mj li nm nn ml lm no np mn lq nq nr mp ns bi translated">异步URLSession</h2><p id="ce87" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在Swift 5.5中，除了发布<code class="fe lv lw lx ly b">async</code>和<code class="fe lv lw lx ly b">await</code>关键词，苹果还更新了很多自己的SDK来支持这两个关键词，其中一个就是<code class="fe lv lw lx ly b">URLSession</code>。</p><p id="39ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">苹果给<code class="fe lv lw lx ly b">URLSession</code>增加了一个新的<code class="fe lv lw lx ly b">data(url:)</code>方法，相当于我们之前用的<code class="fe lv lw lx ly b">dataTask(with:completionHandler:)</code>方法。它是一个抛出的异步方法，返回一个由<code class="fe lv lw lx ly b">Data</code>和<code class="fe lv lw lx ly b">URLRespons</code>组成的元组。下面是如何使用它来发出网络请求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9fd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码是不言自明的，但是，请注意<code class="fe lv lw lx ly b">URLSession.data(from:)</code>方法是一个异步方法，因此代码在等待返回时可能会挂起。这也是为什么我们需要使用关键字<code class="fe lv lw lx ly b">await</code>来调用它。</p><p id="31bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是<code class="fe lv lw lx ly b">fetchAlbumWithAsyncURLSession()</code>的调用地点，与调用<code class="fe lv lw lx ly b">fetchAlbumWithContinuation()</code>基本相同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="49c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个阶段，你可能会问:如果<code class="fe lv lw lx ly b">URLSession</code>的API已经支持async/await，那么使用<code class="fe lv lw lx ly b">CheckedContinuation</code>还有什么意义？嗯，你完全正确！如果可以的话，我们肯定应该使用任何API的async/await变体。</p><p id="8204" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">CheckedContinuation</code>主要用于桥接任何尚不支持async/await语法的异步API。比方说，如果您正在使用不支持async/await语法的第三方网络库(比如Alamofire ),那么您可以使用<code class="fe lv lw lx ly b">CheckedContinuation</code>逐步迁移您的现有代码以支持async/await，同时等待第三方库更新。</p><h1 id="1841" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">异步/等待与关闭</h1><p id="c8ff" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">自从苹果在WWDC21中引入async/await以来，一些初级开发人员问我:为什么每个人都如此热衷于async/await，而我们已经可以通过使用闭包和调度队列做完全相同的事情了？</p><p id="753b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本节中，让我们通过快速浏览使用async/await的一些好处来尝试回答这个问题:</p><ol class=""><li id="bea3" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">当使用闭包时，我们可能会忘记调用完成处理程序，并且没有办法防止这种情况发生。当使用async/await时，如果我们没有从async函数返回，我们将得到一个编译错误。</li><li id="ad53" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">在使用闭包时，不可能使用<code class="fe lv lw lx ly b">do</code>–<code class="fe lv lw lx ly b">catch</code>语句来处理错误，因为闭包不支持这样做。另一方面，我们可以使用<code class="fe lv lw lx ly b">do</code>–<code class="fe lv lw lx ly b">catch</code>语句处理异步函数抛出的错误，就像处理普通函数抛出的错误一样。</li><li id="1725" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">通过使用async/await，我们不再需要担心忘记分派回主线程，因为它已经被<code class="fe lv lw lx ly b">MainActor</code>处理了。</li><li id="d7d2" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">Async/await在提高代码性能的同时，为线程爆炸提供了更高的安全性。你可以查看<a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2021/10254/" rel="noopener ugc nofollow" target="_blank">这段</a> WWDC的视频，了解更多信息。</li><li id="81c9" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">使用async/await语法编写的异步代码都是直线代码。需要按顺序执行的操作都一个接一个地列出来了。这使得我们的代码(实现和调用站点)更短、更清晰、更容易推理。您可以使用以下图片进行快速比较:</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/e5d400de1cf2785798fd429412cd5971.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZfFbVS3FRqeAfnHHLeGsMg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">网络请求实现比较</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/dcf0683b76b72737df862e0883ed690a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zzjmmj4GaMxChe8CnjQV8g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">网络请求调用站点比较</p></figure><h1 id="969d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">包扎</h1><p id="8294" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">你有它！使用async/await发出网络请求非常简单，我们只需简单地使用它就能获得大量好处。不过值得注意的是<strong class="lb iu"> async/await只有iOS 15及以上</strong>才有。因此，如果您的项目仍然需要支持旧版本的iOS，您可能需要等待一段时间，然后更新现有的异步代码以使用async/await。</p><p id="4410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想亲自尝试一下，这里是<a class="ae ky" href="https://github.com/LeeKahSeng/SwiftSenpai-Swift-Concurrency" rel="noopener ugc nofollow" target="_blank">的完整示例代码</a>。</p><p id="1617" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，并希望在新文章发布时得到通知，请随时在<a class="ae ky" href="https://twitter.com/Lee_Kah_Seng" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p><p id="3250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>