<html>
<head>
<title>Zustand vs. Signals — Comparing React State Management Options</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Zustand与Signals—React状态管理选项比较</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/zustand-vs-signals-e664bff2ce4a?source=collection_archive---------0-----------------------#2022-12-09">https://betterprogramming.pub/zustand-vs-signals-e664bff2ce4a?source=collection_archive---------0-----------------------#2022-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="379c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">信号可能是未来，但现在，这就是为什么我更喜欢与Zustand合作。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/49e5887be20752611cf2ed37e8791250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ej-1rHTfJ5ji7_5XscrWg.jpeg"/></div></div></figure><p id="2ebd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">多年来，React生态系统已经获得了看似无穷无尽的状态管理解决方案。除了曾经显而易见且无处不在的Redux之外，React开发人员现在有了无数的选择。MobX、Jotai、反冲、Valtio、Zustand、Redux Toolkit和Rematch只是几个可供考虑的选项。</p><p id="bf3b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这给工程团队留下了困难的(并且经常是有争议的！)决定如何管理应用程序状态的任务。</p><p id="4a6c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将比较最流行的状态管理库之一zustand，以及Preact团队最近发布的新人Signals。</p><h1 id="b232" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">等等，但是上下文呢？</h1><p id="bd12" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">啊，是的，上下文。React 16.3中上下文API的引入在React社区中引起了一些轰动。突然有了一种无需第三方库就能管理应用状态的方法。</p><p id="a7f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它干净、灵活、直观，而且没有增加包的大小，有什么不喜欢的呢？不幸的是，随着上下文API的使用，出现了几个现在已经很好理解的问题，需要额外的努力来解决。我们将讨论上下文依赖和消费者重新呈现这两个主要问题。</p><p id="9f84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管上下文从来没有打算作为全局状态管理的替代，但它仍然成为一个非常受欢迎的解决方案。我们将简要介绍这两个上下文问题，以突出Zustand和Signals以其独特的方式解决的问题。</p><h2 id="cb46" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated"><strong class="ak">上下文依赖问题</strong></h2><p id="28be" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">由于React中数据总是向下流动的特性，上下文提供者只能访问由。下图说明了这一点，许多人对此应该非常熟悉:</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="055f" class="nb lo iq mx b be nc nd l ne nf">export const App = () =&gt; {<br/>  return (<br/>    &lt;LayoutProvider&gt;<br/>      &lt;GraphQLProvider&gt;<br/>        &lt;AuthProvider&gt;<br/>          &lt;UserProvider&gt;<br/>            &lt;ReliesOnUserProviderSoCannotBeMovedUpProvider&gt;<br/>              &lt;GlobalSearchProvider&gt;<br/>                &lt;NeedsAccessToAllProvidersAbove&gt;<br/>                  &lt;YetAnotherProvider&gt;<br/>                    &lt;Layout /&gt;<br/>                  &lt;/YetAnotherProvider&gt;<br/>                &lt;/NeedsAccessToAllProvidersAbove&gt;<br/>              &lt;/GlobalSearchProvider&gt;<br/>            &lt;/ReliesOnUserProviderSoCannotBeMovedUpProvider&gt;<br/>          &lt;/UserProvider&gt;<br/>        &lt;/AuthProvider&gt;<br/>      &lt;/GraphQLProvider&gt;<br/>    &lt;/LayoutProvider&gt;<br/>  );<br/>};</span></pre><p id="0dba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当您的上下文需要访问树中较低位置的状态时，这就成了一个问题。这个问题的解决方案可能涉及将状态移到更高的共享祖先，或者可能将状态存储在一个<em class="ng">是</em>全局可访问的位置。</p><h2 id="1961" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated"><strong class="ak">上下文消费者重新呈现</strong></h2><p id="39ea" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">可以说，使用上下文进行全局状态管理的最大缺陷是，每当上下文值发生变化时，给定上下文的所有使用者都将重新呈现。</p><p id="1927" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这通常是不希望的，因为组件可能只涉及状态的一小部分，并且当没有变化时不需要呈现。</p><p id="14a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决这个问题，你可以创建更多的上下文来负责状态的小片段，或者在memo中包装组件，同时只传递需要的道具给孩子。不幸的是，这两种选择都增加了项目的复杂性，并且没有完全解决根本问题。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="8e98" class="ln lo iq bd lp lq no ls lt lu np lw lx jw nq jx lz jz nr ka mb kc ns kd md me bi translated">比较Zustand和信号</h1><p id="f482" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated"><em class="ng">在下面的沙盒</em>中跟随一个真实的代码示例</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">包含zustand和signal示例的Codesandbox</p></figure><h1 id="ac57" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><strong class="ak">信号介绍</strong></h1><p id="512e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Signals于2022年9月正式发布，现在是Preact核心库的一部分。React包也可用于常规的React项目。</p><p id="2111" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Signals是对状态管理领域的一个特别有趣的补充，因为Preact团队采用了不同于一些更常见的flux (Redux / Rematch / Zustand)和atomic patterns(反冲/ Jotai)的方法。</p><p id="e8ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">他们的主要目标是创建一个尽可能简单、直观和高效的解决方案。该API让人想起Solid JS通过<code class="fe nz oa ob mx b">createSignal</code>提供的状态管理解决方案。灵感也来自以下来源:</p><blockquote class="oc od oe"><p id="e40d" class="kr ks ng kt b ku kv jr kw kx ky ju kz of lb lc ld og lf lg lh oh lj lk ll lm ij bi translated">- Vue:那个。价值获取者</p><p id="8885" class="kr ks ng kt b ku kv jr kw kx ky ju kz of lb lc ld og lf lg lh oh lj lk ll lm ij bi translated">-苗条:总是接受任务，跟踪反应性更新</p><p id="1e8d" class="kr ks ng kt b ku kv jr kw kx ky ju kz of lb lc ld og lf lg lh oh lj lk ll lm ij bi translated">- KnockoutJS + MobX:关于反应性系统的基本原理</p><p id="2b14" class="kr ks ng kt b ku kv jr kw kx ky ju kz of lb lc ld og lf lg lh oh lj lk ll lm ij bi translated">- Solid + S.js:用于信号名称</p><p id="6b6e" class="kr ks ng kt b ku kv jr kw kx ky ju kz of lb lc ld og lf lg lh oh lj lk ll lm ij bi translated">-一些我在2018年职业生涯中开发的专有反应式状态管理系统。它们与solid有很多相似之处，尽管solid要高级得多。</p></blockquote><p id="a87a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae oi" href="https://preactjs.com/blog/introducing-signals/" rel="noopener ugc nofollow" target="_blank">来源</a></p><h2 id="634b" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">用他们的话说</h2><blockquote class="oc od oe"><p id="1ed3" class="kr ks ng kt b ku kv jr kw kx ky ju kz of lb lc ld og lf lg lh oh lj lk ll lm ij bi translated">“信号是管理应用程序状态的反应性原语。</p><p id="4509" class="kr ks ng kt b ku kv jr kw kx ky ju kz of lb lc ld og lf lg lh oh lj lk ll lm ij bi translated">信号的独特之处在于，状态变化会以最有效的方式自动更新组件和UI。自动状态绑定和依赖性跟踪允许信号提供出色的人机工程学和生产力，同时消除最常见的状态管理脚枪。</p><p id="92c8" class="kr ks ng kt b ku kv jr kw kx ky ju kz of lb lc ld og lf lg lh oh lj lk ll lm ij bi translated">信号在任何规模的应用程序中都是有效的，人体工程学加速了小应用程序的开发，性能特征确保任何规模的应用程序在默认情况下都是快速的。"</p></blockquote><p id="2415" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">鉴于signals API是如此的简单和直观，人们几乎可以凭直觉知道事情是如何工作的，而无需阅读大量文档或学习新的思维模型。</p><p id="f913" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">他们的初衷是让下面显示的最简单直观的状态更新场景成为现实。</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="fb73" class="nb lo iq mx b be nc nd l ne nf">// Imagine count is a variable that needs to be accessed through the app<br/><br/>const count = 0;<br/><br/>const Counter = () =&gt; {<br/>  return (<br/>   &lt;button onClick={() =&gt; count++}&gt;<br/>      Value: {count.value}<br/>    &lt;/button&gt;<br/>  );<br/>}</span></pre><p id="18a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">带信号:</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="a9e0" class="nb lo iq mx b be nc nd l ne nf">const count = signal(0);<br/><br/>const Counter = () =&gt; {<br/>  return (<br/>   &lt;button onClick={() =&gt; count.value++}&gt;<br/>      Value: {count.value}<br/>    &lt;/button&gt;<br/>  );<br/>}</span></pre><p id="a2b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">信号的几个重要原则:</p><ul class=""><li id="d9ec" class="oj ok iq kt b ku kv kx ky la ol le om li on lm oo op oq or bi translated">信号在渲染中是参照稳定的(类似于React中的参照)</li><li id="6593" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated">组件可以通过访问`. value '属性来订阅值(不需要选择器)</li><li id="3c70" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated">如果信号的值没有改变，则使用该信号值的组件和效果不会被更新，即使信号的依存关系已经改变。</li><li id="2eb7" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated">自动跟踪信号间的相关性(无相关性数组)</li><li id="347b" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated">Signals能够直接更新DOM中相关的更新部分，而无需重新呈现整个组件(在我看来，这是signals最吸引人的特性)。</li></ul><h1 id="ab64" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><strong class="ak">祖斯坦德简介</strong></h1><p id="3d7f" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Zustand(在德语中翻译为state)是由创建Jotai(日语中为“state”)和React Spring的同一个开发团队创建的。Zustand自2018年发布以来引起了很大的轰动，在过去两年的下载量中轻松超过了反冲。</p><p id="f4dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与Signals类似，Zustand将开发人员的体验放在第一位，并且有一个非常简单的低模板API。熟悉redux的人会觉得Zustand非常好用，因为它遵循Flux原则，并且有许多设计上的相似之处。</p><p id="4559" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用他们的话说:</p><blockquote class="oc od oe"><p id="1acd" class="kr ks ng kt b ku kv jr kw kx ky ju kz of lb lc ld og lf lg lh oh lj lk ll lm ij bi translated">“一个小型、快速和可扩展的bearbones状态管理解决方案，使用简化的flux原则。有一个基于钩子的舒适的api，不是样板或固执己见的。”</p></blockquote><p id="7cda" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一些重要的zustand原则:</p><ul class=""><li id="7771" class="oj ok iq kt b ku kv kx ky la ol le om li on lm oo op oq or bi translated">遵循与Redux / Flux架构相似的设计模式</li><li id="e1ee" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated">使用钩子作为通过选择器访问数据的主要手段</li><li id="cc1c" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated">非独立/灵活</li><li id="51dc" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated">低样板/简单API</li><li id="8918" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated">数据保存在一个单独的存储中(尽管可以将它分开)</li></ul><h1 id="e4e2" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><strong class="ak">我们正在建造什么</strong></h1><p id="54cb" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们将建立一个简单的待办事项列表，以便根据以下标准比较这些库:</p><ul class=""><li id="fea2" class="oj ok iq kt b ku kv kx ky la ol le om li on lm oo op oq or bi translated">开发者体验</li><li id="9e3a" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated">表演</li><li id="e13d" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated">开发者工具</li></ul><h1 id="feb9" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><strong class="ak">开发者体验</strong></h1><h2 id="fbad" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">使用信号<strong class="ak">的设置:</strong></h2><p id="2372" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">设置信号非常简单，只需用<code class="fe nz oa ob mx b">signal()</code>包装一个状态，使其具有反应性:</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="5099" class="nb lo iq mx b be nc nd l ne nf">import { signal } from "@preact/signals-react";<br/><br/>export const lastUpdatedSignal = signal&lt;string&gt;("");<br/><br/>export const inputSignal = signal&lt;string&gt;("");<br/><br/>export const todosSignal = signal&lt;{ text: string; completed: boolean }[]&gt;([<br/>  { text: "test", completed: false },<br/>]);</span></pre><h2 id="9a6e" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated"><strong class="ak">使用Zustand进行设置</strong></h2><p id="1037" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Zustand遵循类似的模式来重新匹配和还原工具包。您创建了包含初始状态和修改它的操作的存储。传统上，状态和功能位于同一位置，如下图所示，然而，也可以在模块级<a class="ae oi" href="https://docs.pmnd.rs/zustand/guides/practice-with-no-store-actions" rel="noopener ugc nofollow" target="_blank">定义动作</a>。</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="d250" class="nb lo iq mx b be nc nd l ne nf">import { ChangeEvent } from "react";<br/>import create from "zustand";<br/><br/>type Todo = { text: string; completed: boolean };<br/><br/>export type TodoState = {<br/>  todos: Todo[];<br/>  lastUpdated?: string;<br/>  input: string;<br/>  handleInput: (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; void;<br/>  addTodo: () =&gt; void;<br/>  toggleIsCompleted: (index: number) =&gt; void;<br/>  removeTodo: (index: number) =&gt; void;<br/>};<br/><br/>export const useTodoStore = create&lt;TodoState&gt;((set) =&gt; ({<br/>  todos: [{ text: "test", completed: false }],<br/>  input: "",<br/>  addTodo: () =&gt; {<br/>    return set((state) =&gt; ({<br/>      todos: [...state.todos, { text: state.input, completed: false }],<br/>      input: "",<br/>    }));<br/>  },<br/>  handleInput: (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {<br/>    set({ input: e.target.value });<br/>  },<br/>  removeTodo: (index: number) =&gt; {<br/>    set((state) =&gt; ({<br/>      todos: state.todos.filter((_, idx) =&gt; idx !== index),<br/>    }));<br/>  },<br/>  toggleIsCompleted: (index: number) =&gt; {<br/>    set((state) =&gt; ({<br/>      lastUpdated: new Date().toLocaleString(),<br/>      todos: state.todos.map((todo, idx) =&gt; {<br/>        if (idx === index) return { ...todo, completed: !todo.completed };<br/>        return todo;<br/>      }),<br/>    }));<br/>  },<br/>}));</span></pre><h2 id="ea06" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">用信号读/写数据</h2><p id="15dc" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">用信号读写数据非常简单。要读取和订阅信号的值，只需访问值属性，例如<code class="fe nz oa ob mx b">mySignal.value</code>。对该值的任何后续更新都将重新呈现该组件。</p><p id="2a7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">写入信号只需要对value属性重新赋值。一个很好的比较心理模型是反应型参考。与ref类似，信号在渲染时也是参考稳定的，因此可以安全地传递给记忆元件。</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="0901" class="nb lo iq mx b be nc nd l ne nf">import { inputSignal, todosSignal, lastUpdatedSignal } from "./todo.signals";<br/>import { InfoBar } from "./info-bar";<br/>import { TodoList, TodoWrapper } from "../components";<br/><br/>const handleInputChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {<br/>  inputSignal.value = e.target.value;<br/>};<br/><br/>const handleAddTodo = () =&gt; {<br/>  todosSignal.value = [<br/>    ...todosSignal.value,<br/>    { text: inputSignal.value, completed: false },<br/>  ];<br/>  inputSignal.value = "";<br/>};<br/><br/>const handleTodoClick = (index: number) =&gt; () =&gt; {<br/>  todosSignal.value = todosSignal.value.map((todo, idx) =&gt;<br/>    idx === index ? { ...todo, completed: !todo.completed } : todo<br/>  );<br/>  lastUpdatedSignal.value = new Date().toLocaleString();<br/>};<br/><br/>const handleRemoveTodo = (index: number) =&gt; {<br/>  todosSignal.value = todosSignal.value.filter((_, idx) =&gt; idx !== index);<br/>};<br/><br/>export const Signals = () =&gt; {<br/>  return (<br/>    &lt;TodoWrapper&gt;<br/>      &lt;InfoBar /&gt;<br/>      &lt;TodoList<br/>        inputValue={inputSignal.value}<br/>        onAddTodo={handleAddTodo}<br/>        onInputChange={handleInputChange}<br/>        onTodoClick={handleTodoClick}<br/>        onRemoveTodo={handleRemoveTodo}<br/>        todos={todosSignal.value}<br/>      /&gt;<br/>    &lt;/TodoWrapper&gt;<br/>  );<br/>};</span></pre><p id="689c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在处理更复杂的嵌套数据时，需要注意的是Preact团队没有实现信号的深度可观测性。<a class="ae oi" href="https://github.com/pmndrs/zustand/issues/106" rel="noopener ugc nofollow" target="_blank">这意味着总是需要更换整个顶层”。值”属性或嵌套信号</a>。</p><h2 id="2e24" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated"><strong class="ak">派生状态</strong></h2><p id="b999" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在我们的待办事项应用程序的<code class="fe nz oa ob mx b">&lt;InfoBar /&gt;</code>部分，我们希望访问我们的信号，以显示最后更新的时间以及已完成待办事项的计数。</p><p id="0220" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们不希望组件在每次修改<code class="fe nz oa ob mx b">todosSignal</code>时都重新呈现，所以我们可以用导出的“计算”函数包装它。</p><p id="7a96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该函数将仅在返回值不同时触发重新呈现(在我们的例子中，是完成的todos的新计数),并且还在计算函数内的信号依赖性改变时重新运行。</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="2481" class="nb lo iq mx b be nc nd l ne nf">import { memo } from "react";<br/>import classes from "./InfoBar.module.scss";<br/>import { lastUpdatedSignal, todosSignal } from "../todo.signals";<br/>import { computed } from "@preact/signals-react";<br/><br/>export const InfoBar = memo(() =&gt; {<br/>  const totalCompleted = computed(<br/>    () =&gt; todosSignal.value.filter((t) =&gt; t.completed).length<br/>  );<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;div className={classes.infoContainer}&gt;<br/>        &lt;p&gt;Total Completed:&lt;/p&gt;<br/>        &lt;p&gt;{totalCompleted.value}&lt;/p&gt;<br/>      &lt;/div&gt;<br/>      &lt;div className={classes.infoContainer}&gt;<br/>        &lt;p&gt;Last Updated:&lt;/p&gt;<br/>        &lt;p&gt;{lastUpdatedSignal.value}&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    &lt;/&gt;<br/>  );<br/>});</span></pre><h2 id="e2d0" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">使用Zustand读取/写入数据</h2><p id="fef2" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">由于Redux中的选择器模式，在Zustand中读取和写入数据对许多人来说可能很熟悉，其中一个主要区别是Zustand选择器包含状态和动作。</p><p id="f776" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面，我们从我们的商店中选择所有需要的东西，以连接我们的待办事项列表。默认情况下，Zustand会对新旧值进行严格的相等检查。</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="8603" class="nb lo iq mx b be nc nd l ne nf">// Only re-renders component if input !== previous input<br/>const input = useTodoStore(state =&gt; state.input)</span></pre><p id="c56d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们返回的是一个带有状态和动作的对象，而且对象在不同的渲染中不是稳定的，所以我们需要将Zustand的“shallow”实用函数作为第二个参数传递给shallowly diff对象属性。如果以下任何值发生变化，我们的组件将重新呈现。</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="e474" class="nb lo iq mx b be nc nd l ne nf">import { TodoList, TodoWrapper } from "../components";<br/>import { useTodoStore } from "./todoStore";<br/>import shallow from "zustand/shallow";<br/>import { InfoBar } from "./info-bar";<br/><br/>export const Zustand = () =&gt; {<br/>  const { todos, handleInput, addTodo, toggleIsCompleted, input, removeTodo } =<br/>    useTodoStore((state) =&gt; {<br/>      return {<br/>        removeTodo: state.removeTodo,<br/>        input: state.input,<br/>        lastUpdated: state.lastUpdated,<br/>        todos: state.todos,<br/>        handleInput: state.handleInput,<br/>        addTodo: state.addTodo,<br/>        toggleIsCompleted: state.toggleIsCompleted,<br/>      };<br/>    }, shallow);<br/><br/>  const handleTodoClick = (idx: number) =&gt; () =&gt; toggleIsCompleted(idx);<br/><br/>  return (<br/>    &lt;TodoWrapper&gt;<br/>      &lt;InfoBar /&gt;<br/>      &lt;TodoList<br/>        inputValue={input}<br/>        onAddTodo={addTodo}<br/>        onInputChange={handleInput}<br/>        onTodoClick={handleTodoClick}<br/>        todos={todos}<br/>        onRemoveTodo={removeTodo}<br/>      /&gt;<br/>    &lt;/TodoWrapper&gt;<br/>  );<br/>};</span></pre><p id="caef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将数据写入Zustand存储需要使用“set”函数，该函数包括带有先前状态的回调。方便地设置自动合并顶级状态，以避免需要在每次更新时扩散，但是更多的嵌套更新仍然需要合并嵌套值。<a class="ae oi" href="https://github.com/pmndrs/zustand#read-from-state-in-actions" rel="noopener ugc nofollow" target="_blank">动作中还有一个getter函数</a>，可以调用它来检索状态片段，而无需更新数据。</p><h2 id="e594" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">派生状态</h2><p id="5749" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在访问下面的<InfoBar/>组件中的数据时，我们对数组中的返回值进行了简单的区分。因此，该组件将仅在原始值改变时重新呈现(类似地通过用信号“计算”来完成)。</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="7b96" class="nb lo iq mx b be nc nd l ne nf">import { memo } from "react";<br/>import classes from "./InfoBar.module.scss";<br/>import { useTodoStore } from "../todoStore";<br/>import shallow from "zustand/shallow";<br/><br/>export const InfoBar = memo(() =&gt; {<br/>  const [lastUpdated, totalCompleted] = useTodoStore(<br/>    (state) =&gt; [<br/>      state.lastUpdated,<br/>      state.todos.filter((todo) =&gt; todo.completed).length,<br/>    ],<br/>    shallow<br/>  );<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;div className={classes.infoContainer}&gt;<br/>        &lt;p&gt;Total Completed:&lt;/p&gt;<br/>        &lt;p&gt;{totalCompleted}&lt;/p&gt;<br/>      &lt;/div&gt;<br/>      &lt;div className={classes.infoContainer}&gt;<br/>        &lt;p&gt;Last Updated:&lt;/p&gt;<br/>        &lt;p&gt;{lastUpdated}&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    &lt;/&gt;<br/>  );<br/>});</span></pre><h1 id="097f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">表演</h1><h2 id="bcad" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">信号性能</h2><p id="be9c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Zustand和Signals都提供了防止不必要的重新渲染以提高性能的方法，但是Signals有几个额外的优化，部分是受其他反应库的启发。</p><p id="4a7d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，让我们更仔细地看看“计算”函数。任何用“computed”包装的信号只有在它的“computed”被调用时才会懒洋洋地运行。值”属性。如果导出的值很昂贵，并且只在某些情况下需要，例如在一些用户交互之后呈现子组件，那么这可能是有帮助的。</p><p id="25dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为计算函数中的依赖关系也是自动跟踪的，所以只有当这些封闭信号中的任何一个被修改时，信号才会重新计算，否则返回以前缓存的值。不需要依赖数组！</p><p id="1ad1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为计算值本身只是信号，所以它们可以在其他计算值中使用。有趣的是，你可以看看幕后的双向链表是如何被用来管理信号依赖性和依赖关系的。</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="ee52" class="nb lo iq mx b be nc nd l ne nf">  // Cached by default<br/>  // Only recomputes when accessed or when todosSignal.value changes<br/>  const totalCompleted = computed(<br/>    () =&gt; todosSignal.value.filter((t) =&gt; t.completed).length<br/>  );</span></pre><p id="e002" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可以说，signals最与众不同的性能特性之一是能够将信号值直接传递给JSX，并在DOM中将其呈现为文本，而无需重新呈现包含它的组件。这可以极大地提高性能，因为正在更新的组件的任何子组件都不会重新呈现。</p><p id="0db3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着确保你所有的道具都是参照稳定的道具，并且孩子在组件树中被记忆的位置更低，这样的精神开销就更少。</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="415c" class="nb lo iq mx b be nc nd l ne nf">const count = signal(0);<br/><br/>const Unoptimized = () =&gt; {<br/>// Re-renders the component when `count` changes:<br/>return &lt;p&gt;{count.value}&lt;/p&gt;;<br/>}<br/><br/>const Optimized = () =&gt; {<br/>// Text automatically updates without re-rendering the component:<br/>return &lt;p&gt;{count}&lt;/p&gt;;<br/>}</span></pre><p id="340b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过跳过重新渲染整个组件，可以跳过中间子组件的重新渲染，如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/526ee9e8f2d624a15acf9efd1e9e720c.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*OYBwm7LkSVb3US8ZaEdIRw.png"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">(来自Signals documentati)</p></figure><h2 id="ebda" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">使用Zustand的性能</h2><p id="494e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Zustand提供了几个不错的开箱即用的优化。对于one，来自选择器的值被自动检查是否严格相等，如果没有变化，则退出渲染。</p><p id="98ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于从选择器返回的数组和对象，Zustand提供了一个方便的shallow diff比较函数，可以作为第二个参数传递给store钩子。或者，您可以编写自己的比较函数来进行更细粒度的控制。</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="d646" class="nb lo iq mx b be nc nd l ne nf">  const { todos, removeTodo } =<br/>    useTodoStore((state) =&gt; {<br/>      return {<br/>        removeTodo: state.removeTodo,<br/>        todos: state.todos,<br/>      };<br/>    },<br/>    // Custom compare function <br/>    (prevState, nextState) =&gt; myCompareFunction(prevState, nextState)<br/>   );</span></pre><p id="55e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与使用Zustand中的选择器相比，我在比较信号中的派生状态与计算值时注意到一个轻微的缺点，即Zustand选择器<em class="ng">总是</em>在存储更新时运行，并且只在进行diff比较后防止重新渲染。</p><p id="a041" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于信号值的性质更加模块化，计算的函数可以不那么频繁地根据相关性变化运行。这意味着Zustand中昂贵的选择器函数可能会被不必要地调用，只是为了以后确定新的和以前的返回值是相同的。当然有可能有较小的Zustand商店来防止这一问题，但这可能会带来新的挑战。在现实世界中，这对于大多数人来说可能不是问题。</p><h2 id="2198" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated"><strong class="ak">信号</strong></h2><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="7135" class="nb lo iq mx b be nc nd l ne nf">  // Only runs if todosSignal Changes<br/><br/>  const totalCompleted = computed(<br/>    () =&gt; todosSignal.value.filter((t) =&gt; t.completed).length<br/>  );    </span></pre><h2 id="9558" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated"><strong class="ak">祖斯坦德</strong></h2><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="b302" class="nb lo iq mx b be nc nd l ne nf">// Runs every time the store changes<br/>  // Only updates if returned values don't pass strict equality check<br/><br/>  const [lastUpdated, totalCompleted] = useTodoStore(<br/>    (state) =&gt; [<br/>      state.lastUpdated,<br/>      state.todos.filter((todo) =&gt; todo.completed).length,<br/>    ],<br/>    shallow<br/>  );</span></pre><h1 id="2582" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">开发者工具</h1><p id="6478" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">相对于其同行，Zustand已经建立了相当多的追随者，因此，已经建立了一个丰富的第三方附加库生态系统。本地存储持久化、表单助手插件、MobX API适配器等等。Zustand还提供了与redux devtools的简单集成，以提供跨应用程序的可观察性。</p><p id="e996" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Signals是国家管理领域的一个相对较新的公司，不具备同样强大的生态系统，但随着时间的推移，这种情况可能会发生变化。</p><p id="4780" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据npm趋势下载历史，Zustand的未来看起来很光明，在一个图书馆来来去去的世界里，重要的是要批判性地思考应该把赌注压在哪匹马上。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/f33e92ed4716aa6852e87c9b4f853151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-a8qoNj8LFGYo9NimUm6zQ.png"/></div></div></figure><p id="de96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还需要注意的是，在撰写本文时，signals在React中不支持并发模式，但是<a class="ae oi" href="https://twitter.com/sebmarkbage/status/1567286781153878021?s=20" rel="noopener ugc nofollow" target="_blank">有人提到</a>将来会增加一个“并发模式安全”。</p><h1 id="befd" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">结束语</h1><p id="a39a" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Signals无疑是react state管理人员名单中一个令人兴奋的新成员，我期待着在未来几年看到它的发展。用于信号的开发工具将是一个非常好的补充，但是这个功能完全有可能在将来被添加。值得注意的是，信号仍然非常新，还没有像Zustand一样经过战斗考验。</p><p id="b369" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目前，我认为我个人仍然会在大型生产应用程序中使用Zustand over Signals，原因有几个。一个是Flux和Redux模式(这是Zustand的灵感来源)在这一点上已经很好理解，很容易掌握。由于Signal缺乏对嵌套数据的深度反应，可能需要更多的时间和思考来构建数据。</p><p id="0f68" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还需要注意的是，React signals包使用了<a class="ae oi" href="https://github.com/preactjs/signals/blob/d25e8bac09c94ed3bad7f12fe380becd8bf1a7ad/packages/react/src/index.ts#L6" rel="noopener ugc nofollow" target="_blank">内部React API</a>，包括有趣的名称<code class="fe nz oa ob mx b">__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED</code>。这可能会造成一些停顿，因为随着时间的推移，这些内部API可能不稳定。也就是说，信号的开发人员工效学和在状态改变时直接换出DOM中的文本的能力非常有吸引力。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h2 id="b245" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated"><strong class="ak">延伸阅读</strong></h2><ul class=""><li id="6be7" class="oj ok iq kt b ku mf kx mg la oz le pa li pb lm oo op oq or bi translated"><a class="ae oi" href="https://codesandbox.io/s/github/kevinschaffter/zustand-signals" rel="noopener ugc nofollow" target="_blank">并排使用zustand和signals的Codesandbox】</a></li><li id="4c30" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated"><a class="ae oi" href="https://preactjs.com/blog/introducing-signals/" rel="noopener ugc nofollow" target="_blank">引入信号—preactjs.com</a></li><li id="a42b" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated"><a class="ae oi" href="https://preactjs.com/blog/signal-boosting/" rel="noopener ugc nofollow" target="_blank">信号增强——信号构建的幕后场景</a></li><li id="9a16" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated"><a class="ae oi" href="https://docs.pmnd.rs/zustand/getting-started/introduction" rel="noopener ugc nofollow" target="_blank"> Zustand文档</a></li></ul></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h2 id="65d1" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated"><strong class="ak">关于优化健康</strong></h2><p id="a40e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Optimize Health是远程护理解决方案的市场领导者，帮助全国各地的提供者团体提供超越实践墙的高质量护理。通过领先的平台技术、托管服务和专家支持的强大组合，我们帮助客户和患者在门诊之外建立更深的联系，并更快地获得更好的结果。了解详情，请访问:<a class="ae oi" href="https://stats.newswire.com/x/html?final=aHR0cDovL3d3dy5vcHRpbWl6ZS5oZWFsdGgv&amp;hit%2Csum=WyIzcnh2Z2QiLCIzcnh2Z2UiLCIzcnh2ZnkiXQ" rel="noopener ugc nofollow" target="_blank"> www.optimize.health </a>。</p></div></div>    
</body>
</html>