<html>
<head>
<title>Using Flask to Build a Simple API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Flask构建简单的API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/setting-up-a-simple-api-b3b00bc026b4?source=collection_archive---------6-----------------------#2019-05-23">https://betterprogramming.pub/setting-up-a-simple-api-b3b00bc026b4?source=collection_archive---------6-----------------------#2019-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f673" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我认识弗拉斯克的旅程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/227da00194985d71330a7c6861c2ac57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JGDhEOqWVmzqofJ7xSS0KA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/photos/D9Zow2REm8U?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">希特什·乔杜里</a>在<a class="ae kv" href="https://unsplash.com/search/photos/python-flask?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="f7f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，我一直在处理数据并创建可以预测的模型…无论我训练它们预测什么！我使用来自动物收容所的数据集来创建一个模型，该模型将根据动物的摄入细节(品种、颜色、大小、位置等)来预测动物在收容所的结局。)</p><p id="a415" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建和调整这些模型是令人着迷的，但是希望有一天有人会想要使用我以自动化的方式构建的模型。理想情况下，这不需要他们打开我的Jupyter笔记本，运行所有的单元格来获得预测。为了避免这种情况，我需要设置一个API来接受输入(更确切地说，是特性)，并根据我训练的模型做出预测。</p><h1 id="0400" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">你好烧瓶</h1><p id="677c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">根据其<a class="ae kv" href="http://flask.pocoo.org/" rel="noopener ugc nofollow" target="_blank">登陆页面</a>，Flask是<em class="mp">“一个基于Werkzeug、Jinja 2和good intentions的Python微框架。”</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/e5e88a9175f2343db8c14490f340c090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D7XsM2HLMXct48ssUAf-Lg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="http://flask.pocoo.org/" rel="noopener ugc nofollow" target="_blank">http://flask.pocoo.org/</a></p></figure><p id="861a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，Flask有助于用Python构建生产就绪的应用程序。我发现Flask特别吸引人，因为它的入门门槛很低——它们让入门变得极其容易！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/2b16c9f54412e1f2e145e5b0453d7ea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uxfi758BmE-LBUVKbrhlKA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">这是直接从他们的登陆页面</p></figure><p id="8ed9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在到达他们的网页的几秒钟内，你就可以启动并运行一个基本的应用程序。只需复制您看到的python代码并保存为“hello.py”，从您的终端安装pip flask，然后运行您的“hello”flask应用程序！</p><p id="698b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只用几行代码，Flask就帮助我启动了一个简单的内置API服务器。太简单了！</p><h1 id="1cd1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">启动并运行</h1><p id="0830" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在我是Flask pro(笑话！)，我可以将“hello”应用程序的基本格式应用到我最初创建的应用程序中。在处理一个模型之前，我从小处着手，决定尝试通过返回“hello，{name}！”来为我的“hello.py”文件添加功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="879e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对Flask文档的快速搜索揭示了一个简单的解决方案。我只需<strong class="ky ir">导入请求</strong>并<strong class="ky ir">将</strong> <code class="fe mu mv mw mx b">name = request.args.get('name')</code>添加到我的“hello.py”文件中。成功了！</p><p id="e367" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过添加请求代码，我能够将一个参数(名称)放入URL，API将返回一个定制的问候。它看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/4ff03ec86152fcf60bde2129b6c79e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*izgiWGXDVSPgoRQAs4hJ4A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个令人兴奋的开始，但不是我想要的</p></figure><p id="498f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这很酷，但不是我想要的。向URL中添加大量参数似乎很繁琐——我需要找到一种更好的方法。</p><h2 id="b64a" class="mz lt iq bd lu na nb dn ly nc nd dp mc lf ne nf me lj ng nh mg ln ni nj mi nk bi translated">初学者的快速笔记</h2><p id="5bb4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在是注意的好时机，每次我改变我的。py文件，我不得不关闭正在运行的flask实例(在我的终端中ctrl+c ),并在刷新我的浏览器之前重新运行<code class="fe mu mv mw mx b">$ flask run</code>。这有点痛苦，直到我发现运行<code class="fe mu mv mw mx b">$flask run —-reload</code>告诉flask在保存python文件时自动重新加载代码。</p><h1 id="6133" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">向上拉平</h1><p id="290c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">同样，为了获得额外的功能，我只需要对我的python文件进行微小的修改。然而，要完全理解我所做的改变，我需要了解更多关于API服务器的基本功能。据我所知，Flask促进了我编写的python脚本(它将充当API服务器)和来自客户端(即Web浏览器)的任何传入请求之间的通信。根据<a class="ae kv" href="https://restful.io/@gonzalovazquez?source=user_popover" rel="noopener ugc nofollow" target="_blank"> Gonzalo Vázquez </a>的说法，一个有效的请求需要四样东西:URL、方法、标题列表和主体。下面我将集中讨论前两个，因为我需要配置我的API来处理这些。幸运的是，Flask让这变得很容易。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="8591" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您将这段代码与上一段代码进行比较，您可以看到<strong class="ky ir">装饰器</strong>发生了变化。通过简单地添加这个装饰器，我已经配置了一个URL，客户端可以在那里与API进行交互，并且我已经告诉Flask，它可以在那里引导我的API将接受的两种不同类型的请求。一个来自客户端的<code class="fe mu mv mw mx b">['GET']</code>请求请求服务器检索一个资源——在本例中，它将检索我添加的HTML(可以通过web浏览器呈现为带有提交按钮的提交表单)。一个<code class="fe mu mv mw mx b">['POST']</code>请求要求服务器创建一个资源(即使用输入返回输出)。</p><p id="52ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设置好这个API服务器后，从我的web浏览器访问它看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/f6ab3bb3dd4b367f0ca5bbbb26c9a39a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*wt7Yvbo0oCYlaOBl0-NuCg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">参赛表格—用户可以输入他们的名字，然后点击“提交”</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/d89770093ab20ef0f0c0df4e32754112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*fa5IsAkT50k6CmykkEFBpQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">点击“提交”后输出！</p></figure><p id="d36f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">真的很酷！是时候看看我是否能让这个为一个模特工作了。</p><h1 id="92d9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">泡菜</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/6d92af2d525f2e95e1f95d9cdc3999c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z2X0KissintC_OOY86ueGw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">不是这种泡菜。Monika Grabkowska 在<a class="ae kv" href="https://unsplash.com/search/photos/pickle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8b9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我的模型通过API进行预测的一个重要步骤是酸洗。我腌了我的<code class="fe mu mv mw mx b">LabelEncoder</code>、<code class="fe mu mv mw mx b">PolynomialFeatures</code>，还有我的模型本身。基本上，任何符合我的数据的东西都被剔除了。这允许我在新的python文件中快速调用这些模型，而不需要在每次API服务器启动时重新训练模型。</p><p id="2c0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过酸洗我的<code class="fe mu mv mw mx b">LabelEncoder</code>和我的<code class="fe mu mv mw mx b">PolynomialFeatures</code>，它可以接受字符串作为输入，只需要基本的特性。因为这两个都已经符合我的数据，所以我简单地对每个的输入特性调用<code class="fe mu mv mw mx b">.transform()</code>,就像我在Jupyter笔记本上训练它们之后所做的那样。</p><p id="40a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至于我的模型，一旦加载了pickled模型，我只需在我的编码特性上调用<code class="fe mu mv mw mx b">.predict()</code>，它就会返回一个预测。</p><h1 id="82e2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">动物收容所结果预测</h1><p id="7ef8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">下面的代码展示了我如何设置一个API服务器来产生一个基于动物特征的预测。如您所见，它与我的“hello.py”文件具有相同的基本特性——装饰器告诉Flask可以访问它的URL、它将接受的请求类型以及如何响应这些请求。唯一的区别是我创建了一个渲染模板来保存HTML(因为HTML又长又丑)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">看看这些泡菜！</p></figure><p id="5930" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">响应我的web浏览器的API如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/3005dd63b7cc8a1fd2a8654964a794f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*OuU8LyAwylM_R1782mlSXQ.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/6cd5bb07d03a70db5182a8fe4401cd04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*rQgy35FrOXgZw0ihxoVJBw.png"/></div></figure><h1 id="fb32" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="2fca" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Flask非常容易上手，并且有很好的文档。它还提供模板，使您的应用程序创建尽可能无痛。我仅仅触及了Flask及其用途的表面，但是我已经能够将我正在构建的这些有用的模型转化为Python环境之外的有用的东西。</p><p id="d9a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mp">所有代码在我的</em> <a class="ae kv" href="https://github.com/MsJacksonIYN/first_flask_app" rel="noopener ugc nofollow" target="_blank"> <em class="mp"> Github </em> </a>上都有</p></div></div>    
</body>
</html>