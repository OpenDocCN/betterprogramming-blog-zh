<html>
<head>
<title>How to Store a Codable Model Offline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何离线存储可编码模型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-store-a-codable-model-offline-693329470b2?source=collection_archive---------6-----------------------#2020-05-08">https://betterprogramming.pub/how-to-store-a-codable-model-offline-693329470b2?source=collection_archive---------6-----------------------#2020-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="24cb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在一个. json文件中保持您的模型离线，并在离线时为存储和提取模型编写通用代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0b9ab1956161f93083b0a2f516743504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BjzwKm01r6N9EdYWPTy8ew.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@japyassu?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">thiago japyasu</a>从<a class="ae ky" href="https://www.pexels.com/photo/silver-iphone-x-beside-succulent-plant-1069798/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄</p></figure><p id="b817" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数时候，我们可能需要像<code class="fe lv lw lx ly b">CoreData, UserDefaults, SQLite</code>一样在存储中保持模型数据离线，但是可能一些开发人员不想花太多时间来创建核心日期实体或数据库表，这需要更多的代码，并且存储巨大的数据库是很好的。</p><p id="f12a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将模型数据保留在应用程序中而不在应用程序中创建任何数据库的替代解决方案。我们将使用<code class="fe lv lw lx ly b">.json</code>文件来保存和检索我们的可编码模型。</p><h2 id="b442" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">先说流程</h2><p id="56f5" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我们有学生模型。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="aa5e" class="lz ma it ly b gy nc nd l ne nf">struct <strong class="ly iu">Students</strong>: <strong class="ly iu">Codable</strong>{<br/>    let name, section, rank: <strong class="ly iu">String</strong><br/>}</span></pre><p id="1e3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mx">我们有几行代码用于在</em> <code class="fe lv lw lx ly b"><em class="mx">FileManager</em></code> <em class="mx">和JSONEncoder内创建一个</em> <code class="fe lv lw lx ly b"><em class="mx">.json</em></code> <em class="mx">文件，用于将我们的模型转换成数据形式。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="1345" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">让我们保存并获取我们的可编码模型</h2><p id="8c03" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">如果你是第一次接触Codable，请查看我之前的文章关于Swift中的Codable。</p><p id="e754" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">离线保存模型</p><p id="fa22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">let status = try <strong class="lb iu">save</strong>(students, <strong class="lb iu">for</strong>: “Students”)</code></p><p id="c831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mx">在那一行中，我们调用</em> <code class="fe lv lw lx ly b"><em class="mx">save</em></code> <em class="mx">函数为一个学生模型取</em> <code class="fe lv lw lx ly b"><em class="mx">“Students”</em></code> <em class="mx">文件名。</em></p><h2 id="5318" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">离线提取模型</h2><p id="3f42" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><em class="mx">对于离线获取模型日期，我们需要将文件名传入</em> <strong class="lb iu"> <em class="mx">函数</em> </strong> <em class="mx">，它将返回</em> <strong class="lb iu"> <em class="mx">学生</em> </strong> <em class="mx">模型。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4114" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">获取模型</strong></p><p id="2bf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">let model = try <strong class="lb iu">loadJSON</strong>(withFilename: “Student”)</code></p><p id="6869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们知道了保存和获取模型以供离线使用的过程，并且不能为了保存和获取的目的而为每一个模型编写这样的代码。所以我们可以为它编写一个通用代码。对于相同的代码，从一个地方处理将会很容易。</p><p id="69a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们将使用枚举来代替类或结构创建泛型代码。这将很容易使用，不需要初始化。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="a7f1" class="lz ma it ly b gy nc nd l ne nf">enum <strong class="ly iu">FileUtility</strong>&lt;Value: <strong class="ly iu">Codable</strong>&gt;{<br/>    case fileName<br/>}</span></pre><p id="8e85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mx">现在我们要给模型添加文件名基础:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="87a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mx">我们将把</em> <strong class="lb iu"> <em class="mx">文件</em> </strong> <em class="mx"> </em> <code class="fe lv lw lx ly b"><em class="mx">Enum</em></code> <em class="mx">添加到我们之前列举的案例:</em></p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="4548" class="lz ma it ly b gy nc nd l ne nf">enum <strong class="ly iu">FileUtility</strong>&lt;Value: <strong class="ly iu">Codable</strong>&gt;{<br/>    case fileName(<strong class="ly iu">Files</strong>)<br/>}</span></pre><p id="6dc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在扩展中，我们有保存和获取的功能。这些函数将有功能为<code class="fe lv lw lx ly b">Encoding &amp; Decoding</code>你的模型为<code class="fe lv lw lx ly b">.json</code>文件到<code class="fe lv lw lx ly b">Data</code>。</p><p id="39c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些方法将是私有的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="813f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只公开这些来访问JSON文件中的保存值和获取值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ce18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个功能，我们可以轻松地让我们的可编码模型离线。这个通用代码将只支持可编码模型。</p><p id="7e81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码的使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="3015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通用Emun需要具有文件名和操作名的模型。它易于使用和理解。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="8cd4" class="np ma it bd mb nq nr ns me nt nu nv mh jz nw ka mk kc nx kd mn kf ny kg mq nz bi translated">结论</h1><p id="9ca3" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">这是从<code class="fe lv lw lx ly b">.json</code>文件中保存和获取模型的快捷解决方案。你不能用这个代替<code class="fe lv lw lx ly b">CoreData</code>或<code class="fe lv lw lx ly b">SQLite</code>。你可以用这个功能代替<code class="fe lv lw lx ly b">UserDefaults</code> <code class="fe lv lw lx ly b">UserDefaults</code>是一个强大的API大多数开发人员喜欢在沙箱中保存少量数据。你可以用<code class="fe lv lw lx ly b">UserDefaults</code>做同样的事情。至于你喜欢哪一个，完全是你自己的选择。通过将数据保存在文件管理器中，没有任何限制—这是tt的另一个替代解决方案。</p><p id="1c6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你<a class="ae ky" href="https://medium.com/better-programming/userdefaults-in-swift-4-d1a278a0ec79" rel="noopener">可能也更喜欢</a> <code class="fe lv lw lx ly b"><em class="mx">UserDefaults</em></code>。</p><p id="302b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为更大的尺寸，获取和保存你的模型数据需要时间，所以你应该记住。这在您的代码中很容易使用，但是您需要小心使用它，并且您需要正确地提供文件名和模型类型。</p><p id="2910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以从这里获得完整的源代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div></div>    
</body>
</html>