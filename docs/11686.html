<html>
<head>
<title>Understanding Smart Pointers in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解C++中的智能指针</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/smart-pointers-in-cpp-708486276526?source=collection_archive---------3-----------------------#2022-04-08">https://betterprogramming.pub/smart-pointers-in-cpp-708486276526?source=collection_archive---------3-----------------------#2022-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0766" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更聪明地工作，而不是更努力</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5054fdd9991494b6a8be60f14f954667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ss_LylfOEI_oHiRaBTQw_A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">米拉德·法库里安在<a class="ae ky" href="https://unsplash.com/photos/58Z17lnVS4U" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="26f9" class="le lf it la b gy lg lh l li lj"><strong class="la iu">Table of Contents</strong></span><span id="feb2" class="le lf it la b gy lk lh l li lj">· <a class="ae ky" href="#5ac0" rel="noopener ugc nofollow">Introduction</a><br/>· <a class="ae ky" href="#306d" rel="noopener ugc nofollow">The Problem</a><br/>· <a class="ae ky" href="#f76b" rel="noopener ugc nofollow">The Solution</a><br/>· <a class="ae ky" href="#6768" rel="noopener ugc nofollow">To access smart pointers:</a><br/>· <a class="ae ky" href="#34de" rel="noopener ugc nofollow">Sample Usage</a><br/>· <a class="ae ky" href="#1ef6" rel="noopener ugc nofollow">Questions</a><br/>  ∘ <a class="ae ky" href="#d2dc" rel="noopener ugc nofollow">Why was the constructor invoked but not the destructor?</a><br/>  ∘ <a class="ae ky" href="#e6cc" rel="noopener ugc nofollow">What if we pass a std::unique_ptr by value to a function?</a><br/>  ∘ <a class="ae ky" href="#2773" rel="noopener ugc nofollow">Why use the heap? Stacks manage memory automatically.</a><br/>· <a class="ae ky" href="#e77c" rel="noopener ugc nofollow">Conclusion</a><br/>· <a class="ae ky" href="#76e3" rel="noopener ugc nofollow">Supplemental Material</a><br/>  ∘ <a class="ae ky" href="#fe65" rel="noopener ugc nofollow">[1] Stack and Heap, Franziska Hinkelmann</a><br/>  ∘ <a class="ae ky" href="#64c1" rel="noopener ugc nofollow">[2] Pointers, Kale Blankenship</a><br/>  ∘ <a class="ae ky" href="#b6ad" rel="noopener ugc nofollow">[3] Pointers and References, Teri Radichel</a><br/>  ∘ <a class="ae ky" href="#d8cb" rel="noopener ugc nofollow">[4] Heap versus Stack for Python Programmers, Naser Tamimi</a><br/>  ∘ <a class="ae ky" href="#44c1" rel="noopener ugc nofollow">[5] Stack, Heaps, and Pointers, Young Coder</a></span></pre><h1 id="eb69" class="ll lf it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="4e25" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi my translated"><span class="l mz na nb bm nc nd ne nf ng di"> C </span> ++智能指针是类对象，其行为类似于原始指针，但是管理在堆上创建的对象的生命周期。它们在软件开发中非常有用，因为它们自动化了删除对象的过程，并有助于防止内存泄漏。这个博客系列将讨论智能指针的基础知识以及如何在C++程序中使用它们。具体来说，我们现在讨论基础知识，下面的博客将深入讨论不同类型的智能指针。</p><p id="60db" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">在此完成后，查看该系列的第二部分和第三部分的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/understanding-smart-pointers-in-cpp-6c3854593503?sk=6ad6b404237c36c4b10a5c3b65a724d9">。</a></p><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/understanding-smart-pointers-in-cpp-6c3854593503"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">现代C++:智能指针的近距离观察</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">“理解智能指针”的续篇</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">better编程. pub</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ks np"/></div></div></a></div><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/understanding-smart-pointer-iii-909512a5eb05"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">通过直观的视觉效果解释C++智能指针</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">我的C++指针系列的第3部分</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">better编程. pub</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od ks np"/></div></div></a></div><h1 id="5ac0" class="ll lf it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">介绍</h1><p id="ada4" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi my translated"><span class="l mz na nb bm nc nd ne nf ng di"> S </span>智能指针是类对象，其行为类似于内置指针，并管理通过new创建的对象，因此无需担心何时以及是否删除——智能指针会在适当的时间自动删除被管理的对象。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="8e29" class="le lf it la b gy lg lh l li lj"><strong class="la iu">💡</strong> Wait, so it is the job of the developer to manage memory allocation and, hence, the deallocation? <em class="of">Short answer: it depends on whether the memory is of the heap or stack.</em> Stacks (aka run-time stack) is responsible for program execution and function calls. The heap, independent of the stack, is extra storage available for dynamically storing objects. The sequentially stored items of the stack are processed frame by frame: destroyed once popped off. The heap stores memory in no sort of order, dynamically, and preserved until deleted explicitly. See [1] for more on heaps and stacks.</span></pre><p id="ff50" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">智能指针在语法上得到定义和使用，几乎与内置(或原始)指针完全一样。在许多情况下，我们可以用智能指针代替普通指针。本质上，通过简单地用智能指针替换普通指针来做同样的事情。有关指针的更多信息，请参见[2]。</p><p id="665e" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">智能指针包含一个内置指针，作为其模板类的一部分，模板类的类型参数是所指向对象的类型，因此我们可以声明指向任何种类的类对象的智能指针。当谈到动态分配的对象时，我们经常谈论谁拥有它们。拥有某物意味着它是你的，你可以随意保留或销毁。在C++中，所有权不仅指引用或使用对象的代码，更重要的是指负责删除对象的代码。</p><p id="4845" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">我们实现了<em class="of">所有权</em>关于在哪里用智能指针释放对象的内存。如果我们没有正确执行<em class="of">所有权</em>，我们可能会因为试图跟踪指向不再存在的对象的指针而导致内存泄漏或意外行为。</p><p id="a5a7" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">智能指针通过删除智能指针析构函数(即对象被删除的地方)使得正确实现<em class="of">所有权</em>变得更加容易。由于编译器确保在销毁对象时调用类对象的析构函数，智能指针销毁可以自动处理指向对象的删除。智能指针<em class="of">拥有</em>对象并为我们删除它。</p><p id="fdc8" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">这个博客系列从智能指针的概述开始:问题、类型和用法。然后，我们将研究作为C++标准库一部分的三个类。</p><ol class=""><li id="9a06" class="og oh it me b mf nh mi ni ml oi mp oj mt ok mx ol om on oo bi translated"><code class="fe op oq or la b">std::unique_ptr</code> ( <a class="ae ky" href="https://en.cppreference.com/w/cpp/memory/unique_ptr" rel="noopener ugc nofollow" target="_blank">来源</a>)</li><li id="5f44" class="og oh it me b mf os mi ot ml ou mp ov mt ow mx ol om on oo bi translated"><code class="fe op oq or la b">std::shared_ptr</code> ( <a class="ae ky" href="https://en.cppreference.com/w/cpp/memory/shared_ptr" rel="noopener ugc nofollow" target="_blank">来源</a>)</li><li id="4e86" class="og oh it me b mf os mi ot ml ou mp ov mt ow mx ol om on oo bi translated"><code class="fe op oq or la b">std::weak_ptr</code> ( <a class="ae ky" href="https://en.cppreference.com/w/cpp/memory/weak_ptr" rel="noopener ugc nofollow" target="_blank">来源</a>)</li></ol><p id="4f2a" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">命名方案反映了功能，每个方案都有特定的用途；所选择的智能指针类型因使用情况而异。</p><p id="4c1b" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">在继续基础知识之前，让我们首先定义列出的类型:(1) <code class="fe op oq or la b">unique_ptr</code>实现唯一的<em class="of">所有权</em> —一次只有一个智能指针<em class="of">拥有</em>对象；销毁拥有智能指针的<em class="of">时，拥有<em class="of">智能指针的</em>对象自动销毁。<code class="fe op oq or la b">shared_ptr</code>②实行共有<em class="of">所有制</em>。任意数量的智能指针共同拥有对象。在销毁最后一个拥有的智能指针时，拥有的对象被销毁。</em></p><p id="0597" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">最后，(3) <code class="fe op oq or la b">weak_ptr</code> <em class="of">不拥有</em>任何对象，并且在对象何时或是否被删除方面不起作用。更确切地说，<code class="fe op oq or la b">weak_ptr</code>只是在<code class="fe op oq or la b">shared_ptr</code>的管理下观察物体，并提供用于确定被观察物体是否仍然存在的工具。<code class="fe op oq or la b">weak_ptr</code>的C++11实现使用了<code class="fe op oq or la b">shared_ptr</code>。</p><h1 id="306d" class="ll lf it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">问题是</h1><p id="bf51" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">资源有时需要从堆中分配(例如，静态变量、锁):必须在某个时候释放的资源。否则，内存泄漏:内存泄漏的长时间运行的程序会慢慢耗尽内存，从而降低性能。</p><p id="8589" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">正如微软写的<em class="of">现代C++ </em>所说，</p><blockquote class="ox oy oz"><p id="7eaa" class="mc md of me b mf nh ju mh mi ni jx mk pa nj mn mo pb nk mr ms pc nl mv mw mx im bi translated">智能指针在<a class="ae ky" href="https://docs.microsoft.com/en-us/cpp/standard-library/memory?view=msvc-170" rel="noopener ugc nofollow" target="_blank"> &lt;内存&gt; </a>头文件的<code class="fe op oq or la b">std</code>命名空间中定义。它们对<a class="ae ky" href="https://docs.microsoft.com/en-us/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=msvc-170" rel="noopener ugc nofollow" target="_blank"> RAII </a>或<em class="it">资源获取是初始化</em>编程习语至关重要。这个习语的主要目标是确保在初始化对象的同时获取资源，以便在一行代码中创建并准备好对象的所有资源。</p><p id="7694" class="mc md of me b mf nh ju mh mi ni jx mk pa nj mn mo pb nk mr ms pc nl mv mw mx im bi translated">实际上，RAII的主要原则是将任何堆分配的资源(例如，动态分配的内存或系统对象句柄)的所有权交给堆栈分配的对象，该对象的析构函数包含删除或释放资源的代码以及任何相关的清理代码。</p><p id="6d74" class="mc md of me b mf nh ju mh mi ni jx mk pa nj mn mo pb nk mr ms pc nl mv mw mx im bi translated">在大多数情况下，当您初始化原始指针或资源句柄以指向实际资源时，请立即将指针传递给智能指针。在现代C++中，原始指针只用于有限范围的小代码块、循环或助手函数，在这些地方，性能是至关重要的，并且不会混淆所有权。"[ <a class="ae ky" href="https://docs.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><h1 id="f76b" class="ll lf it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">解决方案</h1><p id="d284" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">C++98中的智能指针:<code class="fe op oq or la b">std::auto_ptr</code>。(<a class="ae ky" href="https://en.cppreference.com/w/cpp/memory/auto_ptr" rel="noopener ugc nofollow" target="_blank">来源</a>)</p><p id="86de" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">C++11中的智能指针:<code class="fe op oq or la b">std::unique_ptr</code>、<code class="fe op oq or la b">std::shared_ptr</code>、<code class="fe op oq or la b">std::weak_ptr</code>。</p><h2 id="d742" class="le lf it bd lm pd pe dn lq pf pg dp lu ml ph pi lw mp pj pk ly mt pl pm ma pn bi translated"><strong class="ak">提示</strong></h2><p id="1b84" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated"><code class="fe op oq or la b">std::auto_ptr</code>，C++98弃用，C++17移除。这是一次标准化C++11的尝试，c++ 11更好。唯一合法的用例<code class="fe op oq or la b">std::auto_ptr</code>是需要用C++98编译器编译代码。否则，用<code class="fe op oq or la b">std::unique_ptr</code>代替<code class="fe op oq or la b">std::auto_ptr</code>，永不回头。</p><p id="3331" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">智能指针是类对象，其行为类似于原始指针，但管理的对象是<code class="fe op oq or la b">new</code>以及何时或是否删除它们——智能指针在适当的时间自动删除被管理的对象。</p><p id="7c4d" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated"><strong class="me iu">提示</strong></p><p id="5aa9" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">智能指针包含一个内置指针，定义为一个模板类，其类型参数是所指向对象的类型，因此您可以声明指向任何类型的类对象的智能指针。</p><p id="a88a" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">因此，这个自动释放内存的原始指针容器，意味着程序中的内存泄漏是无关紧要的。</p><p id="4c2f" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">从C++11开始，智能指针的三种类型如下所示:</p><ol class=""><li id="a28e" class="og oh it me b mf nh mi ni ml oi mp oj mt ok mx ol om on oo bi translated"><code class="fe op oq or la b">std::unique_ptr</code></li><li id="2c5a" class="og oh it me b mf os mi ot ml ou mp ov mt ow mx ol om on oo bi translated"><code class="fe op oq or la b">std::shared_ptr</code></li><li id="edd4" class="og oh it me b mf os mi ot ml ou mp ov mt ow mx ol om on oo bi translated"><code class="fe op oq or la b">std::weak_ptr</code></li></ol><h1 id="45ba" class="ll lf it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">要访问智能指针:</h1><p id="118d" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">每个都可以通过标准库头<code class="fe op oq or la b">&lt;memory&gt;</code> ( <a class="ae ky" href="https://en.cppreference.com/w/cpp/header/memory" rel="noopener ugc nofollow" target="_blank">源</a>)访问。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="8075" class="le lf it la b gy lg lh l li lj">#include &lt;memory&gt;</span></pre><h1 id="34de" class="ll lf it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">示例用法</h1><p id="dc63" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">要实例化一个唯一的指针并给它赋值25(即键入<code class="fe op oq or la b">int</code>):</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="2511" class="le lf it la b gy lg lh l li lj">std::unique_ptr&lt;int&gt;myPtr1 = std::make_unique&lt;int&gt;(25);</span></pre><p id="657a" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">我们如何使用这个指针？</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="992f" class="le lf it la b gy lg lh l li lj">std::cout &lt;&lt; myPtr1 &lt;&lt; std::endl;</span></pre><blockquote class="ox oy oz"><p id="0a35" class="mc md of me b mf nh ju mh mi ni jx mk pa nj mn mo pb nk mr ms pc nl mv mw mx im bi translated"><em class="it"> 0x60000049c030 </em></p></blockquote><p id="4421" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">指针存储对象的地址。要访问智能指针的值，我们必须取消对它的引用。使用星号符号<code class="fe op oq or la b">*</code>。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="bbac" class="le lf it la b gy lg lh l li lj">std::cout &lt;&lt; myPtr1 &lt;&lt; std::endl;<br/>std::cout &lt;&lt; *myPtr1 &lt;&lt; std::endl;</span></pre><blockquote class="ox oy oz"><p id="c198" class="mc md of me b mf nh ju mh mi ni jx mk pa nj mn mo pb nk mr ms pc nl mv mw mx im bi translated"><em class="it"> 0x6000003ec030 25 </em></p></blockquote><p id="c502" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">因此，就有了地址和值。</p><p id="7815" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated"><strong class="me iu">不共享唯一指针。</strong></p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="1cd8" class="le lf it la b gy lg lh l li lj">std::unique_ptr&lt;int&gt;myPtr1 = std::make_unique&lt;int&gt;(25);<br/>std::unique_ptr&lt;int&gt;myPtr2 = myPtr1;</span></pre><blockquote class="ox oy oz"><p id="2e7c" class="mc md of me b mf nh ju mh mi ni jx mk pa nj mn mo pb nk mr ms pc nl mv mw mx im bi translated"><em class="it">错误:调用隐式删除的复制构造函数' STD::unique _ ptr&lt;int&gt;'</em></p></blockquote><p id="ebc4" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">我们可以使用<code class="fe op oq or la b">move</code>方法将<code class="fe op oq or la b">myPtr1</code>指向的值移动到<code class="fe op oq or la b">myPtr2</code>的值。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="4eba" class="le lf it la b gy lg lh l li lj">std::unique_ptr&lt;int&gt;myPtr1 = std::make_unique&lt;int&gt;(25);<br/>std::unique_ptr&lt;int&gt;myPtr2 = std::move(myPtr1);</span><span id="d9d9" class="le lf it la b gy lk lh l li lj">std::cout &lt;&lt; *myPtr2 &lt;&lt; std::endl;</span></pre><blockquote class="ox oy oz"><p id="29f6" class="mc md of me b mf nh ju mh mi ni jx mk pa nj mn mo pb nk mr ms pc nl mv mw mx im bi translated"><em class="it"> 25 </em></p></blockquote><p id="711a" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">现在，如果我们遵从<code class="fe op oq or la b">move</code>之后的<code class="fe op oq or la b">myPtr1</code>会怎么样。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="f73f" class="le lf it la b gy lg lh l li lj">std::unique_ptr&lt;int&gt;myPtr1 = std::make_unique&lt;int&gt;(25);<br/>std::unique_ptr&lt;int&gt;myPtr2 = std::move(myPtr1);</span><span id="cbc0" class="le lf it la b gy lk lh l li lj">std::cout &lt;&lt; *myPtr2 &lt;&lt; std::endl;<br/>std::cout &lt;&lt; *myPtr1 &lt;&lt; std::endl;</span></pre><blockquote class="ox oy oz"><p id="921c" class="mc md of me b mf nh ju mh mi ni jx mk pa nj mn mo pb nk mr ms pc nl mv mw mx im bi translated"><em class="it"> 25异常:铿锵:</em> <code class="fe op oq or la b"><em class="it">myPtr1</em></code> <em class="it">被移动后使用</em></p></blockquote><p id="52d6" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">变量<code class="fe op oq or la b">myPtr1</code>为空。</p><p id="24e3" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated"><strong class="me iu">自动处理内存释放。</strong></p><p id="47cf" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">这里有一个类来演示这个概念:</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="b8e5" class="le lf it la b gy lg lh l li lj">class MyClass{<br/>public:<br/>    MyClass(){<br/>        std::cout &lt;&lt; "Constructor invoked" &lt;&lt; std::endl;<br/>    }<br/>    ~MyClass(){<br/>        std::cout &lt;&lt; "Destructor invoked" &lt;&lt; std::endl;<br/>    }<br/>};</span></pre><p id="7297" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">创建对象时，调用构造函数；析构函数在删除时被调用。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="6937" class="le lf it la b gy lg lh l li lj">int main() {</span><span id="6e3d" class="le lf it la b gy lk lh l li lj">    std::unique_ptr&lt;MyClass&gt;myPtr1 = std::make_unique&lt;MyClass&gt;();<br/>    std::system("read -p 'Press Enter to continue...' var");</span><span id="2c43" class="le lf it la b gy lk lh l li lj">    return 0;<br/>}</span></pre><blockquote class="ox oy oz"><p id="be09" class="mc md of me b mf nh ju mh mi ni jx mk pa nj mn mo pb nk mr ms pc nl mv mw mx im bi translated"><em class="it">构造函数被调用，按回车键继续… </em></p></blockquote><h1 id="1ef6" class="ll lf it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">问题</h1><h2 id="d2dc" class="le lf it bd lm pd pe dn lq pf pg dp lu ml ph pi lw mp pj pk ly mt pl pm ma pn bi translated">为什么调用了构造函数而没有调用析构函数？</h2><p id="196e" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">一旦对象不再在范围内，它就会被删除。在上面的例子中，我们从未执行完<code class="fe op oq or la b">main()</code>。因此，对象总是在范围内。进一步限制范围的方法是添加弯曲的括号。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="a7f3" class="le lf it la b gy lg lh l li lj">int main() {<br/>    {</span><span id="77e2" class="le lf it la b gy lk lh l li lj">       std::unique_ptr&lt;MyClass&gt;myPtr1 = std::make_unique&lt;MyClass&gt;();<br/>    <br/>    }</span><span id="2807" class="le lf it la b gy lk lh l li lj">    std::system("read -p 'Press Enter to continue...' var");<br/>    return 0;<br/>}</span></pre><blockquote class="ox oy oz"><p id="aaeb" class="mc md of me b mf nh ju mh mi ni jx mk pa nj mn mo pb nk mr ms pc nl mv mw mx im bi translated"><em class="it">构造函数调用析构函数调用回车继续… </em></p></blockquote><p id="0875" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">一个<code class="fe op oq or la b">unique_ptr</code>取得一个指针的<em class="of">所有权</em></p><ul class=""><li id="29ae" class="og oh it me b mf nh mi ni ml oi mp oj mt ok mx po om on oo bi translated">模板:模板参数是<em class="of">拥有的</em>指针引用的类型(即指针类型<code class="fe op oq or la b">T*</code>中的<code class="fe op oq or la b">T</code>)</li><li id="fc60" class="og oh it me b mf os mi ot ml ou mp ov mt ow mx po om on oo bi translated">C++标准库(C++11)的一部分</li><li id="e7e4" class="og oh it me b mf os mi ot ml ou mp ov mt ow mx po om on oo bi translated">它的析构函数调用<em class="of">拥有的</em>指针上的<code class="fe op oq or la b">delete</code></li><li id="90af" class="og oh it me b mf os mi ot ml ou mp ov mt ow mx po om on oo bi translated">当<code class="fe op oq or la b">unique_ptr</code>对象为<code class="fe op oq or la b">delete</code>d或超出范围时调用</li></ul><h2 id="e6cc" class="le lf it bd lm pd pe dn lq pf pg dp lu ml ph pi lw mp pj pk ly mt pl pm ma pn bi translated">如果我们把一个std::unique_ptr按值传递给一个函数会怎么样？</h2><p id="0326" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">对于C++程序员来说，内存管理是一个不小的负担。智能指针是有帮助的，但是完全理解是必须的。</p><p id="cc47" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">这段代码不会被编译，因为没有复制<code class="fe op oq or la b">std::unique_ptr</code>。因此，将其作为参数传递给函数将无法编译。</p><p id="1a8a" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">为了让编译器相信这没问题，可以使用<code class="fe op oq or la b">std::move</code>。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="7fe6" class="le lf it la b gy lg lh l li lj">ptr = f(std::move(ptr));</span></pre><p id="4097" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">如果这不清楚，也许理解引用(即通过值传递参数而不是通过引用传递参数)将有助于巩固这一课[3]。</p><h2 id="2773" class="le lf it bd lm pd pe dn lq pf pg dp lu ml ph pi lw mp pj pk ly mt pl pm ma pn bi translated">为什么不完全避免堆呢？因此，不会发生内存泄漏，因为堆栈会自动管理内存资源。</h2><p id="d78d" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">Young Coder 总结了在程序中只假设静态内存不切实际的原因:</p><ol class=""><li id="ca6e" class="og oh it me b mf nh mi ni ml oi mp oj mt ok mx ol om on oo bi translated">堆栈上的空间是有限的，因此不适合更大的对象。</li><li id="1ed8" class="og oh it me b mf os mi ot ml ou mp ov mt ow mx ol om on oo bi translated">堆栈上的内存大小是动态的:大小必须是恒定的，并且事先已知。</li><li id="2da6" class="og oh it me b mf os mi ot ml ou mp ov mt ow mx ol om on oo bi translated">堆栈遵循<em class="of">先入后出</em> (FILO)范式——只能访问最顶层的项目，因此不能随机访问另一个项目。</li><li id="6a7b" class="og oh it me b mf os mi ot ml ou mp ov mt ow mx ol om on oo bi translated">由于(3)，感兴趣的项目顶部的每个<em class="of">堆栈帧</em>必须被解除分配以访问中间的那个。</li></ol><p id="85fb" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">进入堆——一个没有特定顺序的内存池，可以通过一个变量集来访问它的内存地址值。</p><p id="145f" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">请注意，堆栈将一个项目推到最后一个序列的顶部；堆没有这样的顺序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/82bacf73f5e3f24baf163296a0d3aa84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*w9YJ4w7KeZNQY1NG.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从图解的<a class="ae ky" href="https://medium.com/young-coder/an-illustrated-guide-to-memory-the-stack-the-heap-and-pointers-40a604f7bc53" rel="noopener">指南到堆栈、堆和指针</a>【5】。</p></figure><h1 id="e77c" class="ll lf it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">结论</h1><p id="4b23" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">智能指针是一种有用的类类型，它使程序员能够使用指针，而无需手动分配和释放内存。按照微软的说法，我们应该远离原始指针，除非它的作用范围有限并且使用简单(例如，在一个循环或简单的代码块中)。</p><p id="b2fe" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">现在你已经准备好深入研究三种类型的智能指针:接下来是<code class="fe op oq or la b">std::unique_ptr</code>，然后是<code class="fe op oq or la b">std::shared_ptr</code>和<code class="fe op oq or la b">std::weak_ptr</code>，最后，我们将比较、对比并在实践中使用每一种。</p><h1 id="76e3" class="ll lf it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">补充材料</h1><p id="6993" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">这里提出的主题本身就很重要。为了使您的C++代码在运行时在速度和内存使用方面达到最优，对内存管理的良好理解是必不可少的！下面是整篇文章中引用的相关参考资料。</p><h2 id="fe65" class="le lf it bd lm pd pe dn lq pf pg dp lu ml ph pi lw mp pj pk ly mt pl pm ma pn bi translated"><strong class="ak">【1】栈和堆，</strong> <a class="pp pq ep" href="https://medium.com/u/1bb43593ad65?source=post_page-----708486276526--------------------------------" rel="noopener" target="_blank">弗兰齐斯卡·欣克尔曼</a></h2><div class="nm nn gp gr no np"><a href="https://medium.com/fhinkel/confused-about-stack-and-heap-2cf3e6adb771" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">对栈和堆感到困惑？</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">坦白说，我总是很难把堆栈和堆分开。是的，我读过内存管理，然后…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">medium.com。</p></div></div><div class="ny l"><div class="ps l oa ob oc ny od ks np"/></div></div></a></div><h2 id="64c1" class="le lf it bd lm pd pe dn lq pf pg dp lu ml ph pi lw mp pj pk ly mt pl pm ma pn bi translated">[2]指针，<a class="pp pq ep" href="https://medium.com/u/c1aeceaf7f53?source=post_page-----708486276526--------------------------------" rel="noopener" target="_blank">羽衣甘蓝布兰肯希普</a></h2><div class="nm nn gp gr no np"><a href="https://medium.com/@vCabbage/go-are-pointers-a-performance-optimization-a95840d3ef85" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">Go:指针是性能优化吗？</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">在过去的几周里，我已经回答了几个关于指针作为一种性能的问题/断言…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">medium.co.m</p></div></div></div></a></div><h2 id="b6ad" class="le lf it bd lm pd pe dn lq pf pg dp lu ml ph pi lw mp pj pk ly mt pl pm ma pn bi translated">[3]指针和参考文献，<a class="pp pq ep" href="https://medium.com/u/863161906cc5?source=post_page-----708486276526--------------------------------" rel="noopener" target="_blank">泰瑞·拉迪奇</a></h2><div class="nm nn gp gr no np"><a href="https://medium.com/cloud-security/pointers-and-references-157b854da2c5" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">指针和引用</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">当您的代码指出安全问题时</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">medium.com</p></div></div><div class="ny l"><div class="pt l oa ob oc ny od ks np"/></div></div></a></div><h2 id="d8cb" class="le lf it bd lm pd pe dn lq pf pg dp lu ml ph pi lw mp pj pk ly mt pl pm ma pn bi translated">[4]Python程序员的堆与栈，<a class="pp pq ep" href="https://medium.com/u/f94e8b97c7aa?source=post_page-----708486276526--------------------------------" rel="noopener" target="_blank">纳赛尔·塔米米</a></h2><div class="nm nn gp gr no np"><a href="https://towardsdatascience.com/python-memory-and-objects-e7bec4a2845" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">Python、内存和对象</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">数据科学家的内存管理基础</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">towardsdatascience.com</p></div></div><div class="ny l"><div class="pu l oa ob oc ny od ks np"/></div></div></a></div><h2 id="44c1" class="le lf it bd lm pd pe dn lq pf pg dp lu ml ph pi lw mp pj pk ly mt pl pm ma pn bi translated">[5]堆栈、堆和指针，<a class="pp pq ep" href="https://medium.com/u/7d4570c805e6?source=post_page-----708486276526--------------------------------" rel="noopener" target="_blank">年轻的编码者</a></h2><div class="nm nn gp gr no np"><a href="https://medium.com/young-coder/an-illustrated-guide-to-memory-the-stack-the-heap-and-pointers-40a604f7bc53" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">堆栈、堆和指针的图解指南</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">现代编程如何保证代码安全</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">medium.com</p></div></div><div class="ny l"><div class="pv l oa ob oc ny od ks np"/></div></div></a></div><p id="e281" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">请注意，以上物品不是替换品，而是赠品。对于那些对这里所涉及的主题不熟悉的人来说，最好通读以上内容，参考以上需要更深入了解的主题，然后以挑战自己对细节保持理性的方式返回并重读。</p><p id="f54f" class="pw-post-body-paragraph mc md it me b mf nh ju mh mi ni jx mk ml nj mn mo mp nk mr ms mt nl mv mw mx im bi translated">所有的评论，问题，和补充信息在下面分享，如被允许，将不胜感激！</p></div><div class="ab cl pw px hx py" role="separator"><span class="pz bw bk qa qb qc"/><span class="pz bw bk qa qb qc"/><span class="pz bw bk qa qb"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="3911" class="le lf it la b gy lg lh l li lj"><strong class="la iu">Want to Connect?</strong></span><span id="0f29" class="le lf it la b gy lk lh l li lj">Follow Dr. Robinson on <a class="ae ky" href="https://www.linkedin.com/company/superannotate/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>, <a class="ae ky" href="https://twitter.com/jrobvision" rel="noopener ugc nofollow" target="_blank">Twitter</a>, <a class="ae ky" href="https://www.facebook.com/superannotate" rel="noopener ugc nofollow" target="_blank">Facebook</a>, and <a class="ae ky" href="https://www.instagram.com/doctor__jjj/" rel="noopener ugc nofollow" target="_blank">Instagram</a>.</span><span id="ab15" class="le lf it la b gy lk lh l li lj">Visit my homepage for papers, blogs, email signups, and more!</span></pre><div class="nm nn gp gr no np"><a href="https://www.jrobs-vision.com/" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">人工智能工程师|约瑟夫·p·罗宾逊</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">问候！我是Vicarious Surgical的人工智能工程师，致力于推进下一代外科机器人技术。我的…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">www.jrobs-vision.com</p></div></div><div class="ny l"><div class="qd l oa ob oc ny od ks np"/></div></div></a></div></div><div class="ab cl pw px hx py" role="separator"><span class="pz bw bk qa qb qc"/><span class="pz bw bk qa qb qc"/><span class="pz bw bk qa qb"/></div><div class="im in io ip iq"><div class="kj kk kl km gt np"><a href="https://jvision.medium.com/membership" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">通过我的推荐链接加入Medium约瑟夫·罗宾逊博士</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">jvision.medium.com</p></div></div><div class="ny l"><div class="qe l oa ob oc ny od ks np"/></div></div></a></div></div></div>    
</body>
</html>