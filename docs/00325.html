<html>
<head>
<title>Clock-In/Out System Part 10: Back-End Testing — Unit Testing of Controllers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">上下班打卡系统第10部分:后端测试控制器的单元测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/part-10-testing-backend-testing-unit-testing-controllers-4177370ef581?source=collection_archive---------0-----------------------#2019-04-15">https://betterprogramming.pub/part-10-testing-backend-testing-unit-testing-controllers-4177370ef581?source=collection_archive---------0-----------------------#2019-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="67c7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">NestJS + Angular教程</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/e6c3fdb25434835230d0b2d6f489e857.png" data-original-src="https://miro.medium.com/v2/format:webp/1*KhCkmbtORw2Ux3n5WCrtzA.png"/></div></figure><p id="9f16" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这篇文章是我描述上下班打卡系统的系列文章的一部分。如果你想了解更多，你可以阅读以下内容:</p><ul class=""><li id="ace6" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-1-clock-in-out-system-diagram-a0a51bab02a7?source=post_page---------------------------" rel="noopener">上下班打卡系统第1部分:图</a></li><li id="02aa" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-2-clock-in-out-system-basic-backend-i-authmodule-66d4a5c56122?source=post_page---------------------------" rel="noopener">上下班打卡系统第二部分:基础后端— AuthModule </a></li><li id="f56b" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-3-clock-in-out-system-basic-backend-ii-usersmodule-a56f42b20f62?source=post_page---------------------------" rel="noopener">上下班打卡系统第3部分:基本后端——用户模块</a></li><li id="570e" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-4-clock-in-out-system-basic-backend-iii-appmodule-850dd17883e?source=post_page---------------------------" rel="noopener">上下班打卡系统第4部分:基础后端— AppModule </a></li><li id="4035" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-5-clock-in-out-system-seed-database-and-migration-data-cf037be21aac?source=post_page---------------------------" rel="noopener">上下班打卡系统第5部分:种子数据库和迁移数据</a></li><li id="09ca" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-6-clock-in-out-system-basic-frontend-an-7e5f9ed08c3f?source=post_page---------------------------" rel="noopener">上下班打卡系统第6部分:基本前端</a></li><li id="cb20" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-7-deploy-backend-nestjs-docker-docker-compose-2429c0b6aa9c?source=post_page---------------------------" rel="noopener">上下班打卡系统第7部分:使用Docker/Docker-Compose部署后端(NestJS)</a></li><li id="8948" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-8-clock-in-out-system-deploy-frontend-angular-6-using-environments-ad267325d3b6?source=post_page---------------------------" rel="noopener">上下班打卡系统第8部分:使用环境部署前端(角度6+)</a></li><li id="e6a0" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-9-testing-backend-testing-2d021f48403b?source=post_page---------------------------" rel="noopener">上下班打卡系统第9部分:后端测试——服务的单元测试</a></li><li id="9ede" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-10-testing-backend-testing-unit-testing-controllers-4177370ef581?source=post_page---------------------------" rel="noopener">上下班打卡系统第10部分:后端测试——控制器单元测试</a></li><li id="ddde" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第11部分:后端测试-e2e测试</li><li id="9c7b" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第12部分:前端测试单元测试</li><li id="701a" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第13部分:前端测试集成测试</li></ul><h1 id="ffbc" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">后端测试概述</h1><p id="4584" class="pw-post-body-paragraph kq kr it ks b kt mt ju kv kw mu jx ky kz mv lb lc ld mw lf lg lh mx lj lk ll im bi translated">这是关于后端测试的第二部分，也可以认为是关于质量评估(QA)的第二部分。</p><p id="053d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这个项目不是从一开始就使用测试驱动开发(TDD)开发的，但我目前正在测试阶段进行。多亏了测试阶段，我发现了很多小错误。如果这个项目已经投入生产，这可能是一个大问题。事实是，该项目将在接下来的几周内进入生产模式。这些测试对于修复目前已经发现的几个bug非常有用。</p><p id="7a0e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">测试的第一步是决定你应该测试什么。人们可能会说，你必须测试整个应用程序，你必须获得接近100%的覆盖率。事实上，你不需要测试整个应用程序——但是你必须测试软件中最关键的部分。这可能接近90%或70%，取决于您的应用程序。</p><p id="48b3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在我们的例子中，我将建议我们应该测试服务(app.service、user.service和auth.service)和控制器(app.controller、user.controller)。不需要测试d to、常量、实体或模块。那些测试很难，价值也很小。</p><p id="5972" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">后端使用<a class="ae lv" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>框架开发，该框架使用<a class="ae lv" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>作为测试工具。此外，NestJS包括一个强大的测试包，它模拟了一个类似于<a class="ae lv" href="https://angular.io/guide/testing" rel="noopener ugc nofollow" target="_blank">角度测试包</a>的环境。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="c5fe" class="mb mc it bd md me nf mg mh mi ng mk ml jz nh ka mn kc ni kd mp kf nj kg mr ms bi translated">控制器的测试</h1><p id="fd4b" class="pw-post-body-paragraph kq kr it ks b kt mt ju kv kw mu jx ky kz mv lb lc ld mw lf lg lh mx lj lk ll im bi translated">在这篇文章中，我将描述控制器单元测试。在服务单元测试之后，控制器单元测试是测试金字塔中最简单的测试。我对那些开始从事测试工作的人的建议是，从对服务进行单元测试开始。这些都是小功能，有独特的任务，很容易被隔离。控制器单元测试在服务测试之后进行，因为控制器经常调用服务方法。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/4e2bbe09dea119dc1c63ba096ab07bb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_7U7tlqjeoW1KMAL.png"/></div></div></figure><h1 id="0833" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">应用控制器</h1><p id="af0a" class="pw-post-body-paragraph kq kr it ks b kt mt ju kv kw mu jx ky kz mv lb lc ld mw lf lg lh mx lj lk ll im bi translated">我们要测试的第一个控制器是<code class="fe np nq nr ns b">app.controller.ts</code>，它使用服务<code class="fe np nq nr ns b">AppService</code>。我们的测试套件必须检查<code class="fe np nq nr ns b">app.service</code>将使用正确的参数调用方法。</p><p id="6893" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第一步包括我们将要开发的每个测试的初始配置。<code class="fe np nq nr ns b">app.controller.ts</code>在其构造函数(<code class="fe np nq nr ns b">AppService</code>)中需要一个服务，这将是一个间谍。来自<code class="fe np nq nr ns b">@nestjs/testing</code>的<code class="fe np nq nr ns b">Test</code>包提供了创建测试模块进行测试的方法<code class="fe np nq nr ns b">createTestingModule</code>。在这个<code class="fe np nq nr ns b">testingModule</code>中，<code class="fe np nq nr ns b">providers</code>数组由<code class="fe np nq nr ns b">AppController</code>和一个使用工厂创建的间谍来拦截<code class="fe np nq nr ns b">AppService</code>组成。以下代码向您展示了这一初始配置:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nt"><img src="../Images/bf9dfef50aea12e4556d91e2ff165f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mnAWlmH__ytrbUlFm1s9jw.png"/></div></div></figure><p id="8f4c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下一步包括知道我们想要测试什么。主要思想是独立于任何其他函数/方法来测试每个函数/方法。以下方法是<code class="fe np nq nr ns b">app.controller.ts</code>的代码:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nu"><img src="../Images/20e641c01e2263073acd5136bbb0a579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6zv0xfGQWTu8U7lhM97nw.png"/></div></div></figure><p id="c6a2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe np nq nr ns b">authIn</code>、<code class="fe np nq nr ns b">authOut</code>和<code class="fe np nq nr ns b">usersTicketing </code>方法应检查是否使用正确的参数调用了<code class="fe np nq nr ns b">appService</code>。在我们的例子中，测试是单元测试，因此不应该使用真正的函数/方法来调用这些方法。这就是为什么我们用间谍来做这些事。测试函数的代码如下:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nu"><img src="../Images/55fc6c057c14098c19134e3a59a2e2a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wr9RBL0dL8boj6HkdtGPOA.png"/></div></div></figure><p id="d3d6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在之前的测试中，您可以注意到<code class="fe np nq nr ns b">expect</code>与方法<code class="fe np nq nr ns b">authIn</code>、<code class="fe np nq nr ns b">authOut</code>和<code class="fe np nq nr ns b">usersTicketing</code>相关。它检查这些方法是否被调用，参数是否正确。方法<code class="fe np nq nr ns b">authIn</code>或<code class="fe np nq nr ns b">authOut</code>中抛出的错误是不相关的，因为在这些方法中责任被委托给了<code class="fe np nq nr ns b">AppService</code>。</p><h1 id="0757" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">用户控制器</h1><p id="cf57" class="pw-post-body-paragraph kq kr it ks b kt mt ju kv kw mu jx ky kz mv lb lc ld mw lf lg lh mx lj lk ll im bi translated">测试用户控制器的程序与在<code class="fe np nq nr ns b">app.controller.ts</code>中使用的程序相同。第一步是创建测试模块，其中包含将在下面的测试中使用的spy和控制器。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nv"><img src="../Images/58f0de525d337f3ad8b754c3f36bd76c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zRudABziFoCouCEWrdYs5Q.png"/></div></div></figure><p id="84d3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这些方法非常容易测试，因为使用的技术与<code class="fe np nq nr ns b">app.controller.ts</code>中的相同。要测试的代码如下:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nw"><img src="../Images/2f68658e2b3af4063ff64fcfea9dd2cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EUpC2qOimODLuaOJm5-Jng.png"/></div></div></figure><p id="7854" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">它的测试套件只检查方法<code class="fe np nq nr ns b">getUsersWithoutKey</code>和<code class="fe np nq nr ns b">addUser</code>是否是用正确的参数调用的，如下面的代码所示:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nx"><img src="../Images/e53647185030b3ec2efc32a1343cc259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KSHKB6sn-Bi3HtkKfi0OFQ.png"/></div></div></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="7125" class="mb mc it bd md me nf mg mh mi ng mk ml jz nh ka mn kc ni kd mp kf nj kg mr ms bi translated">结论</h1><p id="a8fb" class="pw-post-body-paragraph kq kr it ks b kt mt ju kv kw mu jx ky kz mv lb lc ld mw lf lg lh mx lj lk ll im bi translated">在本文中，我解释了如何使用Jest和NestJS框架测试后端控制器。如果你知道间谍是如何工作的，这些测试是非常容易的。事实上，控制器经常调用服务的方法。</p><p id="4da5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在下一篇文章中，我将向您展示如何进行后端e2e测试。</p><ul class=""><li id="7a94" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated">GitHub项目是<a class="ae lv" href="https://github.com/Caballerog/clock-in-out" rel="noopener ugc nofollow" target="_blank">https://github.com/Caballerog/clock-in-out</a>。</li><li id="3a27" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">这个帖子的GitHub分支是<a class="ae lv" href="https://github.com/Caballerog/clock-in-out/tree/part9-backend-unit-test" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Caballerog/clock-in-out/tree/part 9-back end-unit-test</a>。</li></ul></div></div>    
</body>
</html>