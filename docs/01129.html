<html>
<head>
<title>Power of the Go Package Gabs for Dynamic JSON</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态JSON的Go包Gabs的威力</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/power-of-the-go-package-gabs-for-dynamic-json-69eb26d91927?source=collection_archive---------12-----------------------#2019-08-16">https://betterprogramming.pub/power-of-the-go-package-gabs-for-dynamic-json-69eb26d91927?source=collection_archive---------12-----------------------#2019-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5350" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Go中的JSON很难处理，Gabs使它变得更容易</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6a9df83340e90018aedb1d41d30d3cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CRDVS_fwoxVydfbgeYTAxw.png"/></div></div></figure><p id="476c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">谷歌开发的<a class="ae lq" href="https://golang.org/pkg/" rel="noopener ugc nofollow" target="_blank"> Go </a>编程语言是基于C编程语言的。它被完全编译并与所有打包成执行所需的单个二进制文件的库静态链接。</p><p id="554e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我们将讨论如何在Go中支持动态JSON。在理解它之前，我们先回忆一下静态JSON在Go中是如何工作的。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="b64c" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak">静态JSON in Go </strong></h1><p id="9b0e" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">静态JSON是指编译时其数据结构的先验定义形成的对象。</p><p id="d435" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过在编译期间在结构中定义键，我们限制了它的作用域，并且我们不能通过添加更多的键来最大化这个作用域。</p><p id="b1a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Go中，JSON分别由在<code class="fe mv mw mx my b">encoding/json</code>包中定义的marshal和unmarshal函数编码和解码。</p><h2 id="c21a" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated"><strong class="ak"> <em class="nl">样品</em> </strong></h2><pre class="kj kk kl km gt nm my nn no aw np bi"><span id="362b" class="mz lz it my b gy nq nr l ns nt">import “encoding/json”</span><span id="f459" class="mz lz it my b gy nu nr l ns nt">import “fmt”</span><span id="f408" class="mz lz it my b gy nu nr l ns nt">type demoStatic struct {</span><span id="af02" class="mz lz it my b gy nu nr l ns nt">Name string `json:”name”`</span><span id="924f" class="mz lz it my b gy nu nr l ns nt">Id int `json:”id”`</span><span id="152e" class="mz lz it my b gy nu nr l ns nt">}</span><span id="44c3" class="mz lz it my b gy nu nr l ns nt">var myStatic demoStatic</span><span id="c066" class="mz lz it my b gy nu nr l ns nt">obj := demoStatic {</span><span id="55b8" class="mz lz it my b gy nu nr l ns nt">“Name”: “foo”,</span><span id="d6a0" class="mz lz it my b gy nu nr l ns nt">“Id”: 1234</span><span id="3f4b" class="mz lz it my b gy nu nr l ns nt">}</span></pre><ul class=""><li id="fc78" class="nv nw it kw b kx ky la lb ld nx lh ny ll nz lp oa ob oc od bi translated">封送处理:对象实例返回一个字节片。</li></ul><pre class="kj kk kl km gt nm my nn no aw np bi"><span id="70ca" class="mz lz it my b gy nq nr l ns nt">bytes,_ := json.Marshal(obj)</span></pre><ul class=""><li id="66fe" class="nv nw it kw b kx ky la lb ld nx lh ny ll nz lp oa ob oc od bi translated">解组意味着用结构的引用解码对象实例的字节片。</li></ul><pre class="kj kk kl km gt nm my nn no aw np bi"><span id="0afb" class="mz lz it my b gy nq nr l ns nt">err := json.Unmarshal(bytes, &amp;myStatic)</span><span id="868a" class="mz lz it my b gy nu nr l ns nt">fmt.Println(err)</span><span id="1d17" class="mz lz it my b gy nu nr l ns nt">fmt.Println(bytes)</span></pre><p id="0d44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go结构是不同数据类型的字段集合，属于case标准。如果需要在外部使用，字段是大写的<strong class="kw iu"/>。如果未导出，则它们在<strong class="kw iu">小写</strong>中。如果未经授权访问字段，编译器将返回错误。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="d42a" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak">启动动态JSON </strong></h1><p id="3b49" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">与静态JSON不同，动态JSON有点麻烦，因为它基本上是在运行时处理结构的字段。</p><p id="b2bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就提出了一个问题:“在运行时定义一个结构有帮助吗？”我认为这不是不可能的，但它可能有点复杂。经过坚持不懈的尝试，我们找到了阿什利·杰夫斯开发的包<a class="ae lq" href="https://github.com/Jeffail/gabs" rel="noopener ugc nofollow" target="_blank"><em class="oe"/></a>。</p><p id="17e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Gabs是一个实用程序，能够处理动态或未知的JSON结构，以及嵌套的JSON结构。</p><h2 id="c906" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated"><strong class="ak"> <em class="nl">样品</em> </strong></h2><pre class="kj kk kl km gt nm my nn no aw np bi"><span id="9974" class="mz lz it my b gy nq nr l ns nt">import “github.com/Jeffail/gabs”</span><span id="3494" class="mz lz it my b gy nu nr l ns nt">parsed,err := gabs.ParseJSON([]byte(`{“foo”:{“John”:{“Doe”:”bar”}}}`))</span><span id="6f9f" class="mz lz it my b gy nu nr l ns nt">out,ok := parsed.Path(“foo.John.Doe”).Data().(string)</span><span id="fb42" class="mz lz it my b gy nu nr l ns nt">//out == bar; ok == true</span></pre><p id="ea6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解析JSON结构后，获得的输出是类型<code class="fe mv mw mx my b">*gabs.Container</code>。</p><ul class=""><li id="8b65" class="nv nw it kw b kx ky la lb ld nx lh ny ll nz lp oa ob oc od bi translated"><em class="oe">容器</em>是Gabs包中定义的结构，是引用特定元素的包装器。</li></ul><pre class="kj kk kl km gt nm my nn no aw np bi"><span id="a38d" class="mz lz it my b gy nq nr l ns nt">type Container struct {</span><span id="a2e0" class="mz lz it my b gy nu nr l ns nt">obj interface{}</span><span id="8355" class="mz lz it my b gy nu nr l ns nt">}</span></pre><p id="6271" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，如果您通过<code class="fe mv mw mx my b">New() as obj:= gabs.New()</code>创建一个新的JSON对象，它将返回一个容器的地址，并引用其元素作为<code class="fe mv mw mx my b">map[string]interface{}</code>。</p><p id="c096" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着一个对象有多个用<code class="fe mv mw mx my b">interface{}</code> <em class="oe">映射的字符串键。</em></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8ebb" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak">通过Gabs设置按键</strong></h1><p id="acb2" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们可以在Gabs结构中设置多个键，而不用担心Gabs的内部机制。</p><pre class="kj kk kl km gt nm my nn no aw np bi"><span id="638c" class="mz lz it my b gy nq nr l ns nt">newObj := gabs.New() // define single object instance</span><span id="efbc" class="mz lz it my b gy nu nr l ns nt">newObj.Set(“value”,”key”)</span><span id="4c9d" class="mz lz it my b gy nu nr l ns nt">out := newObj.String()</span><span id="af1f" class="mz lz it my b gy nu nr l ns nt">fmt.Println(out) //{“key”:”value”}</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="ea53" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak">结论</strong></h1><p id="3c75" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Go中的非静态JSON可能很难处理。但是，在我们了解了Gabs包之后，我们发现管理动态JSON更容易了。</p><p id="7ce9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您的Go代码中有未知的或动态的JSON，请阅读Gabs Go包文档。你可能也会发现它的用处。</p></div></div>    
</body>
</html>