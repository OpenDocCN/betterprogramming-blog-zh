<html>
<head>
<title>Improve Response Time by 10x by Introducing an Interceptor In Nest.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过在Nest.js中引入拦截器，将响应时间提高10倍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/improve-response-time-10x-by-introducing-an-interceptor-in-nestjs-590695692360?source=collection_archive---------0-----------------------#2022-09-15">https://betterprogramming.pub/improve-response-time-10x-by-introducing-an-interceptor-in-nestjs-590695692360?source=collection_archive---------0-----------------------#2022-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d3a1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">带有基准比较的实际实施</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9bc4dea1b60c904605edf0af7f00ba9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kpXC2ia-jAiLRMGE"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@aronvisuals?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aron视觉效果</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4427" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编写可伸缩的快速API可能是一项挑战，今天我想向您介绍我在必须处理大量传入请求的<a class="ae kv" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a> (Node.js)应用程序中实现的一项技术。</p><p id="7831" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法用于特定的用例——当您的API在客户端请求期间执行一些非业务逻辑时。我们将回顾卸载这些工作的方法，并将改进您的API可以处理的总体响应时间和每分钟请求数。</p><p id="3b70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例使用案例:</p><ul class=""><li id="7e1f" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">记录</li><li id="e79e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">指标收集</li><li id="b7bd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">后台作业队列</li><li id="9a39" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">客户端将通过WebSocket或WebHook接收响应</li></ul><p id="07ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我有一个<a class="ae kv" href="https://github.com/dkhorev/nestjs-interceptor-benchmark-demo" rel="noopener ugc nofollow" target="_blank">演示应用程序，准备运行一些基准测试</a>。这是一个条件可变的简单API路径。</p><p id="7caf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的例子是围绕<a class="ae kv" href="https://redis.com" rel="noopener ugc nofollow" target="_blank"> Redis数据库</a>和<a class="ae kv" href="https://www.npmjs.com/package/bull" rel="noopener ugc nofollow" target="_blank"> Bull queue </a>模块构建的。尽管这种技术的其他应用也是可能的，这取决于您选择的服务:Redis Streams、SNS、SQS、RabbitMQ、Kafka或任何常规的DB。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="bd27" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">问题是</h1><p id="d4e5" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">Node.js是后端JavaScript代码的单线程运行时。我们的首要任务是不要在不必要的时候阻塞主线程。</p><p id="1cea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那是什么意思？</p><p id="aa41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们回顾一个简单的例子，一个请求进来，它击中你的控制器，你做一些工作，并返回一个响应。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/e45ffad7fa6e185f924f1463747edd27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ttt4SgBSMRgoCCqf9bB7zw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基本的API请求-响应工作流</p></figure><p id="de50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本例中的所有操作都是同步执行的，因此事件循环在此时被阻塞。访问API的请求越多，每个新客户机等待响应的时间就越长(假设资源有限)。</p><p id="b0c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个图中有一点很突出:客户不关心我们用<code class="fe nl nm nn no b">Logs API</code>做的任何后台工作，那么他为什么要等待它完成呢？如果<code class="fe nl nm nn no b">Logs API</code>是对第三方服务的调用，那么它增加了另一个可能影响您的客户端的故障点。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="6134" class="np mo iq bd mp nq nr dn mt ns nt dp mx lf nu nv mz lj nw nx nb ln ny nz nd oa bi translated">解决方案1 —将日志处理卸载到队列中</h2><p id="4338" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们知道Redis很快，所以排队作业也很快，对吗？</p><p id="3db9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们介绍一个简单的队列，并在后台发送这些日志。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/995a83803de7dbc328746135168a9f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dz0C3CudQOqW5_EBYHIxNQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">客户端不必等待日志API完成的工作流</p></figure><p id="28d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">众所周知，Redis是一种非常快速的内存存储，将作业插入Redis DB大多数情况下可以在1毫秒内完成。</p><p id="323c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与数据库<code class="fe nl nm nn no b">INSERT </code>或第三方API调用相比，Redis的写入速度要快几倍。光是这个变化就能给你带来很多表现。</p><p id="9f28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们知道这个操作也阻止了客户端接收响应，它非常快，但是仍然在阻止。</p><p id="4bf3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种控制器的一个例子是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="73a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将会发生的是，一旦我们在控制器中点击<code class="fe nl nm nn no b">line 3</code>，下面的任何代码的执行将被推迟到下一个滴答，在此之后<code class="fe nl nm nn no b">queueFake</code>的承诺被解决。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="0c16" class="np mo iq bd mp nq nr dn mt ns nt dp mx lf nu nv mz lj nw nx nb ln ny nz nd oa bi translated">解决方案2 —将日志处理卸载到拦截器</h2><p id="42e1" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated"><code class="fe nl nm nn no b">Interceptor</code>也就是后端开发者所说的<code class="fe nl nm nn no b">Middleware</code>。</p><p id="7b4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">什么是中间件？</strong></p><p id="c58c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它是位于请求和响应之间的一段代码。从这个意义上说，我们的路由处理器也是中间件，但是NestJS使用了稍微不同的命名方式— <code class="fe nl nm nn no b">Interceptors</code>。</p><p id="80e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在请求到达控制器之前执行定制代码，而且中间件可以在响应发送之后执行，这是一件很棒的事情。</p><p id="86fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">高层次的想法是——拦截器获取请求信息，并仅在响应被发送时执行阻塞操作。这样一来，Node.js进程繁忙时不会限制传入的请求，应用程序可以在后台进行异步处理(与i/o相关)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/35c7d5ff44c97be99d4c880e8c07d44a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rfNYtDWDBqeK-iHLtiE9oA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">客户端不必等待日志API和队列完成的工作流</p></figure><p id="6996" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，这增加了通过另一个代码块传输请求的开销，但是在大多数情况下，这进一步提高了应用程序的可伸缩性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="15f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们来看一些数字。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="6439" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><strong class="ak">测试工具和场景</strong></h1><p id="cc72" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">自动扫描——一个加载测试API的好工具</p><p id="2877" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a> —一个内存数据库，主要用于缓存、队列和发布/订阅，但它有许多其他很酷的模块，可以作为应用程序的全栈数据库。</p><p id="bc89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将在4种不同的场景中运行这两种解决方案:</p><ul class=""><li id="872c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">用<code class="fe nl nm nn no b">setTimeout</code>模拟延迟<code class="fe nl nm nn no b">5ms</code>的任务添加</li><li id="2c30" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">用<code class="fe nl nm nn no b">setTimeout</code>模拟延迟<code class="fe nl nm nn no b">25ms</code>的任务添加</li><li id="8c4c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">本地主机Redis队列(零网络延迟)</li><li id="d97b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">远程Redis队列(一些网络延迟)</li></ul><p id="dbc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有三种不同的并发级别:</p><ul class=""><li id="fa53" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">每秒x10个请求</li><li id="a5a8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">每秒x50个请求</li><li id="2f89" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">每秒x100个请求</li></ul><p id="52b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基准的图例:</p><ul class=""><li id="4287" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nl nm nn no b">RPM</code> —每分钟请求的API句柄(越高越好)</li><li id="e0c9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nl nm nn no b">Latency</code>—API路线的响应时间(越短越好)</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="8a30" class="np mo iq bd mp nq nr dn mt ns nt dp mx lf nu nv mz lj nw nx nb ln ny nz nd oa bi translated">测试套件—作业添加延迟5毫秒</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/7b275b6ad708908cc88f0d078452774b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4gKlS_XlOphMZQp_xSDf2A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">具有5毫秒合成延迟的测试套件结果。RPM —越高越好。延迟—越低越好。</p></figure><p id="4786" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来这里没有明显的赢家，但是拦截器的路线在x10并发上执行<em class="og">8倍(延迟)和5倍(RPM)。其他并发性测试——是我的单节点进程资源达到极限的地方，所以两种方法的结果非常相似(阻塞进程导致非常高的并发性)。</em></p><p id="77b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下分布式/负载平衡部署(或集群节点应用程序)。每个进程将在x10结果区的某个地方动作，所以在我看来拦截器解决方案是一个明显的赢家。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="5e9b" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">测试套件—作业添加延迟25毫秒</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/d988e4c709973b56d33d17c5b0328207.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFMvyG8suNSnskldjX8Vhg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">25毫秒合成延迟的测试套件结果。RPM —越高越好。延迟—越低越好。</p></figure><p id="ce51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着我们第三方服务响应时间的增长，阻止解决方案会遇到越来越多的问题。</p><p id="2845" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，与<code class="fe nl nm nn no b">5ms</code>试运行相比，<code class="fe nl nm nn no b">x2-x3</code>的转速已经下降。最低延迟也增加到了<code class="fe nl nm nn no b">x2</code>。</p><p id="7d75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">拦截器解决方案的数字看起来是一样的——太好了！无论我们的第三方服务响应时间有多长，我们的API仍然很快。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="fa17" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><strong class="ak">越来越真实</strong></h1><p id="4755" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">现在让我们做一些接近真实世界的测试。我们知道DB插入很慢，所以我希望这种测试的结果是相似的。</p><p id="f1b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我想查一下Redis，它通常很快，可以在1ms以内插入数据。</p><p id="07c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的设置:<a class="ae kv" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>，<a class="ae kv" href="https://www.npmjs.com/package/bull" rel="noopener ugc nofollow" target="_blank"> Bull </a>队列管理器，异步任务将作业插入Redis队列。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="987d" class="np mo iq bd mp nq nr dn mt ns nt dp mx lf nu nv mz lj nw nx nb ln ny nz nd oa bi translated">测试套件— Redis队列，本地主机</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/4b30207ef2c3f66dc29a0a3d67374449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ryZlKoXmdLnACIK1PS9cAw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Redis localhost的测试套件结果。RPM —越高越好。延迟—越低越好。</p></figure><p id="2b28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">令人惊讶的是，Redis localhost似乎没有太大的区别，阻塞控制器中的作业队列甚至更快。</p><p id="a230" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，我们是在网络延迟为0的情况下进行测试的，因此这在这种情况下会发挥作用。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="4a00" class="np mo iq bd mp nq nr dn mt ns nt dp mx lf nu nv mz lj nw nx nb ln ny nz nd oa bi translated">测试套件— Redis remote，<strong class="ak"> EU到EU </strong></h2><p id="b807" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">在真正的prod部署中，您可能会使用Redis的托管版本，并且它不会与您的应用程序位于同一主机上，因此网络延迟很重要。最好的情况是同一个地区/VPC。</p><p id="43dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用过Redislabs的一个8美元的集群。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/faab493ed88242c28f2f6a5d9b1b495c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*taaGfO4XiigEMS70YXtpvg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Redis remote的测试套件结果。RPM —越高越好。延迟—越低越好。</p></figure><p id="c302" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些结果再次证实了我最初的合成延迟运行。非阻塞工作流比阻塞好得多，即使对于非常高速的插入也是如此。</p><p id="da5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，网络延迟成为最大的限制因素，请注意在所有测试案例中，阻塞版本的<em class="og">延迟时间</em>几乎增加到了<em class="og">100毫秒</em>。</p><p id="0bf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里最引人注目的一点是低x10并发性。带有拦截器的路由<em class="og">响应速度几乎快了x50，可以处理x40个以上的请求</em>。</p><p id="a300" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以注意到，拦截器版本的控制器的RPM在所有测试套件中都是相似的——这是因为它正好达到了我的Node.js (1个CPU)资源限制。因此，在使用集群应用版本时，还有更大的改进潜力。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="4fa0" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">结论</h1><p id="e486" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们已经看到<em class="og">延迟在8倍到50倍</em>的范围内有所改善。对于<em class="og"> RPM，它在6x到40x </em>的范围内。</p><p id="5884" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保守地说，对于日志、度量和后台作业等非关键任务的工作负载，使用拦截器(中间件)至少可以获得10倍的性能提升。</p><p id="f2dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你正在做一个中型或大型的项目，回顾一下你的一些控制器是很好的，这样可以节省处理资源。</p><p id="5c8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于一个低RPM的小项目，我不会打扰，但要记住这个解决方案，以备将来使用。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="55fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">包含测试代码的库在这里:<a class="ae kv" href="https://github.com/dkhorev/nestjs-interceptor-benchmark-demo" rel="noopener ugc nofollow" target="_blank">https://github . com/dk horev/nestjs-interceptor-benchmark-demo</a></p><p id="41b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基准记录可在此<a class="ae kv" href="https://docs.google.com/spreadsheets/d/1oGZdzZ6qbJRvCNqaiw5jtvR2uQOSE5ZgAfmiIW5IzTE/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank"> google工作表</a>中找到。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="3e40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这对你有帮助。祝好运，工程快乐！</p></div></div>    
</body>
</html>