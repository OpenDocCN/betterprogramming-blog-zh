<html>
<head>
<title>Preventing Data Races Using Actors in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中使用Actors防止数据竞争</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/preventing-data-races-using-actors-in-swift-ed3d8a69adf3?source=collection_archive---------9-----------------------#2021-09-08">https://betterprogramming.pub/preventing-data-races-using-actors-in-swift-ed3d8a69adf3?source=collection_archive---------9-----------------------#2021-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b55e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">告别数据竞赛</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/de86bc9895d90ecfbc9afd1e41e821aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r2TI4R_Ttel_m_Y9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">汤米·范·凯塞尔的照片🤙 on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="61c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据竞赛——所有开发人员最糟糕的噩梦！它们很难被发现，非常不可预测，并且极难修复。苹果给了开发者各种工具集，如<code class="fe lv lw lx ly b">NSLock</code>和串行队列，以防止运行时发生数据竞争，然而，它们都不能在编译时捕捉竞争条件。随着Swift 5.5的发布，这种情况将不复存在！</p><p id="943b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">介绍<strong class="lb iu"> Actor </strong>，新的Swift语言特性可以帮助开发者在开发期间捕捉任何可能的竞争条件。在本文中，我们将首先看看在使用调度队列和异步任务时，数据竞争是如何发生的。之后，我们将看看演员如何帮助我们识别代码中的竞态条件，并一劳永逸地防止它们发生！</p><p id="73f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">别再浪费时间了，让我们开始吧。</p><h1 id="259a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">数据竞争是如何发生的？</h1><p id="691e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">当两个或多个线程试图同时异步访问(读/写)同一个内存位置时，就会发生数据竞争。在Swift环境中，当我们试图使用调度队列修改对象的状态时，通常会发生这种情况。我这么说是什么意思？</p><p id="8948" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的<code class="fe lv lw lx ly b">Counter</code>类，它有一个<code class="fe lv lw lx ly b">count</code>变量，每调用一次<code class="fe lv lw lx ly b">addCount()</code>函数，它就增加1:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="da70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，假设我们有一个将触发以下代码的按钮:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="bc7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，上面的代码所做的就是使用调度组异步调用<code class="fe lv lw lx ly b">Counter</code>的<code class="fe lv lw lx ly b">addCount()</code>函数1000次。一旦调度组执行完成，我们将在标签上显示<code class="fe lv lw lx ly b">counter</code>的<code class="fe lv lw lx ly b">count</code>值。</p><p id="cfa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理想情况下，当我们每次点击按钮时，我们应该看到标签上显示的<em class="my"> 1，000 </em>，然而事实并非如此。我们得到的结果非常不一致。我们可能偶尔会得到<em class="my"> 1，000 </em>，但通常我们得到的值都小于<em class="my"> 1，000 </em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/f58893cbfadf2ab98728169e690e9fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*gfWTnoCW9vjUE8Lj"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据竞争导致的结果不一致</p></figure><p id="fa90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经猜到，这种不一致是由数据竞争引起的。当多个线程(由调度队列产生)试图异步访问<code class="fe lv lw lx ly b">count</code>时，不能保证每个线程都将一个接一个地更新<code class="fe lv lw lx ly b">count</code>的值，从而导致最终的结果非常不一致并且很难预测。</p><p id="71db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">亲提示:</strong></p><p id="adb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Xcode有一个<strong class="lb iu">线程杀毒器</strong>，帮助开发者以更一致的方式检测数据竞争。您可以导航到<strong class="lb iu">产品</strong> &gt; <strong class="lb iu">方案</strong> &gt; <strong class="lb iu">编辑方案… </strong>之后，在编辑方案对话框中选择<strong class="lb iu">运行</strong> &gt; <strong class="lb iu">诊断</strong> &gt;勾选<strong class="lb iu">线程杀毒器</strong>复选框。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/638974087b2b19e2a8ede0363c9496e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7jMg8gBb7n1msFKC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">启用Xcode线程杀毒程序</p></figure><p id="b43a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您知道了数据竞争是如何发生的，如果我们使用async/await和异步任务做同样的事情，会发生数据竞争吗？让我们来了解一下！</p><h1 id="ce31" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">异步任务和数据竞争</h1><p id="0f10" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在Swift并发领域，任务和任务组的工作方式类似于调度队列和调度组。我们可以通过创建一个产生一组异步执行<code class="fe lv lw lx ly b">addCount()</code>功能的子任务的父任务来实现前面的数据竞争条件。下面是如何做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="abd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们使用<code class="fe lv lw lx ly b">withTaskGroup(of:body:)</code>方法来创建一个任务组。在任务组中，我们创建1000个子任务来异步执行<code class="fe lv lw lx ly b">addCount()</code>功能。值得一提的是，<code class="fe lv lw lx ly b">withTaskGroup(of:body:)</code>方法是可调整的，因此它将被挂起，直到所有子任务完成。一旦发生这种情况，我们将在标签上显示<code class="fe lv lw lx ly b">count</code>值。</p><p id="d29c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我尝试运行上面的代码时，我得到的结果惊人地一致！每次代码执行完毕，我都能看到标签上显示<em class="my"> 1，000 </em>。这是否意味着当我们使用任务和任务组时，数据竞争不会发生？🤔</p><p id="e3eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可惜，答案是否定的！</p><p id="82a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我尝试在启用线程杀毒器的情况下运行上面的代码时，我仍然会得到一个线程杀毒器警告，表明数据竞争确实发生了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/45c71e63fecfccf5ee987925aefaaf3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LNjgoIrZy0HM8qbc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Xcode线程消毒警告</p></figure><p id="b2cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果是，那么为什么我们能够得到如此一致的结果？我的猜测是，苹果在优化整个Swift并发模块方面做得非常好，因此它能够解决简单的数据竞争情况，就像我们在样本代码中遇到的情况一样。</p><p id="025a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用调度队列时，我们可以通过使用串行调度队列来防止并发写入，从而避免数据竞争。如果使用异步任务，我们应该使用什么来防止并发写入？这就是演员的用武之地。</p><h1 id="267d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">拯救行动的演员</h1><p id="59fe" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">Actor是Swift 5.5中引入的新语言功能，主要用于帮助开发人员在开发期间识别任何可能的数据竞争情况。正如您稍后将看到的，每当我们试图编写可能导致数据竞争的代码时，编译器都会给我们一个编译错误。如果你不熟悉演员是如何工作的，可以参考我之前的<a class="ae ky" href="https://swiftsenpai.com/swift/swift-concurrency-get-started/#actor" rel="noopener ugc nofollow" target="_blank">文章</a>讲演员的基础知识。</p><p id="2b78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们试着把<code class="fe lv lw lx ly b">Counter</code>班改成演员。我们需要做的就是把<code class="fe lv lw lx ly b">class</code>换成<code class="fe lv lw lx ly b">actor</code>，就这样！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="701b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个阶段，我们的示例代码将在我们试图访问<code class="fe lv lw lx ly b">count</code>变量的地方给出两个编译错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/fe28a328ab00faed4faaaebf5041bf82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LIVRJ5ohfLYZJq1h2PtrOw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Swift编译器捕捉数据竞争</p></figure><p id="006c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误消息“<em class="my">表达式为‘async’但未标记‘await’</em>”到底是什么意思？这意味着我们不能像这样简单地访问<code class="fe lv lw lx ly b">count</code>变量！</p><p id="3b71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe lv lw lx ly b">Counter</code>现在是一个actor，它一次只允许一个异步任务访问它的可变状态(变量<code class="fe lv lw lx ly b">count</code>)。因此，如果我们要访问<code class="fe lv lw lx ly b">count</code>变量，我们必须用<code class="fe lv lw lx ly b">await</code>标记两个访问点，表明如果有另一个任务访问<code class="fe lv lw lx ly b">count</code>变量，这些访问点可能会挂起。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e0c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得一提的是，actors将保护它的可变状态，使其不被<strong class="lb iu"> read </strong>和<strong class="lb iu"> write </strong>访问。这就是为什么我们会在示例代码中的两个<strong class="lb iu"> </strong>访问点上都出现编译错误。</p><p id="58f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有它！这就是我们如何通过使用参与者来防止数据竞争。如果您想亲自尝试一下示例代码，请在这里随意获取。</p><h1 id="5778" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">包扎</h1><p id="e956" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在Swift中包含actors无疑是一个受欢迎的做法。它使我们能够用很少的编码工作编写更安全的异步代码。事实上，它是一种语言特性，使得它能够在编译时捕捉任何可能的竞争情况，从而防止我们意外地将数据竞争导致的错误发送给我们亲爱的应用程序用户。</p><p id="aa52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你觉得这篇文章有帮助，你可能想看看我的另一篇关于Swift并发的文章:“<a class="ae ky" href="https://swiftsenpai.com/swift/async-await-network-requests/" rel="noopener ugc nofollow" target="_blank">在Swift </a>中用Async/await发出网络请求。”</p><p id="b5a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">欢迎在<a class="ae ky" href="https://twitter.com/Lee_Kah_Seng" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，这样你就不会错过我即将发布的任何与iOS开发相关的文章。</p><p id="212d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。👨🏻‍💻</p></div></div>    
</body>
</html>