# 3 个会破坏规模的工程错误

> 原文：<https://betterprogramming.pub/3-toxic-engineering-attitudes-that-botch-scale-709b0672747>

## 随着团队和代码库的增长，不要做什么

![](img/94a1e53b838a6ba50782e0b3b630268b.png)

由[鲁本·米什丘克](https://unsplash.com/@ruben244?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片。

# **1。过于关注**之前的情况

遗留代码困扰着每个工程师。随着系统变得过时，我们告诉自己，“不要碰它，它能工作”。新的战功隐现。曾经热情的用户厌倦了同样的旧体验。我们说服自己“尊重”那里的东西，因为“那是当时建造的正确的东西。”我们锁定了系统不变量，这些不变量会产生相同的旧的错误行为。我们默许旧的方式。我们沉浸在过去的成功或荣耀中。老化的系统甚至成为文化传统，资深人士解释说:

> “这就是我们这里的做法。”

这种态度破坏了我们的扩展能力，因为它抑制了我们满足动态市场不断增长和变化的需求的能力。企业的未来被它的过去所窒息。起初，它完全不被注意。不可避免地，它变成了成功本身的一个功能:每一次过去的成功都会越来越多地阻碍下一次未来的成功。

遗留代码分散了我们对系统*应该*做什么的注意力。

当我们对遗产进行逆向工程时，我们忘记了我们最初为什么要关注它。当我们终于记起的时候，我们更愿意扭曲我们的最终目标来适应我们已经拥有的，就在我们面前的东西。“已经建了一半了，”我们对自己说。就这样，我们过去的成功模糊了我们未来的方向。

打破这种恶性循环所需要的品质是勇气。

# **2。过于注重完美**

设定 100%的生产正常运行时间目标是不现实的，也是浪费。如果你做到了，那么恭喜你，你没有承担足够的风险，或者应该走得更快。

设定 100%代码覆盖率的测试目标是不现实的，也是浪费。如果你做到了，那么恭喜你，下次你修改第 *N* 行代码时，你也必须修改第 *N* 行测试。

期望每一次测试都是绿色的是不现实和浪费的。如果你做到了，恭喜你，你持续的绿色测试给你零反馈。

对完美的关注削弱了我们快速交付和适应不断变化的市场需求的能力。

微小的、不完美但有用的改进是我们应该期望自己做出的唯一改变。

成功取决于强烈的谦卑感。

# **3。不为对方构建软件**

当我们设计软件时，我们会做很多思考。我们考虑让用户满意的用例。我们列举错误边缘情况。我们设计直观的图形用户界面。我们使用最新的多线程技术分派工作。我们使用最新的 Kubernetes 部署策略升级生产系统。那有什么问题呢？

写软件就像任何其他类型的写作一样:你必须意识到你的读者。

如果受众是系统，那么我们把工程印章集中在原始功能上。正确性。效率和性能。规模。可靠性。

但是系统不是工程师写软件时的观众。当然，系统执行指令，但是它不*读取*指令。当事情出问题时，系统不会自行调试。系统不会自我重构。当新的 CVE 发布时，系统不会自我升级。系统本身不会运行性能测试。当系统忘记如何工作时，它不会对自己进行逆向工程。工程师会。

想想就很恐怖。所有这些软件需要被拼接成一个单一的、一致的自动机，每秒执行数千亿次运算。

计算机系统可以说是人类创造的最复杂的机器，而且它们是无形的。

有多少工程师接触过一个系统？硬件、固件、驱动程序、操作系统、所有用户空间功能，更不用说您的应用程序了。几十万甚至几百万的工程师。我们必须坚持一个一致的故事情节和已知的范例，以一种容易被我们的观众理解的方式:我们的工程师同事。

因此，这意味着标准和惯例不仅仅是针对系统的。它们对我们来说是肉脑。坚持规则让我们理解这些系统是如何运作的。如果每个人都在重新发明轮子，我们交付、重用、代码共享、协作和构建的能力就会荡然无存。

高级工程师的标志是，他们不仅写软件，而且为特定的受众写软件:其他工程师。

这里的成功需要敏锐的同理心和对标准的执着。