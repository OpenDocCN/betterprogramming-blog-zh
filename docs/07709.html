<html>
<head>
<title>The Power of Single-Element Collections in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元素集合在角度上的力量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/single-element-collections-in-angular-8b1c263e3d18?source=collection_archive---------8-----------------------#2021-02-11">https://betterprogramming.pub/single-element-collections-in-angular-8b1c263e3d18?source=collection_archive---------8-----------------------#2021-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="93bc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">避免创建复杂的setters迷宫</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a4c7d9e3f4b90bf80ed0b00f352245a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZFt5dTYEx_IzMUAX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">埃斯特万·洛佩兹在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="b652" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我想分享我对在Angular应用程序中使用单元素集合的力量的想法。我在日常工作中经常发现这方面的用例，所以也许你也会发现它很有用。</p><p id="40eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从一些典型的事情开始:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a48a" class="ma mb it lw b gy mc md l me mf">&lt;workitem-card <br/>  *ngFor="let item of selectedWorkItems"<br/>  [item]="item"<!-- --> <br/>&gt;<!-- --> </span></pre><p id="bea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样的代码我们已经见过很多次了，在我们看来非常自然。每当我们向<code class="fe mg mh mi lw b">selectedWorkItems</code>数组添加一个新元素时，Angular将初始化组件的一个新实例，并在视图中呈现它。一切照旧。</p><p id="70e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在考虑这个:<code class="fe mg mh mi lw b">selectedWorkItems</code>集合可以有<code class="fe mg mh mi lw b">0</code>或<code class="fe mg mh mi lw b">1</code>元素。</p><p id="2f11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，是否还有一个<code class="fe mg mh mi lw b">*ngFor</code>的位置，或者我们应该在组件上切换到一个单独的<code class="fe mg mh mi lw b">selectedWorkItem</code>字段？</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="17e6" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">*ngFor可用于渲染单个元素</h1><p id="64ff" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">让我们想象一下组件模板中的以下结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0c10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在组件中:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3ae5" class="ma mb it lw b gy mc md l me mf">selectedItem: WorkItem = null;<br/>selectItem(item: WorkItem) { this.selectedItem = item };</span></pre><p id="9e71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">又一次，看起来很典型。我们有一个集合(<code class="fe mg mh mi lw b">workItems</code>)，我们允许用户通过点击它来选择一个元素。一旦我们选择了它，我们通过<code class="fe mg mh mi lw b">*ngIf</code>显示<code class="fe mg mh mi lw b">workitem-card</code>组件。</p><p id="c42c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种经典的方法，但是如果使用不当，可能无法达到预期的效果…</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d806" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">*只要条件为真，ngIf就保持相同的组件实例</h1><p id="05f0" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">想想当用户开始点击项目并改变所选项目时会发生什么。</p><p id="feab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">条件将保持真实，因为<code class="fe mg mh mi lw b">selectedItem</code>字段永远不会是<code class="fe mg mh mi lw b">null</code>，因此<code class="fe mg mh mi lw b">*ngIf</code>将保持<code class="fe mg mh mi lw b">workitem-card</code>组件可见。只有它的输入<code class="fe mg mh mi lw b">[item]</code>会改变它的值。</p><p id="74d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">workitem-card</code>组件设置逻辑将不会重新运行。其<code class="fe mg mh mi lw b">constructor</code>和<code class="fe mg mh mi lw b">ngOnInit</code>将不会根据新的输入值运行。第一次点击后会初始化，仅此而已。您可能知道，init逻辑通常高度依赖于组件的键输入。不重新运行它，我们只是冒着组件行为不正常的风险。</p><p id="d054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，您可以重构<code class="fe mg mh mi lw b">workitem-card</code>组件。添加一个setter，给它的代码增加额外的复杂性，然后像那样处理问题。但是有多个输入设置器的组件，它们的初始化逻辑分布在设置器之间，总是很难维护和扩展。所以对我来说，触摸<code class="fe mg mh mi lw b">workitem-card</code>显然是错误的方式。</p><p id="7700" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在真正想要的唯一一件事是，每当您选择另一个项目时，生成一个<code class="fe mg mh mi lw b">workitem-card</code>组件的新实例。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="71a3" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">单项集合可用于实现项目选择机制</h1><p id="1129" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">如开头所述，每当您向集合中添加一条新记录时，<code class="fe mg mh mi lw b">*ngFor</code>都会为您提供一个新的组件实例。那么为什么现在不使用它呢？</p><p id="cf8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以按以下方式重写代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="651c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在组件中:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3d5b" class="ma mb it lw b gy mc md l me mf">selectedItems: WorkItem[] = [];<br/>selectItem(item: WorkItem) { this.selectedItems = [item] };</span></pre><p id="06a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切都像以前一样工作——但更好。每当你选择一个新的项目，你就会得到一个<code class="fe mg mh mi lw b">workitem-card</code>组件的新实例！</p><p id="e502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你把<code class="fe mg mh mi lw b">*ngIf</code>换成了<code class="fe mg mh mi lw b">*ngFor</code>，现在一切都更简单了。您不必接触<code class="fe mg mh mi lw b">workitem-card</code>组件实现。您挑选工作项并为其获取组件。就这么简单。正如我们所希望的，每次都有新的例子。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4d53" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">结论</h1><p id="3807" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">通过将选中的项保存在数组中而不是单个字段中，可以避免创建复杂的setters迷宫，并且只在<code class="fe mg mh mi lw b">ngOnInit</code>方法中保存子组件的init逻辑。</p><p id="f8f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，在大多数情况下，您不会丢失任何东西，总体性能影响也很小。</p><p id="0693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>