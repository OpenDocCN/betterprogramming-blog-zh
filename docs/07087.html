<html>
<head>
<title>Getting Started With Minecraft Plugin Development With Bukkit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Bukkit《我的世界》插件开发入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-guide-to-minecraft-plugin-development-with-bukkit-part-1-36490aaeb510?source=collection_archive---------2-----------------------#2020-12-05">https://betterprogramming.pub/a-guide-to-minecraft-plugin-development-with-bukkit-part-1-36490aaeb510?source=collection_archive---------2-----------------------#2020-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ad60" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Java开发人员指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7734b7b48f2e6869224dc218ec5ad7f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rx9AAA7qBSOwF5zN"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@nina_eyes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">妮娜·里瓦斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="542b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，我决定在CoderDojo Linz 举办一系列关于Java开发的研讨会。由于那里的许多孩子和青少年喜欢玩《我的世界》，选择《我的世界》插件开发作为这些研讨会的主题是一个直截了当的决定。</p><p id="e8ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我以前从未玩过《我的世界》，所以我想先了解一下这个游戏。我玩2到3个小时来学习基础知识的计划升级得相当快，结果我一个星期都没有产出。嗯，我可能已经预料到了。无论如何，现在我回来了，在接下来的部分，我总结了一些关于用<a class="ae kv" href="https://bukkit.org/" rel="noopener ugc nofollow" target="_blank"> Bukkit </a>开发《我的世界》插件的基础知识。</p><h1 id="2ca7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">先决条件</h1><p id="24e2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">请注意，本指南假设您已经熟悉Java。如果你是Java新手，我建议你先了解Java。在这里，你可以找到一些很好的资源来学习它。</p><p id="597c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，有一点与<a class="ae kv" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> Gradle </a>或<a class="ae kv" href="https://maven.apache.org/" rel="noopener ugc nofollow" target="_blank"> Maven </a>相处的经验也不错。我们使用这些构建工具将依赖项(简而言之:来自他人的代码)加载到我们的项目中，并将项目打包到Java档案(JAR)中。</p><p id="918a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本指南给出了你在<code class="fe mp mq mr ms b">build.gradle</code>或<code class="fe mp mq mr ms b">pom.xml</code>中需要的所有代码，但是如果你大致知道他们在做什么就更好了。</p><p id="fed1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，您需要用自己的构建工具创建一个新项目。这里有一些给<a class="ae kv" href="https://www.baeldung.com/gradle" rel="noopener ugc nofollow" target="_blank"> Gradle </a>和<a class="ae kv" href="https://www.baeldung.com/maven" rel="noopener ugc nofollow" target="_blank"> Maven </a>的不错的指南。</p><h1 id="4196" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">运行本地Spigot服务器</h1><p id="dea8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要在你的服务器上安装Bukkit插件，你需要运行一个CraftBukkit服务器或者它的一个分支，比如<a class="ae kv" href="https://www.spigotmc.org/" rel="noopener ugc nofollow" target="_blank">龙头</a>或者<a class="ae kv" href="https://papermc.io/" rel="noopener ugc nofollow" target="_blank">纸张</a>。您可以按照下面描述的步骤启动并连接到Spigot服务器。</p><blockquote class="mt mu mv"><p id="dae6" class="kw kx mw ky b kz la jr lb lc ld ju le mx lg lh li my lk ll lm mz lo lp lq lr ij bi translated">注意:这个指南是关于插件开发的，所以我没有太在意我选择的服务器。在很多情况下，你可能会选择纸而不是龙头，但是插件开发的工作流程是一样的。</p></blockquote><ol class=""><li id="1e13" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">从<a class="ae kv" href="https://hub.spigotmc.org/jenkins/job/BuildTools/lastSuccessfulBuild/artifact/target/BuildTools.jar" rel="noopener ugc nofollow" target="_blank">https://hub . spigotmc . org/Jenkins/job/build tools/lastsccessfulbuild/artifact/target/build tools . jar</a>下载最新的<code class="fe mp mq mr ms b">BuildTools</code>。</li><li id="b498" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">在你的终端中用命令<code class="fe mp mq mr ms b">java -jar BuildTools.jar</code>执行文件<code class="fe mp mq mr ms b">BuildTools.jar</code>。</li><li id="c8ac" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">将文件<code class="fe mp mq mr ms b">spigot-&lt;VERSION&gt;.jar</code>复制或移动到一个空文件夹，用<code class="fe mp mq mr ms b">java -jar spigot-&lt;VERSION&gt;.jar</code>执行。</li><li id="1efa" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">这将产生一些文件和文件夹，但不会旋转服务器，因为你需要接受《我的世界》的最终用户许可协议(EULA)第一。要接受它，打开文件<code class="fe mp mq mr ms b">eula.txt</code>并将行<code class="fe mp mq mr ms b">eula=false</code>改为<code class="fe mp mq mr ms b">eula=true</code>。保存并关闭文件。</li><li id="86cc" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">再次执行<code class="fe mp mq mr ms b">spigot-&lt;VERSION&gt;.jar</code>启动服务器。一旦线<code class="fe mp mq mr ms b">[09:08:39 INFO]: Done (XXXs)! For help, type "help"</code>出现，你就准备好了。</li><li id="4e27" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">打开《我的世界》，选择“多人游戏”。在那里，您可以连接到运行在<code class="fe mp mq mr ms b">localhost</code>上的新服务器。</li></ol><h1 id="41eb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">创建基本插件</h1><p id="c5ff" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，您的服务器已经启动并运行，是时候创建一个基本插件了。首先，用Gradle或Maven创建一个新的Java项目。我用的是Gradle和Java 11，但Maven也在本节中介绍。此外，我使用了IntelliJ IDEA社区作为IDE。</p><p id="ae1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用Bukkit的<a class="ae kv" href="https://www.freecodecamp.org/news/what-is-an-api-in-english-please-b880a3214a82/" rel="noopener ugc nofollow" target="_blank"> API </a>，你需要将以下依赖项添加到你的<code class="fe mp mq mr ms b">build.gradle</code>中，并用Bukkit API的当前版本替换<code class="fe mp mq mr ms b">[VERSION]</code>，你可以在这里找到<a class="ae kv" href="https://hub.spigotmc.org/nexus/content/repositories/public/org/bukkit/bukkit/maven-metadata.xml" rel="noopener ugc nofollow" target="_blank">。在撰写本文时，最新版本是<code class="fe mp mq mr ms b">1.15.2-R0.1-SNAPSHOT</code>。</a></p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="39fa" class="ns lt iq ms b gy nt nu l nv nw">implementation group: 'org.bukkit', name: 'bukkit', version: '[VERSION]'</span></pre><p id="939f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这个依赖项没有存储在任何标准存储库中，所以您还需要添加以下存储库。</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="5389" class="ns lt iq ms b gy nt nu l nv nw">maven { <br/>  url "https://hub.spigotmc.org/nexus/content/repositories/public/" <br/>}</span></pre><p id="e12e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您决定选择Maven而不是Gradle，那么您需要向您的<code class="fe mp mq mr ms b">pom.xml</code>添加以下依赖项。</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="9840" class="ns lt iq ms b gy nt nu l nv nw">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.bukkit&lt;/groupId&gt;<br/>    &lt;artifactId&gt;bukkit&lt;/artifactId&gt;<br/>    &lt;version&gt;[VERSION]&lt;/version&gt;<br/>    &lt;type&gt;jar&lt;/type&gt;<br/>    &lt;scope&gt;provided&lt;/scope&gt;<br/>&lt;/dependency&gt;</span></pre><p id="77d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，您还需要添加以下存储库。</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="7fe7" class="ns lt iq ms b gy nt nu l nv nw">&lt;repository&gt;<br/>    &lt;id&gt;spigot-repo&lt;/id&gt;<br/>    &lt;url&gt;https://hub.spigotmc.org/nexus/content/repositories/public/&lt;/url&gt;<br/>&lt;/repository&gt;</span></pre><p id="3393" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在是时候创建插件的主类了。因此，您现在必须创建一个新的Java类。您可以随意命名它，我将本指南的主类简单地命名为<code class="fe mp mq mr ms b">BukkitPlugin</code>，这绝对不是一个好的描述性名称。当你开发一个真正的插件时，试着为你的类找到描述性的名字。</p><p id="dd28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让你的新类扩展<code class="fe mp mq mr ms b">org.bukkit.plugin.java.JavaPlugin</code>，覆盖方法<code class="fe mp mq mr ms b">onEnable(...)</code>，你就可以开始了。此时，您的整个类应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="f314" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您的插件在服务器上启用时，总是会调用<code class="fe mp mq mr ms b">onEnable(...)</code>方法。</p><p id="0292" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，您需要配置您的插件。要完成这一步，在项目的<code class="fe mp mq mr ms b">resources</code>文件夹中创建文件<code class="fe mp mq mr ms b">plugin.yml</code>。</p><blockquote class="mt mu mv"><p id="3de1" class="kw kx mw ky b kz la jr lb lc ld ju le mx lg lh li my lk ll lm mz lo lp lq lr ij bi translated">信息:<a class="ae kv" href="https://yaml.org/" rel="noopener ugc nofollow" target="_blank"> YAML (YAML不是标记语言)</a>是一种人类可读的数据序列化标准，通常用于配置文件。它使用文件扩展名<code class="fe mp mq mr ms b">.yaml</code>或<code class="fe mp mq mr ms b">.yml</code>。</p></blockquote><p id="695f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Bukkit加载插件需要这个文件。您可以在这个文件中配置很多东西，但是有三个属性是必需的:</p><ul class=""><li id="0401" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">name</code>:你的插件的名字(不能包含任何空格)。</li><li id="1e50" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">version</code>:你插件的版本。</li><li id="6feb" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">main</code>:你插件的主类。</li></ul><p id="d8cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在<a class="ae kv" href="https://bukkit.gamepedia.com/Plugin_YAML" rel="noopener ugc nofollow" target="_blank"> BukkitWiki </a>中找到所有可用的属性。我建议也提供属性<code class="fe mp mq mr ms b">api-version</code>。它描述了您打算使用Bukkit的哪个API版本。设置完所有这些属性后，您的<code class="fe mp mq mr ms b">plugin.yml</code>应该包含以下属性:</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="5891" class="ns lt iq ms b gy nt nu l nv nw">name: MinecraftPluginGuide_DemoPlugin<br/>main: BukkitPlugin<br/>version: 0.1<br/>api-version: 1.16</span></pre><p id="c2c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你创建了一个非常基本的插件。它不会做任何事情，但是您已经为接下来的步骤设置好了您需要的一切，您可以进入下一部分，学习如何将您的插件部署到服务器。</p><h1 id="58fd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">部署插件</h1><p id="9063" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要部署插件，首先需要生成一个包含所有代码和依赖项(如果有的话)的JAR文件。接下来，确保您的服务器没有运行，并将JAR复制到服务器的<code class="fe mp mq mr ms b">plugins</code>目录中。现在你可以运行你的服务器了(见第1节),你的插件将被加载。你可以通过在游戏中运行命令<code class="fe mp mq mr ms b">pl</code>或者直接在服务器窗口检查它是否工作。您的插件应该包含在结果列表中。除此之外，当你的插件被加载时，你会看到一个日志消息。</p><p id="f3ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面几节描述了如何用Gradle和Maven将项目打包到一个JAR中。</p><h2 id="ee66" class="ns lt iq bd lu oa ob dn ly oc od dp mc lf oe of me lj og oh mg ln oi oj mi ok bi translated">格拉德勒</h2><p id="9b87" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果您只使用Bukkit的依赖项，您可以通过在终端中执行以下命令来简单地打包您的项目。请注意，您需要在项目的根目录下才能执行它。</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="c21b" class="ns lt iq ms b gy nt nu l nv nw">./gradlew jar</span></pre><p id="ae8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该命令成功后，您可以从项目内的文件夹<code class="fe mp mq mr ms b">build/libs</code>中获得项目的jar。</p><p id="b644" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您使用Bukkit之外的任何其他依赖项，您需要将它们包含在您的JAR中，并创建一个所谓的“胖JAR”。默认情况下，它们不包括在内。您可以创建一个带有<code class="fe mp mq mr ms b">jar</code>任务的fat JAR，只需通过以下方式覆盖它:</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="e341" class="ns lt iq ms b gy nt nu l nv nw">jar { <br/>    manifest { <br/>        attributes "Main-Class": "BukkitPlugin" <br/>    } </span><span id="39d6" class="ns lt iq ms b gy ol nu l nv nw">    from { <br/>        configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } <br/>    } <br/>}</span></pre><p id="7f6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这对于小项目来说是可以的，但是对于更大的项目，我会推荐<a class="ae kv" href="https://github.com/johnrengelman/shadow" rel="noopener ugc nofollow" target="_blank"> Shadow </a>插件。它添加了一个新的生成fat JAR的<code class="fe mp mq mr ms b">gradle</code>任务。</p><p id="2316" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要添加它，您需要将下面的依赖项添加到您的<code class="fe mp mq mr ms b">build.gradle</code>中的<code class="fe mp mq mr ms b">plugins</code>块中。用您想要的版本替换<code class="fe mp mq mr ms b">[VERSION]</code>模块。撰写本文时的最新版本是<code class="fe mp mq mr ms b">6.1.0.</code>。</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="9a8f" class="ns lt iq ms b gy nt nu l nv nw">id 'com.github.johnrengelman.shadow' version '[VERSION]'</span></pre><p id="154a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的<code class="fe mp mq mr ms b">plugins</code>块现在应该是这样的。</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="b089" class="ns lt iq ms b gy nt nu l nv nw">plugins { <br/>    id 'java' <br/>    id 'com.github.johnrengelman.shadow' version '[VERSION]' <br/>}</span></pre><p id="82f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可以通过执行以下命令来创建一个fat JAR。</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="2cf9" class="ns lt iq ms b gy nt nu l nv nw">./gradlew shadowJar</span></pre><h2 id="2ecd" class="ns lt iq bd lu oa ob dn ly oc od dp mc lf oe of me lj og oh mg ln oi oj mi ok bi translated">专家</h2><p id="7eff" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果您只使用Bukkit的依赖项，您可以通过执行相应的Maven任务来简单地打包您的项目。如果要在控制台执行，需要在电脑上安装Maven。因此，我将只使用IntelliJs的内置功能来执行Maven任务。</p><p id="1861" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要创建一个JAR，打开IntelliJ右上角的Maven工具栏(下图中的橙色方块)，然后打开<code class="fe mp mq mr ms b">Lifecycle</code>下拉菜单，如果它是关闭的，单击<code class="fe mp mq mr ms b">package</code>(绿色方块)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/e5d5b7e0c6b83f4c2e1e5b4dee9836bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rscGS8cduwbCeD4zV4647Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">IntelliJ IDEA社区Maven任务</p></figure><p id="1912" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个任务成功后，您可以从项目中的文件夹<code class="fe mp mq mr ms b">target</code>中获得项目的JAR。</p><p id="e2f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您使用Bukkit之外的任何其他依赖项，您需要将它们包含在您的JAR中，并创建一个所谓的“胖JAR”。默认情况下，它们不包括在内。要在maven中创建一个fat JAR，首先需要在您的<code class="fe mp mq mr ms b">pom.xml</code>中的<code class="fe mp mq mr ms b">version</code>标签下添加一行<code class="fe mp mq mr ms b">&lt;packaging&gt;jar&lt;/packaging&gt;</code>。</p><p id="c58b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们将使用<a class="ae kv" href="https://maven.apache.org/plugins/maven-shade-plugin/" rel="noopener ugc nofollow" target="_blank"> Apache Maven Shade插件</a>来创建一个胖罐子。将以下程序块添加到您的<code class="fe mp mq mr ms b">pom.xml</code>中进行配置。请注意，在复制下面的配置时，您可能需要更改主类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="bf23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在您可以再次执行<code class="fe mp mq mr ms b">package</code>任务，将会生成两个jar。后缀为“-shaded”的是脂肪罐。</p><h1 id="c330" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">记录</h1><p id="5961" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Bukkit有一个内置的日志记录机制，运行得相当好。以下小节描述了如何使用它。</p><h2 id="6822" class="ns lt iq bd lu oa ob dn ly oc od dp mc lf oe of me lj og oh mg ln oi oj mi ok bi translated">获取记录器</h2><p id="78cf" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您可以通过调用<code class="fe mp mq mr ms b">Bukkit.getLogger()</code>或(如果您在<code class="fe mp mq mr ms b">JavaPlugin</code>类中)<code class="fe mp mq mr ms b">getServer().getLogger()</code>来获得服务器的主记录器的实例。您可以使用这个日志记录器向服务器的日志流发送消息，但是我建议您使用您插件的日志记录器。这样，很明显日志消息来自你的插件，因为它们是有前缀的。要获得这个日志记录器，你需要在你的<code class="fe mp mq mr ms b">JavaPlugin</code>类中。在那里你可以简单地调用<code class="fe mp mq mr ms b">getLogger()</code>。我将在下面的例子中使用这种方法。</p><h2 id="d85a" class="ns lt iq bd lu oa ob dn ly oc od dp mc lf oe of me lj og oh mg ln oi oj mi ok bi translated">日志级别</h2><p id="6dad" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Bukkit提供了7个预定义的日志级别，您应该使用它们来区分您的日志消息。这些级别(按降序排列)是:</p><ul class=""><li id="9443" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">SEVERE</code>:表示严重故障</li><li id="b51e" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">WARNING</code>:表示潜在问题</li><li id="1491" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">INFO</code>:信息性消息</li><li id="2687" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">CONFIG</code>:静态配置消息</li><li id="6851" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">FINE</code>:追踪信息</li><li id="732b" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">FINER</code>:相当详细的追踪信息</li><li id="3edd" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">FINEST</code>:非常详细的跟踪信息</li></ul><p id="65eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，<code class="fe mp mq mr ms b">INFO</code>以上的所有日志级别都会打印到控制台。</p><h2 id="a69f" class="ns lt iq bd lu oa ob dn ly oc od dp mc lf oe of me lj og oh mg ln oi oj mi ok bi translated">记录消息</h2><p id="6aa2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要记录消息，您可以简单地执行下面一行。当然，第一个参数可以替换为上述任何日志级别。第二个参数，消息，也可以由你选择。</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="d29c" class="ns lt iq ms b gy nt nu l nv nw">logger.log(Level.INFO, "Info log message");</span></pre><p id="4a98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">Logger</code>类还提供了一些直接记录到某个日志流的方法，不需要传递级别。因此，用下面的语句可以得到与上述语句相同的结果。</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="1473" class="ns lt iq ms b gy nt nu l nv nw">logger.info("Info log message");</span></pre><p id="2cd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，这适用于所有日志级别。</p><h2 id="a084" class="ns lt iq bd lu oa ob dn ly oc od dp mc lf oe of me lj og oh mg ln oi oj mi ok bi translated">设置自定义日志前缀</h2><p id="292f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">默认情况下，您在<code class="fe mp mq mr ms b">plugin.yml</code>中提供的<code class="fe mp mq mr ms b">name</code>被用作日志消息的前缀，通过插件类的日志记录器发送。如果您喜欢使用不同的前缀，您可以这样设置<code class="fe mp mq mr ms b">plugin.yml</code>中的属性<code class="fe mp mq mr ms b">prefix</code>:</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="39ad" class="ns lt iq ms b gy nt nu l nv nw">prefix: custom-log-prefix</span></pre><h2 id="8bb0" class="ns lt iq bd lu oa ob dn ly oc od dp mc lf oe of me lj og oh mg ln oi oj mi ok bi translated">更改日志级别并记录到文件</h2><p id="a3f8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">不幸的是，不可能将任何低于<code class="fe mp mq mr ms b">INFO</code>的级别记录到服务器的控制台或标准日志文件中。Bukkit论坛的一个版主说，在<a class="ae kv" href="https://bukkit.org/threads/setting-the-bukkit-log-level.489087/" rel="noopener ugc nofollow" target="_blank">这个帖子</a>。</p><p id="a8dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果您想将级别设置为<code class="fe mp mq mr ms b">INFO</code>(默认设置)、<code class="fe mp mq mr ms b">WARNING</code>或<code class="fe mp mq mr ms b">SEVERE</code>，那么以编程方式设置日志级别才有意义。设置日志级别意味着将记录该级别及其以上级别的所有消息。</p><p id="386a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着如果日志级别为<code class="fe mp mq mr ms b">INFO</code>，所有的<code class="fe mp mq mr ms b">INFO</code>、<code class="fe mp mq mr ms b">WARNING</code>和<code class="fe mp mq mr ms b">SEVERE</code>消息都将被记录。使用下面的命令可以很容易地将日志级别更改为这些级别之一。当然<code class="fe mp mq mr ms b">INFO</code>可以替换为任何其他级别，但是(如上所述)只有<code class="fe mp mq mr ms b">WARNING</code>或<code class="fe mp mq mr ms b">SEVERE</code>有所不同。</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="7c2f" class="ns lt iq ms b gy nt nu l nv nw">logger.setLevel(Level.INFO);</span></pre><p id="86aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，有可能使用所有的日志级别。您只需添加一个定制的处理程序，顾名思义，它处理日志消息。</p><p id="74a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面几行显示了如何将你的插件日志记录程序的所有日志信息发送到一个文件中。这非常有用，因为会生成一个日志文件，其中只包含插件的日志消息。当然，您的插件日志消息仍然会被发送到标准输出流。</p><p id="b5e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了给你的记录器添加一个新的处理程序，我建议覆盖你的<code class="fe mp mq mr ms b">JavaPlugin</code>的<code class="fe mp mq mr ms b">onLoad()</code>方法，并在那里添加下面的代码。请阅读代码中的注释，了解它在做什么。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="6671" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当插件被禁用时，处理程序也应该被关闭。这可以通过以下代码实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4646" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建处理程序时，可以通过设置不同的格式化程序来更改日志消息的格式。以下代码生成格式为<code class="fe mp mq mr ms b">[&lt;TIME&gt;][&lt;LEVEL&gt;]&lt;MESSAGE&gt;</code>的日志消息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="7a79" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">理解《我的世界》坐标系</h1><p id="054c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">玩家的坐标代表他在一个维度中的位置。维度是一个世界中可访问的领域。坐标系的中心是原点。所有玩家的产卵点都位于原点附近。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/9762bf630ca2ea92ba1fe4fcaf229b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ul0TIChev8YTeFsGYTApUA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">《我的世界》坐标系</p></figure><p id="a4c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">《我的世界》有一个三维坐标系，这意味着它有三个轴。它们都在原点相交。以下是可用的轴:</p><ul class=""><li id="be80" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">X</code>轴:代表玩家向原点的东(正值)或西(负值)移动了多远。</li><li id="92ae" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">Z</code>轴:代表玩家向原点的南(正值)或北(负值)移动了多远。</li><li id="30c5" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">Y</code>轴:代表玩家与原点相比有多高(正值)或多低(负值)。</li></ul><p id="f643" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着玩家的位置总是用3个值来描述:X，Y和z。原点的坐标是<code class="fe mp mq mr ms b">X: 0, Y: 0, Z: 0</code>。在玩《我的世界》的时候，你可以简单地通过按下<code class="fe mp mq mr ms b">F3</code>来切换调试屏幕，以查看你当前的坐标。</p><p id="fa3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">坐标系中的一个单位代表一个区块。这意味着位置<code class="fe mp mq mr ms b">X: 1, Y: 0, Z: 0</code>将是原点以东的一个街区。</p><h1 id="acaf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">添加自定义命令</h1><p id="eb3e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要向服务器添加定制命令，您需要完成两个步骤:在插件的<code class="fe mp mq mr ms b">plugin.yml</code>中注册您的命令，并向您的代码添加命令处理程序。这两个步骤都在本节中进行了描述。例如，我们将添加两个非常简单的命令。第一个命令记录特定的消息，而第二个命令记录用户作为参数传递的消息。</p><h2 id="3445" class="ns lt iq bd lu oa ob dn ly oc od dp mc lf oe of me lj og oh mg ln oi oj mi ok bi translated">注册命令</h2><p id="8b73" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要注册您的命令，您需要将它添加到您的插件的<code class="fe mp mq mr ms b">plugin.yml</code>中。您可以使用键<code class="fe mp mq mr ms b">commands</code>添加命令列表。列表项的关键元素是命令名。一个命令可以包含以下属性:</p><ul class=""><li id="ae80" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">description</code>:该命令功能的简短描述。</li><li id="5baa" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">aliases</code>:命令的替代名称。</li><li id="b76d" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">permission</code>:使用该命令所需的权限(更多细节将在本指南的第二部分介绍)。</li><li id="4161" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">permission-message</code>:当没有权限的人试图触发命令时显示的消息。</li><li id="bcfd" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">usage</code>:如何使用该命令的简短描述。</li></ul><p id="c243" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所述，我们将添加两个命令，一个只记录消息，另一个记录用户作为参数传递的消息。您可以在下面看到命令的配置。</p><p id="a915" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，您也可以在此处添加命令权限，但这将包含在本指南的第二部分中。第一个命令，<code class="fe mp mq mr ms b">log-anything</code>可以用三个名字触发:<code class="fe mp mq mr ms b">log-anything</code>、<code class="fe mp mq mr ms b">log_anything</code>和<code class="fe mp mq mr ms b">loganything</code>，因为后两个名字在别名列表中。</p><p id="1013" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，添加大写字母的命令(如<code class="fe mp mq mr ms b">logAnything</code>)不起作用。第二个命令<code class="fe mp mq mr ms b">log</code>接受消息作为参数记录。这里不需要定义参数，因此您必须检查代码中是否给出了正确的参数数量。</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="64c3" class="ns lt iq ms b gy nt nu l nv nw">commands:<br/>    log-anything:<br/>        description: Logs a message to the console<br/>        aliases: [loganything, log_anything] <br/>        usage: /log-anything<br/>    log: <br/>         description: Logs the given message to the console <br/>         usage: /log [message]</span></pre><h2 id="0a2c" class="ns lt iq bd lu oa ob dn ly oc od dp mc lf oe of me lj og oh mg ln oi oj mi ok bi translated">处理命令</h2><p id="896a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有两种方法处理命令:</p><ul class=""><li id="da04" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nz ng nh ni bi translated">在插件的主类中覆盖<code class="fe mp mq mr ms b">onCommand(...)</code>方法。</li><li id="c73c" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated">添加一个定制的<code class="fe mp mq mr ms b">CommandExecutor</code>并覆盖那里的<code class="fe mp mq mr ms b">onCommand(...)</code>方法。</li></ul><p id="ddda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您只有一两个小命令，我会推荐第一个选项。在所有其他情况下，我更喜欢第二种选择，因为它提供了更好的关注点分离。在下面的小节中，显示了这两个选项。</p><h2 id="d525" class="ns lt iq bd lu oa ob dn ly oc od dp mc lf oe of me lj og oh mg ln oi oj mi ok bi translated">在插件的主类中覆盖<code class="fe mp mq mr ms b">onCommand(...)</code></h2><p id="ff74" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对定制命令做出反应的最简单的可能性可能是在插件的主类中覆盖<code class="fe mp mq mr ms b">onCommand(...)</code>方法。每当用户调用一个命令时，该方法被执行，该命令被记录在<code class="fe mp mq mr ms b">plugin.yml</code>中。此方法包含以下参数:</p><ul class=""><li id="4d48" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">CommandSender sender</code>:命令的来源(详见下一小节)。</li><li id="dea7" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">Command command</code>:执行的命令。</li><li id="84b1" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">String label</code>:使用的别名。</li><li id="f777" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">String[] args</code>:传递给命令的参数。</li></ul><p id="38d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当触发的命令有效时，该方法返回true，否则返回false。如果返回false，命令的用法(在<code class="fe mp mq mr ms b">plugin.yml</code>中定义)被发送给播放器。</p><p id="44c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您在<code class="fe mp mq mr ms b">plugin.yml</code>中只注册了一个命令，您不需要检查哪个命令是在<code class="fe mp mq mr ms b">onCommand(...)</code>中发送的。由于我们在上一步中注册了两个命令，我们需要检查应该执行哪个命令。这可以通过一个<code class="fe mp mq mr ms b">if</code>语句或一个<code class="fe mp mq mr ms b">switch</code>语句来完成，如下例所示。要检查哪个命令被发送，您可以使用命令的名称，这可以通过调用<code class="fe mp mq mr ms b">command.getName()</code>获得。以下代码显示了如何区分这些命令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="f889" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来看看<code class="fe mp mq mr ms b">log</code>命令。它接受玩家提供的参数并记录下来。参数始终由空格分隔(即使您用引号将多个单词括起来)。</p><p id="c587" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们不能只记录第一个参数，而是需要结合所有参数来记录用户传递的完整短语。请查看代码中的注释以了解更多细节。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="f507" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">命令<code class="fe mp mq mr ms b">log-anything</code>稍微简单一点，因为它不需要任何参数。因此，它只记录一条消息并返回<code class="fe mp mq mr ms b">true</code>，如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="e4f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的完整<code class="fe mp mq mr ms b">onCommand(...)</code>方法现在应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="f3af" class="ns lt iq bd lu oa ob dn ly oc od dp mc lf oe of me lj og oh mg ln oi oj mi ok bi translated">添加自定义<code class="fe mp mq mr ms b">CommandExecutor</code></h2><p id="9226" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">正如你所想象的，如果你有很多命令并使用前面描述的方法，插件的主类会变得很大。幸运的是，有另外一种选择。您可以添加任意数量的实现<code class="fe mp mq mr ms b">CommandExecutor</code>的类。这些类可以处理你的命令。为此，您需要创建一个新的类，并让它实现<code class="fe mp mq mr ms b">CommandExecutor</code>接口。</p><p id="cff0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将被迫覆盖<code class="fe mp mq mr ms b">onCommand(...)</code>方法，这样做之后，您可以像在插件的主类中一样使用它。如果您只为一个命令注册了一个<code class="fe mp mq mr ms b">CommandExecutor</code>,您可以跳过检查命令名，并假设您为其注册了执行器的命令已被触发。</p><p id="0628" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从实现<code class="fe mp mq mr ms b">CommandExecutor</code>开始。如前所述，它只是一个实现接口并再次覆盖<code class="fe mp mq mr ms b">onCommand(...)</code>的类。我不会进一步详述<code class="fe mp mq mr ms b">onCommand(...)</code>中的代码，因为它与上面的代码完全相同。这堂课唯一值得注意的是，我期待一个<code class="fe mp mq mr ms b">Plugin</code>作为参数。当命令被触发时，这对于获取插件的日志是必要的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="7762" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成<code class="fe mp mq mr ms b">CommandExecutor</code>后，它需要注册到插件主类的<code class="fe mp mq mr ms b">onEnable(...)</code>方法中。这可以通过下面的代码简单地实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="b9df" class="ns lt iq bd lu oa ob dn ly oc od dp mc lf oe of me lj og oh mg ln oi oj mi ok bi translated">命令来源</h2><p id="0ef2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">可以从播放器或服务器控制台发送命令。在某些情况下，检查命令是否由玩家发出可能很重要。您可以实现以下检查，以确保命令是由玩家发送的。</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="ac4f" class="ns lt iq ms b gy nt nu l nv nw">if (sender instanceof Player) { <br/>  // Command was sent from a player <br/>}</span></pre><h2 id="f82b" class="ns lt iq bd lu oa ob dn ly oc od dp mc lf oe of me lj og oh mg ln oi oj mi ok bi translated">命令名</h2><p id="c0c5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">仔细考虑您选择的命令名。选择已经在《我的世界》或其他插件中可用的命令名称，可能会使您的插件与这些插件不兼容。</p><h1 id="3565" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">与玩家交流</h1><p id="6eb0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">和玩家交流有很多种可能。下面的小节描述了一些你可以向玩家发送信息的方法。对于这三种方法，您都需要一个您想与之通信的播放器的实例。正如在其他章节中解释的那样，这里的先决条件是您有一个播放器实例。</p><h2 id="2a34" class="ns lt iq bd lu oa ob dn ly oc od dp mc lf oe of me lj og oh mg ln oi oj mi ok bi translated">发送聊天信息</h2><p id="a169" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">发送聊天信息只需一个命令。你只需要执行播放器的<code class="fe mp mq mr ms b">sendMessage(String message)</code>方法。</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="f181" class="ns lt iq ms b gy nt nu l nv nw">player.sendMessage("This is a chat message");</span></pre><h2 id="ee58" class="ns lt iq bd lu oa ob dn ly oc od dp mc lf oe of me lj og oh mg ln oi oj mi ok bi translated">在游戏中显示消息</h2><p id="8804" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">发送一条直接在游戏中显示的消息，与<code class="fe mp mq mr ms b">sendTitle(...)</code>一起工作，它需要以下参数:</p><ul class=""><li id="c9bb" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">title</code>:要显示的标题。</li><li id="c307" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">subtitle</code>:要显示的字幕。</li><li id="4e6d" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">fadeIn</code>:字幕淡入的时间(默认为10)。</li><li id="e137" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">stay</code>:标题停留的时间(默认为70)。</li><li id="ab8e" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">fadeOut</code>:字幕淡出的时间(默认为20秒)。</li></ul><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="b2b8" class="ns lt iq ms b gy nt nu l nv nw">player.sendTitle("This is a title", "And a subtitle", 10, 70, 20);</span></pre><h2 id="c273" class="ns lt iq bd lu oa ob dn ly oc od dp mc lf oe of me lj og oh mg ln oi oj mi ok bi translated">播放声音</h2><p id="5806" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">播放声音也可以通过简单的方法调用来实现。<code class="fe mp mq mr ms b">playSound(...)</code>该方法需要以下参数:</p><ul class=""><li id="7e74" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">location</code>:在哪里播放声音。</li><li id="8812" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">sound</code>:要播放的声音。不幸的是，只有已经在游戏中的声音可以通过插件播放。您可以通过<code class="fe mp mq mr ms b">Sound</code>枚举来访问它们。</li><li id="13de" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">volume</code>:声音的音量。</li><li id="e071" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><code class="fe mp mq mr ms b">pitch</code>:声音的音高。</li></ul><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="005a" class="ns lt iq ms b gy nt nu l nv nw">player.playSound(player.getLocation(), Sound.ENTITY_PLAYER_LEVELUP, 1, 1);</span></pre><p id="d80a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，声音无法在图像中捕捉，但下图至少显示了与玩家交流的方法1和2。我保证它也播放了声音；-).</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/b016a3b0a3ecfa55c27e10333fc61b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XvMtjjPEMjLo-09cO0Xv3A.png"/></div></div></figure><h1 id="4221" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">下一步是什么？</h1><p id="f9c8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">本指南涵盖了使用Bukkit开发《我的世界》插件的基础知识。为了更深入地了解《我的世界》插件开发的主题，我建议的主题是:</p><ul class=""><li id="899f" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nz ng nh ni bi translated">收听事件</li><li id="a839" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated">添加自定义事件</li><li id="91d9" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated">添加自定义食谱</li><li id="0e3e" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated">添加配置文件</li><li id="ab9b" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated">处理权限</li><li id="5951" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated">持久数据</li><li id="3730" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated">计划任务</li><li id="2fb0" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated">本地化您的插件</li><li id="d731" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated">调试你的插件</li><li id="c582" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated">关于插件部署的更多细节</li></ul><h1 id="d1b2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资源</h1><p id="5e3e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">完整的源代码可以在<a class="ae kv" href="https://github.com/KatharinaSick/minecraft-plugin-guide" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><h1 id="fa7c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">版本信息</h1><ul class=""><li id="c936" class="na nb iq ky b kz mk lc ml lf op lj oq ln or lr nz ng nh ni bi translated"><a class="ae kv" href="https://www.minecraft.net/de-de" rel="noopener ugc nofollow" target="_blank">《我的世界》1.16.4 (Java版)</a></li><li id="c028" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><a class="ae kv" href="https://hub.spigotmc.org/jenkins/job/BuildTools/" rel="noopener ugc nofollow" target="_blank">构建工具#122 </a></li><li id="89ac" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><a class="ae kv" href="https://www.spigotmc.org/" rel="noopener ugc nofollow" target="_blank">龙头1.16.4 </a></li><li id="bf90" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><a class="ae kv" href="https://www.jetbrains.com/idea/download/#section=windows" rel="noopener ugc nofollow" target="_blank"> IntelliJ IDEA社区2020.2.3 </a></li><li id="3354" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated">Java 11</li><li id="f725" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated">Bukkit依赖项:1 . 15 . 2-r 0.1-快照</li><li id="b561" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nz ng nh ni bi translated"><a class="ae kv" href="https://github.com/johnrengelman/shadow" rel="noopener ugc nofollow" target="_blank"> Gradle Shadow插件6.1.0 </a></li></ul></div></div>    
</body>
</html>