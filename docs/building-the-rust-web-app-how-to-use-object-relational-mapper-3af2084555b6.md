# 构建 Rust Web 应用程序—如何使用对象关系映射器

> 原文：<https://betterprogramming.pub/building-the-rust-web-app-how-to-use-object-relational-mapper-3af2084555b6>

## 最大限度地利用容器

![](img/65a62982027a98e6bb676326cc9b2295.png)

照片由[费德里科·博托斯](https://unsplash.com/@landscapeplaces)在 [Unsplash](https://unsplash.com/) 上拍摄

这是关于编写 web 应用程序的系列文章的第三部分。对于这个系列，我们将在 [Rust](https://www.rust-lang.org/learn/get-started) 中编写 web 应用程序，我将向您解释如何自己编写它。

但是，如果您不愿意自己编写代码，我在这里[创建了一个包含本系列所有代码的库。在本系列的每一部分的结尾，我都提交了一个存储库。](https://github.com/garrettudstrand/rust-web-app/tree/main)[在前一部分](/how-to-write-a-web-app-in-rust-part-2-2da195369fc1)中，我们介绍了使用数据库使 CRUD 操作变得更加容易。在这一部分中，我们将讨论如何使用对象关系映射器，或简称 ORM，来使数据库的使用变得更加容易。

# ORMs

[对象关系映射](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping)是一种在面向对象编程语言的类型系统之间转换数据的技术。[为了简化](https://stackoverflow.com/questions/1279613/what-is-an-orm-how-does-it-work-and-how-should-i-use-one)，它是一种将类及其数据转换成可供其他程序使用的数据的技术。不过，一般来说，当有人提到“一个 ORM”时，他们讨论的是使用这种技术的库。

ORM 几乎总是与数据库一起使用。ORM 将接受一个类中的对象或一个结构的实例，并在数据库中为其创建一个条目。所以，我们可以只给 ORM 一个我们的`Task`结构的实例，它会为我们在`tasks`表中创建一个条目，而不是要求我们自己写`sql`。

所以，ORM 基本上是一种减少样板代码的方法。我们没有写一堆重复的`sql`代码，而是让 ORM 根据我们的结构和我们留在这些结构中的代码来生成`sql`代码。除此之外，ORM 经常实现一些方法来创建数据库中可用的表。这些被称为“迁移”

基本上，我们的数据库驱动程序让我们能够在数据库上运行`sql`命令。它只是允许与我们的数据库进行交互。ORM 允许我们用自己选择的语言编写，而不是运行`sql`命令来与数据库交互。

按照我们配置 Rocket 的方式，它应该使用异步 ORM。目前 Rust 中最流行的异步 ORM 是 [SeaQL/sea-orm](https://github.com/SeaQL/sea-orm) ，所以这是我们将在代码库上实现的。

首先，修改你的`Cargo.toml`,如下所示:

至此，我们已经安装了`sea-orm`和其他一些我们需要的库，并移除了现在多余的库。现在，我们要做的第一件事是创建我之前提到的那些迁移。我们将使用`sea-orm`在我们的数据库中创建表格，所以我们不必手工完成。

# 迁移

在您的终端中，运行以下命令:

```
cargo install sea-orm-cli
```

这将安装一个[命令行界面(CLI)](https://www.techtarget.com/searchwindowsserver/definition/command-line-interface-CLI) ，因此我们可以在我们的终端上运行某些命令。可以想象，这些命令使得用`sea-orm`做某些事情变得更加容易。使用我们新安装的 CLI，我们将通过运行以下命令来创建保存迁移的目录:

```
sea-orm-cli migrate init
```

在我当前版本的`sea-orm`中，这会产生一个稍微错误的`Cargo.toml`。确保您的`migration`目录中的`Cargo.toml`具有为`sea-orm-migration`启用的`sqlx-postgres`和`runtime-tokio-native-tls`特性，并且按照如下方式导入`async-std`和 Rocket(`async-std`的导入是以`[dependencies.async-std]`开始的代码块)。

现在，我们将通过运行以下命令来创建新的迁移:

```
sea-orm-cli migrate generate create_tasks_table
```

现在，如果你转到`migration/src`，你会看到一个以`m`开头的文件，有一些数字，结尾有`create_tasks_table`。对我来说，它以`m20220623_084419_create_tasks_table`结束，但这个数字取决于时间，所以对你来说会有所不同。不管怎样，打开那个文件。现在，将以下代码放入该文件。

注意:在`impl MigrationName...`下，保持字符串与文件名相同。这不应该是我的名字。

删除前面有数字的另一个文件并修改`lib.rs`,这样它只使用您的迁移:

接下来，确保`migration/src`中的`main.rs`如下所示:

现在，在终端运行时

```
cargo new entity
```

将`entity`的`Cargo.toml`修改如下:

注意`[lib]`下面的`name`和`path`值是默认值。但是这些只是放在那里以防缺省值改变。我们真正需要的是`[lib]`来声明 Cargo 有一个库目标。

将`entity/src/main.rs`重命名为`lib.rs`。我们将确保用一些可以导入的代码来替换它。

在我们最初的`src`，`sea-orm`将会取代我们之前在例子中使用的数据库驱动。它在很大程度上是相同的数据库驱动程序，但是它有一些额外的特性和其他特殊的东西来使它与`sea-orm`一起工作。

目前，我们只是将允许我们连接到数据库的代码视为不需要理解的样板文件。我们将把这个样板文件放到它自己的文件中，然后将需要的部分导入到`main.rs`中。因此，在`src`中，用下面的代码创建一个名为`pool.rs`的新文件:

现在，我们将更改我们的主要功能，以连接到我们更新、更好的数据库，并运行我们正在创建的迁移。因此，进入`main.rs`并改变`rocket`功能，如下所示:

现在，这样做很痛苦，但是`main.rs`中的这些代码都不再有目的了，所以我们要删除它。删除`Task`结构、`TaskItem`结构、`TaskId`结构、`TodoDatabase`结构、`DatabaseError`结构、`Database Error`、`add_task`、`read_tasks`、`edit_task`和`delete_task`的两个实现。当该说的都说了，该做的都做了，我们的`main.rs`又几乎焕然一新了。

现在，在 Postgres 中，登录到`todo`数据库，用下面的命令删除预先存在的`tasks`表:

```
DROP TABLE tasks;
```

所有这些都完成后，您可以再次在终端中运行`cargo run`，它将使用我们的迁移来创建一个`tasks`表。它还将创建一个名为`seaql_migrations`的表，该表将跟踪我们的迁移信息。

# 实体

实体是我们用来从数据库中提取数据和将数据放入数据库的奇特结构。使用 SeaORM，可以选择在运行迁移后从数据库中生成实体。但是通常最好只运行一次，并且手工编写大部分实体。

主要是因为我们将编辑这些实体，以便在我们的项目中更好地工作，并且运行实体生成命令会覆盖我们所做的更改。因此，我只是给你我们制作的实体的代码，但是请记住，如果你发现有必要或者有很好的用途，你可以从现有的数据库中生成实体。

因此，在`entity/src`中创建一个名为`tasks.rs`的文件，并输入以下代码:

顺便说一下，您可能注意到我们的`id`字段应用了属性`#[field(default = 0)]`。这使得在处理我们的数据时，如果没有给定值，`id`将默认为 0，因此可以输入没有`id`的`Task` s。

这样一来，在`entity/src`中创建一个名为`lib.rs`的文件，并在其中输入以下代码:

```
pub mod tasks;
```

这将允许在任何导入`entity`库箱的包中使用`tasks.rs`中的`Model`结构(用这段代码创建一个名为`entity`的文件夹允许我们在本地创建一个名为`entity`的库)。如果你想了解更多关于 Rust 如何处理文件和项目间共享代码的信息，请查看 Rust 书籍的第 7 章，其中有一些很好的细节)。

因此，就我们的代码而言，我们现在可以使用导出的`tasks`模型作为获取输入数据的结构。注意，模型实现了`FromForm`，所以我们现在将输入数据为`x-www-form-urlencoded`而不是 JSON。考虑到我们的基本参数数量很少，这个切换很有意义。

此外，在 Rocket 中，默认情况下表单解析是宽松的，所以如果有缺失、重复或额外的字段，它仍然会解析。考虑到我们有些地方可能得到一个`id`，但是没有条目，一个条目，但是没有 id，或者两者都有，这将减少我们以前必须编写的额外代码。

无论如何，让我们通过 ORM 重新实现我们所有的 CRUD 操作。您会注意到，我主要使用模型在数据库中查找条目，并使用模型的结构将我整理的条目添加到数据库中。这就是 ORM 的力量。我现在不用写`sql`；我可以用 Rust 写出函数。

所以，让我们开始吧！首先是重写创建操作。下面是代码:

如您所见，我们再次使用了`DatabaseError`作为来自数据库的实际错误的包装器，这样我们就可以返回这些错误。在`add_task`中，`into_inner`函数从我们拥有的变量中提取我们想要的数据。

最后，在 SeaORM 中，要使用一个模型来更新或创建一个项目，它需要是一个`ActiveModel`，所以我们必须使用我们已经拥有的数据来创建一个`ActiveModel`版本。最后，最后一行当然是将商品插入数据库。

接下来是更简单的读取操作。我已经包含了这个函数中使用的一个变量的导入，因为它是一个命名的导入，否则您将无法正确地导入它。

这个也很简单。使用数据库查找所有任务，并按 id 升序排列。

接下来，`edit_task`有点复杂，但仍然很简单。我们找到我们试图更新的任务，`task_to_update`，修改我们想要的字段，然后调用`update`来更新数据库。

最后，`delete_task`是唯一一个稍微改变了 API 的。由于我从 SeaORM 只得到一个`[DeleteResult](https://docs.rs/sea-orm/latest/sea_orm/struct.DeleteResult.html)`，我现在只返回删除了多少任务，而不是删除的任务。

此外，因为我不能确保任务表单中给出了一个`id`，并且我接受的唯一值是一个`id`，所以我将`id`作为 URL 的一个参数，在这种情况下效果很好。因此，它看起来不同，但基本上做同样的事情。

因此，整体的`main.rs`看起来是这样的:

因此，我们再次实现了 CRUD 操作，这一次使用了 ORM。然而，我们在代码库中添加了很多代码，并且在`main.rs`中只保存了大约三行。让我们谈谈那个。

# 过度设计一个问题

对于任何软件问题，我们可以增加复杂性来增加灵活性。换句话说，我们可以添加更多的代码，使我们的解决方案变得更加复杂，这样就更容易改变我们解决方案的某些方面，或者向它添加新的特性。

通常，我们希望我们的代码有一定的灵活性。由于编程是迭代的，几乎可以肯定有人会看到你写的东西，并决定对它进行修改或添加新功能。如果你的代码是灵活的，无论开发人员要做什么，都会容易得多。

然而，复杂性的增加使得理解你的代码变得更加困难。此外，解决方案越复杂，就越容易出现错误。很难预料或注意到的小问题或错误。

最重要的是，更复杂的代码更难维护。需要维护的代码越来越多，代码做的事情越来越复杂，需要更加小心地维护，而且，假设这个更复杂的代码使用了更多的函数库函数或特性，那么当某个函数库更新时，它更容易崩溃。

因此，对于任何解决方案，您都必须小心谨慎。一个非常灵活的解决方案也将非常复杂，并且将是一场噩梦，尽管最初的意图是使它更容易使用。另一方面，一个非常简单的解决方案将没有灵活性，因此每当需要添加新功能时，它可能都必须从头开始重新编写。两个极端都不理想。

当您“过度设计”一个问题时，这意味着您已经使您的代码过于灵活，并且，在这个过程中，使它比它应该的要复杂得多。当然，一个解决方案是否真的被过度设计是一个主观看法的问题。这取决于开发者的品味和感受。

但是，就像任何主观的事情一样，在某些情况下大多数人都同意。我相信大多数人都会同意，为我们正在做的项目实现 ORM 是过度工程化的。

ORM 使得创建包含大量关系的大量表格以及处理大型数据库中的数据变得非常容易。当你有几十或几百张桌子时，这是一个工具。在我们的例子中，当我们完成这个应用程序时，我们只有两个表。虽然直接通过`sql`维护它们更困难，但它也需要更少的代码复杂性，并且对于少量的表是可管理的。

那么，我为什么要实现 ORM 呢？正如我在本文开始时所说的，我的目标是展示现代 web 应用程序和框架使用的各种库和概念，以便您可以更好地理解它们。虽然 ORM 对这个应用程序来说不是一个好主意，但它是我想要展示的一个概念，因为 ORM 在后端框架中几乎无处不在。

还会有很多其他事情，解决方案最终会增加很多复杂性，而对应用程序的好处却很少，这是因为我试图展示现代 web 开发中使用的概念，即使不是所有的概念对于我们正在制作的特定应用程序都是完美的。

# 集装箱化

你可能已经注意到了我们当前数据库的一个有趣的问题。事实上，我们必须在我们的机器上安装和设置一个应用程序来使我们的代码工作。当只有一个开发人员在一个项目中工作时，这很好。然而，在多个开发人员可能在这个项目上工作的情况下，这会带来许多挑战。

第一个问题是安装软件是乏味的，没有乐趣，而且经常容易出错。第二，并不是所有的应用程序都能在所有的操作系统上使用。虽然 postgres 可以在 Windows、Mac 和 Linux 上使用，但对于许多软件来说，这种交叉兼容性并不是必然的。

更进一步，让我们假设一个从事这个项目的开发人员想在家里使用 postgres。为多个项目使用相同的 postgres 安装是可能的，但是很麻烦。除此之外，很难确定将软件运行所需的配置分布到哪里。

那是在自述文件上完成的吗？在空闲时作为消息发送？放入文本文件？如果这些配置更新或更改，会发生什么情况？你如何通知人们？最后，本地安装很容易被开发人员机器上运行的其他东西破坏或搞乱。

如果有一种安装 postgres 的方法可以避免所有这些问题，那就太好了。既然我提出来了，你知道有。这些问题的答案是集装箱化。集装箱化是如何工作的？我们不是直接在我们的操作系统上运行应用程序，而是在另一个操作系统上运行应用程序。

通过使操作系统尽可能小，加上做一些其他优化，这可以足够快，并在开发环境中工作良好。更好的是，大多数容器(其中的操作系统和应用程序)可以通过某些文件进行配置。因此，我们可以对 postgres 这样的应用程序的配置进行版本控制。

由于我们希望安装的容器和应用程序的设置由配置文件控制，开发人员不必担心手动安装软件。大多数容器化应用也是跨平台的，这意味着你可以在一个容器中运行通常不跨平台的应用。

除此之外，在大多数容器化应用程序中，你可以拥有任意多的容器，因此如果你愿意，你可以为工作安装 postgres，为家庭安装 postgres。除此之外，当配置改变时，开发者不再需要被通知，容器化软件将只接受改变的配置并应用它们。

最后，由于我们的应用程序运行在一个完全独立的操作系统中，我们不必担心它被我们机器上的其他应用程序搞乱或破坏。

记住所有这些，让我们使用容器使我们的 postgres 安装更容易操作。有各种各样的应用程序提供容器化，但我们将使用 [Docker](https://www.docker.com/) 。近年来，很多人开始不喜欢 Docker 的定价模式，因此，如果你打算在未来使用集装箱化，你可能需要考虑其他选择。但是对于我们的玩具示例来说，Docker 会工作得很好。所以，去网站，创建一个账户，安装 Docker 作为桌面应用。

现在，从这里开始，我们将使用[Postgres——官方形象](https://hub.docker.com/_/postgres)来制作我们的容器。什么是图像？它只是安装了应用程序的操作系统。容器是运行图像的实例。因此，我们将使用一个图像来运行一个上面有 postgres 的容器。

我们将如何运行这个图像？我们将使用命令行工具 [docker/compose](https://github.com/docker/compose) ，它与 docker 的桌面安装一起安装。`docker-compose`获取一个名为`docker-compose.yml`的文件，并使用它来决定运行什么映像以及使用什么配置。

顺便说一下，作为一个注意，`Dockerfile` s 可以用来修改现有的图像，让您建立自己的图像，更好地满足您的目的。幸运的是，我们可以只使用基本 postgres 映像，但是`Dockerfile`在开发环境中经常使用，所以我认为应该提到它。

无论如何，我们将在与`Cargo.toml`相同的目录下创建一个名为`docker-compose.yml`的文件。在它里面将会有下面的代码:

现在，如果您转到`todo-app`目录，并运行`docker-compose up`，您的数据库将会启动。随着数据库的运行，您可以打开另一个终端并运行您的应用程序。但是，还有一个问题。

因为 postgres 安装在您的机器上，所以它一直在运行一个使用`port 5432`的服务。因此，当我们访问`port 5432`时，我们将访问我们的本地应用，而不是容器中的应用。

关闭或卸载 postgres 安装，以便连接到容器化的数据库。一旦你这样做了，你会发现什么都没有改变，数据库还是一样的工作。只是现在配置和使用更容易了。

# 我们需要`docker-compose`吗？

不，我们没有。我们可以通过命令行或桌面应用程序使用适当的设置运行映像。但是，使用`docker-compose`允许我们留下一个有用的配置文件，它详细描述了用于使我们的应用程序工作的所有配置。而且，如果我们希望我们的应用程序运行多个容器，我们可以在`docker-compose.yml`中列出所有容器的配置。

我自己从来没有这样做过，但是你也可以使用`[Dockerfile](https://docs.docker.com/engine/reference/builder/)` [的](https://docs.docker.com/engine/reference/builder/)功能来配置你的图像。因此，如果您出于某种奇怪的原因想要使用`docker-compose`，这可能是一种选择。在任何情况下，使用 Docker 都有很多方法，但我相信这种方法可以最大限度地发挥容器化应用程序的优势，因此我们在本系列中使用它。

无论如何，这就是我今天的全部内容。在下一部分中，我们将采用我们当前的应用程序，并解决它目前存在的许多问题，如错误处理能力差和前端不存在。

感谢您阅读这篇文章。我希望这个系列能够继续帮助您提高 web 开发技能。

# 资源

*   【rust-lang.org】Rust 编程语言(T4)
*   [本系列的 GitHub 库](https://github.com/garrettudstrand/rust-web-app/tree/main)
*   [对象-关系映射-维基百科](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping)
*   [数据库——什么是 ORM，它是如何工作的，我应该如何使用它？—堆栈溢出](https://stackoverflow.com/questions/1279613/what-is-an-orm-how-does-it-work-and-how-should-i-use-one)
*   [SeaQL/sea-orm:🐚一个针对 Rust(github.com)的异步&动态 ORM](https://github.com/SeaQL/sea-orm)
*   什么是命令行界面(CLI)？(techtarget.com)
*   [用包、板条箱和模块管理成长中的项目 Rust 编程语言(rust-lang.org)](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html)
*   [删除 sea _ ORM-Rust(docs . RS)中的结果](https://docs.rs/sea-orm/latest/sea_orm/struct.DeleteResult.html)
*   国内码头工人
*   [Postgres —官方图片| Docker Hub](https://hub.docker.com/_/postgres)
*   [docker/compose:使用 Docker(github.com)定义和运行多容器应用程序](https://github.com/docker/compose)
*   [Docker 文件参考| Docker 文档](https://docs.docker.com/engine/reference/builder/)